st->ustrRealm);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: DecodeUnicodeString    error 0x%x\n", Status));
            goto CleanUp;
        }

        Status = DecodeUnicodeString(&(pDigest->refstrParam[MD5_AUTH_URI]),
                                     CP_UTF8,
                                     &pDigest->ustrUri);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: DecodeUnicodeString    error 0x%x\n", Status));
            goto CleanUp;
        }

    }
    else if (pDigest->typeCharset == ISO_8859_1)
    {
        DebugLog((DEB_TRACE, "DigestDecodeDirectiveStrings:      ISO-8859-1 Character set decoding\n"));

        Status = DecodeUnicodeString(&(pDigest->refstrParam[MD5_AUTH_USERNAME]),
                                     CP_8859_1,
                                     &pDigest->ustrUsername);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: DecodeUnicodeString  Username  error 0x%x\n", Status));
            goto CleanUp;
        }

        Status = DecodeUnicodeString(&(pDigest->refstrParam[MD5_AUTH_REALM]),
                                     CP_8859_1,
                                     &pDigest->ustrRealm);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: DecodeUnicodeString  Realm  error 0x%x\n", Status));
            goto CleanUp;
        }

        Status = DecodeUnicodeString(&(pDigest->refstrParam[MD5_AUTH_URI]),
                                     CP_8859_1,
                                     &pDigest->ustrUri);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: DecodeUnicodeString    error 0x%x\n", Status));
            goto CleanUp;
        }

    }
    else
    {
        Status = STATUS_UNMAPPABLE_CHARACTER;
        DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: Unknown CharacterSet encoding for Digest parameters\n"));
        goto CleanUp;
    }


    DebugLog((DEB_TRACE, "DigestDecodeDirectiveStrings: Processing username (%wZ)  realm (%wZ)  URI (%wZ)\n",
               &pDigest->ustrUsername,
               &pDigest->ustrRealm,
               &pDigest->ustrUri));

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestDecodeStrings Leaving\n"));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestInit
//
//  Synopsis:   Initialize a DIGEST_PARAMETER structure
//
//  Effects:
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  This should be called when creating a DIGEST_PARAMTER object
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestInit(
          IN PDIGEST_PARAMETER pDigest
          )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!pDigest)
    {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(pDigest, sizeof(DIGEST_PARAMETER));
    
         // Now allocate the fixed length output buffers
    Status = StringAllocate(&(pDigest->strResponse), MD5_HASH_HEX_SIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "NTDigest:DigestCalculation No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        return(Status);
    }

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestCalcChalRsp
//
//  Synopsis:   Perform Digest Access Calculation for ChallengeResponse
//
//  Effects: 
//
//  Arguments:  pDigest - pointer to digest access data fields
//              bIsChallenge - if TRUE then check Response provided (for HTTP Response)
//                           - if FALSE then calculate Response (for HTTP Request)

//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  Called from DigestCalculation
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestCalcChalRsp(IN PDIGEST_PARAMETER pDigest,
                  IN PUSER_CREDENTIALS pUserCreds,
                  BOOL IsChallenge)
{
    NTSTATUS Status = E_FAIL;
    STRING strHA2;
    STRING strReqDigest;    // Final request digest access value
    STRING strcQOP;         // String pointing to a constant CZ - no need to free up
    int i = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestCalcChalRsp: Entering\n"));

    ZeroMemory(&strHA2, sizeof(strHA2));
    ZeroMemory(&strReqDigest, sizeof(strReqDigest));
    ZeroMemory(&strcQOP, sizeof(strcQOP));

    // Make sure that there is a Request-Digest to Compare to (IsChallenge TRUE) or
    // Set (IsChallenge FALSE)
    if (IsChallenge && (!(pDigest->refstrParam[MD5_AUTH_RESPONSE].Length)))
    {
        // Failed on a require field-value
        DebugLog((DEB_ERROR, "DigestCalcChalRsp: No ChallengeResponse\n"));
        Status = STATUS_INVALID_PARAMETER;
        return(Status);
    }

    // Initialize local variables
    Status = StringAllocate(&strHA2, MD5_HASH_HEX_SIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalcChalRsp: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }
    Status = StringAllocate(&strReqDigest, MD5_HASH_HEX_SIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalcChalRsp: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }


    // Establish which QOP utilized
    if (pDigest->typeQOP == AUTH_CONF)
    {
        RtlInitString(&strcQOP, AUTHCONFSTR);
    }
    else if (pDigest->typeQOP == AUTH_INT)
    {
        RtlInitString(&strcQOP, AUTHINTSTR);
    }
    else if (pDigest->typeQOP == AUTH)
    {
        RtlInitString(&strcQOP, AUTHSTR);
    }

    // Check if already calculated H(A1) the session key
    // Well for Algorithm=MD5 it is just H(username:realm:passwd)
    if (!(pDigest->strSessionKey.Length))
    {
        // No Session Key calculated yet - create one & store it
        DebugLog((DEB_TRACE, "DigestCalcChalRsp: No session key calculated, generate one\n"));
        Status = DigestCalcHA1(pDigest, pUserCreds);
        if (!NT_SUCCESS(Status))
        {
            goto CleanUp;
        }
    }
    // We now have calculated H(A1)

    // Calculate H(A2)
    // For QOP unspecified or "auth"  H(A2) = H( Method: URI)
    // For QOP Auth-int or Auth-conf  H(A2) = H( Method: URI: H(entity-body))
    if ((pDigest->typeQOP == AUTH) || (pDigest->typeQOP == NO_QOP_SPECIFIED))
    {
        // Unspecified or Auth
        DebugLog((DEB_TRACE, "DigestCalcChalRsp: H(A2) using AUTH/Unspecified\n"));
        Status = DigestHash7(&(pDigest->refstrParam[MD5_AUTH_METHOD]),
                             &(pDigest->refstrParam[MD5_AUTH_URI]),
                             NULL, NULL, NULL, NULL, NULL,
                             TRUE, &strHA2);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp H(A2) failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        // Auth-int or Auth-conf
        DebugLog((DEB_TRACE, "DigestCalcChalRsp: H(A2) using AUTH-INT/CONF\n"));
        if (pDigest->refstrParam[MD5_AUTH_HENTITY].Length == 0)
        {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog((DEB_ERROR, "DigestCalChalRsp HEntity Missing\n"));
            goto CleanUp;
        }
        Status = DigestHash7(&(pDigest->refstrParam[MD5_AUTH_METHOD]),
                             &(pDigest->refstrParam[MD5_AUTH_URI]),
                             &(pDigest->refstrParam[MD5_AUTH_HENTITY]),
                             NULL, NULL, NULL, NULL,
                             TRUE, &strHA2);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp H(A2) auth-int failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    // We now have calculated H(A2)


    // Calculate Request-Digest
    // For QOP of Auth, Auth-int, Auth-conf    Req-Digest = H( H(A1): nonce: nc: cnonce: qop: H(A2))
    // For QOP unspecified (old format)   Req-Digest = H( H(A1): nonce: H(A2))
    if (pDigest->typeQOP != NO_QOP_SPECIFIED)
    {
        // Auth, Auth-int, Auth-conf
        if (pDigest->refstrParam[MD5_AUTH_NC].Length == 0)
        {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog((DEB_ERROR, "DigestCalcChalRsp NC Missing\n"));
            goto CleanUp;
        }
        Status = DigestHash7(&(pDigest->strSessionKey),
                             &(pDigest->refstrParam[MD5_AUTH_NONCE]),
                             &(pDigest->refstrParam[MD5_AUTH_NC]),
                             &(pDigest->refstrParam[MD5_AUTH_CNONCE]),
                             &strcQOP,
                             &strHA2, NULL,
                             TRUE, &strReqDigest);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp Req-Digest failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        // Unspecified backwards compat for RFC 2069
        Status = DigestHash7(&(pDigest->strSessionKey),
                             &(pDigest->refstrParam[MD5_AUTH_NONCE]),
                             &strHA2,
                             NULL, NULL, NULL, NULL,
                             TRUE, &strReqDigest);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp Req-Digest old format failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }

    if (IsChallenge)
    {
        // We now have the Request-Digest so just compare to see if they match!
        if (!strncmp(pDigest->refstrParam[MD5_AUTH_RESPONSE].Buffer, strReqDigest.Buffer, 2*MD5_HASH_BYTESIZE))
        {
            DebugLog((DEB_TRACE, "DigestCalcChalRsp Request-Digest Matches!\n"));
            Status = STATUS_SUCCESS;
        }
        else
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp Request-Digest FAILED.\n"));
            Status = STATUS_WRONG_PASSWORD;
        }

    }
    else
    {

        // We are to calculate the response-value so just set it  (Hash Size + NULL)
        if (pDigest->strResponse.MaximumLength >= (MD5_HASH_HEX_SIZE + 1))
        {
            memcpy(pDigest->strResponse.Buffer, strReqDigest.Buffer, (MD5_HASH_HEX_SIZE + 1));
            pDigest->strResponse.Length = MD5_HASH_HEX_SIZE;  // No Count NULL
            Status = STATUS_SUCCESS;
        }
        else
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp Request-Digest Size too small.\n"));
            Status = STATUS_BUFFER_TOO_SMALL;
        }
    }

CleanUp:
    StringFree(&strHA2);
    StringFree(&strReqDigest);
    DebugLog((DEB_TRACE_FUNC, "DigestCalcChalRsp: Leaving   Status 0x%x\n", Status));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestCalcHA1
//
//  Synopsis:   Determine H(A1) for Digest Access
//
//  Effects:    Will calculate the SessionKey and store it in pDigest
//
//  Arguments:  pDigest - pointer to digest access data fields

//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  Called from DigestCalChalRsp
//      Sessionkey is H(A1)
//   Username and realm will be taken from the UserCreds
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestCalcHA1(IN PDIGEST_PARAMETER pDigest,
              IN PUSER_CREDENTIALS pUserCreds)
{
    NTSTATUS Status = E_FAIL;

    UNICODE_STRING ustrTempPasswd = {0};

    STRING strHPwKey = {0};
    STRING strBinaryHPwKey = {0};
    STRING strHA0Base = {0};
    STRING strHA0 = {0};
    STRING strPasswd = {0};
    STRING strUsername = {0};
    STRING strRealm = {0};
    PSTRING pstrAuthzID = NULL;
    LONG rc = 0;
    ULONG ulVersion = 0;
    BOOL fDefChars = FALSE;
    USHORT usHashOffset = 0;
    BOOL fSASLMode = FALSE;
    BOOL fValidHash = FALSE;
    int i = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestCalcHA1: Entering\n"));

    ASSERT(pDigest);
    ASSERT(pUserCreds);

    if (!pUserCreds)
    {
        // No username & domain passed in
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestCalcHA1: No username info passed in\n"));
        goto CleanUp;
    }

    if ((pDigest->typeDigest == SASL_SERVER) || (pDigest->typeDigest == SASL_CLIENT))
    {
        fSASLMode = TRUE;
    }

    // Initialize local variables
    Status = StringAllocate(&strBinaryHPwKey, MD5_HASH_BYTESIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }
    Status = StringAllocate(&strHA0Base, MD5_HASH_HEX_SIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }
    Status = StringAllocate(&strHA0, MD5_HASH_HEX_SIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }

    // Check outputs
    if (pDigest->strSessionKey.MaximumLength <= MD5_HASH_HEX_SIZE)
    {
        StringFree(&(pDigest->strSessionKey));
        Status = StringAllocate(&(pDigest->strSessionKey), MD5_HASH_HEX_SIZE);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }

    if ((pUserCreds->fIsValidDigestHash == TRUE) && (pUserCreds->wHashSelected > 0))
    {
        // selected pre-calculated hash - retrieve from userCreds
        // read in precalc version number
        if (pUserCreds->strDigestHash.Length < MD5_HASH_BYTESIZE)
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1: No Header on Precalc hash\n"));
            Status = SEC_E_NO_CREDENTIALS;
            goto CleanUp;
        }

        // check if valid hash number
        usHashOffset = pUserCreds->wHashSelected * MD5_HASH_BYTESIZE;
        if (pUserCreds->strDigestHash.Length < (usHashOffset + MD5_HASH_BYTESIZE))
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1: Invalid Pre-calc\n"));
            Status = SEC_E_NO_CREDENTIALS;
            goto CleanUp;
        }

        // extract pre-calc hash - this is the binary version of the hash
        memcpy(strBinaryHPwKey.Buffer,
               (pUserCreds->strDigestHash.Buffer + usHashOffset),
               MD5_HASH_BYTESIZE);
        strBinaryHPwKey.Length = MD5_HASH_BYTESIZE;

        // all zero for hash indicates invalid hash calculated
        for (i=0; i < (int)strBinaryHPwKey.Length; i++)
        {
            if (strBinaryHPwKey.Buffer[i])
            {
                fValidHash = TRUE;
                break;
            }
        }

        if (fValidHash == FALSE)
        {
            // This is not a defined hash
            DebugLog((DEB_ERROR, "DigestCalcHA1: Invalid hash selected - not defined\n"));
            Status = SEC_E_NO_CREDENTIALS;
            goto CleanUp;
        }

        if (fSASLMode == TRUE)
        {
            // SASL mode keeps the Password hash in binary form
            Status = StringDuplicate(&strHPwKey, &strBinaryHPwKey);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
        }
        else
        {
            Status = StringAllocate(&strHPwKey, MD5_HASH_HEX_SIZE);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            // HTTP mode needs to have HEX() version of password hash - RFC text is correct
            BinToHex((LPBYTE)strBinaryHPwKey.Buffer, MD5_HASH_BYTESIZE, strHPwKey.Buffer);
            strHPwKey.Length = MD5_HASH_HEX_SIZE;             // Do not count the NULL at the end
        }
#if DBG
        if (fSASLMode == TRUE)
        {
            STRING strTempPwKey;
            ZeroMemory(&strTempPwKey, sizeof(strTempPwKey));
    
            MyPrintBytes(strHPwKey.Buffer, strHPwKey.Length, &strTempPwKey);
            DebugLog((DEB_TRACE, "DigestCalcHA1: SASL Pre-Calc H(%wZ:%wZ:************) is %Z\n",
                      &pUserCreds->ustrUsername, &pUserCreds->ustrDomain, &strTempPwKey));
    
            StringFree(&strTempPwKey);
        }
        else
        {
            DebugLog((DEB_TRACE, "DigestCalcHA1: HTTP Pre-Calc H(%wZ:%wZ:************) is %Z\n",
                      &pUserCreds->ustrUsername, &pUserCreds->ustrDomain, &strHPwKey));
        }
#endif
    }
    else if (pUserCreds->fIsValidPasswd == TRUE)
    {
        // copy over the passwd and decrypt if necessary
        Status = UnicodeStringDuplicatePassword(&ustrTempPasswd, &(pUserCreds->ustrPasswd));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1: Error in dup password, status 0x%0x\n", Status ));
            goto CleanUp;
        }

        if ((pUserCreds->fIsEncryptedPasswd == TRUE) && (ustrTempPasswd.MaximumLength != 0))
        {
            g_LsaFunctions->LsaUnprotectMemory(ustrTempPasswd.Buffer, (ULONG)(ustrTempPasswd.MaximumLength));
        }


        // Need to encode the password for hash calculations
        // We have the cleartext password in ustrTempPasswd,
        //       username in pContext->ustrAccountname,
        //       realm in pContext->ustrDomain
        //   Could do some code size optimization here in the future to shorten this up
        if (pDigest->typeCharset == UTF_8)
        {
            // First check if OK to encode in ISO 8859-1, if not then use UTF-8
            // All characters must be within ISO 8859-1 Character set else fail
            fDefChars = FALSE;
            Status = EncodeUnicodeString(&pUserCreds->ustrUsername, CP_8859_1, &strUsername, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding username\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_TRACE, "DigestCalcHA1: Can not encode Username in 8859-1, use UTF-8\n"));
                StringFree(&strUsername);
                Status = EncodeUnicodeString(&pUserCreds->ustrUsername, CP_UTF8, &strUsername, NULL);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding username\n"));
                    Status = SEC_E_INSUFFICIENT_MEMORY;
                    goto CleanUp;
                }
            }

            fDefChars = FALSE;
            Status = EncodeUnicodeString(&pUserCreds->ustrDomain, CP_8859_1, &strRealm, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding realm\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_TRACE, "DigestCalcHA1: Can not encode realm in 8859-1, use UTF-8\n"));
                StringFree(&strRealm);
                Status = EncodeUnicodeString(&pUserCreds->ustrDomain, CP_UTF8, &strRealm, NULL);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding realm\n"));
                    Status = SEC_E_INSUFFICIENT_MEMORY;
                    goto CleanUp;
                }
            }

            fDefChars = FALSE;
            Status = EncodeUnicodeString(&ustrTempPasswd, CP_8859_1, &strPasswd, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding passwd\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_TRACE, "DigestCalcHA1: Can not encode password in 8859-1, use UTF-8\n"));
                if (strPasswd.Buffer && strPasswd.MaximumLength)
                {
                    ZeroMemory(strPasswd.Buffer, strPasswd.MaximumLength);
                }
                StringFree(&strPasswd);
                Status = EncodeUnicodeString(&ustrTempPasswd, CP_UTF8, &strPasswd, NULL);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding passwd\n"));
                    Status = SEC_E_INSUFFICIENT_MEMORY;
                    goto CleanUp;
                }
            }
        }
        else
        {
            // All characters must be within ISO 8859-1 Character set else fail
            Status = EncodeUnicodeString(&pUserCreds->ustrUsername, CP_8859_1, &strUsername, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding username\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding username in ISO 8859-1\n"));
                Status = STATUS_UNMAPPABLE_CHARACTER;
                goto CleanUp;
            }

            Status = EncodeUnicodeString(&pUserCreds->ustrDomain, CP_8859_1, &strRealm, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding realm\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding realm in ISO 8859-1\n"));
                Status = STATUS_UNMAPPABLE_CHARACTER;
                goto CleanUp;
            }

            Status = EncodeUnicodeString(&ustrTempPasswd, CP_8859_1, &strPasswd, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding passwd\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding passwd in ISO 8859-1\n"));
                Status = STATUS_UNMAPPABLE_CHARACTER;
                goto CleanUp;
            }
            DebugLog((DEB_TRACE, "DigestCalcHA1: Username, Realm, Password encoded in ISO 8859-1\n"));
        }

        if (!strUsername.Length)
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1: Must have non-zero length username\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto CleanUp;
        }

        // Calculate H(A1) based on Algorithm type
        // Auth is not specified or "MD5"
        // Use H(A1Base) = H(username-value:realm-value:passwd)
        if (fSASLMode == TRUE)
        {
            Status = DigestHash7(&strUsername,
                                 &strRealm,
                                 &strPasswd,
                                 NULL, NULL, NULL, NULL,
                                 FALSE, &strHPwKey);
        }
        else
        {

            Status = DigestHash7(&strUsername,
                                 &strRealm,
                                 &strPasswd,
                                 NULL, NULL, NULL, NULL,
                                 TRUE, &strHPwKey);
        }
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1:DigestCalcHA1 H(PwKey) failed : 0x%x\n", Status));
            goto CleanUp;
        }

#if DBG
        if (fSASLMode == TRUE)
        {
            STRING strTempPwKey;
            ZeroMemory(&strTempPwKey, sizeof(strTempPwKey));
    
            MyPrintBytes(strHPwKey.Buffer, strHPwKey.Length, &strTempPwKey);
            DebugLog((DEB_TRACE, "DigestCalcHA1: SASL Password Calc H(%Z:%Z:************) is %Z\n",
                      &strUsername, &strRealm, &strTempPwKey));
    
            StringFree(&strTempPwKey);
        }
        else
        {
            DebugLog((DEB_TRACE, "DigestCalcHA1: HTTP Password Calc H(%Z:%Z:************) is %Z\n",
                      &strUsername, &strRealm, &strHPwKey));
        }
#endif
    }
    else
    {
        Status = SEC_E_NO_CREDENTIALS;
        DebugLog((DEB_ERROR, "DigestCalcHA1: No Pre-calc hash or password\n"));
        goto CleanUp;
    }


    // Check if using SASL then need to add in the AuthzID
    if (fSASLMode == TRUE)
    {
        // Set to use AuthzID otherwise keep the NULL
        // set only if AuthzID contains data
        if ((pDigest->refstrParam[MD5_AUTH_AUTHZID]).Length && 
            (pDigest->refstrParam[MD5_AUTH_AUTHZID]).Buffer)
        {
            pstrAuthzID = &(pDigest->refstrParam[MD5_AUTH_AUTHZID]);
        }
    }

    DebugLog((DEB_TRACE, "DigestCalcHA1:  Algorithm type %d\n", pDigest->typeAlgorithm));

    // Now check if using MD5-SESS.  We need to form
    // H(A1) = H( H(PwKey) : nonce : cnonce [: authzID])
    // otherwise simply set H(A1) = H(PwKey)
    if (pDigest->typeAlgorithm == MD5_SESS)
    {
        DebugLog((DEB_TRACE, "DigestCalcHA1:  First client-server auth\n"));
        Status = DigestHash7(&strHPwKey,
                             &(pDigest->refstrParam[MD5_AUTH_NONCE]),
                             &(pDigest->refstrParam[MD5_AUTH_CNONCE]),
                             pstrAuthzID,
                             NULL, NULL, NULL,
                             TRUE, &(pDigest->strSessionKey));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1:  SessionKey failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {        // Keep SessionKey = H(PwKey) for Algoithm = MD5
       memcpy(pDigest->strSessionKey.Buffer, strHPwKey.Buffer, MD5_HASH_HEX_SIZE);
       pDigest->strSessionKey.Length = MD5_HASH_HEX_SIZE;  // Do not count the NULL terminator
    }

    DebugLog((DEB_TRACE, "DigestCalcHA1:  SessionKey is %Z\n", &(pDigest->strSessionKey)));
    Status = STATUS_SUCCESS;

CleanUp:
    StringFree(&strBinaryHPwKey);
    StringFree(&strHPwKey);
    StringFree(&strHA0Base);
    StringFree(&strHA0);
    if (strPasswd.Buffer && strPasswd.MaximumLength)
    {
        ZeroMemory(strPasswd.Buffer, strPasswd.MaximumLength);
    }
    StringFree(&strPasswd);
    StringFree(&strUsername);
    StringFree(&strRealm);

    if (ustrTempPasswd.Buffer && ustrTempPasswd.MaximumLength)
    {   // Zero out password info just to be safe
        ZeroMemory(ustrTempPasswd.Buffer, ustrTempPasswd.MaximumLength);
    }
    UnicodeStringFree(&ustrTempPasswd);

    DebugLog((DEB_TRACE_FUNC, "DigestCalcHA1: Leaving\n"));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestHash7
//
//  Synopsis:   Hash and Encode 7 STRINGS SOut = Hex(H(S1 S2 S3 S4 S5 S6 S7))
//
//  Effects:   
//
//  Arguments:  pS1,...,pS6 - STRINGS to hash, pS1 must be specified
//              fHexOut - perform a Hex operation on output
//              pSOut - STRING to hold Hex Encoded Hash
//
//  Returns:   STATUS_SUCCESS for normal completion
//
//  Notes:  pSOut->MaximumLength must be atleast (MD5_HASH_BYTESIZE (or MD5_HASH_HEX_SIZE) + sizeof(NULL))
//        Any pS# args which are NULL are skipped
//        if pS# is not NULL
//            Previously checked that pS# is non-zero length strings
//        You most likely want Sx->Length = strlen(Sx) so as not to include NULL
//   This function combines operations like H(S1 S2 S3), H(S1 S2 S3 S4 S5) ....
//   It is assumed that the char ':' is to be included getween Sn and Sn+1
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestHash7(
           IN PSTRING pS1,
           IN PSTRING pS2,
           IN PSTRING pS3,
           IN PSTRING pS4,
           IN PSTRING pS5,
           IN PSTRING pS6,
           IN PSTRING pS7,
           IN BOOL fHexOut,
           OUT PSTRING pSOut)
{

    NTSTATUS Status = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    BYTE bHashData[MD5_HASH_BYTESIZE];
    DWORD cbHashData = MD5_HASH_BYTESIZE;
    USHORT usSizeRequired = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestHash7: Entering \n"));

    ASSERT(pSOut);

    if (fHexOut == TRUE)
    {
        usSizeRequired = MD5_HASH_HEX_SIZE;
    }
    else
    {
        usSizeRequired = MD5_HASH_BYTESIZE;
    }

    // Check if output is proper size or allocate one
    if (!pSOut->Buffer)
    {
        Status = StringAllocate(pSOut, usSizeRequired);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestHash7: No Memory\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }
    else
    {

        if (pSOut->MaximumLength < (usSizeRequired + 1))
        {
            // Output is not large enough to hold Hex(Hash)
            DebugLog((DEB_ERROR, "DigestHash7: Output buffer too small\n"));
            Status = STATUS_BUFFER_TOO_SMALL;
            goto CleanUp;
        }
    }


    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "DigestHash7: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    if (pS1)
    {
        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS1->Buffer,
                             pS1->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }

    if (pS2)
    {

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS2->Buffer,
                             pS2->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }

    if (pS3)
    {
        (void)CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 );

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS3->Buffer,
                             pS3->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }
    if (pS4)
    {

        (void)CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 );

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS4->Buffer,
                             pS4->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }
    if (pS5)
    {

        (void)CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 );

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS5->Buffer,
                             pS5->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }
    if (pS6)
    {

        (void)CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 );

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS6->Buffer,
                             pS6->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }
    if (pS7)
    {

        (void)CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 );

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS7->Buffer,
                             pS7->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             bHashData,
                             &cbHashData,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "DigestHash7: CryptGetHashParam failed : 0x%lx\n", GetLastError()));

        CryptDestroyHash( hHash );
        hHash = NULL;
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    CryptDestroyHash( hHash );
    hHash = NULL;

    ASSERT(cbHashData == MD5_HASH_BYTESIZE);

    if (fHexOut == TRUE)
    {
        BinToHex((LPBYTE)&bHashData, cbHashData, pSOut->Buffer);
        pSOut->Length = MD5_HASH_HEX_SIZE;   // Do not count the NULL at the end
    }
    else
    {
        memcpy(pSOut->Buffer, &bHashData, cbHashData);
        pSOut->Length = MD5_HASH_BYTESIZE;      // Do not count the NULL at the end
    }


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestHash7: Leaving    Status 0x%x\n", Status));

    return(Status);
}


// Blob creation/extraction for GenericPassthrough Messages



//+--------------------------------------------------------------------
//
//  Function:   BlobEncodeRequest
//
//  Synopsis:   Encode the Digest Access Parameters fields into a BYTE Buffer
//
//  Effects:    Creates a Buffer allocation which calling function
//     is responsible to delete with call to BlobFreeRequest()
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:
//
//  Notes:      STATUS_SUCCESS for normal completion
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
BlobEncodeRequest(
    PDIGEST_PARAMETER pDigest,
    OUT BYTE **ppOutBuffer,
    OUT USHORT *cbOutBuffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DebugLog((DEB_TRACE_FUNC, "BlobEncodeRequest: Entering\n"));

    USHORT cbBuffer = 0;
    BYTE *pBuffer = NULL;
    char *pch = NULL;
    PDIGEST_BLOB_REQUEST  pHeader;
    int i = 0;
    USHORT cbValue = 0;

    // Now figure out how many bytes needed to hold field-value NULL terminated
    for (i=0, cbBuffer = 0;i < DIGEST_BLOB_VALUES;i++)
    {
        if (pDigest->refstrParam[i].Buffer && pDigest->refstrParam[i].Length)
        {           // may be able to just count str.length
            cbBuffer += (USHORT)strlencounted(pDigest->refstrParam[i].Buffer, pDigest->refstrParam[i].MaximumLength);
        }
    }
    cbBuffer += (DIGEST_BLOB_VALUES * sizeof(char));       // Account for the separating/terminating NULLs

    // Now add in space for the DSCrackName accountname and domain
    if (pDigest->ustrCrackedAccountName.Buffer && pDigest->ustrCrackedAccountName.Length)
    {
        cbBuffer += (USHORT)(ustrlencounted((const short *)pDigest->ustrCrackedAccountName.Buffer,
                                            pDigest->ustrCrackedAccountName.MaximumLength) * sizeof(WCHAR));
    }

    if (pDigest->ustrCrackedDomain.Buffer && pDigest->ustrCrackedDomain.Length)
    {
        cbBuffer += (USHORT)(ustrlencounted((const short *)pDigest->ustrCrackedDomain.Buffer,
                                            pDigest->ustrCrackedDomain.MaximumLength) * sizeof(WCHAR));
    }
    cbBuffer += (2 * sizeof(WCHAR));       // Account for the separating/terminating NULLs

    cbValue =  cbBuffer + (sizeof(DIGEST_BLOB_REQUEST));     // there will be one extra byte

    if (!(pBuffer = (BYTE *)DigestAllocateMemory(cbValue)))
    {
        DebugLog((DEB_ERROR, "BlobEncodeRequest out of memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "BlobEncodeRequest using %d bytes\n", cbValue));

    *cbOutBuffer = cbValue;    // Return number of bytes we are using for the encoding

    // Zero out memory to autoplace the separating NULLs
    memset(pBuffer, 0, cbValue);

    // Now fill in the information
    pHeader = (PDIGEST_BLOB_REQUEST)pBuffer;
    pHeader->MessageType = VERIFY_DIGEST_MESSAGE;
    pHeader->version = DIGEST_BLOB_VERSION;
    pHeader->digest_type = (USHORT)pDigest->typeDigest;
    pHeader->qop_type = (USHORT)pDigest->typeQOP;
    pHeader->alg_type = (USHORT)pDigest->typeAlgorithm;
    pHeader->charset_type = (USHORT)pDigest->typeCharset;
    pHeader->name_format = (USHORT)pDigest->typeName;             // Format of the username
    pHeader->cbCharValues = cbBuffer;
    pHeader->cbBlobSize = cbValue;   // cbCharValues + charvalues

    // Simply copy over the first DIGEST_BLOB_VALUES that are arranged to be 
    for (i = 0,pch = &(pHeader->cCharValues); i < DIGEST_BLOB_VALUES;i++)
    {
           // Make sure that there is valid data to get length from
        if (pDigest->refstrParam[i].Buffer && pDigest->refstrParam[i].Length)
        {
            cbValue = (USHORT)strlencounted(pDigest->refstrParam[i].Buffer, pDigest->refstrParam[i].MaximumLength);  
            // dont use .length since may include multiple NULLS

            memcpy(pch, pDigest->refstrParam[i].Buffer, cbValue);
        }
        else
            cbValue = 0;
        pch += (cbValue + 1);  // This will leave one NULL at end of field-value
    }


       // Now write out any results from DSCrackName
    if (pDigest->ustrCrackedAccountName.Buffer && pDigest->ustrCrackedAccountName.Length)
    {
        cbValue = (USHORT)(ustrlencounted((const short *)pDigest->ustrCrackedAccountName.Buffer,
                                            pDigest->ustrCrackedAccountName.MaximumLength) * sizeof(WCHAR));  
        memcpy(pch, pDigest->ustrCrackedAccountName.Buffer, cbValue);
    }
    else
    {
        cbValue = 0;
    }
    pch += (cbValue + sizeof(WCHAR));  // This will leave one WCHAR NULL at end of CrackedAccountName

    if (pDigest->ustrCrackedDomain.Buffer && pDigest->ustrCrackedDomain.Length)
    {
        cbValue = (USHORT)(ustrlencounted((const short *)pDigest->ustrCrackedDomain.Buffer,
                                            pDigest->ustrCrackedDomain.MaximumLength) * sizeof(WCHAR));  
        memcpy(pch, pDigest->ustrCrackedDomain.Buffer, cbValue);
    }
    else
    {
        cbValue = 0;
    }
    pch += (cbValue + sizeof(WCHAR));  // This will leave one WCHAR NULL at end of CrackedAccountName

    *ppOutBuffer = pBuffer;    // Pass off memory back to calling routine

    DebugLog((DEB_TRACE, "BlobEncodeRequest: message_type 0x%x, version %d, CharValues %d, BlobSize %d\n",
              pHeader->digest_type, pHeader->version, pHeader->cbCharValues, pHeader->cbBlobSize));

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "BlobEncodeRequest: Leaving   Status 0x%x\n", Status));

    return(Status);
}




//+--------------------------------------------------------------------
//
//  Function:   BlobDecodeRequest
//
//  Synopsis:   Decode the Digest Access Parameters fields from a BYTE Buffer
//
//  Arguments:  pBuffer - pointer to BlobEncodeRequestd buffer as input
//              pDigest - pointer to Digest parameter struct to set STRINGS
//                 to point within pBuffer.  No string memory is allocated
//
//  Returns: NTSTATUS
//
//  Notes: 
//      Currently only processes a single version of the packet.  Check MessageType
//  and version number if new message types are supported on the DC.
//
//---------------------------------------------------------------------

NTSTATUS NTAPI BlobDecodeRequest(
                         IN BYTE *pBuffer,
                         PDIGEST_PARAMETER pDigest
                         )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DIGEST_BLOB_REQUEST Header;
    PDIGEST_BLOB_REQUEST pHeader;
    char *pch = NULL;
    USHORT sLen = 0;
    int i = 0;    // counter
    BOOL  fKnownFormat = FALSE;
    USHORT sMaxRead = 0;
    PWCHAR pusTemp = NULL;
    PWCHAR pusLoc = NULL;
    PUSHORT pusTempLoc = NULL;
    USHORT usCnt = 0;


    DebugLog((DEB_TRACE_FUNC, "BlobDecodeRequest: Entering\n"));

    if (!pBuffer || !pDigest)
    {

        DebugLog((DEB_ERROR, "BlobDecodeRequest: Invalid parameter\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    // Copy over the header for byte alignment
    memcpy((char *)&Header, (char *)pBuffer, sizeof(Header));


    DebugLog((DEB_TRACE, "BlobDecodeRequest: message_type %lu version %d, CharValues %d, BlobSize %d\n",
              Header.MessageType, Header.version, Header.cbCharValues, Header.cbBlobSize));

    // Process the encoded message - use only the known MessageTypes and versions here on the DC
    // This allows for expansion of protocols supported in the future

    if ((Header.MessageType == VERIFY_DIGEST_MESSAGE) && (Header.version == DIGEST_BLOB_VERSION))
    {
        fKnownFormat = TRUE;
        DebugLog((DEB_TRACE, "BlobDecodeRequest: Blob from server known type and version\n"));
    }

    if (!fKnownFormat)
    {
        DebugLog((DEB_ERROR, "BlobDecodeRequest: Not supported MessageType/Version\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    pDigest->typeDigest = (DIGEST_TYPE)Header.digest_type;
    pDigest->typeQOP = (QOP_TYPE)Header.qop_type;
    pDigest->typeAlgorithm = (ALGORITHM_TYPE)Header.alg_type;
    pDigest->typeCharset = (CHARSET_TYPE)Header.charset_type;
    pDigest->typeName = (NAMEFORMAT_TYPE)Header.name_format;

    DebugLog((DEB_TRACE, "BlobDecodeRequest: typeDigest 0x%x, typeQOP %d, typeAlgorithm %d, typeCharset %d NameFormat %d\n",
              pDigest->typeDigest, pDigest->typeQOP, pDigest->typeAlgorithm, pDigest->typeCharset, pDigest->typeName));

    pHeader = (PDIGEST_BLOB_REQUEST)pBuffer;
    pch = &(pHeader->cCharValues);              // strings start on last char of struct
    sMaxRead = Header.cbCharValues;
    for (i = 0; i < DIGEST_BLOB_VALUES;i++)
    {
        sLen = (USHORT)strlencounted(pch, sMaxRead);
        if (!sLen)
        {
            // Null String no value skip to next
            pch++;
            sMaxRead--;
        }
        else
        {     // Simple check to make sure that we do not copy way too much
            if (sLen < (Header.cbCharValues))
            {
                DebugLog((DEB_TRACE, "BlobDecodeRequest: Setting Digest[%d] = %s\n", i, pch));
                pDigest->refstrParam[i].Buffer = pch;
                pDigest->refstrParam[i].Length = sLen;
                pDigest->refstrParam[i].MaximumLength = sLen+1;
                pch += (sLen + 1);   // skip over field-value and NULL
                sMaxRead -= (sLen + 1);
            }
            else
            {
                // This indicates failed NULL separators in BlobData
                // Really should not happen unless encoded wrong
                Status = STATUS_INTERNAL_DB_CORRUPTION;
                memset(pDigest, 0, sizeof(DIGEST_PARAMETER));  // scrubbed all info
                DebugLog((DEB_ERROR, "BlobDecodeRequest: NULL separator missing\n"));
                goto CleanUp;
            }
        }
    }

    if (pDigest->typeName != NAMEFORMAT_UNKNOWN)
    {
        // Read in the values that DSCrackName on the server found out
        // Need to place on SHORT boundary for Unicode string processing

        usCnt = sMaxRead + (2 * sizeof(WCHAR));
        pusTemp = (PWCHAR)DigestAllocateMemory(usCnt);   // Force a NULL terminator just to be safe
        if (!pusTemp)
        {
            Status = STATUS_NO_MEMORY;
            DebugLog((DEB_ERROR, "BlobDecodeRequest: Memory Alloc Error\n"));
            goto CleanUp;
        }

        // Format will be Unicode_account_name NULL Unicode_domain_name NULL [NULL NULL]
        memcpy((PCHAR)pusTemp, pch, sMaxRead); 

        // Read out the two unicode strings
        Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedAccountName), pusTemp);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"BlobDecodeRequest: Failed to duplicate Account Name: 0x%x\n",Status));
            goto CleanUp;
        }

        pusLoc = pusTemp + (1 + (pDigest->ustrCrackedAccountName.Length / sizeof(WCHAR)));  // Skip NULL
        Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedDomain), pusLoc);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"BlobDecodeRequest: Failed to duplicate Domain Name: 0x%x\n",Status));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE,"BlobDecodeRequest: Cracked Account %wZ    Domain %wZ\n",
                  &(pDigest->ustrCrackedAccountName),
                  &(pDigest->ustrCrackedDomain)));
    }

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "Leaving BlobEncodeRequest 0x%x\n", Status));

    if (pusTemp)
    {
        DigestFreeMemory(pusTemp);
        pusTemp = NULL;
    }

    return(Status);
}


// Free BYTE Buffer from BlobEncodeRequest
VOID NTAPI BlobFreeRequest(
    BYTE *pBuffer
    )
{
    if (pBuffer)
    {
        DigestFreeMemory(pBuffer);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\credapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 2000
//
// File:        credapi.cxx
//
// Contents:    Code for credentials APIs for the NtDigest package
//              Main entry points into this dll:
//                SpAcceptCredentials
//                SpAcquireCredentialsHandle
//                SpFreeCredentialsHandle
//                SpQueryCredentialsAttributes
//                SpSaveCredentials
//                SpGetCredentials
//                SpDeleteCredentials
//
//              Helper functions:
//                CopyClientString
//
// History:     ChandanS   26-Jul-1996   Stolen from kerberos\client2\credapi.cxx
//              KDamour    16Mar00       Stolen from NTLM
//
//------------------------------------------------------------------------
#define NTDIGEST_CREDAPI
#include <global.h>

extern BOOL g_bCredentialsInitialized;



//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptCredentials
//
//  Synopsis:   This routine is called after another package has logged
//              a user on.  The other package provides a user name and
//              password and the package will create a logon
//              session for this user.
//
//  Effects:    Creates a logon session
//
//  Arguments:  LogonType - Type of logon, such as network or interactive
//              Accountname - Name of the account that logged on
//              PrimaryCredentials - Primary credentials for the account,
//                  containing a domain name, password, SID, etc.
//              SupplementalCredentials - NtLm -Specific blob not used
//
//  Returns:    None
//
//  Notes:
//
//-------------------------------------------------------------------------- ok
NTSTATUS NTAPI
SpAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_LOGONSESSION pNewLogonSession = NULL;
    UNICODE_STRING  ustrTempPasswd;

    ZeroMemory(&ustrTempPasswd, sizeof(UNICODE_STRING));

    DebugLog((DEB_TRACE_FUNC, "SpAcceptCredentials: Entering\n"));
    DebugLog((DEB_TRACE, "SpAcceptCredentials:    Credential: LogonType %d\n", LogonType));

    if (AccountName)
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:  Entering AccountName %wZ\n",
                AccountName));
    }
    else
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:  No AccountName provided\n"));
    }

    if (PrimaryCredentials)
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:           DomainName\\DownlevelName %wZ\\%wZ\n",
                    &PrimaryCredentials->DomainName,
                    &PrimaryCredentials->DownlevelName));
        DebugLog((DEB_TRACE,"SpAcceptCredentials:           UPN@DnsDomainName %wZ@%wZ\n",
                    &PrimaryCredentials->Upn,
                    &PrimaryCredentials->DnsDomainName));
        DebugLog((DEB_TRACE,"SpAcceptCredentials:           LogonID (%x:%lx)  Flags 0x%x\n",
                    PrimaryCredentials->LogonId.HighPart,
                    PrimaryCredentials->LogonId.LowPart,
                    PrimaryCredentials->Flags));
    }
    else
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:  No PrimaryCredentials provided\n"));
        goto CleanUp;
    }

    if (SupplementalCredentials)
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:           Supplemental Creds  Size %d\n",
                    SupplementalCredentials->CredentialSize));
    }
    else
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:  No Supplemental Credentials provided\n"));
    }

    // If there is no cleartext password then can not do any operations - just leave
    if (!(PrimaryCredentials->Flags & PRIMARY_CRED_CLEAR_PASSWORD)) 
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:  No Primary ClearText Password - no active logon created\n"));
        Status = STATUS_SUCCESS;
        goto CleanUp; 
    }

    //
    // If this is an update, just change the password
    //
    if ((PrimaryCredentials->Flags & PRIMARY_CRED_UPDATE) != 0)
    {
        // Make a copy of the password and encrypt it
        Status = UnicodeStringDuplicatePassword(&ustrTempPasswd, &PrimaryCredentials->Password);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Error in dup password, status 0x%0x\n", Status ));
            goto CleanUp;
        }

        if (ustrTempPasswd.MaximumLength != 0)
        {
            g_LsaFunctions->LsaProtectMemory(ustrTempPasswd.Buffer, (ULONG)(ustrTempPasswd.MaximumLength));
        }

        // Check to see if this LogonId is already in the list and update password
        Status = LogSessHandlerPasswdSet(&PrimaryCredentials->LogonId, &ustrTempPasswd);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Failed to update LogonSession Password\n"));
        }
        else
        {
            DebugLog((DEB_TRACE, "SpAcceptCredentials: Updated Password for LogonSession\n"));
        }
    }
    else
    {
        DebugLog((DEB_TRACE, "SpAcceptCredentials: Create New LogonSession - not an update\n"));

        // This is a new entry into the list so create a LogonSession listing
        pNewLogonSession = (PDIGEST_LOGONSESSION)DigestAllocateMemory(sizeof(DIGEST_LOGONSESSION));
        if (!pNewLogonSession)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Could not allocate memory for logonsession, error 0x%x\n", Status));
            goto CleanUp;
        }
        LogonSessionInit(pNewLogonSession);

        pNewLogonSession->LogonType = LogonType;
        pNewLogonSession->LogonId = PrimaryCredentials->LogonId;
        UnicodeStringDuplicate(&(pNewLogonSession->ustrAccountName), AccountName);
        UnicodeStringDuplicate(&(pNewLogonSession->ustrDomainName), &(PrimaryCredentials->DomainName));
        UnicodeStringDuplicate(&(pNewLogonSession->ustrDownlevelName), &(PrimaryCredentials->DownlevelName));
        UnicodeStringDuplicate(&(pNewLogonSession->ustrDnsDomainName), &(PrimaryCredentials->DnsDomainName));
        UnicodeStringDuplicate(&(pNewLogonSession->ustrUpn), &(PrimaryCredentials->Upn));
        UnicodeStringDuplicate(&(pNewLogonSession->ustrLogonServer), &(PrimaryCredentials->LogonServer));
        Status = UnicodeStringDuplicatePassword(&(pNewLogonSession->ustrPassword), &(PrimaryCredentials->Password));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Error in dup password, status 0x%0x\n", Status ));
            goto CleanUp;
        }

        if (pNewLogonSession->ustrPassword.MaximumLength != 0)
        {
            g_LsaFunctions->LsaProtectMemory(pNewLogonSession->ustrPassword.Buffer,
                                             (ULONG)(pNewLogonSession->ustrPassword.MaximumLength));
        }

        DebugLog((DEB_TRACE, "SpAcceptCredentials: Added new logonsession into list,  handle 0x%x\n", pNewLogonSession));
        LogSessHandlerInsert(pNewLogonSession);
        pNewLogonSession = NULL;                          // Turned over memory to LogSessHandler
    }

CleanUp:

    if (ustrTempPasswd.Buffer && ustrTempPasswd.MaximumLength)
    {   // Zero out password info just to be safe
        ZeroMemory(ustrTempPasswd.Buffer, ustrTempPasswd.MaximumLength);
    }
    UnicodeStringFree(&ustrTempPasswd);

    DebugLog((DEB_TRACE_FUNC, "SpAcceptCredentials:  Leaving status 0x%x\n", Status));

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpAcquireCredentialsHandle
//
//  Synopsis:   Contains Digest Server Code for AcquireCredentialsHandle which
//              creates a Credential associated with a logon session.
//
//  Effects:    Creates a DIGEST_CREDENTIAL
//
//  Arguments:  PrincipalName - Name of logon session for which to create credential
//              CredentialUseFlags - Flags indicating whether the credentials
//                  is for inbound or outbound use.
//              LogonId - The logon ID of logon session for which to create
//                  a credential.
//              AuthorizationData - Optional username, domain, password info
//              GetKeyFunction - Unused function to retrieve a session key
//              GetKeyArgument - Unused Argument for GetKeyFunction
//              CredentialHandle - Receives handle to new credential
//              ExpirationTime - Receives expiration time for credential
//
//  Returns:
//    STATUS_SUCCESS -- Call completed successfully
//    SEC_E_NO_SPM -- Security Support Provider is not running
//    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
//    SEC_E_PRINCIPAL_UNKNOWN -- No such principal
//    SEC_E_NOT_OWNER -- caller does not own the specified credentials
//    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory
//    SEC_E_NOT_SUPPORTED - CredentialUse must be Outbound (Inbound once client code added)
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpAcquireCredentialsHandle(
    IN OPTIONAL PUNICODE_STRING pPrincipalName,
    IN ULONG CredentialUseFlags,
    IN OPTIONAL PLUID pLogonId,
    IN OPTIONAL PVOID pAuthorizationData,
    IN PVOID pGetKeyFunction,
    IN PVOID pGetKeyArgument,
    OUT PULONG_PTR ppCredentialHandle,
    OUT PTimeStamp pExpirationTime
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_CREDENTIAL pTmpCred = NULL;
    PDIGEST_CREDENTIAL pCredential = NULL;
    PDIGEST_LOGONSESSION pLogonSession = NULL;
    PDIGEST_CONTEXT pContext = NULL;                    // for delegation info lookup

    ULONG NewCredentialUseFlags = CredentialUseFlags;

    UNICODE_STRING AuthzUserName;
    UNICODE_STRING AuthzDomainName;
    UNICODE_STRING AuthzPassword;
    UNICODE_STRING ustrTempPasswd;

    SECPKG_CLIENT_INFO ClientInfo;
    SECPKG_CALL_INFO CallInfo;
    PLUID pLogonIdToUse = NULL;
    UNICODE_STRING CapturedPrincipalName = {0};
    ULONG CredentialFlags = 0;
    BOOL bAuthzDataProvided = FALSE;

    DebugLog((DEB_TRACE_FUNC, "SpAcquireCredentialsHandle:  Entering\n"));

    // Initialize structures

    ZeroMemory(&AuthzUserName, sizeof(UNICODE_STRING));
    ZeroMemory(&AuthzDomainName, sizeof(UNICODE_STRING));
    ZeroMemory(&AuthzPassword, sizeof(UNICODE_STRING));
    ZeroMemory(&ustrTempPasswd, sizeof(UNICODE_STRING));

    if (!ppCredentialHandle)
    {
        DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Invalid arg to ACH (possible NULL pointer)\n"));
        return STATUS_INVALID_PARAMETER;
    }

    *ppCredentialHandle = NULL;
    if (pExpirationTime)
    {
        *pExpirationTime = g_TimeForever;    // Never times out credential
        DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Expiration TimeStamp  high/low 0x%x/0x%x\n",
                  pExpirationTime->HighPart, pExpirationTime->LowPart));
    }

    // This should really not happen - just a quick check
    ASSERT(g_bCredentialsInitialized);
    if (!g_bCredentialsInitialized)
    {
        DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle credential manager not initialized\n"));
        return SEC_E_NO_SPM;
    }

    // Allow only INBOUND or OUTBOUND (not DEFAULT or Reserved)
    if ( (CredentialUseFlags & (DIGEST_CRED_OUTBOUND | DIGEST_CRED_INBOUND)) == 0)
    {
        DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Credential flag not supported\n"));
        Status = SEC_E_NOT_SUPPORTED;
        goto CleanUp;
    }

    //
    // First get information about the caller.
    //

    Status = g_LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle: Failed to get client information: 0x%x\n",Status));
        goto CleanUp;
    }

    Status = g_LsaFunctions->GetCallInfo(&CallInfo);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle: Failed to get call information: 0x%x\n",Status));
        goto CleanUp;
    }


    // Check if acting as the server  (Inbound creds)
    if (NewCredentialUseFlags & DIGEST_CRED_INBOUND)
    {
        DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Creating an Inbound Credential\n"));

        // Allocate a credential block and initialize it.
        pTmpCred = (PDIGEST_CREDENTIAL)DigestAllocateMemory(sizeof(DIGEST_CREDENTIAL) );
        if (!pTmpCred)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;      // Out of memory return error
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle Out of Memory\n"));
            goto CleanUp;
        }
        Status = CredentialInit(pTmpCred);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: CredentialInit error 0x%x\n", Status));
            goto CleanUp;
        }

        pTmpCred->CredentialUseFlags = NewCredentialUseFlags;
        memcpy(&(pTmpCred->LogonId), &ClientInfo.LogonId, sizeof(LUID));

        pTmpCred->ClientProcessID = ClientInfo.ProcessID;
        
        //
        // Add it to the list of valid credential handles.
        //

        pTmpCred->lReferences = 1;
        (void)CredPrint(pTmpCred);

        CredHandlerInsertCred(pTmpCred);
        *ppCredentialHandle = (LSA_SEC_HANDLE) pTmpCred;    // link to the output

        DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Added Credential 0x%lx\n", pCredential));

        pTmpCred = NULL;                                    // We do not own this memory anymore
    }
    else
    {       //   Called by a client for Outbound direction

        // Locate the LogonSession to utilize for the credential
        // If the caller is a system process with the SE_TCB_NAME privilege, and the caller provides
        // both the name and logon identifier, the function verifies that they match before returning
        // the credentials. If only one is provided, the function returns a handle to that identifier.

        // A caller that is not a system process can only obtain a handle to the credentials under
        // which it is running. The caller can provide the name or the logon identifier, but it must
        // be for the current session or the request fails.


        DebugLog((DEB_TRACE,"SpAcquireCredentialsHandle: Have Outbound Credential request\n"));
        if (ARGUMENT_PRESENT(pLogonId) && ((pLogonId->LowPart != 0) || (pLogonId->HighPart != 0)))
        {
            // If the LUID of request not equal to Client LUID then must have TCBPrivilege, else rejest request
             if (((pLogonId->LowPart != ClientInfo.LogonId.LowPart) ||
                  (pLogonId->HighPart != ClientInfo.LogonId.HighPart)) &&
                  !ClientInfo.HasTcbPrivilege)
            {
                Status = STATUS_PRIVILEGE_NOT_HELD;
                DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle: LoginID change forbidden\n"));
                goto CleanUp;
            }

            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle:   Using pLogonID luid (%x:%lx)\n",
                     pLogonId->HighPart, pLogonId->LowPart));

            Status = LogSessHandlerLogonIdToPtr(pLogonId, FALSE, &pLogonSession);
            if (!NT_SUCCESS (Status))
            {            // Could not find the LogonID so fail
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: could not find LogonID    status 0x%x\n", Status));
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                goto CleanUp;
            }
            pLogonIdToUse = pLogonId;

            // If Principal name supplied, make sure they match with the loginsession
            if (ARGUMENT_PRESENT(pPrincipalName) && pPrincipalName->Length)
            {
                if (!RtlEqualUnicodeString(pPrincipalName,&(pLogonSession->ustrAccountName),TRUE))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: PrincipalName does not match LogonSession\n"));
                    Status = STATUS_NO_SUCH_LOGON_SESSION;
                    goto CleanUp;
                }
            }
        }
        else if (ARGUMENT_PRESENT(pPrincipalName) && (pPrincipalName->Length))
        {
            // Given only the principal name to lookup
            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: logonsession principal name lookup %wZ\n", pPrincipalName));
            Status = LogSessHandlerAccNameToPtr(pPrincipalName, &pLogonSession);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: principal name not in logon list    error 0x%x\n", Status));
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                goto CleanUp;
            }

            // If make sure we have TCB if logonID are different
            if ((((pLogonSession->LogonId).LowPart != ClientInfo.LogonId.LowPart) ||
                 ((pLogonSession->LogonId).HighPart != ClientInfo.LogonId.HighPart)) &&
                 !ClientInfo.HasTcbPrivilege)
           {
               Status = STATUS_PRIVILEGE_NOT_HELD;
               DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle: PrincipalName selection forbidden, LoginID differs\n"));
               goto CleanUp;
           }

           // pLogonIdToUse = &ClientInfo.LogonId;
           pLogonIdToUse = &(pLogonSession->LogonId);

        }
        else
        {
            // No LoginID or Principal name provided
            // Use the callers logon id.

            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle:   Using callers Logon (%x:%lx)\n",
                    ClientInfo.LogonId.HighPart,
                    ClientInfo.LogonId.LowPart));

            Status = LogSessHandlerLogonIdToPtr(&ClientInfo.LogonId, FALSE,  &pLogonSession);
            if (!NT_SUCCESS (Status))
            {
                // Could not find the LogonID so fail
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: could not find caller's LogonSession   status 0x%x\n", Status));
                goto CleanUp;
            }
            pLogonIdToUse = &ClientInfo.LogonId;
        }

        // We now must have a pLogonSession - this conditional is not needed after testing completed
        if (!pLogonSession)
        {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Must have LogonSession\n"));
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto CleanUp;
        }

        if (pAuthorizationData)
        {
            Status = CredAuthzData(pAuthorizationData,
                                   &CallInfo,
                                   &NewCredentialUseFlags,
                                   &AuthzUserName,
                                   &AuthzDomainName,
                                   &AuthzPassword);

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle: CredAuthzData error in reading authdata status 0x%x\n", Status));
            }
            else
                bAuthzDataProvided = TRUE;
            DebugLog((DEB_TRACE,"SpAcquireCredentialsHandle: AuthData provided Username=%wZ   DomainName=%wZ\n",
                      &AuthzUserName, &AuthzDomainName));
        }

        DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Using LogonSession Handle 0x%lx\n", pLogonSession));
        DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle:       Logon luid (%x:%lx)\n",
                (pLogonSession->LogonId).HighPart,
                (pLogonSession->LogonId).LowPart));

        if (!bAuthzDataProvided)
        {          // If no authz data then see if it matches with a 
            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Check to see if cred exists\n"));
            Status = CredHandlerLocatePtr(pLogonIdToUse, NewCredentialUseFlags, &pCredential);
        }
        else 
            Status = SEC_E_NO_CREDENTIALS;  // passed creds - need to create new context

        if (NT_SUCCESS(Status))
        {
            // We currently have a credential for this ProcessID, LogonId - just make any updates
            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: We currently have existing Credentials at 0x%x\n", pCredential));
            

            Status = LogSessHandlerPasswdGet(pLogonSession, &(ustrTempPasswd));
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Error LogSess get TempPasswd   Status 0x%x\n", Status));
                goto CleanUp;
            }
            Status = CredHandlerPasswdSet(pCredential, &(ustrTempPasswd));
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Errors in Passwd set     Status 0x%x\n", Status));
                goto CleanUp;
            }

            *ppCredentialHandle = (LSA_SEC_HANDLE) pCredential;    // link to the output
            pCredential = NULL;                                    // Reference for this context owned by system
        }
        else
        {
            // We need to create a new Credential
            Status = STATUS_SUCCESS;                            // there is no error right now
            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Creating an Outbound Credential\n"));
            // Allocate a credential block and initialize it.
            pTmpCred = (PDIGEST_CREDENTIAL)DigestAllocateMemory(sizeof(DIGEST_CREDENTIAL) );
            if (!pTmpCred)
            {
                Status = SEC_E_INSUFFICIENT_MEMORY;
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle Out of Memory\n"));
                goto CleanUp;
            }

            Status = CredentialInit(pTmpCred);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: CredentialInit error 0x%x\n", Status));
                goto CleanUp;
            }

            pTmpCred->CredentialUseFlags = NewCredentialUseFlags;
            memcpy(&(pTmpCred->LogonId), &(pLogonSession->LogonId), sizeof(LUID));

            pTmpCred->ClientProcessID = ClientInfo.ProcessID;

            // Copy over the account & password info
            // Some of these might not be utilized in client - may remove as appropriate

            if (!bAuthzDataProvided)
            {
                Status = UnicodeStringDuplicate(&(pTmpCred->ustrAccountName), &(pLogonSession->ustrAccountName));
                if (pLogonSession->ustrDnsDomainName.Length)
                {
                    Status = UnicodeStringDuplicate(&(pTmpCred->ustrDnsDomainName), &(pLogonSession->ustrDnsDomainName));
                }
                else
                {           // No DNSDomainName filled in - use NT's DomainName
                    Status = UnicodeStringDuplicate(&(pTmpCred->ustrDnsDomainName), &(pLogonSession->ustrDomainName));
                }
                Status = UnicodeStringDuplicate(&(pTmpCred->ustrDomainName), &(pLogonSession->ustrDomainName));
                Status = UnicodeStringDuplicate(&(pTmpCred->ustrDownlevelName), &(pLogonSession->ustrDownlevelName));
                Status = UnicodeStringDuplicate(&(pTmpCred->ustrLogonServer), &(pLogonSession->ustrLogonServer));
                Status = UnicodeStringDuplicate(&(pTmpCred->ustrUpn), &(pLogonSession->ustrUpn));
                Status = LogSessHandlerPasswdGet(pLogonSession, &(pTmpCred->ustrPassword));
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Error LogSess get Passwd   Status 0x%x\n", Status));
                    goto CleanUp;
                }
            }
            else
            {
                // Force in the Authz creds provided

                Status = UnicodeStringDuplicate(&(pTmpCred->ustrAccountName), &AuthzUserName);
                Status = UnicodeStringDuplicate(&(pTmpCred->ustrDomainName), &AuthzDomainName);
                Status = UnicodeStringDuplicate(&(pTmpCred->ustrDnsDomainName), &AuthzDomainName);
                Status = UnicodeStringDuplicatePassword(&(pTmpCred->ustrPassword), &AuthzPassword);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Authz string copies error 0x%x\n", Status));
                    goto CleanUp;
                }

                // Since Auth data is cleartext password MUST encrypt since always keep in encrypted format
                if (pTmpCred->ustrPassword.MaximumLength != 0)
                {
                    g_LsaFunctions->LsaProtectMemory(pTmpCred->ustrPassword.Buffer,
                                                     (ULONG)(pTmpCred->ustrPassword.MaximumLength));
                }
            }

            pTmpCred->lReferences = 1;
            (void)CredPrint(pTmpCred);

            // Add it to the list of valid credential handles.
            CredHandlerInsertCred(pTmpCred);
            *ppCredentialHandle = (LSA_SEC_HANDLE) pTmpCred;    // link to the output

            pTmpCred = NULL;                                    // We do not own this memory anymore
            // pLogonSession = NULL;                               // The Cred has ownership of ref count for logonsession

            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Added Credential 0x%lx\n", *ppCredentialHandle));

        }
    }


CleanUp:

    UnicodeStringFree(&AuthzUserName);
    UnicodeStringFree(&AuthzDomainName);
    if (AuthzPassword.Buffer && AuthzPassword.MaximumLength)
    {   // Zero out password info just to be safe
        ZeroMemory(AuthzPassword.Buffer, AuthzPassword.MaximumLength);
    }
    UnicodeStringFree(&AuthzPassword);
    if (ustrTempPasswd.Buffer && ustrTempPasswd.MaximumLength)
    {   // Zero out password info just to be safe
        ZeroMemory(ustrTempPasswd.Buffer, ustrTempPasswd.MaximumLength);
    }
    UnicodeStringFree(&ustrTempPasswd);

    if (pTmpCred)
    {
        CredentialFree(pTmpCred);
        pTmpCred = NULL;
    }
    
    if (pLogonSession)
    {
        LogSessHandlerRelease(pLogonSession);
    }

    if (pCredential)
    {
        CredHandlerRelease(pCredential);
    }

    if (pContext)
    {
        CtxtHandlerRelease(pContext);
    }

    DebugLog((DEB_TRACE_FUNC, "SpAcquireCredentialsHandle:  Leaving    Status  0x%x\n", Status));
    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   SpFreeCredentialsHandle
//
//  Synopsis:   Frees a credential created by AcquireCredentialsHandle.
//
//  Effects:    Dereferences the credential in the global list..
//
//  Arguments:  CredentialHandle - Handle to the credential to free
//              (acquired through AcquireCredentialsHandle)
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              SEC_E_INVALID_HANDLE if the handle is not valid
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpFreeCredentialsHandle(
    IN ULONG_PTR CredentialHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_CREDENTIAL pDigestCred = NULL;

    DebugLog((DEB_TRACE_FUNC, "SpFreeCredentialsHandle: Entering  Handle 0x%x\n", CredentialHandle));

    Status = CredHandlerHandleToPtr(CredentialHandle, TRUE, &pDigestCred);   // unlink from list
    if (!NT_SUCCESS(Status))
    {
        Status = SEC_E_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpFreeCredentialsHandle: Can not find ContextHandle in list   Status 0x%x\n", Status));
        goto CleanUp;
    }
       // Now check if we should release the memory
    ASSERT(pDigestCred);

    DebugLog((DEB_TRACE, "SpFreeCredentialsHandle: FreeCredHandle 0x%x    ReferenceCount is %d\n",
              pDigestCred, pDigestCred->lReferences));

    // Dereference the credential, it will also unlink from list if necessary
    Status = CredHandlerRelease(pDigestCred);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpFreeCredentialsHandle: Error in Releasing Credential  Status 0x%x\n", Status));
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SpFreeCredentialsHandle: Leaving  Handle 0x%x    Status 0x%x\n", CredentialHandle, Status));

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryCredentialsAttributes
//
//  Synopsis:   retrieves the attributes of a credential, such as the name associated with the credential.
//
//  Effects:    Dereferences the credential in the global list..
//
//  Arguments:  CredentialHandle - Handle of the credentials to be queried
//              CredentialAttribute - Specifies the attribute to query. This parameter can be any of the following attributes
//                                  SECPKG_CRED_ATTR_NAMES 
//                                  SECPKG_ATTR_SUPPORTED_ALGS 
//                                  SECPKG_ATTR_CIPHER_STRENGTHS 
//                                  SECPKG_ATTR_SUPPORTED_PROTOCOLS
//              Buffer - Pointer to a buffer that receives the requested attribute
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              SEC_E_INVALID_HANDLE if the handle is not valid
//
//  Notes:
//   The caller must allocate the structure pointed to by the pBuffer parameter.
//   The security package allocates the buffer for any pointer returned in the pBuffer structure
//   The caller can call the FreeContextBuffer function to free any pointers allocated by the security package.
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpQueryCredentialsAttributes(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN ULONG CredentialAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS TempStatus = STATUS_SUCCESS;
    PDIGEST_CREDENTIAL pDigestCred = NULL;
    SECPKG_CALL_INFO CallInfo;
    SecPkgCredentials_NamesW Names;

    LPWSTR ContextNames = NULL;
    LPWSTR Where = NULL;

    DWORD cchUserName = 0;
    DWORD cchDomainName = 0;
    ULONG Length = 0;


    DebugLog((DEB_TRACE_FUNC, "SpQueryCredentialsAttributes: Entering  Handle 0x%x\n", CredentialHandle));

    Names.sUserName = NULL;

    Status = g_LsaFunctions->GetCallInfo(&CallInfo);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"SpQueryCredentialsAttributes: Failed to get call information: 0x%x\n",Status));
        goto CleanUp;
    }


    if (CredentialAttribute != SECPKG_CRED_ATTR_NAMES)
    {
        DebugLog((DEB_WARN, "SpQueryCredentialsAttributes: Invalid Request Attribute %d\n", CredentialAttribute));
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        goto CleanUp;
    }


    Status = CredHandlerHandleToPtr(CredentialHandle, FALSE, &pDigestCred);   // unlink from list
    if (!NT_SUCCESS(Status))
    {
        Status = SEC_E_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: Can not find ContextHandle in list   Status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // specified creds.
    //

    Length = pDigestCred->ustrAccountName.Length + pDigestCred->ustrDomainName.Length + (2 * sizeof(WCHAR));

    ContextNames = (LPWSTR)DigestAllocateMemory( Length );
    if( ContextNames == NULL ) {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: Internal Allocate failed   Status 0x%x\n", Status));
        goto CleanUp;
    }

    Where = ContextNames;

    if(pDigestCred->ustrDomainName.Length) {
        RtlCopyMemory( ContextNames, pDigestCred->ustrDomainName.Buffer, pDigestCred->ustrDomainName.Length);
        cchDomainName = pDigestCred->ustrDomainName.Length / sizeof(WCHAR);
        ContextNames[ cchDomainName ] = L'\\';
        Where += (cchDomainName+1);
    }


    if(pDigestCred->ustrAccountName.Length) {
        RtlCopyMemory( Where, pDigestCred->ustrAccountName.Buffer, pDigestCred->ustrAccountName.Length);
    }

    cchUserName = pDigestCred->ustrAccountName.Length / sizeof(WCHAR);
    Where[ cchUserName ] = L'\0';


    //
    // Allocate memory in the client's address space
    //

    Status = g_LsaFunctions->AllocateClientBuffer(
                NULL,
                Length,
                (PVOID *) &Names.sUserName
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: AllocateClientBuffer failed   Status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Copy the string there
    //

    Status = g_LsaFunctions->CopyToClientBuffer(
                NULL,
                Length,
                Names.sUserName,
                ContextNames
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: CopyToClientBuffer string failed   Status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Now copy the address of the string there
    //


    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
    {   // Write out only a 32bit value
        Status = g_LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(ULONG),
                    Buffer,
                    &Names
                    );
    }
    else
    {
        Status = g_LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(Names),
                    Buffer,
                    &Names
                    );
    }
    
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: CopyToClientBuffer string address failed   Status 0x%x\n", Status));
        goto CleanUp;
    }


CleanUp:


    // Dereference the credential
    if (pDigestCred)
    {
        TempStatus = CredHandlerRelease(pDigestCred);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: Error in Releasing Credential  Status 0x%x\n", TempStatus));
        }
    }

    if (!NT_SUCCESS(Status))
    {
        if (Names.sUserName != NULL)
        {
            (VOID) g_LsaFunctions->FreeClientBuffer(
                        NULL,
                        Names.sUserName
                        );
        }
        Names.sUserName = NULL;
    }

    if( ContextNames ) {
        DigestFreeMemory( ContextNames );
    }

    DebugLog((DEB_TRACE_FUNC, "SpQueryCredentialsAttributes: Leaving  Handle 0x%x    Status 0x%x\n", CredentialHandle, Status));

    return(Status);
}


NTSTATUS NTAPI
SpSaveCredentials(
    IN ULONG_PTR CredentialHandle,
    IN PSecBuffer Credentials
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Credentials);
    DebugLog((DEB_TRACE_FUNC, "SpSaveCredentials: Entering/Leaving\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


NTSTATUS NTAPI
SpGetCredentials(
    IN ULONG_PTR CredentialHandle,
    IN OUT PSecBuffer Credentials
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Credentials);
    DebugLog((DEB_TRACE_FUNC, "SpGetCredentials: Entering/Leaving\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//   Function not implemented.  ok
NTSTATUS NTAPI
SpDeleteCredentials(
    IN ULONG_PTR CredentialHandle,
    IN PSecBuffer Key
    )
{
    UNREFERENCED_PARAMETER(Key);
    DebugLog((DEB_TRACE_FUNC, "SpDeleteCredentials:       Entering/Leaving  CredentialHandle 0x%x\n", CredentialHandle));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



/*++

Routine Description:

    Duplicates a token

Arguments:

    OriginalToken - Token to duplicate
    DuplicatedToken - Receives handle to duplicated token

Return Value:

    Any error from NtDuplicateToken

--*/
SECURITY_STATUS
SspDuplicateToken(
    IN HANDLE OriginalToken,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE DuplicatedToken
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    QualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.EffectiveOnly = FALSE;
    QualityOfService.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    QualityOfService.ImpersonationLevel = ImpersonationLevel;
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    Status = NtDuplicateToken(
                OriginalToken,
                SSP_TOKEN_ACCESS,
                &ObjectAttributes,
                FALSE,
                TokenImpersonation,
                DuplicatedToken
                );

    return Status;
}


NTSTATUS
SspGetToken (
    OUT PHANDLE ReturnedTokenHandle)
{
    HANDLE TokenHandle = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE TmpHandle = NULL;
    SECURITY_IMPERSONATION_LEVEL SecImpLevel = SecurityImpersonation;

    Status = g_LsaFunctions->ImpersonateClient();

    if (!NT_SUCCESS (Status))
    {
        goto CleanUp;
    }

    // get the token
    // note: there MUST be an impersonation token.
    // LsaFunctions->ImpersonateClient will call ImpersonateSelf() when necessary

    Status = NtOpenThreadToken(NtCurrentThread(),
                               TOKEN_DUPLICATE |
                               TOKEN_QUERY |
                               WRITE_DAC,
                               TRUE,
                               &TokenHandle);

    if (!NT_SUCCESS (Status))
    {
        goto CleanUp;
    }

    Status = SspDuplicateToken(TokenHandle,
                               SecImpLevel,
                               &TmpHandle);

    if (!NT_SUCCESS (Status))
    {
        goto CleanUp;
    }

CleanUp:
    if (ReturnedTokenHandle != NULL)
    {
        if (!NT_SUCCESS (Status))
        {
            *ReturnedTokenHandle = NULL;
        }
        else
        {
            *ReturnedTokenHandle = TmpHandle;
            TmpHandle = NULL;
        }
    }

    if (TokenHandle != NULL)
    {
        NtClose(TokenHandle);
    }

    if (TmpHandle != NULL)
    {
        NtClose(TmpHandle);
    }

    // ignore return value, we may not have impersonated successfully..
    RevertToSelf();

    return Status;
}



NTSTATUS
CredPrint(PDIGEST_CREDENTIAL pCredential)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!pCredential)
    {
        return (STATUS_INVALID_PARAMETER); 
    }

    DebugLog((DEB_TRACE, "CredPrint:          Credential 0x%x   \n", pCredential));

    if (pCredential->CredentialUseFlags & DIGEST_CRED_INBOUND)
    {
            DebugLog((DEB_TRACE, "CredPrint:          INBOUND Session Credential   \n"));
    }
    else
    {
            DebugLog((DEB_TRACE, "CredPrint:          OUTBOUND Session Credential   \n"));
    }

    DebugLog((DEB_TRACE, "CredPrint:          AccountName %wZ   \n", &(pCredential->ustrAccountName)));
    // DebugLog((DEB_TRACE, "CredPrint:          Password %wZ   \n", &(pCredential->ustrPassword)));
    DebugLog((DEB_TRACE, "CredPrint:          DnsDomainName %wZ   \n", &(pCredential->ustrDnsDomainName)));
    DebugLog((DEB_TRACE, "CredPrint:          Upn %wZ   \n", &(pCredential->ustrUpn)));
    DebugLog((DEB_TRACE, "CredPrint:          DownlevelName %wZ   \n", &(pCredential->ustrDownlevelName)));
    DebugLog((DEB_TRACE, "CredPrint:          DomainName %wZ   \n", &(pCredential->ustrDomainName)));
    DebugLog((DEB_TRACE, "CredPrint:          LogonServer %wZ   \n", &(pCredential->ustrLogonServer)));
    DebugLog((DEB_TRACE, "CredPrint:          References %ld   \n", pCredential->lReferences));

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   CredAuthData
//
//  Synopsis:   Copy over supplied auth data.
//
//  Effects:    Fills in string values - calling function must free.
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              SEC_E_INVALID_HANDLE if the handle is not valid
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
CredAuthzData(
    IN PVOID AuthorizationData,
    IN PSECPKG_CALL_INFO pCallInfo,
    IN OUT PULONG NewCredentialUseFlags,
    IN OUT PUNICODE_STRING pUserName,
    IN OUT PUNICODE_STRING pDomainName,
    IN OUT PUNICODE_STRING pPassword
    )
{


    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;
    UNICODE_STRING Password;
    PSEC_WINNT_AUTH_IDENTITY pAuthIdentity = NULL;
    BOOLEAN DoUnicode = TRUE;
    PSEC_WINNT_AUTH_IDENTITY_EXW pAuthIdentityEx = NULL;

    PSEC_WINNT_AUTH_IDENTITY_W TmpCredentials = NULL;
    ULONG CredSize = 0;
    ULONG Offset = 0;
    ULONG ulBuffSize = 0;

    SEC_WINNT_AUTH_IDENTITY32 Cred32 ;
    SEC_WINNT_AUTH_IDENTITY_EX32 CredEx32 ;

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Copy over the authorization data into out address
    // space and make a local copy of the strings.
    //

    DebugLog((DEB_TRACE_FUNC, "CredAuthzData: Entering\n"));

    RtlInitUnicodeString(&UserName, NULL);
    RtlInitUnicodeString(&DomainName, NULL);
    RtlInitUnicodeString(&Password, NULL);

    ZeroMemory(&Cred32, sizeof(SEC_WINNT_AUTH_IDENTITY32));
    ZeroMemory(&CredEx32, sizeof(SEC_WINNT_AUTH_IDENTITY_EX32));

    ASSERT(pCallInfo);

    if (AuthorizationData != NULL)
    {
        ulBuffSize = ((sizeof(SEC_WINNT_AUTH_IDENTITY_EXW) > sizeof(SEC_WINNT_AUTH_IDENTITY32)) ?
                      sizeof(SEC_WINNT_AUTH_IDENTITY_EXW) : sizeof(SEC_WINNT_AUTH_IDENTITY32));
        
        pAuthIdentityEx = (PSEC_WINNT_AUTH_IDENTITY_EXW) DigestAllocateMemory(ulBuffSize);


        if (pAuthIdentityEx != NULL)
        {

            if ( pCallInfo->Attributes & SECPKG_CALL_WOWCLIENT )
            {

                Status = g_LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof( Cred32 ),
                            pAuthIdentityEx,
                            AuthorizationData );

                if ( NT_SUCCESS( Status ) )
                {
                    RtlCopyMemory( &Cred32, pAuthIdentityEx, sizeof( Cred32 ) );
                }

            }
            else 
            {
                Status = g_LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof(SEC_WINNT_AUTH_IDENTITY),
                            pAuthIdentityEx,
                            AuthorizationData);
            }

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto CleanUp;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DebugLog((DEB_ERROR, "CredAuthzData: Error from Digest Allocate is 0x%lx\n", Status));
            goto CleanUp;
        }

        //
        // Check for the ex version
        //

        if (pAuthIdentityEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION)
        {
            //
            // It's an EX structure.
            //

            if ( pCallInfo->Attributes & SECPKG_CALL_WOWCLIENT )
            {
                Status = g_LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof( CredEx32 ),
                            &CredEx32,
                            AuthorizationData );

                if ( NT_SUCCESS( Status ) )
                {
                    pAuthIdentityEx->Version = CredEx32.Version ;
                    pAuthIdentityEx->Length = (CredEx32.Length < sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) ? 
                                               sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) : CredEx32.Length );

                    pAuthIdentityEx->User = (PWSTR) UlongToPtr( CredEx32.User );
                    pAuthIdentityEx->UserLength = CredEx32.UserLength ;
                    pAuthIdentityEx->Domain = (PWSTR) UlongToPtr( CredEx32.Domain );
                    pAuthIdentityEx->DomainLength = CredEx32.DomainLength ;
                    pAuthIdentityEx->Password = (PWSTR) UlongToPtr( CredEx32.Password );
                    pAuthIdentityEx->PasswordLength = CredEx32.PasswordLength ;
                    pAuthIdentityEx->Flags = CredEx32.Flags ;
                    pAuthIdentityEx->PackageList = (PWSTR) UlongToPtr( CredEx32.PackageList );
                    pAuthIdentityEx->PackageListLength = CredEx32.PackageListLength ;

                }

            }
            else
            {
                Status = g_LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                            pAuthIdentityEx,
                            AuthorizationData);
            }


            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto CleanUp;
            }
            pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) &pAuthIdentityEx->User;
            CredSize = pAuthIdentityEx->Length;
            Offset = FIELD_OFFSET(SEC_WINNT_AUTH_IDENTITY_EXW, User);
        }
        else
        {
            pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_W) pAuthIdentityEx;

            if ( pCallInfo->Attributes & SECPKG_CALL_WOWCLIENT )
            {
                pAuthIdentity->User = (PWSTR) UlongToPtr( Cred32.User );
                pAuthIdentity->UserLength = Cred32.UserLength ;
                pAuthIdentity->Domain = (PWSTR) UlongToPtr( Cred32.Domain );
                pAuthIdentity->DomainLength = Cred32.DomainLength ;
                pAuthIdentity->Password = (PWSTR) UlongToPtr( Cred32.Password );
                pAuthIdentity->PasswordLength = Cred32.PasswordLength ;
                pAuthIdentity->Flags = Cred32.Flags ;
            }
            CredSize = sizeof(SEC_WINNT_AUTH_IDENTITY_W);
        }

        if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) != 0)
        {
            DoUnicode = FALSE;
            //
            // Turn off the marshalled flag because we don't support marshalling
            // with ansi.
            //

            pAuthIdentity->Flags &= ~SEC_WINNT_AUTH_IDENTITY_MARSHALLED;
        }
        else if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) == 0)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "CredAuthzData: Error from pAuthIdentity->Flags is 0x%lx\n", pAuthIdentity->Flags));
            goto CleanUp;
        }
        

        // This is the only place where we can figure out whether null
        // session was requested

        if ((pAuthIdentity->UserLength == 0) &&
            (pAuthIdentity->DomainLength == 0) &&
            (pAuthIdentity->PasswordLength == 0) &&
            (pAuthIdentity->User != NULL) &&
            (pAuthIdentity->Domain != NULL) &&
            (pAuthIdentity->Password != NULL))
        {
            *NewCredentialUseFlags |= DIGEST_CRED_NULLSESSION;
        }

        //
        // Copy over the strings
        //
        if( (pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED) != 0 ) {
            ULONG TmpCredentialSize;
            ULONG_PTR EndOfCreds;
            ULONG_PTR TmpUser;
            ULONG_PTR TmpDomain;
            ULONG_PTR TmpPassword;

            if( pAuthIdentity->UserLength > UNLEN ||
                pAuthIdentity->PasswordLength > PWLEN ||
                pAuthIdentity->DomainLength > DNS_MAX_NAME_LENGTH ) {

                DebugLog((DEB_ERROR, "CredAuthzData: Supplied credentials illegal length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            //
            // The callers can set the length of field to n chars, but they
            // will really occupy n+1 chars (null-terminator).
            //

            TmpCredentialSize = CredSize +
                             (  pAuthIdentity->UserLength +
                                pAuthIdentity->DomainLength +
                                pAuthIdentity->PasswordLength +
                             (((pAuthIdentity->User != NULL) ? 1 : 0) +
                             ((pAuthIdentity->Domain != NULL) ? 1 : 0) +
                             ((pAuthIdentity->Password != NULL) ? 1 : 0)) ) * sizeof(WCHAR);

            EndOfCreds = (ULONG_PTR) AuthorizationData + TmpCredentialSize;

            //
            // Verify that all the offsets are valid and no overflow will happen
            //

            TmpUser = (ULONG_PTR) pAuthIdentity->User;

            if ((TmpUser != NULL) &&
                ( (TmpUser < (ULONG_PTR) AuthorizationData) ||
                  (TmpUser > EndOfCreds) ||
                  ((TmpUser + (pAuthIdentity->UserLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpUser + (pAuthIdentity->UserLength * sizeof(WCHAR))) < TmpUser)))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Username in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            TmpDomain = (ULONG_PTR) pAuthIdentity->Domain;

            if ((TmpDomain != NULL) &&
                ( (TmpDomain < (ULONG_PTR) AuthorizationData) ||
                  (TmpDomain > EndOfCreds) ||
                  ((TmpDomain + (pAuthIdentity->DomainLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpDomain + (pAuthIdentity->DomainLength * sizeof(WCHAR))) < TmpDomain)))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Domainname in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            TmpPassword = (ULONG_PTR) pAuthIdentity->Password;

            if ((TmpPassword != NULL) &&
                ( (TmpPassword < (ULONG_PTR) AuthorizationData) ||
                  (TmpPassword > EndOfCreds) ||
                  ((TmpPassword + (pAuthIdentity->PasswordLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpPassword + (pAuthIdentity->PasswordLength * sizeof(WCHAR))) < TmpPassword)))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Password in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            //
            // Allocate a chunk of memory for the credentials
            //

            TmpCredentials = (PSEC_WINNT_AUTH_IDENTITY_W) DigestAllocateMemory(TmpCredentialSize - Offset);
            if (TmpCredentials == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto CleanUp;
            }

            //
            // Copy the credentials from the client
            //

            Status = g_LsaFunctions->CopyFromClientBuffer(
                        NULL,
                        TmpCredentialSize - Offset,
                        TmpCredentials,
                        (PUCHAR) AuthorizationData + Offset
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Failed to copy whole auth identity\n"));
                goto CleanUp;
            }

            //
            // Now convert all the offsets to pointers.
            //

            if (TmpCredentials->User != NULL)
            {
                USHORT cbUser;

                TmpCredentials->User = (LPWSTR) RtlOffsetToPointer(
                                                TmpCredentials->User,
                                                (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                );

                ASSERT( (TmpCredentials->UserLength*sizeof(WCHAR)) <= 0xFFFF );

                cbUser = (USHORT)(TmpCredentials->UserLength * sizeof(WCHAR));
                UserName.Buffer = (PWSTR)DigestAllocateMemory( cbUser );

                if (UserName.Buffer == NULL ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto CleanUp;
                }

                CopyMemory( UserName.Buffer, TmpCredentials->User, cbUser );
                UserName.Length = cbUser;
                UserName.MaximumLength = cbUser;
            }

            if (TmpCredentials->Domain != NULL)
            {
                USHORT cbDomain;

                TmpCredentials->Domain = (LPWSTR) RtlOffsetToPointer(
                                                    TmpCredentials->Domain,
                                                    (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                    );

                ASSERT( (TmpCredentials->DomainLength*sizeof(WCHAR)) <= 0xFFFF );
                cbDomain = (USHORT)(TmpCredentials->DomainLength * sizeof(WCHAR));
                DomainName.Buffer = (PWSTR)DigestAllocateMemory( cbDomain );

                if (DomainName.Buffer == NULL ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto CleanUp;
                }

                CopyMemory( DomainName.Buffer, TmpCredentials->Domain, cbDomain );
                DomainName.Length = cbDomain;
                DomainName.MaximumLength = cbDomain;
            }

            if (TmpCredentials->Password != NULL)
            {
                USHORT cbPassword;

                TmpCredentials->Password = (LPWSTR) RtlOffsetToPointer(
                                                    TmpCredentials->Password,
                                                    (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                    );


                ASSERT( (TmpCredentials->PasswordLength*sizeof(WCHAR)) <= 0xFFFF );
                cbPassword = (USHORT)(TmpCredentials->PasswordLength * sizeof(WCHAR));
                Password.Buffer = (PWSTR)DigestAllocateMemory( cbPassword );

                if (Password.Buffer == NULL ) {
                    ZeroMemory( TmpCredentials->Password, cbPassword );
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto CleanUp;
                }

                CopyMemory( Password.Buffer, TmpCredentials->Password, cbPassword );
                Password.Length = cbPassword;
                Password.MaximumLength = cbPassword;

                ZeroMemory( TmpCredentials->Password, cbPassword );
            }


        } else {

            if (pAuthIdentity->Password != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->Password,
                                pAuthIdentity->PasswordLength,
                                DoUnicode,
                                &Password
                                );
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "CredAuthzData: Error from CopyClientString is 0x%lx\n", Status));
                    goto CleanUp;
                }

            }

            if (pAuthIdentity->User != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->User,
                                pAuthIdentity->UserLength,
                                DoUnicode,
                                &UserName
                                );
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "CredAuthzData: Error from CopyClientString is 0x%lx\n", Status));
                    goto CleanUp;
                }

            }

            if (pAuthIdentity->Domain != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->Domain,
                                pAuthIdentity->DomainLength,
                                DoUnicode,
                                &DomainName
                                );
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "CredAuthzData: Error from CopyClientString is 0x%lx\n", Status));
                    goto CleanUp;
                }

                //
                // Make sure that the domain name length is not greater
                // than the allowed dns domain name
                //

                if (DomainName.Length > DNS_MAX_NAME_LENGTH * sizeof(WCHAR))
                {
                    DebugLog((DEB_ERROR, "CredAuthzData: Invalid supplied domain name %wZ\n",
                        &DomainName ));
                    Status = SEC_E_UNKNOWN_CREDENTIALS;
                    goto CleanUp;
                }

            }
        }
    }   // AuthorizationData != NULL

    pUserName->Buffer = UserName.Buffer;
    pUserName->Length = UserName.Length;
    pUserName->MaximumLength = UserName.MaximumLength;
    UserName.Buffer = NULL;      // give memory to calling process
    
    pDomainName->Buffer = DomainName.Buffer;
    pDomainName->Length = DomainName.Length;
    pDomainName->MaximumLength = DomainName.MaximumLength;
    DomainName.Buffer = NULL;      // give memory to calling process

    pPassword->Buffer = Password.Buffer;
    pPassword->Length = Password.Length;
    pPassword->MaximumLength = Password.MaximumLength;
    Password.Buffer = NULL;      // give memory to calling process


CleanUp:


    if (pAuthIdentityEx != NULL)
    {
        DigestFreeMemory(pAuthIdentityEx);
    }

    if (TmpCredentials != NULL)
    {
        DigestFreeMemory(TmpCredentials);
    }

    if (DomainName.Buffer != NULL)
    {
        DigestFreeMemory(DomainName.Buffer);
    }

    if (UserName.Buffer != NULL)
    {
        DigestFreeMemory(UserName.Buffer);
    }

    if (Password.Buffer != NULL)
    {
        ZeroMemory(Password.Buffer, Password.Length);
        DigestFreeMemory(Password.Buffer);
    }

    DebugLog((DEB_TRACE_FUNC, "CredAuthzData: Leaving    Status 0x%x\n", Status));

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\ctxt.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        ctxt.cxx
//
// Contents:    Context manipulation functions
//
//
// History:     KDamour  15Mar00   Stolen from NTLM context.cxx
//
//------------------------------------------------------------------------
#include "global.h"

// Globals for manipulating Context Lists
RTL_CRITICAL_SECTION l_ContextCritSect;

LIST_ENTRY       l_ContextList;

// Indicate if completed Initialization of Credential Handler
BOOL  g_bContextInitialized = FALSE;



//+--------------------------------------------------------------------
//
//  Function:   SspContextInitialize
//
//  Synopsis:   Initializes the context manager package
//
//  Arguments:  none
//
//  Returns: NTSTATUS
//
//  Notes: Called by SpInitialize
//
//---------------------------------------------------------------------
NTSTATUS
CtxtHandlerInit(VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize the Context list to be empty.
    //

    Status = RtlInitializeCriticalSection(&l_ContextCritSect);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "CtxtHandlerInit: Failed to initialize critsec   0x%x\n", Status));
        goto CleanUp;
    }
    
    InitializeListHead( &l_ContextList );


    // Simple variable test to make sure all initialized;
    g_bContextInitialized = TRUE;

CleanUp:

    return Status;
}


// Add a Context into the Context List
NTSTATUS
CtxtHandlerInsertCred(
    IN PDIGEST_CONTEXT  pDigestCtxt
    )
{
    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerInsertCred: Entering with Context 0x%x RefCount %ld\n", pDigestCtxt, pDigestCtxt->lReferences));
    RtlEnterCriticalSection( &l_ContextCritSect );
    DebugLog((DEB_TRACE, "CtxtHandlerInsertCred: add into list\n"));
    InsertHeadList( &l_ContextList, &pDigestCtxt->Next );
    RtlLeaveCriticalSection( &l_ContextCritSect );
    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerInsertCred: Leaving with Context 0x%x\n", pDigestCtxt));

    return STATUS_SUCCESS;
}


// Initialize a Context into the IdleState with the data from the Credential provided
NTSTATUS NTAPI
ContextInit(
           IN OUT PDIGEST_CONTEXT pContext,
           IN PDIGEST_CREDENTIAL pCredential
           )
{

    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "ContextInit: Entering\n"));

    if (!pContext || !pCredential)
    {
        return STATUS_INVALID_PARAMETER;
    }

    ZeroMemory(pContext, sizeof(DIGEST_CONTEXT));

    pContext->typeQOP = QOP_UNDEFINED;
    pContext->typeDigest = DIGEST_UNDEFINED;
    pContext->typeAlgorithm = ALGORITHM_UNDEFINED;
    pContext->typeCipher = CIPHER_UNDEFINED;
    pContext->typeCharset = CHARSET_UNDEFINED;
    pContext->lReferences = 0;
    pContext->ulSendMaxBuf = SASL_MAX_DATA_BUFFER;
    pContext->ulRecvMaxBuf = SASL_MAX_DATA_BUFFER;
    pContext->TimeCreated = time(NULL);
    pContext->ContextHandle = (ULONG_PTR)pContext;
    pContext->PasswordExpires = g_TimeForever;        // never expire

    // Now copy over all the info we need from the supplied credential

    pContext->CredentialUseFlags = pCredential->CredentialUseFlags;   // Keep the info on inbound/outbound

    Status = UnicodeStringDuplicate(&(pContext->ustrAccountName), &(pCredential->ustrAccountName));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "ContextInit: Failed to copy Domain into Context\n"));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicate(&(pContext->ustrDomain), &(pCredential->ustrDnsDomainName));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "ContextInit: Failed to copy Domain into Context\n"));
        goto CleanUp;
    }

       // Copy over the Credential Password if known - thread safe - this is encrypted text
    Status = CredHandlerPasswdGet(pCredential, &pContext->ustrPassword);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "ContextInit: CredHandlerPasswdGet error    status 0x%x\n", Status));
        goto CleanUp;
    }


CleanUp:
    DebugLog((DEB_TRACE_FUNC, "ContextInit: Leaving\n"));
    return Status;

}


// Once done with a context - release the resouces
NTSTATUS NTAPI
ContextFree(
           IN PDIGEST_CONTEXT pContext
           )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT iCnt = 0;

    DebugLog((DEB_TRACE_FUNC, "ContextFree: Entering with Context 0x%x\n", pContext));
    ASSERT(pContext);
    ASSERT(0 == pContext->lReferences);

    if (!pContext)
    {
        return STATUS_INVALID_PARAMETER;
    }

    DebugLog((DEB_TRACE, "ContextFree: Context RefCount %ld\n", pContext->lReferences));

    DebugLog((DEB_TRACE, "ContextFree: Checking TokenHandle for LogonID (%x:%lx)\n",
               pContext->LoginID.HighPart, pContext->LoginID.LowPart));
    if (pContext->TokenHandle)
    {
        DebugLog((DEB_TRACE, "ContextFree: Closing TokenHandle for LogonID (%x:%lx)\n",
                   pContext->LoginID.HighPart, pContext->LoginID.LowPart));
        NtClose(pContext->TokenHandle);
        pContext->TokenHandle = NULL;
    }

    StringFree(&(pContext->strNonce));
    StringFree(&(pContext->strCNonce));
    StringFree(&(pContext->strOpaque));
    StringFree(&(pContext->strSessionKey));
    UnicodeStringFree(&(pContext->ustrDomain));
    UnicodeStringFree(&(pContext->ustrPassword));
    UnicodeStringFree(&(pContext->ustrAccountName));

    StringFree(&(pContext->strResponseAuth));

    for (iCnt = 0; iCnt < MD5_AUTH_LAST; iCnt++)
    {
        StringFree(&(pContext->strDirective[iCnt]));
    }
    
    DigestFreeMemory(pContext);

    DebugLog((DEB_TRACE_FUNC, "ContextFree: Leaving with Context 0x%x\n", pContext));
    return Status;

}



/*++

Routine Description:

    This routine checks to see if the Context is for the specified
    Client Connection, and references the Context if it is valid.

    The caller may optionally request that the Context be
    removed from the list of valid Contexts - preventing future
    requests from finding this Context.

Arguments:

    ContextHandle - Points to the ContextHandle of the Context
        to be referenced.

    RemoveContext - This boolean value indicates whether the caller
        wants the Context to be removed from the list
        of Contexts.  TRUE indicates the Context is to be removed.
        FALSE indicates the Context is not to be removed.


Return Value:

    NULL - the Context was not found.

    Otherwise - returns a pointer to the referenced Context.

--*/
NTSTATUS NTAPI
CtxtHandlerHandleToContext(
    IN ULONG_PTR ContextHandle,
    IN BOOLEAN RemoveContext,
    OUT PDIGEST_CONTEXT *ppContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_CONTEXT Context = NULL;
    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerHandleToContext: Entering    ContextHandle 0x%lx\n", ContextHandle));

    //
    // Acquire exclusive access to the Context list
    //

    RtlEnterCriticalSection( &l_ContextCritSect );

    //
    // Now walk the list of Contexts looking for a match.
    //

    for ( ListEntry = l_ContextList.Flink;
          ListEntry != &l_ContextList;
          ListEntry = ListEntry->Flink ) {

        Context = CONTAINING_RECORD( ListEntry, DIGEST_CONTEXT, Next );

        //
        // Found a match ... reference this Context
        // (if the Context is being removed, we would increment
        // and then decrement the reference, so don't bother doing
        // either - since they cancel each other out).
        //

        if ( Context == (PDIGEST_CONTEXT) ContextHandle)
        {
            if (!RemoveContext)
            {
                //
                // Timeout this context if caller is not trying to remove it.
                // We only timeout contexts that are being setup, not
                // fully authenticated contexts.
                //

                if (CtxtHandlerTimeHasElapsed(Context))
                {
                        DebugLog((DEB_ERROR, "CtxtHandlerHandleToContext: Context 0x%lx has timed out.\n",
                                    ContextHandle ));
                        Status = SEC_E_CONTEXT_EXPIRED;
                        goto CleanUp;
                }

                lReferences = InterlockedIncrement(&Context->lReferences);
            }
            else
            {
                RemoveEntryList( &Context->Next );
                DebugLog((DEB_TRACE, "CtxtHandlerHandleToContext:Delinked Context 0x%lx\n",Context ));
            }

            DebugLog((DEB_TRACE, "CtxtHandlerHandleToContext: FOUND Context = 0x%x, RemoveContext = %d, ReferenceCount = %ld\n",
                       Context, RemoveContext, Context->lReferences));
            *ppContext = Context;
            goto CleanUp;
        }

    }

    //
    // No match found
    //

    DebugLog((DEB_WARN, "CtxtHandlerHandleToContext: Tried to reference unknown Context 0x%lx\n", ContextHandle ));
    Status =  STATUS_OBJECT_NAME_NOT_FOUND;

CleanUp:

    RtlLeaveCriticalSection( &l_ContextCritSect );
    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerHandleToContext: Leaving\n" ));

    return(Status);
}



/*++

Routine Description:

    This routine checks to see if the LogonId is for the specified
    Server Connection, and references the Context if it is valid.

    The caller may optionally request that the Context be
    removed from the list of valid Contexts - preventing future
    requests from finding this Context.

Arguments:

    pstrOpaque - Opaque string that uniquely references the SecurityContext


Return Value:

    NULL - the Context was not found.

    Otherwise - returns a pointer to the referenced Context.

--*/
NTSTATUS NTAPI
CtxtHandlerOpaqueToPtr(
    IN PSTRING pstrOpaque,
    OUT PDIGEST_CONTEXT *ppContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_CONTEXT Context = NULL;
    LONG rc = 0;
    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerOpaqueToPtr: Entering    Opaque (%Z)\n", pstrOpaque));

    //
    // Acquire exclusive access to the Context list
    //

    RtlEnterCriticalSection( &l_ContextCritSect );

    //
    // Now walk the list of Contexts looking for a match.
    //

    for ( ListEntry = l_ContextList.Flink;
          ListEntry != &l_ContextList;
          ListEntry = ListEntry->Flink ) {

        Context = CONTAINING_RECORD( ListEntry, DIGEST_CONTEXT, Next );

        //
        // Found a match ... reference this Context
        // (if the Context is being removed, we would increment
        // and then decrement the reference, so don't bother doing
        // either - since they cancel each other out).
        //

        rc = RtlCompareString(pstrOpaque, &(Context->strOpaque), FALSE);
        if (!rc)
        {

            //
            // Timeout this context if caller is not trying to remove it.
            // We only timeout contexts that are being setup, not
            // fully authenticated contexts.
            //

            if (CtxtHandlerTimeHasElapsed(Context))
            {
                    DebugLog((DEB_ERROR, "CtxtHandlerOpaqueToPtr: Context 0x%x has timed out.\n",
                                Context ));
                    Status = SEC_E_CONTEXT_EXPIRED;
                    goto CleanUp;
            }

            lReferences = InterlockedIncrement(&Context->lReferences);

            DebugLog((DEB_TRACE, "CtxtHandlerOpaqueToPtr: FOUND Context = 0x%x, ReferenceCount = %ld\n",
                       Context, Context->lReferences));
            *ppContext = Context;
            goto CleanUp;
        }

    }

    //
    // No match found
    //

    DebugLog((DEB_WARN, "CtxtHandlerOpaqueToPtr: Tried to reference unknown Opaque (%Z)\n", pstrOpaque));
    Status =  STATUS_OBJECT_NAME_NOT_FOUND;

CleanUp:

    RtlLeaveCriticalSection( &l_ContextCritSect );
    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerOpaqueToPtr: Leaving\n" ));

    return(Status);
}



// Check the Creation time with the Current time.
// If the difference is greater than the MAX allowed, Context is no longer valid
BOOL
CtxtHandlerTimeHasElapsed(
    PDIGEST_CONTEXT pContext)
{
    BOOL bStatus = FALSE;
    DWORD dwTimeElapsed = 0;
    time_t timeCurrent = time(NULL);

    dwTimeElapsed = (DWORD)(timeCurrent - pContext->TimeCreated);

    if (dwTimeElapsed > g_dwParameter_Lifetime)
    {
        bStatus = TRUE;
    }

    return(bStatus);
}



//+--------------------------------------------------------------------
//
//  Function:   CtxtHandlerRelease
//
//  Synopsis:   Releases the Context by decreasing reference counter
//
//  Arguments:  pContext - pointer to credential to de-reference
//
//  Returns: NTSTATUS
//
//  Notes:  
//
//---------------------------------------------------------------------
NTSTATUS
CtxtHandlerRelease(
    PDIGEST_CONTEXT pContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG lReferences = 0;

    lReferences = InterlockedDecrement(&pContext->lReferences);

    DebugLog((DEB_TRACE, "CtxtHandlerRelease: (RefCount) UserContextInit deref 0x%x  references %ld\n",
               pContext, lReferences));

    ASSERT( lReferences >= 0 );

    //
    // If the count has dropped to zero, then free all alloced stuff
    //

    if (lReferences == 0)
    {
        DebugLog((DEB_TRACE, "CtxtHandlerRelease: (RefCount) UserContextInit freed 0x%x\n", pContext));
        Status = ContextFree(pContext);
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\ctxt.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        ctxt.h
//
// Contents:    declarations, constants for context manager
//
//
// History:     KDamour  15Mar00   Created
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_CTXT_H
#define NTDIGEST_CTXT_H

// Utilized for Str to int conversion                  
#define HEXBASE 16
#define TENBASE 10

// number of bytes to hold ChallengeResponse directives and symbols (actual count is 107) round up for padding
// 14 for charset
#define CB_CHALRESP 364
#define CB_CHAL     400

#define RSPAUTH_STR "rspauth=%Z"

// Hash locations for pre-calculated DS hashes                      
#define PRECALC_NONE 0
#define PRECALC_ACCOUNTNAME 1
#define PRECALC_UPN 2
#define PRECALC_NETBIOS 3

//  Number of secbuffers for each type  HTTP and SASL
#define ASC_HTTP_NUM_INPUT_BUFFERS 5
#define ASC_SASL_NUM_INPUT_BUFFERS 1
#define ASC_HTTP_NUM_OUTPUT_BUFFERS 1
#define ASC_SASL_NUM_OUTPUT_BUFFERS 1
 
// Initializes the context manager package 
NTSTATUS CtxtHandlerInit(VOID);

// Add a Context into the Cntext List
NTSTATUS CtxtHandlerInsertCred(IN PDIGEST_CONTEXT  pDigestCtxt);

// Initialize all the struct elements in a Context from the Credential
NTSTATUS NTAPI ContextInit(IN OUT PDIGEST_CONTEXT pContext, IN PDIGEST_CREDENTIAL pCredential);

// Release memory utilized by the Context
NTSTATUS NTAPI ContextFree(IN PDIGEST_CONTEXT pContext);

// Find the security context handle by the opaque reference
NTSTATUS NTAPI CtxtHandlerOpaqueToPtr(
                             IN PSTRING pstrOpaque,
                             OUT PDIGEST_CONTEXT *ppContext);

// Find the security context by the security context handle
NTSTATUS NTAPI CtxtHandlerHandleToContext(IN ULONG_PTR ContextHandle, IN BOOLEAN RemoveContext,
    OUT PDIGEST_CONTEXT *ppContext);

// Releases the Context by decreasing reference counter
NTSTATUS CtxtHandlerRelease(PDIGEST_CONTEXT pContext);

// Check to see if COntext is within valid lifetime
BOOL CtxtHandlerTimeHasElapsed(PDIGEST_CONTEXT pContext);

// From ctxtapi.cxx

// Creates the Output SecBuffer for the Challenge
NTSTATUS NTAPI ContextCreateChal(IN PDIGEST_CONTEXT pContext, IN PSTRING pstrRealm, OUT PSecBuffer OutBuffer);

// Creates the Output SecBuffer for the Challenge Response
NTSTATUS NTAPI DigestCreateChalResp(IN PDIGEST_PARAMETER pDigest, 
                                    IN PUSER_CREDENTIALS pUserCreds,
                                    OUT PSecBuffer OutBuffer);

// Check SecurityToken for corredct structure format
BOOL ContextIsTokenOK(IN PSecBuffer pTempToken, IN ULONG ulMaxSize);

// Called for server incoming messages - verify Digest and generate sessionkey if necessary
NTSTATUS NTAPI DigestProcessParameters(IN OUT PDIGEST_CONTEXT pContext,
                                       IN PDIGEST_PARAMETER pDigest,
                                       OUT PSecBuffer pFirstOutputToken,
                                       OUT PNTSTATUS pAuditLogStatus);

// Called for client outbound messages - generate the response hash
NTSTATUS NTAPI DigestGenerateParameters(IN OUT PDIGEST_CONTEXT pContext,
    IN PDIGEST_PARAMETER pDigest, OUT PSecBuffer pFirstOutputToken);

// LSA calls this function in the Generic Passthrough call
NTSTATUS NTAPI DigestPackagePassthrough(IN USHORT cbMessageRequest, IN BYTE *pMessageRequest,
                         IN OUT ULONG *pulMessageResponse, OUT PBYTE *ppMessageResponse);

// Lookup passwords and perform digest cal auth (runs on the DC)
NTSTATUS NTAPI DigestResponseBru(IN BYTE *pDigestParamEncoded,
                 IN OUT ULONG *pculResponse, OUT PBYTE *ppResponse);

// Formatted printout of Digest Parameters
NTSTATUS DigestPrint(PDIGEST_PARAMETER pDigest);

// Formatted printout of Context
NTSTATUS ContextPrint(IN PDIGEST_CONTEXT pDigest);

// Create a logonSession for the Authenticated LogonToken in the SecurityContext
NTSTATUS CtxtCreateLogSess(IN PDIGEST_CONTEXT pDigest);

//  Extract the username & domain from the Digest structure directives
NTSTATUS UserCredentialsExtract(PDIGEST_PARAMETER pDigest,
                                PUSER_CREDENTIALS pUserCreds);

//   Release memory allocated into UserCredentials
NTSTATUS UserCredentialsFree(PUSER_CREDENTIALS pUserCreds);

NTSTATUS DigestSASLResponseAuth(
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSecBuffer pOutputToken);

NTSTATUS DigestCalculateResponseAuth(
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSTRING pstrHash);

NTSTATUS DigestDecodeUserAccount(
    IN PDIGEST_PARAMETER pDigest,
    OUT PUNICODE_STRING  pustrDC);

#endif  // DNTDIGEST_CTXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\debug.h ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:       debug.h
//
// Contents:   debugging information for SSP
//
//             Helper functions:
//
// History:    KDamour  15Mar00   created
//
//---------------------------------------------------------------------

#ifndef NTDIGEST_DEBUG_H
#define NTDIGEST_DEBUG_H

#include "dsysdbg.h"
DECLARE_DEBUG2(Digest);

#if DBG
#define DebugLog(x) DigestDebugPrint x
#else
#define DebugLog(x)
#endif


#define DEB_ERROR      0x00000001
#define DEB_WARN       0x00000002
#define DEB_TRACE      0x00000004
#define DEB_TRACE_ASC  0x00000008
#define DEB_TRACE_ISC  0x00000010
#define DEB_TRACE_LSA  0x00000020
#define DEB_TRACE_USER 0x00000040
#define DEB_TRACE_FUNC 0x00000080
#define DEB_TRACE_MEM  0x00000100
#define TRACE_STUFF    0x00000200

#endif   /* NTDIGEST_DEBUG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\func.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        ntdigestfunc.h
//
// Contents:    prototypes for export functions
//
//
// History:     KDamour  15Mar00 Stolen from NTLM ntlmfunc.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_NTDIGESTFUNC_H__
#define NTDIGEST_NTDIGESTFUNC_H__

NTSTATUS NTAPI SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Tables,
    OUT PULONG TableCount
    );


NTSTATUS NTAPI SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables
    );

// SpLsaModeInitializeFn           SpLsaModeInitialize;
SpInitializeFn                  SpInitialize;

// SpUserModeInitializeFn          SpUserModeInitialize;
//LSA_AP_INITIALIZE_PACKAGE       LsaApInitializePackage;

SpGetInfoFn                     SpGetInfo;
LSA_AP_LOGON_USER_EX2           LsaApLogonUserEx2;

SpAcceptCredentialsFn           SpAcceptCredentials;
SpAcquireCredentialsHandleFn    SpAcquireCredentialsHandle;
SpFreeCredentialsHandleFn       SpFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes;
SpSaveCredentialsFn             SpSaveCredentials;
SpGetCredentialsFn              SpGetCredentials;
SpDeleteCredentialsFn           SpDeleteCredentials;

SpInitLsaModeContextFn          SpInitLsaModeContext;
SpDeleteContextFn               SpDeleteContext;
SpAcceptLsaModeContextFn        SpAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         LsaApLogonTerminated;
SpApplyControlTokenFn           SpApplyControlToken;
LSA_AP_CALL_PACKAGE             LsaApCallPackage;
LSA_AP_CALL_PACKAGE             LsaApCallPackageUntrusted;
LSA_AP_CALL_PACKAGE_PASSTHROUGH LsaApCallPackagePassthrough;
SpShutdownFn                    SpShutdown;
SpGetUserInfoFn                 SpGetUserInfo;

SpInstanceInitFn                SpInstanceInit;
SpInitUserModeContextFn         SpInitUserModeContext;
SpMakeSignatureFn               SpMakeSignature;
SpVerifySignatureFn             SpVerifySignature;
SpSealMessageFn                 SpSealMessage;
SpUnsealMessageFn               SpUnsealMessage;
SpGetContextTokenFn             SpGetContextToken;
SpQueryContextAttributesFn      SpQueryContextAttributes;
SpDeleteContextFn               SpDeleteUserModeContext;
SpCompleteAuthTokenFn           SpCompleteAuthToken;
SpFormatCredentialsFn           SpFormatCredentials;
SpMarshallSupplementalCredsFn   SpMarshallSupplementalCreds;
SpExportSecurityContextFn       SpExportSecurityContext;
SpImportSecurityContextFn       SpImportSecurityContext;
SpGetExtendedInformationFn      SpGetExtendedInformation ;
SpSetExtendedInformationFn      SpSetExtendedInformation ;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes ;


// Local Prototypes for Digest SSP
NTSTATUS SspCreateTokenDacl(HANDLE Token);

#endif // NTDIGEST_NTDIGESTFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\ctxtapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        ctxtapi.cxx
//
// Contents:    Context APIs for the Digest security package
//              Main entry points into this dll:
//                SpDeleteContext
//                SpInitLsaModeContext
//                SpApplyControlToken
//                SpAcceptLsaModeContext
//
// History:   KDamour  16Mar00       Based from NTLM ctxtapi.cxx
//
//------------------------------------------------------------------------

extern "C"
{
#include <stdio.h>
}

#include "global.h"

extern "C"
{
#include <ntdsapi.h>           // DS_USER_PRINCIPAL_NAME
#include <ntdsa.h>           // CrackSingleName
}

#define MAXBUFNUMLEN 9       // VERY BIG number of digits in maxbuf

//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteContext
//
//  Synopsis:   Deletes an NtDigest context
//
//    Deletes the local data structures associated with the specified
//    security context in the LSA.
//
//    This API terminates a context on the local machine.
//
//  Effects:
//
//  Arguments:  ContextHandle - The context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_HANDLE
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpDeleteContext(
               IN ULONG_PTR ContextHandle
               )
{
    DebugLog((DEB_TRACE_FUNC, "SpDeleteContext: Entering   ContextHandle 0x%lx\n", ContextHandle ));
    PDIGEST_CONTEXT pContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Find the currently existing user context and delink it
    // so that another context cannot Reference it before we
    // Dereference this one.  
    //
    Status = CtxtHandlerHandleToContext(ContextHandle, TRUE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_SUCCESS;
        DebugLog((DEB_TRACE, "SpDeleteContext: CtxtHandlerHandleToContext not found 0x%x\n", Status ));
        goto CleanUp;
    }

    //  Now deference - there may be other references from pointer references (from Handles)
    //  inside the LSA but will be released
    if (pContext)
    {
        Status = CtxtHandlerRelease(pContext);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpDeleteContext: DereferenceUserContext error  Status 0x%x\n", Status ));
        }
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SpDeleteContext: Leaving ContextHandle 0x%lx    status 0x%x\n",
               ContextHandle, Status ));
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpInitLsaModeContext
//
//  Synopsis:   Digest implementation of InitializeSecurityContext
//              while in Lsa mode. If we return TRUE in *MappedContext,
//              secur32 will call SpInitUserModeContext with
//              the returned context handle and ContextData
//              as input. Fill in whatever info needed for
//              the user mode APIs
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpInitLsaModeContext(
                    IN OPTIONAL ULONG_PTR CredentialHandle,
                    IN OPTIONAL ULONG_PTR OldContextHandle,
                    IN OPTIONAL PUNICODE_STRING pustrTargetName,
                    IN ULONG fContextReqFlags,
                    IN ULONG TargetDataRep,
                    IN PSecBufferDesc InputBuffers,
                    OUT PULONG_PTR NewContextHandle,
                    IN OUT PSecBufferDesc OutputBuffers,
                    OUT PULONG fContextAttributes,
                    OUT PTimeStamp pExpirationTime,
                    OUT PBOOLEAN MappedContext,
                    OUT PSecBuffer ContextData
                    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "SpInitLsaModeContext: Entering  ContextHandle 0x%x\n", OldContextHandle));

    SecBuffer TempTokens[6];
    PSecBuffer pChalInputToken;
    PSecBuffer pMethodInputToken;
    PSecBuffer pHEntityInputToken;
    PSecBuffer pOutputToken;
    DIGEST_PARAMETER Digest;
    PDIGEST_CONTEXT pNewContext = NULL;            // keep pointer to release new context on error
    PDIGEST_CONTEXT pContext = NULL;               // used to update the context
    BOOL bLockedContext = FALSE;                   // if we obtained a refcount on a Context
    BOOL fDefChars = FALSE;                        // were default chars utilized in Unicode encoding
    int iTemp = 0;

    SecBuffer ReplyBuffer;                         // Output is generated in this buffer

    char *cptr = NULL;

    ULONG  fContextAttr = ISC_REQ_REPLAY_DETECT;   // Flags on the Attributes of the context
    DIGEST_TYPE typeDigest = NO_DIGEST_SPECIFIED;
    QOP_TYPE typeQOP = NO_QOP_SPECIFIED;
    ALGORITHM_TYPE typeAlgorithm = NO_ALGORITHM_SPECIFIED;
    CHARSET_TYPE typeCharset = ISO_8859_1;
    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;  // are we in SASL or HTTP mode


    PDIGEST_CREDENTIAL pCredential = NULL;    
    STRING strcSASLMethod;
    STRING strcSASLHEntity;
    STRING strcNC;
    STRING strTargetName;
           
    // Verify Args
    if (!fContextAttributes || !NewContextHandle || !OutputBuffers)
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Invalid arg (possible NULL pointer)\n"));
        return STATUS_INVALID_PARAMETER;
    }

    *fContextAttributes = 0;
    *NewContextHandle = NULL;
    if (pExpirationTime)
    {
        *pExpirationTime = g_TimeForever;
    }
    *MappedContext = FALSE;
    ContextData->pvBuffer = NULL;
    ContextData->cbBuffer = 0;


    // Create pointers to tokens for processing
    pChalInputToken = &TempTokens[0];
    pMethodInputToken = &TempTokens[1];
    pHEntityInputToken = &TempTokens[3];
    pOutputToken = &TempTokens[4];
    DigestInit(&Digest);

    ZeroMemory(TempTokens,sizeof(TempTokens));
    ZeroMemory(&strTargetName, sizeof(strTargetName));

    ZeroMemory(&ReplyBuffer, sizeof(ReplyBuffer));

    // Must have a Credential Handle to perform processing - will ref count 
    Status = CredHandlerHandleToPtr(CredentialHandle, FALSE, &pCredential);
    if (!NT_SUCCESS(Status))
    {
        Status = SEC_E_UNKNOWN_CREDENTIALS;
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Could not locate the Credential\n"));
        goto CleanUp;
    }

    // Verify that credential is marked OUTBOUND for ASC call
    if (!(pCredential->CredentialUseFlags & DIGEST_CRED_OUTBOUND))
    {
        Status = SEC_E_NOT_SUPPORTED;
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Credential not marked for Outbound connections\n"));
        goto CleanUp;
    }

    // Retrieve the information from the SecBuffers & check proper formattting
    // Check for NULL input for InputBuffers - as is done for 1st call to ISC
    if (InputBuffers && (InputBuffers->cBuffers))
    {
        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 0,   // get the first SECBUFFER_TOKEN
                                 &pChalInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pChalInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: SspGetTokenBufferByIndex (ChalRspInputToken) status 0x%x\n", Status));
            goto CleanUp;
        }
    }

           // Process the output buffer
    if ( !SspGetTokenBufferByIndex( OutputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &pOutputToken,
                             FALSE )  ||
         !ContextIsTokenOK(pOutputToken, 0))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: SspGetTokenBufferByIndex (OutputToken)    status 0x%x\n", Status));
        goto CleanUp;
    }

    if (fContextReqFlags & ISC_REQ_ALLOCATE_MEMORY)
    {
        pOutputToken->pvBuffer = NULL;
        pOutputToken->cbBuffer = 0;
    }

    // To support SASL's call to ISC BEFORE any calls to ASC just return SEC_I_CONTINUE_NEEDED
    if (pChalInputToken->cbBuffer <= 1)
    {
        // Need to create a context for this connection - destroy if unsuccessful auth
        pNewContext = (PDIGEST_CONTEXT)DigestAllocateMemory(sizeof(DIGEST_CONTEXT));
        if (!pNewContext)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: ISC empty context - Out of memory on challenge context\n"));
            goto CleanUp;
        }

        CredPrint(pCredential);

        // Initialize new context
        Status = ContextInit(pNewContext, pCredential);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: ISC empty context - ContextInit error status 0x%x\n", Status));
            goto CleanUp;
        }

        Status = SEC_I_CONTINUE_NEEDED;           // Have no input for processing
        pOutputToken->cbBuffer = 0;          // No output buffer
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: ISC empty context - Called with no Input Buffer    Status 0x%x\n", Status));

        // Add the Newly created Context into the list of Contexts
        pNewContext->lReferences = 1;      // pass reference back to ISC caller
        CtxtHandlerInsertCred(pNewContext);
        // pContext = pNewContext;                        // set to have dereferenced
        *NewContextHandle = (ULONG_PTR)pNewContext;    // Just report back with the updated context
        *fContextAttributes = fContextAttr;            // Return the ISC Attributes set on Context

        // bLockedContext = TRUE;               // Release memory to CtxtHandler
        pNewContext = NULL;                  // We no longer own this memory - turned over to CtxtHandler

        goto CleanUp;
    }

    // Verify SecBuffer inputs - both SASL and HTTP require atleast 1 buffer
    if (!InputBuffers || !InputBuffers->cBuffers)
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Invalid SecBufferDesc\n"));
        return STATUS_INVALID_PARAMETER;
    }

    // We have input in the SECBUFFER 0th location - parse it
    Status = DigestParser2(pChalInputToken, MD5_AUTH_NAMES, MD5_AUTH_LAST, &Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: DigestParser error status 0x%x\n", Status));
        goto CleanUp;
    }

    // Check to see if we have an old context passed in or need to create a new one
    if (OldContextHandle)
    {
        // Old Context passed in - locate the security context and use that
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Passed in OldContextHandle 0x%lx - lookup in list\n", OldContextHandle));
        Status = CtxtHandlerHandleToContext(OldContextHandle, FALSE, &pContext);
        if (!NT_SUCCESS (Status))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: CtxtHandlerHandleToContext error 0x%x\n", Status));
            goto CleanUp;
        }
        bLockedContext = TRUE;
    }
    else
    {
        // Need to create a context for this connection - destroy if unsuccessful auth
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: No OldContextHandle - create new Context\n"));
        pNewContext = (PDIGEST_CONTEXT)DigestAllocateMemory(sizeof(DIGEST_CONTEXT));
        if (!pNewContext)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: out of memory on challenge context\n"));
            goto CleanUp;
        }
    
        CredPrint(pCredential);
    
        // Initialize new context
        Status = ContextInit(pNewContext, pCredential);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: ContextInit error status 0x%x\n", Status));
            goto CleanUp;
        }
        pContext = pNewContext;                       // for filling in the context information
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: New Context Created   0x%x\n", pContext));
    }

    if (pContext && pContext->strResponseAuth.Length)
    {
        // We have already generated session key from challenge response
        // now checking response auth from server

        if (Digest.refstrParam[MD5_AUTH_RSPAUTH].Length != MD5_HASH_HEX_SIZE)
        {
            Status = STATUS_MUTUAL_AUTHENTICATION_FAILED;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: RspAuth incorrect size\n"));
            goto CleanUp;
        }

        // Now compare the response auth strings
        if (!RtlEqualString(&(pContext->strResponseAuth),
                           &(Digest.refstrParam[MD5_AUTH_RSPAUTH]),
                           FALSE))
        {
            Status = STATUS_MUTUAL_AUTHENTICATION_FAILED;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: RspAuth is incorrect\n"));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE, "SpInitLsaModeContext: RspAuth matches!\n"));

        // ResponseAuth is verified - generate mapped context
        *fContextAttributes = pContext->ContextReq; // Return the ISC Attributes set on Context
        *NewContextHandle = (ULONG_PTR)pContext;    // Just report back with the updated context
        pOutputToken->cbBuffer = 0;          // No output buffer
        if (pExpirationTime)
        {
            *pExpirationTime = pContext->PasswordExpires;
        }

        Status = SspMapDigestContext(pContext, NULL , ContextData);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext, SspMapContext Status 0x%x\n", Status));
            goto CleanUp;
        }

        // this is final call, indicate to map the context
        *MappedContext = TRUE;

        goto CleanUp;
    }


    // Determine if we are in HTTP or SASL mode
    // SASL mode has 1 or less buffers provided,  HTTP has 3
    if (InputBuffers->cBuffers > 1)
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }
    else
    {
        typeDigestMode = DIGESTMODE_SASL;
    }

        // HTTP has special Buffer needs in that it must pass in the METHOD, HEntity
    if (typeDigestMode == DIGESTMODE_HTTP)
    {
        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 1,   // get the second SECBUFFER_TOKEN 
                                 &pMethodInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pMethodInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {                           // Check to make sure that string is present
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: SspGetTokenBufferByIndex (MethodInputToken) status 0x%x\n", Status));
            goto CleanUp;
        }

        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 2,   // get the third SECBUFFER_TOKEN
                                 &pHEntityInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pHEntityInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: SspGetTokenBufferByIndex (HEntityInputToken)   status 0x%x\n", Status));
            goto CleanUp;
        }

        // Verify that there is a valid Method provided
        if (!pMethodInputToken->pvBuffer || !pMethodInputToken->cbBuffer ||
            (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Method SecBuffer must have valid method string status 0x%x\n", Status));
            goto CleanUp;
        }

        iTemp = strlencounted((char *)pMethodInputToken->pvBuffer, pMethodInputToken->cbBuffer);
        if (!iTemp)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Method SecBuffer must have valid method string status 0x%x\n", Status));
            goto CleanUp;
        }
        Digest.refstrParam[MD5_AUTH_METHOD].Length = (USHORT)iTemp;
        Digest.refstrParam[MD5_AUTH_METHOD].MaximumLength = (unsigned short)(pMethodInputToken->cbBuffer);
        Digest.refstrParam[MD5_AUTH_METHOD].Buffer = (char *)pMethodInputToken->pvBuffer;       // refernce memory - no alloc!!!!

        // Check to see if we have H(Entity) data to utilize


        if (pHEntityInputToken->cbBuffer)
        {
            // Verify that there is a valid Method provided
            if (!pHEntityInputToken->pvBuffer || (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
            {
                Status = SEC_E_INVALID_TOKEN;
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: HEntity SecBuffer must have valid string status 0x%x\n", Status));
                goto CleanUp;
            }

            iTemp = strlencounted((char *)pHEntityInputToken->pvBuffer, pHEntityInputToken->cbBuffer);

            if ((iTemp != 0) && (iTemp != (MD5_HASH_BYTESIZE * 2)))
            {
                Status = SEC_E_INVALID_TOKEN;
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: HEntity SecBuffer must have valid MD5 Hash data 0x%x\n", Status));
                goto CleanUp;
            }

            if (iTemp)
            {
                Digest.refstrParam[MD5_AUTH_HENTITY].Length = (USHORT)iTemp;
                Digest.refstrParam[MD5_AUTH_HENTITY].MaximumLength = (unsigned short)(pHEntityInputToken->cbBuffer);
                Digest.refstrParam[MD5_AUTH_HENTITY].Buffer = (char *)pHEntityInputToken->pvBuffer;       // refernce memory - no alloc!!!!
            }
        }

        typeDigest = DIGEST_CLIENT;


        // Determine which Algorithm to support under HTTP
        Status = CheckItemInList(MD5_SESSSTR, &(Digest.refstrParam[MD5_AUTH_ALGORITHM]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            // Check if MD5 specified (or none specified so MD5 defaults)
            Status = CheckItemInList(MD5STR, &(Digest.refstrParam[MD5_AUTH_ALGORITHM]), FALSE);
            if (NT_SUCCESS(Status) || (Digest.refstrParam[MD5_AUTH_ALGORITHM].Length == 0))
            {
                typeAlgorithm = MD5;
                DebugLog((DEB_TRACE, "SpInitLsaModeContext: Server allows MD5 (or defaulted); selected as algorithm\n"));
            }
            else
            {
                Status = SEC_E_QOP_NOT_SUPPORTED;
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: Unknown Server algorithms provided\n"));
                goto CleanUp;
            }
        }
        else
        {
            typeAlgorithm = MD5_SESS;
            fContextAttr |= (ISC_RET_REPLAY_DETECT | ISC_RET_SEQUENCE_DETECT);
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Server allows MD5-sess; selected as algorithm\n"));
        }
    }
    else
    {
        // All others follow the SASL Interface so there are default values
        typeDigest = SASL_CLIENT;
        fContextAttr |= ISC_RET_MUTUAL_AUTH;   // require response auth from server

        // SASL supports only MD5-Sess verify that server offered this
        Status = CheckItemInList(MD5_SESSSTR, &(Digest.refstrParam[MD5_AUTH_ALGORITHM]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Unknown Server algorithm provided\n"));
            goto CleanUp;
        }
        else
        {
            typeAlgorithm = MD5_SESS;
            fContextAttr |= (ISC_RET_REPLAY_DETECT | ISC_RET_SEQUENCE_DETECT);
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Server allows MD5-sess; selected as algorithm\n"));
        }


        // Set Method to Authenticate
        RtlInitString(&strcSASLMethod, AUTHENTICATESTR);
        StringReference(&(Digest.refstrParam[MD5_AUTH_METHOD]), &strcSASLMethod);  // refernce memory - no alloc!!!!

        RtlInitString(&strcSASLHEntity, ZERO32STR);
        StringReference(&(Digest.refstrParam[MD5_AUTH_HENTITY]), &strcSASLHEntity);  // refernce memory - no alloc!!!!

    }

    // Determine if we can process the QOP specified - check return in client if consistent
    if (fContextReqFlags & ISC_REQ_CONFIDENTIALITY)
    {
        // make sure that server presented the auth-conf option
        Status = CheckItemInList(AUTHCONFSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            // Failed to provide necessary QOP
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Server failed to provide QOP=AUTH-CONF\n"));
            goto CleanUp;
        }
        // OK agreed to QOP
        fContextAttr |= (ISC_RET_CONFIDENTIALITY | ISC_RET_INTEGRITY);
        typeQOP = AUTH_CONF;
    }
    else if (fContextReqFlags & ISC_REQ_INTEGRITY)
    {
        // make sure that server presented the auth-int option
        Status = CheckItemInList(AUTHINTSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            // Failed to provide necessary QOP
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Server failed to provide QOP=AUTH-INT\n"));
            goto CleanUp;
        }
        // OK agreed to QOP
        fContextAttr |= ISC_RET_INTEGRITY;
        typeQOP = AUTH_INT;
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Client selected QOP=AUTH-INT\n"));
    }
    else
    {
        // no client specified QOP so use auth if allowed  (backwards compat may have no QOP presented from server)
        Status = CheckItemInList(AUTHSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            // either QOP is not specified or all options are unknown
            if (Digest.refstrParam[MD5_AUTH_QOP].Length == 0)
            {
                // Backwards compatibility with RFC 2069
                typeQOP = NO_QOP_SPECIFIED;
                DebugLog((DEB_TRACE, "SpInitLsaModeContext: No QOP specified - back compat with RFC 2069\n"));
            }
            else
            {
                Status = SEC_E_QOP_NOT_SUPPORTED;
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: Server failed to provide QOP=AUTH\n"));
                goto CleanUp;
            }
        }
        else
        {
            // defaulting to AUTH
            typeQOP = AUTH;
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Client selected QOP=AUTH by default\n"));
        }
    }

    // Check to see if the Server has provided character set for encoding - only UTF-8 accepted
    Status = CheckItemInList(MD5_UTF8STR, &(Digest.refstrParam[MD5_AUTH_CHARSET]), TRUE);
    if (NT_SUCCESS(Status))
    {
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Server allows UTF-8 encoding\n"));

        // Determine which character set to utilize
        if (((typeDigest == SASL_CLIENT) && (g_fParameter_UTF8SASL == TRUE)) ||
            ((typeDigest == DIGEST_CLIENT) && (g_fParameter_UTF8HTTP == TRUE)))
        {
            typeCharset = UTF_8;
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selected UTF-8 encoding\n"));
        }
        else
        {
            typeCharset = ISO_8859_1;
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selected ISO 8859-1 encoding\n"));
        }
    }

    // Pull in the URI provided in TargetName - replace any value in challenge string - link ONLY no allocate
    if (!pustrTargetName)
    {
        Status = SEC_E_TARGET_UNKNOWN;
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: URI TargetName must have valid UnicodeString\n"));
        goto CleanUp;
    }

    Status = EncodeUnicodeString(pustrTargetName, CP_8859_1, &strTargetName, &fDefChars);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "SpInitLsaModeContext: Error in encoding target URI in ISO-8859-1\n"));
        goto CleanUp;
    }

    if (fDefChars == TRUE)
    {
        // We could not encode the provided target URI within ISO 8859-1 characters
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Target URI can not be encoded in ISO 8859-1\n"));
        Status = STATUS_UNMAPPABLE_CHARACTER;
        goto CleanUp;
    }

    StringReference(&(Digest.refstrParam[MD5_AUTH_URI]), &strTargetName);  // refernce memory - no alloc!!!!

            // Create the CNonce
    Status = OpaqueCreate(&(pContext->strCNonce));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: OpaqueCreate for CNonce      status 0x%x\n", Status));
        goto CleanUp;
    }

    // Establish the Client Nonce
    StringReference(&(Digest.refstrParam[MD5_AUTH_CNONCE]), &(pContext->strCNonce));  // refernce memory - no alloc!!!!


    // Keep a copy of the Nonce and Cnonce for future Delegation requests (actually not used in client ISC)
    Status = StringDuplicate(&pContext->strNonce, &Digest.refstrParam[MD5_AUTH_NONCE]);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: StringDuplicate CNonce failed      status 0x%x\n", Status));
        goto CleanUp;
    }
    
    // check to make sure that there was an initial Realm provided
    if ((typeDigestMode == DIGESTMODE_HTTP) && (!Digest.refstrParam[MD5_AUTH_REALM].Length))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Server failed to provide a Realm in Challenge   status 0x%x\n", Status));
        goto CleanUp;
    }

    RtlInitString(&strcNC, NCFIRST);
    StringReference(&(Digest.refstrParam[MD5_AUTH_NC]), &strcNC);  // refernce memory - no alloc!!!!

    // Set the type of Digest Parameters we are to process
    pContext->typeDigest = typeDigest;
    pContext->typeAlgorithm = typeAlgorithm;
    pContext->typeQOP = typeQOP;
    pContext->typeCipher = CIPHER_UNDEFINED;
    pContext->typeCharset = typeCharset;    // Digest parameter will be set in DigestGenerateParameters call

    if (pContext->typeQOP == AUTH_CONF)
    {
        // Check if server offered RC4  Most cases this will be the cipher selected
        Status = CheckItemInList(STR_CIPHER_RC4, &(Digest.refstrParam[MD5_AUTH_CIPHER]), FALSE);
        if (NT_SUCCESS(Status))
        {
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selecting RC4 for auth-conf cipher\n"));
            pContext->typeCipher = CIPHER_RC4;
        }
        else
        {
            Status = CheckItemInList(STR_CIPHER_3DES, &(Digest.refstrParam[MD5_AUTH_CIPHER]), FALSE);
            if (NT_SUCCESS(Status))
            {
                DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selecting Triple DES for auth-conf cipher\n"));
                pContext->typeCipher = CIPHER_3DES;
            }
            else
            {
                Status = CheckItemInList(STR_CIPHER_RC4_56, &(Digest.refstrParam[MD5_AUTH_CIPHER]), FALSE);
                if (NT_SUCCESS(Status))
                {
                    DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selecting RC4-56 for auth-conf cipher\n"));
                    pContext->typeCipher = CIPHER_RC4_56;
                }
                else
                {
                    Status = CheckItemInList(STR_CIPHER_RC4_40, &(Digest.refstrParam[MD5_AUTH_CIPHER]), FALSE);
                    if (NT_SUCCESS(Status))
                    {
                        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selecting RC4-40 for auth-conf cipher\n"));
                        pContext->typeCipher = CIPHER_RC4_40;
                    }
                    else
                    {
                        Status = CheckItemInList(STR_CIPHER_DES, &(Digest.refstrParam[MD5_AUTH_CIPHER]), FALSE);
                        if (NT_SUCCESS(Status))
                        {
                            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selecting DES for auth-conf cipher\n"));
                            pContext->typeCipher = CIPHER_DES;
                        }
                        else
                        {
                            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Failed to find known ciper in list\n"));
                            Status = STATUS_CRYPTO_SYSTEM_INVALID;
                            goto CleanUp;
                        }
                    }
                }
            }
        }
    }

    // Check if server specified a MaxBuffer
    if (Digest.refstrParam[MD5_AUTH_MAXBUF].Length && Digest.refstrParam[MD5_AUTH_MAXBUF].Buffer)
    {
        if (Digest.refstrParam[MD5_AUTH_MAXBUF].Length < MAXBUFNUMLEN)
        {
            ULONG ulMaxBuf = 0;
            CHAR  czMaxBuf[MAXBUFNUMLEN + 1];

            ZeroMemory(czMaxBuf, (MAXBUFNUMLEN + 1));
            memcpy(czMaxBuf, Digest.refstrParam[MD5_AUTH_MAXBUF].Buffer, Digest.refstrParam[MD5_AUTH_MAXBUF].Length);

            Status = RtlCharToInteger(czMaxBuf, TENBASE, &ulMaxBuf);
            if (!NT_SUCCESS(Status))
            {
                Status =  SEC_E_ILLEGAL_MESSAGE;
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: MaxBuf directive value malformed 0x%x\n", Status));
                goto CleanUp;
            }
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Server MaxBuf set to %lu\n", ulMaxBuf));
            pContext->ulSendMaxBuf = ulMaxBuf;
        }
        else
        {
            Status =  SEC_E_ILLEGAL_MESSAGE;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: MaxBuf directive value too large 0x%x\n", Status));
            goto CleanUp;
        }
    }

    // We now have completed setup for the digest fields - time to process the data

    DebugLog((DEB_TRACE, "SpInitLsaModeContext: Digest inputs processing completed\n"));

    ContextPrint(pContext);

    Status = DigestGenerateParameters(pContext, &Digest, &ReplyBuffer);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: DigestGenerateParameters error  status 0x%x\n", Status));
        goto CleanUp;
    }

        // Now transfer the Challenge buffer to the ouput secbuffer
    if ((fContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
    {
        if (pOutputToken->cbBuffer < ReplyBuffer.cbBuffer)
        {
            DebugLog((DEB_ERROR,"SpInitLsaModeContext: Output token is too small - sent in %d, needed %d\n",
                pOutputToken->cbBuffer, ReplyBuffer.cbBuffer));
            pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
            Status = STATUS_BUFFER_TOO_SMALL;
            goto CleanUp;
        }

        RtlCopyMemory(pOutputToken->pvBuffer, ReplyBuffer.pvBuffer, ReplyBuffer.cbBuffer);
        pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
    }
    else
    {
        pOutputToken->pvBuffer = ReplyBuffer.pvBuffer;
        pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
        ReplyBuffer.pvBuffer = NULL;
        ReplyBuffer.cbBuffer = 0;
        fContextAttr |= ISC_RET_ALLOCATED_MEMORY;
    }

    pContext->ContextReq = fContextAttr;
    pContext->PasswordExpires = g_TimeForever;   // never expire

    *fContextAttributes = pContext->ContextReq; // Return the ISC Attributes set on Context
    *NewContextHandle = (ULONG_PTR)pContext;    // Just report back with the updated context
    if (pExpirationTime)
    {
        *pExpirationTime = pContext->PasswordExpires;

        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Context Expiration TimeStamp  high/low 0x%x/0x%x\n",
                  pExpirationTime->HighPart, pExpirationTime->LowPart));
    }

    // Check if need to check server's response auth
    if (pContext->ContextReq & ISC_RET_MUTUAL_AUTH)
    {
        // Calculate the expected response auth from the server
        Status = DigestCalculateResponseAuth(&Digest, &(pContext->strResponseAuth));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext, DigestCalculateResponseAuth Status 0x%x\n",
                       Status));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Pre-calculated RspAuth %Z\n",
                  &(pContext->strResponseAuth)));

        // Keep copy of digest values for context map on last ISC call
        for (iTemp = 0; iTemp < MD5_AUTH_LAST; iTemp++)
        {
            StringDuplicate(&pContext->strDirective[iTemp], &(Digest.refstrParam[iTemp]));
        }

        // Need to verify the output from final ASC call to verify server has session key
        Status = SEC_I_CONTINUE_NEEDED;
    }
    else
    {
        Status = SspMapDigestContext(pContext, &Digest, ContextData);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext, SspMapContext Status 0x%x\n", Status));
            goto CleanUp;
        }

        // this is last call, indicate to map the context
        *MappedContext = TRUE;
    }

    // Add the Newly created Context into the list of Contexts unless it was there before
    if (pNewContext)
    {
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Added context   0x%x\n", pNewContext));
        pNewContext->lReferences = 1;
        CtxtHandlerInsertCred(pNewContext);
        // bLockedContext = TRUE;               // Release memory to CtxtHandler
        pNewContext = NULL;                  // We no longer own this memory - turned over to CtxtHandler
    }

    DebugLog((DEB_TRACE, "SpInitLsaModeContext: Will create UserContext on exit\n"));

CleanUp:

    // Failed to complete operations if non-NULL so clean up
    if (pNewContext)
    {
        ContextFree(pNewContext);
        pNewContext = NULL;
    }

    // DeReference - pCredential
    if (pCredential)
    {
        SubStatus = CredHandlerRelease(pCredential);
        if (!NT_SUCCESS(SubStatus))
        {
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: CredHandlerRelease error  Status 0x%x\n", SubStatus));
            if (NT_SUCCESS(Status))
            {
                Status = SubStatus;    // Indicate release error
            }
        }
        pCredential = NULL;
    }

    if (bLockedContext && pContext)
    {   // happened only if ref counted a SecurityContext
        SubStatus = CtxtHandlerRelease(pContext);
        if (!NT_SUCCESS(SubStatus))
        {
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: CtxtHandlerRelease error Status 0x%x\n", SubStatus));
            if (NT_SUCCESS(Status))
            {
                Status = SubStatus;    // Indicate release error
            }
        }
        pContext = NULL;
    }

        // Free up any allocated memory from the ouput reply buffer
    if (ReplyBuffer.pvBuffer)
    {
        DigestFreeMemory(ReplyBuffer.pvBuffer);
        ReplyBuffer.pvBuffer = NULL;
        ReplyBuffer.cbBuffer = 0;
    }

    // Clean up local memory used by Digest
    DigestFree(&Digest);

    StringFree(&strTargetName);

    DebugLog((DEB_TRACE, "SpInitLsaModeContext: Mapped context %d    Flags IN:0x%lx  OUT:0x%lx\n",
               *MappedContext, fContextReqFlags,*fContextAttributes));

    DebugLog((DEB_TRACE_FUNC, "SpInitLsaModeContext: Leaving  Context 0x%x   Status 0x%x\n", *NewContextHandle, Status));

    return(Status);
}



NTSTATUS NTAPI
SpApplyControlToken(
                   IN ULONG_PTR ContextHandle,
                   IN PSecBufferDesc ControlToken
                   )
{
    DebugLog((DEB_TRACE_FUNC, "SpApplyControlToken: Entering/Leaving \n"));
    UNREFERENCED_PARAMETER(ContextHandle);
    UNREFERENCED_PARAMETER(ControlToken);
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptLsaModeContext
//
//  Synopsis:   Digest implementation of AcceptSecurityContext call.
//
//  Effects:
//
//  Arguments:
//   CredentialHandle - Handle to the credentials to be used to
//       create the context.
//
//   OldContextHandle - Handle to the partially formed context, if this is
//       a second call (see above) or NULL if this is the first call.
//
//   InputToken - Pointer to the input token.  In the first call this
//       token can either be NULL or may contain security package specific
//       information.
//
//   ContextReqFlags - Requirements of the context, package specific.
//
//      #define ASC_REQ_REPLAY_DETECT    0x00000004
//      #define ASC_REQ_SEQUENCE_DETECT  0x00000008
//      #define ASC_REQ_CONFIDENTIALITY  0x00000010
//      #define ASC_REQ_ALLOCATE_MEMORY 0x00000100
//
//   TargetDataRep - Long indicating the data representation (byte ordering, etc)
//        on the target.  The constant SECURITY_NATIVE_DREP may be supplied
//        by the transport indicating that the native format is in use.
//
//   NewContextHandle - New context handle.  If this is a second call, this
//       can be the same as OldContextHandle.
//
//   OutputToken - Buffer to receive the output token.
//
//   ContextAttributes -Attributes of the context established.
//
//        #define ASC_RET_REPLAY_DETECT     0x00000004
//        #define ASC_RET_SEQUENCE_DETECT   0x00000008
//        #define ASC_RET_CONFIDENTIALITY   0x00000010
//        #define ASC_RET_ALLOCATED_BUFFERS 0x00000100
//
//   ExpirationTime - Expiration time of the context.
//
//
//  Requires:
//
//  Returns:
//    STATUS_SUCCESS - Message handled
//    SEC_I_CONTINUE_NEEDED -- Caller should call again later
//
//    SEC_E_NO_SPM -- Security Support Provider is not running
//    SEC_E_INVALID_TOKEN -- Token improperly formatted
//    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
//    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
//    SEC_E_LOGON_DENIED -- User is no allowed to logon to this server
//    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpAcceptLsaModeContext(
                      IN OPTIONAL ULONG_PTR CredentialHandle,
                      IN OPTIONAL ULONG_PTR OldContextHandle,
                      IN PSecBufferDesc InputBuffers,
                      IN ULONG fContextReqFlags,
                      IN ULONG TargetDataRep,
                      OUT PULONG_PTR NewContextHandle,
                      OUT PSecBufferDesc OutputBuffers,
                      OUT PULONG fContextAttributes,
                      OUT PTimeStamp pExpirationTime,
                      OUT PBOOLEAN MappedContext,
                      OUT PSecBuffer ContextData
                      )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    NTSTATUS AuditLogStatus = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "SpAcceptLsaModeContext: Entering \n"));

    SecBuffer TempTokens[6];
    PSecBuffer pChalRspInputToken;
    PSecBuffer pMethodInputToken;
    PSecBuffer pURIInputToken;
    PSecBuffer pHEntityInputToken;
    PSecBuffer pOutputToken;
    PSecBuffer pRealmInputToken;
    DIGEST_PARAMETER Digest;
    PDIGEST_CONTEXT pNewContext = NULL;            // keep pointer to release new context on error
    BOOL bLockedCredential = FALSE;
    BOOL bLockedContext = FALSE;
    BOOL fLogonSessionCreated = FALSE;

    SecBuffer ReplyBuffer;                         // Output is generated in this buffer

    int iTemp = 0;

    char *cptr = NULL;


    ULONG  fContextAttr = ASC_REQ_REPLAY_DETECT;    // Flags on the Attributes of the context
    DIGEST_TYPE typeDigest = NO_DIGEST_SPECIFIED;
    QOP_TYPE typeQOP = NO_QOP_SPECIFIED;
    ALGORITHM_TYPE typeAlgorithm = NO_ALGORITHM_SPECIFIED;
    CHARSET_TYPE typeCharset = ISO_8859_1;
    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;   // Are we in SASL or HTTP mode

    LARGE_INTEGER  liContextTime = { 0xFFFFFFFF, 0x7FFFFFFF };     // initial set to forever

    PDIGEST_CREDENTIAL pCredential = NULL; 
    PDIGEST_CONTEXT pContext = NULL; 

    STRING strcMethod;
    STRING strcHEntity;
    STRING strRealm;
    UNICODE_STRING refustrRealm;

    BOOL fDefChars = FALSE;

    // Create pointers to tokens for processing
    pChalRspInputToken = &TempTokens[0];
    pMethodInputToken = &TempTokens[1];
    pURIInputToken = &TempTokens[2];
    pHEntityInputToken = &TempTokens[3];
    pRealmInputToken = &TempTokens[4];
    pOutputToken = &TempTokens[5];
    DigestInit(&Digest);

    ZeroMemory(TempTokens,sizeof(TempTokens));
    ZeroMemory(&strcMethod, sizeof(strcMethod));
    ZeroMemory(&strcHEntity, sizeof(strcHEntity));
    ZeroMemory(&strRealm, sizeof(strRealm));
    ZeroMemory(&refustrRealm, sizeof(refustrRealm));

    ZeroMemory(&ReplyBuffer, sizeof(ReplyBuffer));

      // Initialize the output values
    if (!fContextAttributes || !NewContextHandle || !InputBuffers || !OutputBuffers)
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Invalid arg (possible NULL pointer)\n"));
        return STATUS_INVALID_PARAMETER;
    }

    *NewContextHandle = (ULONG_PTR)NULL;
    *MappedContext = FALSE;
    *fContextAttributes = 0;
    if (pExpirationTime)
    {
        *pExpirationTime = g_TimeForever;
    }
    ContextData->pvBuffer = NULL;
    ContextData->cbBuffer = 0;


    // Determine if we are in HTTP or SASL mode
    // SASL mode has 1 or less buffers provided,  HTTP has 5
    if (InputBuffers->cBuffers > 1)
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }
    else
    {
        typeDigestMode = DIGESTMODE_SASL;
    }

    // Must have a Credential Handle to perform processing
    Status = CredHandlerHandleToPtr(CredentialHandle, FALSE, &pCredential);
    if (!NT_SUCCESS(Status))
    {
        Status = SEC_E_UNKNOWN_CREDENTIALS;
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: No Credential Handle passed\n"));
        goto CleanUp;
    }
    bLockedCredential = TRUE;


    // Verify that credential is marked INBOUND for ASC call
    if (!(pCredential->CredentialUseFlags & DIGEST_CRED_INBOUND))
    {
        Status = SEC_E_NOT_SUPPORTED;
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Credential not marked for Inbound connections\n"));
        goto CleanUp;
    }

    // Retrieve the information from the SecBuffers & check proper formattting

    // First check to make sure that that the proper number of buffers were passed
    if (typeDigestMode == DIGESTMODE_HTTP)
    {
        // HTTP has 5 buffers in Input: ChallengeResponse, Method, URI, HEntity, Realm
        if ((InputBuffers->cBuffers < ASC_HTTP_NUM_INPUT_BUFFERS) ||
            (OutputBuffers->cBuffers < ASC_HTTP_NUM_OUTPUT_BUFFERS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Incorrect number of Input/Output HTTP Sec Buffers\n"));
            goto CleanUp;
        }
    }
    else
    {
        // SASL has 1 buffer in Input: ChallengeResponse
        if ((InputBuffers->cBuffers < ASC_SASL_NUM_INPUT_BUFFERS) ||
            (OutputBuffers->cBuffers < ASC_SASL_NUM_OUTPUT_BUFFERS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Incorrect number of Input/Ouput SASL Sec Buffers\n"));
            goto CleanUp;
        }
        fContextAttr |= ASC_RET_MUTUAL_AUTH;   // SASL requires response auth from server
    }

    if ( !SspGetTokenBufferByIndex( InputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &pChalRspInputToken,
                             TRUE ) ||
         !ContextIsTokenOK(pChalRspInputToken,NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: SspGetTokenBufferByIndex (ChalRspInputToken) returns 0x%x\n", Status));
        goto CleanUp;
    }

    if ( !SspGetTokenBufferByIndex( OutputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &pOutputToken,
                             FALSE )  ||
         !ContextIsTokenOK(pOutputToken, 0))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext, SspGetTokenBufferByIndex (OutputToken) returns 0x%x\n", Status));
        goto CleanUp;
    }


    if (fContextReqFlags & ASC_REQ_ALLOCATE_MEMORY)
    {
        pOutputToken->pvBuffer = NULL;
        pOutputToken->cbBuffer = 0;
    }

    // Reset output buffer if provided
    if ((pOutputToken->pvBuffer) && (pOutputToken->cbBuffer >= 1))
    {
        cptr = (char *)pOutputToken->pvBuffer;
        *cptr = '\0';
    }

    //
    // If no ChallengeResponse data provided (only NULL in buffer), then this is the first call
    // Determine a nonce, open up a null context, and return it. Return SEC_E_INCOMPLETE_MESSAGE to
    // indicate that a challenge-response is expected
    //

    if ((!pChalRspInputToken->pvBuffer) || (pChalRspInputToken->cbBuffer <= 1))
    {

        pNewContext = (PDIGEST_CONTEXT)DigestAllocateMemory(sizeof(DIGEST_CONTEXT));
        if (!pNewContext)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: out of memory on challenge context\n"));
            goto CleanUp;
        }
        Status = ContextInit(pNewContext, pCredential);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: ContextInit error 0x%x\n", Status));
            goto CleanUp;
        }

        if (typeDigestMode == DIGESTMODE_HTTP)
        {
           typeDigest = DIGEST_SERVER;
        }
        else
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: SASL Requested\n"));
            typeDigest = SASL_SERVER;
        }
        pNewContext->typeDigest = typeDigest;

        // Determine which character set to utilize
        if (((typeDigest == SASL_SERVER) && (g_fParameter_UTF8SASL == TRUE)) ||
            ((typeDigest == DIGEST_SERVER) && (g_fParameter_UTF8HTTP == TRUE)))
        {
            typeCharset = UTF_8;
        }
        else
        {
            typeCharset = ISO_8859_1;
        }
        pNewContext->typeCharset = typeCharset;
        
        // We will use the Opaque as the CNonce
        Status = OpaqueCreate(&(pNewContext->strOpaque));
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: OpaqueCreate error 0x%x\n", Status));
            goto CleanUp;
        }

        Status = NonceCreate(&(pNewContext->strNonce));
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: NonceCreate error 0x%x\n", Status));
            goto CleanUp;
        }

        if (pNewContext->typeDigest == DIGEST_SERVER)
        {
           // Now see if a Realm was passed in to use for this challenge - the value could be single byte or Unicode 
           // Order is if realm passed to ASC use that, else  just use the current domain name

           if ( !SspGetTokenBufferByIndex( InputBuffers,
                                    4,   // get the fifth SECBUFFER_TOKEN
                                    &pRealmInputToken,
                                    TRUE ) ||
                !ContextIsTokenOK(pRealmInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
           {
               Status = SEC_E_INVALID_TOKEN;
               DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: SspGetTokenBufferByIndex (RealmInputToken) returns 0x%x\n", Status));
               goto CleanUp;
           }

           iTemp = 0;
           if (pRealmInputToken->cbBuffer)
           {
               if (!pRealmInputToken->pvBuffer)
               {
                   Status = SEC_E_INVALID_TOKEN;
                   DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: No input buffer (RealmInputToken)    error 0x%x\n", Status));
                   goto CleanUp;
               }

               if (PBUFFERTYPE(pRealmInputToken) == SECBUFFER_PKG_PARAMS)
               {
                   iTemp = ustrlencounted((const short *)pRealmInputToken->pvBuffer, pRealmInputToken->cbBuffer);
                   if (iTemp > 0)
                   {
                       refustrRealm.Length = (USHORT)(iTemp * sizeof(WCHAR));
                       refustrRealm.MaximumLength = (unsigned short)(pRealmInputToken->cbBuffer);
                       refustrRealm.Buffer = (PWSTR)pRealmInputToken->pvBuffer;       // refernce memory - no alloc!!!!

                       // Check if OK to use UTF-8 encoding
                       if (pNewContext->typeCharset == UTF_8)
                       {
                           Status = EncodeUnicodeString(&refustrRealm, CP_UTF8, &strRealm, NULL);
                           if (!NT_SUCCESS(Status))
                           {
                               DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Input Realm UTF-8 encoding error\n"));
                               goto CleanUp;
                           }

                       }
                       else
                       {
                           Status = EncodeUnicodeString(&refustrRealm, CP_8859_1, &strRealm, &fDefChars);
                           if (!NT_SUCCESS(Status))
                           {
                               DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Input Realm ISO 8859-1 encoding error\n"));
                               goto CleanUp;
                           }
                           if (fDefChars == TRUE)
                           {
                               // We could not encode the provided Realm within ISO 8859-1 characters
                               DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Input Realm can not be encoded in ISO 8859-1\n"));
                               Status = STATUS_UNMAPPABLE_CHARACTER;
                               goto CleanUp;
                           }

                       }
                   }
               }
               else
               {
                   Status = SEC_E_INVALID_TOKEN;
                   DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Realm buffer type invalid   error 0x%x\n", Status));
                   goto CleanUp;
               }
           }
           
        }

        typeAlgorithm = MD5_SESS;
        pNewContext->typeAlgorithm = typeAlgorithm;

        // Determine if we can process the QOP specified
        if (fContextReqFlags & ASC_REQ_CONFIDENTIALITY)
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: AUTH-CONF requested\n"));
            fContextAttr |= (ASC_RET_CONFIDENTIALITY | ASC_REQ_INTEGRITY);
            typeQOP = AUTH_CONF;               // Offer AUTH-CONF, AUTH_INT, and AUTH
        }
        else if (fContextReqFlags & ASC_REQ_INTEGRITY)
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: AUTH-INT requested\n"));
            fContextAttr |= ASC_RET_INTEGRITY;
            typeQOP = AUTH_INT;               // Offer AUTH-INT and AUTH
        }
        else
            typeQOP = AUTH;                   // Offer AUTH

        // Stale directive will be set if VerifyMessage indicates that context expired.
        // Application indicates if the challenge should indicate Stale
        if (fContextReqFlags & ASC_REQ_STALE)
        {
            fContextAttr |= ASC_RET_STALE;
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Requested stale flag be indicated\n"));
        }

        pNewContext->typeQOP = typeQOP;

        // Establish the attribute flags for this security context
        pNewContext->ContextReq = fContextAttr;

        Status = ContextCreateChal(pNewContext, &strRealm, &ReplyBuffer);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Failed to create Challenge   status 0x%x\n", Status));
            goto CleanUp;
        }

            // Now transfer the Challenge buffer to the ouput secbuffer
        if ((fContextReqFlags & ASC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if (pOutputToken->cbBuffer < ReplyBuffer.cbBuffer)
            {
                DebugLog((DEB_ERROR,"SpAcceptLsaModeContext:Output token is too small - sent in %d, needed %d\n",
                    pOutputToken->cbBuffer, ReplyBuffer.cbBuffer));
                pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
                Status = STATUS_BUFFER_TOO_SMALL;
                goto CleanUp;
            }

            RtlCopyMemory(pOutputToken->pvBuffer, ReplyBuffer.pvBuffer, ReplyBuffer.cbBuffer);
            pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
        }
        else
        {
            pOutputToken->pvBuffer = ReplyBuffer.pvBuffer;
            pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
            ReplyBuffer.pvBuffer = NULL;
            ReplyBuffer.cbBuffer = 0;
            fContextAttr |= ASC_RET_ALLOCATED_MEMORY;
        }

        // Update any new attributes
        pNewContext->ContextReq = fContextAttr;

        // Set the time expiration for this context
        // This time is in 100 Nanoseconds since 1604
        Status = NtQuerySystemTime (&liContextTime);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Failed to get current time\n"));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Current TimeStamp  high/low 0x%x/0x%x\n",
                  liContextTime.HighPart, liContextTime.LowPart));

        PrintTimeString(liContextTime, TRUE);

        // g_dwParameter_Lifetime is in number of seconds - convert to number of 100 nanoseconds
        liContextTime.QuadPart += ((LONGLONG)g_dwParameter_Lifetime * (LONGLONG)SECONDS_TO_100NANO);
        if (pExpirationTime)
        {
            *pExpirationTime = liContextTime;

            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Context Expiration TimeStamp  high/low 0x%x/0x%x\n",
                      pExpirationTime->HighPart, pExpirationTime->LowPart));

            PrintTimeString(liContextTime, TRUE);
        }
 
        pNewContext->PasswordExpires = liContextTime;
        pNewContext->lReferences = 1;


        // Add it into the list of Contexts
        CtxtHandlerInsertCred(pNewContext);
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Context added to list Opaque = %s\n", (pNewContext->strOpaque).Buffer));
        // pContext = pNewContext;              // set to have dereferenced
        *NewContextHandle = (ULONG_PTR)pNewContext;
        *fContextAttributes = fContextAttr;            // Return the ASC Attributes set on Context
        // bLockedContext = TRUE;               // Release memory to CtxtHandler
        // bLockedCredential = FALSE;           // Do not Dereference the credential until context is unlinked and freed
        pNewContext = NULL;                  // We no longer own this memory - turned over to CtxtHandler
        Status = SEC_I_CONTINUE_NEEDED;
        goto CleanUp;
    }

    // Processing ChallengeResponse (challenge was handled right before this
    // We have input in the SECBUFFER 0th location - parse it
    Status = DigestParser2(pChalRspInputToken, MD5_AUTH_NAMES, MD5_AUTH_LAST, &Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: DigestParser error 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: DigestParser Returned OK\n"));

    // Do not allow AuthzID processing at this time
    if (Digest.refstrParam[MD5_AUTH_AUTHZID].Length)
    {
        Status = SEC_E_WRONG_PRINCIPAL;
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Can not process AuthzID directives 0x%x\n", Status));
        goto CleanUp;
    }

    // HTTP has special Buffer needs in that it must pass in the METHOD, HEntity
    if (typeDigestMode == DIGESTMODE_HTTP)
    {
        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 1,   // get the second SECBUFFER_TOKEN 
                                 &pMethodInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pMethodInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {                           // Check to make sure that string is present
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: SspGetTokenBufferByIndex (MethodInputToken) returns 0x%x\n", Status));
            goto CleanUp;
        }

        /*                         // Not used in this version, may be used in the future
        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 2,   // get the third SECBUFFER_TOKEN
                                 &pURIInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pURIInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: SspGetTokenBufferByIndex (URIInputToken) returns %d\n", Status));
            goto CleanUp;
        }
        */

        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 3,   // get the forth SECBUFFER_TOKEN
                                 &pHEntityInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pHEntityInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: SspGetTokenBufferByIndex (HEntityInputToken) returns 0x%x\n", Status));
            goto CleanUp;
        }


        // Verify that there is a valid Method provided
        if (!pMethodInputToken->pvBuffer || !pMethodInputToken->cbBuffer ||
            (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Method SecBuffer must have valid method string status 0x%x\n", Status));
            goto CleanUp;
        }

        iTemp = strlencounted((char *)pMethodInputToken->pvBuffer, pMethodInputToken->cbBuffer);
        if (!iTemp)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Method SecBuffer must have valid method string status 0x%x\n", Status));
            goto CleanUp;
        }
        Digest.refstrParam[MD5_AUTH_METHOD].Length = (USHORT)iTemp;
        Digest.refstrParam[MD5_AUTH_METHOD].MaximumLength = (unsigned short)(pMethodInputToken->cbBuffer);
        Digest.refstrParam[MD5_AUTH_METHOD].Buffer = (char *)pMethodInputToken->pvBuffer;       // refernce memory - no alloc!!!!

        // Check to see if we have H(Entity) data to utilize
        if (pHEntityInputToken->cbBuffer)
        {
            // Verify that there is a valid Method provided
            if (!pHEntityInputToken->pvBuffer || (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
            {
                Status = SEC_E_INVALID_TOKEN;
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: HEntity SecBuffer must have valid string status 0x%x\n", Status));
                goto CleanUp;
            }

            iTemp = strlencounted((char *)pHEntityInputToken->pvBuffer, pHEntityInputToken->cbBuffer);

            if ((iTemp != 0) && (iTemp != (MD5_HASH_BYTESIZE * 2)))
            {
                Status = SEC_E_INVALID_TOKEN;
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: HEntity SecBuffer must have valid MD5 Hash data 0x%x\n", Status));
                goto CleanUp;
            }

            if (iTemp)
            {
                Digest.refstrParam[MD5_AUTH_HENTITY].Length = (USHORT)iTemp;
                Digest.refstrParam[MD5_AUTH_HENTITY].MaximumLength = (unsigned short)(pHEntityInputToken->cbBuffer);
                Digest.refstrParam[MD5_AUTH_HENTITY].Buffer = (char *)pHEntityInputToken->pvBuffer;       // refernce memory - no alloc!!!!
            }
        }

        typeDigest = DIGEST_SERVER;
    }
    else
    {
        // All others follow the SASL Interface so there are default values
        typeDigest = SASL_SERVER;

        // Set Method to Authenticate
        RtlInitString(&strcMethod, AUTHENTICATESTR);
        StringReference(&(Digest.refstrParam[MD5_AUTH_METHOD]), &strcMethod);  // refernce memory - no alloc!!!!

        RtlInitString(&strcHEntity, ZERO32STR);
        StringReference(&(Digest.refstrParam[MD5_AUTH_HENTITY]), &strcHEntity);  // refernce memory - no alloc!!!!

    }

    // Since we requested only MD5_SESS in the challenge, the response had better be MD5_SESS too!
    typeAlgorithm = MD5_SESS;
    fContextAttr |= (ASC_RET_REPLAY_DETECT | ASC_RET_SEQUENCE_DETECT);

    if (NT_SUCCESS(CheckItemInList(AUTHCONFSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), TRUE)))
    {
        // client requested AUTH-CONF since privacy requested
        fContextAttr |= (ASC_RET_CONFIDENTIALITY | ASC_RET_INTEGRITY);
        typeQOP = AUTH_CONF;
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client selected QOP=AUTH-CONF\n"));
    }
    else if (NT_SUCCESS(CheckItemInList(AUTHINTSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), TRUE)))
    {
            // client requested AUTH-INT since privacy requested
        fContextAttr |= ASC_RET_INTEGRITY;
        typeQOP = AUTH_INT;
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client selected QOP=AUTH-INT\n"));
    }
    else if (NT_SUCCESS(CheckItemInList(AUTHSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), TRUE)))
    {
        // check to see if client specified auth only
        typeQOP = AUTH;
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client selected QOP=AUTH\n"));
    }
    else     
    {        // Client did not specify any QOP
        if (!Digest.refstrParam[MD5_AUTH_QOP].Length)
        {
            if (typeDigestMode == DIGESTMODE_HTTP)
            {
                typeQOP = NO_QOP_SPECIFIED;      // This is OK - acts like AUTH but response different
                DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client did not specify QOP (HTTP only)\n"));
            }
            else
            {
                typeQOP = AUTH;                 // This is OK - SASL defaults to AUTH
                DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client did not specify QOP, default to AUTH\n"));
            }
        }
        else
        {
            // Failed to provide recognized QOP
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Client failed to provide recognized QOP\n"));
            goto CleanUp;
        }
    }

    //  If there is no OldContextToken passed in, then check for SecurityContext handle (in opaque) else return error
    if ( !ARGUMENT_PRESENT( OldContextHandle ))
    {
        // Search for Reference to SecurityContextHandle
        Status = CtxtHandlerOpaqueToPtr(&(Digest.refstrParam[MD5_AUTH_OPAQUE]), &pContext);
        if (!NT_SUCCESS (Status))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: CtxtHandlerOpaqueToPtr error 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        // We have a SecurityContextHandle to use - see if it is in the ContextList and valid
        Status = CtxtHandlerHandleToContext(OldContextHandle, FALSE, &pContext);
        if (!NT_SUCCESS (Status))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: CtxtHandlerHandleToContext error 0x%x\n", Status));
            goto CleanUp;
        }
    }

    DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Acquired Context ptr for 0x%x\n", pContext));
    bLockedContext = TRUE;
        

        // Can only call AcceptSecurityContect Once after ChallengeResponse
        // For non-persistent connections (no OldContextHandle passed in), just return SCH and return
    if (pContext->strSessionKey.Length)
    {
        if (ARGUMENT_PRESENT( OldContextHandle ))
        {
            Status = STATUS_LOGON_FAILURE;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Multiple call to completed ASC\n"));
            goto CleanUp;
        }
        else
        {
            Status = SEC_I_COMPLETE_NEEDED;
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Opaque located CtxtHandle, return handle, Complete needed\n"));
            *NewContextHandle = (ULONG_PTR)pContext;    // Just report back with the updated context
            pContext = NULL;               
            goto CleanUp;
        }
    }


    // Check to see if the Server has provided character set for encoding - only UTF-8 accepted
    Status = CheckItemInList(MD5_UTF8STR, &(Digest.refstrParam[MD5_AUTH_CHARSET]), TRUE);
    if (NT_SUCCESS(Status))
    {
        // The ChallengeResponse requested UTF-8 encoding, check to see that server allowed this

        if (((typeDigest == SASL_SERVER) && (g_fParameter_UTF8SASL == TRUE)) ||
            ((typeDigest == DIGEST_SERVER) && (g_fParameter_UTF8HTTP == TRUE)))
        {
            typeCharset = UTF_8;
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Server allows UTF-8 encoding\n"));
        }
        else
        {
            // We did not authorize this type of encoding - fail the request
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Client requested UTF-8 server did not offer\n"));
            Status = SEC_E_ILLEGAL_MESSAGE;
            goto CleanUp;
        }
    }

    // We now have a pointer to the Security Context to use, finish up setting up the digestparamter fields

    // Set the type of Digest Parameters we are to process
    pContext->typeDigest = typeDigest;
    pContext->typeAlgorithm = typeAlgorithm;
    pContext->typeQOP = typeQOP;
    pContext->typeCharset = typeCharset;


    if (pContext->typeQOP == AUTH_CONF)
    {
        Status = CheckItemInList(STR_CIPHER_RC4, &(Digest.refstrParam[MD5_AUTH_CIPHER]), TRUE);
        if (NT_SUCCESS(Status))
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Selecting RC4 for auth-conf cipher\n"));
            pContext->typeCipher = CIPHER_RC4;
        }
        else
        {
            Status = CheckItemInList(STR_CIPHER_3DES, &(Digest.refstrParam[MD5_AUTH_CIPHER]), TRUE);
            if (NT_SUCCESS(Status))
            {
                DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Selecting Triple DES for auth-conf cipher\n"));
                pContext->typeCipher = CIPHER_3DES;
            }
            else
            {
                Status = CheckItemInList(STR_CIPHER_RC4_56, &(Digest.refstrParam[MD5_AUTH_CIPHER]), TRUE);
                if (NT_SUCCESS(Status))
                {
                    DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Selecting RC4-56 for auth-conf cipher\n"));
                    pContext->typeCipher = CIPHER_RC4_56;
                }
                else
                {
                    Status = CheckItemInList(STR_CIPHER_RC4_40, &(Digest.refstrParam[MD5_AUTH_CIPHER]), TRUE);
                    if (NT_SUCCESS(Status))
                    {
                        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Selecting RC4-40 for auth-conf cipher\n"));
                        pContext->typeCipher = CIPHER_RC4_40;
                    }
                    else
                    {
                        Status = CheckItemInList(STR_CIPHER_DES, &(Digest.refstrParam[MD5_AUTH_CIPHER]), TRUE);
                        if (NT_SUCCESS(Status))
                        {
                            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Selecting DES for auth-conf cipher\n"));
                            pContext->typeCipher = CIPHER_DES;
                        }
                        else
                        {
                            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Failed to find known ciper selected by client\n"));
                            Status = STATUS_CRYPTO_SYSTEM_INVALID;
                            goto CleanUp;
                        }
                    }
                }
            }
        }
    }

    // Check if client specified a MaxBuffer
    if (Digest.refstrParam[MD5_AUTH_MAXBUF].Length && Digest.refstrParam[MD5_AUTH_MAXBUF].Buffer)
    {
        if (Digest.refstrParam[MD5_AUTH_MAXBUF].Length < MAXBUFNUMLEN)
        {
            ULONG ulMaxBuf = 0;
            CHAR  czMaxBuf[MAXBUFNUMLEN + 1];

            ZeroMemory(czMaxBuf, (MAXBUFNUMLEN + 1));
            memcpy(czMaxBuf, Digest.refstrParam[MD5_AUTH_MAXBUF].Buffer, Digest.refstrParam[MD5_AUTH_MAXBUF].Length);

            Status = RtlCharToInteger(czMaxBuf, TENBASE, &ulMaxBuf);
            if (!NT_SUCCESS(Status))
            {
                Status =  SEC_E_ILLEGAL_MESSAGE;
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: MaxBuf directive value malformed 0x%x\n", Status));
                goto CleanUp;
            }
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client MaxBuf set to %lu\n", ulMaxBuf));
            pContext->ulSendMaxBuf = ulMaxBuf;
        }
        else
        {
            Status =  SEC_E_ILLEGAL_MESSAGE;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: MaxBuf directive value too large 0x%x\n", Status));
            goto CleanUp;
        }
    }

    DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Digest inputs processing completed\n"));

    // ReplyBuffer will contain the ResponseAuth if generated
    Status = DigestProcessParameters(pContext, &Digest, &ReplyBuffer, &AuditLogStatus);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: DigestProcessParameters error 0x%x\n", Status));
        goto CleanUp;
    }

    fLogonSessionCreated = TRUE;   // We have successfully authed the request & created LogonID & Token

    if ((fContextReqFlags & ASC_REQ_ALLOCATE_MEMORY) == 0)
    {
        if (pOutputToken->cbBuffer < ReplyBuffer.cbBuffer)
        {
            DebugLog((DEB_ERROR,"SpAcceptLsaModeContext:Output token is too small - sent in %d, needed %d\n",
                pOutputToken->cbBuffer, ReplyBuffer.cbBuffer));
            pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
            Status = STATUS_BUFFER_TOO_SMALL;
            goto CleanUp;
        }

        RtlCopyMemory(pOutputToken->pvBuffer, ReplyBuffer.pvBuffer, ReplyBuffer.cbBuffer);
        pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
    }
    else
    {
        pOutputToken->pvBuffer = ReplyBuffer.pvBuffer;
        pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
        ReplyBuffer.pvBuffer = NULL;
        ReplyBuffer.cbBuffer = 0;
        fContextAttr |= ASC_RET_ALLOCATED_MEMORY;
    }

    // Establish the attribute flags for this security context
    pContext->ContextReq = fContextAttr;

    // Keep a copy of the Cnonce for future Delegation requests
    Status = StringDuplicate(&pContext->strCNonce, &Digest.refstrParam[MD5_AUTH_CNONCE]);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: StringDuplicate CNonce failed      status 0x%x\n", Status));
        goto CleanUp;
    }

    // Now create a LogonSession for the completed LogonToken contained SecurityContext
    // This can be utilized in delegated digest client's ACH
    DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Adding a LogonSession for successful ASC\n"));
    Status = CtxtCreateLogSess(pContext);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: CtxtCreateLogSess failed      status 0x%x\n", Status));
        goto CleanUp;
    }

    Status = SspMapDigestContext(pContext, &Digest, ContextData);

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext, SspMapContext returns %d\n", Status));
        goto CleanUp;
    }

    *MappedContext = TRUE;

    pContext->ulNC++;                           // Everything verified so increment to next nonce count
    *NewContextHandle = (ULONG_PTR)pContext;    // Just report back with the updated context

    *fContextAttributes = fContextAttr;            // Return the ASC Attributes set on Context


    if (pExpirationTime)
    {
        *pExpirationTime = pContext->PasswordExpires;
    }

    Status = STATUS_SUCCESS;

CleanUp:

    // Now perform auditlogon Raid #329545
    if (Status == STATUS_SUCCESS) {      // Check to see if completed a logon
        if (pContext)
        {
            g_LsaFunctions->AuditLogon(
                STATUS_SUCCESS,
                STATUS_SUCCESS,
                &(pContext->ustrAccountName),
                &(pContext->ustrDomain),
                &g_ustrWorkstationName,
                NULL,
                Network,
                &g_DigestSource,
                &(pContext->LoginID)
                );
        }
    }
    else {
        if (pContext)
        {
            g_LsaFunctions->AuditLogon(
                Status,
                AuditLogStatus,
                &(pContext->ustrAccountName),
                &(pContext->ustrDomain),
                &g_ustrWorkstationName,
                NULL,
                Network,
                &g_DigestSource,
                &(pContext->LoginID)
                );
        }
    }

    if (!NT_SUCCESS(Status))
    {       // Failed to complete operations so clean up
        if (fLogonSessionCreated == TRUE)
        {
            // Notify LSA that LogonID is not valid
            SubStatus = g_LsaFunctions->DeleteLogonSession(&(pContext->LoginID));
            if (!NT_SUCCESS(SubStatus))
            {
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: cleanup DeleteLogonSession failed\n"));
            }
            fLogonSessionCreated = FALSE;

            // If we created a token then we need to close it
            if (pContext->TokenHandle)
            {
                SubStatus = NtClose(pContext->TokenHandle);
                pContext->TokenHandle = NULL;
            }
        }

        if (pNewContext)
        {
            ContextFree(pNewContext);
        }
        pNewContext = NULL;
        *NewContextHandle = NULL;
    }

    // DeReference - pCredential, pOldContext
    if (bLockedCredential && pCredential)
    {
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: CredHandlerRelease to be called for 0x%x\n", pCredential));
        SubStatus = CredHandlerRelease(pCredential);
        if (!NT_SUCCESS(SubStatus))
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: CredHandlerRelease error 0x%x\n", SubStatus));
            if (NT_SUCCESS(Status))
            {
                Status = SubStatus;    // Indicate release error
            }
        }
    }

    if (bLockedContext && pContext)
    {
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: CtxtHandlerRelease to be called for 0x%x\n", pContext));
        SubStatus = CtxtHandlerRelease(pContext);
        if (!NT_SUCCESS(SubStatus))
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: CtxtHandlerRelease error 0x%x\n", SubStatus));
            if (NT_SUCCESS(Status))
            {
                Status = SubStatus;    // Indicate release error
            }
        }
    }

        // Free up any allocated memory from the ouput reply buffer
    if (ReplyBuffer.pvBuffer)
    {
        DigestFreeMemory(ReplyBuffer.pvBuffer);
        ReplyBuffer.pvBuffer = NULL;
        ReplyBuffer.cbBuffer = 0;
    }

    // Clean up local memory used by Digest
    DigestFree(&Digest);

    StringFree(&strRealm);

    DebugLog((DEB_TRACE_FUNC, "SpAcceptLsaModeContext: Leaving  Context 0x%x   Status 0x%x\n", *NewContextHandle, Status));

    return(Status);
}


//   Creates a logon session for the logontoken contained in the SecurityContext
// The Token was created for the authenticated digest by ConvertAuthDataToToken
NTSTATUS
CtxtCreateLogSess(
                 IN PDIGEST_CONTEXT pContext)
{

    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_LOGONSESSION pNewLogonSession = NULL;

    DebugLog((DEB_TRACE_FUNC, "CtxtCreateLogSess: Entering\n"));

    // Create a new entry into LogonSession listing
    pNewLogonSession = (PDIGEST_LOGONSESSION)DigestAllocateMemory(sizeof(DIGEST_LOGONSESSION));
    if (!pNewLogonSession)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "CtxtCreateLogSess: Could not allocate memory for logonsession, error 0x%x\n", Status));
        goto CleanUp;
    }
    LogonSessionInit(pNewLogonSession);

    pNewLogonSession->LogonType = Network;
    pNewLogonSession->LogonId = pContext->LoginID;

    UnicodeStringDuplicate(&(pNewLogonSession->ustrAccountName), &(pContext->ustrAccountName));
    UnicodeStringDuplicate(&(pNewLogonSession->ustrDomainName), &(pContext->ustrDomain));

    DebugLog((DEB_TRACE, "CtxtCreateLogSess: Added new logonsession into list,  handle 0x%x\n", pNewLogonSession));
    LogSessHandlerInsert(pNewLogonSession);
    pNewLogonSession = NULL;                          // Turned over memory to LogSessHandler


CleanUp:

    if (pNewLogonSession)
    {
        DigestFreeMemory(pNewLogonSession);
        pNewLogonSession = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "CtxtCreateLogSess: Leaving  Status 0x%x\n", Status));

    return(Status);
}



// Some quick checks to make sure SecurityToken buffers are OK
//
//
// Args
//     ulMaxSize - if non-zero then buffer must not be larger than this value, if zero  no check is done
BOOL
ContextIsTokenOK(
                IN PSecBuffer pTempToken,
                IN ULONG ulMaxSize)
{
    BOOL bStatus = TRUE;

    if (!pTempToken)
    {
        DebugLog((DEB_ERROR, "ContextIsTokenOK: Error  Bad input\n"));
        return FALSE;
    }

    // If Buffer pointer is NULL then cbBuffer length must be zero
    if ((!pTempToken->pvBuffer) && (pTempToken->cbBuffer))
    {
        DebugLog((DEB_ERROR, "ContextIsTokenOK: Error  Buffer NULL, length non-zero\n"));
        return FALSE;
    }

    // Verify that the input authentication string length is not too large
    if (ulMaxSize && (pTempToken->cbBuffer > ulMaxSize))
    {
        DebugLog((DEB_ERROR, "ContextIsTokenOK: Error  Buffer size too big (Max %lu  Buffer %lu)\n",
                    ulMaxSize, pTempToken->cbBuffer));
        return FALSE;
    }

    return TRUE;
}


// Creats the Challenge in the server to send back to the client
//
//  Args:  pContext  - secruity context to utilize for Challenge Creation
//         pstrRealm - allows for override of the Realm directive by this string
//         OutBuffer - secbuffer to store the output challenge in
NTSTATUS NTAPI
ContextCreateChal(
                 IN PDIGEST_CONTEXT pContext,
                 IN PSTRING pstrRealm,
                 OUT PSecBuffer OutBuffer
                 )
{

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cbChallenge = 0;
    ULONG cbLenNeeded = 0;
    BOOL  fSASLMode = FALSE;
    STRING strTempRealm;

    PCHAR pczTemp = NULL;
    PCHAR pczTemp2 = NULL;

    DebugLog((DEB_TRACE_FUNC, "ContextCreateChal: Entering\n"));

    ZeroMemory(&strTempRealm, sizeof(strTempRealm));

    // allocate the buffers for output - in the future can optimze to allocate exact amount needed
    pczTemp = (PCHAR)DigestAllocateMemory((3 * NTDIGEST_SP_MAX_TOKEN_SIZE) + 1);
    if (!pczTemp)
    {
        DebugLog((DEB_ERROR, "ContextCreateChal:  No memory for output buffers\n"));
        goto CleanUp;
    }

    pczTemp2 = (PCHAR)DigestAllocateMemory(NTDIGEST_SP_MAX_TOKEN_SIZE + 1);
    if (!pczTemp2)
    {
        DebugLog((DEB_ERROR, "ContextCreateChal:  No memory for output buffers\n"));
        goto CleanUp;
    }

    pczTemp[0] = '\0';
    pczTemp2[0] = '\0';

    // Check to make sure we have minimal input and outputs
    if ((!pContext) || (!OutBuffer) || (!pstrRealm))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "ContextCreateChal:  Invalid args\n"));
        goto CleanUp;
    }

    //  calculate the MAX possible size for the respose - will be smaller than this value
    cbLenNeeded = CB_CHAL;    // MAX byte count for directives and symbols
    cbLenNeeded += pContext->strNonce.Length;
    cbLenNeeded += pContext->strOpaque.Length;
    cbLenNeeded += pstrRealm->Length;
    cbLenNeeded += g_strNtDigestUTF8ServerRealm.Length;
    cbLenNeeded += g_strNTDigestISO8859ServerRealm.Length;  // Really only need one of these but make simple math

    if (cbLenNeeded > NTDIGEST_SP_MAX_TOKEN_SIZE)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "ContextCreateChal: output exceed max size or buffer too small  len is %d\n", cbLenNeeded));
        goto CleanUp;
    }

    if (pContext->typeDigest == SASL_SERVER)
    {
        fSASLMode = TRUE;
    }

    if (pContext->typeQOP == AUTH_CONF)
    {
        sprintf(pczTemp, "qop=\"auth,auth-int,auth-conf\",cipher=\"3des,des,rc4-40,rc4,rc4-56\",algorithm=%s,nonce=\"%Z\"",
                ((fSASLMode == TRUE) ? MD5_SESS_SASLSTR: MD5_SESSSTR), &pContext->strNonce);
    }
    else if (pContext->typeQOP == AUTH_INT)
    {
        sprintf(pczTemp, "qop=\"auth,auth-int\",algorithm=%s,nonce=\"%Z\"",
                ((fSASLMode == TRUE) ? MD5_SESS_SASLSTR: MD5_SESSSTR), &pContext->strNonce);
    }
    else
    {
        sprintf(pczTemp, "qop=\"auth\",algorithm=%s,nonce=\"%Z\"",
                ((fSASLMode == TRUE) ? MD5_SESS_SASLSTR: MD5_SESSSTR), &pContext->strNonce);
    }

    // Attach opaque data (but not on SASL_SERVER)
    if ((pContext->strOpaque.Length) && (pContext->typeDigest != SASL_SERVER))
    {
        sprintf(pczTemp2, ",opaque=\"%Z\"", &pContext->strOpaque);
        strcat(pczTemp, pczTemp2);
    }

    // Attach charset to allow UTF-8 character encoding
    if (pContext->typeCharset == UTF_8)
    {
        strcat(pczTemp, ",charset=utf-8");
    }

    // Attach realm - allow the strRealm to override the system DnsDomainName
    if (pstrRealm->Length)
    {
        Status = BackslashEncodeString(pstrRealm, &strTempRealm);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "ContextCreateChal: BackslashEncode failed      status 0x%x\n", Status));
            goto CleanUp;
        }
        DebugLog((DEB_TRACE, "ContextCreateChal: Realm provided  (%Z)  backslash encoded (%Z)\n", pstrRealm, &strTempRealm));
        sprintf(pczTemp2, ",realm=\"%Z\"", &strTempRealm);
        strcat(pczTemp, pczTemp2);
    }
    else
    {
        // determine the realm to present based on charset requested
        if (pContext->typeCharset == UTF_8)
        {
            if (g_strNtDigestUTF8ServerRealm.Length)
            {
                Status = BackslashEncodeString(&g_strNtDigestUTF8ServerRealm, &strTempRealm);
                if (!NT_SUCCESS (Status))
                {
                    DebugLog((DEB_ERROR, "ContextCreateChal: BackslashEncode failed      status 0x%x\n", Status));
                    goto CleanUp;
                }
                DebugLog((DEB_TRACE, "ContextCreateChal: UTF-8 default Realm  (%Z)  backslash encoded (%Z)\n",
                           &g_strNtDigestUTF8ServerRealm, &strTempRealm));
                sprintf(pczTemp2, ",realm=\"%Z\"", &strTempRealm);
                strcat(pczTemp, pczTemp2);
            }
        }
        else
        {
            if (g_strNTDigestISO8859ServerRealm.Length)
            {
                Status = BackslashEncodeString(&g_strNTDigestISO8859ServerRealm, &strTempRealm);
                if (!NT_SUCCESS (Status))
                {
                    DebugLog((DEB_ERROR, "ContextCreateChal: BackslashEncode failed      status 0x%x\n", Status));
                    goto CleanUp;
                }
                DebugLog((DEB_TRACE, "ContextCreateChal: ISO 8859-1 default Realm  (%Z)  backslash encoded (%Z)\n",
                           &g_strNTDigestISO8859ServerRealm, &strTempRealm));
                sprintf(pczTemp2, ",realm=\"%Z\"", &strTempRealm);
                strcat(pczTemp, pczTemp2);
            }
        }

    }

    // Attach stale directive if indicated
    if (pContext->ContextReq & ASC_RET_STALE)
    {
        sprintf(pczTemp2, ",stale=true");
        strcat(pczTemp, pczTemp2);
    }

    // total buffer for Challenge (NULL is not included in output buffer - ref:Bug 310201)
    //            cbLenNeeded = strlen(pczTemp) + sizeof(CHAR);
    cbLenNeeded = strlen(pczTemp);

    // Check on allocating output buffer
    if (!OutBuffer->cbBuffer)
    {
        OutBuffer->pvBuffer = DigestAllocateMemory(cbLenNeeded);
        if (!OutBuffer->pvBuffer)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "ContextCreateChal: out of memory on challenge output\n"));
            goto CleanUp;
        }
        OutBuffer->cbBuffer = cbLenNeeded;
        OutBuffer->BufferType = SECBUFFER_DATA;
    }

    if (cbLenNeeded > OutBuffer->cbBuffer)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "ContextCreateChal: output buffer too small need %d len is %d\n",
                  cbLenNeeded, OutBuffer->cbBuffer));
        goto CleanUp;
    }

    memcpy(OutBuffer->pvBuffer, pczTemp, cbLenNeeded);

    // Now indicate number of bytes utilized in output buffer
    OutBuffer->cbBuffer = cbLenNeeded;

CleanUp:

    if (pczTemp)
    {
        DigestFreeMemory(pczTemp);
        pczTemp = NULL;
    }

    if (pczTemp2)
    {
        DigestFreeMemory(pczTemp2);
        pczTemp2 = NULL;
    }

    StringFree(&strTempRealm);

    DebugLog((DEB_TRACE_FUNC, "ContextCreateChal: Leaving      Status 0x%x\n", Status));
    return(Status);
}


// Generate the output buffer from a given Digest
NTSTATUS NTAPI
DigestCreateChalResp(
                 IN PDIGEST_PARAMETER pDigest,
                 IN PUSER_CREDENTIALS pUserCreds,
                 OUT PSecBuffer OutBuffer
                 )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cbChallenge = 0;
    ULONG cbLenNeeded = 0;
    char *pczQOP = NULL;
    STRING strcQOP;      // string pointing to a constant value
    STRING strcAlgorithm;
    BOOL fSASLMode = FALSE;
    UINT uCodePage = CP_8859_1; 

    STRING strTempRealm;      // Backslash encoded forms
    STRING strTempUsername;
    STRING strTempUri;

    STRING strRealm;
    STRING strUsername;
    PSTRING pstrUsername = NULL;
    PSTRING pstrRealm = NULL;

    PCHAR pczTemp = NULL;
    PCHAR pczTemp2 = NULL;

    DebugLog((DEB_TRACE_FUNC, "DigestCreateChalResp: Entering\n"));

    ZeroMemory(&strTempRealm, sizeof(strTempRealm));
    ZeroMemory(&strTempUsername, sizeof(strTempUsername));
    ZeroMemory(&strTempUri, sizeof(strTempUri));
    ZeroMemory(&strRealm, sizeof(strRealm));
    ZeroMemory(&strUsername, sizeof(strUsername));

    // allocate the buffers for output - in the future can optimze to allocate exact amount needed
    pczTemp = (PCHAR)DigestAllocateMemory((3 * NTDIGEST_SP_MAX_TOKEN_SIZE) + 1);
    if (!pczTemp)
    {
        DebugLog((DEB_ERROR, "DigestCreateChalResp:  No memory for output buffers\n"));
        goto CleanUp;
    }

    pczTemp2 = (PCHAR)DigestAllocateMemory(NTDIGEST_SP_MAX_TOKEN_SIZE + 1);
    if (!pczTemp2)
    {
        DebugLog((DEB_ERROR, "DigestCreateChalResp:  No memory for output buffers\n"));
        goto CleanUp;
    }

    pczTemp[0] = '\0';
    pczTemp2[0] = '\0';

    RtlInitString(&strcQOP, NULL);
    RtlInitString(&strcAlgorithm, NULL);

    if ((pDigest->typeDigest == SASL_SERVER) || (pDigest->typeDigest == SASL_CLIENT))
    {
        fSASLMode = TRUE;
    }

    // Establish which QOP utilized
    if (pDigest->typeQOP == AUTH_CONF)
    {
        RtlInitString(&strcQOP, AUTHCONFSTR);
    }
    else if (pDigest->typeQOP == AUTH_INT)
    {
        RtlInitString(&strcQOP, AUTHINTSTR);
    }
    else if (pDigest->typeQOP == AUTH)
    {
        RtlInitString(&strcQOP, AUTHSTR);
    }


    // Determine which code page to utilize
    if (pDigest->typeCharset == UTF_8)
    {
        uCodePage = CP_UTF8;
    }
    else
    {
        uCodePage = CP_8859_1;
    }

    // if provided with UserCred then use them, otherwise use Digest directive values
    if (pUserCreds)
    {
        DebugLog((DEB_TRACE, "DigestCreateChalResp: UserCredentials presented - encode and output\n"));

        Status = EncodeUnicodeString(&pUserCreds->ustrUsername, uCodePage, &strUsername, NULL);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "DigestCreateChalResp: Error in encoding username\n"));
            goto CleanUp;
        }

        Status = EncodeUnicodeString(&pUserCreds->ustrDomain, uCodePage, &strRealm, NULL);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "DigestCreateChalResp: Error in encoding realm\n"));
            goto CleanUp;
        }

            // Now encode the user directed fields (username, URI, realm)
        Status = BackslashEncodeString(&strUsername, &strTempUsername);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestCreateChalResp: BackslashEncode failed      status 0x%x\n", Status));
            goto CleanUp;
        }

        Status = BackslashEncodeString(&strRealm, &strTempRealm);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestCreateChalResp: BackslashEncode failed      status 0x%x\n", Status));
            goto CleanUp;
        }

        // Utilize these strings in the output
        pstrUsername = &strTempUsername;
        pstrRealm = &strTempRealm;

        // Make copy of the directive values for LSA to Usermode context
        Status = StringDuplicate(&(pDigest->strUsernameEncoded), pstrUsername);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCreateChalResp: Failed to copy over UsernameEncoded\n"));
            goto CleanUp;
        }

        Status = StringDuplicate(&(pDigest->strRealmEncoded), pstrRealm);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCreateChalResp: Failed to copy over RealmEncoded\n"));
            goto CleanUp;
        }
                // refernce memory - no alloc!!!!
        StringReference(&(pDigest->refstrParam[MD5_AUTH_USERNAME]), &(pDigest->strUsernameEncoded));
        StringReference(&(pDigest->refstrParam[MD5_AUTH_REALM]), &(pDigest->strRealmEncoded));
    }
    else
    {
        // No usercreds passed in so just use the current digest directive values
        DebugLog((DEB_WARN, "DigestCreateChalResp: No UserCredentials - use provided digest\n"));
        pstrUsername = &(pDigest->refstrParam[MD5_AUTH_USERNAME]);
        pstrRealm = &(pDigest->refstrParam[MD5_AUTH_REALM]);
    }

    Status = BackslashEncodeString(&pDigest->refstrParam[MD5_AUTH_URI], &strTempUri);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestCreateChalResp: BackslashEncode failed      status 0x%x\n", Status));
        goto CleanUp;
    }

       // Precalc the amount of space needed for output
    cbLenNeeded = CB_CHALRESP;    // MAX byte count for directives and symbols
    cbLenNeeded += pstrUsername->Length;
    cbLenNeeded += pstrRealm->Length;
    cbLenNeeded += pDigest->refstrParam[MD5_AUTH_NONCE].Length;
    cbLenNeeded += strTempUri.Length;
    cbLenNeeded += pDigest->strResponse.Length;
    cbLenNeeded += strcAlgorithm.Length;
    cbLenNeeded += pDigest->refstrParam[MD5_AUTH_CNONCE].Length;
    cbLenNeeded += pDigest->refstrParam[MD5_AUTH_OPAQUE].Length;
    cbLenNeeded += MAX_AUTH_LENGTH;
    cbLenNeeded += pDigest->refstrParam[MD5_AUTH_NC].Length;
    cbLenNeeded += strcQOP.Length;

    if (cbLenNeeded > NTDIGEST_SP_MAX_TOKEN_SIZE)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestCreateChalResp: output exceed max size or buffer too small  len is %d\n", cbLenNeeded));
        goto CleanUp;
    }

    // In digest calc - already checked username,realm,nonce,method,uri
    // Make sure there are values for the rest needed

    if ((!pDigest->strResponse.Length) ||
        (!pDigest->refstrParam[MD5_AUTH_NC].Length) ||
        (!pDigest->refstrParam[MD5_AUTH_CNONCE].Length))
    {
        // Failed on a require field-value
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestCreateChalResp: Response, NC, or Cnonce is zero length\n"));
        goto CleanUp;
    }

    if (pstrRealm->Length)
    {
        sprintf(pczTemp,
       "username=\"%Z\",realm=\"%Z\",nonce=\"%Z\",%s=\"%Z\",cnonce=\"%Z\",nc=%Z",
                pstrUsername,
                pstrRealm,
                &pDigest->refstrParam[MD5_AUTH_NONCE],
                ((fSASLMode == TRUE) ? DIGESTURI_STR: URI_STR),
                &strTempUri,
                &pDigest->refstrParam[MD5_AUTH_CNONCE],
                &pDigest->refstrParam[MD5_AUTH_NC]);
    }
    else
    {
        sprintf(pczTemp,
       "username=\"%Z\",realm=\"\",nonce=\"%Z\",%s=\"%Z\",cnonce=\"%Z\",nc=%Z",
                pstrUsername,
                &pDigest->refstrParam[MD5_AUTH_NONCE],
                ((fSASLMode == TRUE) ? DIGESTURI_STR: URI_STR),
                &strTempUri,
                &pDigest->refstrParam[MD5_AUTH_CNONCE],
                &pDigest->refstrParam[MD5_AUTH_NC]);
    }

    if (fSASLMode == TRUE)
    {
        // Do not output algorithm - must be md5-sess and that is assumed
        sprintf(pczTemp2, ",response=%Z", &pDigest->strResponse);
        strcat(pczTemp, pczTemp2);
    }
    else
    {
        if (pDigest->typeAlgorithm == MD5_SESS)
        {
            sprintf(pczTemp2, ",algorithm=MD5-sess,response=\"%Z\"", &pDigest->strResponse);
            strcat(pczTemp, pczTemp2);
        }
        else
        {
            sprintf(pczTemp2, ",response=\"%Z\"", &pDigest->strResponse);
            strcat(pczTemp, pczTemp2);
        }
    }

    // Attach QOP if specified - support older format for no QOP
    if (strcQOP.Length)
    {
        if (fSASLMode == TRUE)
        {
            sprintf(pczTemp2, ",qop=%Z", &strcQOP);
            strcat(pczTemp, pczTemp2);
        }
        else
        {
            sprintf(pczTemp2, ",qop=\"%Z\"", &strcQOP);
            strcat(pczTemp, pczTemp2);
        }
    }

    // Attach Cipher selected if required
    if (pDigest->typeQOP == AUTH_CONF)
    {
        // FIX optimize these into a list for efficiency
        if (pDigest->typeCipher == CIPHER_RC4)
        {
            sprintf(pczTemp2, ",cipher=%s", STR_CIPHER_RC4);
            strcat(pczTemp, pczTemp2);
        }
        else if (pDigest->typeCipher == CIPHER_RC4_56)
        {
            sprintf(pczTemp2, ",cipher=%s", STR_CIPHER_RC4_56);
            strcat(pczTemp, pczTemp2);
        }
        else if (pDigest->typeCipher == CIPHER_RC4_40)
        {
            sprintf(pczTemp2, ",cipher=%s", STR_CIPHER_RC4_40);
            strcat(pczTemp, pczTemp2);
        }
        else if (pDigest->typeCipher == CIPHER_3DES)
        {
            sprintf(pczTemp2, ",cipher=%s", STR_CIPHER_3DES);
            strcat(pczTemp, pczTemp2);
        }
        else if (pDigest->typeCipher == CIPHER_DES)
        {
            sprintf(pczTemp2, ",cipher=%s", STR_CIPHER_DES);
            strcat(pczTemp, pczTemp2);
        }
    }

    // Attach opaque data (but not on SASL)
    if ((fSASLMode == FALSE) && pDigest->refstrParam[MD5_AUTH_OPAQUE].Length)
    {
        sprintf(pczTemp2, ",opaque=\"%Z\"", &pDigest->refstrParam[MD5_AUTH_OPAQUE]);
        strcat(pczTemp, pczTemp2);
    }

    // Attach charset to indicate that UTF-8 character encoding is utilized
    if (pDigest->typeCharset == UTF_8)
    {
        strcat(pczTemp, ",charset=utf-8");
    }


    // total buffer for Challenge (NULL is not included in output buffer - ref:Bug 310201)
    //            cbLenNeeded = strlen(pczTemp) + sizeof(CHAR);
    cbLenNeeded = strlen(pczTemp);

    // Check on allocating output buffer
    if (!OutBuffer->cbBuffer)
    {
        OutBuffer->pvBuffer = DigestAllocateMemory(cbLenNeeded);
        if (!OutBuffer->pvBuffer)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "DigestCreateChalResp: out of memory on challenge output\n"));
            goto CleanUp;
        }
        OutBuffer->cbBuffer = cbLenNeeded;
    }

    if (cbLenNeeded > OutBuffer->cbBuffer)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestCreateChalResp: output buffer too small need %d len is %d\n",
                  cbLenNeeded, OutBuffer->cbBuffer));
        goto CleanUp;
    }

    memcpy(OutBuffer->pvBuffer, pczTemp, cbLenNeeded);
    OutBuffer->cbBuffer = cbLenNeeded;
    OutBuffer->BufferType = SECBUFFER_TOKEN;

CleanUp:

    if (pczTemp)
    {
        DigestFreeMemory(pczTemp);
        pczTemp = NULL;
    }

    if (pczTemp2)
    {
        DigestFreeMemory(pczTemp2);
        pczTemp2 = NULL;
    }

    StringFree(&strTempRealm);
    StringFree(&strTempUsername);
    StringFree(&strTempUri);
    StringFree(&strRealm);
    StringFree(&strUsername);

    DebugLog((DEB_TRACE_FUNC, "DigestCreateChalResp: Leaving   status 0x%x\n", Status));
    return(Status);
}


// This is the main section to process a Context with an incoming Digest message to authenticate the
// message on the DC, generate a session key, and get the user Token.  On subsequent calls, the session key
// can be utilized directly and if the Digest is authenticated, the Token can be utilized.
// AuditLogStatus can be used to provide SubStatus in AuditLogging on server
NTSTATUS NTAPI
DigestProcessParameters(
                       IN OUT PDIGEST_CONTEXT pContext,
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSecBuffer pOutputToken,
                       OUT PNTSTATUS pAuditLogStatus)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    ULONG ulNonceCount = 0;
    USHORT cbDigestParamEncoded = 0;     // Contains the number of bytes in Request to send out

    BYTE *pMessageResponse = NULL;
    ULONG ulMessageResponse = 0;

    BOOL fLogonSessionCreated = FALSE;    // indicate if the LSA was notified about logon

    // Encoded Digest Parameters to send over Generic Passthrough
    BYTE *pDigestParamEncoded = NULL;

    // Response buffer from Generic Passthough (extracted from MessageResposne)
    PDIGEST_BLOB_RESPONSE pDigestResponse = NULL;
    UCHAR *pucResponseBuffer = NULL;     // Used for alignment to long word boundaries
    BOOL  fKnownFormat = FALSE;          // is the response blob format known

    // Generic Passthrough variables - used to send data to DC for digest verification
    UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING(TEXT(MSV1_0_PACKAGE_NAME));
    UNICODE_STRING ustrDC;      // Location for generic passthrough
    PMSV1_0_PASSTHROUGH_REQUEST PassthroughRequest = NULL;
    PMSV1_0_PASSTHROUGH_RESPONSE PassthroughResponse = NULL;
    ULONG RequestSize = 0;
    ULONG ResponseSize = 0;
    PUCHAR Where = NULL;

    // AuthData to Logon Token Variables
    SECURITY_LOGON_TYPE LogonType = Network;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = SecurityImpersonation;
    UNICODE_STRING ustrAccountName;
    PUCHAR puctr = NULL;
    ULONG ulSumTotal = 0;
    ULONG i = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestProcessParameters: Entering\n"));

    ZeroMemory(&ustrAccountName, sizeof(ustrAccountName));
    ZeroMemory(&ustrDC, sizeof(ustrDC));

    // Copy over the context types into the digest structure
    pDigest->typeAlgorithm = pContext->typeAlgorithm;
    pDigest->typeDigest = pContext->typeDigest;
    pDigest->typeQOP = pContext->typeQOP;
    pDigest->typeCharset = pContext->typeCharset;

        // Check to make sure that the nonce sent back originated from this machine and is valid
    Status = NonceIsValid(&(pDigest->refstrParam[MD5_AUTH_NONCE]));
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestProcessParameters: Nonce is not valid\n"));
        goto CleanUp;
    }

        // Make sure that the nonces are the same
    if (RtlCompareString(&(pContext->strNonce), &(pDigest->refstrParam[MD5_AUTH_NONCE]), FALSE))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestProcessParameters: nonce does not mach Context nonce!\n"));
        goto CleanUp;
    }

    // We must have a noncecount specified since we specified a qop in the Challenge
    // If we decide to support no noncecount modes then we need to make sure that qop is not specified
    if (pDigest->refstrParam[MD5_AUTH_NC].Length)
    {
        Status = RtlCharToInteger(pDigest->refstrParam[MD5_AUTH_NC].Buffer, HEXBASE, &ulNonceCount);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog((DEB_ERROR, "DigestProcessParameters: Nonce Count badly formatted\n"));
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestProcessParameters: Nonce Count not specified\n"));
        goto CleanUp;
    }

    // Check nonceCount is incremented to preclude replay
    if (ulNonceCount < (pContext->ulNC + 1))
    {
        // We failed to verify next noncecount
        Status = SEC_E_OUT_OF_SEQUENCE;
        DebugLog((DEB_ERROR, "DigestProcessParameters: NonceCount failed to increment!\n"));
        goto CleanUp;
    }

    // Verify that this context matches the content in the Digest Parameters
    // We have already gone to the DC and authenticated the first message
    if (pContext->strSessionKey.Length)
    {
        DebugLog((DEB_TRACE, "DigestProcessParameters: We have a previous session key - use key for auth\n"));

        // Copy the SessionKey from the Context into the Digest Structure to verify against
        // This will have Digest Auth routines use the SessionKey rather than recompute H(A1)
        StringFree(&(pDigest->strSessionKey));
        Status = StringDuplicate(&(pDigest->strSessionKey), &(pContext->strSessionKey));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to copy over SessionKey\n"));
            goto CleanUp;
        }

        // No check locally that Digest is authentic
        Status = DigestCalculation(pDigest, NULL);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: Oh no we FAILED Authentication!!!!\n"));
            goto CleanUp;
        }

        // We have an authenticated the request
        // Can utilize logonID
        pContext->ulNC =  ulNonceCount;         // Indicate that we have processed up to this NC
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestProcessParameters: No session key - call DC for auth\n"));

        Status = DigestDecodeDirectiveStrings(pDigest);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: DigestDecodeDirectiveStrings  error 0x%x\n", Status));
            goto CleanUp;
        }

        // Identify the domain to send generic passthough to
        Status = DigestDecodeUserAccount(pDigest, &ustrDC);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: DigestDecodeUserAccount failed 0x%x\n", Status));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE, "DigestProcessParameters: GenericPassthrough to domain [%wZ]\n", &ustrDC));

        // Serialize the Digest Parameters (if need to send off box)
        cbDigestParamEncoded = 0;    // Will be allocated by BlobEncodeRequest
        Status = BlobEncodeRequest(pDigest, &pDigestParamEncoded, &cbDigestParamEncoded);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: BlobEncodeRequest failed 0x%x\n", Status));
            goto CleanUp;
        }

        // Send the Serialized Digest to the DC for verification & return of validity & session key
        // If paramters match, perform authentication locally and utilize previous token
        //
        // We have to pass off to the DC so build the request.
        //
        RequestSize = sizeof(MSV1_0_PASSTHROUGH_REQUEST) +
                      ustrDC.Length +
                      g_ustrNtDigestPackageName.Length +
                      cbDigestParamEncoded;

        PassthroughRequest = (PMSV1_0_PASSTHROUGH_REQUEST) DigestAllocateMemory(RequestSize);
        if (PassthroughRequest == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto CleanUp;
        }
        Where = (PUCHAR) (PassthroughRequest + 1);       // Points to byte AFTER passthrough header

        PassthroughRequest->MessageType = MsV1_0GenericPassthrough;

        PassthroughRequest->DomainName.Length = ustrDC.Length;
        PassthroughRequest->DomainName.MaximumLength = ustrDC.Length;
        PassthroughRequest->DomainName.Buffer = (LPWSTR) Where;       // this is NOT NULL TERMINATED
        RtlCopyMemory(
                     Where,
                     ustrDC.Buffer,
                     ustrDC.Length
                     );
        Where += ustrDC.Length;

        PassthroughRequest->PackageName.Length = g_ustrNtDigestPackageName.Length;
        PassthroughRequest->PackageName.MaximumLength = g_ustrNtDigestPackageName.Length;
        PassthroughRequest->PackageName.Buffer = (LPWSTR) Where;    // Not NULL terminated - relative reference
        RtlCopyMemory(
                     Where,
                     g_ustrNtDigestPackageName.Buffer,
                     g_ustrNtDigestPackageName.Length
                     );
        Where += g_ustrNtDigestPackageName.Length;
        PassthroughRequest->LogonData = Where;
        PassthroughRequest->DataLength = (ULONG)cbDigestParamEncoded;

        RtlCopyMemory(
                     Where,
                     pDigestParamEncoded,
                     cbDigestParamEncoded
                     );

        //
        // We've build the buffer, now call NTLM to pass it through.
        //
        Status = g_LsaFunctions->CallPackage(
                                            &MsvPackageName,
                                            PassthroughRequest,
                                            RequestSize,                                  // How many bytes to send in Request
                                            (PVOID *) &PassthroughResponse,               // Place the buffers here
                                            &ResponseSize,                                // Passed back the size of the buffer
                                            &SubStatus                                    // Return code from Digest Auth on the DC
                                            );


        DebugLog((DEB_TRACE, "DigestProcessParameters: Returned from Server's passthrough call Response buffer size %ld\n",
                  ResponseSize));

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"DigestProcessParameters: Failed to call MSV package to verify Digest: 0x%x\n",Status));
            if (Status == STATUS_INVALID_INFO_CLASS)
            {
                Status = STATUS_LOGON_FAILURE;
            }
            goto CleanUp;
        }

        if (!NT_SUCCESS(SubStatus))
        {
            Status = SubStatus;
            DebugLog((DEB_ERROR,"DigestProcessParameters: DC failed to verify Digest Response: 0x%x\n",Status));
            goto CleanUp;
        }

        // Now pull out info from the Passthrough Response structure
        if (PassthroughResponse->DataLength < sizeof(DIGEST_BLOB_RESPONSE))
        {
            // The returned data is not the expected size
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR,"DigestProcessParameters: DC Response wrong data size: 0x%x\n",Status));
            goto CleanUp;
        }
        // Copy it to a structure - can do direct map once we know this works OK
        // Copy to Allocated memory forces aligment of fields
        pDigestResponse = (PDIGEST_BLOB_RESPONSE)DigestAllocateMemory(PassthroughResponse->DataLength);
        if (!pDigestResponse)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR,"DigestProcessParameters: Out of memory for response buffer alloc\n"));
            goto CleanUp;
        }

        Where = (PUCHAR) (PassthroughResponse + 1);          // start copy after header 
        RtlCopyMemory(
                     pDigestResponse,
                     Where,
                     PassthroughResponse->DataLength
                     );

        // We should now have all the data we need for sessionkeys and if verified auth

        // Check the MessageType and Versions if supported
        if ((pDigestResponse->MessageType == VERIFY_DIGEST_MESSAGE_RESPONSE) && (pDigestResponse->version == DIGEST_BLOB_VERSION))
        {
            fKnownFormat = TRUE;      // We know how to process this blob from the DC
            DebugLog((DEB_TRACE,"DigestProcessParameters: DC Response known type and version\n"));
        }

        if (!fKnownFormat)
        {
            // The returned data not of a known type or version
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR,"DigestProcessParameters: DC Response unknown type or version\n"));
            goto CleanUp;
        }


        DebugLog((DEB_TRACE,"DigestProcessParameters: Processing DC Response\n"));


        // If authenticated then, create a logon token with the DC returns (unless previous token exists)


        // Now create the logon token with the AuthData buffer
        //    LsaConvertAuthDataToToken()
        // Set the AuthorityName to the DC's Domainname
        // g_DigestSource established at SpInitialize time in the LSA

        if (!pDigestResponse->ulAuthDataSize)
        {
            // We do not have any AuthData
            Status = STATUS_LOGON_FAILURE;
            DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to determine AuthData\n"));
            goto CleanUp;             
        }

        // Copy over data to place on correct boundary (alloc should force long word boundary)
        puctr = (PUCHAR)DigestAllocateMemory(pDigestResponse->ulAuthDataSize);
        if (!puctr)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "DigestProcessParameters: out of memory on response PAC buffer\n"));
            goto CleanUp;
        }
        memcpy(puctr,&(pDigestResponse->cAuthData),pDigestResponse->ulAuthDataSize);  

        ulSumTotal = 0;
        for (i=0; i < (pDigestResponse->ulAuthDataSize); i++)
        {
            ulSumTotal += (ULONG)*(puctr + i);
        }
        // DebugLog((DEB_TRACE, "DigestProcessParameters: AuthData SumTotal is %ld\n", ulSumTotal));

        Status = g_LsaFunctions->ConvertAuthDataToToken(puctr, pDigestResponse->ulAuthDataSize,
                                                        ImpersonationLevel, &g_DigestSource, LogonType, &pDigest->ustrCrackedDomain,
                                                        &(pContext->TokenHandle), &(pContext->LoginID), &ustrAccountName, &SubStatus);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to form token from AuthData 0x%x subStatus 0x%x\n",
                      Status, SubStatus));
            pContext->TokenHandle = NULL;   // no valid handle returned
            goto CleanUp;
        }

        fLogonSessionCreated = TRUE;    // LSA notified about LogonID

        DebugLog((DEB_TRACE, "DigestProcessParameters: Token Created  Handle 0x%x, LogonID (%x:%lx) \n",
                   pContext->TokenHandle, pContext->LoginID.HighPart, pContext->LoginID.LowPart));
        DebugLog((DEB_TRACE, "DigestProcessParameters:                AccountName %wZ \n", &ustrAccountName));
        DebugLog((DEB_TRACE, "DigestProcessParameters:                Domain %wZ \n", &pDigest->ustrCrackedDomain));
        DebugLog((DEB_TRACE, "DigestProcessParameters:                Passthrough UserName  %wZ \n", &pDigest->ustrUsername));

        pContext->ulNC =  ulNonceCount;         // Indicate that we have processed up to this NC

        // Since all authenticated, initialize the known Context states
        (void)UnicodeStringFree(&(pContext->ustrAccountName));
        Status = UnicodeStringDuplicate(&(pContext->ustrAccountName), &ustrAccountName);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to copy UserName into Context\n"));
            goto CleanUp;
        }
        (void)UnicodeStringFree(&(pContext->ustrDomain));
        Status = UnicodeStringDuplicate(&(pContext->ustrDomain), &pDigest->ustrCrackedDomain);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to copy UserName into Context\n"));
            goto CleanUp;
        }

        StringFree(&(pContext->strSessionKey));
        Status = StringAllocate(&(pContext->strSessionKey), pDigestResponse->SessionKeyMaxLength);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to alloc Sessionkey memory\n"));
            goto CleanUp;
        }
        
        memcpy(pContext->strSessionKey.Buffer, pDigestResponse->SessionKey, pDigestResponse->SessionKeyMaxLength);
        pContext->strSessionKey.Length = (USHORT)strlencounted(pContext->strSessionKey.Buffer, pDigestResponse->SessionKeyMaxLength);


        DebugLog((DEB_TRACE, "DigestProcessParameters: Response Data from passthrough call\n"));
        DebugLog((DEB_TRACE, "       Session Key: %Z\n", &(pContext->strSessionKey)));

        if (pContext->typeDigest == SASL_SERVER)
        {
            // Form the ResponseAuth according to RFC2831 Sect 2.1.3
            StringFree(&pDigest->strSessionKey);
            StringDuplicate(&pDigest->strSessionKey, &pContext->strSessionKey); 
            Status = DigestSASLResponseAuth(pDigest, pOutputToken);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to generate ResponseAuth\n"));
                goto CleanUp;
            }
        }
    }

    // Token created - Logon OK
    *pAuditLogStatus = STATUS_SUCCESS; 

CleanUp:
    BlobFreeRequest(pDigestParamEncoded);
    DigestFreeMemory(pMessageResponse);
    pMessageResponse = NULL;
    ulMessageResponse = 0;

    if (!NT_SUCCESS(Status))
    {
        // If we failed - do extra cleanup
        if (fLogonSessionCreated == TRUE)
        {
            // Notify LSA that LogonID is not valid
            SubStatus = g_LsaFunctions->DeleteLogonSession(&(pContext->LoginID));
            if (!NT_SUCCESS(SubStatus))
            {
                DebugLog((DEB_ERROR, "DigestProcessParameters: cleanup DeleteLogonSession failed\n"));
            }
            fLogonSessionCreated = FALSE;

        }

        // If we created a token then we need to close it
        if (pContext->TokenHandle)
        {
            SubStatus = NtClose(pContext->TokenHandle);
            pContext->TokenHandle = NULL;
        }

    }

    if (pDigestResponse)
    {
        DigestFreeMemory(pDigestResponse);
    }

    if (PassthroughRequest != NULL)
    {
        DigestFreeMemory(PassthroughRequest);
    }
    if (PassthroughResponse != NULL)
    {
        g_LsaFunctions->FreeReturnBuffer(PassthroughResponse);
    }
    if (ustrAccountName.Buffer)
    {     // Need to free up memory from token creation
        g_LsaFunctions->FreeLsaHeap(ustrAccountName.Buffer);
        ustrAccountName.Buffer = NULL;
        ustrAccountName.Length = ustrAccountName.MaximumLength = 0;
    }
    DigestFreeMemory(puctr);
    UnicodeStringFree(&ustrDC);

    DebugLog((DEB_TRACE_FUNC, "DigestProcessParameters: Leaving\n"));
    return(Status);
}


//  This call is utilized by Initialize Securitycontext - it is used to create the sessionkey
//  form the response hash. This function is called only as a client process
NTSTATUS NTAPI
DigestGenerateParameters(
                       IN OUT PDIGEST_CONTEXT pContext,
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSecBuffer pOutputToken)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;

    UNICODE_STRING ustrTempPasswd;
    USER_CREDENTIALS UserCreds;

    ZeroMemory(&UserCreds, sizeof(USER_CREDENTIALS));
    ZeroMemory(&ustrTempPasswd, sizeof(ustrTempPasswd));

    DebugLog((DEB_TRACE_FUNC, "DigestGenerateParameters: Entering\n"));

    pDigest->typeDigest = pContext->typeDigest;
    pDigest->typeAlgorithm = pContext->typeAlgorithm;
    pDigest->typeQOP = pContext->typeQOP;
    pDigest->typeCipher = pContext->typeCipher;
    pDigest->typeCharset = pContext->typeCharset;

    // We must have specified the username and password

    Status = UnicodeStringDuplicate(&(UserCreds.ustrDomain), &(pContext->ustrDomain));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Duplicate Domain string   status 0x%x\n", Status));
        goto CleanUp;
    }
    Status = UnicodeStringDuplicate(&(UserCreds.ustrUsername), &(pContext->ustrAccountName));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Duplicate Username string   status 0x%x\n", Status));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicatePassword(&(UserCreds.ustrPasswd), &(pContext->ustrPassword));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Duplicate Password string   status 0x%x\n", Status));
        goto CleanUp;
    }
    UserCreds.fIsValidPasswd = TRUE;
    UserCreds.fIsEncryptedPasswd = TRUE;


    
    DebugLog((DEB_TRACE, "DigestGenerateParameters: Before DigestCalculation\n"));
    (void)DigestPrint(pDigest);

    // No check locally that Digest is authentic
    Status = DigestCalculation(pDigest, &UserCreds);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Oh no we FAILED Authentication!!!!\n"));
        goto CleanUp;
    }

        // DigestCalculation determined the sessionkey - copy into this context
    StringFree(&(pContext->strSessionKey));
    Status = StringDuplicate( &(pContext->strSessionKey), &(pDigest->strSessionKey));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Failed to copy over SessionKey\n"));
        goto CleanUp;
    }

    // We have an authenticated the request
    // Can utilize logonID

    Status = DigestCreateChalResp(pDigest, &UserCreds, pOutputToken);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Failed to create Output String  status 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "DigestGenerateParameters: After DigestCalculation & copy struct\n"));
    (void)DigestPrint(pDigest);

CleanUp:

    UserCredentialsFree(&UserCreds);
    UnicodeStringFree(&ustrTempPasswd);

    DebugLog((DEB_TRACE_FUNC, "DigestGenerateParameters: Leaving\n"));

    return(Status);
}




// Called by digest (inside LSA) with a buffer routed from a server to the DC running this code
// We need to strip out the header and extract the DIGEST_BLOB_REQUEST
//
//  pcbMessageRequest will return the number of bytes allocated for response
//  ppMessageResponse will contain the pointer to the allocated buffer
//     calling routine must free the buffer (DigestFreeMemory) after it is done with it
NTSTATUS NTAPI
DigestPackagePassthrough(IN USHORT cbMessageRequest,
                         IN BYTE *pMessageRequest,
                         IN OUT ULONG *pulMessageResponse,
                         OUT PBYTE *ppMessageResponse)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "DigestPackagePassthrough: Entering\n"));

    if (!pMessageRequest || !ppMessageResponse || !pulMessageResponse ||
        (cbMessageRequest < sizeof(DIGEST_BLOB_REQUEST)))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestPackagePassthrough: Bad input Paramters\n"));
        goto CleanUp;
    }

    // Function will allocate space for Response - we need to free it after use
    Status = DigestResponseBru(pMessageRequest, pulMessageResponse, ppMessageResponse);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestPackagePassthrough: Error with DigestVerifyResponseBru\n"));
        goto CleanUp;
    }

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "DigestPackagePassthrough: Leaving\n"));
    return(Status);
}


// Routine receives the DigestBlob to process by extracting the password
// and verifying the response-value.  If authenticated, the SessionKey can be returned
// to the server for future authentication
//
// This routine runs under LSA on the DC.  It will do the actual Digest auth and return session keys
//
//   pcbResponse is a pointer to a USHORT which holds amount of bytes in PResponse
//         it also returns the number of bytes actually used
//   The buffer will be allocated in this routine by DigestAllocateMemory and must be freed by DigestFreeMemory by
//   calling routine
NTSTATUS NTAPI
DigestResponseBru(
                 IN BYTE *pDigestParamEncoded,
                 IN OUT ULONG *pulResponse,
                 OUT PBYTE *ppResponse)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusSub = STATUS_LOGON_FAILURE;
    DIGEST_PARAMETER Digest;
    PDIGEST_BLOB_RESPONSE pBlobResponse = NULL;
    USER_CREDENTIALS UserCreds;
    PUCHAR pucAuthData = NULL;
    ULONG  ulAuthDataSize = 0;
    ULONG  ulBuffer = 0;
    BOOL   fDigestValid = FALSE;
    USHORT indx = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestResponseBru: Entering\n"));

    ZeroMemory(&UserCreds, sizeof(USER_CREDENTIALS));

    Status = DigestInit(&Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed to initialize digest struct\n"));
        goto CleanUp;
    }


    Status = BlobDecodeRequest(pDigestParamEncoded, &Digest);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed to copy over SessionKey 0x%x\n", Status));
        goto CleanUp;
    }

    // Pull out the username and domain to process
    Status = UserCredentialsExtract(&Digest, &UserCreds);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed UserCredentialsExtract 0x%x\n", Status));
        goto CleanUp;
    }

    // Extract Passwords (Cleartext and hash if available)
    Status = DigestGetPasswd(&UserCreds, &pucAuthData, &ulAuthDataSize);
    if (Status == STATUS_INVALID_SERVER_STATE)
    {
        DebugLog((DEB_WARN, "DigestResponseBru: Unable to get credentials - not on Domain Controller   0x%x\n"));
        StatusSub = STATUS_LOGON_FAILURE;
    }
    else if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed to find password for %wZ\n", &(UserCreds.ustrUsername)));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "DigestResponseBru: Got password for user %wZ, is valid %d; AuthData size %ld\n",
              &(UserCreds.ustrUsername), UserCreds.fIsValidPasswd, ulAuthDataSize ));
    DebugLog((DEB_TRACE, "DigestResponseBru: HashCred size is %d\n", UserCreds.strDigestHash.Length ));


    // We now have passwd - either/both pre-computed hash or passwd
    // Also, an authData blob to marshal back to server
    
    // Now validate the Digest ChallengeResponse
    // Check precalculated hashes first
    fDigestValid = FALSE;
    if (UserCreds.fIsValidDigestHash == TRUE)
    {
        // Need to cycle over the possible matching hashes based on username format
        indx = 1;  // skip the first hash this is the header
        while ((fDigestValid == FALSE) && (indx < TOTALPRECALC_HEADERS))
        {
            if (UserCreds.sHashTags[indx])
            {
                DebugLog((DEB_TRACE, "DigestResponseBru: Checking Precalc hash 0x%x\n", indx));
                UserCreds.wHashSelected = indx;
            }
            else
            {
                indx++;      // skip to the next hash since incorrect format
                continue;
            }

            StringFree(&Digest.strSessionKey);      // clear out any previous session key info
            StatusSub = DigestCalculation(&Digest, &UserCreds);
            if (NT_SUCCESS(StatusSub))
            {        // Precalculated hash matched!
                DebugLog((DEB_TRACE, "DigestResponseBru: Digest valid with precalc hash 0x%x\n", indx));
                fDigestValid = TRUE;
            }
            else if ((StatusSub == STATUS_WRONG_PASSWORD) || (StatusSub == SEC_E_NO_CREDENTIALS))
            {        // Really we know only that the Hash did not compare - could be anything incorrect
                     // We do not provide information that the password was incorrect
                DebugLog((DEB_TRACE, "DigestResponseBru: Digest did not match precalc hash 0x%x\n", indx));
                indx++;
            }
            else
            {
                Status = StatusSub;
                DebugLog((DEB_ERROR, "DigestResponseBru: Digest Verify Failed 0x%x\n", Status));
                goto CleanUp;
            }
        }
        if (fDigestValid == FALSE)
        {
            UserCreds.fIsValidDigestHash = FALSE;    // no need to try to use any of these hashes again
        }
    }

    // If ClearText passwd available, then try to validate the Digest ChallengeResponse
    if ((fDigestValid == FALSE) && (UserCreds.fIsValidPasswd == TRUE))
    {
        StringFree(&Digest.strSessionKey);      // clear out any previous session key info
        StatusSub = DigestCalculation(&Digest, &UserCreds);
        if (NT_SUCCESS(StatusSub))
        {        // Really we know only that the Hash did not compare - could be anything incorrect
                 // We do not provide information that the password was incorrect
            DebugLog((DEB_TRACE, "DigestResponseBru: Digest valid with cleartext password\n"));
            fDigestValid = TRUE;
        }
        else if (StatusSub == STATUS_WRONG_PASSWORD)
        {        // Really we know only that the Hash did not compare - could be anything incorrect
                 // We do not provide information that the password was incorrect
            DebugLog((DEB_ERROR, "DigestResponseBru: Digest did not match cleartext passsword\n"));
        }
        else
        {
            Status = StatusSub;
            DebugLog((DEB_ERROR, "DigestResponseBru: Digest Verify Failed 0x%x\n", Status));
            goto CleanUp;
        }
    }

    // We completed the Auth (it might have failed though)
    // Make sure enough room in output buffer
    ulBuffer = sizeof(DIGEST_BLOB_RESPONSE);
    if (fDigestValid == TRUE)
    {
        // We succeeded in auth so send back AuthData for tokens
        ulBuffer += ulAuthDataSize;
    }
    else
    {
        ulAuthDataSize = 0;    // Do not send back Auth data unless Digest Calc Succeeded
    }

    DebugLog((DEB_TRACE, "DigestResponseBru: Total size for return buffer is %ld bytes\n", ulBuffer));

    pBlobResponse = (PDIGEST_BLOB_RESPONSE)DigestAllocateMemory(ulBuffer);
    if (!pBlobResponse)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "DigestResponseBru: Can not allocate memory for Output Response Buffer\n"));
        goto CleanUp;
    }

    pBlobResponse->MessageType = VERIFY_DIGEST_MESSAGE_RESPONSE;
    pBlobResponse->version = DIGEST_BLOB_VERSION;
    if (!NT_SUCCESS(StatusSub))
    {
        StatusSub = STATUS_LOGON_FAILURE;                 // Returns either Sucess or LogonFailure
    }
    pBlobResponse->Status = StatusSub;                    // Should be STATUS_SUCCESS or STATUS_LOGON_FAILURE
    pBlobResponse->ulAuthDataSize = ulAuthDataSize;

    // Could be an assert too
    if (Digest.strSessionKey.Length != MD5_HASH_HEX_SIZE)
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed SessionKey generation\n"));
        Status = STATUS_INTERNAL_ERROR;      // Program flow failure
        goto CleanUp;
    }
    pBlobResponse->SessionKeyMaxLength = MD5_HASH_HEX_SIZE + 1;   // MD5 hash + NULL
    memcpy(pBlobResponse->SessionKey, Digest.strSessionKey.Buffer, MD5_HASH_HEX_SIZE);

    if (ulAuthDataSize)
    {   // Copy over the AuthData only if DigestCalc succeeded (i.e. ulAuthDataSize != 0)
        memcpy(&(pBlobResponse->cAuthData), pucAuthData, ulAuthDataSize);
    }

    // OK we are done filling in output Response buffer - we can leave now!

    *pulResponse = ulBuffer;                            // Set the size of the response blob
    *ppResponse = (PBYTE)pBlobResponse;                 // set the buffer allocated

CleanUp:

    DigestFree(&Digest);
    UserCredentialsFree(&UserCreds);

    // Cleanup any allocated heap from GetUserAuthData
    if (pucAuthData)
    {
        g_LsaFunctions->FreeLsaHeap(pucAuthData);
        pucAuthData = NULL;
        ulAuthDataSize = 0;
    }

    if (!NT_SUCCESS(Status))
    {
        // We had an error  - free allocated memory
        *pulResponse = 0;
        if (pBlobResponse)
        {
            DigestFreeMemory(pBlobResponse);
            pBlobResponse = NULL;
            *ppResponse = NULL;    // No output buffer provided
        }
    }

    DebugLog((DEB_TRACE_FUNC, "DigestResponseBru: Leaving\n"));

    return(Status);
}


NTSTATUS
DigestPrint(PDIGEST_PARAMETER pDigest)
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    if (!pDigest)
    {
        return (STATUS_INVALID_PARAMETER); 
    }

    if (pDigest->typeDigest == DIGEST_UNDEFINED)
    {
        DebugLog((DEB_TRACE, "Digest:       DIGEST_UNDEFINED\n"));
    }
    if (pDigest->typeDigest == NO_DIGEST_SPECIFIED)
    {
        DebugLog((DEB_ERROR, "Digest:       NO_DIGEST_SPECIFIED\n"));
    }
    if (pDigest->typeDigest == DIGEST_CLIENT)
    {
        DebugLog((DEB_TRACE, "Digest:       DIGEST_CLIENT\n"));
    }
    if (pDigest->typeDigest == DIGEST_SERVER)
    {
        DebugLog((DEB_TRACE, "Digest:       DIGEST_SERVER\n"));
    }
    if (pDigest->typeDigest == SASL_SERVER)
    {
        DebugLog((DEB_TRACE, "Digest:       SASL_SERVER\n"));
    }
    if (pDigest->typeDigest == SASL_CLIENT)
    {
        DebugLog((DEB_TRACE, "Digest:       SASL_CLIENT\n"));
    }
    if (pDigest->typeQOP == QOP_UNDEFINED)
    {
        DebugLog((DEB_ERROR, "Digest:       QOP: Not QOP_UNDEFINED\n"));
    }
    if (pDigest->typeQOP == NO_QOP_SPECIFIED)
    {
        DebugLog((DEB_TRACE, "Digest:       QOP: Not Specified\n"));
    }
    if (pDigest->typeQOP == AUTH)
    {
        DebugLog((DEB_TRACE, "Digest:       QOP: AUTH\n"));
    }
    if (pDigest->typeQOP == AUTH_INT)
    {
        DebugLog((DEB_TRACE, "Digest:       QOP: AUTH_INT\n"));
    }
    if (pDigest->typeQOP == AUTH_CONF)
    {
        DebugLog((DEB_TRACE, "Digest:       QOP: AUTH_CONF\n"));
    }
    if (pDigest->typeAlgorithm == ALGORITHM_UNDEFINED)
    {
        DebugLog((DEB_ERROR, "Digest:       Algorithm: ALGORITHM_UNDEFINED\n"));
    }
    if (pDigest->typeAlgorithm == NO_ALGORITHM_SPECIFIED)
    {
        DebugLog((DEB_TRACE, "Digest:       Algorithm: NO_ALGORITHM_SPECIFIED\n"));
    }
    if (pDigest->typeAlgorithm == MD5)
    {
        DebugLog((DEB_TRACE, "Digest:       Algorithm: MD5\n"));
    }
    if (pDigest->typeAlgorithm == MD5_SESS)
    {
        DebugLog((DEB_TRACE, "Digest:       Algorithm: MD5_SESS\n"));
    }
    if (pDigest->typeCharset == ISO_8859_1)
    {
        DebugLog((DEB_TRACE, "Digest:       CharSet: ISO-8859-1\n"));
    }
    if (pDigest->typeCharset == UTF_8)
    {
        DebugLog((DEB_TRACE, "Digest:       CharSet: UTF-8\n"));
    }

    for (i=0; i < MD5_AUTH_LAST;i++)
    {
        if (pDigest->refstrParam[i].Buffer &&
            pDigest->refstrParam[i].Length)
        {
            DebugLog((DEB_TRACE, "Digest:       Digest[%d] = \"%Z\"\n", i,  &pDigest->refstrParam[i]));
        }
    }


    DebugLog((DEB_TRACE, "Digest:      SessionKey %Z\n", &(pDigest->strSessionKey)));
    DebugLog((DEB_TRACE, "Digest:     Response %Z\n", &(pDigest->strResponse)));
    DebugLog((DEB_TRACE, "Digest:     Username %wZ\n", &(pDigest->ustrUsername)));
    DebugLog((DEB_TRACE, "Digest:     Realm %wZ\n", &(pDigest->ustrRealm)));
    DebugLog((DEB_TRACE, "Digest:     URI %wZ\n", &(pDigest->ustrUri)));
    DebugLog((DEB_TRACE, "Digest:     CrackedAccountName %wZ\n", &(pDigest->ustrCrackedAccountName)));
    DebugLog((DEB_TRACE, "Digest:     CrackedDomain %wZ\n", &(pDigest->ustrCrackedDomain)));

    return(Status);
}



NTSTATUS
ContextPrint(PDIGEST_CONTEXT pContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    if (!pContext)
    {
        return (STATUS_INVALID_PARAMETER); 
    }

    if (pContext->typeDigest == DIGEST_UNDEFINED)
    {
        DebugLog((DEB_TRACE, "Context:       DIGEST_UNDEFINED\n"));
    }
    if (pContext->typeDigest == NO_DIGEST_SPECIFIED)
    {
        DebugLog((DEB_ERROR, "Context:       NO_DIGEST_SPECIFIED\n"));
    }
    if (pContext->typeDigest == DIGEST_CLIENT)
    {
        DebugLog((DEB_TRACE, "Context:       DIGEST_CLIENT\n"));
    }
    if (pContext->typeDigest == DIGEST_SERVER)
    {
        DebugLog((DEB_TRACE, "Context:       DIGEST_SERVER\n"));
    }
    if (pContext->typeDigest == SASL_SERVER)
    {
        DebugLog((DEB_TRACE, "Context:       SASL_SERVER\n"));
    }
    if (pContext->typeDigest == SASL_CLIENT)
    {
        DebugLog((DEB_TRACE, "Context:       SASL_CLIENT\n"));
    }
    if (pContext->typeQOP == QOP_UNDEFINED)
    {
        DebugLog((DEB_ERROR, "Context:       QOP: QOP_UNDEFINED\n"));
    }
    if (pContext->typeQOP == NO_QOP_SPECIFIED)
    {
        DebugLog((DEB_TRACE, "Context:       QOP: NO_QOP_SPECIFIED\n"));
    }
    if (pContext->typeQOP == AUTH)
    {
        DebugLog((DEB_TRACE, "Context:       QOP: AUTH\n"));
    }
    if (pContext->typeQOP == AUTH_INT)
    {
        DebugLog((DEB_TRACE, "Context:       QOP: AUTH_INT\n"));
    }
    if (pContext->typeQOP == AUTH_CONF)
    {
        DebugLog((DEB_TRACE, "Context:       QOP: AUTH_CONF\n"));
    }
    if (pContext->typeAlgorithm == ALGORITHM_UNDEFINED)
    {
        DebugLog((DEB_ERROR, "Context:       Algorithm: ALGORITHM_UNDEFINED\n"));
    }
    if (pContext->typeAlgorithm == NO_ALGORITHM_SPECIFIED)
    {
        DebugLog((DEB_TRACE, "Context:       Algorithm: NO_ALGORITHM_SPECIFIED\n"));
    }
    if (pContext->typeAlgorithm == MD5)
    {
        DebugLog((DEB_TRACE, "Context:       Algorithm: MD5\n"));
    }
    if (pContext->typeAlgorithm == MD5_SESS)
    {
        DebugLog((DEB_TRACE, "Context:       Algorithm: MD5_SESS\n"));
    }
    if (pContext->typeCipher == CIPHER_RC4)
    {
        DebugLog((DEB_TRACE, "Context:       Cipher: RC4\n"));
    }
    if (pContext->typeCipher == CIPHER_RC4_40)
    {
        DebugLog((DEB_TRACE, "Context:       Cipher: RC4_40\n"));
    }
    if (pContext->typeCipher == CIPHER_RC4_56)
    {
        DebugLog((DEB_TRACE, "Context:       Cipher: RC4_56\n"));
    }
    if (pContext->typeCipher == CIPHER_3DES)
    {
        DebugLog((DEB_TRACE, "Context:       Cipher: 3DES\n"));
    }
    if (pContext->typeCipher == CIPHER_DES)
    {
        DebugLog((DEB_TRACE, "Context:       Cipher: DES\n"));
    }
    if (pContext->typeCharset == ISO_8859_1)
    {
        DebugLog((DEB_TRACE, "Context:       Charset: ISO-8859-1\n"));
    }
    if (pContext->typeCharset == UTF_8)
    {
        DebugLog((DEB_TRACE, "Context:       Charset: UTF-8\n"));
    }

    DebugLog((DEB_TRACE, "Context:      NC %d\n", pContext->ulNC));
    DebugLog((DEB_TRACE, "Context:      LogonId (%x:%lx)\n", pContext->LoginID.HighPart, pContext->LoginID.LowPart ));

    DebugLog((DEB_TRACE, "Context:      strNonce %Z\n", &(pContext->strNonce)));
    DebugLog((DEB_TRACE, "Context:      strCNonce %Z\n", &(pContext->strCNonce)));
    DebugLog((DEB_TRACE, "Context:      strOpaque %Z\n", &(pContext->strOpaque)));
    DebugLog((DEB_TRACE, "Context:      strSessionKey %Z\n", &(pContext->strSessionKey)));
    DebugLog((DEB_TRACE, "Context:      ustrDomain %wZ\n", &(pContext->ustrDomain)));
    DebugLog((DEB_TRACE, "Context:      ustrAccountName %wZ\n", &(pContext->ustrAccountName)));
    DebugLog((DEB_TRACE, "Context:      SendMaxBuf %lu\n", &(pContext->ulSendMaxBuf)));

    return(Status);
}



//   Extracts the username and domain from the digest directives
//   Need to process the character set to properly decode the directive values
//   The major character sets are UTF-8 and ISO-8859-1
//   The forms that may be present in the directive values are:
//         Username               Realm
//   1.    username               domain
//   2.    domain/username        domainForestName
//   3.    UPN                    domainForestName
NTSTATUS UserCredentialsExtract(PDIGEST_PARAMETER pDigest,
                                PUSER_CREDENTIALS pUserCreds)
{
    NTSTATUS Status = STATUS_SUCCESS;
    int     iRC = 0;

    DebugLog((DEB_TRACE_FUNC, "UserCredentialsExtract: Entering\n"));

    if (!pDigest || !(pDigest->refstrParam[MD5_AUTH_USERNAME].Length))
    {
        Status = STATUS_NO_SUCH_USER;
        DebugLog((DEB_ERROR, "UserCredentialsExtract: Invalid Username or realm\n"));
        goto CleanUp;
    }

    Status = DigestDecodeDirectiveStrings(pDigest);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "UserCredentialsExtract: DigestDecodeDirectiveStrings  error 0x%x\n", Status));
        goto CleanUp;
    }

    // parse out the username & domain

    pUserCreds->typeName = pDigest->typeName;       // Indicate which type of name format utilized

    Status = UnicodeStringDuplicate(&(pUserCreds->ustrUsername), &(pDigest->ustrCrackedAccountName));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "UserCredentialsExtract: UnicodeStringDuplicate  Username  error 0x%x\n", Status));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicate(&(pUserCreds->ustrDomain), &(pDigest->ustrCrackedDomain));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "UserCredentialsExtract: UnicodeStringDuplicate  Domain  error 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "UserCredentialsExtract: Hash index %d   Account %wZ   Domain %wZ\n",
              pUserCreds->wHashSelected,
              &(pUserCreds->ustrUsername),
              &(pUserCreds->ustrDomain)));

    DebugLog((DEB_TRACE_FUNC, "UserCredentialsExtract: Leaving   Status 0x%x\n", Status));

CleanUp:

    return(Status);
}


//   Release memory allocated into UserCredentials
NTSTATUS UserCredentialsFree(PUSER_CREDENTIALS pUserCreds)
{
    NTSTATUS Status = STATUS_SUCCESS;

    UnicodeStringFree(&(pUserCreds->ustrUsername));
    if (pUserCreds->ustrPasswd.MaximumLength)
    {
        ZeroMemory(pUserCreds->ustrPasswd.Buffer, pUserCreds->ustrPasswd.MaximumLength);
    }
    UnicodeStringFree(&(pUserCreds->ustrPasswd));
    UnicodeStringFree(&(pUserCreds->ustrDomain));
    if (pUserCreds->strDigestHash.MaximumLength)
    {
        ZeroMemory(pUserCreds->strDigestHash.Buffer, pUserCreds->strDigestHash.MaximumLength);
    }
    StringFree(&(pUserCreds->strDigestHash));

    return(Status);
}





//+--------------------------------------------------------------------
//
//  Function:   DigestSASLResponseAuth
//
//  Synopsis:   Generate the ResponseAuth from the server
//
//  Arguments:  pDigest - pointer to Digest parameter struct
//              pCoutputToken - location to send output string to
//
//  Returns: NTSTATUS
//
//  Notes: 
//
//---------------------------------------------------------------------

NTSTATUS DigestSASLResponseAuth(
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSecBuffer pOutputToken)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cbLenNeeded = 0;
    STRING strReqAuth;

    PCHAR pczTemp = NULL;

    ZeroMemory(&strReqAuth, sizeof(strReqAuth));

    ASSERT(pDigest);

    DebugLog((DEB_TRACE_FUNC, "DigestSASLResponseAuth: Entering\n"));

    Status = DigestCalculateResponseAuth(pDigest, &strReqAuth);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestSASLResponseAuth: Request Auth failed : 0x%x\n", Status));
        goto CleanUp;
    }

    cbLenNeeded = sizeof(RSPAUTH_STR);
    cbLenNeeded += strReqAuth.Length;

    // allocate the buffers for output - in the future can optimze to allocate exact amount needed
    pczTemp = (PCHAR)DigestAllocateMemory(cbLenNeeded + 1);
    if (!pczTemp)
    {
        DebugLog((DEB_ERROR, "ContextCreateChal:  No memory for output buffers\n"));
        goto CleanUp;
    }

    sprintf(pczTemp, RSPAUTH_STR, &strReqAuth); 

    pOutputToken->cbBuffer = strlen(pczTemp);
    pOutputToken->pvBuffer = pczTemp;


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestSASLResponseAuth: Leaving 0x%x\n", Status));

    StringFree(&strReqAuth);
    return Status;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestCalculateResponseAuth
//
//  Synopsis:   Calculate the ResponseAuth Hash value
//
//  Arguments:  pDigest - pointer to Digest parameter struct
//              pCoutputToken - location to send output string to
//
//  Returns: NTSTATUS
//
//  Notes: 
//
//---------------------------------------------------------------------
NTSTATUS DigestCalculateResponseAuth(
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSTRING pstrHash)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cbLenNeeded = 0;
    STRING strHA2;
    STRING strcQOP;

    PCHAR pczTemp = NULL;

    ZeroMemory(&strHA2, sizeof(strHA2));

    ASSERT(pDigest);
    ASSERT(pstrHash);


    DebugLog((DEB_TRACE_FUNC, "DigestCalculateResponseAuth: Entering\n"));

    DigestPrint(pDigest);

    StringFree(pstrHash);


    // Establish which QOP utilized
    if (pDigest->typeQOP == AUTH_CONF)
    {
        RtlInitString(&strcQOP, AUTHCONFSTR);
    }
    else if (pDigest->typeQOP == AUTH_INT)
    {
        RtlInitString(&strcQOP, AUTHINTSTR);
    }
    else if (pDigest->typeQOP == AUTH)
    {
        RtlInitString(&strcQOP, AUTHSTR);
    }
    else
    {
        RtlInitString(&strcQOP, NULL);
    }

    // Calculate H(A2)
    // For QOP unspecified or "auth"  H(A2) = H( : URI)
    // For QOP Auth-int or Auth-conf  H(A2) = H( : URI: H(entity-body))
    if ((pDigest->typeQOP == AUTH) || (pDigest->typeQOP == NO_QOP_SPECIFIED))
    {
        // Unspecified or Auth
        DebugLog((DEB_TRACE, "DigestCalculateResponseAuth: H(A2) using AUTH/Unspecified\n"));
        Status = DigestHash7(NULL,
                             &(pDigest->refstrParam[MD5_AUTH_URI]),
                             NULL, NULL, NULL, NULL, NULL,
                             TRUE, &strHA2);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalculateResponseAuthDigestCalculateResponseAuth:  H(A2) failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        // Auth-int or Auth-conf
        DebugLog((DEB_TRACE, "DigestCalculateResponseAuth: H(A2) using AUTH-INT/CONF\n"));
        Status = DigestHash7(NULL,
                             &(pDigest->refstrParam[MD5_AUTH_URI]),
                             &(pDigest->refstrParam[MD5_AUTH_HENTITY]),
                             NULL, NULL, NULL, NULL,
                             TRUE, &strHA2);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalculateResponseAuth H(A2) auth-int failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    // We now have calculated H(A2)


    // Calculate Request-Digest
    // For QOP of Auth, Auth-int, Auth-conf    Req-Digest = H( H(A1): nonce: nc: cnonce: qop: H(A2))
    Status = DigestHash7(&(pDigest->strSessionKey),
                     &(pDigest->refstrParam[MD5_AUTH_NONCE]),
                     &(pDigest->refstrParam[MD5_AUTH_NC]),
                     &(pDigest->refstrParam[MD5_AUTH_CNONCE]),
                     &strcQOP,
                     &strHA2, NULL,
                     TRUE, pstrHash);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalculateResponseAuth: Request Auth failed : 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "DigestCalculateResponseAuth: ResponseAuth is %Z\n", pstrHash));

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestCalculateResponseAuth: Leaving 0x%x\n", Status));

    StringFree(&strHA2);
    
    return Status;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestDecodeUserAccount
//
//  Synopsis:   Process the Digest to extract Account Username, Account Domain
//      generic passthrough domain controller, and index for precalculated digest hash
//
//  Arguments:  pDigest - pointer to Digest parameter struct
//              pustrUsername - username extracted from digest
//              pusrtUserDomain - domain indicated for account
//              pustrDC - domain to pass generic passthrough to
//              pPreCalcIndx - index to use for precalculated index
//
//  Returns: NTSTATUS
//
//  Notes: 
//
//---------------------------------------------------------------------
NTSTATUS DigestDecodeUserAccount(
    IN PDIGEST_PARAMETER pDigest,
    OUT PUNICODE_STRING pustrDC)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NAMEFORMAT_TYPE Indx = NAMEFORMAT_UNKNOWN;
    USHORT usTemp = 0;
    DWORD DsStatus = 0;
    HANDLE hDS = NULL;

    WCHAR wczName[UNLEN+1];
    PWCHAR pwczAcct = NULL;

    WCHAR wczCrackedDnsDomain[DNS_MAX_NAME_LENGTH + 1 + 1];                     // ensured a NULL terminator
    DWORD dwCrackedDnsDomainCnt = (DNS_MAX_NAME_LENGTH+1) * sizeof(WCHAR);
    WCHAR wczCrackedName[UNLEN+DNS_MAX_NAME_LENGTH + 2 + 1];
    DWORD dwCrackedNameCnt = ((UNLEN+DNS_MAX_NAME_LENGTH + 2) * sizeof(WCHAR));
    DWORD dwCrackError = 0; 

    DebugLog((DEB_TRACE_FUNC, "DigestDecodeUserAccount: Entering\n"));



    DebugLog((DEB_TRACE, "DigestDecodeUserAccount: Checking format on username %wZ\n", &pDigest->ustrUsername));

    if (pDigest->ustrUsername.Length / sizeof(WCHAR) > UNLEN)
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestDecodeUserAccount: Username too long 0x%x\n", Status));
        goto CleanUp;
    }

    // Now copy string and NULL terminate
    ZeroMemory(wczName, sizeof(wczName));
    ZeroMemory(wczCrackedDnsDomain, sizeof(wczCrackedDnsDomain));
    ZeroMemory(wczCrackedName, sizeof(wczCrackedName));

    memcpy(wczName, pDigest->ustrUsername.Buffer, pDigest->ustrUsername.Length);

    // 1. If provided username and realm (assumed to be domain) use that
    if ((pDigest->ustrRealm.Length) && (pDigest->ustrUsername.Length))
    {
        Indx = NAMEFORMAT_ACCOUNTNAME;

        if (pustrDC)
        {
            UnicodeStringFree(pustrDC);
            UnicodeStringDuplicate(pustrDC, &(pDigest->ustrRealm));
            DebugLog((DEB_TRACE, "DigestDecodeUserAccount: GenericPassthrough DC %wZ\n",
                       pustrDC));
        }

        Status = UnicodeStringDuplicate(&(pDigest->ustrCrackedAccountName), &pDigest->ustrUsername);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeUserAccount: UnicodeStringDuplicate  Username  error 0x%x\n", Status));
            goto CleanUp;
        }

        Status = UnicodeStringDuplicate(&(pDigest->ustrCrackedDomain), &(pDigest->ustrRealm));
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeUserAccount: UnicodeStringDuplicate  Domain  error 0x%x\n", Status));
            goto CleanUp;
        }

        pDigest->typeName = Indx;
        Status = STATUS_SUCCESS;
        goto CleanUp;
    }
/*
    // 2. Check for UPN
    DebugLog((DEB_TRACE, "DigestDecodeUserAccount: Checking with CrackSingleName\n"));
    Status = CrackSingleName(DS_USER_PRINCIPAL_NAME,
                             DS_NAME_NO_FLAGS,
                             wczName,
                             DS_NT4_ACCOUNT_NAME,
                             &dwCrackedDnsDomainCnt,
                             wczCrackedDnsDomain,
                             &dwCrackedNameCnt,
                             wczCrackedName,
                             &dwCrackError);
    if (NT_SUCCESS(Status) && (DS_NAME_NO_ERROR == dwCrackError))
    {
        DebugLog((DEB_TRACE, "DigestDecodeUserAccount: CrackSingleName DS_USER_PRINCIPAL_NAME Succeeded\n"));
        DebugLog((DEB_TRACE, "DigestDecodeUserAccount: CrackSingleName dwErr 0x%x   CrackName %S    CrackDomain %S\n",
                   dwCrackError,
                  wczCrackedName,
                  wczCrackedDnsDomain));

        Indx = NAMEFORMAT_UPN;


        // Output name format always will be domain+'\'+account+'\0'
        // Need account location
        pwczAcct = wcschr(wczCrackedName, L'\\');
        if (!pwczAcct)
        {
            Status = STATUS_INVALID_ADDRESS;
            DebugLog((DEB_ERROR, "DigestDecodeUserAccount: Can not locate Account name  0x%x\n", Status));
            goto CleanUp;
        }

        Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedAccountName), pwczAcct+1);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeUserAccount: UnicodeStringDuplicate  Username  error 0x%x\n", Status));
            goto CleanUp;
        }

        Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedDomain), wczCrackedDnsDomain);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeUserAccount: UnicodeStringDuplicate  Domain  error 0x%x\n", Status));
            goto CleanUp;
        }

        if (pustrDC)
        {
            UnicodeStringFree(pustrDC);
            UnicodeStringDuplicate(pustrDC, &(pDigest->ustrCrackedDomain));
            DebugLog((DEB_TRACE, "DigestDecodeUserAccount: GenericPassthrough DC %wZ\n",
                       pustrDC));
        }

        pDigest->typeName = Indx;
        Status = STATUS_SUCCESS;
        goto CleanUp;
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestDecodeUserAccount: CrackSingleName DS_USER_PRINCIPAL_NAME Failed 0x%x  CrackErr 0x%x\n",
                   Status,
                  dwCrackError));
    }

    // 2. Check for NetBIOS
    DebugLog((DEB_TRACE, "DigestDecodeUserAccount: Checking with CrackSingleName\n"));
    Status = CrackSingleName(DS_NT4_ACCOUNT_NAME,
                             DS_NAME_NO_FLAGS,
                             wczName,
                             DS_NT4_ACCOUNT_NAME,
                             &dwCrackedDnsDomainCnt,
                             wczCrackedDnsDomain,
                             &dwCrackedNameCnt,
                             wczCrackedName,
                             &dwCrackError);
    if (NT_SUCCESS(Status) && (DS_NAME_NO_ERROR == dwCrackError))
    {
        DebugLog((DEB_TRACE, "DigestDecodeUserAccount: CrackSingleName DS_NT4_ACCOUNT_NAME Succeeded\n"));
        DebugLog((DEB_TRACE, "DigestDecodeUserAccount: CrackSingleName dwErr 0x%x   CrackName %S    CrackDomain %S\n",
                   dwCrackError,
                  wczCrackedName,
                  wczCrackedDnsDomain));

        Indx = NAMEFORMAT_NETBIOS;

        // Output name format always will be domain+'\'+account+'\0'
        // Need account location
        pwczAcct = wcschr(wczCrackedName, L'\\');
        if (!pwczAcct)
        {
            Status = STATUS_INVALID_ADDRESS;
            DebugLog((DEB_ERROR, "DigestDecodeUserAccount: Can not locate Account name  0x%x\n", Status));
            goto CleanUp;
        }

        Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedAccountName), pwczAcct+1);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeUserAccount: UnicodeStringDuplicate  Username  error 0x%x\n", Status));
            goto CleanUp;
        }

        Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedDomain), wczCrackedDnsDomain);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeUserAccount: UnicodeStringDuplicate  Domain  error 0x%x\n", Status));
            goto CleanUp;
        }

        if (pustrDC)
        {
            UnicodeStringFree(pustrDC);
            UnicodeStringDuplicate(pustrDC, &(pDigest->ustrCrackedDomain));
            DebugLog((DEB_TRACE, "DigestDecodeUserAccount: GenericPassthrough DC %wZ\n",
                       pustrDC));
        }

        pDigest->typeName = Indx;
        goto CleanUp;
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestDecodeUserAccount: CrackSingleName DS_USER_PRINCIPAL_NAME Failed 0x%x\n", Status));
    }
*/    
    // default to username
    if (Indx == NAMEFORMAT_UNKNOWN)
    {
        Status = STATUS_INVALID_ADDRESS;
        DebugLog((DEB_ERROR, "DigestDecodeUserAccount: Invalid format for username and realm\n", Status));
    }



CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestDecodeUserAccount: Leaving 0x%x\n", Status));
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\logsess.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        logsess.h
//
// Contents:    declarations, constants for logonsession manager
//
//
// History:     KDamour  13May 00   Created
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_LOGSESS_H
#define NTDIGEST_LOGSESS_H      

//  Initializes the LogonSession manager package
NTSTATUS LogSessHandlerInit(VOID);

NTSTATUS LogSessHandlerInsert(IN PDIGEST_LOGONSESSION  pDigestLogSess);

// Initialize the LogSess Structure
NTSTATUS LogonSessionInit(IN PDIGEST_LOGONSESSION pLogonSession);

// Free up memory utilized by LogonSession Structure
NTSTATUS LogonSessionFree(IN PDIGEST_LOGONSESSION pDigestLogSess);

// Locate a LogonSession based on a LogonId
NTSTATUS LogSessHandlerLogonIdToPtr(
                             IN PLUID pLogonId,
                             IN BOOLEAN ForceRemove,
                             OUT PDIGEST_LOGONSESSION * pUserLogonSession);

// Locate a LogonSession based on a Principal Name (UserName)
NTSTATUS LogSessHandlerAccNameToPtr(
                             IN PUNICODE_STRING pustrAccountName,
                             OUT PDIGEST_LOGONSESSION * pUserLogonSession);

NTSTATUS LogSessHandlerRelease(PDIGEST_LOGONSESSION pLogonSession);

// Set the unicode string password in the LogonSession
NTSTATUS LogSessHandlerPasswdSet(
                                IN PLUID pLogonId,
                                IN PUNICODE_STRING pustrPasswd);

// Get the unicode string password in the logonsession
NTSTATUS LogSessHandlerPasswdGet(
                             IN PDIGEST_LOGONSESSION pLogonSession,
                             OUT PUNICODE_STRING pustrPasswd);

#endif // NTDIGEST_LOGSESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\global.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        global.h
//
// Contents:    global include file for NTDigest security package
//
//
// History:     KDamour 15Mar00   Stolen from msv_sspi\global.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_GLOBAL_H
#define NTDIGEST_GLOBAL_H


#ifndef UNICODE
#define UNICODE
#endif // UNICODE


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#include <windows.h>
#ifndef RPC_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H
#include <rpc.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>


#include <dns.h>


// For notify.cxx  DsGetDcName
#include <dsgetdc.h>
#include <lm.h>

// For notify.cxx  DsRoleGetPrimaryDomainInformation
#include <Dsrole.h>

#include <md5.h>
#include <hmac.h>

#include <pac.hxx>

#include <wow64t.h>

// Local includes for NT Digest Access SSP
#include "debug.h"          /* Support for dsysdbg logging */
#include "wdigest.h"
#include "ntdigest.h"       /* Prototype functions for package */
#include "digestsspi.h"
#include "func.h"           // Forward declearations of functions
#include "util.h"
#include "lsaap.h"

#include "ctxt.h"
#include "cred.h"
#include "logsess.h"
#include "nonce.h"
#include "auth.h"
#include "user.h"



// Code page for latin-1  ISO-8859-1  (for unicode conversion)
#define CP_8859_1  28591


// Various character definiations
#define CHAR_BACKSLASH '\\'
#define CHAR_DQUOTE    '"'
#define CHAR_EQUAL     '='
#define CHAR_COMMA     ','
#define CHAR_NULL      '\0'


#define SECONDS_TO_100NANO  10000000        // Convert 100 nanoseconds to seconds


//  General Macros
#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }


//
// Macro to return the type field of a SecBuffer
//

#define BUFFERTYPE(_x_) ((_x_).BufferType & ~SECBUFFER_ATTRMASK)
#define PBUFFERTYPE(_x_) ((_x_)->BufferType & ~SECBUFFER_ATTRMASK)


//
// Macros for manipulating globals
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef NTDIGEST_GLOBAL
#define EXTERN
#else
#define EXTERN extern
#endif // NTDIGEST_GLOBAL


typedef enum _NTDIGEST_STATE {
    NtDigestLsaMode = 1,
    NtDigestUserMode
} NTDIGEST_STATE, *PNTDIGEST_STATE;

EXTERN NTDIGEST_STATE g_NtDigestState;

EXTERN ULONG_PTR g_NtDigestPackageId;

// Indicate if running on Domain Controller - used in auth.cxx
EXTERN BOOL g_fDomainController;

EXTERN SECPKG_FUNCTION_TABLE g_NtDigestFunctionTable;

// Package name - used only in Generic Passthrough operations
EXTERN UNICODE_STRING g_ustrNtDigestPackageName;

// Helper routines for use by a Security package handed over by Lsa
// User functions established in userapi.cxx
EXTERN SECPKG_USER_FUNCTION_TABLE g_NtDigestUserFuncTable;
EXTERN PSECPKG_DLL_FUNCTIONS g_UserFunctions;

// Save the PSECPKG_PARAMETERS sent in by SpInitialize
EXTERN PLSA_SECPKG_FUNCTION_TABLE g_LsaFunctions;
EXTERN SECPKG_PARAMETERS g_NtDigestSecPkg;

// Parameters set via Registry

//  Lifetime is the number seconds a NONCE is valid for before marked Stale 
EXTERN DWORD g_dwParameter_Lifetime;

//  Max number os contexts to keep; 0 means no limit 
EXTERN DWORD g_dwParameter_MaxCtxtCount;

// BOOL if local policy permits Negotiation Protocol
EXTERN BOOL g_fParameter_Negotiate;

// BOOL if local policy permits UTF-8 encoding of username and realm for HTTP requests & SASL
EXTERN BOOL g_fParameter_UTF8HTTP;
EXTERN BOOL g_fParameter_UTF8SASL;

// Value for AcquireCredentialHandle
EXTERN TimeStamp g_TimeForever;

// Amount of time in milliseconds for the garbage collector of expired contexts to sleep
EXTERN DWORD g_dwExpireSleepInterval;

// TokenSource for AuthData to Token Creation
EXTERN TOKEN_SOURCE g_DigestSource;

// TokenSource for AuthData to Token Creation
EXTERN UNICODE_STRING g_ustrWorkstationName;

// Precalculate the UTF8 and ISO versions of the Server's Realm
EXTERN STRING g_strNtDigestUTF8ServerRealm;
EXTERN STRING g_strNTDigestISO8859ServerRealm;

EXTERN PSID g_NtDigestGlobalLocalSystemSid;
EXTERN PSID g_NtDigestGlobalAliasAdminsSid;

// Memory management variables

extern PSTR MD5_AUTH_NAMES[];

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // NTDIGEST_GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\logsess.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        logsess.cxx
//
// Contents:    LogonSession functions:
//
//
// History:     KDamour  15Mar00   Stolen from NTLM
//
//------------------------------------------------------------------------
#include "global.h"

//
// Crit Sect to protect various globals in this module.
//

RTL_CRITICAL_SECTION l_LogSessCritSect;

LIST_ENTRY l_LogSessList;

// Simple variable to make sure that the package was initialize
BOOL g_bLogSessInitialized = FALSE;



//+--------------------------------------------------------------------
//
//  Function:   LogSessHandlerInit
//
//  Synopsis:   Initializes the LogonSession manager package
//
//  Arguments:  none
//
//  Returns: NTSTATUS
//
//  Notes: Called by SpInitialize
//
//---------------------------------------------------------------------
NTSTATUS
LogSessHandlerInit(VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize the LogonSession list to be empty.
    //

    Status = RtlInitializeCriticalSection(&l_LogSessCritSect);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "LogSessHandlerInit: Failed to initialize critsec   0x%x\n", Status));
        goto CleanUp;
    }
    
    InitializeListHead( &l_LogSessList );

    // Simple variable test to make sure all initialized;
    g_bLogSessInitialized = TRUE;

CleanUp:

    return Status;
}

NTSTATUS
LogSessHandlerInsert(
    IN PDIGEST_LOGONSESSION  pDigestLogSess
    )
{
    RtlEnterCriticalSection( &l_LogSessCritSect );
    InsertHeadList( &l_LogSessList, &pDigestLogSess->Next );
    RtlLeaveCriticalSection( &l_LogSessCritSect );

    return STATUS_SUCCESS;
}


// Initialize the LogSess Structure
NTSTATUS
LogonSessionInit(
    IN PDIGEST_LOGONSESSION pLogonSession)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!pLogonSession)
    {
        return STATUS_INVALID_PARAMETER;
    }

    ZeroMemory(pLogonSession, sizeof(DIGEST_LOGONSESSION));
    pLogonSession->LogonSessionHandle = (ULONG_PTR)pLogonSession;
    pLogonSession->lReferences = 1;

    return(Status);
}


// Free up memory utilized by LogonSession Structure
NTSTATUS
LogonSessionFree(
    IN PDIGEST_LOGONSESSION pDigestLogSess)
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Free up all Unicode & String structures
    UnicodeStringFree(&(pDigestLogSess->ustrAccountName));
    UnicodeStringFree(&(pDigestLogSess->ustrDownlevelName));
    UnicodeStringFree(&(pDigestLogSess->ustrDomainName));
    UnicodeStringFree(&(pDigestLogSess->ustrPassword));
    UnicodeStringFree(&(pDigestLogSess->ustrDnsDomainName));
    UnicodeStringFree(&(pDigestLogSess->ustrUpn));
    UnicodeStringFree(&(pDigestLogSess->ustrLogonServer));

    DigestFreeMemory(pDigestLogSess);

    return(Status);
}




/*++

Routine Description:

    This routine checks to see if the LogonID is from a currently
    active client, and references the LogSess if it is valid.

    The caller may optionally request that the client's LogSess be
    removed from the list of valid LogonSession - preventing future
    requests from finding this LogSess.

    For a client's LogSess to be valid, the LogSess value
    must be on our list of active LogonSession.


Arguments:

    LogonSessionHandle - Points to the LogonSession Handle of the LogSess
        to be referenced.

    ForceRemove - This boolean value indicates whether the caller
        wants the logon process's LogSess to be removed from the list
        of LogonSession.  TRUE indicates the LogSess is to be removed.
        FALSE indicates the LogSess is not to be removed.
        

Return Value:

    STATUS_INVALID_HANDLE - the LogSess was not found.

    STATUS_SUCCESS - returns a pointer to the referenced LogonSession.
        

--*/
NTSTATUS
LogSessHandlerLogonIdToPtr(
                             IN PLUID pLogonId,
                             IN BOOLEAN ForceRemove,
                             OUT PDIGEST_LOGONSESSION * ppUserLogonSession
                             )
{
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_LOGONSESSION pLogonSession = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    LONG  lReferences = 0;

    *ppUserLogonSession = NULL ;

    //
    // Acquire exclusive access to the LogonSession list
    //

    RtlEnterCriticalSection( &l_LogSessCritSect );


    //
    // Now walk the list of LogonSession looking for a match.
    //

    for ( ListEntry = l_LogSessList.Flink;
        ListEntry != &l_LogSessList;
        ListEntry = ListEntry->Flink )
    {

        pLogonSession = CONTAINING_RECORD( ListEntry, DIGEST_LOGONSESSION, Next );

        if (RtlEqualLuid(&(pLogonSession->LogonId), pLogonId))
        {
            // Found the LogonSession

            DebugLog((DEB_TRACE, "LogSessHandlerLogonIdToPtr: Found LogSess for LogonID (%x:%lx)\n",
                       pLogonId->HighPart, pLogonId->LowPart ));

            if (!ForceRemove)
            {
                lReferences = InterlockedIncrement(&pLogonSession->lReferences);

                DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Incremented ReferenceCount %ld\n", lReferences));
            }
            else
            {
                // ForceRemove of True will unlink this LogonSession from the list of active LogonSessions
                // The structure pointet will be returned for the calling function to free up if required
                // Would call LogSessHandlerRelease to dereference the counter (and maybe free up)
                
                DebugLog((DEB_TRACE, "LogSessHandlerLogonIdToPtr: Unlinking 0x%lx    Refcount = %d\n",
                          pLogonSession, pLogonSession->lReferences));

                RemoveEntryList( &pLogonSession->Next );
            }

            // Return a pointer to the LogSess found
            *ppUserLogonSession = pLogonSession ;

            goto CleanUp;
        }
    }

    //
    // No match found
    //
    DebugLog((DEB_WARN, "LogSessHandlerLogonIdToPtr: Tried to reference unknown LogonID (%x:%lx)\n",
                pLogonId->HighPart, pLogonId->LowPart ));
    Status = STATUS_INVALID_HANDLE;

CleanUp:

    RtlLeaveCriticalSection( &l_LogSessCritSect );

    return(Status);
}



// Locate a LogonSession based on a Principal Name (UserName) ok
NTSTATUS
LogSessHandlerAccNameToPtr(
                             IN PUNICODE_STRING pustrAccountName,
                             OUT PDIGEST_LOGONSESSION *ppUserLogonSession
                             )
{
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_LOGONSESSION pLogonSession = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    LONG lReferences = 0;


    *ppUserLogonSession = NULL ;

    if ((!pustrAccountName) || (!pustrAccountName->Length))
    {
        DebugLog((DEB_ERROR, "LogSessHandlerAccNameToPtr: No AccountName provided\n"));
        Status = STATUS_INVALID_PARAMETER_1;
        return(Status);
    }

    //
    // Acquire exclusive access to the LogonSession list
    //

    RtlEnterCriticalSection( &l_LogSessCritSect );


    //
    // Now walk the list of LogonSession looking for a match.
    //

    for ( ListEntry = l_LogSessList.Flink;
        ListEntry != &l_LogSessList;
        ListEntry = ListEntry->Flink )
    {

        pLogonSession = CONTAINING_RECORD( ListEntry, DIGEST_LOGONSESSION, Next );


        if ((pLogonSession->ustrAccountName).Length)
        {
            DebugLog((DEB_TRACE, "LogSessHandlerAccNameToPtr: Checking %wZ against AccountName %wZ\n",
                       &(pLogonSession->ustrAccountName), pustrAccountName ));

            if (RtlEqualUnicodeString(&(pLogonSession->ustrAccountName), pustrAccountName, TRUE))
            {
                lReferences = InterlockedIncrement(&pLogonSession->lReferences);

                DebugLog((DEB_TRACE, "LogSessHandlerAccNameToPtr: Incremented ReferenceCount %ld\n", lReferences));
    
                // Found the LogonSession
                *ppUserLogonSession = pLogonSession ;
    
                goto CleanUp;
            }
        }

    }

    //
    // No match found
    //
    DebugLog((DEB_WARN, "LogSessHandlerAccNameToPtr: Tried to reference unknown AccountName %wZ\n",
               pustrAccountName ));

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

CleanUp:

    RtlLeaveCriticalSection( &l_LogSessCritSect );

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   LogSessHandlerRelease
//
//  Synopsis:   Releases the LogonSession by decrementing reference counter
//
//  Arguments:  pLogonSession - pointer to logonsession to de-reference
//
//  Returns: NTSTATUS
//
//  Notes: Called by ACH & AcceptCredentials. Since multiple threads can have a context
//   checked out, simply decrease the reference counter on release. LsaApLogonTerminated
//   is called by LSA to remove the LogonSession from the Active LIst.
//   There can be atmost only 1 reference for a handle (owned by LSA and release by call
//   to this function).  The other references will be pointer references so these can
//   be decremented without it being attached to active logonsession list.
//
//---------------------------------------------------------------------
NTSTATUS
LogSessHandlerRelease(
    PDIGEST_LOGONSESSION pLogonSession)
{
    NTSTATUS Status = STATUS_SUCCESS;

    LONG lReferences = 0;


    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerRelease: Entering for  LogonSession 0x%0x   LogonID (%x:%lx) \n",
              pLogonSession, pLogonSession->LogonId.HighPart, pLogonSession->LogonId.LowPart));

    lReferences = InterlockedDecrement(&pLogonSession->lReferences);

    DebugLog((DEB_TRACE, "LogSessHandlerRelease: Decremented to ReferenceCount %ld\n", lReferences));

    ASSERT( lReferences >= 0 );
    //
    // If the count has dropped to zero, then free all alloced stuff
    //

    if (lReferences == 0)
    {
        DebugLog((DEB_TRACE, "LogSessHandlerRelease: Deleting LogonSession\n"));
        Status = LogonSessionFree(pLogonSession);
    }

    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerRelease: Leaving  Status 0x%x\n", Status));

    return(Status);
}



// Helper functions for processing fields within the logonsessions



//+--------------------------------------------------------------------
//
//  Function:   LogSessHandlerPasswdSet
//
//  Synopsis:   Set the unicode string password in the LogonSession
//
//  Arguments:  pLogonID - pointer to LogonSession LogonID to use
//              pustrPasswd - pointer to new password
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS
LogSessHandlerPasswdSet(
    IN PLUID pLogonId,
    IN PUNICODE_STRING pustrPasswd)
{

    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_LOGONSESSION pLogonSession = NULL;
    NTSTATUS Status = STATUS_SUCCESS;


    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerPasswdSet: Entering   LogonID (%x:%lx)\n",
              pLogonId->HighPart, pLogonId->LowPart));

    //
    // Acquire exclusive access to the LogonSession list
    //

    RtlEnterCriticalSection( &l_LogSessCritSect );

    //
    // Now walk the list of LogonSession looking for a match.
    //

    for ( ListEntry = l_LogSessList.Flink;
        ListEntry != &l_LogSessList;
        ListEntry = ListEntry->Flink )
    {

        pLogonSession = CONTAINING_RECORD( ListEntry, DIGEST_LOGONSESSION, Next );

        if (RtlEqualLuid(&(pLogonSession->LogonId), pLogonId))
        {
            // Found the LogonSession

            DebugLog((DEB_TRACE, "LogSessHandlerLogonIdToPtr: Found LogSess with  LogonID (%x:%lx)\n",
                       pLogonId->HighPart, pLogonId->LowPart ));

            if (pLogonSession->ustrPassword.Buffer)
            {
                UnicodeStringFree(&(pLogonSession->ustrPassword));
            }
            Status = UnicodeStringDuplicatePassword(&(pLogonSession->ustrPassword), pustrPasswd);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "LogSessHandlerPasswdGet: Error in setting LogonSession password, status 0x%0x\n", Status ));
                goto CleanUp;
            }

            DebugLog((DEB_TRACE, "LogSessHandlerPasswdSet: updated password\n"));

            goto CleanUp;
        }
    }

    //
    // No match found
    //
    DebugLog((DEB_WARN, "LogSessHandlerPasswdSet: Unable to locate LogonID (%x:%lx) \n",
               pLogonId->HighPart, pLogonId->LowPart ));

    Status = STATUS_INVALID_HANDLE;

CleanUp:

    RtlLeaveCriticalSection( &l_LogSessCritSect );

    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerPasswdSet: Exiting   LogonID (%x:%lx)\n",
              pLogonId->HighPart, pLogonId->LowPart));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   LogSessHandlerPasswdGet
//
//  Synopsis:   Get the unicode string password in the logonsession
//
//  Arguments:  pLogonSession - pointer to LogonSession to use
//              pustrPasswd - pointer to destination copy of password
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS
LogSessHandlerPasswdGet(
    IN PDIGEST_LOGONSESSION pLogonSession,
    OUT PUNICODE_STRING pustrPasswd)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerPasswdGet: Entering\n" ));

    if (pustrPasswd->Buffer)
    {
        UnicodeStringFree(pustrPasswd);
    }
            // Protect reading from the LogonSession
    RtlEnterCriticalSection( &l_LogSessCritSect );
    Status = UnicodeStringDuplicatePassword(pustrPasswd, &(pLogonSession->ustrPassword));
    RtlLeaveCriticalSection( &l_LogSessCritSect );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "LogSessHandlerPasswdGet: Error in getting LogonSession password, status 0x%0x\n", Status ));
    }

    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerPasswdGet: Exiting, status 0x%0x\n", Status ));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\digestsspi.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        digestsspi.h
//
// Contents:    credential and context structures
//
//
// History:     KDamour 15Mar00   Stolen from msv_sspi\ntlmsspi.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_DIGESTSSPI_H
#define NTDIGEST_DIGESTSSPI_H

#include <time.h>

#include "auth.h"

                                                         
////////////////////////////////////////////////////////////////////////
//
// Global Definitions
//
////////////////////////////////////////////////////////////////////////


//
// Description of a logon session - stores the username, domain, password.
//   Notation used for LogonSession  is LogSess
//

typedef struct _DIGEST_LOGONSESSION {

    // Global list of all LogonSessions.
    //  (Serialized by SspLogonSessionCritSect)
    LIST_ENTRY Next;

    // This is the Handle for this LogonSession - same as its memory address - no need to ref count
    ULONG_PTR LogonSessionHandle;

    // Ref Counter Used to prevent this LogonSession from being deleted prematurely.
    // Two cases for initial value
    //     AcceptCredential sets to one and enters it into active logon list.  Call to ApLogonTerminate
    //         decrements count and removes it from list.
    // In both cases, a refcount of zero causes the logonsession to be deleted from memory
    LONG lReferences;

     // Logon ID of the client
    LUID LogonId;

    // Default credentials on client context, on server context UserName
    // Gathered from calls to SpAcceptCredentials
    SECURITY_LOGON_TYPE LogonType;
    UNICODE_STRING ustrAccountName;
    UNICODE_STRING ustrDownlevelName;   // Sam Account Name
    UNICODE_STRING ustrDomainName;      // Netbios domain name where account is located

    // IMPORTANT NOTE - you must use CredHandlerPasswdSet and CredHandlerPasswdGet once the
    // credential is placed into the list.  The main reason for this is that multiple threads
    // will be utilizing the same memory and this value can change as updates come in from
    // SpAcceptCredential
    // It is encrypted with LsaFunctions->LsaProtectMemory( Password->Buffer, (ULONG)Password->Length );
    // Need to decrypt with LsaFunctions->LsaUnprotectMemory( HiddenPassword->Buffer, (ULONG)HiddenPassword->Length );

    // Stores the current plaintext password (if available) with reversible encryption
    UNICODE_STRING ustrPassword;

    UNICODE_STRING ustrDnsDomainName;   // DNS domain name where account is located (if known)
    UNICODE_STRING ustrUpn;             // UPN of account (if known)
    UNICODE_STRING ustrLogonServer;

} DIGEST_LOGONSESSION, *PDIGEST_LOGONSESSION;

//
// Description of a credential.
//  We use this for a combined list of logon sessions and credentials
//

typedef struct _DIGEST_CREDENTIAL {

    //
    // Global list of all Credentials.
    //  (Serialized by SspCredentialCritSect)
    //

    LIST_ENTRY Next;

    //
    // Used to prevent this Credential from being deleted prematurely.
    //

    LONG lReferences;

    //
    // Flag to indicate that Credential is not attached to CredentialList
    //  once References is 0 and Unlinked is True - this record can be removed from list

    BOOL Unlinked;


    //
    // This is the Handle for this credential - same as its memory address
    //
    ULONG_PTR CredentialHandle;

    //
    // Flag of how credential may be used.
    //
    // SECPKG_CRED_* flags
    //

    ULONG CredentialUseFlags;

    //
    // Default credentials on client context, on server context UserName
    // Gathered from calls to SpAcceptCredentials
    //

    SECURITY_LOGON_TYPE LogonType;
    UNICODE_STRING ustrAccountName;
    LUID LogonId;                       // Logon ID of the client
    UNICODE_STRING ustrDownlevelName;   // Sam Account Name
    UNICODE_STRING ustrDomainName;      // Netbios domain name where account is located

    // Stores the current plaintext (if available) version of the logon users account
    // IMPORTANT NOTE - you must use CredHandlerPasswdSet and CredHandlerPasswdGet once the
    // credential is placed into the list.  The main reason for this is that multiple threads
    // will be utilizing the same memory and this value can change as updates come in from
    // SpAcceptCredential
    // Password will be encryped with LSAFunction as in LogonSession
    UNICODE_STRING ustrPassword;

    ULONG Flags;

    UNICODE_STRING ustrDnsDomainName;   // DNS domain name where account is located (if known)
    UNICODE_STRING ustrUpn;             // UPN of account (if known)
    UNICODE_STRING ustrLogonServer;

    //
    // Process Id of client
    //

    ULONG ClientProcessID;

    //
    // Time created or last accessed (may be used for aging entries)
    //

    time_t TimeCreated;


} DIGEST_CREDENTIAL, *PDIGEST_CREDENTIAL;


//
// Description of a Context
//

typedef struct _DIGEST_CONTEXT {

    // Global list of all Contexts
    //  (Serialized by SspContextCritSect)
    LIST_ENTRY Next;

    // This is the Handle for this context - same as its memory address
    ULONG_PTR ContextHandle;

    // Used to prevent this Context from being deleted prematurely.
    //  (Serialized by SspContextCritSect)
    LONG lReferences;

    // Flag to indicate that Context is not attached to List
    BOOL bUnlinked;

    // Maintain the context requirements
    ULONG ContextReq;

    // Digest Parameters for this context
    DIGEST_TYPE typeDigest;

    // Digest Parameters for this context
    QOP_TYPE typeQOP;

    // Digest Parameters for this context
    ALGORITHM_TYPE typeAlgorithm;

    // Cipher to use for encrypt/decrypt
    CIPHER_TYPE typeCipher;

    // Charset used for digest directive values
    CHARSET_TYPE typeCharset;

    //  Server generated Nonce for Context
    STRING strNonce;

    //  Client generated CNonce for Context
    STRING strCNonce;

    // Nonce count for replay prevention
    ULONG  ulNC;

    // Maximum size for the buffers to send and receive data for auth-int and auth-conf (SASL mode)
    ULONG  ulSendMaxBuf;
    ULONG  ulRecvMaxBuf;

    //  Unique Reference for this Context   BinHex(rand[128])
    //  Utilize the First N chars of this as the CNONCE for InitializeSecurityContect
    STRING strOpaque;

    //  BinHex(H(A1)) sent from DC and stored in context for future
    //  auth without going to the DC
    STRING strSessionKey;

    // Client only -  calculated response auth to be returned from server
    STRING strResponseAuth;

    // Copy of directive values from auth - used for rspauth support
    STRING  strDirective[MD5_AUTH_LAST];


    //  Only valid after ASC has successfully authenticated and converted AuthData to Token

    // Token Handle of authenticated user
    HANDLE TokenHandle;

    // LogonID used in the Token
    LUID  LoginID;


    //
    // Information from Credentials
    //

    //
    //  Maintain a copy of the credential UseFlags (we can tell if inbound or outbound)
    //
    ULONG CredentialUseFlags;

    // Copy of the account info
    UNICODE_STRING ustrDomain;
    UNICODE_STRING ustrPassword;         // Encrypted
    UNICODE_STRING ustrAccountName;

    //
    // Process Id of client (TBD)
    //

    ULONG ClientProcessID;
    NTSTATUS LastStatus;


    // Timeout the context after awhile.
    time_t TimeCreated;
    ULONG Interval;
    TimeStamp PasswordExpires;                // Time inwhich session key expires

} DIGEST_CONTEXT, *PDIGEST_CONTEXT;



// This structure contains the state info for the User mode
// security context. It is passwd between the LSAMode and the UserMode address spaces
// In UserMode, this is unpacked into the DIGEST_USERCONTEXT struct
typedef struct _DIGEST_PACKED_USERCONTEXT{

    ULONG  ulFlags;            // Flags to control processing of packed UserContext

    //
    // Timeout the context after awhile.
    //
    TimeStamp Expires;                // Time inwhich session key expires

    //
    // Maintain the context requirements
    //

    ULONG ContextReq;

    //
    //  Maintain a copy of the credential UseFlags (we can tell if inbound or outbound)
    //

    ULONG CredentialUseFlags;

    //
    // Digest Parameters for this context
    //

    ULONG typeDigest;

    //
    // Digest Parameters for this context
    //

    ULONG typeQOP;

    //
    // Digest Parameters for this context
    //

    ULONG typeAlgorithm;

    //
    // Cipher to use for encrypt/decrypt
    //

    ULONG typeCipher;

    //
    // Charset used for digest directive values
    //

    ULONG typeCharset;

    //
    //  Max-size of message buffer to allow for auth-int & auth-conf processing
    //  This is the combined size of (HEADER + Data + Trailer)
    //  in SASL Header is zero length, max Trailer size if padding+HMAC
    //
    ULONG ulSendMaxBuf;
    ULONG ulRecvMaxBuf;

    //
    // Token Handle of authenticated user
    //  Only valid when in AuthenticatedState.
    //     Filled in only by AcceptSecurityContext
    //     It will be NULL is struct is from InitializeSecurityContext
    //  Must cast this to a HANDLE once back into the usermode context
    //

    ULONG ClientTokenHandle;

    //  Size of each component set over
    ULONG   uSessionKeyLen;
    ULONG   uAccountNameLen;
    ULONG   uDigestLen[MD5_AUTH_LAST];

    // All directive data will be passed as single byte charaters
    // Order is the same as in auth.h (MD5_AUTH_NAME)
    // username, realm, nonce, cnonce ...  then sessionkey
    UCHAR    ucData;


} DIGEST_PACKED_USERCONTEXT, * PDIGEST_PACKED_USERCONTEXT;


// This structure contains the state info for the User mode
// security context.
typedef struct _DIGEST_USERCONTEXT{

    //
    // Global list of all Contexts
    //  (Serialized by UserContextCritSect)
    //
    LIST_ENTRY           Next;

    //
    // Handle to the LsaContext
    //     This will have the handle to the context in LSAMode Address space
    //
    ULONG_PTR            LsaContext;

    //
    // Timeout the context after awhile.
    //
    TimeStamp Expires;                // Time inwhich session key expires

    //
    // Used to prevent this Context from being deleted prematurely.
    //  (Serialized by Interlocked*)
    //

    LONG      lReferences;

    //
    // Flag to indicate that Context is not attached to List - skip when scanning list
    //

    BOOL      bUnlinked;

    //
    // Digest Parameters for this context
    //

    DIGEST_TYPE typeDigest;

    //
    // QOP selected for this context
    //

    QOP_TYPE typeQOP;

    //
    // Digest Parameters for this context
    //

    ALGORITHM_TYPE typeAlgorithm;

    //
    // Cipher to use for encrypt/decrypt
    //

    CIPHER_TYPE typeCipher;

    //
    // Charset used for digest directive values
    //
    CHARSET_TYPE typeCharset;

    //
    // Token Handle of authenticated user
    //  Only valid when in AuthenticatedState.
    //     Filled in only by AcceptSecurityContext                     - so we are the server
    //     Mapped to UserMode Client space from LSA TokenHandle
    //     It will be NULL is struct is from InitializeSecurityContext - so we are client
    //

    HANDLE ClientTokenHandle;


    //
    // Maintain the context requirements
    //

    ULONG ContextReq;

    //
    //  Maintain a copy of the credential UseFlags (we can tell if inbound or outbound)
    //

    ULONG CredentialUseFlags;

    // Flags TBD
    ULONG         ulFlags;


    // Nonce Count
    ULONG         ulNC;

    // Maxbuffer for auth-int and auth-conf processing
    ULONG         ulSendMaxBuf;
    ULONG         ulRecvMaxBuf;

    // SASL sequence numbering
    DWORD  dwSendSeqNum;                        // Makesignature/verifysignature server to client sequence number
    DWORD  dwRecvSeqNum;                        // Makesignature/verifysignature server to client sequence number

    // SASL Sign and Seal Keys.  Save calculated values on sequence number = 0
    BYTE bKcSealHashData[MD5_HASH_BYTESIZE];
    BYTE bKiSignHashData[MD5_HASH_BYTESIZE];
    BYTE bKcUnsealHashData[MD5_HASH_BYTESIZE];
    BYTE bKiVerifyHashData[MD5_HASH_BYTESIZE];

    BYTE bSealKey[MD5_HASH_BYTESIZE];
    BYTE bUnsealKey[MD5_HASH_BYTESIZE];

    HCRYPTKEY hSealCryptKey;   // Handle to Cryptkey based on Byte keys
    HCRYPTKEY hUnsealCryptKey;

    //
    //  Hex(H(A1)) sent from DC and stored in context for future
    //  auth without going to the DC. Binary version is derived from HEX(H(A1))
    //  and is used in SASL mode for integrity protection and encryption
    //

    STRING    strSessionKey;
    BYTE      bSessionKey[MD5_HASH_BYTESIZE];

    // Account name used in token creation for securityContext session
    UNICODE_STRING ustrAccountName;

    //
    //  Values utilized in the Initial Digest Auth ChallResponse
    //
    STRING strParam[MD5_AUTH_LAST];         // points to owned memory - will need to free up!


} DIGEST_USERCONTEXT, * PDIGEST_USERCONTEXT;


#endif // ifndef NTDIGEST_DIGESTSSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\lsaap.cxx ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:       lsaap.cxx
//
// Contents:   Authentication package dispatch routines
//               LsaApInitializePackage (Not needed done in SpInitialize)
//               LsaApLogonUser2
//               LsaApCallPackage
//               LsaApCallPackagePassthrough
//               LsaApLogonTerminated
//
//             Helper functions:
//
// History:    KDamour  10Mar00   Stolen from msv_sspi\msv1_0.c
//
//---------------------------------------------------------------------


#include "global.h"

#include <samisrv.h>

#define SAM_CLEARTEXT_CREDENTIAL_NAME L"CLEARTEXT"
#define SAM_WDIGEST_CREDENTIAL_NAME   WDIGEST_SP_NAME     // Name of the Supplemental (primary) cred blob for MD5 hashes


/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage().

--*/
NTSTATUS
LsaApCallPackage (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

{
    ULONG MessageType;

    DebugLog((DEB_TRACE_FUNC, "LsaApCallPackage: Entering/Leaving \n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage() for untrusted clients.


--*/
NTSTATUS
LsaApCallPackageUntrusted (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

{
    ULONG MessageType;

    DebugLog((DEB_TRACE_FUNC, "LsaApCallPackageUntrusted: Entering/Leaving \n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage() for passthrough logon requests.
    When the passthrough is called (from AcceptSecurityCOntext)
    a databuffer is sent to the DC and this function is called.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the protocol message was resident.
        This may be necessary to fix-up any pointers within the
        protocol message buffer.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Is used to return the address of the
        protocol buffer in the client process.  The authentication
        package is responsible for allocating and returning the
        protocol buffer within the client process.  This buffer is
        expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned protocol buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the return
        buffer could not could not be allocated because the client
        does not have sufficient quota.




--*/
NTSTATUS
LsaApCallPackagePassthrough (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusProtocol = STATUS_SUCCESS;
    PDIGEST_BLOB_REQUEST pDigestBlob = NULL;
    ULONG MessageType = 0;
    USHORT i = 0;
    ULONG ulReturnBuffer = 0;
    BYTE *pReturnBuffer = NULL;


    DebugLog((DEB_TRACE_FUNC, "LsaApCallPackagePassthrough: Entering \n"));

    
    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(ULONG) ) {
        DebugLog((DEB_ERROR, "FAILED message size to contain MessageType\n"));
        return STATUS_INVALID_PARAMETER;
    }

    memcpy((char *)&MessageType, (char *)ProtocolSubmitBuffer, sizeof(MessageType));

    if ( MessageType != VERIFY_DIGEST_MESSAGE)
    {
        DebugLog((DEB_ERROR, "FAILED to have correct message type\n"));
        return STATUS_ACCESS_DENIED;
    }

    //
    // Allow the DigestCalc routine to only set the return buffer information
    // on success conditions.
    //

    DebugLog((DEB_TRACE, "LsaApCallPackagePassthrough: setting return buffers to NULL\n"));
    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

       // We will need to free any memory allocated in the Returnbuffer
    StatusProtocol = DigestPackagePassthrough((USHORT)SubmitBufferLength, (BYTE *)ProtocolSubmitBuffer,
                         &ulReturnBuffer, &pReturnBuffer);
    if (!NT_SUCCESS(StatusProtocol))
    {
        DebugLog((DEB_ERROR,"LsaApCallPackagePassthrough: DigestPackagePassthrough failed 0x%x\n",Status));
        ulReturnBuffer = 0;
        goto CleanUp;
    }

    // DebugLog((DEB_TRACE, "LsaApCallPackagePassthrough: setting return auth status to STATUS_SUCCEED\n"));
    // DebugLog((DEB_TRACE, "LsaApCallPackagePassthrough: Total Return Buffer size %ld bytes\n", ulReturnBuffer));

    // Now place the data back to the client (the server calling this)
    Status = g_LsaFunctions->AllocateClientBuffer(
                NULL,
                ulReturnBuffer,
                ProtocolReturnBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto CleanUp;
    }
    Status = g_LsaFunctions->CopyToClientBuffer(
                NULL,
                ulReturnBuffer,
                *ProtocolReturnBuffer,
                pReturnBuffer
                );
    if (!NT_SUCCESS(Status))
    {     // Failed to copy over the data to the client
        g_LsaFunctions->FreeClientBuffer(
            NULL,
            *ProtocolReturnBuffer
            );
        *ProtocolReturnBuffer = NULL;
    }
    else
    {
        *ReturnBufferLength = ulReturnBuffer;
    }

CleanUp:

    *ProtocolStatus = StatusProtocol;

    if (pReturnBuffer)
    {
       DigestFreeMemory(pReturnBuffer);
       pReturnBuffer = NULL;
       ulReturnBuffer = 0;
    }

    DebugLog((DEB_TRACE_FUNC, "LsaApCallPackagePassthrough: Leaving  Status 0x%x\n", Status));
    return(Status);
}


/*++

Routine Description:

    This routine is used to authenticate a user logon attempt.  This is
    the user's initial logon.  A new LSA logon session will be established
    for the user and validation information for the user will be returned.


--*/
NTSTATUS
LsaApLogonUserEx2 (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * SupplementalCredentials
    )


{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "LsaApLogonUserEx2: Entering/Leaving \n"));

    //
    // Return status to the caller
    //

    return (SEC_E_UNSUPPORTED_FUNCTION);

}


/*++

Routine Description:

    This routine is used to notify each authentication package when a logon
    session terminates.  A logon session terminates when the last token
    referencing the logon session is deleted.

Arguments:

    LogonId - Is the logon ID that just logged off.

Return Status:

    None.
--*/
VOID
LsaApLogonTerminated (
    IN PLUID pLogonId
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_LOGONSESSION pLogonSession = NULL;
    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "LsaApLogonTerminated: Entering LogonID (%x:%lx) \n",
              pLogonId->HighPart, pLogonId->LowPart));

    //
    // Find the entry, dereference, and de-link it from the active logon table.
    //

    Status = LogSessHandlerLogonIdToPtr(pLogonId, TRUE, &pLogonSession);
    if (!NT_SUCCESS(Status))
    {
        goto CleanUp;    // No LongonID found in Active list - simply exit quietly
    }

    DebugLog((DEB_TRACE, "LsaApLogonTerminated: Found LogonID (%x:%lx) \n",
              pLogonId->HighPart, pLogonId->LowPart));


    // This relies on the LSA terminating all of the credentials before killing off
    // the LogonSession.

    lReferences = InterlockedDecrement(&pLogonSession->lReferences);

    DebugLog((DEB_TRACE, "LsaApLogonTerminated: Refcount %ld \n", lReferences));

    ASSERT( lReferences >= 0 );

    if (lReferences)
    {
        DebugLog((DEB_WARN, "LsaApLogonTerminated: WARNING Terminate LogonID (%x:%lx) non-zero RefCount!\n",
                  pLogonId->HighPart, pLogonId->LowPart));
    }
    else
    {
        DebugLog((DEB_TRACE, "LsaApLogonTerminated: Removed LogonID (%x:%lx) from Active List! \n",
                  pLogonId->HighPart, pLogonId->LowPart));

        LogonSessionFree(pLogonSession);
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "LsaApLogonTerminated: Exiting LogonID (%x:%lx) \n",
              pLogonId->HighPart, pLogonId->LowPart));

    return;
}


// Routine to acquire the plaintext password for a given user
// If supplemental credentials exist that contain the Digest Hash values
//    then return them also.
// This routine runs on the domain controller
// Must provide STRING strPasswd
// If ppucUserAuthData pointer is NULL - do not retrieve UserAuthData

NTSTATUS
DigestGetPasswd(
    IN PUSER_CREDENTIALS pUserCreds,
    OUT PUCHAR * ppucUserAuthData,
    OUT PULONG pulAuthDataSize
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_HANDLE UserHandle = NULL;
    UNICODE_STRING ustrcPackageName;

    UNICODE_STRING ustrcTemp;
    STRING strcTemp;
    PVOID pvPlainPwd = NULL;
    PVOID pvHashCred = NULL;
    ULONG ulLenPassword = 0;
    ULONG ulLenHash = 0;
    ULONG ulVersion = 0;
    BOOL bOpenedSAM = FALSE;

    DebugLog((DEB_TRACE_FUNC,"DigestGetPasswd: Entering\n"));

    RtlZeroMemory(&ustrcTemp, sizeof(ustrcTemp));
    RtlZeroMemory(&strcTemp, sizeof(strcTemp));
    RtlZeroMemory(&ustrcPackageName, sizeof(ustrcPackageName));
    pUserCreds->fIsValidDigestHash = FALSE;
    pUserCreds->fIsValidPasswd = FALSE;

    *pulAuthDataSize = 0L;
    *ppucUserAuthData = NULL;

    DebugLog((DEB_TRACE,"DigestGetPasswd: looking for username (unicode) %wZ\n", &(pUserCreds->ustrUsername)));

    if (!g_fDomainController)
    {
        DebugLog((DEB_ERROR,"DigestGetPasswd: Not on a domaincontroller - can not get credentials\n"));
        Status =  STATUS_INVALID_SERVER_STATE;
        goto CleanUp;
    }

    //  Call LsaOpenSamUser()
    Status = g_LsaFunctions->OpenSamUser(&(pUserCreds->ustrUsername), SecNameSamCompatible,
                                         NULL, FALSE, 0, &UserHandle);
    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog((DEB_ERROR, "DigestGetPasswd: Failed to open SAM for user %wZ, Status = 0x%x\n",
                   &(pUserCreds->ustrUsername), Status));
        goto CleanUp;
    }
    bOpenedSAM = TRUE;


    DebugLog((DEB_TRACE,"DigestGetPasswd: Have a valid UserHandle\n"));

    //
    // Retrieve the MD5 hashed pre-calculated values if they exist for this user
    //
    // NOTE : On NT 5, this API only works on Domain Controllers !!
    //
    RtlInitUnicodeString(&ustrcPackageName, SAM_WDIGEST_CREDENTIAL_NAME);

    Status = SamIRetrievePrimaryCredentials( (SAMPR_HANDLE) UserHandle,
                                             &ustrcPackageName,
                                             &pvHashCred,
                                             &ulLenHash);

    if (!NT_SUCCESS( Status ))
    {
        pvHashCred = NULL;
        DebugLog((DEB_TRACE,"DigestGetPasswd: NO Pre-calc Hashes were found for user\n"));
    }
    else
    {

        strcTemp.Buffer = (PCHAR) pvHashCred;
        strcTemp.Length = strcTemp.MaximumLength = (USHORT) ulLenHash;

        Status = StringDuplicate(&(pUserCreds->strDigestHash), &strcTemp);
        if (!NT_SUCCESS( Status ))
        {
            DebugLog((DEB_ERROR, "DigestGetPasswd: Failed to copy plaintext password, error 0x%x\n", Status));
            goto CleanUp;
        }

        // DebugLog((DEB_TRACE,"DigestGetPasswd: Have the PASSWORD %wZ\n", &(pUserCreds->ustrPasswd)));


        Status = RtlCharToInteger(pUserCreds->strDigestHash.Buffer, TENBASE, &ulVersion);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog((DEB_ERROR, "DigestGetPasswd: Badly formatted pre-calc version\n"));
            goto CleanUp;
        }

        // Check version and size of credentials
        if ((ulVersion != SUPPCREDS_VERSION) || (ulLenHash < (TOTALPRECALC_HEADERS * MD5_HASH_BYTESIZE)))
        {
            DebugLog((DEB_ERROR, "DigestGetPasswd: Invalid precalc version or size\n"));
            pUserCreds->fIsValidDigestHash = FALSE;
        }
        else
        {
            pUserCreds->fIsValidDigestHash = TRUE;
            // setup the hashes to utilize  - get format from the notify.cxx hash calcs
            switch (pUserCreds->typeName)
            {
            case NAMEFORMAT_ACCOUNTNAME:
                pUserCreds->sHashTags[NAME_ACCT] = 1;
                pUserCreds->sHashTags[NAME_ACCT_DOWNCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCT_UPCASE] = 1;
                break;
            case NAMEFORMAT_UPN:
                pUserCreds->sHashTags[NAME_UPN] = 1;
                pUserCreds->sHashTags[NAME_UPN_DOWNCASE] = 1;
                pUserCreds->sHashTags[NAME_UPN_UPCASE] = 1;
                break;
            case NAMEFORMAT_NETBIOS:
                pUserCreds->sHashTags[NAME_NT4] = 1;
                pUserCreds->sHashTags[NAME_NT4_DOWNCASE] = 1;
                pUserCreds->sHashTags[NAME_NT4_UPCASE] = 1;
                break;
            default:
                break;
            }
        }


        DebugLog((DEB_TRACE,"DigestGetPasswd: Read in Pre-calc Hashes  size = %lu\n", ulLenHash));
    }
    
    //
    // Retrieve the plaintext password
    //
    // NOTE : On NT 5, this API only works on Domain Controllers !!
    //
    RtlInitUnicodeString(&ustrcPackageName, SAM_CLEARTEXT_CREDENTIAL_NAME);

    // Note:  Would be nice to have this as a LSAFunction
    Status = SamIRetrievePrimaryCredentials( (SAMPR_HANDLE) UserHandle,
                                             &ustrcPackageName,
                                             &pvPlainPwd,
                                             &ulLenPassword);

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "DigestGetPasswd: Failed to retrieve plaintext password, error 0x%x\n", Status));

        if (pUserCreds->fIsValidDigestHash == FALSE)
        {
            // We have no pre-computed MD5 hashes and also no cleartext password
            // we can not perform any Digest Auth operations
            //
            // Explicitly set the status to be "wrong password" instead of whatever
            // is returned by SamIRetrievePrimaryCredentials
            //
            Status = STATUS_WRONG_PASSWORD;
            DebugLog((DEB_ERROR,"DigestGetPasswd: Can not obtain cleartext or Hashed Creds\n"));
            goto CleanUp;
        }

    }
    else
    {
        ustrcTemp.Buffer = (PUSHORT) pvPlainPwd;
        ustrcTemp.Length = ustrcTemp.MaximumLength = (USHORT) ulLenPassword;

        Status = UnicodeStringDuplicate(&(pUserCreds->ustrPasswd), &ustrcTemp);
        if (!NT_SUCCESS( Status ))
        {
            DebugLog((DEB_ERROR, "DigestGetPasswd: Failed to copy plaintext password, error 0x%x\n", Status));
            goto CleanUp;
        }

        // DebugLog((DEB_TRACE,"DigestGetPasswd: Have the PASSWORD %wZ\n", &(pUserCreds->ustrPasswd)));

        pUserCreds->fIsValidPasswd = TRUE;

        DebugLog((DEB_TRACE,"DigestGetPasswd: Password retrieved\n"));
    }

    // We have some form of credentials based on password (either cleartext or pre-computed)

    if (ppucUserAuthData)
    {       // Go fetch the AuthData to marshall back to the server for Token creation
        *ppucUserAuthData = NULL;
        *pulAuthDataSize = 0;
            // Calling   LsaGetUserAuthData()
        Status = g_LsaFunctions->GetUserAuthData(UserHandle, ppucUserAuthData, pulAuthDataSize);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"DigestGetPasswd: failed acquire UseAuthData 0x%x\n", Status));
            goto CleanUp;
        }
    }

CleanUp:

    // Release any memory from SamI* calls         Would be nice to have this as a LSAFunction
    
    if (pvPlainPwd)
    {
        if (ulLenPassword > 0)
        {
            ZeroMemory(pvPlainPwd, ulLenPassword);
        }
        LocalFree(pvPlainPwd);
        pvPlainPwd = NULL;
    }

    if (pvHashCred)
    {
        LocalFree(pvHashCred);
        pvHashCred = NULL;
    }


    if (bOpenedSAM == TRUE)
    {
        // LsaCloseSamUser()
     Status = g_LsaFunctions->CloseSamUser(UserHandle);
     if (!NT_SUCCESS(Status))
     {
         DebugLog((DEB_ERROR,"DigestGetPasswd: failed LsaCloseSamUser 0x%x\n", Status));
     }
     bOpenedSAM = FALSE;
    }

    if (!NT_SUCCESS(Status))
    {     // Cleanup functions since there was a failure
        if (*ppucUserAuthData)
        {
            g_LsaFunctions->FreeLsaHeap(*ppucUserAuthData);
            *ppucUserAuthData = NULL;
            *pulAuthDataSize = 0L;
        }
    }

    DebugLog((DEB_TRACE_FUNC,"DigestGetPasswd: Leaving\n"));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\lsaap.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        LsaAp.h
//
// Contents:    prototypes for export functions
//
//
// History:     KDamour  15Mar00  Created (based on NTLM)
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_LSAAP_H
#define NTDIGEST_LSAAP_H


///////////////////////////////////////////////////////////////////////
//                                                                   //
// Authentication package dispatch routine definitions               //
//                                                                   //
///////////////////////////////////////////////////////////////////////

NTSTATUS
LsaApInitializePackage(
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PSTRING Database OPTIONAL,
    IN PSTRING Confidentiality OPTIONAL,
    OUT PSTRING *AuthenticationPackageName
    );

NTSTATUS
LsaApLogonUser(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationLength,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority
    );

NTSTATUS
LsaApCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
LsaApCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

VOID
LsaApLogonTerminated(
    IN PLUID LogonId
    );


// Acquire a users cleartext password and/or Digest hashed password forms
NTSTATUS
DigestGetPasswd(
    IN PUSER_CREDENTIALS pUserCreds,
    OUT PUCHAR * ppucUserAuthData,
    OUT PULONG pulAuthDataSize
    );

#endif // NTDIGEST_LSAAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\notify.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        notify.cxx
//
// Contents:    Credential functions:
//
//
// History:     KDamour  29Mar01   Created
//
//------------------------------------------------------------------------

#include <stdio.h>
#include "global.h"



//
// Precomputed digest hash functions
//
//  This is the ordered list of digest hash functions contained in the supplemental (primary)
//  credential for the user in the DS on the DC.  The order is imporant to preserve and new
//  versions of the hash functions can be appended to the list the the DigestSelectHash()
//  function updated
//
//      H(davemo:redmond:MyPassword) - I think this form is used for some sasl implementations
//              and is the default way our client side packages the info when you use the auth
//              identity structure.
//
//      H(redmond\davemo:corp.microsoft.com:MyPassword) - this form will handle backwards compatibility
//              with older IE clients. Currently a Digest IE client will type in a username that is the
//              netbios domain\user form and the client will return the realm hint. The realm hint will
//              be provided by new Digest (IIS) servers and determined by a call to
//              DsRoleGetPrimaryDomainInformation to retrieve DomainForestName.
//
//      H(davemo@redmond.microsoft.com:corp.microsoft.com:MyPassword) - We want to eventually move
//              everyone to UPNs and this gives us forward compatiblity. The realm value comes from the
//              same method as above.
//
//     Each format will have argument formatted, uppercase, lowercase formats.


//+-------------------------------------------------------------------------
//
//  Function:   CredentialUpdateNotify
//
//  Synopsis:   This routine is called from LSA in order to obtain
//              new Digest Hash credentials to be stored as supplemental
//              credentials when ever a user's password is set/changed.
//              These precalculated hashes can be used instead of turning
//              on Reversible Encryption on the DC
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN   ClearPassword      -- the clear text password
//  IN   OldCredentials     -- the previous digest credentials
//  IN   OldCredentialsSize -- size of OldCredentials
//  IN   UserAccountControl -- info about the user
//  IN   UPN                -- user principal name of the account (Optional)
//  IN   UserName           -- the SAM account name of the account
//  IN   DnsDomainName      -- DNS domain name of the account
//  OUT  NewCredentials     -- space allocated for SAM containing
//                             the credentials based on the input parameters
//                             to be freed by CredentialUpdateFree
//  OUT  NewCredentialSize  -- size of NewCredentials
//
//
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes:      WDigest.DLL needs to be registered (in the registry) as a
//              package that SAM calls out to in order for this routine
//              to be involked.
//              We are called when the password changes. This routine is not
//              called when the username, UPN, or DNSDomainName changes. It is
//              a known issue and noted that the users must change their passwords
//              to populate a updated hash after a domainname change.
//              Need to set key 
//                 \Registry\Machine\System\CurrentControlSet\Control\LSA   Notification Packages
//
//
//--------------------------------------------------------------------------
NTSTATUS
CredentialUpdateNotify (
    IN PUNICODE_STRING ClearPassword,
    IN PVOID OldCredentials,
    IN ULONG OldCredentialsSize,
    IN ULONG UserAccountControl,
    IN PUNICODE_STRING UPN,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING DnsDomainName,
    OUT PVOID *NewCredentials,
    OUT ULONG *NewCredentialsSize
    )
{

   // Structure will be composed of a series of binary hash values
   // Each hash is a binary version of a MD5 hash of  H(username:realm:password)
   // Each hash is MD5_HASH_BYTESIZE (16 bytes) in length.  The Hex version of
   // that is  32 bytes in length.
   //  The supplimental creds will have the following structure
    // All versions will have the similar start of 16 byte header - version number
    //   Version 1 supplimental creds looks like
    //        Header  (version number as ASCII string <sp> number of pre-calculated hashes)  i.e  "1 6\0\0...\0"
    //        H(username, short domain name, password)              (16 bytes)
    //        H(UPN, NULL string, password)

    NTSTATUS Status = STATUS_SUCCESS;
    NET_API_STATUS  NetStatus = NERR_Success;
    PCHAR  pWhere = NULL;
    PCHAR  pcSuppCreds = NULL;
    ULONG  ulSuppCredSize = 0;
    USHORT usLength = 0;
    USHORT ucTotalByteCount = 0;
    DWORD  dwRC = 0;
    USHORT usNumWChars = 0;
    PWCHAR pwBS = L"\\";
    UNICODE_STRING ustrFlatDomainName = {0};;
    UNICODE_STRING ustrNetBios = {0};

    DebugLog((DEB_TRACE_FUNC, "CredentialUpdateNotify: Entering\n"));
    DebugLog((DEB_TRACE, "CredentialUpdateNotify: UPN (%wZ), Username (%wZ), DNSDomainName (%wZ)\n",
              UPN, UserName, DnsDomainName));

    ASSERT(NewCredentials);
    ASSERT(NewCredentialsSize);

    *NewCredentials = NULL;
    *NewCredentialsSize = NULL;


    ulSuppCredSize = (NUMPRECALC_HEADERS+ 1) * MD5_HASH_BYTESIZE;        // 1 for the header
    pcSuppCreds = (PCHAR)DigestAllocateMemory(ulSuppCredSize);
    if (!pcSuppCreds)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Error from Digest Allocate is 0x%lx\n", Status));
        goto CleanUp;
    }

    usNumWChars =  (NetbiosDomainName->Length + sizeof(WCHAR)) / sizeof(WCHAR);
    Status = UnicodeStringAllocate(&ustrFlatDomainName, usNumWChars);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Copy Domain error 0x%x\n", Status));
        goto CleanUp;
    }

    RtlCopyUnicodeString(&ustrFlatDomainName, NetbiosDomainName);

    Status = RtlUpcaseUnicodeString(&ustrFlatDomainName, &ustrFlatDomainName, FALSE);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Upcase failed    error 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "CredentialUpdateNotify: Flat DomainName (%wZ)\n", &ustrFlatDomainName));

    // Hash 0   Header information
    pWhere = pcSuppCreds;
    sprintf(pWhere, "%d %d", SUPPCREDS_VERSION, NUMPRECALC_HEADERS);
    pWhere += MD5_HASH_BYTESIZE;
    ucTotalByteCount += MD5_HASH_BYTESIZE; 


    // Now write out the pre-calculated hashes
    //  IMPORTANT to make sure that NUMPRECALC_HEADERS is updated if new hashes added !!!!!!

    // Hash 1   username:FlatDomainName:password
    usLength = MD5_HASH_BYTESIZE * 3;
    Status = PrecalcForms(UserName, &ustrFlatDomainName, ClearPassword, pWhere, &usLength);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += usLength;
    ucTotalByteCount += usLength;

    // Hash 2   UPN::password
    usLength = MD5_HASH_BYTESIZE * 3;;
    Status = PrecalcForms(UPN, NULL, ClearPassword, pWhere, &usLength);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += usLength;
    ucTotalByteCount += usLength;

    // Hash 3   NetBIOS::password
    //         NetBIOS name   flatdomain\username

    usNumWChars =  (ustrFlatDomainName.Length + UserName->Length + sizeof(WCHAR)) / sizeof(WCHAR);
    Status = UnicodeStringAllocate(&ustrNetBios, usNumWChars);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Copy Domain error 0x%x\n", Status));
        goto CleanUp;
    }

    RtlCopyUnicodeString(&ustrNetBios, &ustrFlatDomainName);
    
    Status = RtlAppendUnicodeToString(&ustrNetBios, pwBS);    
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Append Separator error 0x%x\n", Status));
        goto CleanUp;
    }
    Status = RtlAppendUnicodeStringToString(&ustrNetBios, UserName);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Append username error 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "CredentialUpdateNotify: NetBIOS name %wZ\n", &ustrNetBios));

    usLength = MD5_HASH_BYTESIZE * 3;;
    Status = PrecalcForms(&ustrNetBios, NULL, ClearPassword, pWhere, &usLength);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    ucTotalByteCount += usLength;

    ASSERT(ucTotalByteCount == ulSuppCredSize);

    // Provide the supplimental credentials
    *NewCredentials = pcSuppCreds;
    *NewCredentialsSize = ulSuppCredSize;

    DebugLog((DEB_TRACE, "CredentialUpdateNotify: Succeeded in pre-calc of digest hashes  Aux cred size 0x%x\n",
              ulSuppCredSize ));

CleanUp:

    UnicodeStringFree(&ustrFlatDomainName);
    UnicodeStringFree(&ustrNetBios);

    DebugLog((DEB_TRACE_FUNC, "CredentialUpdateNotify: Leaving   Status 0x%x\n", Status));

    return Status;
}



//
// Free's the memory allocated by CredentialUpdateNotify
//
VOID
CredentialUpdateFree(
    PVOID p
    )
{
    if (p) {
        DigestFreeMemory(p);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   CredentialUpdateRegister
//
//  Synopsis:   This routine is called from LSA in order to obtain
//              the name of the supplemental credentials passed into this package
//              when a password is changed or set.
//
//  Effects:    Register with LSA that we want to be notified on PWD change
//
//  Arguments:
//
//  OUT CredentialName -- the name of credential tag in the supplemental
//                        credentials.  Note this memory is never freed
//                        by SAM, but must remain valid for the lifetime
//                        of the process.
//
//  Requires:   no global requirements
//
//  Returns:    TRUE
//
//  Notes:      wdigest.DLL needs to be registered (in the registry) as a
//              package that SAM calls out to in order for this routine
//              to be involked.
//              This will be run only on the DC
//
//
//--------------------------------------------------------------------------
BOOLEAN
CredentialUpdateRegister(
    OUT UNICODE_STRING *CredentialName
    )
{
    ASSERT(CredentialName);

    RtlInitUnicodeString(CredentialName, WDIGEST_SP_NAME);

    return TRUE;
}




//+--------------------------------------------------------------------
//
//  Function:   PrecalcForms
//
//  Synopsis:   given a username, realm, password form
//                H(username, realm, password)
//                H(UPPER(username), UPPER(realm), password)
//                H(LOWER(username), LOWER(realm))
//
//  Effects:    None
//
//  Arguments:  pustrUsername - pointer to unicode_string struct with account name
//              pustrRealm - pointer to unicode_string struct with realm
//              pustrPassword - pointer to unicode_string struct with cleartext password
//              pHash - pointer to byte buffer for ouput passwrd hash
//              piHashSize - pointer to size of the binary buffer passed in & bytes written on output
//
//  Returns:  STATUS_SUCCESS for normal completion
//            STATUS_BUFFER_TOO_SMALL - Hash buffer too small, iHashSize contains min size
//
//  Notes:  Form three versions:
//                format provided, Uppercase and Lowercase versions
//
//---------------------------------------------------------------------
NTSTATUS PrecalcForms(
    IN PUNICODE_STRING pustrUsername, 
    IN PUNICODE_STRING pustrRealm,
    IN PUNICODE_STRING pustrPassword,
    OUT PCHAR pHash,
    IN OUT PUSHORT piHashSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCHAR  pWhere = NULL;
    USHORT usLength = 0;
    UNICODE_STRING ustrTempUsername;
    UNICODE_STRING ustrTempRealm;

    DebugLog((DEB_TRACE_FUNC, "PrecalcForms: Entering\n"));

    ZeroMemory(&ustrTempUsername, sizeof(ustrTempUsername));
    ZeroMemory(&ustrTempRealm, sizeof(ustrTempRealm));

    if (*piHashSize < (MD5_HASH_BYTESIZE * 3))
    {
        Status = SEC_E_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "PrecalcForms: Buffer size too small for multiple hashes   0x%x\n", Status));
        goto CleanUp;
    }
    
    pWhere = pHash;

    // First hash - use the input credentials
    usLength = MD5_HASH_BYTESIZE;
    Status = PrecalcDigestHash(pustrUsername,
                               pustrRealm,
                               pustrPassword,
                               pWhere,
                               &usLength);
    if ((!NT_SUCCESS (Status)) && (Status != STATUS_UNMAPPABLE_CHARACTER))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += MD5_HASH_BYTESIZE;

    // Create local copies for case modificaiton
    Status = UnicodeStringDuplicate(&ustrTempUsername, pustrUsername);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Username copy     error 0x%x\n", Status));
        goto CleanUp;
    }


    Status = UnicodeStringDuplicate(&ustrTempRealm, pustrRealm);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Realm copy     error 0x%x\n", Status));
        goto CleanUp;
    }

    // Now form lowercase version

    Status = RtlDowncaseUnicodeString(&ustrTempUsername, &ustrTempUsername, FALSE);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Downcase failed    error 0x%x\n", Status));
        goto CleanUp;
    }

    Status = RtlDowncaseUnicodeString(&ustrTempRealm, &ustrTempRealm, FALSE);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Downcase failed    error 0x%x\n", Status));
        goto CleanUp;
    }

    usLength = MD5_HASH_BYTESIZE;
    Status = PrecalcDigestHash(&ustrTempUsername,
                               &ustrTempRealm,
                               pustrPassword,
                               pWhere,
                               &usLength);
    if ((!NT_SUCCESS (Status)) && (Status != STATUS_UNMAPPABLE_CHARACTER))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += MD5_HASH_BYTESIZE;

    // Now form uppercase version

    Status = RtlUpcaseUnicodeString(&ustrTempUsername, &ustrTempUsername, FALSE);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Upcase failed    error 0x%x\n", Status));
        goto CleanUp;
    }

    Status = RtlUpcaseUnicodeString(&ustrTempRealm, &ustrTempRealm, FALSE);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Upcase failed    error 0x%x\n", Status));
        goto CleanUp;
    }

    usLength = MD5_HASH_BYTESIZE;
    Status = PrecalcDigestHash(&ustrTempUsername,
                               &ustrTempRealm,
                               pustrPassword,
                               pWhere,
                               &usLength);
    if ((!NT_SUCCESS (Status)) && (Status != STATUS_UNMAPPABLE_CHARACTER))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }

    // Indicate that we used three MD5 hashes
    *piHashSize = (MD5_HASH_BYTESIZE * 3);
    Status = STATUS_SUCCESS;

CleanUp:

    UnicodeStringFree(&ustrTempUsername);
    UnicodeStringFree(&ustrTempRealm);

    DebugLog((DEB_TRACE_FUNC, "PrecalcForms: Leaving   0x%x\n", Status));

    return (Status);
}



//+--------------------------------------------------------------------
//
//  Function:   PrecalcDigestHash
//
//  Synopsis:   Calculate PasswordHash  H(accountname:realm:password) 
//
//  Effects:    None
//
//  Arguments:  pustrUsername - pointer to unicode_string struct with account name
//              pustrRealm - pointer to unicode_string struct with realm
//              pustrPassword - pointer to unicode_string struct with cleartext password
//              pHash - pointer to byte buffer for ouput passwrd hash
//              piHashSize - pointer to size of the binary buffer passed in & bytes written on output
//
//  Returns:  STATUS_SUCCESS for normal completion
//            STATUS_BUFFER_TOO_SMALL - Binary Hash buffer too small, iHashSize contains min size
//
//  Notes:  For each parameter, if it can be encoded fully in ISO 8859-1 then do so.
//     If not (there are extended characters), then encode in UTF-8.  Each component is tested separately.
//
//---------------------------------------------------------------------
NTSTATUS PrecalcDigestHash(
    IN PUNICODE_STRING pustrUsername, 
    IN PUNICODE_STRING pustrRealm,
    IN PUNICODE_STRING pustrPassword,
    OUT PCHAR pHash,
    IN OUT PUSHORT piHashSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;


    STRING strUsername;
    STRING strRealm;
    STRING strPasswd;
    STRING strHash;
    BOOL fDefChars = FALSE;

    DebugLog((DEB_TRACE_FUNC, "PrecalcDigestHash: Entering\n"));

    ZeroMemory(&strUsername, sizeof(strUsername));
    ZeroMemory(&strRealm, sizeof(strRealm));
    ZeroMemory(&strPasswd, sizeof(strPasswd));
    ZeroMemory(&strHash, sizeof(strHash));

    if (*piHashSize < MD5_HASH_BYTESIZE)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_TRACE_FUNC, "PrecalcDigestHash: Hash output buffer too small\n"));
        *piHashSize = MD5_HASH_BYTESIZE;   // return how many bytes are needed to write out value
    }

    // First check if OK to encode in ISO 8859-1, if not then use UTF-8
    // All characters must be within ISO 8859-1 Character set else fail

    if (pustrUsername && pustrUsername->Length && pustrUsername->Buffer)
    {
        fDefChars = FALSE;
        Status = EncodeUnicodeString(pustrUsername, CP_8859_1, &strUsername, &fDefChars);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "PrecalcDigestHash: Error in encoding username\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
        if (fDefChars == TRUE)
        {
            DebugLog((DEB_TRACE, "PrecalcDigestHash: Can not encode Username in 8859-1, use UTF-8\n"));
            StringFree(&strUsername);
            Status = EncodeUnicodeString(pustrUsername, CP_UTF8, &strUsername, NULL);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding username\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
        }
    }


    if (pustrRealm && pustrRealm->Length && pustrRealm->Buffer)
    {
        fDefChars = FALSE;
        Status = EncodeUnicodeString(pustrRealm, CP_8859_1, &strRealm, &fDefChars);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "PrecalcDigestHash: Error in encoding realm\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
        if (fDefChars == TRUE)
        {
            DebugLog((DEB_TRACE, "PrecalcDigestHash: Can not encode realm in 8859-1, use UTF-8\n"));
            StringFree(&strRealm);
            Status = EncodeUnicodeString(pustrRealm, CP_UTF8, &strRealm, NULL);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding realm\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
        }
    }


    if (pustrPassword && pustrPassword->Length && pustrPassword->Buffer)
    {
        fDefChars = FALSE;
        Status = EncodeUnicodeString(pustrPassword, CP_8859_1, &strPasswd, &fDefChars);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "PrecalcDigestHash: Error in encoding passwd\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
        if (fDefChars == TRUE)
        {
            DebugLog((DEB_TRACE, "PrecalcDigestHash: Can not encode password in 8859-1, use UTF-8\n"));
            if (strPasswd.Buffer && strPasswd.MaximumLength)
            {
                ZeroMemory(strPasswd.Buffer, strPasswd.MaximumLength);
            }
            StringFree(&strPasswd);
            Status = EncodeUnicodeString(pustrPassword, CP_UTF8, &strPasswd, NULL);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "PrecalcDigestHash: Error in encoding passwd\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
        }
    }

    Status = StringAllocate(&strHash, MD5_HASH_BYTESIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "PrecalcDigestHash: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }

    // Use PasswdHash = H(username-value:realm-value:passwd)
    Status = DigestHash7(&strUsername,
                         &strRealm,
                         &strPasswd,
                         NULL, NULL, NULL, NULL,
                         FALSE, &strHash);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "PrecalcDigestHash: H(U:R:PW) failed : 0x%x\n", Status));
        goto CleanUp;
    }
    
#if DBG
    STRING strTempPwKey;
    ZeroMemory(&strTempPwKey, sizeof(strTempPwKey));

    MyPrintBytes(strHash.Buffer, strHash.Length, &strTempPwKey);
    DebugLog((DEB_TRACE, "DigestCalcHA1: Binary H(%Z:%Z:************) is %Z\n",
               &strUsername, &strRealm, &strTempPwKey));

    StringFree(&strTempPwKey);
#endif

    memcpy(pHash, strHash.Buffer, MD5_HASH_BYTESIZE);
    *piHashSize = MD5_HASH_BYTESIZE;

CleanUp:

    if (Status == STATUS_UNMAPPABLE_CHARACTER)
    {
        // We were unable to make the mapping to the selected codepage
        // Case exists if inputs are unicode characters not contained in ISO 8859-1 and codepage is ISO 8859-1
        // Zero out the hash
        ZeroMemory(pHash, sizeof(MD5_HASH_BYTESIZE));
        *piHashSize = MD5_HASH_BYTESIZE;   // return how many bytes are needed to write out value
    }

    if (strPasswd.MaximumLength && strPasswd.Buffer)
    {
        // Make sure to erase any password info
        ZeroMemory(strPasswd.Buffer, strPasswd.MaximumLength);
    }

    StringFree(&strUsername);
    StringFree(&strRealm);
    StringFree(&strPasswd);
    StringFree(&strHash);

    DebugLog((DEB_TRACE_FUNC, "PrecalcDigestHash: Leaving  Status 0x%x\n", Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\user.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        user.cxx
//
// Contents:    Context manipulation functions
//
//
// History:     KDamour  15Mar00   Derrived from NTLM context.cxx
//
//------------------------------------------------------------------------
#include "global.h"

// This list contains all of the User Contexts
LIST_ENTRY           l_UserCtxtList;

// Lock for access to UserCtxtList
RTL_CRITICAL_SECTION l_UserCtxtCritSect;


// Indicate if completed Initialization of Credential Handler
BOOL  g_bUserContextInitialized = FALSE;



//+--------------------------------------------------------------------
//
//  Function:   UserCtxtHandlerInit
//
//  Synopsis:   Initializes the context manager package
//
//  Arguments:  none
//
//  Returns: NTSTATUS
//
//  Notes: Called by SpInstanceInit
//
//---------------------------------------------------------------------
NTSTATUS
UserCtxtHandlerInit(VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize the Context list to be empty.
    //

    Status = RtlInitializeCriticalSection(&l_UserCtxtCritSect);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "UserCtxtHandlerInit: Failed to initialize critsec   0x%x\n", Status));
        goto CleanUp;
    }
    
    InitializeListHead( &l_UserCtxtList );


    // Simple variable test to make sure all initialized;
    g_bUserContextInitialized = TRUE;

CleanUp:

    return Status;
}


// Add a Context into the UserMode Context List
NTSTATUS
UserCtxtHandlerInsertCred(
    IN PDIGEST_USERCONTEXT  pUserContext
    )
{
    RtlEnterCriticalSection( &l_UserCtxtCritSect );
    DebugLog((DEB_TRACE, "UserCtxtHandlerRelease: (RefCount) UserContextInit linked 0x%x\n", pUserContext->LsaContext));
    InsertHeadList( &l_UserCtxtList, &pUserContext->Next );
    RtlLeaveCriticalSection( &l_UserCtxtCritSect );

    return STATUS_SUCCESS;
}


// Initialize a UserMode Context
NTSTATUS NTAPI
UserCtxtInit(
           PDIGEST_USERCONTEXT pContext
           )
{

    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "UserCtxtInit: Entering\n"));
    ASSERT(pContext);

    if (!pContext)
    {
        return STATUS_INVALID_PARAMETER;
    }

    ZeroMemory(pContext, sizeof(DIGEST_USERCONTEXT));

    DebugLog((DEB_TRACE_FUNC, "UserCtxtInit: Leaving \n"));
    return Status;
}


// Once done with a context - release the resouces
NTSTATUS NTAPI
UserCtxtFree(
           IN PDIGEST_USERCONTEXT pContext
           )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    DebugLog((DEB_TRACE_FUNC, "UserCtxtFree: Entering  with LSA context 0x%x\n", pContext->LsaContext));
    ASSERT(pContext);
    ASSERT(pContext->lReferences == 0);

    if (!pContext)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (pContext->ClientTokenHandle)
    {
        NTSTATUS IgnoreStatus;
        IgnoreStatus = NtClose(pContext->ClientTokenHandle);
        // ASSERT (NT_SUCCESS (IgnoreStatus));
        if (!NT_SUCCESS(IgnoreStatus))
        {
            DebugLog((DEB_ERROR, "UserCtxtFree: Could not Close the TokenHandle!!!!\n"));
        }
        pContext->ClientTokenHandle = NULL;
    }

    if (pContext->hSealCryptKey)
    {
        CryptDestroyKey( pContext->hSealCryptKey );
        pContext->hSealCryptKey = NULL;
    }

    if (pContext->hUnsealCryptKey)
    {
        CryptDestroyKey( pContext->hUnsealCryptKey );
        pContext->hUnsealCryptKey = NULL;
    }

    StringFree(&(pContext->strSessionKey));
    UnicodeStringFree(&(pContext->ustrAccountName));

    //
    //  Values utilized in the Initial Digest Auth ChallResponse
    //  Can be utilized for defaults in future MakeSignature/VerifySignature
    //
    for (i=0; i < MD5_AUTH_LAST; i++)
    {
        StringFree(&(pContext->strParam[i]));
    }

    DigestFreeMemory(pContext);

    DebugLog((DEB_TRACE_FUNC, "UserCtxtFree: Leaving\n"));
    return Status;
}



/*++

Routine Description:

    This routine checks to see if the Context is for the specified
    Client Connection, and references the Context if it is valid.

    The caller may optionally request that the Context be
    removed from the list of valid Contexts - preventing future
    requests from finding this Context.

Arguments:

    ContextHandle - Points to the ContextHandle of the Context
        to be referenced.

    RemoveContext - This boolean value indicates whether the caller
        wants the Context to be removed from the list
        of Contexts.  TRUE indicates the Context is to be removed.
        FALSE indicates the Context is not to be removed.


Return Value:

    NULL - the Context was not found.

    Otherwise - returns a pointer to the referenced Context.

--*/
NTSTATUS NTAPI
UserCtxtHandlerHandleToContext(
                              IN ULONG_PTR ContextHandle,
                              IN BOOLEAN RemoveContext,
                              OUT PDIGEST_USERCONTEXT *ppContext
                              )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_USERCONTEXT pContext = NULL;
    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "UserCtxtHandlerHandleToContext: Entering\n" ));


    //
    // Acquire exclusive access to the Context list
    //

    RtlEnterCriticalSection( &l_UserCtxtCritSect );

    //
    // Now walk the list of Contexts looking for a match.
    //

    for ( ListEntry = l_UserCtxtList.Flink;
        ListEntry != &l_UserCtxtList;
        ListEntry = ListEntry->Flink )
    {

        pContext = CONTAINING_RECORD( ListEntry, DIGEST_USERCONTEXT, Next );

        //
        // Found a match ... reference this Context
        // (if the Context is being removed, we would increment
        // and then decrement the reference, so don't bother doing
        // either - since they cancel each other out).
        //

        DebugLog((DEB_TRACE, "UserCtxtHandlerHandleToContext: Checking context %lx for userctxt %lx\n",
                  pContext->LsaContext, ContextHandle ));

        if (pContext->LsaContext != ContextHandle)
        {
            continue;
        }


        if (!RemoveContext)
        {
            lReferences = InterlockedIncrement(&pContext->lReferences);
        }
        else
        {
            DebugLog((DEB_TRACE, "UserCtxtHandlerRelease: (RefCount) UserContextInit delinked 0x%x\n", ContextHandle));
            RemoveEntryList( &pContext->Next );
        }

        DebugLog((DEB_TRACE, "CtxtHandlerHandleToContext FOUND Context = 0x%x, RemoveContext = %d, ReferenceCount = %ld\n",
                   pContext, RemoveContext, pContext->lReferences));
        *ppContext = pContext;
        goto CleanUp;

    }

    //
    // No match found
    //

    DebugLog((DEB_WARN, "UserCtxtHandlerHandleToContext: Tried to reference unknown Context 0x%lx\n", ContextHandle ));
    Status =  STATUS_OBJECT_NAME_NOT_FOUND;
    *ppContext = NULL;

CleanUp:

    RtlLeaveCriticalSection( &l_UserCtxtCritSect );
    DebugLog((DEB_TRACE_FUNC, "UserCtxtHandlerHandleToContext: Leaving  Status 0x%x\n", Status ));

    return(Status);
}



// Check the Creation time with the Current time.
// If the difference is greater than the MAX allowed, Context is no longer valid
BOOL
UserCtxtHandlerTimeHasElapsed(
    PDIGEST_USERCONTEXT pContext)
{
    BOOL bStatus = FALSE;
    DWORD dwTimeElapsed = 0;
    time_t timeCurrent = time(NULL);

    return FALSE;

    // dwTimeElapsed = (DWORD)(timeCurrent - pContext->TimeCreated);

    if (dwTimeElapsed > g_dwParameter_Lifetime)
    {
        bStatus = TRUE;
    }

    return(bStatus);
}



//+--------------------------------------------------------------------
//
//  Function:   CtxtHandlerRelease
//
//  Synopsis:   Releases the Context by decreasing reference counter
//
//  Arguments:  pContext - pointer to credential to de-reference
//
//  Returns: NTSTATUS
//
//  Notes: Called by ASC. Since multiple threads must wait for ownership
//   of a context, reference count must be either 0 (unused) or 1 (in process)
//
//---------------------------------------------------------------------
NTSTATUS
UserCtxtHandlerRelease(
    PDIGEST_USERCONTEXT pUserContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG lReferences = 0;

    lReferences = InterlockedDecrement(&pUserContext->lReferences);

    DebugLog((DEB_TRACE, "UserCtxtHandlerRelease: (RefCount) UserContextInit deref 0x%x  references %ld\n",
               pUserContext, lReferences));

    ASSERT( lReferences >= 0 );

    //
    // If the count has dropped to zero, then free all alloced stuff
    //

    if (lReferences == 0)
    {
        DebugLog((DEB_TRACE, "UserCtxtHandlerRelease: (RefCount) UserContextInit freed 0x%x\n", pUserContext));
        Status = UserCtxtFree(pUserContext);
    }

    return(Status);
}


// Following functions make use of the lock for insuring single threaded operation


/*++

RoutineDescription:

    Creates a new DACL for the token granting the server and client
    all access to the token.

Arguments:

    Token - Handle to an impersonation token open for TOKEN_QUERY and
        WRITE_DAC

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - insufficient memory to complete
        the function.

    Errors from NtSetSecurityObject

--*/
NTSTATUS
SspCreateTokenDacl(
    HANDLE Token
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTOKEN_USER ProcessTokenUser = NULL;
    PTOKEN_USER ThreadTokenUser = NULL;
    PTOKEN_USER ImpersonationTokenUser = NULL;
    HANDLE ProcessToken = NULL;
    HANDLE ImpersonationToken = NULL;
    BOOL fInsertImpersonatingUser = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG AclLength = 0;
    PACL NewDacl = NULL;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    BOOL fReleaseContextLock = FALSE;


    DebugLog((DEB_TRACE_FUNC, "SspCreateTokenDacl: Entering  Token is 0x%x\n", Token));

    //
    // Build the two well known sids we need.
    //

    if (g_NtDigestGlobalLocalSystemSid == NULL || g_NtDigestGlobalAliasAdminsSid == NULL ) {

        RtlEnterCriticalSection(&l_UserCtxtCritSect);
        fReleaseContextLock = TRUE;

        if (g_NtDigestGlobalLocalSystemSid == NULL)
        {
            PSID pLocalSidSystem = NULL;
            DebugLog((DEB_TRACE, "SspCreateTokenDacl: Allocate and Init LocalSystem SID\n"));
            Status = RtlAllocateAndInitializeSid(
                        &NtAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID,
                        0,0,0,0,0,0,0,
                        &pLocalSidSystem
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SspCreateTokenDacl: RtlAllocateAndInitializeSid returns 0x%lx\n", Status ));
                goto Cleanup;
            }
            DebugLog((DEB_TRACE, "SspCreateTokenDacl: Allocate and Init LocalSystem SID  DONE\n"));
            g_NtDigestGlobalLocalSystemSid = pLocalSidSystem;
        }

        if (g_NtDigestGlobalAliasAdminsSid == NULL)
        {
            PSID pLocalSidAdmins = NULL;

            DebugLog((DEB_TRACE, "SspCreateTokenDacl: Allocate and Init AliasAdmin SID\n"));
            Status = RtlAllocateAndInitializeSid(
                        &NtAuthority,
                        2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0,0,0,0,0,0,
                        &pLocalSidAdmins
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SspCreateTokenDacl, RtlAllocateAndInitializeSid returns 0x%lx\n", Status ));
                goto Cleanup;
            }

            DebugLog((DEB_TRACE, "SspCreateTokenDacl: Allocate and Init AliasAdmin SID  DONE\n"));
            g_NtDigestGlobalAliasAdminsSid = pLocalSidAdmins;
        }

        RtlLeaveCriticalSection(&l_UserCtxtCritSect);
        fReleaseContextLock = FALSE;
    }

    //
    // it's possible that the current thread is impersonating a user.
    // if that's the case, get it's token user, and revert to insure we
    // can open the process token.
    //

    Status = NtOpenThreadToken(
                            NtCurrentThread(),
                            TOKEN_QUERY | TOKEN_IMPERSONATE,
                            TRUE,
                            &ImpersonationToken
                            );

    if( NT_SUCCESS(Status) )
    {
        //
        // stop impersonating.
        //

        RevertToSelf();

        //
        // get the token user for the impersonating user.
        //
        Status = SspGetTokenUser(
                    ImpersonationToken,
                    &ImpersonationTokenUser
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SspCreateTokenDacl: SspGetTokenUser (1) returns 0x%lx\n", Status ));
            goto Cleanup;
        }
    }

    //
    // Open the process token to find out the user sid
    //

    Status = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_QUERY,
                &ProcessToken
                );

    if(!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SspCreateTokenDacl: NtOpenProcessToken returns 0x%lx\n", Status ));
        goto Cleanup;
    }

    //
    // get the token user for the process token.
    //
    Status = SspGetTokenUser(
                ProcessToken,
                &ProcessTokenUser
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SspCreateTokenDacl: SspGetTokenUser (2) returns 0x%lx\n", Status ));
        goto Cleanup;
    }


    //
    // Now get the token user for the thread.
    //
    Status = SspGetTokenUser(
                Token,
                &ThreadTokenUser
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SspCreateTokenDacl: SspGetTokenUser (3) returns 0x%lx\n", Status ));
        goto Cleanup;
    }


    AclLength = 4 * sizeof( ACCESS_ALLOWED_ACE ) - 4 * sizeof( ULONG ) +
                RtlLengthSid( ProcessTokenUser->User.Sid ) +
                RtlLengthSid( ThreadTokenUser->User.Sid ) +
                RtlLengthSid( g_NtDigestGlobalLocalSystemSid ) +
                RtlLengthSid( g_NtDigestGlobalAliasAdminsSid ) +
                sizeof( ACL );

    //
    // determine if we need to add impersonation token sid onto the token Dacl.
    //

    if( ImpersonationTokenUser &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, ProcessTokenUser->User.Sid ) &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, ThreadTokenUser->User.Sid )
        )
    {
        AclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof( ULONG )) +
                RtlLengthSid( ImpersonationTokenUser->User.Sid );

        fInsertImpersonatingUser = TRUE;
    }


    NewDacl = (PACL)DigestAllocateMemory(AclLength );

    if (NewDacl == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "SspCreateTokenDacl: NtLmallocate returns 0x%lx\n", NewDacl));
        goto Cleanup;
    }

    Status = RtlCreateAcl( NewDacl, AclLength, ACL_REVISION2 );
    ASSERT(NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ProcessTokenUser->User.Sid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ThreadTokenUser->User.Sid
                 );
    ASSERT( NT_SUCCESS( Status ));

    if( fInsertImpersonatingUser )
    {
        Status = RtlAddAccessAllowedAce (
                     NewDacl,
                     ACL_REVISION2,
                     TOKEN_ALL_ACCESS,
                     ImpersonationTokenUser->User.Sid
                     );
        ASSERT( NT_SUCCESS( Status ));
    }

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 g_NtDigestGlobalAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 g_NtDigestGlobalLocalSystemSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlCreateSecurityDescriptor (
                 &SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlSetDaclSecurityDescriptor(
                 &SecurityDescriptor,
                 TRUE,
                 NewDacl,
                 FALSE
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = NtSetSecurityObject(
                 Token,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    ASSERT( NT_SUCCESS( Status ));


Cleanup:

    if( fReleaseContextLock )
        RtlLeaveCriticalSection(&l_UserCtxtCritSect);

    if (ImpersonationToken != NULL)
    {
        //
        // put the thread token back if we were impersonating.
        //

        SetThreadToken( NULL, ImpersonationToken );
        NtClose(ImpersonationToken);
    }

    if (ThreadTokenUser != NULL) {
        DigestFreeMemory( ThreadTokenUser );
    }

    if (ProcessTokenUser != NULL) {
        DigestFreeMemory( ProcessTokenUser );
    }

    if (ImpersonationTokenUser != NULL) {

        DigestFreeMemory( ImpersonationTokenUser );
    }

    if (NewDacl != NULL) {
        DigestFreeMemory( NewDacl );
    }

    if (ProcessToken != NULL)
    {
        NtClose(ProcessToken);
    }

    DebugLog((DEB_TRACE_FUNC, "SspCreateTokenDacl: Leaving  Token is 0x%x\n", Token));

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\nonce.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        nonce.h
//
// Contents:    Constants for the Nonce Generator/Validator

//
// History:     
//              KDamour  21Mar00       Created
//
//------------------------------------------------------------------------
#ifndef NTDIGEST_NONCE_H
#define NTDIGEST_NONCE_H

#include <wincrypt.h>

// Handle into the CryptoAPI
extern HCRYPTPROV g_hCryptProv;
extern WORD       g_SupportedCrypto;

extern char *pbSeparator;   // the COLON separator

// NONCE FORMAT
//   rand-data = rand[16]
//   nonce_binary = time-stamp  rand-data H(time-stamp ":" rand-data ":" nonce_private_key)
//   nonce = hex(nonce_binary)

// SIZE implies number of ASCII chars
// BYTESIZE is the number of bytes of Data (binary)
#define NONCE_PRIVATE_KEY_BYTESIZE 16                    // Generate 128 bit random private key
#define RANDDATA_BYTESIZE 16                             // # of random bytes at beginning of nonce
#define TIMESTAMP_BYTESIZE sizeof(time_t)                // size of timestamp in nonce binary 8 bytes
#define MD5_HASH_BYTESIZE 16                             // MD5 hash size
#define MD5_HASH_HEX_SIZE (2*MD5_HASH_BYTESIZE)     // BYTES needed to store a Hash as hex Encoded

// For Hex encoding need 2chars per byte encoded
#define NONCE_SIZE ((2*TIMESTAMP_BYTESIZE) + (2*RANDDATA_BYTESIZE) + (2*MD5_HASH_BYTESIZE))
#define NONCE_TIME_LOC 0
#define NONCE_RANDDATA_LOC (2 * TIMESTAMP_BYTESIZE)
#define NONCE_HASH_LOC (NONCE_RANDDATA_LOC + (2 * RANDDATA_BYTESIZE))

#define OPAQUE_RANDATA_SIZE 16                    // Make 128bits of rand data for reference
#define OPAQUE_SIZE (OPAQUE_RANDATA_SIZE * 2)

#define MAX_URL_SIZE        512


NTSTATUS NTAPI NonceInitialize(VOID);

NTSTATUS NTAPI NonceCreate(OUT PSTRING pstrNonce);

// Primary function to call to check validity of a nonce
NTSTATUS NonceIsValid(PSTRING pstrNonce);

// Helper function for NonceIsValid to check if time expired
BOOL NonceIsExpired(PSTRING pstrNonce);

// Helper function for NonceIsValid to check if Hash is correct
BOOL NonceIsTampered(PSTRING pstrNonce);


BOOL HashData(BYTE *pbData, DWORD cbData, BYTE *pbHash );

// Create the Hash for the Nonce Parameters
NTSTATUS NTAPI NonceHash( IN LPBYTE pbTime, IN DWORD cbTime,
           IN LPBYTE pbRandom, IN DWORD cbRandom,
           IN LPBYTE pbKey, IN DWORD cbKey,
           OUT LPBYTE pbHash);

NTSTATUS NTAPI OpaqueCreate(IN OUT PSTRING pstrOpaque);

//  Set the bitmask for the supported crypto CSP installed
NTSTATUS NTAPI SetSupportedCrypto(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\nonce.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        nonce.cxx
//
// Contents:    Context APIs for the Digest security package
//              Main entry points into this dll:
//                NonceCreate
//                NonceValidate
//                NonceInitialize
//
// History:     ChandanS 26-Jul-1996   Stolen from kerberos\client2\ctxtapi.cxx
//              KDamour  16Mar00       Stolen from NTLM ctxtapi.cxx
//
//------------------------------------------------------------------------
#include <global.h>
#include <time.h>

// Hold the Hex representation plus the NULL
char g_cNoncePrivateKey[(2*NONCE_PRIVATE_KEY_BYTESIZE) + 1];


//
//  Globals
//

HCRYPTPROV g_hCryptProv = 0;             // Handle for CryptoAPI
WORD       g_SupportedCrypto = 0;        // Supported Crypt Functions bitmask (i.e. SUPPORT_DES)


// Needed for Digest Calculation and Nonce Hash
char *pbSeparator = COLONSTR;


//+--------------------------------------------------------------------
//
//  Function:   NonceInitialize
//
//  Synopsis:   This function is to be called
//
//  Arguments:  None
//
//  Returns:    
//
//  Notes:
//      CryptReleaseContext( g_hCryptProv, 0 ) to release the cypt context
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
NonceInitialize(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BYTE abTemp[NONCE_PRIVATE_KEY_BYTESIZE];
    HCRYPTKEY hKey = 0;

    DebugLog((DEB_TRACE_FUNC, "NonceInitialize: Entering\n"));

    if (g_hCryptProv)
    {         // Catch cases where LSA and Usermode running in same addr space
        DebugLog((DEB_TRACE, "NonceInitialize: Already Inited Leaving\n"));
        return STATUS_SUCCESS;
    }

    //
    // Get a handle to the CSP we'll use for all our hash functions etc
    //
    if ( !CryptAcquireContext( &g_hCryptProv,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        DebugLog((DEB_ERROR, "NonceInitialize:CryptCreateHash() failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        return(Status);
    }


    //
    // Generate and copy over the random bytes
    //
    if ( !CryptGenRandom( g_hCryptProv,
                          NONCE_PRIVATE_KEY_BYTESIZE,
                          abTemp ) )
    {
        DebugLog((DEB_ERROR, "NonceInitialize:NonceInitialize CryptGenRandom() failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        return (Status);
    }

    BinToHex((LPBYTE) abTemp, NONCE_PRIVATE_KEY_BYTESIZE, (LPSTR) g_cNoncePrivateKey);

    SetSupportedCrypto();
    

    DebugLog((DEB_TRACE_FUNC, "NonceInitialize:Leaving NonceInitialize\n"));

    return (Status);
}


//+--------------------------------------------------------------------
//
//  Function:   SetSupportedCrypto
//
//  Synopsis:   Set the bitmask for the supported crypto CSP installed
//
//  Arguments:   none
//
//  Returns:  STATUS_DATA_ERROR - error in reading CSP capabilities 
//            STATUS_SUCCESS - operation completed normally
//
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
SetSupportedCrypto(VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    g_SupportedCrypto = SUPPORT_3DES | SUPPORT_DES | SUPPORT_RC4_40 | SUPPORT_RC4 | SUPPORT_RC4_56;

    // FIXFIX  use CryptGetProvParam to set to actual installed CSP

    return(Status);
}


//+--------------------------------------------------------------------
//
//  Function:   NonceCreate
//
//  Synopsis:   This function is to be called once during User Mode initialization
//
//  Arguments:   pczNonce - pointer to a STRING to fillin
//                      with a new nonce
//
//  Returns:  STATUS_DATA_ERROR - input NONCE not enough space 
//            STATUS_SUCCESS - operation completed normally
//
//  Notes:   Function will return error if Nonce UNICODE_STRING is not empty
//        NONCE FORMAT
//        rand-data = rand[16]
//        nonce_binary = time-stamp  rand-data H(time-stamp ":" rand-data ":" nonce_private_key)
//        nonce = hex(nonce_binary)
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
NonceCreate(
    IN OUT PSTRING pstrNonce 
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BYTE  abRandomData[RANDDATA_BYTESIZE];
    char  acRandomHex[(2*RANDDATA_BYTESIZE) + 1];
    int cbNonce = 0;

    time_t tcurrent = time(NULL);

    DebugLog((DEB_TRACE_FUNC, "NonceCreate: Entering\n"));

        // Check to make sure that there is enough space on ouput string
        // Need room for the Nonce and the NULL terminator
    if (!pstrNonce->Buffer)
    {
        Status = StringAllocate(pstrNonce, NONCE_SIZE);
        if (!NT_SUCCESS (Status))
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "NonceCreate: StringAllocate error 0x%x\n", Status));
            goto CleanUp;
        }

    }
    if (pstrNonce->MaximumLength < (NONCE_SIZE + 1))
    {
        DebugLog((DEB_ERROR, "NonceCreate: Input STRING too small\n"));
        Status = STATUS_BUFFER_TOO_SMALL;
        goto CleanUp;
    }


        // Copy over the current time
    BinToHex((LPBYTE)&tcurrent, sizeof(time_t), (LPSTR) pstrNonce->Buffer);
    cbNonce += (sizeof(time_t) * 2);


    //
    // Generate and copy over the random bytes
    //
    if ( !CryptGenRandom( g_hCryptProv,
                          RANDDATA_BYTESIZE,
                          abRandomData ) )
    {
        DebugLog((DEB_TRACE, "NonceCreate: CryptGenRandom() failed : 0x%x\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        return (Status);
    }

    //
    // Convert to ASCII, doubling the length, and add to nonce 
    //
    BinToHex( abRandomData, RANDDATA_BYTESIZE, acRandomHex);
    memcpy(pstrNonce->Buffer + NONCE_RANDDATA_LOC, acRandomHex, (2 * NONCE_PRIVATE_KEY_BYTESIZE));

    //
    // Now calculate the Hash. It will be NULL terminated but STRING length does not include NULL
    //

    Status = NonceHash((LPBYTE) pstrNonce->Buffer, (2 * sizeof(time_t)),
                       (LPBYTE) acRandomHex, (2 * RANDDATA_BYTESIZE),
                       (LPBYTE) g_cNoncePrivateKey, (2 * NONCE_PRIVATE_KEY_BYTESIZE),
                       (LPBYTE) (pstrNonce->Buffer + NONCE_HASH_LOC));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "NonceCreate: failed %d\n", Status));
        goto CleanUp;
    }

    pstrNonce->Length = NONCE_SIZE;
    
CleanUp:

    if (!NT_SUCCESS(Status))
    {
        pstrNonce->Length = 0;
    }

    DebugLog((DEB_TRACE_FUNC, "NonceCreate: Leaving\n"));

    return (Status);
}

//+--------------------------------------------------------------------
//
//  Function:   NonceIsValid
//
//  Synopsis:   Called with a pointer to a Nonce and returns NTSTATUS  This is the
//     main function that checks for a valid nonce.
//
//  Arguments:  None
//
//  Returns:   NTSTATUS  STATUS_SUCCESS if NONCE generated locally and is valid  
//
//  Notes:
//
//---------------------------------------------------------------------

NTSTATUS
NonceIsValid(
    PSTRING pstrNonce
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "NonceIsValid: Entering\n"));

    // Check the size first
    if (pstrNonce->Length != NONCE_SIZE)
    {
        DebugLog((DEB_ERROR, "NonceIsValid: Incorrect size for the Nonce\n"));
        return STATUS_UNSUCCESSFUL;
    }

    if (!pstrNonce->Buffer)
    {
        DebugLog((DEB_ERROR, "NonceIsValid: NULL pointer for the Nonce\n"));
        return STATUS_UNSUCCESSFUL;
    }
    
    if (NonceIsTampered(pstrNonce))
    {
        DebugLog((DEB_ERROR, "NonceIsValid: Nonce hash does not match\n"));
        return STATUS_UNSUCCESSFUL;
    }

    DebugLog((DEB_TRACE_FUNC, "NonceIsValid: Leaving\n"));

    return (Status);
}

/*++

Routine Description:

    Creates MD5 hash of input buffer

Arguments:

    pbData - data to hash
    cbData - size of data pointed to by pbData
    pbHash - buffer that receives hash; is assumed to be big enough to contain MD5 hash

Return Value:

    TRUE if successful, FALSE if not

--*/
BOOL HashData( BYTE *pbData,
               DWORD cbData,
               BYTE *pbHash )
{
    HCRYPTHASH hHash = NULL;

    DebugLog((DEB_TRACE_FUNC, "HashData: Entering\n"));

    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "HashData: CryptCreateHash  failed : 0x%lx\n", GetLastError()));
        return FALSE;
    }

    if ( !CryptHashData( hHash,
                         pbData,
                         cbData,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "HashData: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        
        CryptDestroyHash( hHash );
        return FALSE;
    }

    DWORD cbHash = MD5_HASH_BYTESIZE;
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             pbHash,
                             &cbHash,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "HashData: CryptCreateHash failed : 0x%lx\n", GetLastError()));

        CryptDestroyHash( hHash );
        return FALSE;
    }

    CryptDestroyHash( hHash );

    DebugLog((DEB_TRACE_FUNC, "HashData: Leaving\n"));
    return TRUE;
}


/*++

Routine Description:

    Creates MD5 hash of the Nonce values

Arguments:

    pbTime - pointer to char buffer encoded Time()
    cbTime - number of bytes in encoded Time() buffer to process
    pbRandom - pointer to char buffer encoded random sequence
    cbRandom - number of bytes in encoded random buffer to process
    pbTKey - pointer to char buffer encoded private key
    cbKey - number of bytes in encoded private key buffer to process
    pbHash - pointer to char buffer encoded Nonce Hash
    cbHash - number of bytes in encoded Time() buffer to process

Return Value:

    STATUS_SUCCESS - normal completion

--*/
NTSTATUS NTAPI
NonceHash( IN LPBYTE  pbTime,
           IN DWORD cbTime,
           IN LPBYTE  pbRandom,
           IN DWORD cbRandom,
           IN LPBYTE pbKey,
           IN DWORD cbKey,
           OUT LPBYTE pbHash)
{
    NTSTATUS Status = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    DWORD cbHash = MD5_HASH_BYTESIZE;    // Number of bytes for MD5 hash
    unsigned char abHashBin[MD5_HASH_BYTESIZE];

    DebugLog((DEB_TRACE, "NonceHash: Entering\n"));

    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         pbTime,
                         cbTime,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         (const unsigned char *)pbSeparator,
                         COLONSTR_LEN,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         pbRandom,
                         cbRandom,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         (const unsigned char *)pbSeparator,
                         COLONSTR_LEN,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         pbKey,
                         cbKey,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             abHashBin,
                             &cbHash,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

        // Now convert the Hash to hex
    BinToHex(abHashBin, MD5_HASH_BYTESIZE, (char *)pbHash);

CleanUp:
    if (hHash)
    {
        CryptDestroyHash( hHash );
        hHash = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "NonceHash: Leaving\n"));
    return(Status);
}

//+--------------------------------------------------------------------
//
//  Function:   NonceIsExpired
//
//  Synopsis:   Check the timestamp to make sure that Nonce is still valid
//
//  Arguments:  None
//
//  Returns:   TRUE/FALSE if Nonce is expired 
//
//  Notes:   Called from NonceIsValid
//
//---------------------------------------------------------------------
BOOL NonceIsExpired(PSTRING pstrNonce)
{
    DebugLog((DEB_TRACE_FUNC, "NonceIsExpired: Entering\n"));
    time_t tcurrent = time(NULL);
    time_t tnonce = 0;

    // time-stamp is the first bytes in the nonce

    HexToBin(pstrNonce->Buffer, (2*TIMESTAMP_BYTESIZE), (unsigned char *)&tnonce);

    // If LifeTime set to zero - nonces never expire
    if (((unsigned long)tnonce > (unsigned long)tcurrent) ||
         (g_dwParameter_Lifetime && (((unsigned long)tcurrent - (unsigned long)tnonce) > g_dwParameter_Lifetime)))
    {
        DebugLog((DEB_TRACE_FUNC, "NonceIsExpired:  NonceHash has expired.  Expired = TRUE\n"));
        return TRUE;
    }

    DebugLog((DEB_TRACE_FUNC, "NonceIsExpired: Leaving  Expired = FALSE\n"));
    return FALSE;
}


//+--------------------------------------------------------------------
//
//  Function:   NonceIsTampered
//
//  Synopsis:   Check the hash matches for the Nonce
//
//  Arguments:  None
//
//  Returns:   TRUE/FALSE if Nonce hash fails check 
//
//  Notes:   Called from NonceIsValid
//
//---------------------------------------------------------------------
BOOL NonceIsTampered(PSTRING pstrNonce)
{
    BOOL bStatus = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    unsigned char abHashHex[(2*MD5_HASH_BYTESIZE) + 1];

    DebugLog((DEB_TRACE_FUNC, "NonceIsTampered:Entering \n"));

    Status = NonceHash((LPBYTE) (pstrNonce->Buffer + NONCE_TIME_LOC), (2 * sizeof(time_t)),
                       (LPBYTE) (pstrNonce->Buffer + NONCE_RANDDATA_LOC), (2 * RANDDATA_BYTESIZE),
                       (LPBYTE) g_cNoncePrivateKey, (2 * NONCE_PRIVATE_KEY_BYTESIZE),
                       (LPBYTE) abHashHex);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "NonceIsTampered: NonceHash has failed %d\n", Status));
        bStatus = TRUE;
        goto CleanUp;
    }

    if (memcmp(abHashHex, (pstrNonce->Buffer + NONCE_HASH_LOC), (2 * MD5_HASH_BYTESIZE)))
    {
        DebugLog((DEB_ERROR, "NonceIsTampered: memcmp failed\n"));
        bStatus = TRUE;
        goto CleanUp;
    }

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "NonceIsTampered: Leaving\n"));
    return bStatus;
}




//+--------------------------------------------------------------------
//
//  Function:   OpaqueCreate
//
//  Synopsis:  Creates an Opaque string composed of OPAQUE_SIZE of random data
//
//  Arguments:   pstrOpque - pointer to a STRING to fillin
//                      with a new opaque
//
//  Returns:  STATUS_DATA_ERROR - input NONCE not enough space 
//            STATUS_SUCCESS - operation completed normally
//
//  Notes:   Function will return error if Nonce STRING is not empty
//        OPAQUE FORMAT
//        opaque_binary = rand[OPAQUE_SIZE]
//        nonce = Hex(opaque_binary)
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
OpaqueCreate(
    IN OUT PSTRING pstrOpaque 
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BYTE  abRandomData[OPAQUE_RANDATA_SIZE];
    char  acRandomHex[(2*OPAQUE_RANDATA_SIZE) + 1];
    int cbNonce = 0;
    DebugLog((DEB_TRACE_FUNC, "OpaqueCreate: Entering\n"));

        // Check to make sure that there is enough space on ouput string
        // Need room for the Nonce and the NULL terminator
    if (!pstrOpaque->Buffer)
    {
        Status = StringAllocate(pstrOpaque, OPAQUE_SIZE);
        if (!NT_SUCCESS (Status))
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "OpaqueCreate: StringAllocate error 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else if (pstrOpaque->MaximumLength < ((2 * OPAQUE_RANDATA_SIZE) + 1))
    {
        DebugLog((DEB_ERROR, "OpaqueCreate: Input STRING too small\n"));
        Status = STATUS_BUFFER_TOO_SMALL;
        goto CleanUp;
    }

    //
    // Generate and copy over the random bytes
    //
    if ( !CryptGenRandom( g_hCryptProv,
                          OPAQUE_RANDATA_SIZE,
                          abRandomData ) )
    {
        DebugLog((DEB_TRACE, "OpaqueCreate: CryptGenRandom() failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        return (Status);
    }

    //
    // Convert to ASCII, doubling the length, and add to nonce 
    //
    BinToHex( abRandomData, OPAQUE_RANDATA_SIZE, pstrOpaque->Buffer);

    pstrOpaque->Length = (2 * OPAQUE_RANDATA_SIZE);
    
CleanUp:

    if (!NT_SUCCESS(Status))
    {
        pstrOpaque->Length = 0;
    }

    DebugLog((DEB_TRACE_FUNC, "OpaqueCreate: Leaving\n"));

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\ntdigest.h ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:       ntdigest.h
//
// Contents:   some general defines for SSP NTDigest
//
//             Helper functions:
//
// History:    KDamour  10Mar00   Created
//
//---------------------------------------------------------------------

#ifndef NTDIGEST_NTDIGEST_H
#define NTDIGEST_NTDIGEST_H


#define NTDIGEST_TOKEN_NAME_A         "WDIGEST"
#define NTDIGEST_DLL_NAME             L"wdigest.dll"

#define NTDIGEST_SP_COMMENT_A         "Digest Authentication for Windows"
#define NTDIGEST_SP_COMMENT           L"Digest Authentication for Windows"

#define NTDIGEST_SP_VERSION          1

//  Registry Information
#define REG_DIGEST_BASE     TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\WDigest")

// Values
#define REG_DIGEST_OPT_LIFETIME  TEXT("Lifetime")
#define REG_DIGEST_OPT_EXPIRESLEEP  TEXT("Expiresleep")
#define REG_DIGEST_OPT_DELEGATION  TEXT("Delegation")
#define REG_DIGEST_OPT_NEGOTIATE  TEXT("Negotiate")
#define REG_DIGEST_OPT_DEBUGLEVEL  TEXT("Debuglevel")
#define REG_DIGEST_OPT_MAXCTXTCOUNT  TEXT("MaxContext")
#define REG_DIGEST_OPT_UTF8HTTP  TEXT("UTF8HTTP")     // allow UTF-8 encoding for HTTP mode
#define REG_DIGEST_OPT_UTF8SASL  TEXT("UTF8SASL")     // allow UTF-8 encoding for SASL mode

#define NTDIGEST_SP_CAPS           (SECPKG_FLAG_TOKEN_ONLY | \
                               SECPKG_FLAG_IMPERSONATION | \
                               SECPKG_FLAG_ACCEPT_WIN32_NAME | \
                               SECPKG_FLAG_DELEGATION | \
                               SECPKG_FLAG_LOGON )

                               // SECPKG_FLAG_INTEGRITY | \

// Establish a limit to the sizes of the Auth header values
// From RFC Draft SASL max size if 4096 bytes - seems arbitrary                                         
#define NTDIGEST_SP_MAX_TOKEN_SIZE  4096

//  Lifetime for a Nonce - 10 hours
#define PARAMETER_LIFETIME (36000)

#define SASL_MAX_DATA_BUFFER   65536

// Max number of context entries to keep before tossing out old ones
#define PARAMETER_MAXCTXTCOUNT  30000

//  BOOL is Delegation is allowed on machine - default is FALSE
#define PARAMETER_DELEGATION        FALSE

//  BOOL is Nego support is allowed on machine - default is FALSE
#define PARAMETER_NEGOTIATE         FALSE

// MILLISECONDS for Sleep for the garbage collector for expired context entries
// Every 15 minutes is a reasonable default 1000*60*15 = 
#define PARAMETER_EXPIRESLEEPINTERVAL 900000

// Boolean if challenges should be sent with UTF8 support 
#define PARAMETER_UTF8_HTTP          TRUE
#define PARAMETER_UTF8_SASL          TRUE

// Function Prototypes
void DebugInitialize(void);


VOID DigestWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus);


BOOL NtDigestReadRegistry(
    BOOL fFirstTime);

void ReadDwordRegistrySetting(
    HKEY    hReadKey,
    HKEY    hWriteKey,
    LPCTSTR pszValueName,
    DWORD * pdwValue,
    DWORD   dwDefaultValue);

void SPUnloadRegOptions(void);

BOOL SPLoadRegOptions(void);

// Some common max sizes
#define NTDIGEST_MAX_REALM_SIZE   256    // should be based on a NT domain size


#endif // NTDIGEST_NTGDIGEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\parser.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        parser.cxx
//
// Contents:    Digest Access Parser for directives
//              Main entry points into this dll:
//                ParseForNames
//                CheckItemInList
//   Very primitive parser.  All strings must be quoted except for NC
//
// History:     KDamour 16Mar00   Based on IIS authfilt.cxx
//
//------------------------------------------------------------------------

#include <global.h>


    // Used by parser to find the keywords
    // Keep insync with enum MD5_AUTH_NAME
PSTR MD5_AUTH_NAMES[] = {
    "username",
    "realm",
    "nonce",
    "cnonce",
    "nc",
    "algorithm",
    "qop",
    "method",
    "uri",
    "response",
    "hentity",
    "authzid",
    "domain",
    "stale",
    "opaque",
    "maxbuf",
    "charset",
    "cipher",
    "digest-uri",
    "rspauth",
    ""              // Not really needed
};



enum STATE_TYPE
{
    READY,
    DIRECTIVE,
    ASSIGNMENT,
    QUOTEDVALUE,
    VALUE,
    ENDING,
    PROCESS_ENTRY,
    FAILURE
};


//+--------------------------------------------------------------------
//
//  Function:   DigestParser2
//
//  Synopsis:  Parse list of name=value pairs for known names
//
//  Effects:  
//
//  Arguments:     pszStr - line to parse ( '\0' delimited - terminated)
//    pNameTable - table of known names
//    cNameTable - number of known names
//    pDigest - set all of the directives in pDigest->strParams[x}
//
//  Returns:  STATUS_SUCCESS if success, E_FAIL if error
//
//  Notes:
//     Buffers are not wide Unicode!
//
//
//---------------------------------------------------------------------
NTSTATUS DigestParser2(
    PSecBuffer pInputBuf,
    PSTR *pNameTable,
    UINT cNameTable,
    OUT PDIGEST_PARAMETER pDigest
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSTR pcBeginName = NULL;
    PSTR pcEndName = NULL;
    PSTR pcBeginValue = NULL;
    PSTR pcEndValue = NULL;
    PSTR pcEndBuffer = NULL;    // End of buffer to prevent NC increment from going past end
    PSTR pcCurrent = NULL;
    STATE_TYPE parserstate = READY;
    BOOL fEscapedChar = FALSE;


    LONG  cbDirective = 0;
    LONG  cbValue = 0;

    // Verify that buffer exists and is of type single byte characters (not Unicode)
    if (!pInputBuf || (pInputBuf->cbBuffer && !pInputBuf->pvBuffer) ||
        (PBUFFERTYPE(pInputBuf) != SECBUFFER_TOKEN))
    {                                                    
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestParser2: Incorrect digest buffer format    status 0x%x\n", Status));
        goto CleanUp;
    }

    if (!pInputBuf->cbBuffer)
    {
        return STATUS_SUCCESS;    // Nothing to process  happens with makesignature
    }

    pcEndBuffer = (char *)pInputBuf->pvBuffer + pInputBuf->cbBuffer;

    for (pcCurrent = (char *)pInputBuf->pvBuffer; pcCurrent < pcEndBuffer; pcCurrent++)
    {
        if (parserstate == FAILURE)
        {
            break;
        }
        if (*pcCurrent == CHAR_NULL)
        {   //  If we hit a premature End of String then Exit immediately from scan
            break;
        }
        if (parserstate == READY)
        {
            if (isspace(*pcCurrent) || (*pcCurrent == CHAR_COMMA))
            {
                continue;    // get next char within for loop
            }
            pcBeginName = pcCurrent;
            pcEndName = pcCurrent;
            pcBeginValue = pcEndValue = NULL;
            parserstate = DIRECTIVE;
            continue;
        }
        if (parserstate == DIRECTIVE)
        {
            if (*pcCurrent == CHAR_EQUAL)
            {
                parserstate = ASSIGNMENT;
                continue;
            }
            if (isspace(*pcCurrent))
            {
                continue;    // get next char within for loop
            }
            pcEndName = pcCurrent;
            continue;
        }
        if (parserstate == ASSIGNMENT)
        {
            if (*pcCurrent == CHAR_DQUOTE)
            {
                pcBeginValue = NULL;
                pcEndValue = NULL;
                parserstate = QUOTEDVALUE;
                continue;
            }
            if (isspace(*pcCurrent))
            {
                continue;    // get next char within for loop
            }
            pcBeginValue = pcCurrent;
            pcEndValue = pcCurrent;
            parserstate = VALUE;
            continue;
        }
        if (parserstate == QUOTEDVALUE)
        {
            if ((*pcCurrent == CHAR_BACKSLASH) && (fEscapedChar == FALSE))
            {
                // used to escape the following character
                fEscapedChar = TRUE;
                continue;
            }
            if ((*pcCurrent == CHAR_DQUOTE) && (fEscapedChar == FALSE))
            {
                Status = DigestProcessEntry(pcBeginName, pcEndName, pcBeginValue, pcEndValue,
                                            pNameTable, cNameTable, TRUE, pDigest);
                parserstate = READY;   // start again statemachine
                continue;
            }
            fEscapedChar = FALSE;    // reset to not escaped state
            if (!pcBeginValue)
            {
                pcBeginValue = pcCurrent;
                pcEndValue = pcCurrent;
                continue;
            }
            pcEndValue = pcCurrent;
            continue;
        }
        if (parserstate == VALUE)
        {
            if (isspace(*pcCurrent))
            {
                continue;    // get next char within for loop
            }
            if (*pcCurrent == CHAR_COMMA)
            {
                Status = DigestProcessEntry(pcBeginName, pcEndName, pcBeginValue, pcEndValue,
                                            pNameTable, cNameTable, FALSE, pDigest);
                parserstate = READY;   // start again statemachine
                continue;
            }
            else
            {
                pcEndValue = pcCurrent;
            }
        }
    }

    if ((parserstate == FAILURE) || (parserstate == QUOTEDVALUE) ||
        (parserstate == ASSIGNMENT) || (parserstate == DIRECTIVE))
    {
        Status = E_FAIL;
        goto CleanUp;
    }

    // There might be a NULL terminated directive value to process
    if ((parserstate == VALUE))
    {
        Status = DigestProcessEntry(pcBeginName, pcEndName, pcBeginValue, pcEndValue,
                                    pNameTable, cNameTable, FALSE, pDigest);
    }


CleanUp:
    DebugLog((DEB_TRACE, "DigestParser: leaving status  0x%x\n", Status));
    return(Status);
}


NTSTATUS DigestProcessEntry(
    IN PSTR pcBeginName,
    IN PSTR pcEndName,
    IN PSTR pcBeginValue,
    IN PSTR pcEndValue,
    IN PSTR *pNameTable,
    IN UINT cNameTable,
    IN BOOL fBSlashEncoded,
    OUT PDIGEST_PARAMETER pDigest
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT  cbName = 0;
    USHORT  cbValue = 0;
    UINT iN = 0;
    BOOL fBSPresent = FALSE;
    PCHAR pcTemp = NULL;
    PSTR pcDst = NULL;
    PSTR pcLoc = NULL;
    USHORT iCnt = 0;

    if (!pcBeginName || !pcEndName)
    {
        DebugLog((DEB_ERROR, "DigestProcessEntry: Badly formed directive\n"));
        return (STATUS_UNSUCCESSFUL);
    }
    cbName = (USHORT)(pcEndName - pcBeginName) + 1;

    if (pcBeginValue && pcEndValue)
    {
        cbValue = (USHORT)(pcEndValue - pcBeginValue) + 1;
    }
    else
        cbValue = 0;

    for ( iN = 0 ; iN < cNameTable ; ++iN )
    {
        if ( !_strnicmp( pNameTable[iN], pcBeginName, cbName ) )
        {
            // DebugLog((DEB_TRACE, "DigestParser: Found %s directive in table put in value %s!\n", pszBeginName, pszBeginVal));
            break;
        }
    }

    if ( iN < cNameTable )   // We found a match!!!!!
    {
        if (iN == MD5_AUTH_DIGESTURI)
        {
            iN = MD5_AUTH_URI;          // Map SASL's "digest-uri" to "uri"
        }

        if (cbValue)
        {
            // For space optimization, if not Backslash encoded then use orginal memory buffer
            //  To simply code, can removed all refernces and just use a copy of the original
            //  while removing the backslash characters
            if (fBSlashEncoded == TRUE)
            {
                // quick search to see if there is a BackSlash character there
                fBSPresent = CheckBSlashChar(pcBeginValue, cbValue);
                if (fBSPresent == TRUE)
                {
                    pcDst = (PCHAR)DigestAllocateMemory(cbValue + 1);
                    if (!pcDst)
                    {
                        Status = SEC_E_INSUFFICIENT_MEMORY;
                        DebugLog((DEB_ERROR, "DigestProcessEntry: allocate error   0x%x\n", Status));
                        goto CleanUp;
                    }

                       // Now copy over the string removing and back slash encoding
                    pcLoc = pcBeginValue;
                    pcTemp = pcDst;
                    while (pcLoc <= pcEndValue)
                    {
                        if (*pcLoc == CHAR_BACKSLASH)
                        {
                            pcLoc++;   // eat the backslash
                        }
                        *pcTemp++ = *pcLoc++;
                        iCnt++;
                    }
                      // give the memory to member structure
                    pDigest->strDirective[iN].Buffer = pcDst;
                    pDigest->strDirective[iN].Length = iCnt;
                    pDigest->strDirective[iN].MaximumLength = cbValue+1;
                    pcDst = NULL;

                    pDigest->refstrParam[iN].Buffer = pDigest->strDirective[iN].Buffer;
                    pDigest->refstrParam[iN].Length = pDigest->strDirective[iN].Length;
                    pDigest->refstrParam[iN].MaximumLength = pDigest->strDirective[iN].MaximumLength;
                }
                else
                {
                    pDigest->refstrParam[iN].Buffer = pcBeginValue;
                    pDigest->refstrParam[iN].Length = cbValue;
                    pDigest->refstrParam[iN].MaximumLength = cbValue;
                }

            }
            else
            {
                pDigest->refstrParam[iN].Buffer = pcBeginValue;
                pDigest->refstrParam[iN].Length = cbValue;
                pDigest->refstrParam[iN].MaximumLength = cbValue;
            }
        }
    }

CleanUp:

    return(Status);
}


//+--------------------------------------------------------------------
//
//  Function:   CheckBSlashChar
//
//  Synopsis:  Search a string for a Back Slash character
//
//  Effects:
//
//  Arguments: 
//    pcStr - pointer to string of characters
//    len - number of characters to search
//
//  Returns:  TRUE if found, FALSE otherwise
//
//  Notes:
//
//
//---------------------------------------------------------------------
BOOL CheckBSlashChar(
    IN PSTR pcStr,
    IN USHORT len)
{
    BOOL fFound = FALSE;
    USHORT i = 0;

    for (i = 0; i < len; i++)
    {
        if (*pcStr++ == CHAR_BACKSLASH)
        {
            fFound = TRUE;
            break;
        }
    }

    return (fFound);
}



//+--------------------------------------------------------------------
//
//  Function:   CheckItemInList
//
//  Synopsis:  Searches a comma delimited list for specified string
//
//  Effects:
//
//  Arguments: 
//    pstrItem - pointer to string Item to look for
//    pstrList - pointer to string of comma delimited list
//    fOneItem - enforce that only 1 item is in List provided (no comma lists)
//
//  Returns:  STATUS_SUCCESS if found, E_FAIL otherwise
//
//  Notes:
//
//
//---------------------------------------------------------------------
NTSTATUS CheckItemInList(
    PCHAR pszItem,
    PSTRING pstrList,
    BOOL  fOneItem
    )
{
    int cbItem = 0;
    int cbListItem = 0;
    char *pch = NULL;
    char *pchStart = NULL;
    USHORT cbCnt = 0;

    ASSERT(pszItem);
    ASSERT(pstrList);

      // check to make sure that there is data in the list
    if (!pstrList->Length)
    {
        return(E_FAIL);
    }

    // There MUST be a bu
    ASSERT(pstrList->Buffer);

    pch = pstrList->Buffer;
    pchStart = NULL;
    cbItem = strlen(pszItem);

    // If oneItem selected then item MUST match list
    if (fOneItem)
    {
        if ((cbItem == pstrList->Length) && 
            (!_strnicmp(pszItem, pstrList->Buffer, cbItem)))
        {
            return(STATUS_SUCCESS);
        }
        else
        {
            return(E_FAIL);
        }
    }

    // Scan List until NULL
    while ((*pch != '\0') && (cbCnt < pstrList->Length))
    {
       // At start of next item in list
       // skip any whitespaces
       if (isspace((unsigned int)*pch) || (*pch == ','))
       {
           pch++;
           cbCnt++;
           continue;     // skip to the next while
       }

       // pointing at start of next item

       pchStart = pch;

       // scan for end of item
       while ((*pch != ',') && (*pch != '\0') && (cbCnt < pstrList->Length))
       {
           pch++;
           cbCnt++;
       }

       // pch points to end of item
       cbListItem = (int)(pch - pchStart);

       // Check it item matches item in list
       if (cbListItem == cbItem)
       {
           if (!_strnicmp(pszItem, pchStart, cbItem))
           {
               // found a match
               return(STATUS_SUCCESS);
           }
       }

       // If not end of List then skip to next character
       if (*pch != '\0')
       {
           pch++;
           cbCnt++;
       }

    }

    return(E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\user.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        user.h
//
// Contents:    declarations, constants for UserMode context manager
//
//
// History:     KDamour  13Apr00   Created
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_USER_H
#define NTDIGEST_USER_H

#include "nonce.h"

#define DES_BLOCKSIZE 8
#define RC4_BLOCKSIZE 1

// For import of plain text keys
typedef struct _PLAINTEXTBLOB
{
  BLOBHEADER Blob;
  DWORD      dwKeyLen;
  CHAR       bKey[MD5_HASH_BYTESIZE];
} PLAINTEXTBLOB;

// Initializes the context manager package 
NTSTATUS UserCtxtHandlerInit(VOID);

// Add a Context into the Cntext List
NTSTATUS UserCtxtHandlerInsertCred(IN PDIGEST_USERCONTEXT  pDigestCtxt);

// Initialize all the struct elements in a Context
NTSTATUS NTAPI UserCtxtInit(IN PDIGEST_USERCONTEXT pContext);

// Release memory utilized by the Context
NTSTATUS NTAPI UserCtxtFree(IN PDIGEST_USERCONTEXT pContext);

// Finf the security context by the security context handle
NTSTATUS NTAPI UserCtxtHandlerHandleToContext(IN ULONG_PTR ContextHandle, IN BOOLEAN RemoveContext,
    OUT PDIGEST_USERCONTEXT *ppContext);

// Releases the Context by decreasing reference counter
NTSTATUS UserCtxtHandlerRelease(PDIGEST_USERCONTEXT pContext);

// Check to see if Context is within valid lifetime
BOOL UserCtxtHandlerTimeHasElapsed(PDIGEST_USERCONTEXT pContext);

// Creates a new DACL for the token granting the server and client
NTSTATUS SspCreateTokenDacl(HANDLE Token);

// From userapi.cxx

// SECURITY_STATUS SEC_ENTRY FreeContextBuffer(void SEC_FAR *  pvContextBuffer);

NTSTATUS SspGetTokenUser(HANDLE Token, PTOKEN_USER * pTokenUser);

// Create a local context for a real context
NTSTATUS SspMapDigestContext(IN PDIGEST_CONTEXT pLsaContext,
                             IN PDIGEST_PARAMETER pDigest,
                             OUT PSecBuffer  ContextData);

NTSTATUS NTAPI DigestUserProcessParameters(
                       IN OUT PDIGEST_USERCONTEXT pContext,
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSecBuffer pFirstOutputToken);


NTSTATUS NTAPI DigestUserHTTPHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN eSignSealOp Op,
                        IN OUT PSecBufferDesc pMessage,
                        IN ULONG MessageSeqNo
                        );

NTSTATUS NTAPI DigestUserSignHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pMessage,
                        IN ULONG MessageSeqNo
                        );

NTSTATUS NTAPI DigestUserSealHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pMessage,
                        IN ULONG MessageSeqNo
                        );

NTSTATUS NTAPI DigestUserUnsealHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pMessage,
                        IN ULONG MessageSeqNo
                        );

NTSTATUS NTAPI DigestUserVerifyHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pMessage,
                        IN ULONG MessageSeqNo
                        );

// Unpack the context from LSA mode into the User mode Context
NTSTATUS DigestUnpackContext(
    IN PDIGEST_PACKED_USERCONTEXT pPackedUserContext,
    OUT PDIGEST_USERCONTEXT pContext);

// Printout the fields present in usercontext pContext
NTSTATUS UserContextPrint(PDIGEST_USERCONTEXT pContext);

// Create a symmetric key with a given cleartext shared secret
NTSTATUS SEC_ENTRY CreateSymmetricKey(
    IN ALG_ID     Algid,
    IN DWORD      cbKey,
    IN UCHAR      *pbKey,
    IN UCHAR      *pbIV,
    OUT HCRYPTKEY *phKey
    );

// Encrypt data with the symmetric key - non-consecutive buffers
NTSTATUS SEC_ENTRY EncryptData2(
    IN HCRYPTKEY  hKey,
    IN ULONG      cbBlocklength,
    IN ULONG      cbData,
    IN OUT UCHAR  *pbData,
    IN ULONG      cbSignature,
    IN OUT UCHAR  *pbSignature
    );


NTSTATUS SEC_ENTRY DecryptData(
    IN HCRYPTKEY  hKey,
    IN ULONG      cbData,
    IN OUT UCHAR  *pbData
    );

// Calculate the HMAC block for SASL messaging
NTSTATUS
SEC_ENTRY
CalculateSASLHMAC(
    IN PDIGEST_USERCONTEXT pContext,
    IN BOOL  fSign,
    IN PSTRING pstrSignKeyConst,
    IN DWORD dwSeqNum,
    IN PBYTE pdata,                        // location of data to HMAC
    IN ULONG cbdata,                       // How many bytes of data to process
    OUT PSASL_MAC_BLOCK pMacBlock
    );

// For encrypt (seal)/ decrypt (unseal) calculate the value of Kc RFC 2831 sect 2.4
NTSTATUS
SEC_ENTRY
CalculateKc(
    IN PBYTE pbSessionKey,
    IN USHORT cbHA1n,
    IN PSTRING pstrSealKeyConst,
    IN PBYTE pHashData
    );

void
SetDESParity(
        PBYTE           pbKey,
        DWORD           cbKey
        );

NTSTATUS
AddDESParity(
    IN PBYTE           pbSrcKey,
    IN DWORD           cbSrcKey,
    OUT PBYTE          pbDstKey,
    OUT PDWORD         pcbDstKey
    );

#endif  // DIGEST_USER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\ntdigest.cxx ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:       ntdigest.c
//
// Contents:   main entrypoints for the digest security package
//               SpLsaModeInitialize
//               SpInitialize
//               SpShutdown
//               SpGetInfo
//
//             Helper functions:
//
// History:    KDamour  10Mar00   Stolen from msv_sspi\ntlm.cxx
//
//---------------------------------------------------------------------
#define NTDIGEST_GLOBAL
#include "global.h"


/* Debugging information setup */
DEFINE_DEBUG2(Digest);

DEBUG_KEY  MyDebugKeys[] = {{DEB_ERROR, "Error"},
    {DEB_WARN, "Warning"},
    {DEB_TRACE, "Trace"},
    {DEB_TRACE_ASC, "TraceASC"},
    {DEB_TRACE_ISC, "TraceISC"},
    {DEB_TRACE_LSA, "TraceLSA"},
    {DEB_TRACE_USER, "TraceUser"},
    {DEB_TRACE_FUNC, "TraceFuncs"},
    {DEB_TRACE_MEM, "TraceMem"},
    {TRACE_STUFF, "Stuff"},
    {0, NULL}
};

//   set to TRUE once initialized 
BOOL l_bDebugInitialized = FALSE;
BOOL l_bDigestInitialized = FALSE;

// Registry reading
HKEY   g_hkBase      = NULL;
HANDLE g_hParamEvent = NULL;
HANDLE g_hWait       = NULL;

#define COMPUTER_NAME_SIZE (MAX_COMPUTERNAME_LENGTH + 1)



//+--------------------------------------------------------------------
//
//  Function:   SpLsaModeInitialize
//
//  Synopsis:   This function is called by the LSA when this DLL is loaded.
//              It returns security package function tables for all
//              security packages in the DLL.
//
//  Arguments:  LsaVersion - Version number of the LSA
//              PackageVersion - Returns version number of the package
//              Tables - Returns array of function tables for the package
//              TableCount - Returns number of entries in array of
//                      function tables.
//
//  Returns:    PackageVersion (as above)
//              Tables (as above)
//              TableCount (as above)
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Tables,
    OUT PULONG TableCount
    )
{
#if DBG
    DebugInitialize();
#endif

    DebugLog((DEB_TRACE_FUNC, "SpLsaModeInitialize: Entering\n"));


    SECURITY_STATUS Status = SEC_E_OK;

    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        DebugLog((DEB_ERROR, "SpLsaModeInitialize: Invalid LSA version: %d\n", LsaVersion));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    // Fill in the dispatch table for functions exported by ssp
    g_NtDigestFunctionTable.InitializePackage        = NULL;
    g_NtDigestFunctionTable.LogonUser                = NULL;
    g_NtDigestFunctionTable.CallPackage              = LsaApCallPackage;
    g_NtDigestFunctionTable.LogonTerminated          = LsaApLogonTerminated;
    g_NtDigestFunctionTable.CallPackageUntrusted     = LsaApCallPackageUntrusted;
    g_NtDigestFunctionTable.LogonUserEx              = NULL;
    g_NtDigestFunctionTable.LogonUserEx2             = LsaApLogonUserEx2;
    g_NtDigestFunctionTable.Initialize               = SpInitialize;
    g_NtDigestFunctionTable.Shutdown                 = SpShutdown;
    g_NtDigestFunctionTable.GetInfo                  = SpGetInfo;
    g_NtDigestFunctionTable.AcceptCredentials        = SpAcceptCredentials;
    g_NtDigestFunctionTable.AcquireCredentialsHandle = SpAcquireCredentialsHandle;
    g_NtDigestFunctionTable.FreeCredentialsHandle    = SpFreeCredentialsHandle;
    g_NtDigestFunctionTable.SaveCredentials          = SpSaveCredentials;
    g_NtDigestFunctionTable.GetCredentials           = SpGetCredentials;
    g_NtDigestFunctionTable.DeleteCredentials        = SpDeleteCredentials;
    g_NtDigestFunctionTable.InitLsaModeContext       = SpInitLsaModeContext;
    g_NtDigestFunctionTable.AcceptLsaModeContext     = SpAcceptLsaModeContext;
    g_NtDigestFunctionTable.DeleteContext            = SpDeleteContext;
    g_NtDigestFunctionTable.ApplyControlToken        = SpApplyControlToken;
    g_NtDigestFunctionTable.GetUserInfo              = SpGetUserInfo;
    g_NtDigestFunctionTable.QueryCredentialsAttributes = SpQueryCredentialsAttributes ;
    g_NtDigestFunctionTable.GetExtendedInformation   = SpGetExtendedInformation ;
    g_NtDigestFunctionTable.SetExtendedInformation   = SpSetExtendedInformation ;
    g_NtDigestFunctionTable.CallPackagePassthrough   = LsaApCallPackagePassthrough;


    *PackageVersion = SECPKG_INTERFACE_VERSION;
    *Tables = &g_NtDigestFunctionTable;
    *TableCount = 1;

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SpLsaModeInitialize:Leaving\n"));

    return(Status);
}


//+--------------------------------------------------------------------
//
//  Function:   SpInitialize
//
//  Synopsis:   Initializes the Security package
//
//  Arguments:  PackageId - Contains ID for this package assigned by LSA
//              Parameters - Contains machine-specific information
//              FunctionTable - Contains table of LSA helper routines
//
//  Returns: None
//
//  Notes: Everything that was done in LsaApInitializePackage
//         should be done here. Lsa assures us that only
//         one thread is executing this at a time. Don't
//         have to worry about concurrency problems.(BUGBUG verify)
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpInitialize(
    IN ULONG_PTR pPackageId,
    IN PSECPKG_PARAMETERS pParameters,
    IN PLSA_SECPKG_FUNCTION_TABLE pFunctionTable
    )
{

    SECURITY_STATUS Status = SEC_E_OK;
    DWORD   dwWinErr = 0;
    NT_PRODUCT_TYPE NtProductType = NtProductWinNt;
    WCHAR wszComputerName[COMPUTER_NAME_SIZE];
    DWORD dwComputerNameLen = COMPUTER_NAME_SIZE;

    DebugLog((DEB_TRACE_FUNC, "SpInitialize: Entering\n"));

    // Indicate that we completed initialization
    ASSERT(l_bDigestInitialized == FALSE);   // never called more than once
    l_bDigestInitialized = TRUE;

    // Initialize global values
    ZeroMemory(&g_strNtDigestUTF8ServerRealm, sizeof(g_strNtDigestUTF8ServerRealm));
    ZeroMemory(&g_strNTDigestISO8859ServerRealm, sizeof(g_strNTDigestISO8859ServerRealm));


    // Define time for AcquirCredentialHandle
    // We really need this to be a day less than maxtime so when callers
    // of sspi convert to utc, they won't get time in the past.

    g_TimeForever.HighPart = 0x7FFFFFFF;
    g_TimeForever.LowPart  = 0xFFFFFFFF;

    //
    // All the following are global
    //

    g_NtDigestState                  = NtDigestLsaMode;   /* enum */
    g_NtDigestPackageId              = pPackageId;

    //
    // Save away the Lsa functions
    //

    g_LsaFunctions    = pFunctionTable;


    //
    // Establish the packagename
    //
    RtlInitUnicodeString(
        &g_ustrNtDigestPackageName,
        WDIGEST_SP_NAME
        );


    // Set the WorkstationName
    if (!GetComputerNameExW(ComputerNameNetBIOS, wszComputerName, &dwComputerNameLen))
    {
        ZeroMemory(&g_ustrWorkstationName, sizeof(g_ustrWorkstationName));
        DebugLog((DEB_ERROR, "SpInitialize: Get ComputerName  error 0x%x\n", GetLastError()));
    }
    else
    {
        Status = UnicodeStringWCharDuplicate(&g_ustrWorkstationName, wszComputerName);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpInitialize: ComputerName copy   status 0x%x\n", Status));
            goto CleanUp;
        }
    }


    // Need to initialize Crypto stuff and nonce creations
    Status = NonceInitialize();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from NonceInitialize   status 0x%x\n", Status));
        goto CleanUp;
    }


    //
    // Determine if this machine is running Windows NT or Lanman NT.
    //  LanMan NT runs on a domain controller.
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        //  Nt Product Type undefined - WinNt assumed
        NtProductType = NtProductWinNt;
    }

    if (NtProductType == NtProductLanManNt)
    {
        g_fDomainController = TRUE;              // Allow password checking only on DomainControllers
    }

    //
    // Save the Parameters info to a global struct
    //
    g_NtDigestSecPkg.MachineState = pParameters->MachineState;
    g_NtDigestSecPkg.SetupMode = pParameters->SetupMode;
    g_NtDigestSecPkg.Version = pParameters->Version;

    Status = UnicodeStringDuplicate(
                                 &g_NtDigestSecPkg.DnsDomainName,
                                 &(pParameters->DnsDomainName));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from UnicodeStringDuplicate    status 0x%x\n", Status));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicate(
                                 &g_NtDigestSecPkg.DomainName,
                                 &(pParameters->DomainName));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from UnicodeStringDuplicate   status 0x%x\n", Status));
        goto CleanUp;
    }


    if (pParameters->DomainSid != NULL) {
        Status = SidDuplicate( &g_NtDigestSecPkg.DomainSid,
                                pParameters->DomainSid );
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpInitialize: Error from SidDuplicate   status 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
        g_NtDigestSecPkg.DomainSid = NULL;

    DebugLog((DEB_TRACE, "SpInitialize: DNSDomain = %wZ, Domain = %wZ\n", &(g_NtDigestSecPkg.DnsDomainName),
               &(g_NtDigestSecPkg.DomainName)));


    // For server challenges, precalculate the UTF-8 and ISO versions of the realm

    Status = EncodeUnicodeString(&(g_NtDigestSecPkg.DnsDomainName), CP_8859_1, &g_strNTDigestISO8859ServerRealm, NULL);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "SpInitialize: Error in encoding domain in ISO-8859-1\n"));
        ZeroMemory(&g_strNTDigestISO8859ServerRealm, sizeof(STRING));
    }

    Status = EncodeUnicodeString(&(g_NtDigestSecPkg.DnsDomainName), CP_UTF8, &g_strNtDigestUTF8ServerRealm, NULL);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "SpInitialize: Error in encoding domain in UTF-8\n"));
        ZeroMemory(&g_strNtDigestUTF8ServerRealm, sizeof(STRING));
    }

    //
    // Initialize the digest token source
    //

    RtlCopyMemory(
        g_DigestSource.SourceName,
        NTDIGEST_TOKEN_NAME_A,
        sizeof(NTDIGEST_TOKEN_NAME_A)
        );

    NtAllocateLocallyUniqueId(&g_DigestSource.SourceIdentifier);


    //
    // Init the LogonSession stuff
    //
    Status = LogSessHandlerInit();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from LogSessHandlerInit   status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Init the Credential stuff
    //
    Status = CredHandlerInit();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from CredHandlerInit   status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Init the Context stuff
    //
    Status = CtxtHandlerInit();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from ContextInitialize    status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Read in the registry values for SSP configuration - in LSA space
    //
    SPLoadRegOptions();

CleanUp:

    if (!NT_SUCCESS (Status))
    {
        SPUnloadRegOptions();
        SpShutdown();
    }

    DebugLog((DEB_TRACE_FUNC, "SpInitialize: Leaving\n"));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   SpShutdown
//
//  Synopsis:   Exported function to shutdown the Security package.
//
//  Effects:    Forces the freeing of all credentials, contexts
//              and frees all global data
//
//  Arguments:  none
//
//  Returns:
//
//  Notes:      SEC_E_OK in all cases
//         Most of the stuff was taken from SspCommonShutdown()
//         from svcdlls\ntlmssp\common\initcomn.c
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpShutdown(
    VOID
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpShutdown: Entering\n"));

    // Need to identify how to shutdown without causing faults with
    // incoming messages

    DebugLog((DEB_TRACE_FUNC, "SpShutdown: Leaving\n"));

    return(SEC_E_OK);
}



//+--------------------------------------------------------------------
//
//  Function:   SpGetInfo
//
//  Synopsis:   Returns information about the package
//
//  Effects:    returns pointers to global data
//
//  Arguments:  PackageInfo - Receives security package information
//
//  Returns:    SEC_E_OK in all cases
//
//  Notes:      Pointers to constants ok. Lsa will copy the data
//              before sending it to someone else. This function required
//              to return SUCCESS for the package to stay loaded.
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpGetInfo(
    OUT PSecPkgInfo PackageInfo
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpGetInfo:  Entering\n"));

    PackageInfo->fCapabilities    = NTDIGEST_SP_CAPS;
    PackageInfo->wVersion         = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    PackageInfo->wRPCID           = RPC_C_AUTHN_DIGEST;
    PackageInfo->cbMaxToken       = NTDIGEST_SP_MAX_TOKEN_SIZE;
    PackageInfo->Name             = WDIGEST_SP_NAME;
    PackageInfo->Comment          = NTDIGEST_SP_COMMENT;

    DebugLog((DEB_TRACE_FUNC, "SpGetInfo: Leaving\n"));

    return(SEC_E_OK);
}

// Misc SECPKG Functions

NTSTATUS NTAPI
SpGetUserInfo(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserData
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpGetUserInfo: Entering/Leaving\n"));

    // FIXIFX Fields of UserData are username, domain, server

    UNREFERENCED_PARAMETER(LogonId);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(UserData);

    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpGetExtendedInformation
//
//  Synopsis:   Return extended information to the LSA
//
//  Arguments:  [Class] -- Information Class
//              [pInfo] -- Returned Information Pointer
//
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
SpGetExtendedInformation(
    IN  SECPKG_EXTENDED_INFORMATION_CLASS Class,
    OUT PSECPKG_EXTENDED_INFORMATION * ppInformation
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSECPKG_EXTENDED_INFORMATION Information = NULL;
    ULONG Size = 0;


    DebugLog((DEB_TRACE_FUNC, "SpGetExtendedInformation:  Entering\n"));

    switch ( Class )
    {

        case SecpkgWowClientDll:

            //
            // This indicates that we're smart enough to handle wow client processes
            //

            Information = (PSECPKG_EXTENDED_INFORMATION)
                                DigestAllocateMemory( sizeof( SECPKG_EXTENDED_INFORMATION ) +
                                              (MAX_PATH * sizeof(WCHAR) ) );

            if ( Information == NULL )
            {
                Status = STATUS_INSUFFICIENT_RESOURCES ;
                goto Cleanup ;
            }

            Information->Class = SecpkgWowClientDll ;
            Information->Info.WowClientDll.WowClientDllPath.Buffer = (PWSTR) (Information + 1);
            Size = ExpandEnvironmentStrings(
                        L"%SystemRoot%\\" WOW64_SYSTEM_DIRECTORY_U L"\\" NTDIGEST_DLL_NAME,
                        Information->Info.WowClientDll.WowClientDllPath.Buffer,
                        MAX_PATH );
            Information->Info.WowClientDll.WowClientDllPath.Length = (USHORT) (Size * sizeof(WCHAR));
            Information->Info.WowClientDll.WowClientDllPath.MaximumLength = (USHORT) ((Size + 1) * sizeof(WCHAR) );
            *ppInformation = Information ;
            Information = NULL ;

            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;
    }

Cleanup:

    if ( Information != NULL )
    {
        DigestFreeMemory( Information );
    }

    DebugLog((DEB_TRACE_FUNC, "SpGetExtendedInformation:  Leaving    Status %d\n", Status));

    return Status ;
}



NTSTATUS NTAPI
SpSetExtendedInformation(
    IN SECPKG_EXTENDED_INFORMATION_CLASS Class,
    IN PSECPKG_EXTENDED_INFORMATION Info
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpSetExtendedInformation: Entering/Leaving \n"));

    UNREFERENCED_PARAMETER(Class);
    UNREFERENCED_PARAMETER(Info);
    return(SEC_E_UNSUPPORTED_FUNCTION) ;
}

//
// Registry Reading routines
//  This routine is called in single-threaded mode from the LSA for SpInitialize and SPInstanceInit
//  In user applications only SPInstanceInit calls this function
//
BOOL SPLoadRegOptions(void)
{
    if (NULL != g_hParamEvent)
    {
        // Already called - no need to re-execute
        DebugLog((DEB_TRACE, "SPLoadRegOptions: Already initialized - Leaving \n"));
        return TRUE;
    }

    g_hParamEvent = CreateEvent(NULL,
                           FALSE,
                           FALSE,
                           NULL);

    DigestWatchParamKey(g_hParamEvent, FALSE);

    return TRUE;
}


void SPUnloadRegOptions(void)
{
    if (NULL != g_hWait) 
    {
        RtlDeregisterWaitEx(g_hWait, (HANDLE)-1);
        g_hWait = NULL;
    }

    if(NULL != g_hkBase)
    {
        RegCloseKey(g_hkBase);
        g_hkBase = NULL;
    }

    if(NULL != g_hParamEvent)
    {
        CloseHandle(g_hParamEvent);
        g_hParamEvent = NULL;
    }

}


// Helper function to read in a DWORD - sets value if not present in registry
void
ReadDwordRegistrySetting(
    HKEY    hReadKey,
    HKEY    hWriteKey,
    LPCTSTR pszValueName,
    DWORD * pdwValue,
    DWORD   dwDefaultValue)
{
    DWORD dwSize = 0;
    DWORD dwType = 0;

    dwSize = sizeof(DWORD);
    if(RegQueryValueEx(hReadKey, 
                       pszValueName, 
                       NULL, 
                       &dwType, 
                       (PUCHAR)pdwValue, 
                       &dwSize) != STATUS_SUCCESS)
    {
        *pdwValue = dwDefaultValue;

        if(hWriteKey)
        {
            RegSetValueEx(hWriteKey, 
                          pszValueName, 
                          0, 
                          REG_DWORD, 
                          (PUCHAR)pdwValue, 
                          sizeof(DWORD));
        }
    }
}


// Can be called at any time to change the default values
// As long as a DWORD assignment can be done in a single step
BOOL
NtDigestReadRegistry(BOOL fFirstTime)
{
    DWORD  dwBool = 0;
    DWORD  dwDebug = 0;

    HKEY        hWriteKey = 0;


    // Open top-level key that has write access.
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REG_DIGEST_BASE,
                    0,
                    KEY_READ | KEY_SET_VALUE,
                    &hWriteKey) != STATUS_SUCCESS)
    {
        hWriteKey = 0;
    }


    // "LifeTime"
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_LIFETIME,
        &g_dwParameter_Lifetime,
        PARAMETER_LIFETIME);

    // "Negotiate" Supported - BOOL value
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_NEGOTIATE,
        &dwBool,
        PARAMETER_NEGOTIATE);
    if (dwBool)
        g_fParameter_Negotiate = TRUE;
    else
        g_fParameter_Negotiate = FALSE;

    // UTF8 Supported in HTTP mode - BOOL value
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_UTF8HTTP,
        &dwBool,
        PARAMETER_UTF8_HTTP);
    if (dwBool)
        g_fParameter_UTF8HTTP = TRUE;
    else
        g_fParameter_UTF8HTTP = FALSE;

    // UTF8 supported in SASL - BOOL value
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_UTF8SASL,
        &dwBool,
        PARAMETER_UTF8_SASL);
    if (dwBool)
        g_fParameter_UTF8SASL = TRUE;
    else
        g_fParameter_UTF8SASL = FALSE;

    // MaxContextCount
    /*
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_MAXCTXTCOUNT,
        &g_dwParameter_MaxCtxtCount,
        PARAMETER_MAXCTXTCOUNT);
    */

#if DBG
    // DebugLevel
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_DEBUGLEVEL,
        &dwDebug,
        0);
    DigestInfoLevel = dwDebug;   // Turn on/off selected messages

#endif

    if(hWriteKey)
    {
        RegCloseKey(hWriteKey);
        hWriteKey = 0;
    }

    DebugLog((DEB_TRACE, "NtDigestReadRegistry:  Lifetime %lu, Negotiate %d, UTF-8 HTTP %d, UTF-8 SASL %d, DebugLevel 0x%x\n",
              g_dwParameter_Lifetime,
              g_fParameter_Negotiate,
              g_fParameter_UTF8HTTP,
              g_fParameter_UTF8SASL,
              dwDebug));

    return TRUE;
}

//  This routine is called in single-threaded mode from the LSA for SpLsaModeInitialize and SPInstanceInit
//  In user applications only SPInstanceInit calls this function
void
DebugInitialize(void)
{
#if DBG
    if (l_bDebugInitialized == TRUE)
    {
        return;
    }
    l_bDebugInitialized = TRUE;
    DigestInitDebug(MyDebugKeys);
    DigestInfoLevel = 0x0;             // Turn on OFF messages - Registry read will adjust which ones to keep on
#endif
    return;
}

////////////////////////////////////////////////////////////////////
//
//  Name:       DigestWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
DigestWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus)
{
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;
    BOOL        fFirstTime = FALSE;
    DWORD       disp;

    if(g_hkBase == NULL)
    {
        // First time we've been called.
        Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                REG_DIGEST_BASE,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &g_hkBase,
                                &disp);
        if(Status)
        {
            DebugLog((DEB_WARN,"Failed to open WDigest key: 0x%x\n", Status));
            return;
        }

        fFirstTime = TRUE;
    }

    if(pCtxt != NULL)
    {
        if (NULL != g_hWait) 
        {
            Status = RtlDeregisterWait(g_hWait);
            if(!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
                goto Reregister;
            }
        }

        lRes = RegNotifyChangeKeyValue(
                    g_hkBase,
                    TRUE,
                    REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                    (HANDLE)pCtxt,
                    TRUE);

        if (ERROR_SUCCESS != lRes) 
        {
            DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
            // we're tanked now. No further notifications, so get this one
        }
    }

    NtDigestReadRegistry(fFirstTime);

Reregister:

    if(pCtxt != NULL)
    {
        Status = RtlRegisterWait(&g_hWait,
                                 (HANDLE)pCtxt,
                                 DigestWatchParamKey,
                                 (HANDLE)pCtxt,
                                 INFINITE,
                                 WT_EXECUTEINPERSISTENTIOTHREAD|
                                 WT_EXECUTEONLYONCE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\userapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        userapi.cxx
//
// Contents:    User-mode APIs to the NtDigest security package
//
//              Main user mode entry points into this dll:
//                SpUserModeInitialize
//                SpInstanceInit
//                SpDeleteUserModeContext
//                SpInitUserModeContext
//                SpMakeSignature
//                SpVerifySignature
//                SpSealMessage
//                SpUnsealMessage
//                SpGetContextToken
//                SpQueryContextAttributes
//                SpCompleteAuthToken
//                SpFormatCredentials
//                SpMarshallSupplementalCreds
//                SpExportSecurityContext
//                SpImportSecurityContext
//
//              Helper functions:
//                SspCreateTokenDacl
//                SspMapContext (this is called in Lsa mode)
//
// History:     ChandanS 26-Jul-1996   Stolen from kerberos\client2\userapi.cxx
//              KDamour  18Mar00       Stolen from NTLM userapi.cxx
//
//------------------------------------------------------------------------

//
//  This area is still under determination as to support for userlevel functions
//

#include "global.h"
#include <stdio.h>         // For sprintf

#if DBG
#define TEMPSIZE 4000
#endif

// Winsock-ish host/network byte order converters for short and long integers.
//
#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

#define htonl(x)        ((((x) >> 24) & 0x000000FFL) | \
                        (((x) >>  8) & 0x0000FF00L) | \
                        (((x) <<  8) & 0x00FF0000L) | \
                        (((x) << 24) & 0xFF000000L))



//+-------------------------------------------------------------------------
//
//  Function:   SpUserModeInitialize
//
//  Synopsis:   Initialize an the Digest DLL in a client's
//              address space also called in LSA
//
//  Effects:
//
//  Arguments:  LsaVersion - Version of the security dll loading the package
//              PackageVersion - Version of the Digest package
//              UserFunctionTable - Receives a copy of Digests's user mode
//                  function table
//              pcTables - Receives count of tables returned.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS  - normal completion
//              STATUS_INVALID_PARAMETER - LsaVersion specified is incorrect
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS
SEC_ENTRY
SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables
    )
{
#if DBG
    DebugInitialize();
#endif

    DebugLog((DEB_TRACE_FUNC, "SpUserModeInitialize: Entering\n" ));

    NTSTATUS Status = STATUS_SUCCESS;

    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    *PackageVersion = SECPKG_INTERFACE_VERSION;

    g_NtDigestUserFuncTable.InstanceInit          = SpInstanceInit;
    g_NtDigestUserFuncTable.MakeSignature         = SpMakeSignature;
    g_NtDigestUserFuncTable.VerifySignature       = SpVerifySignature;
    g_NtDigestUserFuncTable.SealMessage           = SpSealMessage;
    g_NtDigestUserFuncTable.UnsealMessage         = SpUnsealMessage;
    g_NtDigestUserFuncTable.GetContextToken       = SpGetContextToken;
    g_NtDigestUserFuncTable.QueryContextAttributes = SpQueryContextAttributes;
    g_NtDigestUserFuncTable.CompleteAuthToken     = SpCompleteAuthToken;
    g_NtDigestUserFuncTable.InitUserModeContext   = SpInitUserModeContext;
    g_NtDigestUserFuncTable.DeleteUserModeContext = SpDeleteUserModeContext;
    g_NtDigestUserFuncTable.FormatCredentials     = SpFormatCredentials;
    g_NtDigestUserFuncTable.MarshallSupplementalCreds = SpMarshallSupplementalCreds;
    g_NtDigestUserFuncTable.ExportContext         = SpExportSecurityContext;
    g_NtDigestUserFuncTable.ImportContext         = SpImportSecurityContext;

    *UserFunctionTable = &g_NtDigestUserFuncTable;
    *pcTables = 1;

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "SpUserModeInitialize: Leaving    Status 0x%x\n", Status));
    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   SpInstanceInit
//
//  Synopsis:   Initialize an instance of the NtDigest package in a client's
//              address space. Also called once in LSA
//
//  Effects:
//
//  Arguments:  Version - Version of the security dll loading the package
//                         and it is Unused and Un-initialized
//              FunctionTable - Contains helper routines for use by NtDigest
//                         and it is fixed static
//              UserFunctions - Receives a copy of NtDigest's user mode
//                  function table - NOPE - has No information at all
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpInstanceInit: Entering\n" ));
    NTSTATUS Status = STATUS_SUCCESS;

    // Save the Alloc/Free functions
    // Check if called in LSA or from Usermode - LSA calls SPInitialize then SPInstanceInit

    if (g_NtDigestState != NtDigestLsaMode)
    {
        g_NtDigestState = NtDigestUserMode;   // indicate in user address space
    }
    g_UserFunctions = DllFunctionTable;

    // Need to initialize Crypto stuff and nonce creations
    Status = NonceInitialize();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInstanceInit: Error from NonceInitialize is %d\n", Status));
        goto CleanUp;
    }

    //
    // Init the UserMode Context stuff
    //
    Status = UserCtxtHandlerInit();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInstanceInit: Error from UserCtxtHandlerInit 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Read in the registry values for SSP configuration - in user mode space
    //
    SPLoadRegOptions();

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SpInstanceInit: Leaving    Status = 0x%lx\n", Status ));
    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteUserModeContext
//
//  Synopsis:   Deletes a user mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa context handle of the context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//        If this is an exported context, send a flag back to the LSA so that
//        Lsa does not call the SecpDeleteSecurityContext in the lsa process
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpDeleteUserModeContext(
    IN ULONG_PTR ContextHandle
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpDeleteUserModeContext: Entering   ContextHandle 0x%lx\n", ContextHandle ));
    PDIGEST_USERCONTEXT pUserContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Find the currently existing user context and delink it
    // so that another context cannot Reference it before we
    // Dereference this one.
    //
    Status = UserCtxtHandlerHandleToContext(ContextHandle, TRUE, &pUserContext);
    if (!NT_SUCCESS(Status))
    {
        //
        // pContext is legally NULL when we are dealing with an incomplete
        // context.  This can often be the case when the second call to
        // InitializeSecurityContext() fails.
        //
        ///        Status = STATUS_INVALID_HANDLE;
        Status = STATUS_SUCCESS;
        DebugLog((DEB_WARN, "SpDeleteUserModeContext: UserCtxtHandlerHandleToContext not found 0x%x\n", Status ));
        goto CleanUp;
    }

    //  Now deference 
    if (pUserContext != NULL)
    {
        Status = UserCtxtHandlerRelease(pUserContext);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpDeleteUserModeContext: DereferenceUserContext error  Status 0x%x\n", Status ));
        }
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SpDeleteUserModeContext: Leaving ContextHandle 0x%lx    status 0x%x\n",
               ContextHandle, Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpInitUserModeContext
//
//  Synopsis:   Creates a user-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitUserModeContext(
    IN ULONG_PTR ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;
    PDIGEST_PACKED_USERCONTEXT pPackedUserContext = NULL;
    UINT Length = 0;

    DebugLog((DEB_TRACE_FUNC, "SpInitUserModeContext: Entering  ContextHandle 0x%lx\n", ContextHandle ));
    
    ASSERT(PackedContext);


    // If Marshalled data is too small for holding a Client Context - reject it
    if (PackedContext->cbBuffer < sizeof(DIGEST_PACKED_USERCONTEXT))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "SpInitUserModeContext:  ContextData size < DIGEST_PACKED_USERCONTEXT\n" ));
        goto CleanUp;
    }

    pPackedUserContext = (PDIGEST_PACKED_USERCONTEXT) DigestAllocateMemory(PackedContext->cbBuffer);
    if (!pPackedUserContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "SpInitUserModeContext: DigestAllocateMemory for Packed Copy returns NULL\n" ));
        goto CleanUp;
    }

    // Copy the Packed User Context from LSA to local memory so it wil be long word aligned
    memcpy(pPackedUserContext, PackedContext->pvBuffer, PackedContext->cbBuffer);


    // Now we will unpack this transfered LSA context into UserMode space Context List
    pContext = (PDIGEST_USERCONTEXT) DigestAllocateMemory( sizeof(DIGEST_USERCONTEXT) );
    if (!pContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "SpInitUserModeContext: DigestAllocateMemory returns NULL\n" ));
        goto CleanUp;
    }

    Status = UserCtxtInit(pContext);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpInitUserModeContext: UserContextInit error 0x%x\n", Status));
        goto CleanUp;
    }

    // Store the location of the context in the LSA
    pContext->LsaContext =  ContextHandle;

    Status = DigestUnpackContext(pPackedUserContext, pContext);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpInitUserModeContext: DigestUnpackContext error 0x%x\n", Status));
        goto CleanUp;
    }

    UserContextPrint(pContext);


    Status = UserCtxtHandlerInsertCred(pContext);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpInitUserModeContext: UserCtxtHandlerInsertCred error  status 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "SpInitUserModeContext: (RefCount) UserContextInit created & listed 0x%x\n", pContext));

CleanUp:

    if (!NT_SUCCESS(Status))
    {
        if (pContext != NULL)
        {
            // Release the User context on error if allocated
            UserCtxtFree(pContext);
            pContext = NULL;
        }
    }

    if (pPackedUserContext)
    {
        DigestFreeMemory(pPackedUserContext);
        pPackedUserContext = NULL;
    }

    // Let FreeContextBuffer handle freeing the virtual allocs

    if (PackedContext->pvBuffer != NULL)
    {
        FreeContextBuffer(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
        PackedContext->cbBuffer = 0;
    }

    DebugLog((DEB_TRACE_FUNC, "SpInitUserModeContext: Leaving      status 0x%x\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpMakeSignature
//
//  Synopsis:   Signs a message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSignMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpMakeSignature(
    IN ULONG_PTR ContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;
    BOOL    bServer = FALSE;
    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;   // Are we in SASL or HTTP mode

    DebugLog((DEB_TRACE_FUNC, "SpMakeSignature:Entering   ContextHandle 0x%lx\n", ContextHandle ));
    UNREFERENCED_PARAMETER(fQOP);


    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpMakeSignature: Could not find ContextHandle\n" ));
        goto CleanUp;
    }

    UserContextPrint(pContext);

    // Check to see if Integrity is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;
    if ((pContext->typeDigest == SASL_CLIENT) ||
        (pContext->typeDigest == SASL_SERVER))
    {
        typeDigestMode = DIGESTMODE_SASL;
    }
    else
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }

    if (typeDigestMode == DIGESTMODE_HTTP)
    {
        DebugLog((DEB_TRACE, "SpMakeSignature: HTTP SignMessage selected\n"));
        Status = DigestUserHTTPHelper(
                            pContext,
                            eSign,
                            pMessage,
                            MessageSeqNo
                            );
    }
    else
    {
        if ((bServer && !(pContext->ContextReq & ASC_REQ_INTEGRITY)) ||
            (!bServer && !(pContext->ContextReq & ISC_REQ_INTEGRITY)) )
        {
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpMakeSignature: Did not negotiate INTEGRITY\n" ));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE, "SpMakeSignature: SASL SignMessage selected\n"));
        Status = DigestUserSignHelper(
                            pContext,
                            pMessage,
                            MessageSeqNo
                            );
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpMakeSignature: DigestUserHTTP/SASLSignHelper returns %lx\n", Status ));
        goto CleanUp;
    }

CleanUp:

    if (pContext != NULL)
    {
        SubStatus = UserCtxtHandlerRelease(pContext);

        // Don't destroy previous status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }
    
    DebugLog((DEB_TRACE_FUNC, "SpMakeSignature:Leaving   status 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating the Digest Access
//              for data bufferswith the current Security Context state.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Unused ULONG
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This routine should be called AFTER you have a valid security context
//      from (usually) acceptsecuritycontext.  The usermode context has a nonce
//      count that is automatically incremented for each successful verify signature
//      function call.  Therefore, calling this functio with the same noncecount
//      will return a failed status message.
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
SpVerifySignature(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;
    BOOL    bServer = FALSE;
    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;   // Are we in SASL or HTTP mode

    DebugLog((DEB_TRACE_FUNC, "SpVerifySignature:Entering   ContextHandle 0x%lx\n", ContextHandle ));

    // Reset output flags
    if (pfQOP)
    {
        *pfQOP = 0;
    }

    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpVerifySignature: Could not find ContextHandle\n" ));
        goto CleanUp;
    }

    UserContextPrint(pContext);

    // Check to see if Integrity is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;
    if ((pContext->typeDigest == SASL_CLIENT) ||
        (pContext->typeDigest == SASL_SERVER))
    {
        typeDigestMode = DIGESTMODE_SASL;
    }
    else
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }

    if (typeDigestMode == DIGESTMODE_HTTP)
    {
        DebugLog((DEB_TRACE, "SpVerifySignature: HTTP VerifyMessage selected\n"));
        Status = DigestUserHTTPHelper(
                            pContext,
                            eVerify,
                            pMessage,
                            MessageSeqNo
                            );
    }
    else
    {
        if ((bServer && !(pContext->ContextReq & ASC_REQ_INTEGRITY)) ||
            (!bServer && !(pContext->ContextReq & ISC_REQ_INTEGRITY)) )
        {
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpVerifySignature: Did not negotiate INTEGRITY\n" ));
            goto CleanUp;
        }
        else
        {
            DebugLog((DEB_TRACE, "SpVerifySignature: SASL VerifyMessage selected\n"));
            Status = DigestUserVerifyHelper(
                                pContext,
                                pMessage,
                                MessageSeqNo
                                );
        }
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpVerifySignature: DigestUserHTTP/SASLSignHelper returns %lx\n", Status ));
        goto CleanUp;
    }

CleanUp:

    if (pContext != NULL)
    {
        SubStatus = UserCtxtHandlerRelease(pContext);

        // Don't destroy previous status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }
    
    DebugLog((DEB_TRACE_FUNC, "SpVerifySignature:Leaving   status 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpSealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpSealMessage(
    IN ULONG_PTR ContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;
    BOOL     bServer = FALSE;

    DebugLog((DEB_TRACE_FUNC, "SpSealMessage:Entering   ContextHandle 0x%lx\n", ContextHandle ));
    UNREFERENCED_PARAMETER(fQOP);


    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpSealMessage: Could not find ContextHandle\n" ));
        goto CleanUp;
    }

    UserContextPrint(pContext);

    // Check to see if Confidentiality is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;
    if ((bServer && !(pContext->ContextReq & ASC_RET_CONFIDENTIALITY)) ||
        (!bServer && !(pContext->ContextReq & ISC_RET_CONFIDENTIALITY)) )
    {
        // Since CONFIDENTIALITY not negoiated - check if integrity selected
        if ((bServer && (pContext->ContextReq & ASC_RET_INTEGRITY)) ||
            (!bServer && (pContext->ContextReq & ISC_RET_INTEGRITY)) )
        {
            DebugLog((DEB_TRACE, "SpSealMessage: No Confidentiality selected - use Integrity ONLY\n"));
            // Just call the Sign routine only
            Status = DigestUserSignHelper(
                                pContext,
                                pMessage,
                                MessageSeqNo
                                );
        }
        else
        {
            DebugLog((DEB_ERROR, "SpSealMessage: Neither Confidentiality  nor Integrity selected\n"));
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpSealMessage: Did not negotiate CONFIDENTIALITY\n" ));
            goto CleanUp;
        }
    }
    else
    {
        // Use SignHelper for both SASL  - HTTP not speced
        Status = DigestUserSealHelper(
                            pContext,
                            pMessage,
                            MessageSeqNo
                            );
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpSealMessage: DigestUserSASLHelper returns %lx\n", Status ));
        goto CleanUp;
    }

CleanUp:

    if (pContext != NULL)
    {
        SubStatus = UserCtxtHandlerRelease(pContext);

        // Don't destroy previous status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }
    
    DebugLog((DEB_TRACE_FUNC, "SpSealMessage:Leaving   status 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpUnsealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleUnsealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpUnsealMessage(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;
    BOOL  bServer;    // acting as the server ?

    DebugLog((DEB_TRACE_FUNC, "SpUnsealMessage:Entering   ContextHandle 0x%lx\n", ContextHandle ));

    // Reset output flags
    if (pfQOP)
    {
        *pfQOP = 0;
    }


    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpUnsealMessage: Could not find ContextHandle\n" ));
        goto CleanUp;
    }

    UserContextPrint(pContext);

    // Check to see if Confidentiality is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;
    if ((bServer && !(pContext->ContextReq & ASC_RET_CONFIDENTIALITY)) ||
        (!bServer && !(pContext->ContextReq & ISC_RET_CONFIDENTIALITY)) )
    {
        if ((bServer && (pContext->ContextReq & ASC_RET_INTEGRITY)) ||
            (!bServer && (pContext->ContextReq & ISC_RET_INTEGRITY)) )
        {
            DebugLog((DEB_TRACE, "SpUnsealMessage: No Confidentiality selected - use Integrity ONLY\n"));
            Status = DigestUserVerifyHelper(
                                pContext,
                                pMessage,
                                MessageSeqNo
                                );

            // signal QOP was only for integrity
            if (pfQOP)
            {
                *pfQOP = SIGN_ONLY;
            }
        }
        else
        {
            DebugLog((DEB_ERROR, "SpUnsealMessage: Neither Confidentiality  nor Integrity selected\n"));
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpUnsealMessage: Did not negotiate CONFIDENTIALITY\n" ));
            goto CleanUp;
        }
    }
    else
    {
        Status = DigestUserUnsealHelper(
                            pContext,
                            pMessage,
                            MessageSeqNo
                            );
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpUnsealMessage: DigestUserSASLHelper returns %lx\n", Status ));
        goto CleanUp;
    }

CleanUp:

    if (pContext != NULL)
    {
        SubStatus = UserCtxtHandlerRelease(pContext);

        // Don't destroy previous status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }
    
    DebugLog((DEB_TRACE_FUNC, "SpUnsealMessage:Leaving   status 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes: Used in ImpersonateSecurityContext SSPI Call
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpGetContextToken(
    IN ULONG_PTR ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpGetContextToken: Entering   ContextHandle 0x%lx\n", ContextHandle ));

    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;

    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpGetContextToken: UserCtxtHandlerHandleToContext error 0x%x\n", Status));
    }

    DebugLog((DEB_TRACE, "SpGetContextToken:       Client ImpersonationToken  0x%lx\n", pContext->ClientTokenHandle ));


    if (pContext && pContext->ClientTokenHandle)
    {
        *ImpersonationToken = pContext->ClientTokenHandle;
        goto CleanUp;
    }

    Status = STATUS_INVALID_HANDLE;
    DebugLog((DEB_ERROR, "SpGetContextToken: no token handle\n" ));

CleanUp:

    if (pContext != NULL)
    {
        Status = UserCtxtHandlerRelease(pContext);
    }

    DebugLog((DEB_TRACE_FUNC, "SpGetContextToken: Leaving  Status 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//              This API allows a customer of the security
//              services to determine certain attributes of
//              the context.  These are: sizes, names, and lifespan.
//
//  Effects:
//
//  Arguments:
//
//    ContextHandle - Handle to the context to query.
//
//    Attribute - Attribute to query.
//
//
//    Buffer - Buffer to copy the data into.  The buffer must
//             be large enough to fit the queried attribute.
//
//
//  Requires:
//
//  Returns:
//
//        STATUS_SUCCESS - Call completed successfully
//
//        STATUS_INVALID_HANDLE -- Credential/Context Handle is invalid
//        STATUS_NOT_SUPPORTED -- Function code is not supported
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpQueryContextAttributes(
    IN ULONG_PTR ContextHandle,
    IN ULONG Attribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;

    DebugLog((DEB_TRACE_FUNC, "SpQueryContextAttributes: Entering ContextHandle 0x%lx\n", ContextHandle ));

    PSecPkgContext_Sizes ContextSizes = NULL;
    PSecPkgContext_Flags ContextFlags = NULL;
    PSecPkgContext_DceInfo ContextDceInfo = NULL;
    PSecPkgContext_Names ContextNames = NULL;
    PSecPkgContext_PackageInfo PackageInfo = NULL;
    PSecPkgContext_NegotiationInfo NegInfo = NULL;
    PSecPkgContext_PasswordExpiry PasswordExpires = NULL;
    PSecPkgContext_KeyInfo KeyInfo = NULL;
    PSecPkgContext_AccessToken AccessToken = NULL;
    PSecPkgContext_StreamSizes StreamSizes = NULL;

    ULONG PackageInfoSize = 0;
    BOOL    bServer = FALSE;
    LPWSTR pszEncryptAlgorithmName = NULL;
    LPWSTR pszSignatureAlgorithmName = NULL;
    DWORD dwBytes = 0;
    ULONG ulMaxMessage = 0;

    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;   // Are we in SASL or HTTP mode


    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpQueryContextAttributes: HandleToContext error 0x%x\n", Status));
        Status = STATUS_INVALID_HANDLE;
        goto CleanUp;
    }


    // Check to see if Integrity is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    if ((pContext->typeDigest == SASL_CLIENT) ||
        (pContext->typeDigest == SASL_SERVER))
    {
        typeDigestMode = DIGESTMODE_SASL;
    }
    else
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }

    //
    // Handle each of the various queried attributes
    //

    DebugLog((DEB_TRACE, "SpQueryContextAttributes : 0x%lx\n", Attribute ));
    switch ( Attribute) {
    case SECPKG_ATTR_SIZES:

        ContextSizes = (PSecPkgContext_Sizes) Buffer;
        ZeroMemory(ContextSizes, sizeof(SecPkgContext_Sizes));
        ContextSizes->cbMaxToken = NTDIGEST_SP_MAX_TOKEN_SIZE;
        if (typeDigestMode == DIGESTMODE_HTTP)
        {      // HTTP has signature the same as token in Authentication Header info
            ContextSizes->cbMaxSignature = NTDIGEST_SP_MAX_TOKEN_SIZE;
        }
        else
        {    // SASL has specialized signature block
            ContextSizes->cbMaxSignature = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        if ((pContext->typeCipher == CIPHER_3DES) || 
            (pContext->typeCipher == CIPHER_DES))
        {
            ContextSizes->cbBlockSize = DES_BLOCKSIZE;
            ContextSizes->cbSecurityTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        else if ((pContext->typeCipher == CIPHER_RC4) || 
                 (pContext->typeCipher == CIPHER_RC4_40) ||
                 (pContext->typeCipher == CIPHER_RC4_56))
        {
            ContextSizes->cbBlockSize = RC4_BLOCKSIZE;
            ContextSizes->cbSecurityTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        else
        {
            ContextSizes->cbBlockSize = 0;
            if (typeDigestMode == DIGESTMODE_HTTP)
            {      // HTTP has signature the same as token in Authentication Header info
                ContextSizes->cbSecurityTrailer = 0;
            }
            else
            {    // SASL has specialized signature block
                ContextSizes->cbSecurityTrailer = MAC_BLOCK_SIZE + MAX_PADDING;   // handle Auth-int case
            }
        }
        break;
    
    case SECPKG_ATTR_DCE_INFO:

        ContextDceInfo = (PSecPkgContext_DceInfo) Buffer;
        ZeroMemory(ContextDceInfo, sizeof(SecPkgContext_DceInfo));
        ContextDceInfo->AuthzSvc = 0;

        break;

    case SECPKG_ATTR_NAMES:

        ContextNames = (PSecPkgContext_Names) Buffer;
        ZeroMemory(ContextNames, sizeof(SecPkgContext_Names));

        if (pContext->ustrAccountName.Length && pContext->ustrAccountName.Buffer)
        {
            dwBytes = pContext->ustrAccountName.Length + sizeof(WCHAR);
            ContextNames->sUserName = (LPWSTR)g_UserFunctions->AllocateHeap(dwBytes);
            if (ContextNames->sUserName)
            {
                ZeroMemory(ContextNames->sUserName, dwBytes);
                memcpy(ContextNames->sUserName, pContext->ustrAccountName.Buffer, pContext->ustrAccountName.Length);
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        break;
    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        if ((Attribute == SECPKG_ATTR_NEGOTIATION_INFO) && (g_fParameter_Negotiate == FALSE))
        {
            Status = STATUS_NOT_SUPPORTED;
            goto CleanUp;
        }

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;
        ZeroMemory(PackageInfo, sizeof(SecPkgContext_PackageInfo));
        PackageInfoSize = sizeof(SecPkgInfoW) + sizeof(WDIGEST_SP_NAME) + sizeof(NTDIGEST_SP_COMMENT);
        PackageInfo->PackageInfo = (PSecPkgInfoW) g_UserFunctions->AllocateHeap(PackageInfoSize);
        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto CleanUp;
        }
        PackageInfo->PackageInfo->Name = (LPWSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPWSTR) ((((PBYTE) PackageInfo->PackageInfo->Name)) + sizeof(WDIGEST_SP_NAME));
        wcscpy(
            PackageInfo->PackageInfo->Name,
            WDIGEST_SP_NAME
            );

        wcscpy(
            PackageInfo->PackageInfo->Comment,
            NTDIGEST_SP_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = RPC_C_AUTHN_DIGEST;
        PackageInfo->PackageInfo->fCapabilities = NTDIGEST_SP_CAPS;
        PackageInfo->PackageInfo->cbMaxToken    = NTDIGEST_SP_MAX_TOKEN_SIZE;

        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            NegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
        }

        break;

    case SECPKG_ATTR_PASSWORD_EXPIRY:
        PasswordExpires = (PSecPkgContext_PasswordExpiry) Buffer;
        if (pContext->Expires.QuadPart != 0)
        {
            PasswordExpires->tsPasswordExpires = pContext->Expires;
        }
        else
            Status = STATUS_NOT_SUPPORTED;
        break;

    case SECPKG_ATTR_KEY_INFO:
        KeyInfo = (PSecPkgContext_KeyInfo) Buffer;
        ZeroMemory(KeyInfo, sizeof(SecPkgContext_KeyInfo));
        if (typeDigestMode == DIGESTMODE_HTTP)
        {
            // HTTP mode
            KeyInfo->SignatureAlgorithm = CALG_MD5;
        }
        else
        {
            // SASL mode
            KeyInfo->KeySize = 128;       // All modes use a 128 bit key - may have less entropy though (i.e. rc4-XX)
            KeyInfo->SignatureAlgorithm = CALG_HMAC;
            pszSignatureAlgorithmName = WSTR_CIPHER_HMAC_MD5;
            switch (pContext->typeCipher)
            {
                case CIPHER_RC4:
                case CIPHER_RC4_40:
                case CIPHER_RC4_56:
                    KeyInfo->KeySize = 16 * 8;    // All modes use a 128 bit key - may have less entropy though (i.e. rc4-XX)
                    KeyInfo->SignatureAlgorithm = CALG_RC4;
                    pszEncryptAlgorithmName = WSTR_CIPHER_RC4;
                    break;
                case CIPHER_DES:
                    KeyInfo->KeySize = 7 * 8;
                    KeyInfo->SignatureAlgorithm = CALG_DES;
                    pszEncryptAlgorithmName = WSTR_CIPHER_DES;
                    break;
                case CIPHER_3DES:
                    KeyInfo->KeySize = 14 * 8;
                    KeyInfo->SignatureAlgorithm = CALG_3DES_112;
                    pszEncryptAlgorithmName = WSTR_CIPHER_3DES;
                    break;
            }
            if (pszEncryptAlgorithmName)
            {
                KeyInfo->sEncryptAlgorithmName = (LPWSTR)
                    g_UserFunctions->AllocateHeap(sizeof(WCHAR) * (wcslen(pszEncryptAlgorithmName) + 1));
                if (KeyInfo->sEncryptAlgorithmName != NULL)
                {
                    wcscpy(
                        KeyInfo->sEncryptAlgorithmName,
                        pszEncryptAlgorithmName
                        );
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            if (pszSignatureAlgorithmName)
            {
                KeyInfo->sSignatureAlgorithmName = (LPWSTR)
                    g_UserFunctions->AllocateHeap(sizeof(WCHAR) * (wcslen(pszSignatureAlgorithmName) + 1));
                if (KeyInfo->sSignatureAlgorithmName != NULL)
                {
                    wcscpy(
                        KeyInfo->sSignatureAlgorithmName,
                        pszSignatureAlgorithmName
                        );
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        break;
    case SECPKG_ATTR_STREAM_SIZES:
        StreamSizes = (PSecPkgContext_StreamSizes) Buffer;
        ZeroMemory(StreamSizes, sizeof(SecPkgContext_StreamSizes));

        if (typeDigestMode == DIGESTMODE_HTTP)
        { 
        }
        else
        {    // SASL
            ulMaxMessage = pContext->ulRecvMaxBuf;
            if (pContext->ulSendMaxBuf < ulMaxMessage)
            {
                ulMaxMessage = pContext->ulSendMaxBuf;
            }
            StreamSizes->cbMaximumMessage = ulMaxMessage - (MAC_BLOCK_SIZE + MAX_PADDING);
        }

        if ((pContext->typeCipher == CIPHER_3DES) || 
            (pContext->typeCipher == CIPHER_DES))
        {
            StreamSizes->cbBlockSize = DES_BLOCKSIZE;
            StreamSizes->cbTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        else if ((pContext->typeCipher == CIPHER_RC4) || 
                 (pContext->typeCipher == CIPHER_RC4_40) ||
                 (pContext->typeCipher == CIPHER_RC4_56))
        {
            StreamSizes->cbBlockSize = RC4_BLOCKSIZE;
            StreamSizes->cbTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        break;
    case SECPKG_ATTR_ACCESS_TOKEN:
        AccessToken = (PSecPkgContext_AccessToken) Buffer;
        //
        // ClientTokenHandle can be NULL, for instance:
        // 1. client side context.
        // 2. incomplete server context.
        //      Token is not duped - caller must not CloseHandle
        AccessToken->AccessToken = (void*)pContext->ClientTokenHandle;
        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }


CleanUp:

    if (!NT_SUCCESS(Status))
    {
        switch (Attribute) {

        case SECPKG_ATTR_NAMES:

            if (ContextNames != NULL && ContextNames->sUserName )
            {
                g_UserFunctions->FreeHeap(ContextNames->sUserName);
                ContextNames->sUserName = NULL;
            }
            break;

        case SECPKG_ATTR_DCE_INFO:

            if (ContextDceInfo != NULL && ContextDceInfo->pPac)
            {
                g_UserFunctions->FreeHeap(ContextDceInfo->pPac);
                ContextDceInfo->pPac = NULL;
            }
            break;

        case SECPKG_ATTR_KEY_INFO:
            if (KeyInfo != NULL && KeyInfo->sEncryptAlgorithmName)
            {
                g_UserFunctions->FreeHeap(KeyInfo->sEncryptAlgorithmName);
                KeyInfo->sEncryptAlgorithmName = NULL;
            }
            if (KeyInfo != NULL && KeyInfo->sSignatureAlgorithmName)
            {
                g_UserFunctions->FreeHeap(KeyInfo->sSignatureAlgorithmName);
                KeyInfo->sSignatureAlgorithmName = NULL;
            }
            break;
        }
    }

    if (pContext != NULL)
    {
        SubStatus = UserCtxtHandlerRelease(pContext);
    }

    DebugLog((DEB_TRACE_FUNC, "SpQueryContextAttributes: Leaving ContextHandle 0x%lx\n", ContextHandle ));
    return(Status);
    
}



//+-------------------------------------------------------------------------
//
//  Function:   SpCompleteAuthToken
//
//  Synopsis:   Completes a context  - used to perform user mode verification of
//          challenge response for non-persistent connections re-established via ASC
//          call.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpCompleteAuthToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulQOP = 0;

    DebugLog((DEB_TRACE_FUNC, "SpCompleteAuthToken: Entering    ContextHandle 0x%lx\n", ContextHandle ));

    Status = SpVerifySignature(ContextHandle, InputBuffer, 0, &ulQOP);

    DebugLog((DEB_TRACE_FUNC, "SpCompleteAuthToken: Leaving    ContextHandle 0x%lx    Status = 0x%x\n",
               ContextHandle, Status));

    return(Status);
}


NTSTATUS NTAPI
SpFormatCredentials(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    )
{
    UNREFERENCED_PARAMETER (Credentials);
    UNREFERENCED_PARAMETER (FormattedCredentials);
    DebugLog((DEB_TRACE_FUNC, "SpFormatCredentials: Entering/Leaving\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

NTSTATUS NTAPI
SpMarshallSupplementalCreds(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds
    )
{
    UNREFERENCED_PARAMETER (CredentialSize);
    UNREFERENCED_PARAMETER (Credentials);
    UNREFERENCED_PARAMETER (MarshalledCredSize);
    UNREFERENCED_PARAMETER (MarshalledCreds);
    DebugLog((DEB_TRACE_FUNC, "SpMarshallSupplementalCreds: Entering/Leaving\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Function:   NtDigestMakePackedContext
//
//  Synopsis:   Maps a context to the caller's address space
//
//  Effects:
//
//  Arguments:  Context - The context to map
//              MappedContext - Set to TRUE on success
//              ContextData - Receives a buffer in the caller's address space
//                      with the mapped context.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NtDigestMakePackedContext(
    IN PDIGEST_USERCONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData,
    IN ULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT PackedContext = NULL;
    ULONG ContextSize = 0, ContextNameSize = 0;

    DebugLog((DEB_TRACE_FUNC, "NtDigestMakePackedContext: Entering/Leaving\n"));


    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Function:   SpExportSecurityContext
//
//  Synopsis:   Exports a security context to another process
//
//  Effects:    Allocates memory for output
//
//  Arguments:  ContextHandle - handle to context to export
//              Flags - Flags concerning duplication. Allowable flags:
//                      SECPKG_CONTEXT_EXPORT_DELETE_OLD - causes old context
//                              to be deleted.
//              PackedContext - Receives serialized context to be freed with
//                      FreeContextBuffer
//              TokenHandle - Optionally receives handle to context's token.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SpExportSecurityContext(
    IN ULONG_PTR ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    OUT PHANDLE TokenHandle
    )
{
    PDIGEST_USERCONTEXT Context = NULL, pvContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    ULONG ContextSize = 0;
    BOOLEAN MappedContext = FALSE;

    DebugLog((DEB_TRACE_FUNC, "SpExportSecurityContext:Entering/Leaving     ContextHandle 0x%x\n", ContextHandle ));

    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+-------------------------------------------------------------------------
//
//  Function:   NtDigestCreateUserModeContext
//
//  Synopsis:   Creates a user-mode context to support impersonation and
//              message integrity and privacy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NtDigestCreateUserModeContext(
    IN ULONG_PTR ContextHandle,
    IN HANDLE Token,
    IN PSecBuffer MarshalledContext,
    OUT PDIGEST_USERCONTEXT * NewContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "NtDigestCreateUserModeContext: Entering/Leaving     ContextHandle 0x%x\n", ContextHandle ));

    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpImportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
SpImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN HANDLE Token,
    OUT PULONG_PTR ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT Context = NULL;

    DebugLog((DEB_TRACE_FUNC, "SpImportSecurityContext: Entering/Leaving   ContextHandle 0x%x\n", ContextHandle));


    return(SEC_E_UNSUPPORTED_FUNCTION);
}



/*++

RoutineDescription:

    Gets the TOKEN_USER from an open token

Arguments:

    Token - Handle to a token open for TOKEN_QUERY access

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to complete the
        function.

    Errors from NtQueryInformationToken.

--*/

NTSTATUS
SspGetTokenUser(
    HANDLE Token,
    PTOKEN_USER * pTokenUser
    )
{
    PTOKEN_USER LocalTokenUser = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG TokenUserSize = 0;

    DebugLog((DEB_TRACE_FUNC, "SspGetTokenUser:  Entering  Token 0x%x    pTokenUser 0x%x\n", Token, pTokenUser));

    //
    // Query the token user.  First pass in NULL to get back the
    // required size.
    //

    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                NULL,
                0,
                &TokenUserSize
                );

    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        ASSERT(Status != STATUS_SUCCESS);
        DebugLog((DEB_ERROR, "SspGetTokenUser: NtQueryInformationToken (1st call) returns 0x%lx for Token 0x%x\n", Status, Token ));
        goto CleanUp;
    }

    //
    // Now allocate the required ammount of memory and try again.
    //

    LocalTokenUser = (PTOKEN_USER) DigestAllocateMemory(TokenUserSize);
    if (LocalTokenUser == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanUp;
    }
    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                LocalTokenUser,
                TokenUserSize,
                &TokenUserSize
                );

    if (NT_SUCCESS(Status))
    {
        *pTokenUser = LocalTokenUser;
    }
    else
    {
        DigestFreeMemory(LocalTokenUser);
        DebugLog((DEB_ERROR, "SspGetTokenUser: NtQueryInformationToken (2nd call) returns 0x%lx for Token 0x%x\n", Status, Token ));
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SspGetTokenUser:  Leaving  Token 0x%x with Status 0x%x\n", Token, Status));
    return(Status);
}



/*++

RoutineDescription:

    Create a local context for a real context
    Don't link it to out list of local contexts.
    Called inside LSA to prep packed Context buffer to send to UserMode addr space

Arguments:
   pLsaContext - pointer to a Context in LSA to map over to User space
   pDigest - pointer to digest auth parameters - may be NULL and use Context instead
   ContextData - packed Context information to send to usermode process

Return Value:

--*/
NTSTATUS
SspMapDigestContext(
    IN PDIGEST_CONTEXT   pLsaContext,           // LSA Context
    IN PDIGEST_PARAMETER pDigest,
    OUT PSecBuffer  ContextData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_PACKED_USERCONTEXT pPackedUserCtxt = NULL;      // Return buffer to on good auth to UserMode addr space
    USHORT cbLenNeeded = 0;
    PUCHAR  pucLoc = NULL;
    HANDLE  hTemp = NULL;
    int iAuth = 0;

    DebugLog((DEB_TRACE_FUNC, "SspMapContext: Entering  for LSA context %lx\n", pLsaContext));
    ASSERT(ContextData);
    ASSERT(pLsaContext);

    if (!pLsaContext)
    {
        Status = STATUS_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SspMapContext: pLsaContext invalid\n"));
        goto CleanUp;
    }

    // Copy over only selected fields
    cbLenNeeded = sizeof(DIGEST_PACKED_USERCONTEXT);
    if (pDigest)
    {
        cbLenNeeded += pDigest->refstrParam[MD5_AUTH_USERNAME].Length;
        cbLenNeeded += pDigest->refstrParam[MD5_AUTH_REALM].Length;
        cbLenNeeded += pDigest->refstrParam[MD5_AUTH_NONCE].Length;
        cbLenNeeded += pDigest->refstrParam[MD5_AUTH_CNONCE].Length;
        cbLenNeeded += pDigest->refstrParam[MD5_AUTH_ALGORITHM].Length;
        cbLenNeeded += pDigest->refstrParam[MD5_AUTH_QOP].Length;
        cbLenNeeded += pDigest->refstrParam[MD5_AUTH_AUTHZID].Length;
        cbLenNeeded += pDigest->refstrParam[MD5_AUTH_OPAQUE].Length;
    }
    else
    {
        cbLenNeeded += pLsaContext->strDirective[MD5_AUTH_USERNAME].Length;
        cbLenNeeded += pLsaContext->strDirective[MD5_AUTH_REALM].Length;
        cbLenNeeded += pLsaContext->strDirective[MD5_AUTH_NONCE].Length;
        cbLenNeeded += pLsaContext->strDirective[MD5_AUTH_CNONCE].Length;
        cbLenNeeded += pLsaContext->strDirective[MD5_AUTH_ALGORITHM].Length;
        cbLenNeeded += pLsaContext->strDirective[MD5_AUTH_QOP].Length;
        cbLenNeeded += pLsaContext->strDirective[MD5_AUTH_AUTHZID].Length;
        cbLenNeeded += pLsaContext->strDirective[MD5_AUTH_OPAQUE].Length;
    }
    cbLenNeeded += pLsaContext->strSessionKey.Length;
    cbLenNeeded += pLsaContext->ustrAccountName.Length;

    DebugLog((DEB_TRACE, "SspMapContext:  Packed Digest will be %d bytes \n", cbLenNeeded));

    //   DigestAllocateMemory will use g_LsaFunctions->AllocateLsaHeap()
    pPackedUserCtxt = (PDIGEST_PACKED_USERCONTEXT)g_LsaFunctions->AllocateLsaHeap(cbLenNeeded);
    if (!pPackedUserCtxt)
    {
        // Failed to allocate memory to send info to usermode space
        ContextData->cbBuffer = 0;
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "SspMapContext: out of memory on usermode contextdata\n"));
        goto CleanUp;
    }

       // Now initialize the UserMode Context struct to return
    ZeroMemory(pPackedUserCtxt, cbLenNeeded);
    pPackedUserCtxt->Expires = pLsaContext->PasswordExpires;
    pPackedUserCtxt->typeAlgorithm = (ULONG)pLsaContext->typeAlgorithm;
    pPackedUserCtxt->typeCipher = (ULONG)pLsaContext->typeCipher;
    pPackedUserCtxt->typeCharset = (ULONG)pLsaContext->typeCharset;
    pPackedUserCtxt->typeDigest = (ULONG)pLsaContext->typeDigest;
    pPackedUserCtxt->typeQOP = (ULONG)pLsaContext->typeQOP;
    pPackedUserCtxt->ulSendMaxBuf = pLsaContext->ulSendMaxBuf;
    pPackedUserCtxt->ulRecvMaxBuf = pLsaContext->ulRecvMaxBuf;
    pPackedUserCtxt->ContextReq = (ULONG)pLsaContext->ContextReq;
    pPackedUserCtxt->CredentialUseFlags = (ULONG)pLsaContext->CredentialUseFlags;

    // Now mark that there is data for these items  ONLY non-zero items will be written out!!!
    if (pDigest)
    {
        pPackedUserCtxt->uDigestLen[MD5_AUTH_USERNAME] = (ULONG)pDigest->refstrParam[MD5_AUTH_USERNAME].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_REALM] = (ULONG)pDigest->refstrParam[MD5_AUTH_REALM].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_NONCE] = (ULONG)pDigest->refstrParam[MD5_AUTH_NONCE].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_CNONCE] = (ULONG)pDigest->refstrParam[MD5_AUTH_CNONCE].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_ALGORITHM] = (ULONG)pDigest->refstrParam[MD5_AUTH_ALGORITHM].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_QOP] = (ULONG)pDigest->refstrParam[MD5_AUTH_QOP].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_AUTHZID] = (ULONG)pDigest->refstrParam[MD5_AUTH_AUTHZID].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_OPAQUE] = (ULONG)pDigest->refstrParam[MD5_AUTH_OPAQUE].Length;
    }
    else
    {
        pPackedUserCtxt->uDigestLen[MD5_AUTH_USERNAME] = (ULONG)pLsaContext->strDirective[MD5_AUTH_USERNAME].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_REALM] = (ULONG)pLsaContext->strDirective[MD5_AUTH_REALM].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_NONCE] = (ULONG)pLsaContext->strDirective[MD5_AUTH_NONCE].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_CNONCE] = (ULONG)pLsaContext->strDirective[MD5_AUTH_CNONCE].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_ALGORITHM] = (ULONG)pLsaContext->strDirective[MD5_AUTH_ALGORITHM].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_QOP] = (ULONG)pLsaContext->strDirective[MD5_AUTH_QOP].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_AUTHZID] = (ULONG)pLsaContext->strDirective[MD5_AUTH_AUTHZID].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_OPAQUE] = (ULONG)pLsaContext->strDirective[MD5_AUTH_OPAQUE].Length;
    }
    pPackedUserCtxt->uSessionKeyLen = (ULONG)pLsaContext->strSessionKey.Length;
    pPackedUserCtxt->uAccountNameLen = (ULONG)pLsaContext->ustrAccountName.Length;


    // dup token if it exists
    if (pLsaContext->TokenHandle != NULL)
    {
        Status = g_LsaFunctions->DuplicateHandle(
                           pLsaContext->TokenHandle,
                           &(hTemp));

        if (!NT_SUCCESS(Status))
        {
            if (pPackedUserCtxt)
            {
                DigestFreeMemory(pPackedUserCtxt);
            }
            ContextData->cbBuffer = 0;
            DebugLog((DEB_ERROR, "SspMapContext: DuplicateHandle returns 0x%lx\n", Status));
            goto CleanUp;
        }
        // Must pack the HANDLE into a fixed size structure for IA64 and i32 formats
        pPackedUserCtxt->ClientTokenHandle = (ULONG) ((ULONG_PTR)hTemp);
        DebugLog((DEB_TRACE, "SspMapContext: DuplicateHandle successful  ClientTokenHandle 0x%x\n", pPackedUserCtxt->ClientTokenHandle));
    }

    // Now copy over the string data elements
    pucLoc = &(pPackedUserCtxt->ucData);
    if (pDigest)
    {
        for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
        {
           if (pPackedUserCtxt->uDigestLen[iAuth])
           {
               memcpy(pucLoc, pDigest->refstrParam[iAuth].Buffer, pPackedUserCtxt->uDigestLen[iAuth]);
               pucLoc += pPackedUserCtxt->uDigestLen[iAuth];
           }
        }
    }
    else
    {
        for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
        {
           if (pPackedUserCtxt->uDigestLen[iAuth])
           {
               memcpy(pucLoc, pLsaContext->strDirective[iAuth].Buffer, pPackedUserCtxt->uDigestLen[iAuth]);
               pucLoc += pPackedUserCtxt->uDigestLen[iAuth];
           }
        }
    }

    if (pPackedUserCtxt->uSessionKeyLen)
    {
        memcpy(pucLoc, pLsaContext->strSessionKey.Buffer, pPackedUserCtxt->uSessionKeyLen);
        pucLoc += pPackedUserCtxt->uSessionKeyLen;
    }

    if (pPackedUserCtxt->uAccountNameLen)
    {
        memcpy(pucLoc, pLsaContext->ustrAccountName.Buffer, pPackedUserCtxt->uAccountNameLen);
        pucLoc += pPackedUserCtxt->uAccountNameLen;
    }

    ContextData->pvBuffer = pPackedUserCtxt;
    ContextData->cbBuffer = cbLenNeeded;
    ContextData->BufferType = SECBUFFER_TOKEN;


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SspMapContext: Leaving  LsaContext  %lx    Status 0x%x\n", pLsaContext, Status));
    return(Status);
}




//+--------------------------------------------------------------------
//
//  Function:   DigestUserHTTPHelper
//
//  Synopsis:   Process a SecBuffer with a given User Security Context
//              Used with HTTP for auth after initial ASC/ISC exchange
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
DigestUserHTTPHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN eSignSealOp Op,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;

    ULONG     ulSeqNo = 0;
    PSecBuffer pChalRspInputToken = NULL;
    PSecBuffer pMethodInputToken = NULL;
    PSecBuffer pURIInputToken = NULL;
    PSecBuffer pHEntityInputToken = NULL;
    PSecBuffer pFirstOutputToken = NULL;
    DIGEST_PARAMETER Digest;
    PDIGEST_CONTEXT pNewContext = NULL;            // keep pointer to release new context on error
    int iTemp = 0;
    int iAuth = 0;
    char *cptr = NULL;
    char  szNCOverride[2*NCNUM];             // Overrides the provided NC if non-zero using only NCNUM digits
    STRING strURI;
    UNICODE_STRING refustrURI;
    BOOL fDefChars = FALSE;

    ZeroMemory(&strURI, sizeof(strURI));
    ZeroMemory(&refustrURI, sizeof(refustrURI));

    DebugLog((DEB_TRACE_FUNC, "DigestUserHTTPHelper: Entering \n"));

    DigestInit(&Digest);

    if (pSecBuff->cBuffers < 1)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: Not enough input buffers 0x%x\n", Status));
        goto CleanUp;
    }
    pChalRspInputToken = &(pSecBuff->pBuffers[0]);
    if (!ContextIsTokenOK(pChalRspInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: ContextIsTokenOK (ChalRspInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // We have input in the SECBUFFER 0th location - parse it
    Status = DigestParser2(pChalRspInputToken, MD5_AUTH_NAMES, MD5_AUTH_LAST, &Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: DigestParser error 0x%x\n", Status));
        goto CleanUp;
    }

       // Now determine all of the other buffers

    DebugLog((DEB_TRACE, "DigestUserHTTPHelper: pContext->ContextReq 0x%lx \n", pContext->ContextReq));

    DebugLog((DEB_TRACE, "DigestUserHTTPHelper: HTTP SecBuffer Format\n"));
    // Retrieve the information from the SecBuffers & check proper formattting
    if (pSecBuff->cBuffers < 4)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: Not enough input buffers 0x%x\n", Status));
        goto CleanUp;
    }
    
    pMethodInputToken = &(pSecBuff->pBuffers[1]);
    if (!ContextIsTokenOK(pMethodInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {                           // Check to make sure that string is present
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: ContextIsTokenOK (MethodInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    pURIInputToken = &(pSecBuff->pBuffers[2]);
    if (!ContextIsTokenOK(pURIInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: ContextIsTokenOK (URIInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    pHEntityInputToken = &(pSecBuff->pBuffers[3]);
    if (!ContextIsTokenOK(pHEntityInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: ContextIsTokenOK (HEntityInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // Take care of the output buffer
    if (Op == eSign)
    {
        if (pSecBuff->cBuffers < 5)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: No Output Buffers %d\n", Status));
            goto CleanUp;
        }
        pFirstOutputToken = &(pSecBuff->pBuffers[4]);
        if (!ContextIsTokenOK(pFirstOutputToken, 0))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper, ContextIsTokenOK (FirstOutputToken) failed  0x%x\n", Status));
            goto CleanUp;
        }

        // Reset output buffer
        if (pFirstOutputToken && (pFirstOutputToken->pvBuffer) && (pFirstOutputToken->cbBuffer >= 1))
        {
            cptr = (char *)pFirstOutputToken->pvBuffer;
            *cptr = '\0';
        }

    }
    else
    {
        pFirstOutputToken = NULL;    // There is no output buffer
    }

    // Verify that there is a valid Method provided
    if (!pMethodInputToken->pvBuffer || !pMethodInputToken->cbBuffer ||
        (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: Method SecBuffer must have valid method string status 0x%x\n", Status));
        goto CleanUp;
    }

    iTemp = strlencounted((char *)pMethodInputToken->pvBuffer, pMethodInputToken->cbBuffer);
    if (!iTemp)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: Method SecBuffer must have valid method string status 0x%x\n", Status));
        goto CleanUp;
    }
    Digest.refstrParam[MD5_AUTH_METHOD].Length = (USHORT)iTemp;
    Digest.refstrParam[MD5_AUTH_METHOD].MaximumLength = (unsigned short)(pMethodInputToken->cbBuffer);
    Digest.refstrParam[MD5_AUTH_METHOD].Buffer = (char *)pMethodInputToken->pvBuffer;       // refernce memory - no alloc!!!!


    // Check to see if we have H(Entity) data to utilize
    if (pHEntityInputToken->cbBuffer)
    {
        // Verify that there is a valid Method provided
        if (!pHEntityInputToken->pvBuffer || (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: HEntity SecBuffer must have valid string status 0x%x\n", Status));
            goto CleanUp;
        }

        iTemp = strlencounted((char *)pHEntityInputToken->pvBuffer, pHEntityInputToken->cbBuffer);

        if ((iTemp != 0) && (iTemp != (MD5_HASH_BYTESIZE * 2)))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: HEntity SecBuffer must have valid MD5 Hash data 0x%x\n", Status));
            goto CleanUp;
        }

        if (iTemp)
        {
            Digest.refstrParam[MD5_AUTH_HENTITY].Length = (USHORT)iTemp;
            Digest.refstrParam[MD5_AUTH_HENTITY].MaximumLength = (unsigned short)(pHEntityInputToken->cbBuffer);
            Digest.refstrParam[MD5_AUTH_HENTITY].Buffer = (char *)pHEntityInputToken->pvBuffer;       // refernce memory - no alloc!!!!
        }
    }


    // Import the URI if it is a sign otherwise verify URI match if verify
    if (Op == eSign)
    {
        // Pull in the URI provided in SecBuffer
        if (!pURIInputToken || !pURIInputToken->cbBuffer || !pURIInputToken->pvBuffer)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: URI SecBuffer must have valid string 0x%x\n", Status));
            goto CleanUp;
        }


        iTemp = 0;

        if (PBUFFERTYPE(pURIInputToken) == SECBUFFER_PKG_PARAMS)
        {
            iTemp = strlencounted((char *)pURIInputToken->pvBuffer, pURIInputToken->cbBuffer);

            if (iTemp > 0)
            {
                Status = StringCharDuplicate(&strURI, (char *)pURIInputToken->pvBuffer, (USHORT)iTemp);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestUserHTTPHelper: StringCharDuplicate   error 0x%x\n", Status));
                    goto CleanUp;
                }
            }
        }
        else
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: URI buffer type invalid   error %d\n", Status));
            goto CleanUp;
        }

        StringReference(&(Digest.refstrParam[MD5_AUTH_URI]), &strURI);  // refernce memory - no alloc!!!!
    }

    // If we have a NonceCount in the MessageSequenceNumber then use that
    if (MessageSeqNo)
    {
        ulSeqNo = MessageSeqNo;
    }
    else
    {
        ulSeqNo = pContext->ulNC + 1;           // Else use the next sequence number
    }

    sprintf(szNCOverride, "%0.8x", ulSeqNo); // Buffer is twice as big as we need (for safety) so just clip out first 8 characters
    szNCOverride[NCNUM] = '\0';         // clip to 8 digits
    DebugLog((DEB_TRACE, "DigestUserHTTPHelper: Message Sequence NC is %s\n", szNCOverride));
    Digest.refstrParam[MD5_AUTH_NC].Length = (USHORT)NCNUM;
    Digest.refstrParam[MD5_AUTH_NC].MaximumLength = (unsigned short)(NCNUM+1);
    Digest.refstrParam[MD5_AUTH_NC].Buffer = (char *)szNCOverride;          // refernce memory - no alloc!!!!

    // Now link in the stored context values into the digest if this is a SignMessage
    // If there are values there from the input auth line then override them with context's value
    if (Op == eSign)
    {
        for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
        {
            if (pContext->strParam[iAuth].Length)
            {       // Link in only if passed into the user context from the LSA context
                Digest.refstrParam[iAuth].Length = pContext->strParam[iAuth].Length;
                Digest.refstrParam[iAuth].MaximumLength = pContext->strParam[iAuth].MaximumLength;
                Digest.refstrParam[iAuth].Buffer = pContext->strParam[iAuth].Buffer;          // reference memory - no alloc!!!!
            }
        }
    }
    DebugLog((DEB_TRACE, "DigestUserHTTPHelper: Digest inputs processing completed\n"));

    Status = DigestUserProcessParameters(pContext, &Digest, pFirstOutputToken);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: DigestUserProcessParameters     error 0x%x\n", Status));
        goto CleanUp;
    }

    // For testing if nonce is stale, but digest calc still verified
    if (Op == eVerify)
    {
        if (NT_SUCCESS(Status) && NonceIsExpired(&(Digest.refstrParam[MD5_AUTH_NONCE])))
        {
            Status = SEC_E_CONTEXT_EXPIRED;
            DebugLog((DEB_TRACE, "DigestUserHTTPHelper: NONCE is out of date. Flag stale return   Status 0x%x\n", Status));
        }
    }

    pContext->ulNC = ulSeqNo;                           // Everything verified so increment to next nonce count

CleanUp:

    DigestFree(&Digest);

    StringFree(&strURI);

    DebugLog((DEB_TRACE_FUNC, "DigestUserHTTPHelper: Leaving    Status 0x%x\n", Status));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestUserSignHelper
//
//  Synopsis:   Process a SecBuffer with a given User Security Context
//              Used with SASL section 2.3 RFC
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//                    
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
DigestUserSignHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;

    PDWORD    pdwSeqNum = NULL;             // points to the Sequence number to use
    PSecBuffer pSecBufToken = NULL;
    PSecBuffer pSecBufData = NULL;
    PSecBuffer pSecBufPad = NULL;

    PSecBuffer pSecBufHMAC = NULL;          // Points to the HMAC appended to the data block
    PSecBuffer pSecBufMsg = NULL;          // Points to the data section

    BOOL bServer = FALSE;
    SASL_MAC_BLOCK  MacBlock;
    DWORD dwSeqNumber = 0;
    STRING  strcSignKeyConst;     // pointer to a constant valued string

    ULONG Index = 0;
    

    DebugLog((DEB_TRACE_FUNC, "DigestUserSignHelper: Entering \n"));

    ZeroMemory(&MacBlock, sizeof(SASL_MAC_BLOCK));
    RtlInitString(&strcSignKeyConst, NULL);

    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    
    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < pSecBuff->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            pSecBufToken = &pSecBuff->pBuffers[Index];
        }
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_DATA)
        {
            pSecBufData = &pSecBuff->pBuffers[Index];
        }
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_PADDING)
        {
            pSecBufPad = &pSecBuff->pBuffers[Index];
        }
    }

    if ((!pSecBufPad) || (!pSecBufPad->cbBuffer))
    {   // If no SECBUFFER_PADDING, use SECBUFFER_TOKEN
        pSecBufHMAC = pSecBufToken;
    }
    else
    {
        pSecBufHMAC = pSecBufPad;
        if (pSecBufToken)
        {
            pSecBufToken->cbBuffer = 0;
        }
    }
    if (!ContextIsTokenOK(pSecBufHMAC, 0) || (pSecBufHMAC->cbBuffer < MAC_BLOCK_SIZE))
    {
        Status = SEC_E_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestUserSignHelper: ContextIsTokenOK (SignatureToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    if (!ContextIsTokenOK(pSecBufData, 0))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserSignHelper: ContextIsTokenOK (SecBufMsg) failed  0x%x\n", Status));
        goto CleanUp;
    }


    // Determine the sequence number & Constant Key Sring to utilize acting as the server
    if (bServer)
    {
        pdwSeqNum = &(pContext->dwSendSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_S2C_SIGN_KEY);
        DebugLog((DEB_TRACE, "DigestUserSignHelper: Signing in Server Mode (Message StoC)  SeqNum %d\n", *pdwSeqNum));
    }
    else
    {             // acting as the client
        pdwSeqNum = &(pContext->dwSendSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_C2S_SIGN_KEY);
        DebugLog((DEB_TRACE, "DigestUserSignHelper: Signing in Client Mode (Message CtoS)  SeqNum %d\n", *pdwSeqNum));
    }

    Status = CalculateSASLHMAC(pContext, TRUE, &strcSignKeyConst, *pdwSeqNum,
                               (PBYTE)pSecBufData->pvBuffer, pSecBufData->cbBuffer, &MacBlock);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestUserSignHelper: Error in CalculateSASLHMAC   status 0x%x\n", Status));
        goto CleanUp;
    }

        // Write the calculated MAC block out to the SecBuffer
    memcpy(pSecBufHMAC->pvBuffer, &MacBlock, MAC_BLOCK_SIZE);
    DebugLog((DEB_TRACE, "DigestUserSignHelper: Wrote out the calculated MAC Block.\n"));
    pSecBufHMAC->cbBuffer = MAC_BLOCK_SIZE;           // indicate number of bytes we used for padding and HMAC block

    // completed all tasks down to here.  Need to update the sequence number
    (*pdwSeqNum)++;
    DebugLog((DEB_TRACE, "DigestUserSignHelper: Updated SeqNum to %d\n", *pdwSeqNum));


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUserSignHelper: Leaving    Status 0x%x\n", Status));

    return(Status);
}




//+--------------------------------------------------------------------
//
//  Function:   DigestUserVerifyHelper
//
//  Synopsis:   Process a SecBuffer with a given User Security Context
//              Used with SASL section 2.3 RFC
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//                    
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
DigestUserVerifyHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;

    PDWORD    pdwSeqNum = NULL;             // points to the Sequence number to use
    PBYTE     pMsgHMAC  = NULL;             // Location of the HMAC in the message
    PSecBuffer pSecBufData = NULL;
    PSecBuffer pSecBufStream = NULL;

    PSecBuffer pSecBufHMAC = NULL;          // Points to the HMAC appended to the data block
    PSecBuffer pSecBufMsg = NULL;          // Points to the data section

    BOOL bServer = FALSE;
    SASL_MAC_BLOCK  MacBlock;
    SASL_MAC_BLOCK  TokenMacBlock;
    DWORD dwSeqNumber = 0;
    STRING  strcSignKeyConst;
    ULONG cbSecBufMsgIntegrity = 0;        // Number of bytes in message to calc HMAC on

    ULONG Index = 0;

#if DBG
    char szTemp[TEMPSIZE];
    ZeroMemory(szTemp, TEMPSIZE);
#endif
    

    DebugLog((DEB_TRACE_FUNC, "DigestUserVerifyHelper: Entering \n"));

    ZeroMemory(&MacBlock, sizeof(SASL_MAC_BLOCK));
    ZeroMemory(&TokenMacBlock, sizeof(SASL_MAC_BLOCK));
    RtlInitString(&strcSignKeyConst, NULL);

    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    
    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < pSecBuff->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_DATA)
        {
            pSecBufData = &pSecBuff->pBuffers[Index];
        }
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_STREAM)
        {
            pSecBufStream = &pSecBuff->pBuffers[Index];
        }
    }


    // Must be for decrypt/verify
    if ((!pSecBufStream) || (!pSecBufStream->cbBuffer))
    {   // If no SECBUFFER_STREAM, use SECBUFFER_DATA
        pSecBufMsg = pSecBufData;
    }
    else
    {
        pSecBufMsg = pSecBufStream;
    }

    if ((!ContextIsTokenOK(pSecBufMsg, 0)) || (pSecBufMsg->cbBuffer < MAC_BLOCK_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserVerifyHelper: ContextIsTokenOK (SecBufMsg) decrypt/verify failed  0x%x\n", Status));
        goto CleanUp;
    }
    
    // Strip off the MsgType and the Sequence Number
    cbSecBufMsgIntegrity = pSecBufMsg->cbBuffer - (MAC_BLOCK_SIZE);


    // Determine the sequence number to utilize acting as the server
    if (bServer)
    {
        pdwSeqNum = &(pContext->dwRecvSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_C2S_SIGN_KEY);
        DebugLog((DEB_TRACE, "DigestUserVerifyHelper: Verifying in Server Mode (Message CtoS)  SeqNum %d\n", *pdwSeqNum));
    }
    else
    {             // acting as the client
        pdwSeqNum = &(pContext->dwRecvSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_S2C_SIGN_KEY);
        DebugLog((DEB_TRACE, "DigestUserVerifyHelper: Verifying in Client Mode (Message StoC)  SeqNum %d\n", *pdwSeqNum));
    }



    Status = CalculateSASLHMAC(pContext, FALSE, &strcSignKeyConst, *pdwSeqNum,
                               (PBYTE)pSecBufMsg->pvBuffer, cbSecBufMsgIntegrity, &MacBlock);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestUserVerifyHelper: Error in CalculateSASLHMAC   status 0x%x\n", Status));
        goto CleanUp;
    }


    DebugLog((DEB_TRACE, "DigestUserVerifyHelper: Ready to compare MacBlocks\n"));

    // Check validity of MAC block ONLY do not write it out
    pMsgHMAC =  (PBYTE)pSecBufMsg->pvBuffer + cbSecBufMsgIntegrity;
    memcpy(&TokenMacBlock, pMsgHMAC, MAC_BLOCK_SIZE); 
    if (MacBlock.dwSeqNumber != TokenMacBlock.dwSeqNumber)
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        DebugLog((DEB_ERROR, "DigestUserVerifyHelper: SASL MAC blocks out of sequence. Failed verify.  Status 0x%x\n", Status));
#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&TokenMacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Token's HMAC-MD5 block %s\n", szTemp));
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&MacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: TComputed HMAC-MD5 block %s\n", szTemp));
#endif
        goto CleanUp;
    }
    if (memcmp(&MacBlock, &TokenMacBlock, MAC_BLOCK_SIZE))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        DebugLog((DEB_ERROR, "DigestUserVerifyHelper: SASL MAC blocks do not match. Failed verify.  Status 0x%x\n", Status));
#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&TokenMacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Token's HMAC-MD5 block %s\n", szTemp));
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&MacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: TComputed HMAC-MD5 block %s\n", szTemp));
#endif
        goto CleanUp;
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestUserVerifyHelper: SASL MAC blocks match!\n"));
    }


    // completed all tasks down to here.  Need to update the sequence number

    (*pdwSeqNum)++;

    // Update the Data information (without the attached HMAC info block
    if (pSecBufData)
    {
        pSecBufData->cbBuffer = pSecBufMsg->cbBuffer - MAC_BLOCK_SIZE;
        pSecBufData->pvBuffer = pSecBufMsg->pvBuffer;
    }
    DebugLog((DEB_TRACE, "DigestUserVerifyHelper: Updated SeqNum to %d\n", *pdwSeqNum));


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUserVerifyHelper: Leaving    Status 0x%x\n", Status));

    return(Status);

}



//+--------------------------------------------------------------------
//
//  Function:   DigestUserSealHelper
//
//  Synopsis:   Process a SecBuffer with a given User Security Context
//              Used with SASL section 2.3 RFC
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//                    
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
DigestUserSealHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;

    PDWORD    pdwSeqNum = NULL;             // points to the Sequence number to use
    PSecBuffer pSecBufToken = NULL;
    PSecBuffer pSecBufData = NULL;
    PSecBuffer pSecBufPad = NULL;

    PSecBuffer pSecBufHMAC = NULL;          // Points to the HMAC appended to the data block
    PSecBuffer pSecBufMsg = NULL;          // Points to the data section

    BOOL bServer = FALSE;
    SASL_MAC_BLOCK  MacBlock;
    DWORD dwSeqNumber = 0;
    STRING  strcSignKeyConst;
    STRING  strcSealKeyConst;
    PUCHAR  pbIV = NULL;

    BYTE bKcTempData[MD5_HASH_BYTESIZE];    // Message integrity keys RFC 2831 sec 2.3

    ULONG Index = 0;
    USHORT cbHA1n = 0;         // Number of bytes for Ha1 in Kcc/Kcs
    DWORD cbKey = 0;             // Number of bytes of Kcc/Kcs to use for the key
    DWORD cbKeyNoParity = 0;             // Number of bytes of Kcc/Kcs to use for the key with no parity
    DWORD cbTempKey = 0;
    ULONG cbBlockSize = RC4_BLOCKSIZE;    // Blocksize for the given cipher
    ULONG cbPrefixPadding = 0;   // number of bytes needed for padding out to blocksize
    ULONG cbBlocks = 0;
    PBYTE pHMACTemp = NULL;
    ALG_ID Algid = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestUserSealHelper: Entering \n"));

    ZeroMemory(&MacBlock, sizeof(SASL_MAC_BLOCK));
    RtlInitString(&strcSignKeyConst, NULL);
    RtlInitString(&strcSealKeyConst, NULL);

    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    
    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < pSecBuff->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            pSecBufToken = &pSecBuff->pBuffers[Index];
        }
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_DATA)
        {
            pSecBufData = &pSecBuff->pBuffers[Index];
        }
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_PADDING)
        {
            pSecBufPad = &pSecBuff->pBuffers[Index];
        }
    }

    if ((!pSecBufPad) || (!pSecBufPad->cbBuffer))
    {   // If no SECBUFFER_PADDING, use SECBUFFER_TOKEN
        pSecBufHMAC = pSecBufToken;
    }
    else
    {
        pSecBufHMAC = pSecBufPad;
        if (pSecBufToken)
        {
            pSecBufToken->cbBuffer = 0;
        }
    }
    if (!ContextIsTokenOK(pSecBufHMAC, 0) || (pSecBufHMAC->cbBuffer < (MAC_BLOCK_SIZE + MAX_PADDING)))
    {
        Status = SEC_E_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestUserSealHelper: ContextIsTokenOK (SignatureToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    if (!ContextIsTokenOK(pSecBufData, 0))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserSealHelper: ContextIsTokenOK (SecBufMsg) failed  0x%x\n", Status));
        goto CleanUp;
    }


    // Determine the sequence number & Constant Key Sring to utilize acting as the server
    if (bServer)
    {
        pdwSeqNum = &(pContext->dwSendSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_S2C_SIGN_KEY);
        RtlInitString(&strcSealKeyConst, SASL_S2C_SEAL_KEY);
        DebugLog((DEB_TRACE, "DigestUserSealHelper: Signing in Server Mode (Message StoC)  SeqNum %d\n", *pdwSeqNum));
    }
    else
    {             // acting as the client
        pdwSeqNum = &(pContext->dwSendSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_C2S_SIGN_KEY);
        RtlInitString(&strcSealKeyConst, SASL_C2S_SEAL_KEY);
        DebugLog((DEB_TRACE, "DigestUserSealHelper: Signing in Client Mode (Message CtoS)  SeqNum %d\n", *pdwSeqNum));
    }

    // Based on the Cypher selected - establish the byte count parameters - magic numbers from RFC

    if (pContext->typeCipher == CIPHER_RC4)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_RC4_40)
    {
        cbHA1n = 5;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_RC4_56)
    {
        cbHA1n = 7;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_DES)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 8;    // number of bytes to use from Kcc/Kcs
        cbKeyNoParity = 7;
        cbBlockSize = DES_BLOCKSIZE;  // DES uses a blocksize of 8
        Algid = CALG_DES;
    }
    else if (pContext->typeCipher == CIPHER_3DES)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        cbKeyNoParity = 14;
        cbBlockSize = DES_BLOCKSIZE;  // DES uses a blocksize of 8
        Algid = CALG_3DES_112;
    }
    else
    {
        Status = SEC_E_CRYPTO_SYSTEM_INVALID;
        DebugLog((DEB_ERROR, "DigestUserSealHelper: ContextIsTokenOK (SecBufMsg) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // If the cipher is not a stream cipher - the place prefix padding before SASL MAC
    //  Modified to include padding based on message datasize + the 10 byte HMAC
    if (cbBlockSize != 1)
    {
        cbBlocks =  (pSecBufData->cbBuffer + SASL_MAC_HMAC_SIZE) / cbBlockSize;         // integer divison
        cbPrefixPadding = cbBlockSize - ((pSecBufData->cbBuffer + SASL_MAC_HMAC_SIZE) - (cbBlockSize * cbBlocks));
        if (!cbPrefixPadding)
        {
            cbPrefixPadding = cbBlockSize;      // if padding is zero set it to the blocksize - i.e. always pad
        }
        DebugLog((DEB_TRACE, "DigestUserSealHelper: DataSize %lu  BlockSize %lu  Padding %lu\n",
                   pSecBufData->cbBuffer, cbBlockSize, cbPrefixPadding));
    }

    Status = CalculateSASLHMAC(pContext, TRUE, &strcSignKeyConst, *pdwSeqNum,
                               (PBYTE)pSecBufData->pvBuffer, pSecBufData->cbBuffer, &MacBlock);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestUserSealHelper: Error in CalculateSASLHMAC   status 0x%x\n", Status));
        goto CleanUp;
    }

        // Write the calculated MAC block out to the SecBuffer
        // Put the padding as the prefix
    pHMACTemp = (PBYTE)pSecBufHMAC->pvBuffer;
    memset(pHMACTemp, cbPrefixPadding, cbPrefixPadding);
    memcpy(pHMACTemp + cbPrefixPadding, &MacBlock, MAC_BLOCK_SIZE);
    DebugLog((DEB_TRACE, "DigestUserSealHelper: Wrote out the calculated MAC Block.\n"));
    pSecBufHMAC->cbBuffer = MAC_BLOCK_SIZE + cbPrefixPadding;  // indicate number of bytes we used for padding and HMAC block

        // Completed the Integrity calculation, now encrypt the data if requested
        // Encrypt the message, padding and first SASL_MAC_HMAC_SIZE (10) bytes of HMAC (the integrity value)

    // Compute Kc for encryption (seal) & generate Cryptkey
    if (pContext->hSealCryptKey == NULL)
    {
        ASSERT(*pdwSeqNum == 0);    // Should be first call into package

        // Compute on first time call to encrypt - save for other sequence numbers
        Status = CalculateKc(pContext->bSessionKey, cbHA1n, &strcSealKeyConst, pContext->bKcSealHashData);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserSealHelper: Error in CalculateKc   status 0x%x\n", Status));
            goto CleanUp;
        }

        // code to expand the DES key into multiple of 8 bytes (key with parity)
        if ((pContext->typeCipher == CIPHER_DES) || (pContext->typeCipher == CIPHER_3DES))
        {
            Status = AddDESParity(pContext->bKcSealHashData,
                                  cbKeyNoParity,
                                  bKcTempData,
                                  &cbTempKey);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "DigestUserSealHelper: Error in AddDESParity   status 0x%x\n", Status));
                goto CleanUp;
            }
            // replace with DES parity version
            ASSERT(cbKey == cbTempKey);
            memcpy(pContext->bSealKey, bKcTempData, cbTempKey);
            pbIV = &(pContext->bKcSealHashData[8]);
        }
        else
        {
            memcpy(pContext->bSealKey, pContext->bKcSealHashData, MD5_HASH_BYTESIZE);
            pbIV = NULL;
        }

        //  generate symmetric key from the cleartext
        Status = CreateSymmetricKey(Algid, cbKey, pContext->bSealKey, pbIV, &pContext->hSealCryptKey);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserSealHelper: Error in CalculateKc   status 0x%x\n", Status));
            goto CleanUp;
        }

    }

    if ((pContext->typeCipher == CIPHER_3DES) || (pContext->typeCipher == CIPHER_DES))
    {

        DebugLog((DEB_TRACE, "DigestUserSealHelper: 3DES/DES Encryption\n"));

             // Specify IV  - take only the last 8 bytes per RFC 2831 sect 2.4
        Status = EncryptData2(pContext->hSealCryptKey, cbBlockSize,
                             pSecBufData->cbBuffer, (PUCHAR)pSecBufData->pvBuffer,
                             (cbPrefixPadding + SASL_MAC_HMAC_SIZE), pHMACTemp);

        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserSealHelper: Error in EncryptData   status 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        Status = EncryptData2(pContext->hSealCryptKey, cbBlockSize,
                             pSecBufData->cbBuffer, (PUCHAR)pSecBufData->pvBuffer,
                             (cbPrefixPadding + SASL_MAC_HMAC_SIZE), pHMACTemp);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserSealHelper: Error in EncryptData   status 0x%x\n", Status));
            goto CleanUp;
        }
    }

    DebugLog((DEB_TRACE, "DigestUserSealHelper: Data encrypted\n"));

    // completed all tasks down to here.  Need to update the sequence number
    (*pdwSeqNum)++;
    DebugLog((DEB_TRACE, "DigestUserSealHelper: Updated SeqNum to %d\n", *pdwSeqNum));


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUserSealHelper: Leaving    Status 0x%x\n", Status));

    return(Status);
}


//+--------------------------------------------------------------------
//
//  Function:   DigestUserUnsealHelper
//
//  Synopsis:   Process a SecBuffer with a given User Security Context
//              Used with SASL section 2.3 RFC
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//                    
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestUserUnsealHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;

    PDWORD    pdwSeqNum = NULL;             // points to the Sequence number to use
    PSecBuffer pSecBufData = NULL;
    PSecBuffer pSecBufStream = NULL;

    PSecBuffer pSecBufHMAC = NULL;          // Points to the HMAC appended to the data block
    PSecBuffer pSecBufMsg = NULL;          // Points to the data section

    BOOL bServer = FALSE;
    SASL_MAC_BLOCK  MacBlock;
    SASL_MAC_BLOCK  TokenMacBlock;         // Extract the HMAC block imbedded in the message
    DWORD dwSeqNumber = 0;
    STRING  strcSignKeyConst;
    STRING  strcSealKeyConst;
    PBYTE  pMsgHMAC = NULL;

    BYTE bKcTempData[MD5_HASH_BYTESIZE];    // Message integrity keys RFC 2831 sec 2.3
    PUCHAR pbIV = NULL;

    ULONG Index = 0;
    USHORT cbHA1n = 0;          // Number of bytes for Ha1 in Kcc/Kcs
    DWORD cbKey = 0;             // Number of bytes of Kcc/Kcs to use for the key
    DWORD cbKeyNoParity = 0;     // Number of bytes of Kcc/Kcs to use for the key with no parity
    DWORD cbTempKey = 0;
    ULONG cbBlockSize = 1;    // Blocksize for the given cipher
    UCHAR cbPrefixPadding = 0;   // number of bytes needed for padding out to blocksize
    ULONG cbMsg = 0;            // number of bytes in the actual message
    PBYTE pHMACTemp = NULL;
    PBYTE pMsgPadding = NULL;   // Location of a padding byte
    ALG_ID Algid = 0;

    ULONG cbSecBufMsgPrivacy = 0;            // Number of bytes to decrypt (unseal)

#if DBG
    char szTemp[TEMPSIZE];
    ULONG  iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
#endif
    

    DebugLog((DEB_TRACE_FUNC, "DigestUserUnsealHelper: Entering\n"));

    ZeroMemory(&MacBlock, sizeof(MacBlock));
    ZeroMemory(&TokenMacBlock, sizeof(TokenMacBlock));
    RtlInitString(&strcSignKeyConst, NULL);
    RtlInitString(&strcSealKeyConst, NULL);

    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    
    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < pSecBuff->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_DATA)
        {
            pSecBufData = &pSecBuff->pBuffers[Index];
        }
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_STREAM)
        {
            pSecBufStream = &pSecBuff->pBuffers[Index];
        }
    }

    // Must be for decrypt/verify
    if ((!pSecBufStream) || (!pSecBufStream->cbBuffer))
    {   // If no SECBUFFER_STREAM, use SECBUFFER_DATA
        pSecBufMsg = pSecBufData;
    }
    else
    {
        pSecBufMsg = pSecBufStream;
    }

    if ((!ContextIsTokenOK(pSecBufMsg, 0)) || (pSecBufMsg->cbBuffer < MAC_BLOCK_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: ContextIsTokenOK (SecBufMsg) decrypt/verify failed  0x%x\n", Status));
        goto CleanUp;
    }
    
    // Strip off the MsgType and the Sequence Number
    cbSecBufMsgPrivacy = pSecBufMsg->cbBuffer - (SASL_MAC_MSG_SIZE + SASL_MAC_SEQ_SIZE);

    if (!ContextIsTokenOK(pSecBufMsg, 0) || (pSecBufMsg->cbBuffer < MAC_BLOCK_SIZE))
    {
        Status = SEC_E_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: ContextIsTokenOK (SignatureToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // Determine the sequence number & Constant Key Sring to utilize acting as the server
    if (bServer)
    {
        pdwSeqNum = &(pContext->dwRecvSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_C2S_SIGN_KEY);
        RtlInitString(&strcSealKeyConst, SASL_C2S_SEAL_KEY);
        DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Signing in Server Mode (Message StoC)  SeqNum %d\n", *pdwSeqNum));
    }
    else
    {             // acting as the client
        pdwSeqNum = &(pContext->dwRecvSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_S2C_SIGN_KEY);
        RtlInitString(&strcSealKeyConst, SASL_S2C_SEAL_KEY);
        DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Signing in Client Mode (Message CtoS)  SeqNum %d\n", *pdwSeqNum));
    }

    // Based on the Cypher selected - establish the byte count parameters - magic numbers from RFC

    if (pContext->typeCipher == CIPHER_RC4)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_RC4_40)
    {
        cbHA1n = 5;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_RC4_56)
    {
        cbHA1n = 7;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_DES)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 8;    // number of bytes to use from Kcc/Kcs
        cbKeyNoParity = 7;
        cbBlockSize = 8;  // DES uses a blocksize of 8
        Algid = CALG_DES;
    }
    else if (pContext->typeCipher == CIPHER_3DES)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        cbKeyNoParity = 14;
        cbBlockSize = 8;  // DES uses a blocksize of 8
        Algid = CALG_3DES_112;
    }
    else
    {
        Status = SEC_E_CRYPTO_SYSTEM_INVALID;
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: ContextIsTokenOK (SecBufMsg) failed  0x%x\n", Status));
        goto CleanUp;
    }

        // Decrypt the message, padding and first SASL_MAC_HMAC_SIZE (10) bytes of HMAC (the integrity value)

    // Compute Kc for encryption (seal)
    if (pContext->hUnsealCryptKey == NULL)
    {
        ASSERT(*pdwSeqNum == 0);
        // Compute on first time call to encrypt - save for other sequence numbers
        Status = CalculateKc(pContext->bSessionKey, cbHA1n, &strcSealKeyConst, pContext->bKcUnsealHashData);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in CalculateKc   status 0x%x\n", Status));
            goto CleanUp;
        }

        // code to expand the DES key into multiple of 8 bytes (key with parity)
        if ((pContext->typeCipher == CIPHER_DES) || (pContext->typeCipher == CIPHER_3DES))
        {
            Status = AddDESParity(pContext->bKcUnsealHashData,
                                  cbKeyNoParity,
                                  bKcTempData,
                                  &cbTempKey);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in AddDESParity   status 0x%x\n", Status));
                goto CleanUp;
            }
            // replace with DES parity version
            ASSERT(cbKey == cbTempKey);
            memcpy(pContext->bUnsealKey, bKcTempData, cbKey);
            pbIV = &(pContext->bKcUnsealHashData[8]);
        }
        else
        {
            // For RC4 ciphers
            memcpy(pContext->bUnsealKey, pContext->bKcUnsealHashData, MD5_HASH_BYTESIZE);
            pbIV = NULL;
        }

        //  generate the symmetric key from the cleartext
        Status = CreateSymmetricKey(Algid, cbKey, pContext->bUnsealKey, pbIV, &pContext->hUnsealCryptKey);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in CalculateKc   status 0x%x\n", Status));
            goto CleanUp;
        }
    }


    if ((pContext->typeCipher == CIPHER_3DES) || (pContext->typeCipher == CIPHER_DES))
    {

             // Specify IV  - take only the last 8 bytes per RFC 2831 sect 2.4
        Status = DecryptData(pContext->hUnsealCryptKey, cbSecBufMsgPrivacy,
                             (PUCHAR)pSecBufMsg->pvBuffer);

        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in DecryptData   status 0x%x\n", Status));
            goto CleanUp;
        }

        // Padding length is indicated in the actual padding - get the pad byte near HMAC
        if (pSecBufMsg->cbBuffer  < (MAC_BLOCK_SIZE + 1))
        {
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Determining padding not enough space   status 0x%x\n", Status));
            goto CleanUp;
        }
        pMsgPadding =  (PBYTE)pSecBufMsg->pvBuffer + (pSecBufMsg->cbBuffer - (MAC_BLOCK_SIZE + 1));

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        if ((MAC_BLOCK_SIZE + 1) < iTempLen)
        {
            iTempLen = (MAC_BLOCK_SIZE + 1);
        }
        BinToHex(pMsgPadding, iTempLen, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "DecryptData: HMAC & padding byte Data bytes (%dof%d bytes) %s\n",
                      iTempLen, (MAC_BLOCK_SIZE + 1), szTemp));
        }
        DebugLog((DEB_TRACE, "DecryptData:  MAC block size %d bytes\n", MAC_BLOCK_SIZE));
#endif

        cbPrefixPadding = *pMsgPadding;
        if (cbPrefixPadding > MAX_PADDING)
        {
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Padding selected (%d) too large   status 0x%x\n",
                      cbPrefixPadding, Status));
            goto CleanUp;
        }

        if (pSecBufMsg->cbBuffer  < (MAC_BLOCK_SIZE + cbPrefixPadding))
        {
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Message incorrect length   status 0x%x\n", Status));
            goto CleanUp;
        }
        cbMsg = pSecBufMsg->cbBuffer - (MAC_BLOCK_SIZE + cbPrefixPadding);

        DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Padding found to be %d bytes\n", cbPrefixPadding));
    }
    else
    {
        Status = DecryptData(pContext->hUnsealCryptKey, cbSecBufMsgPrivacy,
                             (PUCHAR)pSecBufMsg->pvBuffer);

        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in EncryptData   status 0x%x\n", Status));
            goto CleanUp;
        }

        // There is no padding on stream ciphers, so just remove the SASL HMAC block
        cbMsg = pSecBufMsg->cbBuffer - MAC_BLOCK_SIZE;
        DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Stream Cipher - No padding\n"));
    }

    // Locate the beginning of the message
    pMsgHMAC =  (PBYTE)pSecBufMsg->pvBuffer + (pSecBufMsg->cbBuffer - MAC_BLOCK_SIZE);

    Status = CalculateSASLHMAC(pContext, FALSE, &strcSignKeyConst, *pdwSeqNum,
                               (PBYTE)pSecBufMsg->pvBuffer, cbMsg, &MacBlock);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in CalculateSASLHMAC   status 0x%x\n", Status));
        goto CleanUp;
    }


    DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Ready to compare MacBlocks\n"));

    // Check validity of MAC block ONLY do not write it out
    memcpy(&TokenMacBlock, pMsgHMAC, MAC_BLOCK_SIZE); 
    if (MacBlock.dwSeqNumber != TokenMacBlock.dwSeqNumber)
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: SASL MAC blocks out of sequence. Failed verify.  Status 0x%x\n", Status));
#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&TokenMacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Token's HMAC-MD5 block %s\n", szTemp));
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&MacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: TComputed HMAC-MD5 block %s\n", szTemp));
#endif
        goto CleanUp;
    }
    if (memcmp(&MacBlock, &TokenMacBlock, MAC_BLOCK_SIZE))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: SASL MAC blocks do not match. Failed verify.  Status 0x%x\n", Status));
#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&TokenMacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Token's HMAC-MD5 block %s\n", szTemp));
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&MacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: TComputed HMAC-MD5 block %s\n", szTemp));
#endif
        goto CleanUp;
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestUserUnsealHelper: SASL MAC blocks match!\n"));
    }

    // Write out to SECBUFFERDATA the length and location of message
    if (pSecBufData)
    {
        pSecBufData->cbBuffer = cbMsg;
        pSecBufData->pvBuffer = pSecBufMsg->pvBuffer;
    }

    // completed all tasks down to here.  Need to update the sequence number
    (*pdwSeqNum)++;
    DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Updated SeqNum to %d\n", *pdwSeqNum));


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUserUnsealHelper: Leaving    Status 0x%x\n", Status));

    return(Status);
}


// Process the Digest information with the context info and generate any output token info
NTSTATUS NTAPI
DigestUserProcessParameters(
                           IN PDIGEST_USERCONTEXT pContext,
                           IN PDIGEST_PARAMETER pDigest,
                           OUT PSecBuffer pFirstOutputToken)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulNonceCount = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestUserProcessParameters: Entering\n"));


    // Some common input verification tests

    // We must have a noncecount specified since we specified a qop in the Challenge
    // If we decide to support no noncecount modes then we need to make sure that qop is not specified
    if (pDigest->refstrParam[MD5_AUTH_NC].Length)
    {
        Status = RtlCharToInteger(pDigest->refstrParam[MD5_AUTH_NC].Buffer, HEXBASE, &ulNonceCount);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog((DEB_ERROR, "DigestUserProcessParameters: Nonce Count badly formatted\n"));
            goto CleanUp;
        }
    }

    // Check nonceCount is incremented to preclude replay
    if (!(ulNonceCount > pContext->ulNC))
    {
        // We failed to verify next noncecount
        Status = SEC_E_OUT_OF_SEQUENCE;
        DebugLog((DEB_ERROR, "DigestUserProcessParameters: NonceCount failed to increment!\n"));
        goto CleanUp;
    }

    // Since we are in UserMode we MUST have a sessionkey to use - if non then can not process
    if (!pContext->strSessionKey.Length)
    {
        Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;    // indicate that we needed a call to ASC or ISC first
        DebugLog((DEB_ERROR, "DigestUserProcessParameters: No Session Key contained in UserContext\n"));
        goto CleanUp;
    }

    // Copy the SessionKey from the Context into the Digest Structure to verify against
    // This will have Digest Auth routines use the SessionKey rather than recompute H(A1)
    StringFree(&(pDigest->strSessionKey));
    Status = StringDuplicate(&(pDigest->strSessionKey), &(pContext->strSessionKey));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestUserProcessParameters: Failed to copy over SessionKey\n"));
        goto CleanUp;
    }

    // Set the type of Digest Parameters we are to process
    pDigest->typeDigest = pContext->typeDigest;
    pDigest->typeQOP = pContext->typeQOP;
    pDigest->typeAlgorithm = pContext->typeAlgorithm;
    pDigest->typeCharset = pContext->typeCharset;

    DigestPrint(pDigest);

    // No check locally that Digest is authentic
    Status = DigestCalculation(pDigest, NULL);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestUserProcessParameters: Oh no we FAILED Authentication!!!!\n"));
        goto CleanUp;
    }

       // Send to output buffer only if there is an output buffer
       // This allows this routine to be used in UserMode
    if (pFirstOutputToken)
    {
        Status = DigestCreateChalResp(pDigest, NULL, pFirstOutputToken);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestUserProcessParameters: Failed to create Output String\n"));
            goto CleanUp;
        }
    }

CleanUp:
    
    DebugLog((DEB_TRACE_FUNC, "DigestUserProcessParameters: Leaving   Status 0x%x\n", Status));
    return(Status);
}


// Unpack the context from LSA mode into the User mode Context
NTSTATUS
DigestUnpackContext(
    IN PDIGEST_PACKED_USERCONTEXT pPackedUserContext,
    OUT PDIGEST_USERCONTEXT pContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR  pucLoc = NULL;
    USHORT uNumWChars = 0;
    int iAuth = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestUnpackContext: Entering\n"));

    ASSERT(pContext);

    //
    // If TokenHandle is NULL, we are being called as
    // as an effect of InitializeSecurityContext, else we are
    // being called because of AcceptSecurityContext
    //

    if (pPackedUserContext->ClientTokenHandle != NULL)
    {
        DebugLog((DEB_TRACE, "DigestUnpackContext: Called from ASC\n" ));
        pContext->ClientTokenHandle = (HANDLE) ((ULONG_PTR)pPackedUserContext->ClientTokenHandle);
        if (FAILED(SspCreateTokenDacl(pContext->ClientTokenHandle)))
        {
            Status = STATUS_INVALID_HANDLE;
            DebugLog((DEB_ERROR, "DigestUnpackContext: SspCreateTokenDacl failed\n" ));
            goto CleanUp;
        }
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestUnpackContext: Called from ISC\n" ));
    }

    //
    // Copy over all of the other fields - some data might be binary so
    // use RtlCopyMemory(Dest, Src, len)
    //
    pContext->Expires = pPackedUserContext->Expires;
    pContext->typeAlgorithm = (ALGORITHM_TYPE)pPackedUserContext->typeAlgorithm;
    pContext->typeCharset = (CHARSET_TYPE)pPackedUserContext->typeCharset;
    pContext->typeCipher = (CIPHER_TYPE)pPackedUserContext->typeCipher;
    pContext->typeDigest = (DIGEST_TYPE)pPackedUserContext->typeDigest;
    pContext->typeQOP = (QOP_TYPE)pPackedUserContext->typeQOP;
    pContext->ulSendMaxBuf = pPackedUserContext->ulSendMaxBuf;
    pContext->ulRecvMaxBuf = pPackedUserContext->ulRecvMaxBuf;
    pContext->ulNC = 1;                    // Force to one to account for ISC/ASC first message verify
    pContext->lReferences = 1;
    pContext->ContextReq = pPackedUserContext->ContextReq;
    pContext->CredentialUseFlags = pPackedUserContext->CredentialUseFlags;

    // Now check on the strings attached
    pucLoc = &(pPackedUserContext->ucData);
    for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
    {
        if (pPackedUserContext->uDigestLen[iAuth])
        {
            Status = StringAllocate(&(pContext->strParam[iAuth]), (USHORT)pPackedUserContext->uDigestLen[iAuth]);
            if (!NT_SUCCESS(Status))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DebugLog((DEB_ERROR, "DigestUnpackContext: DigestAllocateMemory for Params returns NULL\n" ));
                goto CleanUp;
            }
            memcpy(pContext->strParam[iAuth].Buffer, pucLoc, (USHORT)pPackedUserContext->uDigestLen[iAuth]);
            pContext->strParam[iAuth].Length = (USHORT)pPackedUserContext->uDigestLen[iAuth];
            pucLoc +=  (USHORT)pPackedUserContext->uDigestLen[iAuth];
            // DebugLog((DEB_TRACE, "DigestUnpackContext: Param[%d] is length %d - %.50s\n",
            //           iAuth, pPackedUserContext->uDigestLen[iAuth], pContext->strParam[iAuth].Buffer ));
        }
    }
        // Now do the SessionKey
    if (pPackedUserContext->uSessionKeyLen)
    {
        Status = StringAllocate(&(pContext->strSessionKey), (USHORT)pPackedUserContext->uSessionKeyLen);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DebugLog((DEB_ERROR, "DigestUnpackContext: DigestAllocateMemory for SessionKey returns NULL\n" ));
            goto CleanUp;
        }
        memcpy(pContext->strSessionKey.Buffer, pucLoc, pPackedUserContext->uSessionKeyLen);
        pContext->strSessionKey.Length = (USHORT)pPackedUserContext->uSessionKeyLen;
        pucLoc +=  (USHORT)pPackedUserContext->uSessionKeyLen;
    }
    
        // Now do the AccountName
    if (pPackedUserContext->uAccountNameLen)
    {
        uNumWChars = (USHORT)pPackedUserContext->uAccountNameLen / sizeof(WCHAR);
        Status = UnicodeStringAllocate(&(pContext->ustrAccountName), uNumWChars);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DebugLog((DEB_ERROR, "DigestUnpackContext: DigestAllocateMemory for AccountName returns NULL\n" ));
            goto CleanUp;
        }
        memcpy(pContext->ustrAccountName.Buffer, pucLoc, pPackedUserContext->uAccountNameLen);
        pContext->ustrAccountName.Length = (USHORT)pPackedUserContext->uAccountNameLen;
        pucLoc +=  (USHORT)pPackedUserContext->uAccountNameLen;
    }

    // Now determine the binary version of the SessionKey from HEX() version
    ASSERT(pContext->strSessionKey.Length == MD5_HASH_HEX_SIZE);
    HexToBin(pContext->strSessionKey.Buffer, MD5_HASH_HEX_SIZE, pContext->bSessionKey);

#if DBG
    char szTemp[TEMPSIZE];
    ZeroMemory(szTemp, TEMPSIZE);

    BinToHex(pContext->bSessionKey, MD5_HASH_BYTESIZE, szTemp);
    DebugLog((DEB_TRACE, "DigestUnpackContext: verify SessionKey %Z is binary %s\n",
              &(pContext->strSessionKey), szTemp));
#endif
    
CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUnpackContext: Leaving       Status 0x%x\n", Status));
    return(Status);
}


// Printout the fields present in usercontext pContext
NTSTATUS
UserContextPrint(PDIGEST_USERCONTEXT pContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    if (!pContext)
    {
        return (STATUS_INVALID_PARAMETER); 
    }


    DebugLog((DEB_TRACE_FUNC, "UserContext:      Entering for Context Handle at 0x%x\n", pContext));

    DebugLog((DEB_TRACE, "UserContext:      NC %ld\n", pContext->ulNC));

    DebugLog((DEB_TRACE, "UserContext:      LSA Context 0x%x\n", pContext->LsaContext));


    if (pContext->typeDigest == DIGEST_CLIENT)
    {
        DebugLog((DEB_TRACE, "UserContext:       DIGEST_CLIENT\n"));
    }
    if (pContext->typeDigest == DIGEST_SERVER)
    {
        DebugLog((DEB_TRACE, "UserContext:       DIGEST_SERVER\n"));
    }
    if (pContext->typeDigest == SASL_SERVER)
    {
        DebugLog((DEB_TRACE, "UserContext:       SASL_SERVER\n"));
    }
    if (pContext->typeDigest == SASL_CLIENT)
    {
        DebugLog((DEB_TRACE, "UserContext:       SASL_CLIENT\n"));
    }

    if (pContext->typeQOP == AUTH)
    {
        DebugLog((DEB_TRACE, "UserContext:       QOP: AUTH\n"));
    }
    if (pContext->typeQOP == AUTH_INT)
    {
        DebugLog((DEB_TRACE, "UserContext:       QOP: AUTH_INT\n"));
    }
    if (pContext->typeQOP == AUTH_CONF)
    {
        DebugLog((DEB_TRACE, "UserContext:       QOP: AUTH_CONF\n"));
    }
    if (pContext->typeAlgorithm == MD5)
    {
        DebugLog((DEB_TRACE, "UserContext:       Algorithm: MD5\n"));
    }
    if (pContext->typeAlgorithm == MD5_SESS)
    {
        DebugLog((DEB_TRACE, "UserContext:       Algorithm: MD5_SESS\n"));
    }


    if (pContext->typeCharset == ISO_8859_1)
    {
        DebugLog((DEB_TRACE, "UserContext:       Charset: ISO 8859-1\n"));
    }
    if (pContext->typeCharset == UTF_8)
    {
        DebugLog((DEB_TRACE, "UserContext:       Charset: UTF-8\n"));
    }

    if (pContext->typeCipher == CIPHER_RC4)
    {
        DebugLog((DEB_TRACE, "UserContext:       Cipher: CIPHER_RC4\n"));
    }
    else if (pContext->typeCipher == CIPHER_RC4_40)
    {
        DebugLog((DEB_TRACE, "UserContext:       Cipher: CIPHER_RC4_40\n"));
    }
    else if (pContext->typeCipher == CIPHER_RC4_56)
    {
        DebugLog((DEB_TRACE, "UserContext:       Cipher: CIPHER_RC4_56\n"));
    }
    else if (pContext->typeCipher == CIPHER_DES)
    {
        DebugLog((DEB_TRACE, "UserContext:       Cipher: CIPHER_DES\n"));
    }
    else if (pContext->typeCipher == CIPHER_3DES)
    {
        DebugLog((DEB_TRACE, "UserContext:       Cipher: CIPHER_3DES\n"));
    }

    DebugLog((DEB_TRACE, "UserContext:       ContextReq 0x%lx     CredentialUseFlags 0x%x\n",
              pContext->ContextReq,
              pContext->CredentialUseFlags));

    for (i=0; i < MD5_AUTH_LAST;i++)
    {
        if (pContext->strParam[i].Buffer &&
            pContext->strParam[i].Length)
        {
            DebugLog((DEB_TRACE, "UserContext:       Digest[%d] = \"%Z\"\n", i,  &pContext->strParam[i]));
        }
    }

    if (pContext->strSessionKey.Length)
    {
        DebugLog((DEB_TRACE, "UserContext:      SessionKey %Z\n", &pContext->strSessionKey));
    }

    if (pContext->ustrAccountName.Length)
    {
        DebugLog((DEB_TRACE, "UserContext:      AccountName %wZ\n", &pContext->ustrAccountName));
    }

    DebugLog((DEB_TRACE_FUNC, "UserContext:      Leaving\n"));

    return(Status);
}

// CryptoAPI function support

NTSTATUS
SEC_ENTRY
CreateSymmetricKey(
    IN ALG_ID     Algid,
    IN DWORD       cbKey,
    IN UCHAR      *pbKey,
    IN UCHAR      *pbIV,
    OUT HCRYPTKEY *phKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLAINTEXTBLOB   PlainBlob;

    DebugLog((DEB_TRACE_FUNC, "CreateSymmetricKey: Entering\n"));

    ASSERT(*phKey == NULL);

    ZeroMemory(&PlainBlob, sizeof(PlainBlob));

    if (cbKey > MD5_HASH_BYTESIZE)
    {
        DebugLog((DEB_ERROR, "CreateSymmetricKey: Shared key too long\n"));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

#if DBG
        char szTemp[TEMPSIZE];
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex(pbKey, cbKey, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CreateSymmetricKey: Creating symmetric for  %s\n", szTemp));
        }
#endif

    PlainBlob.Blob.bType = PLAINTEXTKEYBLOB;
    PlainBlob.Blob.bVersion = CUR_BLOB_VERSION;
    PlainBlob.Blob.reserved = 0;
    PlainBlob.Blob.aiKeyAlg = Algid;
    memcpy(PlainBlob.bKey, pbKey, cbKey);
    PlainBlob.dwKeyLen = cbKey;


    // import thw simpleblob to get a handle to the symmetric key
    if (!CryptImportKey(g_hCryptProv,
                        (BYTE *)&PlainBlob,
                        sizeof(PlainBlob),
                        0,
                        0,
                        phKey))
    {
        DebugLog((DEB_ERROR, "CreateSymmetricKey: CryptImportKey failed     error 0x%x\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
    }


    if ((Algid == CALG_DES) || (Algid == CALG_3DES_112))
    {

       if (!pbIV)
       {
           DebugLog((DEB_WARN, "CreateSymmetricKey: No IV selected for DES\n"));
       }
       else
       {
#if DBG
                // Now convert the Hash to Hex  - for TESTING ONLY
           ZeroMemory(szTemp, TEMPSIZE);
           BinToHex(pbIV, 8, szTemp);
           if (szTemp)
           {
               DebugLog((DEB_TRACE, "CreateSymmetricKey: IV bytes set to  %s\n", szTemp));
           }
#endif
           if (!CryptSetKeyParam(*phKey, KP_IV, pbIV, 0))
           {
               DebugLog((DEB_ERROR, "CreateSymmetricKey:CryptSetKeyParam() failed : 0x%x\n", GetLastError()));
               Status = STATUS_INTERNAL_ERROR;
               goto CleanUp;
           }
       }

    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "CreateSymmetricKey: Leaving     status 0x%x\n", Status));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   EncryptData2
//
//  Synopsis:   Encrypt a data buffer (broken into two pieces DATA and Signature)
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN   Algid              -- Encryption algorithm to utilize
//  IN   pbIV               -- DES salt (if any provided)
//  IN   hKey               -- symmetric key to utilize
//  IN   cbBlocklength      -- natural block length for encoding (RC will be 1 and DES will be 8)
//  IN   cbData             -- number of data bytes to encrypt
//  IN   pbData             -- pointer to data bytes to encrypt
//  IN   cbSignature        -- number of signature bytes to encrypt after Data is encrypted
//  IN   pbSignature        -- number of bytes in signature to encrypt
//
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS
SEC_ENTRY
EncryptData2(
    IN HCRYPTKEY  hKey,
    IN ULONG      cbBlocklength,
    IN ULONG      cbData,
    IN OUT UCHAR  *pbData,
    IN ULONG      cbSignature,
    IN OUT UCHAR  *pbSignature
    )
{
    DWORD    dwBytesEncrypt = 0;
    ULONG    cbTemp = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    cbBlocks = 0;
    ULONG    cbDataExtra = 0;
    ULONG    cbCnt = 0;               // number of bytes to alloc for merged data
    PBYTE    pbBuff2 = NULL;          // temp alloc for merge of extra bytes & signature
    PBYTE    pbDataExtra = NULL;      // location for start of extra memory bytes

    DebugLog((DEB_TRACE_FUNC, "EncryptData2: Entering   %lu bytes\n", cbData));
    DebugLog((DEB_TRACE, "EncryptData2:      Blocklength %lu\n", cbBlocklength));
    DebugLog((DEB_TRACE, "EncryptData2:      Signature block %lu bytes\n", cbSignature));


    // Check if encrypting 1 or two buffers
    if (!cbSignature)
    {
        DebugLog((DEB_TRACE, "EncryptData2: one buffer only - direct encode\n"));
        DebugLog((DEB_TRACE, "EncryptData2:    buffer %lu bytes\n", cbData));
        // Only one buffer utilized
        dwBytesEncrypt = cbData;
        if (!CryptEncrypt(hKey, 0, FALSE, 0, pbData, &dwBytesEncrypt, cbData))
        {
            DebugLog((DEB_ERROR, "EncryptData2:CryptEncrypt one buffer failed : 0x%x\n", GetLastError()));
            Status = STATUS_INTERNAL_ERROR;
            goto CleanUp;
        }
    }
    else
    {
        // We have two buffers to encrypt

        // Identify if there are extra bytes beyond blocksize for cipher
        cbBlocks = cbData / cbBlocklength;    // integer division
        cbDataExtra =  cbData - (cbBlocklength * cbBlocks);

        DebugLog((DEB_TRACE, "EncryptData2: number of cipher blocks %lu   number extra bytes %lu\n",
                  cbBlocks, cbDataExtra));

        if (cbDataExtra)
        {
            DebugLog((DEB_TRACE, "EncryptData2: merge signature - encrypt two buffers & replace\n"));
            // extra data bytes starting memory location
            pbDataExtra = pbData + (cbBlocklength * cbBlocks);

            // There are bytes outside a multiple of the cipher block size
            // create temp buffer for extra bytes and HMAC
            cbCnt = cbDataExtra + cbSignature;
            DebugLog((DEB_TRACE, "EncryptData2: merge block size %lu bytes\n", cbCnt));
            pbBuff2 = (PBYTE)DigestAllocateMemory(cbCnt + MAX_PADDING);
            if (!pbBuff2)
            {
                DebugLog((DEB_ERROR, "EncryptData2:out of memory\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }

            // copy over the bytes to temp buffer
            memcpy(pbBuff2, pbDataExtra, cbDataExtra);
            memcpy(pbBuff2 + cbDataExtra, pbSignature, cbSignature);

            // encrypt any multiples of blocklength in the data section (first buffer)
            if (cbBlocks)
            {
                dwBytesEncrypt = cbBlocklength * cbBlocks;
                DebugLog((DEB_TRACE, "EncryptData2:    buffer 1 %lu bytes\n", dwBytesEncrypt));
                if (!CryptEncrypt(hKey, 0, FALSE, 0, pbData, &dwBytesEncrypt, dwBytesEncrypt))
                {
                    DebugLog((DEB_ERROR, "EncryptData2:CryptEncrypt first buffer (blocklength) failed : 0x%x\n", GetLastError()));
                    Status = STATUS_INTERNAL_ERROR;
                    goto CleanUp;
                }
            }

            // encrypt the temp buffer - copy back to original locations afterwards
            dwBytesEncrypt = cbCnt;
            DebugLog((DEB_TRACE, "EncryptData2:    buffer 2 encrypt %lu bytes in %lu byte buffer\n",
                      dwBytesEncrypt, cbCnt + MAX_PADDING));
            if (!CryptEncrypt(hKey, 0, FALSE, 0, pbBuff2, &dwBytesEncrypt, cbCnt + MAX_PADDING))
            {
                DebugLog((DEB_ERROR, "EncryptData2:CryptEncrypt second buffer (blocklength) failed : 0x%x\n", GetLastError()));
                Status = STATUS_INTERNAL_ERROR;
                goto CleanUp;
            }
            memcpy(pbSignature, pbBuff2 + cbDataExtra, cbSignature);
            memcpy(pbDataExtra, pbBuff2, cbDataExtra);

        }
        else
        {
            DebugLog((DEB_TRACE, "EncryptData2: multiple of cipher blocksize - encrypt two buffers directly\n"));

            // encrypt data buffer and then signature buffer - data buffer is multiple of blocksize
            if (cbData)
            {
                dwBytesEncrypt = cbData;
                DebugLog((DEB_TRACE, "EncryptData2:    buffer 1 %lu bytes\n", dwBytesEncrypt));
                if (!CryptEncrypt(hKey, 0, FALSE, 0, pbData, &dwBytesEncrypt, cbData))
                {
                    DebugLog((DEB_ERROR, "EncryptData2:CryptEncrypt first buffer (blocklength) failed : 0x%x\n", GetLastError()));
                    Status = STATUS_INTERNAL_ERROR;
                    goto CleanUp;
                }
                DebugLog((DEB_TRACE, "EncryptData2:    needed %lu bytes for encrypted buffer 1\n", dwBytesEncrypt));
            }

            // Final encrypt of signature buffer
            dwBytesEncrypt = cbSignature;
            DebugLog((DEB_TRACE, "EncryptData2:    buffer 2 %lu bytes\n", dwBytesEncrypt));
            //   We do our own padding so we must have Final=FALSE so CAPI will not add in one
            if (!CryptEncrypt(hKey, 0, FALSE, 0, pbSignature, &dwBytesEncrypt, cbSignature))
            {
                DebugLog((DEB_ERROR, "EncryptData2:CryptEncrypt second buffer (blocklength) failed : 0x%x\n", GetLastError()));
                Status = STATUS_INTERNAL_ERROR;
                goto CleanUp;
            }
            DebugLog((DEB_TRACE, "EncryptData2:    needed %lu bytes for encrypted buffer 2\n", dwBytesEncrypt));
        }


    }

    goto CleanUp;

CleanUp:

    if (pbBuff2)
    {
        DigestFreeMemory(pbBuff2);
        pbBuff2 = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "EncryptData2: Leaving     status 0x%x\n", Status));

    return(Status);
}


NTSTATUS
SEC_ENTRY
DecryptData(
    IN HCRYPTKEY  hKey,
    IN ULONG      cbData,
    IN OUT UCHAR  *pbData
    )
{
    ULONG    cb = cbData;
    ULONG    cbTemp = 0;
    NTSTATUS Status = STATUS_SUCCESS;

#if DBG
    char szTemp[TEMPSIZE];
    ULONG  iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
#endif

    DebugLog((DEB_TRACE_FUNC, "DecryptData: Entering   %lu bytes at 0x%x\n", cbData, pbData));

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
    iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
    if (cbData < iTempLen)
    {
        iTempLen = cbData;
    }
    BinToHex(pbData, iTempLen, szTemp);

    if (szTemp)
    {
        DebugLog((DEB_TRACE, "DecryptData: Encrypted Data bytes (%dof%d bytes) %s\n",
                  iTempLen, cbData, szTemp));
    }

    iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
    if (cbData < iTempLen)
    {
        iTempLen = cbData;
    }
    BinToHex((pbData + cbData - iTempLen), iTempLen, szTemp);

    if (szTemp)
    {
        DebugLog((DEB_TRACE, "DecryptData: Encrypted end of buffer (%dof%d bytes) %s\n",
                  iTempLen, cbData, szTemp));
    }
#endif
    
    // import the simpleblob to get a handle to the symmetric key
    if (!CryptDecrypt(hKey, 0, FALSE, 0, pbData, &cb))
    {
        DebugLog((DEB_ERROR, "DecryptData:CryptCreateHash() failed : 0x%x\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }


#if DBG

    DebugLog((DEB_ERROR, "DecryptData:  Decrypted number of bytes %lu\n", cb));

            // Now convert the Hash to Hex  - for TESTING ONLY
    iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
    if (cb < iTempLen)
    {
        iTempLen = cb;
    }
    BinToHex(pbData, iTempLen, szTemp);

    if (szTemp)
    {
        DebugLog((DEB_TRACE, "DecryptData: Decrypted Data bytes (%dof%d bytes) %s\n",
                  iTempLen, cbData, szTemp));
    }

    iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
    if (cb < iTempLen)
    {
        iTempLen = cb;
    }
    BinToHex((pbData + cb - iTempLen), iTempLen, szTemp);

    if (szTemp)
    {
        DebugLog((DEB_TRACE, "DecryptData: Decrypted end of buffer (%dof%d bytes) %s\n",
                  iTempLen, cbData, szTemp));
    }
#endif

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DecryptData: Leaving     status 0x%x\n", Status));

    return(Status);
}


NTSTATUS
SEC_ENTRY
CalculateSASLHMAC(
    IN PDIGEST_USERCONTEXT pContext,
    IN BOOL  fSign,
    IN PSTRING pstrSignKeyConst,
    IN DWORD dwSeqNum,                     // Sequence number to process
    IN PBYTE pData,                        // location of data to HMAC
    IN ULONG cbData,                       // How many bytes of data to process
    OUT PSASL_MAC_BLOCK pMacBlock)
{
    NTSTATUS Status = STATUS_SUCCESS;

    HCRYPTHASH hHash = NULL;
    HCRYPTKEY hCryptKey = NULL;
    HMAC_INFO hmacinfo;

    BYTE bKiHashData[MD5_HASH_BYTESIZE];    // Message integrity keys RFC 2831 sec 2.3
    DWORD cbKiHashData = 0;                 // Size of Message integrity keys

    BYTE bHMACData[HMAC_MD5_HASH_BYTESIZE];
    DWORD cbHMACData = 0;

#if DBG
    char szTemp[TEMPSIZE];
    ULONG  iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
#endif


    DebugLog((DEB_TRACE_FUNC, "CalculateSASLHMAC: Entering\n"));
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Processing %d bytes in data block\n", cbData));

    // Clear the output
    ZeroMemory(pMacBlock, sizeof(SASL_MAC_BLOCK));

    // Initialize local variables
    ZeroMemory(bKiHashData, MD5_HASH_BYTESIZE);
    ZeroMemory(bHMACData, HMAC_MD5_HASH_BYTESIZE);
    ZeroMemory(&hmacinfo, sizeof(HMAC_INFO));


    // Always do an integrety calculation on the input data
    // We should have clear text data at this stage
    if (!dwSeqNum)
    {
        if ( !CryptCreateHash( g_hCryptProv,
                               CALG_MD5,
                               0,
                               0,
                               &hHash ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMAC: CryptCreateHash failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pContext->bSessionKey,
                             MD5_HASH_BYTESIZE,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMAC: CryptHashData failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        if (pstrSignKeyConst->Length)
        {
            if ( !CryptHashData( hHash,
                                 (const unsigned char *)pstrSignKeyConst->Buffer,
                                 pstrSignKeyConst->Length,
                                 0 ) )
            {
                DebugLog((DEB_ERROR, "CalculateSASLHMAC: CryptHashData failed : 0x%lx\n", GetLastError()));
                Status = STATUS_ENCRYPTION_FAILED;
                goto CleanUp;
            }
        }

        cbKiHashData = MD5_HASH_BYTESIZE;
        if ( !CryptGetHashParam( hHash,
                                 HP_HASHVAL,
                                 bKiHashData,
                                 &cbKiHashData,
                                 0 ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMAC: CryptGetHashParam failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        CryptDestroyHash( hHash );
        hHash = NULL;

        ASSERT(cbKiHashData == MD5_HASH_BYTESIZE);

        // save the key for later sign/verify use
        if (fSign == TRUE)
        {
            memcpy(pContext->bKiSignHashData, bKiHashData, MD5_HASH_BYTESIZE);
        }
        else
        {
            memcpy(pContext->bKiVerifyHashData, bKiHashData, MD5_HASH_BYTESIZE);
        }

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex(bKiHashData, MD5_HASH_BYTESIZE, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMAC: Calculated Ki hash is %s\n", szTemp));
        }
#endif

    }
    else
    {
        // retrieve it from the saved context info
        if (fSign == TRUE)
        {
            memcpy(bKiHashData, pContext->bKiSignHashData, MD5_HASH_BYTESIZE);
        }
        else
        {
            memcpy(bKiHashData, pContext->bKiVerifyHashData, MD5_HASH_BYTESIZE);
        }
        cbKiHashData = MD5_HASH_BYTESIZE;
#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex(bKiHashData, MD5_HASH_BYTESIZE, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMAC: Ki retrieved from context is %s\n", szTemp));
        }
#endif

    }

    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Ready to start the HMAC calculation\n"));

    // We now have Kic or Kis depending on if we are running as server or client
    // Now calculate the SASL_MAC_BLOCK structure to compare or set for message

    pMacBlock->wMsgType    = htons(1);
    pMacBlock->dwSeqNumber = htonl(dwSeqNum);
    
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: SeqNumber is %ld\n", dwSeqNum));


    // Need to create the symmetric key from the cleartext shared secret
    // Specified CALC_RC4 since we need to provide a valid encrypt type for import key
    // not actually utilized when we do the HMAC which is simply a hash function
    Status = CreateSymmetricKey(CALG_RC4, MD5_HASH_BYTESIZE, bKiHashData, NULL, &hCryptKey);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: Error in CreateSymmetricKey     Status 0x%x\n", Status));
        goto CleanUp;
    }

    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_HMAC,
                           hCryptKey,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    hmacinfo.HashAlgid = CALG_MD5;     // Use MD5 as the hashing function for the HMAC
    hmacinfo.cbOuterString = 0;        // use default 64 byte outerstring
    hmacinfo.cbInnerString = 0;        // use default 64 byte innerstring

    if ( !CryptSetHashParam( hHash,
                           HP_HMAC_INFO,
                           (PBYTE)&hmacinfo,
                           0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC CryptSetHashParam failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }
           // Prepend SeqNum to the data stream to perform HMAC on
           //  Need to form the network order version first

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex((PUCHAR)&pMacBlock->dwSeqNumber, sizeof(DWORD), szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMAC: HMAC component SeqNum %s\n", szTemp));
        }
#endif
    if ( !CryptHashData( hHash,
                         (const unsigned char *)&pMacBlock->dwSeqNumber,
                         sizeof(DWORD),
                         0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC CryptHashData failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    // Now HMAC the data to protect

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        if (cbData < iTempLen)
        {
            iTempLen = cbData;
        }
        BinToHex(pData, iTempLen, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMAC: HMAC component Data (%dof%d bytes) %s\n",
                      iTempLen, cbData, szTemp));
        }
#endif
    if (cbData)
    {
        if ( !CryptHashData( hHash,
                             pData,
                             cbData,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC CryptHashData failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }

    cbHMACData = HMAC_MD5_HASH_BYTESIZE;
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             bHMACData,
                             &cbHMACData,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC CryptGetHashParam failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "CalculateSASLHMAC: HMAC hash length  %d bytes\n", cbHMACData));
    ASSERT(cbHMACData == HMAC_MD5_HASH_BYTESIZE);

    CryptDestroyKey( hCryptKey );
    hCryptKey = NULL;

    CryptDestroyHash( hHash );
    hHash = NULL;


    // We now have the HMAC so form up the MAC block for SASL

    // Now convert the Hash to Hex  - for TESTING ONLY
    if (cbHMACData != HMAC_MD5_HASH_BYTESIZE)
    {
        // This should never happen
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC-MD5 result length incorrect\n"));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex(bHMACData, HMAC_MD5_HASH_BYTESIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: HMAC-MD5 is %s\n", szTemp));
#endif

    memcpy(pMacBlock->hmacMD5, bHMACData, SASL_MAC_HMAC_SIZE);

#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)pMacBlock, HMAC_MD5_HASH_BYTESIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: HMAC-MD5 block is %s\n", szTemp));
#endif


CleanUp:

        // Release Key resources
    if (hCryptKey)
    {
        CryptDestroyKey( hCryptKey );
        hCryptKey = NULL;
    }
        // Release Hash resources
    if (hHash)
    {
        CryptDestroyHash( hHash );
        hHash = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "CalculateSASLHMAC: Leaving     status 0x%x\n", Status));

    return(Status);
}




NTSTATUS
SEC_ENTRY
CalculateKc(
    IN PBYTE pbSessionKey,
    IN USHORT cbHA1n,
    IN PSTRING pstrSealKeyConst,
    IN PBYTE pHashData)                    // MD5 hash for Kc
{
    NTSTATUS Status = STATUS_SUCCESS;

    HCRYPTHASH hHash = NULL;

    DWORD cbKcHashData = 0;                 // Size of Message integrity keys

    ASSERT(cbHA1n <= MD5_HASH_BYTESIZE);
    ASSERT(cbHA1n > 0);

#if DBG
    char szTemp[TEMPSIZE];
    ZeroMemory(szTemp, TEMPSIZE);

    BinToHex(pbSessionKey, MD5_HASH_BYTESIZE, szTemp);
    DebugLog((DEB_TRACE_FUNC, "CalculateKc: Entering\n"));

    DebugLog((DEB_TRACE_FUNC, "CalculateKc: Binary SessionKey %s\n", szTemp));
    DebugLog((DEB_TRACE_FUNC, "CalculateKc: cbHA1n %d\n", cbHA1n));
    DebugLog((DEB_TRACE_FUNC, "CalculateKc: SealKeyConst %Z\n", pstrSealKeyConst));
#endif


    // Clear the output
    ZeroMemory(pHashData, MD5_HASH_BYTESIZE);


    // Kc = MD5( {H(A1)[0...cbHA1n], ConstantString})    take only the first cbHA1n bytes of H(A1)
    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "CalculateKc: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         (const unsigned char *)pbSessionKey,
                         cbHA1n,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateKc: CryptHashData failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    if (pstrSealKeyConst->Length)
    {
        if ( !CryptHashData( hHash,
                             (const unsigned char *)pstrSealKeyConst->Buffer,
                             pstrSealKeyConst->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "CalculateKc: CryptHashData failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }

    cbKcHashData = MD5_HASH_BYTESIZE;
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             pHashData,
                             &cbKcHashData,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateKc: CryptGetHashParam failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    CryptDestroyHash( hHash );
    hHash = NULL;

    DebugLog((DEB_TRACE, "CalculateKc: readback hash with %d bytes\n", cbKcHashData));

#if DBG
        // Now convert the Hash to Hex  - for TESTING ONLY
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex(pHashData, MD5_HASH_BYTESIZE, szTemp);

    if (szTemp)
    {
        DebugLog((DEB_TRACE, "CalculateKc: Kc hash is %s\n", szTemp));
    }
#endif


CleanUp:

        // Release Hash resources
    if (hHash)
    {
        CryptDestroyHash( hHash );
        hHash = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "CalculateKc: Leaving     status 0x%x\n", Status));

    return(Status);
}




BYTE DESParityTable[] = {0x00,0x01,0x01,0x02,0x01,0x02,0x02,0x03,
                      0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04};

//
// set the parity on the DES key - ODD parity
// NOTE : must be called before deskey
// key must be cbKey number of bytes
// routine from RSA lib
//
void
SetDESParity(
        PBYTE           pbKey,
        DWORD           cbKey
        )
{
    DWORD i;

    for (i=0;i<cbKey;i++)
    {
        if (!((DESParityTable[pbKey[i]>>4] + DESParityTable[pbKey[i]&0x0F]) % 2))
            pbKey[i] = pbKey[i] ^ 0x01;
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   addDESParity
//
//  Synopsis:   This routine is called for DES plaintext keys to add in Odd parity bits
//              Input of 7 bytes will be expanded to 8bytes with parity
//              Input of 14 bytes will be expanded to 14 bytes
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN   pbSrckey              -- buffer with key to expand
//  IN   cbKey             -- size of input non-parity expanded key
//  OUT   pbOutputkey              -- buffer with key to expand
//
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS
AddDESParity(
    IN PBYTE           pbSrcKey,
    IN DWORD           cbSrcKey,
    OUT PBYTE          pbDstKey,
    OUT PDWORD          pcbDstKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BYTE bKiHashData[MD5_HASH_BYTESIZE];    // Message integrity keys RFC 2831 sec 2.3

    ASSERT(pbSrcKey);
    ASSERT(pbDstKey);
    ASSERT(pcbDstKey);

    ZeroMemory(pbDstKey, MD5_HASH_BYTESIZE);

    if ((cbSrcKey != 7) && (cbSrcKey != 14))
    {
        DebugLog((DEB_ERROR, "AddDESParity: wrong input size buffer\n"));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }


	pbDstKey[0] =  pbSrcKey[0];
    pbDstKey[1] = (pbSrcKey[1] >> 1) | ((pbSrcKey[0] & 0x01) << 7);
	pbDstKey[2] = (pbSrcKey[2] >> 2) | ((pbSrcKey[1] & 0x03) << 6);
	pbDstKey[3] = (pbSrcKey[3] >> 3) | ((pbSrcKey[2] & 0x07) << 5);
	pbDstKey[4] = (pbSrcKey[4] >> 4) | ((pbSrcKey[3] & 0x0F) << 4);
	pbDstKey[5] = (pbSrcKey[5] >> 5) | ((pbSrcKey[4] & 0x1F) << 3);
	pbDstKey[6] = (pbSrcKey[6] >> 6) | ((pbSrcKey[5] & 0x3F) << 2);
	pbDstKey[7] = (pbSrcKey[6] << 1);

    SetDESParity(pbDstKey, 8);
    *pcbDstKey = 8;

    // Now check if need to expand the 14 bytes into the full 16 byte buffer
    if (cbSrcKey == 14)
    {
        pbDstKey[0 + 8] =  pbSrcKey[0 + 7];
        pbDstKey[1 + 8] = (pbSrcKey[1 + 7] >> 1) | ((pbSrcKey[0 + 7] & 0x01) << 7);
        pbDstKey[2 + 8] = (pbSrcKey[2 + 7] >> 2) | ((pbSrcKey[1 + 7] & 0x03) << 6);
        pbDstKey[3 + 8] = (pbSrcKey[3 + 7] >> 3) | ((pbSrcKey[2 + 7] & 0x07) << 5);
        pbDstKey[4 + 8] = (pbSrcKey[4 + 7] >> 4) | ((pbSrcKey[3 + 7] & 0x0F) << 4);
        pbDstKey[5 + 8] = (pbSrcKey[5 + 7] >> 5) | ((pbSrcKey[4 + 7] & 0x1F) << 3);
        pbDstKey[6 + 8] = (pbSrcKey[6 + 7] >> 6) | ((pbSrcKey[5 + 7] & 0x3F) << 2);
        pbDstKey[7 + 8] = (pbSrcKey[6 + 7] << 1);
        SetDESParity(pbDstKey + 8, 8);
        *pcbDstKey = 16;
    }

#if DBG
    char szTemp[TEMPSIZE];
    ZeroMemory(szTemp, TEMPSIZE);

    BinToHex(pbSrcKey, (UINT)cbSrcKey, szTemp);
    DebugLog((DEB_TRACE, "AddDESParity: Key no-parity : %s\n", szTemp));


    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex(pbDstKey, (UINT)*pcbDstKey, szTemp);
    DebugLog((DEB_TRACE, "AddDESParity: Key expanded with parity : %s\n", szTemp));
#endif

CleanUp:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\wdigest.h ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:       wdigest.h
//
// Contents:   some general defines for SSP WDigest
//
//             Helper functions:
//
// History:    KDamour  29Jun00   Created
//
//---------------------------------------------------------------------

#ifndef NTDIGEST_WDIGEST_H
#define NTDIGEST_WDIGEST_H


////////////////////////////////////////////////////////////////////////
//
// Name of the package to pass in to AcquireCredentialsHandle, etc.
//
////////////////////////////////////////////////////////////////////////

#ifndef WDIGEST_SP_NAME_A

#define WDIGEST_SP_NAME_A            "WDigest"
#define WDIGEST_SP_NAME              L"WDigest"

#endif // WDIGEST_SP_NAME_A


// To indicate that the challenge should indicate Stale is TRUE
// To be used if VerifyMessage returns that context has expired
#define ASC_REQ_STALE         0x20000000
#define ASC_RET_STALE         0x20000000

//
// This flag indicates to EncryptMessage that the message is not to actually
// be encrypted, but a header/trailer are to be produced.
//

#ifndef SIGN_ONLY
#define SIGN_ONLY 0x80000001
#endif   // SIGN_ONLY

#endif // NTDIGEST_WGDIGEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\testb\test.cpp ===
// Test.cpp : Defines the entry point for the console application.
//

#include "testglobal.h"


#include <stdio.h>      // printf


#include <security.h>   // General definition of a Security Support Provider



#define AUTH_USERNAME "test1"
#define AUTH_USERNAME_W L"test1"
#define AUTH_REALM   "simple_digest"
#define AUTH_REALM_W L"simple_digest\"_widechar"
#define AUTH_NONCE "9b38dce631309cc25a653ebaad5b18ee01c8bf385260b26db0574a302be4c11367"
#define AUTH_METHOD "GET"
#define AUTH_ALGORITHM "md5-sess"
#define AUTH_QOP "auth"
#define AUTH_PASSWD "secret"
#define AUTH_CNONCE "34c52218425a779f41d5075931fe6c93"
#define AUTH_URI "/dir/index.html"
#define AUTH_URI_W L"/dir/index.html"
#define AUTH_URI2 "/simple_digest/progress.html"
#define AUTH_URI2_W L"/simple_digest/progress.html"
#define AUTH_NC  "0000000b"
#define AUTH_NC1  "00000001"
#define AUTH_NC2  "00000002"
#define AUTH_NC3  "00000003"
#define AUTH_NC4  "00000004"
#define AUTH_REQDIGEST "60cac55049f9887c9fb853f485128368"


#define STR_BUF_SIZE   4000


// Prototypes
void PrintStatus(SECURITY_STATUS NetStatus);
void MyPrintTime(LPSTR Comment,TimeStamp ConvertTime);


int __cdecl
main(int argc, char* argv[])
{
    int  bPass = 1;
    SECURITY_STATUS Status = STATUS_SUCCESS;

    char cTemp[STR_BUF_SIZE];  // temp buffer for scratch data
    char cOutputTemp[STR_BUF_SIZE];
    char szOutSecBuf[STR_BUF_SIZE];
    char szChallenge[STR_BUF_SIZE];
    char szISCChallengeResponse[STR_BUF_SIZE];   // Output buffer from ISC
    char szASCChallengeResponse[STR_BUF_SIZE];   // Output buffer from ASC

    // SSPI Interface tests

    ULONG PackageCount = 0;
    int i = 0;
    PSecPkgInfo pPackageInfo = NULL;
    PSecPkgInfo pPackageTmp = NULL;
    SECURITY_STATUS TmpStatus = STATUS_SUCCESS;
    HANDLE hClientToken = NULL;
    CredHandle ServerCred;
    CredHandle ClientCred;
    TimeStamp Lifetime;
    BOOL bServerCred = FALSE;
    BOOL bClientCred = FALSE;
    BOOL bRC = FALSE;


    ULONG ContextReqFlags = 0;
    ULONG ContextFlagsUtilized = 0;
    ULONG TargetDataRep = 0;
    ULONG ContextAttributes = 0;


    CtxtHandle OldContextHandle;
    CtxtHandle ServerCtxtHandle;
    CtxtHandle ClientCtxtHandle;

    SecBufferDesc InputBuffers;
    SecBufferDesc OutputBuffers;
    SecBuffer TempTokensIn[6];
    SecBuffer TempTokensOut[6];

    SecPkgContext_Names SecServerName;
    SecPkgCredentials_Names SecCredClientName;
    SecPkgContext_StreamSizes StreamSizes;
    TimeStamp SecContextExpiry;

    PCHAR pcPtr = NULL;
    int iLen = 0;

    STRING strChallenge;
    STRING strMethod;
    STRING strURL;
    STRING strHEntity;
    STRING strOutBuffer;

    UNICODE_STRING ustrUsername;
    UNICODE_STRING ustrPassword;
    UNICODE_STRING ustrDomain;
    STRING strTemp;

    ULONG ulMessSeqNo = 0;
    ULONG ulQOP = 0;

    SEC_WINNT_AUTH_IDENTITY_W AuthData;

    printf("Begining TESTB...\n");

    ZeroMemory(&ClientCred, sizeof(CredHandle));
    ZeroMemory(&ServerCred, sizeof(CredHandle));
    ZeroMemory(&OldContextHandle, sizeof(CtxtHandle));
    ZeroMemory(&ServerCtxtHandle, sizeof(CtxtHandle));
    ZeroMemory(&ClientCtxtHandle, sizeof(CtxtHandle));
    ZeroMemory(&SecServerName, sizeof(SecPkgContext_Names));
    ZeroMemory(&SecCredClientName, sizeof(SecPkgCredentials_Names));
    ZeroMemory(&SecContextExpiry, sizeof(SecContextExpiry));

    ZeroMemory(&ustrUsername, sizeof(ustrUsername));
    ZeroMemory(&ustrPassword, sizeof(ustrPassword));
    ZeroMemory(&ustrDomain, sizeof(ustrDomain));
    ZeroMemory(&strTemp, sizeof(strTemp));
    ZeroMemory(&StreamSizes, sizeof(StreamSizes));

    // Pull out any command line args
    if (argc > 1)
    {
        for (i = 1; i < argc; i++)
        {
            pcPtr = argv[i];
            if (*pcPtr == '-')
            {
                iLen = strlen(pcPtr);
                if (iLen >= 2)
                {
                    switch (*(pcPtr + 1))
                    {
                    case 'u':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrUsername, (pcPtr + 2));
                        break;
                    case 'd':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrDomain, (pcPtr + 2));
                        break;
                    case 'p':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrPassword, (pcPtr + 2));
                        break;
                    case '?':
                    default:
                        printf("Usage: %s -uUsername -pPassword -ddomain\n", argv[0]);
                        return(-1);
                        break;

                    }
                }
            }
        }
    }

    //
    // Get info about the security packages.
    //

    Status = EnumerateSecurityPackages( &PackageCount, &pPackageInfo );
    TmpStatus = GetLastError();

    if (!NT_SUCCESS(Status)) {
        printf( "FAILED:     EnumerateSecurityPackages failed: 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

      printf( "PackageCount: %ld\n", PackageCount );
      for ( i= 0; i< (int)PackageCount; i++)
      {
        pPackageTmp = (pPackageInfo + i);
        printf( "Name: %ws Comment: %ws\n", pPackageTmp->Name, pPackageTmp->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pPackageTmp->fCapabilities,
                pPackageTmp->wVersion,
                pPackageTmp->wRPCID,
                pPackageTmp->cbMaxToken );
      }

    //
    // Get info about the security packages.
    //

    Status = QuerySecurityPackageInfo( WDIGEST_SP_NAME, &pPackageInfo );
    TmpStatus = GetLastError();

    if (!NT_SUCCESS(Status)) {
        printf( "FAILED:    QuerySecurityPackageInfo failed:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

        printf( "Name: %ws Comment: %ws\n", pPackageInfo->Name, pPackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pPackageInfo->fCapabilities,
                pPackageInfo->wVersion,
                pPackageInfo->wRPCID,
                pPackageInfo->cbMaxToken );


    //
    // Acquire a credential handle for the server side
    //

    printf("Server  AcquireCredentialHandle\n");
    Status = AcquireCredentialsHandle(
                    NULL,           // New principal
                    WDIGEST_SP_NAME, // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &ServerCred,
                    &Lifetime );

    if (!NT_SUCCESS(Status)) {
        printf( "FAILED:    AcquireCredentialsHandle failed:  status 0x%x\n", Status);
        // TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = 0;
        ZeroMemory(&ServerCred, sizeof(CredHandle));
        goto CleanUp;
    }
    bServerCred = TRUE;
    MyPrintTime("Server ACH LifeTime: ", Lifetime);

    //
    // Acquire a credential handle for the client side
    //
    printf("Client  AcquireCredentialHandle\n");

    if (ustrUsername.Length || ustrPassword.Length || ustrDomain.Length)
    {
        printf("ACH Using supplied credentials\n");
        printf("      Username %wZ    Domain  %wZ    Password %wZ\n",
                &ustrUsername, &ustrDomain, &ustrPassword);

        ZeroMemory(&AuthData, sizeof(SEC_WINNT_AUTH_IDENTITY_W));
        AuthData.Domain = ustrDomain.Buffer;
        AuthData.DomainLength = ustrDomain.Length / sizeof(WCHAR);
        AuthData.Password = ustrPassword.Buffer;
        AuthData.PasswordLength = ustrPassword.Length / sizeof(WCHAR);
        AuthData.User = ustrUsername.Buffer;
        AuthData.UserLength = ustrUsername.Length / sizeof(WCHAR);
        AuthData.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        Status = AcquireCredentialsHandle(
                        NULL,  //  AUTH_USERNAME_W,           // get the creds for user digest
                        WDIGEST_SP_NAME, // Package Name
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        &AuthData,    // Make NULL not to use any AuthData for cred
                        NULL,
                        NULL,
                        &ClientCred,
                        &Lifetime );
    }
    else
    {
        printf("ACH Using default credentials\n");
        Status = AcquireCredentialsHandle(
                        NULL,  //  AUTH_USERNAME_W,           // get the creds for user digest
                        WDIGEST_SP_NAME, // Package Name
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &ClientCred,
                        &Lifetime );
    }

    if (!NT_SUCCESS(Status)) {
        printf( "FAILED:      AcquireCredentialsHandle failed:   status 0x%x\n", Status);
        // TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = 0;
        // ZeroMemory(&ClientCred, sizeof(CredHandle));
        goto CleanUp;
    }
    else
        bClientCred = TRUE;


        printf( "ClientCred: 0x%lx 0x%lx   ",
                ClientCred.dwLower, ClientCred.dwUpper );
        printf( "ServerCred: 0x%lx 0x%lx   \n",
                ServerCred.dwLower, ServerCred.dwUpper );
        MyPrintTime( "Client ACH Lifetime: ", Lifetime );


    // Big time - call Accept with no parameters to get a challenge


    StringAllocate(&strChallenge, 1);

    StringCharDuplicate(&strMethod, "GET");
    StringCharDuplicate(&strURL, AUTH_URI);
    StringAllocate(&strHEntity, NULL);

    StringAllocate(&strOutBuffer, 4000);


    // ZeroMemory(TempTokensIn, sizeof(TempTokensIn));
    // ZeroMemory(TempTokensOut, sizeof(TempTokensOut));
    ZeroMemory(&InputBuffers, sizeof(InputBuffers));
    ZeroMemory(&OutputBuffers, sizeof(OutputBuffers));


    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 5;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = 0;  // for NULL
    TempTokensIn[0].pvBuffer = NULL;
    TempTokensIn[1].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[1].cbBuffer = 0;  // for NULL
    TempTokensIn[1].pvBuffer = NULL;
    TempTokensIn[2].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[2].cbBuffer = 0;  // for NULL
    TempTokensIn[2].pvBuffer = NULL;
    TempTokensIn[3].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[3].cbBuffer = 0;  //  strHEntity.Length + 1;  // for NULL
    TempTokensIn[3].pvBuffer = NULL;  // strHEntity.Buffer;
    TempTokensIn[4].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[4].cbBuffer = 0; // (wcslen(AUTH_REALM_W) + 1) * sizeof(WCHAR);  //  Realm size count  to use for this challenge
    TempTokensIn[4].pvBuffer = NULL; //  AUTH_REALM_W;            // Realm to use for this challenge


    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = 0;      //   strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = NULL;   //   strOutBuffer.Buffer;

    ContextReqFlags = ASC_REQ_REPLAY_DETECT | ASC_REQ_CONNECTION | ASC_REQ_ALLOCATE_MEMORY;

    printf("ASC will create the output buffer\n");

    Status = AcceptSecurityContext(
                                   &ServerCred,
                                   NULL,
                                   &InputBuffers,
                                   ContextReqFlags,
                                   TargetDataRep,
                                   &ServerCtxtHandle,
                                   &OutputBuffers,
                                   &ContextAttributes,
                                   &Lifetime);

    if ((Status != SEC_I_CONTINUE_NEEDED) && 
        (Status != STATUS_SUCCESS))      // Indicates that this is the challenge
    {
        printf("FAILED:    SpAcceptLsaModeContext error   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    if (!OutputBuffers.pBuffers[0].pvBuffer && OutputBuffers.pBuffers[0].cbBuffer)
    {
        printf("FAILED:    SpAcceptLsaModeContext invalid output buffer pointer with length provided\n");
        Status = SEC_E_INTERNAL_ERROR;
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    ZeroMemory(szChallenge, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';
    strncpy(szChallenge, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    szChallenge[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    Status = FreeContextBuffer(OutputBuffers.pBuffers[0].pvBuffer);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:     FreeContextBuffer error:  status 0x%x\n", Status);
        TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    printf("Context Flags  Req  0x%lx    Ret 0x%lx\n", ContextReqFlags, ContextAttributes); 

    printf("Challenge Output Buffer is:\n%s\n\n", cOutputTemp);

    MyPrintTime("Server ASC LifeTime: ", Lifetime);

    printf("Now call the SSPI InitializeSecCtxt to generate the ChallengeResponse\n");


    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 3;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(szChallenge) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = szChallenge;
    TempTokensIn[1].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[1].cbBuffer = strMethod.Length + 1;  // for NULL
    TempTokensIn[1].pvBuffer = strMethod.Buffer;
    TempTokensIn[2].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[2].cbBuffer = 0;  //  strHEntity.Length + 1;  // for NULL
    TempTokensIn[2].pvBuffer = NULL;  // strHEntity.Buffer;


    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    ContextReqFlags = ISC_REQ_REPLAY_DETECT | ISC_REQ_CONNECTION;

    Status = InitializeSecurityContext(&ClientCred,
                                       NULL,
                                       AUTH_URI_W,
                                       ContextReqFlags,
                                       NULL,
                                       SECURITY_NATIVE_DREP,
                                       &InputBuffers,
                                       NULL,
                                       &ClientCtxtHandle,
                                       &OutputBuffers,
                                       &ContextFlagsUtilized,
                                       &Lifetime);


    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:      InitializeSecurityContext error:  status 0x%x\n", Status);
        TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    printf("InitializeSecurityContext SUCCEEDED with Context Handle (0x%x,0x%x)\n",
           ClientCtxtHandle.dwLower, ClientCtxtHandle.dwUpper );


    printf("Context Flags  Req  0x%lx    Ret 0x%lx\n", ContextReqFlags, ContextFlagsUtilized); 
    MyPrintTime("Client ISC LifeTime: ", Lifetime);

    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    ZeroMemory(szChallenge, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';
    strncpy(szISCChallengeResponse, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    szISCChallengeResponse[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    printf("\nISC: Challenge Response Output Buffer is\n%s\n\n", szISCChallengeResponse);

    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 5;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cOutputTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cOutputTemp;
    TempTokensIn[1].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[1].cbBuffer = strMethod.Length + 1;  // for NULL
    TempTokensIn[1].pvBuffer = strMethod.Buffer;
    TempTokensIn[2].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[2].cbBuffer = strURL.Length + 1;  // for NULL
    TempTokensIn[2].pvBuffer = strURL.Buffer;
    TempTokensIn[3].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[3].cbBuffer = 0;  //  strHEntity.Length + 1;  // for NULL
    TempTokensIn[3].pvBuffer = NULL;  // strHEntity.Buffer;
    TempTokensIn[4].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[4].cbBuffer = 0;                   //  Realm not used for challengeresponse
    TempTokensIn[4].pvBuffer = NULL;                //  not used for challengeresponse


    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer =  strOutBuffer.Buffer;

    ContextReqFlags = ASC_REQ_REPLAY_DETECT | ASC_REQ_CONNECTION;      // | ASC_REQ_ALLOCATE_MEMORY;


    printf("Calling the AcceptSC with a ChallengeResponse (should talk to the DC)!\n");
    Status = AcceptSecurityContext(
                                   &ServerCred,
                                   NULL,
                                   &InputBuffers,
                                   ContextReqFlags,
                                   TargetDataRep,
                                   &ServerCtxtHandle,
                                   &OutputBuffers,
                                   &ContextAttributes,
                                   &Lifetime);
                                   
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:      AcceptSecurityContext 2nd Call:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    strcpy(szASCChallengeResponse, (char *)InputBuffers.pBuffers[0].pvBuffer);

    printf("ASC has accepted the Challenge Resposne\n");

    printf("Now have a valid Security Context handle from ISC and ASC\n\n");

    printf("Context Flags  Req  0x%lx    Ret 0x%lx\n", ContextReqFlags, ContextAttributes);

    MyPrintTime("Server ASC LifeTime: ", Lifetime);


    Status = FreeContextBuffer(OutputBuffers.pBuffers[0].pvBuffer);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    FreeContextBuffer error:   status 0x%x\n", Status);
        TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    // Now get some info on the securitycontexts
    Status = QueryContextAttributes(&ServerCtxtHandle, SECPKG_ATTR_NAMES, &SecServerName);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    QueryContextAttributes error:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    if (SecServerName.sUserName)
    {
        printf("QueryContextAttributes reports that Username is %S\n", SecServerName.sUserName);
    }

    // Now get some info on the securitycontexts
    Status = QueryContextAttributes(&ServerCtxtHandle, SECPKG_ATTR_PASSWORD_EXPIRY, &SecContextExpiry);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    QueryContextAttributes error:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    MyPrintTime("QueryContextAttributes reports server context expires: ", SecContextExpiry);


    // Now get some info on the securitycontexts
    Status = QueryContextAttributes(&ServerCtxtHandle, SECPKG_ATTR_STREAM_SIZES, &StreamSizes);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    QueryContextAttributes SECPKG_ATTR_STREAM_SIZES error:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    printf("Server Context(StreamSizes): MaxBuf %lu   Blocksize %lu\n",
           StreamSizes.cbMaximumMessage, StreamSizes.cbBlockSize);

    // Now get some info on the securitycontexts
    Status = QueryCredentialsAttributes(&ClientCred, SECPKG_CRED_ATTR_NAMES, &SecCredClientName);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:  QueryCredentialAttributes error:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    if (SecCredClientName.sUserName)
    {
        printf("QueryCredentialAttributes reports that Username is %S\n", SecCredClientName.sUserName);
    }

    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 5;
    InputBuffers.pBuffers = TempTokensIn;

        // The first call to MakeSignature this represents the SECOND request on this Nonce!
    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = 0;     // strlen(szISCChallengeResponse) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = NULL;  //  szISCChallengeResponse;
    TempTokensIn[1].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[1].cbBuffer = strMethod.Length + 1;  // for NULL
    TempTokensIn[1].pvBuffer = strMethod.Buffer;
    TempTokensIn[2].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[2].cbBuffer = (strlen(AUTH_URI2) + 1) * sizeof(CHAR);  //  Realm size count  to use for this challenge
    TempTokensIn[2].pvBuffer = AUTH_URI2;            // Realm to use for this challenge
    TempTokensIn[3].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[3].cbBuffer = 0;   // strHEntity.Length + 1;  // for NULL
    TempTokensIn[3].pvBuffer = NULL;  //  strHEntity.Buffer;
    TempTokensIn[4].BufferType = SECBUFFER_PKG_PARAMS;             // There is no OutputBuffers
    TempTokensIn[4].cbBuffer = 4000;                               // So tack on another bufffer on end for output
    TempTokensIn[4].pvBuffer = szOutSecBuf;

    Status = MakeSignature(&ClientCtxtHandle,
                           ulQOP,
                           &InputBuffers,
                           0);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    MakeSignature error:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    printf("\nMakeSig: Challenge Response Output Buffer for 2nd message is\n%s\n", szOutSecBuf);


    // You now send Output buffer to Server - in this case the buffer is szOutSecBuf

    printf("Now verify that the 2nd message is Authenticate\n");

            // The First message to VerifySignature is the Input to the final call of ASC
    strcpy(cOutputTemp, szOutSecBuf);
    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cOutputTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cOutputTemp;

    Status = VerifySignature(&ServerCtxtHandle,
                             &InputBuffers,
                             ulMessSeqNo,
                             &ulQOP);                                   
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    VerifySignature 1st Call  error :  status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }
    printf("Now have a authenticated 1st message under context 0x%x !\n", ServerCtxtHandle);

    printf("VerifySig: Check if still OK: Output Buffer (Verify should not have modified it) is\n%s\n\n", cOutputTemp);

    Status = VerifySignature(&ServerCtxtHandle,
                             &InputBuffers,
                             ulMessSeqNo,
                             &ulQOP);                                   
    if (NT_SUCCESS(Status))
    {
        printf("FAILED:     VerifySignature 2nd Call  should not have succeeded  status 0x%x\n", Status);
        bPass = 0;
        goto CleanUp;
    }
    printf("Verified that replay does not work!!\n");

    goto CleanUp;



CleanUp:

    printf("Leaving NT Digest testb\n\n\n");

    if (pPackageInfo)
    {
        FreeContextBuffer(pPackageInfo);
    }

    if (SecServerName.sUserName)
    {
        FreeContextBuffer(SecServerName.sUserName);
    }

    if (SecCredClientName.sUserName)
    {
        FreeContextBuffer(SecCredClientName.sUserName);
    }



    printf("About to call deletesecuritycontext\n");

    //
    // Free the security context handle
    //
    if (ServerCtxtHandle.dwLower || ServerCtxtHandle.dwUpper)
    {
        Status = DeleteSecurityContext(&ServerCtxtHandle);
        if (!NT_SUCCESS(Status))
        {
            printf("ERROR:  DeleteSecurityContext ServerCtxtHandle failed: ");
            PrintStatus(Status);
        }
    }

    if (ClientCtxtHandle.dwLower || ClientCtxtHandle.dwUpper)
    {
        Status = DeleteSecurityContext(&ClientCtxtHandle);
        if (!NT_SUCCESS(Status))
        {
            printf("ERROR:  DeleteSecurityContext ClientCtxtHandle failed: ");
            PrintStatus(Status);
        }
    }
    //
    // Free the credential handles
    //

    printf("Now calling to Free the ServerCred\n");
    if (bServerCred)
    {
        Status = FreeCredentialsHandle( &ServerCred );

        if (!NT_SUCCESS(Status))
        {
            printf( "FreeCredentialsHandle failed for ServerCred: " );
            PrintStatus(Status);
        }
    }

    printf("Now calling to Free the ServerCred\n");
    if (bClientCred)
    {
        Status = FreeCredentialsHandle(&ClientCred);

        if (!NT_SUCCESS(Status))
        {
            printf( "FreeCredentialsHandle failed for ClientCred: " );
            PrintStatus( Status );
        }
    }

    StringFree(&strChallenge);
    StringFree(&strMethod);
    StringFree(&strURL);
    StringFree(&strHEntity);
    StringFree(&strOutBuffer);


    if (bPass != 1)
    {
        printf("FAILED test run with one or more tests failing.\n");
    }
    else
    {
        printf("All tests passed.\n");
    }

    return 0;
}


void
PrintStatus(
    SECURITY_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = 0x%lx",NetStatus );

    switch (NetStatus) {

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;
    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;
    case SEC_I_CONTINUE_NEEDED:
        printf( " SEC_I_CONTINUE_NEEDED" ); break;
    }

    printf( "\n" );
}



void
MyPrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;
    NTSTATUS Status;

    printf( "%s  High/low 0x%x/0x%x:    ", Comment,  ConvertTime.HighPart, ConvertTime.LowPart);

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( (ConvertTime.HighPart == 0x7FFFFFFF) && (ConvertTime.LowPart == 0xFFFFFFFF) ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        LocalTime.HighPart = 0;
        LocalTime.LowPart = 0;

        Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
        if (!NT_SUCCESS( Status )) {
            printf( "Can't convert time from GMT to Local time\n" );
            LocalTime = ConvertTime;
        }

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}




// Support Routines


//+-------------------------------------------------------------------------
//
//  Function:   StringAllocate
//
//  Synopsis:   Allocates cb chars to STRING Buffer
//
//  Arguments:  pString - pointer to String to allocate memory to
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
StringAllocate(
    IN PSTRING pString,
    IN USHORT cb
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringAllocate\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    cb = cb + 1;   // Add in extra room for the terminating NULL

    if (ARGUMENT_PRESENT(pString))
    {
        pString->Length = 0;

        pString->Buffer = (char *)DigestAllocateMemory((ULONG)(cb * sizeof(CHAR)));
        if (pString->Buffer)
        {
            pString->MaximumLength = cb;
        }
        else
        {
            pString->MaximumLength = 0;
            Status = STATUS_NO_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

CleanUp:
    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringAllocate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringFree
//
//  Synopsis:   Clears a String and releases the memory
//
//  Arguments:  pString - pointer to String to clear
//
//  Returns:    SEC_E_OK - released memory succeeded
//
//  Requires:
//
//  Effects:    de-allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
StringFree(
    IN PSTRING pString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringFree\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pString) &&
        (pString->Buffer != NULL))
    {
        DigestFreeMemory(pString->Buffer);
        pString->Length = 0;
        pString->MaximumLength = 0;
        pString->Buffer = NULL;
    }

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringFree\n"));
    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   StringCharDuplicate
//
//  Synopsis:   Duplicates a NULL terminated char. If the source string buffer is
//              NULL the destionation will be too.
//
//  Arguments:  Destination - Receives a copy of the source NULL Term char *
//              czSource - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCharDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cbSourceCz = 0;

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(czSource)) &&
        ((cbSourceCz = strlen(czSource)) != 0))
    {

        DestinationString->Buffer = (LPSTR) DigestAllocateMemory(cbSourceCz + sizeof(CHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = cbSourceCz;
            DestinationString->MaximumLength = cbSourceCz + sizeof(CHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                czSource,
                cbSourceCz
                );

            DestinationString->Buffer[cbSourceCz/sizeof(CHAR)] = '\0';
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            // DebugLog((DEB_ERROR, "NTDigest: StringCharDuplicate, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringCharDuplicate\n"));
    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   DigestAllocateMemory
//
//  Synopsis:   Allocate memory in either lsa mode or user mode
//
//  Effects:    Allocated chunk is zeroed out
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PVOID
DigestAllocateMemory(
    IN ULONG BufferSize
    )
{
    PVOID Buffer = NULL;
    // DebugLog((DEB_TRACE, "Entering DigestAllocateMemory\n"));

        Buffer = LocalAlloc(LPTR, BufferSize);

    // DebugLog((DEB_TRACE, "Leaving DigestAllocateMemory\n"));
    return Buffer;
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmFree
//
//  Synopsis:   Free memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
DigestFreeMemory(
    IN PVOID Buffer
    )
{
    // DebugLog((DEB_TRACE, "Entering DigestFreeMemory\n"));

            LocalFree(Buffer);

    // DebugLog((DEB_TRACE, "Leaving DigestFreeMemory\n"));
}

/*

//+-------------------------------------------------------------------------
//
//  Function:   DecodeUnicodeString
//
//  Synopsis:   Convert an encoded string into Unicode 
//
//  Arguments:  pstrSource - pointer to String with encoded input
//              
//              pustrDestination - pointer to a destination Unicode string
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets UNICODE_STRING sizes
//
//  Notes:  Must call UnicodeStringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
DecodeUnicodeString(
    IN PSTRING pstrSource,
    IN UINT CodePage,
    OUT PUNICODE_STRING pustrDestination
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    int      cNumWChars = 0;     // number of wide characters
    int      cb = 0;      // number of bytes to allocate
    int      iRC = 0;     // return code
    DWORD    dwError = 0;

    // Handle case if there is no characters to convert
    if (!pstrSource->Length)
    {
         pustrDestination->Length = 0;
         pustrDestination->MaximumLength = 0;
         pustrDestination->Buffer = NULL;
         goto CleanUp;
    }

    // Determine number of characters needed in unicode string
    cNumWChars = MultiByteToWideChar(CodePage,
                              0,
                              pstrSource->Buffer,
                              pstrSource->Length,
                              NULL,
                              0);
    if (cNumWChars <= 0)
    {
        Status = E_FAIL;
        dwError = GetLastError();
        goto CleanUp;
    }

    Status = UnicodeStringAllocate(pustrDestination, (USHORT)cNumWChars);
    if (!NT_SUCCESS(Status))
    {
        goto CleanUp;
    }

    // We now have the space allocated so convert encoded unicode
    iRC = MultiByteToWideChar(CodePage,
                              0,
                              pstrSource->Buffer,
                              pstrSource->Length,
                              pustrDestination->Buffer,
                              cNumWChars);
    if (iRC == 0)
    {
        UnicodeStringFree(pustrDestination);    // Free up allocation on error
        Status = E_FAIL;
        dwError = GetLastError();
        goto CleanUp;
    }

    // decoding successful set size of unicode string

    pustrDestination->Length = (USHORT)(iRC * sizeof(WCHAR));


CleanUp:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringDuplicate
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too. Assumes Destination has
//              no string info (called ClearUnicodeString)
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with DigestAllocateMemory
//
//  Notes:      will add a NULL character to resulting UNICODE_STRING
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringDuplicate(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering DuplicateUnicodeString\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {

        DestinationString->Buffer = (LPWSTR) DigestAllocateMemory(SourceString->Length + sizeof(WCHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + sizeof(WCHAR);
            RtlCopyMemory(
                         DestinationString->Buffer,
                         SourceString->Buffer,
                         SourceString->Length
                         );

            DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving UnicodeStringDuplicate\n"));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringAllocate
//
//  Synopsis:   Allocates cb wide chars to STRING Buffer
//
//  Arguments:  pString - pointer to String to allocate memory to
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringAllocate(
    IN PUNICODE_STRING pString,
    IN USHORT cNumWChars
    )
{
    // DebugLog((DEB_TRACE, "Entering UnicodeStringAllocate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cb = 0;

    cb = cNumWChars + 1;   // Add in extra room for the terminating NULL

    cb = cb * sizeof(WCHAR);    // now convert to wide characters


    if (ARGUMENT_PRESENT(pString))
    {
        pString->Length = 0;

        pString->Buffer = (PWSTR)DigestAllocateMemory((ULONG)(cb));
        if (pString->Buffer)
        {
            pString->MaximumLength = cb;    // this value is in terms of bytes not WCHAR count
        }
        else
        {
            pString->MaximumLength = 0;
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

CleanUp:
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringClear
//
//  Synopsis:   Clears a UnicodeString and releases the memory
//
//  Arguments:  pString - pointer to UnicodeString to clear
//
//  Returns:    SEC_E_OK - released memory succeeded
//
//  Requires:
//
//  Effects:    de-allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringFree(
    OUT PUNICODE_STRING pString
    )
{

    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pString) &&
        (pString->Buffer != NULL))
    {
        DigestFreeMemory(pString->Buffer);
        pString->Length = 0;
        pString->MaximumLength = 0;
        pString->Buffer = NULL;
    }

    return(Status);

}


*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\util.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        ntdigestutil.cxx
//
// Contents:    Utility functions for NtDigest package:
//                UnicodeStringDuplicate
//                SidDuplicate
//                DigestAllocateMemory
//                DigestFreeMemory
//
//
// History:     KDamour  15Mar00   Stolen from NTLM ntlmutil.cxx
//
//------------------------------------------------------------------------
#include "global.h"

#include <stdio.h>
#include <malloc.h>
#include <des.h>


//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringDuplicate
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too. Assumes Destination has
//              no string info (called ClearUnicodeString)
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with DigestAllocateMemory
//
//  Notes:      will add a NULL character to resulting UNICODE_STRING
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringDuplicate(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering DuplicateUnicodeString\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(!DestinationString->Buffer);   // catch any memory leaks

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {
        DestinationString->Buffer = (LPWSTR) DigestAllocateMemory(SourceString->Length + sizeof(WCHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + sizeof(WCHAR);
            RtlCopyMemory(
                         DestinationString->Buffer,
                         SourceString->Buffer,
                         SourceString->Length
                         );

            DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "NTDigest: UnicodeStringDuplicate, Allocate returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving UnicodeStringDuplicate\n"));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringCopy
//
//  Synopsis:   Copies a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too. If there is enough room
//              in the destination, no new memory will be allocated
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    no allocation of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringCopy(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCopy\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    // DestinationString->Buffer = NULL;
    // DestinationString->Length = 0;
    // DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL) &&
        (SourceString->Length))
    {

        if ((DestinationString->Buffer != NULL) &&
            (DestinationString->MaximumLength >= (SourceString->Length + sizeof(WCHAR))))
        {

            DestinationString->Length = SourceString->Length;
            RtlCopyMemory(
                DestinationString->Buffer,
                SourceString->Buffer,
                SourceString->Length
                );

            DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            DestinationString->Length = 0;
            DebugLog((DEB_ERROR, "UnicodeStringCopy: DestinationString not enough space\n"));
            goto CleanUp;
        }
    }
    else
    {   // Indicate that there is no content in this string
        DestinationString->Length = 0;
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringDuplicate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeDuplicatePassword
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.  The MaximumLength contains
//              room for encryption padding data.
//
//  Effects:    allocates memory with LsaFunctions.AllocatePrivateHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "Entering UnicodeDuplicatePassword\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(DestinationString);
    ASSERT(!DestinationString->Buffer);   // catch any memory leaks

    DestinationString->Buffer = NULL;
    DestinationString->Length =
                        DestinationString->MaximumLength =
                        0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {
        USHORT PaddingLength;

        PaddingLength = DESX_BLOCKLEN - (SourceString->Length % DESX_BLOCKLEN);

        if( PaddingLength == DESX_BLOCKLEN )
        {
            PaddingLength = 0;
        }

        DestinationString->Buffer = (LPWSTR) DigestAllocateMemory(
                                                    SourceString->Length +
                                                    PaddingLength
                                                    );

        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + PaddingLength;

            if( DestinationString->MaximumLength == SourceString->MaximumLength )
            {
                //
                // duplicating an already padded buffer -- pickup the original
                // pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->MaximumLength
                    );
            } else {

                //
                // duplicating an unpadded buffer -- pickup only the string
                // and fill the rest with the boot time pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->Length
                    );
            }

        }
        else
        {
            Status = STATUS_NO_MEMORY;
            DebugLog((DEB_ERROR, "UnicodeDuplicatePassword, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "Entering UnicodeDuplicatePassword\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringAllocate
//
//  Synopsis:   Allocates cb wide chars to STRING Buffer
//
//  Arguments:  pString - pointer to String to allocate memory to
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringAllocate(
    IN PUNICODE_STRING pString,
    IN USHORT cNumWChars
    )
{
    // DebugLog((DEB_TRACE, "Entering UnicodeStringAllocate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cb = 0;

    ASSERT(pString);
    ASSERT(!pString->Buffer);

    cb = cNumWChars + 1;   // Add in extra room for the terminating NULL

    cb = cb * sizeof(WCHAR);    // now convert to wide characters


    if (ARGUMENT_PRESENT(pString))
    {
        pString->Length = 0;

        pString->Buffer = (PWSTR)DigestAllocateMemory((ULONG)(cb));
        if (pString->Buffer)
        {
            pString->MaximumLength = cb;    // this value is in terms of bytes not WCHAR count
        }
        else
        {
            pString->MaximumLength = 0;
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

CleanUp:
    // DebugLog((DEB_TRACE, "Leaving UnicodeStringAllocate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringClear
//
//  Synopsis:   Clears a UnicodeString and releases the memory
//
//  Arguments:  pString - pointer to UnicodeString to clear
//
//  Returns:    SEC_E_OK - released memory succeeded
//
//  Requires:
//
//  Effects:    de-allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringFree(
    OUT PUNICODE_STRING pString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering UnicodeStringClear\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pString) &&
        (pString->Buffer != NULL))
    {
        DigestFreeMemory(pString->Buffer);
        pString->Length = 0;
        pString->MaximumLength = 0;
        pString->Buffer = NULL;
    }

    // DebugLog((DEB_TRACE, "NTDigest: Leaving UnicodeStringClear\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringVerify
//
//  Synopsis:   If STRING length non-zero, Buffer exist
//
//  Arguments:  pString - pointer to String to check
//
//  Returns:    STATUS_SUCCESS - released memory succeeded
//              STATUS_INVALID_PARAMETER - String bad format
//
//  Requires:
//
//  Effects:
//
//  Notes: If Strings are created properly, this should never fail
//
//--------------------------------------------------------------------------
NTSTATUS
StringVerify(
    OUT PSTRING pString
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!pString)
    {
        return STATUS_INVALID_PARAMETER;
    }
        // If there is a length, buffer must exist
        // MaxSize can not be smaller than string length
    if (pString->Length &&
        (!pString->Buffer ||
         (pString->MaximumLength < pString->Length)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------------
//
//  Function:   StringDuplicate
//
//  Synopsis:   Duplicates a STRING. If the source string buffer is
//              NULL the destionation will be too.
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(DestinationString);
    ASSERT(!DestinationString->Buffer);   // catch any memory leaks

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {
        DestinationString->Buffer = (LPSTR) DigestAllocateMemory(
                       SourceString->Length + sizeof(CHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + sizeof(CHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                SourceString->Buffer,
                SourceString->Length
                );

            DestinationString->Buffer[SourceString->Length/sizeof(CHAR)] = '\0';
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "NTDigest: StringDuplicate, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringDuplicate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringCopy
//
//  Synopsis:   Copies a STRING. If the source string buffer is
//              NULL the destionation will be too. If there is enough room
//              in the destination, no new memory will be allocated
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    no allocation of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringCopy(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCopy\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    // DestinationString->Buffer = NULL;
    // DestinationString->Length = 0;
    // DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL) &&
        (SourceString->Length))
    {

        if ((DestinationString->Buffer != NULL) &&
            (DestinationString->MaximumLength >= (SourceString->Length + sizeof(CHAR))))
        {

            DestinationString->Length = SourceString->Length;
            RtlCopyMemory(
                DestinationString->Buffer,
                SourceString->Buffer,
                SourceString->Length
                );

            DestinationString->Buffer[SourceString->Length/sizeof(CHAR)] = '\0';
        }
        else
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            DestinationString->Length = 0;
            DebugLog((DEB_ERROR, "StringCopy: DestinationString not enough space\n"));
            goto CleanUp;
        }
    }
    else
    {   // Indicate that there is no content in this string
        DestinationString->Length = 0;
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringDuplicate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringReference
//
//  Synopsis:   Reference the source string to the destination.  No memory allocated
//
//  Arguments:  DestinationString - Receives a reference of the source string
//              SourceString - String to reference
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    no allocation of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringReference(
    OUT PSTRING pDestinationString,
    IN  PSTRING pSourceString
    )
{
    if (!pDestinationString || !pSourceString)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // This will only create a reference - no string buffer memory actually copied
    memcpy(pDestinationString, pSourceString, sizeof(STRING));

    return STATUS_SUCCESS; 
}



//+-------------------------------------------------------------------------
//
//  Function:   StringCharDuplicate
//
//  Synopsis:   Duplicates a NULL terminated char. If the source string buffer is
//              NULL the destionation will be too.
//
//  Arguments:  Destination - Receives a copy of the source NULL Term char *
//              czSource - String to copy
//              uCnt - number of characters to copy over (0 if copy until NULL)
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource,
    IN OPTIONAL USHORT uCnt
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCharDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cbSourceCz = 0;

    //ASSERT(DestinationString);
    //ASSERT(!DestinationString->Buffer);  // catch any memory leaks

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    // If uCnt specified then use that as max length, otherwise locate NULL terminator
    if (uCnt)
    {
        cbSourceCz = uCnt;
    }
    else
    {
        cbSourceCz = strlen(czSource);
    }

    if ((ARGUMENT_PRESENT(czSource)) &&
        (cbSourceCz != 0))
    {
        DestinationString->Buffer = (LPSTR) DigestAllocateMemory(cbSourceCz + sizeof(CHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = cbSourceCz;
            DestinationString->MaximumLength = cbSourceCz + sizeof(CHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                czSource,
                cbSourceCz
                );
            // Since AllocateMemory zeroes out buffer, already NULL terminated
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "NTDigest: StringCharDuplicate, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringCharDuplicate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringCharDuplicate
//
//  Synopsis:   Duplicates a NULL terminated char. If the source string buffer is
//              NULL the destionation will be too.
//
//  Arguments:  Destination - Receives a copy of the source NULL Term char *
//              czSource - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringWCharDuplicate(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL WCHAR *szSource
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCharDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cbSourceSz = 0;

    ASSERT(DestinationString);
    ASSERT(!DestinationString->Buffer);   // catch any memory leaks

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(szSource)) &&
        ((cbSourceSz = (USHORT)wcslen(szSource)) != 0))
    {

        DestinationString->Buffer = (PWSTR) DigestAllocateMemory((cbSourceSz * sizeof(WCHAR)) + sizeof(WCHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = (cbSourceSz * sizeof(WCHAR));
            DestinationString->MaximumLength = ((cbSourceSz * sizeof(WCHAR)) + sizeof(WCHAR));    // Account for NULL WCHAR at end
            RtlCopyMemory(
                DestinationString->Buffer,
                szSource,
                (cbSourceSz * sizeof(WCHAR))
                );

            DestinationString->Buffer[cbSourceSz] = '\0';
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "NTDigest: StringCharDuplicate, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringCharDuplicate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringReference
//
//  Synopsis:   Reference the source unicode_string to the destination.  No memory allocated
//
//  Arguments:  DestinationString - Receives a reference of the source string
//              SourceString - String to reference
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    no allocation of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringReference(
    OUT PUNICODE_STRING pDestinationString,
    IN  PUNICODE_STRING pSourceString
    )
{
    if (!pDestinationString || !pSourceString)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // This will only create a reference - no string buffer memory actually copied
    memcpy(pDestinationString, pSourceString, sizeof(UNICODE_STRING));

    return STATUS_SUCCESS; 
}




//+-------------------------------------------------------------------------
//
//  Function:   DecodeUnicodeString
//
//  Synopsis:   Convert an encoded string into Unicode 
//
//  Arguments:  pstrSource - pointer to String with encoded input
//              
//              pustrDestination - pointer to a destination Unicode string
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets UNICODE_STRING sizes
//
//  Notes:  Must call UnicodeStringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
DecodeUnicodeString(
    IN PSTRING pstrSource,
    IN UINT CodePage,
    OUT PUNICODE_STRING pustrDestination
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    int      cNumWChars = 0;     // number of wide characters
    int      cb = 0;      // number of bytes to allocate
    int      iRC = 0;     // return code
    DWORD    dwError = 0;

    // Handle case if there is no characters to convert
    if (!pstrSource->Length)
    {
         pustrDestination->Length = 0;
         pustrDestination->MaximumLength = 0;
         pustrDestination->Buffer = NULL;
         goto CleanUp;
    }

    // Determine number of characters needed in unicode string
    cNumWChars = MultiByteToWideChar(CodePage,
                              0,
                              pstrSource->Buffer,
                              pstrSource->Length,
                              NULL,
                              0);
    if (cNumWChars <= 0)
    {
        Status = E_FAIL;
        dwError = GetLastError();
        DebugLog((DEB_ERROR, "DecodeUnicodeString: failed to determine wchar count  error 0x%x\n", dwError));
        goto CleanUp;
    }

    Status = UnicodeStringAllocate(pustrDestination, (USHORT)cNumWChars);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DecodeUnicodeString: Failed Unicode allocation\n"));
        goto CleanUp;
    }

    // We now have the space allocated so convert encoded unicode
    iRC = MultiByteToWideChar(CodePage,
                              0,
                              pstrSource->Buffer,
                              pstrSource->Length,
                              pustrDestination->Buffer,
                              cNumWChars);
    if (iRC == 0)
    {
        UnicodeStringFree(pustrDestination);    // Free up allocation on error
        Status = E_FAIL;
        dwError = GetLastError();
        DebugLog((DEB_ERROR, "DecodeUnicodeString: failed to decode source string  error 0x%x\n", dwError));
        goto CleanUp;
    }

    // decoding successful set size of unicode string

    pustrDestination->Length = (USHORT)(iRC * sizeof(WCHAR));

    //DebugLog((DEB_TRACE, "DecodeUnicodeString: string (%Z) is unicode (%wZ)\n", pstrSource, pustrDestination));
    //DebugLog((DEB_TRACE, "DecodeUnicodeString: unicode length %d   maxlength %d\n", 
              //pustrDestination->Length, pustrDestination->MaximumLength));

CleanUp:

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   EncodeUnicodeString
//
//  Synopsis:   Encode a Unicode string into a charset string 
//
//  Arguments:  pustrSource - pointer to Unicode_String with  input
//              
//              pstrDestination - pointer to a destination encoded string
//
//              pfUsedDefaultChar - pointer to BOOL if default character had to be used since
//                  the Source contains characters outside the character set specified
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
EncodeUnicodeString(
    IN PUNICODE_STRING pustrSource,
    IN UINT CodePage,
    OUT PSTRING pstrDestination,
    IN OUT PBOOL pfUsedDefaultChar
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int      cNumChars = 0;     // number of wide characters
    int      iRC = 0;     // return code
    DWORD    dwError = 0;
    PBOOL    pfUsedDef = NULL;
    DWORD    dwFlags = 0;

    // Handle case if there is no characters to convert
    if (!pustrSource->Length)
    {
         pstrDestination->Length = 0;
         pstrDestination->MaximumLength = 0;
         pstrDestination->Buffer = NULL;
         goto CleanUp;
    }

    // If UTF-8 then do not allow default char mapping (ref MSDN)
    if (CodePage != CP_UTF8)
    {
        pfUsedDef = pfUsedDefaultChar;
        dwFlags = WC_NO_BEST_FIT_CHARS;
    }

    // Determine number of characters needed in unicode string
    cNumChars = WideCharToMultiByte(CodePage,
                                      dwFlags,
                                      pustrSource->Buffer,
                                      (pustrSource->Length / sizeof(WCHAR)),
                                      NULL,
                                      0,
                                      NULL,
                                      NULL);
    if (cNumChars <= 0)
    {
        Status = E_FAIL;
        dwError = GetLastError();
        DebugLog((DEB_ERROR, "EncodeUnicodeString: failed to determine char count  error 0x%x\n", dwError));
        goto CleanUp;
    }

    Status = StringAllocate(pstrDestination, (USHORT)cNumChars);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "EncodeUnicodeString: Failed String allocation\n"));
        goto CleanUp;
    }

    // We now have the space allocated so convert to encoded unicode
    iRC = WideCharToMultiByte(CodePage,
                              dwFlags,
                              pustrSource->Buffer,
                              (pustrSource->Length / sizeof(WCHAR)),
                              pstrDestination->Buffer,
                              cNumChars,
                              NULL,
                              pfUsedDef);
    if (iRC == 0)
    {
        Status = E_FAIL;
        dwError = GetLastError();
        DebugLog((DEB_ERROR, "EncodeUnicodeString: failed to decode source string  error 0x%x\n", dwError));
        StringFree(pstrDestination);    // Free up allocation on error
        goto CleanUp;
    }

    // decoding successful set size of unicode string

    pstrDestination->Length = (USHORT)iRC;

CleanUp:

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   StringFree
//
//  Synopsis:   Clears a String and releases the memory
//
//  Arguments:  pString - pointer to String to clear
//
//  Returns:    SEC_E_OK - released memory succeeded
//
//  Requires:
//
//  Effects:    de-allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
StringFree(
    IN PSTRING pString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringFree\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pString) &&
        (pString->Buffer != NULL))
    {
        DigestFreeMemory(pString->Buffer);
        pString->Length = 0;
        pString->MaximumLength = 0;
        pString->Buffer = NULL;
    }

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringFree\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringAllocate
//
//  Synopsis:   Allocates cb chars to STRING Buffer
//
//  Arguments:  pString - pointer to String to allocate memory to
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
StringAllocate(
    IN PSTRING pString,
    IN USHORT cb
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringAllocate\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(pString);
    ASSERT(!pString->Buffer);   // catch any memory leaks

    cb = cb + 1;   // Add in extra room for the terminating NULL

    if (ARGUMENT_PRESENT(pString))
    {
        pString->Length = 0;

        pString->Buffer = (char *)DigestAllocateMemory((ULONG)(cb * sizeof(CHAR)));
        if (pString->Buffer)
        {
            pString->MaximumLength = cb;
        }
        else
        {
            pString->MaximumLength = 0;
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

CleanUp:
    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringAllocate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   SidDuplicate
//
//  Synopsis:   Duplicates a SID
//
//  Arguments:  DestinationSid - Receives a copy of the SourceSid
//              SourceSid - SID to copy
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate memory
//                  failed
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
SidDuplicate(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering SidDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SidSize;

    // ASSERT(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);

    *DestinationSid = (PSID) DigestAllocateMemory( SidSize );

    if (ARGUMENT_PRESENT(*DestinationSid))
    {
        RtlCopyMemory(
            *DestinationSid,
            SourceSid,
            SidSize
            );
    }
    else
    {
        Status =  STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "NTDigest: SidDuplicate, DigestAllocateMemory returns NULL\n"));
        goto CleanUp;
    }

CleanUp:
    // DebugLog((DEB_TRACE, "NTDigest: Leaving SidDuplicate\n"));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   DigestAllocateMemory
//
//  Synopsis:   Allocate memory in either lsa mode or user mode
//
//  Effects:    Allocated chunk is zeroed out
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PVOID
DigestAllocateMemory(
    IN ULONG BufferSize
    )
{
    PVOID Buffer = NULL;
    // DebugLog((DEB_TRACE, "Entering DigestAllocateMemory\n"));

    if (g_NtDigestState == NtDigestLsaMode)
    {
        Buffer = g_LsaFunctions->AllocateLsaHeap(BufferSize);
        if (Buffer != NULL)
        {
            RtlZeroMemory(Buffer, BufferSize);
        }
        DebugLog((DEB_TRACE_MEM, "Memory: LSA alloc %lu bytes at 0x%x\n", BufferSize, Buffer ));
    }
    else
    {
        ASSERT(g_NtDigestState == NtDigestUserMode);
        Buffer = LocalAlloc(LPTR, BufferSize);
        DebugLog((DEB_TRACE_MEM, "Memory: Local alloc %lu bytes at 0x%x\n", BufferSize, Buffer ));
    }

    // DebugLog((DEB_TRACE, "Leaving DigestAllocateMemory\n"));
    return Buffer;
}



//+-------------------------------------------------------------------------
//
//  Function:   DigestFreeMemory
//
//  Synopsis:   Free memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
DigestFreeMemory(
    IN PVOID Buffer
    )
{
    // DebugLog((DEB_TRACE, "Entering DigestFreeMemory\n"));

    if (ARGUMENT_PRESENT(Buffer))
    {
        if (g_NtDigestState == NtDigestLsaMode)
        {
            DebugLog((DEB_TRACE_MEM, "DigestFreeMemory: LSA free at 0x%x\n", Buffer ));
            g_LsaFunctions->FreeLsaHeap(Buffer);
        }
        else
        {
            ASSERT(g_NtDigestState == NtDigestUserMode);
            DebugLog((DEB_TRACE_MEM, "DigestFreeMemory: Local free at 0x%x\n", Buffer ));
            LocalFree(Buffer);
        }
    }

    // DebugLog((DEB_TRACE, "Leaving DigestFreeMemory\n"));
}




// Helper functions
/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - binary data to convert
    cSrc - length of binary data
    pDst - buffer receiving ASCII representation of pSrc

Return Value:

    Nothing

--*/
VOID
BinToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )
{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( UINT x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}

/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - ASCII data to convert to binary
    cSrc - length of ASCII data
    pDst - buffer receiving binary representation of pSrc

Return Value:

    Nothing

--*/
VOID
HexToBin(
    LPSTR  pSrc,
    UINT   cSrc,
    LPBYTE pDst
    )
{
#define TOBIN(a) ((a)>='a' ? (a)-'a'+10 : (a)-'0')

    for ( UINT x = 0, y = 0 ; x < cSrc ; x = x + 2 )
    {
        BYTE v;
        v = TOBIN(pSrc[x])<<4;
        pDst[y++] = v + TOBIN(pSrc[x+1]);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   CopyClientString
//
//  Synopsis:   copies a client string to local memory, including
//              allocating space for it locally.
//
//  Arguments:
//              SourceString  - Could be Ansi or Wchar in client process
//              SourceLength  - bytes
//              DoUnicode     - whether the string is Wchar
//
//  Returns:
//              DestinationString - Unicode String in Lsa Process
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
CopyClientString(
    IN PWSTR SourceString,
    IN ULONG SourceLength,
    IN BOOLEAN DoUnicode,
    OUT PUNICODE_STRING DestinationString
    )
{
    // DebugLog((DEB_TRACE,"NTDigest: Entering CopyClientString\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    STRING TemporaryString;
    ULONG SourceSize = 0;
    ULONG CharacterSize = sizeof(CHAR);

    ASSERT(DestinationString);
    ASSERT(!DestinationString->Buffer);    

    //
    // First initialize the string to zero, in case the source is a null
    // string
    //

    DestinationString->Length = DestinationString->MaximumLength = 0;
    DestinationString->Buffer = NULL;
    TemporaryString.Buffer = NULL;


    if (SourceString != NULL)
    {

        //
        // If the length is zero, allocate one byte for a "\0" terminator
        //

        if (SourceLength == 0)
        {
            DestinationString->Buffer = (LPWSTR) DigestAllocateMemory(sizeof(WCHAR));
            if (DestinationString->Buffer == NULL)
            {
                DebugLog((DEB_ERROR,"CopyClientString, Error from DigestAllocate is 0x%lx\n", Status));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            DestinationString->MaximumLength = sizeof(WCHAR);
            *DestinationString->Buffer = L'\0';

        }
        else
        {
            //
            // Allocate a temporary buffer to hold the client string. We may
            // then create a buffer for the unicode version. The length
            // is the length in characters, so  possible expand to hold unicode
            // characters and a null terminator.
            //

            if (DoUnicode)
            {
                CharacterSize = sizeof(WCHAR);
            }

            SourceSize = (SourceLength + 1) * CharacterSize;

            //
            // insure no overflow aggainst UNICODE_STRING
            //

            if ( (SourceSize > 0xFFFF) ||
                 ((SourceSize - CharacterSize) > 0xFFFF)
                 )
            {
                Status = STATUS_INVALID_PARAMETER;
                DebugLog((DEB_ERROR,"CopyClientString: SourceSize is too large\n"));
                goto Cleanup;
            }


            TemporaryString.Buffer = (LPSTR) DigestAllocateMemory(SourceSize);
            if (TemporaryString.Buffer == NULL)
            {
                Status = SEC_E_INSUFFICIENT_MEMORY;
                DebugLog((DEB_ERROR,"CopyClientString: Error from DigestAllocate is 0x%lx\n", Status));
                goto Cleanup;
            }
            TemporaryString.Length = (USHORT) (SourceSize - CharacterSize);
            TemporaryString.MaximumLength = (USHORT) SourceSize;


            //
            // Finally copy the string from the client
            //

            Status = g_LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            SourceSize - CharacterSize,
                            TemporaryString.Buffer,
                            SourceString
                            );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"CopyClientString: Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto Cleanup;
            }

            //
            // If we are doing unicode, finish up now
            //
            if (DoUnicode)
            {
                DestinationString->Buffer = (LPWSTR) TemporaryString.Buffer;
                DestinationString->Length = (USHORT) (SourceSize - CharacterSize);
                DestinationString->MaximumLength = (USHORT) SourceSize;
            }
            else
            {
                NTSTATUS Status1;
                Status1 = RtlAnsiStringToUnicodeString(
                            DestinationString,
                            &TemporaryString,
                            TRUE
                            );      // allocate destination
                if (!NT_SUCCESS(Status1))
                {
                    Status = SEC_E_INSUFFICIENT_MEMORY;
                    DebugLog((DEB_ERROR,"CopyClientString: Error from RtlAnsiStringToUnicodeString is 0x%lx\n", Status));
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:

    if (TemporaryString.Buffer != NULL)
    {
        //
        // Free this if we failed and were doing unicode or if we weren't
        // doing unicode
        //

        if ((DoUnicode && !NT_SUCCESS(Status)) || !DoUnicode)
        {
            DigestFreeMemory(TemporaryString.Buffer);
        }
    }

    // DebugLog((DEB_TRACE,"NTDigest: Leaving CopyClientString\n"));

    return(Status);
}



/*++

Routine Description:

    This routine parses a Token Descriptor and pulls out the useful
    information.

Arguments:

    TokenDescriptor - Descriptor of the buffer containing the token. 

    BufferIndex - Selects which buffer to extract
    
    Token - Handle to the SecBuffer to write selected buffer to.

    ReadonlyOK - TRUE if the token buffer may be readonly.

Return Value:

    TRUE - If token buffer was properly found.

--*/

BOOLEAN
SspGetTokenBufferByIndex(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PSecBuffer * Token,
    IN BOOLEAN ReadonlyOK
    )
{

    NTSTATUS StatusTmp = STATUS_SUCCESS;
    ULONG i, Index = 0;
    PSecBuffer Buffer = NULL;

    //
    // If there is no TokenDescriptor passed in,
    //  just pass out NULL to our caller.
    //

    ASSERT(*Token != NULL);
    if ( !ARGUMENT_PRESENT( TokenDescriptor) ) {
        return TRUE;
    }

    if (TokenDescriptor->ulVersion != SECBUFFER_VERSION)
    {
        DebugLog((DEB_ERROR,"SspGetTokenBufferByIndex: Wrong Version number\n"));
        return FALSE;
    }

    //
    // Verify that it is a valid location
    //

    if (BufferIndex >= TokenDescriptor->cBuffers)
    {
        DebugLog((DEB_ERROR,"SspGetTokenBufferByIndex: Index out of range for SecBufferDesc\n"));
        return FALSE;
    }

    // DebugLog((DEB_TRACE,"SspGetTokenBufferByIndex: NumberTokens %d\n",TokenDescriptor->cBuffers));

    Buffer = &TokenDescriptor->pBuffers[BufferIndex];

    //
    // If the buffer is readonly and readonly isn't OK,
    // reject the buffer.
    //

    if (!ReadonlyOK && (Buffer->BufferType & SECBUFFER_READONLY))
    {
        DebugLog((DEB_TRACE,"SspGetTokenBufferByIndex: request write on READONLY Token buffer\n"));
        return  FALSE;
    }

    //
    // Return the requested information
    //
    if (Buffer->cbBuffer && Buffer->pvBuffer)
    {
        StatusTmp = g_LsaFunctions->MapBuffer(Buffer, Buffer);
        if (!NT_SUCCESS(StatusTmp))
        {
            DebugLog((DEB_ERROR,"SspGetTokenBufferByIndex: Unable to MapBuffer 0x%x\n", StatusTmp));
            return FALSE;
        }
    }

    *Token = Buffer;

    return TRUE;
}


// determine strlen for a counted string buffer which may or may not be terminated
size_t strlencounted(const char *string,
                     size_t maxcnt)
{
    size_t cnt = 0;
    if (maxcnt <= 0)
    {
        return 0;
    }

    while (maxcnt--)
    {
        if (!*string)
        {
            break;
        }
        cnt++;
        string++;
    }

    return cnt;
}


// determine strlen for a counted string buffer which may or may not be terminated
// maxcnt is the max number of BYTES (so number of unicode chars is 1/2 the maxcnt)
size_t ustrlencounted(const short *string,
                     size_t maxcnt)
{
    size_t cnt = 0;
    if (maxcnt <= 0)
    {
        return 0;
    }

    maxcnt = maxcnt / 2;    // determine number of unicode characters to search

    while (maxcnt--)
    {
        if (!*string)
        {
            break;
        }
        cnt++;
        string++;
    }

    return cnt;
}

// Performs a Backslash encoding of the source string into the destination string per RFC 2831
// Section 7.2 and RFC 2616 sect 2.2
NTSTATUS BackslashEncodeString(IN PSTRING pstrSrc,  OUT PSTRING pstrDst)
{
    NTSTATUS Status = S_OK;
    USHORT  uCharsMax = 0;
    PCHAR pcSrc = NULL;
    PCHAR pcDst = NULL;
    USHORT  uCharsUsed = 0;
    USHORT  uCharSrcCnt = 0;

    StringFree(pstrDst);

    if (!pstrSrc || !pstrDst || !pstrSrc->Length)
    {
        return S_OK;
    }

    uCharsMax = pstrSrc->Length * 2;  // Max size if each character needs to be encoded
    Status = StringAllocate(pstrDst, uCharsMax);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"BackshlashEncodeString: String allocation failed   0x%x\n", Status));
        goto CleanUp;
    }

    // now map over each character - encode as necessary
    pcSrc = pstrSrc->Buffer;
    pcDst = pstrDst->Buffer;
    while (uCharSrcCnt < pstrSrc->Length)
    {
        switch (*pcSrc)
        {
            case CHAR_DQUOTE:
            case CHAR_BACKSLASH:
                *pcDst++ = CHAR_BACKSLASH;
                *pcDst++ = *pcSrc++;
                uCharsUsed+= 2;
                break;
            default:
                *pcDst++ = *pcSrc++;
                uCharsUsed++;
                break;
        }
        uCharSrcCnt++;
    }

    pstrDst->Length = uCharsUsed;

CleanUp:
    return Status;
}



// Print out the date and time from a given TimeStamp (converted to localtime)
NTSTATUS PrintTimeString(TimeStamp ConvertTime, BOOL fLocalTime)
{
    NTSTATUS Status = STATUS_SUCCESS;

    LARGE_INTEGER LocalTime;
    LARGE_INTEGER SystemTime;

    SystemTime = (LARGE_INTEGER)ConvertTime;
    LocalTime.HighPart = 0;
    LocalTime.LowPart = 0;

    if (ConvertTime.HighPart == 0x7FFFFFFF)
    {
        DebugLog((DEB_TRACE, "PrintTimeString: Never ends\n"));
    }

    if (fLocalTime)
    {
        Status = RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
        if (!NT_SUCCESS( Status )) {
            DebugLog((DEB_ERROR, "PrintTimeString: Can't convert time from GMT to Local time\n"));
            LocalTime = ConvertTime;
        }
    }
    else
    {
        LocalTime = ConvertTime;
    }

    TIME_FIELDS TimeFields;

    RtlTimeToTimeFields( &LocalTime, &TimeFields );

    DebugLog((DEB_TRACE, "PrintTimeString: %ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
            TimeFields.Month,
            TimeFields.Day,
            TimeFields.Year,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second));

    return Status;
}

// Printout the Hex representation of a buffer
NTSTATUS MyPrintBytes(void *pbuff, USHORT uNumBytes, PSTRING pstrOutput)
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT  uNumTotal = 0;
    PCHAR pctr = NULL;
    PCHAR pOut = NULL;
    USHORT i = 0;

    // Each byte will be encoded as   XX <sp>

    uNumTotal = (uNumBytes * 3) + 1;
    
    StringFree(pstrOutput);
    Status = StringAllocate(pstrOutput, uNumTotal);
    if (!NT_SUCCESS (Status))
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "ContextInit: StringAllocate error 0x%x\n", Status));
        goto CleanUp;
    }

    pOut = (PCHAR)pstrOutput->Buffer;

    for (i = 0, pctr = (PCHAR)pbuff; i < uNumBytes; i++)
    {
       sprintf(pOut, "%02x ", (*pctr & 0xff));
       pOut += 3;
       pctr++;
    }
    pstrOutput->Length = uNumBytes * 3;

CleanUp:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\testb\testglobal.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        global.h
//
// Contents:    global include file for NTDigest security package
//
//
// History:     KDamour 15Mar00   Stolen from msv_sspi\global.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_GLOBAL_H
#define NTDIGEST_GLOBAL_H


#ifndef UNICODE
#define UNICODE
#endif // UNICODE


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#include <windows.h>
#ifndef RPC_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H
#include <rpc.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>
// #include <dsysdbg.h>
#include <lsarpc.h>
#include <lsaitf.h>
#include <dns.h>
#include <dnsapi.h>
#include <lmcons.h>

#include <md5.h>
#include <hmac.h>

#include <pac.hxx>

// Local includes for NT Digest Access SSP
#include "wdigest.h"       /* Prototype functions for package */

//
// Macros for manipulating globals
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef NTDIGEST_GLOBAL
#define EXTERN
#else
#define EXTERN extern
#endif // NTDIGEST_GLOBAL


// Copies a CzString to a String (memory alloc and copy)
NTSTATUS StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource);


// Allocates cb bytes to STRING Buffer
NTSTATUS StringAllocate(IN PSTRING pString, IN USHORT cb);

// Clears a String and releases the memory
NTSTATUS StringFree(IN PSTRING pString);


// Allocate memory in LSA or user mode
PVOID DigestAllocateMemory(IN ULONG BufferSize);

// De-allocate memory from DigestAllocateMemory
VOID DigestFreeMemory(IN PVOID Buffer);



#ifdef __cplusplus
}
#endif // __cplusplus
#endif // NTDIGEST_GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\testc\test.cpp ===
// Test.cpp : Defines the entry point for the console application. This code uses SASL calling convention
//

#include "testglobal.h"

#include <stdio.h>      // printf

#include <security.h>   // General definition of a Security Support Provider


#define AUTH_USERNAME "test1"
#define AUTH_USERNAME_W L"test1"

#define AUTH_NONCE "9b38dce631309cc25a653ebaad5b18ee01c8bf385260b26db0574a302be4c11367"
#define AUTH_URI_W L"imap/elwood.innosoft.com"
#define AUTH_NC  "0000000b"
#define AUTH_NC1  "00000001"
#define AUTH_NC2  "00000002"
#define AUTH_NC3  "00000003"
#define AUTH_NC4  "00000004"

#define AUTHDATA_USERNAME L"test1"
// #define AUTHDATA_DOMAIN   L"kdamour2w.damourlan.nttest.microsoft.com"
// #define AUTHDATA_DOMAIN   L"damourlan"
#define AUTHDATA_DOMAIN   L"damourlan"
#define AUTHDATA_PASSWORD L"test1"


#define STR_BUF_SIZE   4000

char g_czTestPasswd[257];


BOOLEAN QuietMode = FALSE; // Don't be verbose


// Prototypes
void PrintStatus(SECURITY_STATUS NetStatus);
void PrintTime(LPSTR Comment,TimeStamp ConvertTime);

void ISCRETFlags(ULONG ulFlags);
void ASCRETFlags(ULONG ulFlags);

VOID BinToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    );

int __cdecl
main(int argc, char* argv[])
{
    BOOL bPass = TRUE;
    SECURITY_STATUS Status = STATUS_SUCCESS;

    char cTemp[STR_BUF_SIZE];  // temp buffer for scratch data
    char cTemp2[STR_BUF_SIZE];  // temp buffer for scratch data
    char cOutputTemp[STR_BUF_SIZE];
    char szOutSecBuf[STR_BUF_SIZE];
    char szChallenge[STR_BUF_SIZE];
    char szISCChallengeResponse[STR_BUF_SIZE];   // Output buffer from ISC
    char szASCChallengeResponse[STR_BUF_SIZE];   // Output buffer from ASC
    char szASCResponseAuth[STR_BUF_SIZE];   // Output buffer from ASC

    // SSPI Interface tests

    ULONG PackageCount = 0;
    int i = 0;
    PSecPkgInfo pPackageInfo = NULL;
    PSecPkgInfo pPackageTmp = NULL;
    SECURITY_STATUS TmpStatus = STATUS_SUCCESS;
    CredHandle ServerCred;
    CredHandle ClientCred;
    TimeStamp Lifetime;
    BOOL bServerCred = FALSE;
    BOOL bClientCred = FALSE;

    SecPkgContext_StreamSizes StreamSizes;

    ULONG ClientContextReqFlags = ISC_REQ_INTEGRITY | ISC_REQ_CONFIDENTIALITY | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONNECTION;
    ULONG ServerContextReqFlags = ASC_REQ_INTEGRITY | ASC_REQ_CONFIDENTIALITY;
    ULONG ClientContextRetFlags = 0;
    ULONG ServerContextRetFlags = 0;
    ULONG TargetDataRep = 0;


    CtxtHandle OldContextHandle;
    CtxtHandle ServerCtxtHandle;
    CtxtHandle ClientCtxtHandle;

    SecBufferDesc InputBuffers;
    SecBufferDesc OutputBuffers;
    SecBuffer TempTokensIn[6];
    SecBuffer TempTokensOut[6];

    PCHAR pcPtr = NULL;
    int iLen = 0;

    UNICODE_STRING ustrUsername;
    UNICODE_STRING ustrPassword;
    UNICODE_STRING ustrDomain;
    STRING strTemp;

    STRING strChallenge;
    STRING strMethod;
    STRING strHEntity;
    STRING strOutBuffer;

    ULONG ulMessSeqNo = 0;
    ULONG ulQOP = 0;

    SEC_WINNT_AUTH_IDENTITY_W AuthData;

    printf("Begining TESTC...\n");


    ZeroMemory(&ClientCred, sizeof(CredHandle));
    ZeroMemory(&ServerCred, sizeof(CredHandle));
    ZeroMemory(&OldContextHandle, sizeof(CtxtHandle));
    ZeroMemory(&ServerCtxtHandle, sizeof(CtxtHandle));
    ZeroMemory(&ClientCtxtHandle, sizeof(CtxtHandle));

    ZeroMemory(&ustrUsername, sizeof(ustrUsername));
    ZeroMemory(&ustrPassword, sizeof(ustrPassword));
    ZeroMemory(&ustrDomain, sizeof(ustrDomain));
    ZeroMemory(&strTemp, sizeof(strTemp));
    ZeroMemory(&StreamSizes, sizeof(StreamSizes));

    // Pull out any command line args
    if (argc > 1)
    {
        for (i = 1; i < argc; i++)
        {
            pcPtr = argv[i];
            if (*pcPtr == '-')
            {
                iLen = strlen(pcPtr);
                if (iLen >= 2)
                {
                    switch (*(pcPtr + 1))
                    {
                    case 'u':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrUsername, (pcPtr + 2));
                        break;
                    case 'd':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrDomain, (pcPtr + 2));
                        break;
                    case 'p':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrPassword, (pcPtr + 2));
                        break;
                    case '?':
                    default:
                        printf("Usage: %s -uUsername -pPassword -ddomain\n", argv[0]);
                        return(-1);
                        break;

                    }
                }
            }
        }
    }

    //
    // Get info about the security packages.
    //

    Status = EnumerateSecurityPackages( &PackageCount, &pPackageInfo );
    TmpStatus = GetLastError();

    if (!NT_SUCCESS(Status)) {
        printf( "EnumerateSecurityPackages failed: 0x%x", Status);
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    if ( !QuietMode ) {
      printf( "PackageCount: %ld\n", PackageCount );
      for ( i= 0; i< (int)PackageCount; i++)
      {
        pPackageTmp = (pPackageInfo + i);
        printf( "Name: %ws Comment: %ws\n", pPackageTmp->Name, pPackageTmp->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pPackageTmp->fCapabilities,
                pPackageTmp->wVersion,
                pPackageTmp->wRPCID,
                pPackageTmp->cbMaxToken );
      }
    }

    //
    // Get info about the security packages.
    //

    Status = QuerySecurityPackageInfo( WDIGEST_SP_NAME, &pPackageInfo );
    TmpStatus = GetLastError();

    if (!NT_SUCCESS(Status)) {
        printf( "QuerySecurityPackageInfo failed: " );
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", pPackageInfo->Name, pPackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pPackageInfo->fCapabilities,
                pPackageInfo->wVersion,
                pPackageInfo->wRPCID,
                pPackageInfo->cbMaxToken );
    }


    //
    // Acquire a credential handle for the server side
    //

    printf("Server  AcquireCredentialHandle\n");
    Status = AcquireCredentialsHandle(
                    NULL,           // New principal
                    WDIGEST_SP_NAME, // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &ServerCred,
                    &Lifetime );

    if (!NT_SUCCESS(Status)) {
        printf( "AcquireCredentialsHandle failed: ");
        printf( "FAILED:    AcquireCredentialsHandle failed:  status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = FALSE;
        ZeroMemory(&ServerCred, sizeof(CredHandle));
        goto CleanUp;
    }
    bServerCred = TRUE;


    //
    // Acquire a credential handle for the client side
    //
    printf("Client  AcquireCredentialHandle\n");

    if (ustrUsername.Length || ustrPassword.Length || ustrDomain.Length)
    {
        printf("ACH Using supplied credentials\n");
        printf("      Username %wZ    Domain  %wZ    Password %wZ\n",
                &ustrUsername, &ustrDomain, &ustrPassword);

        ZeroMemory(&AuthData, sizeof(SEC_WINNT_AUTH_IDENTITY_W));
        AuthData.Domain = ustrDomain.Buffer;
        AuthData.DomainLength = ustrDomain.Length / sizeof(WCHAR);
        AuthData.Password = ustrPassword.Buffer;
        AuthData.PasswordLength = ustrPassword.Length / sizeof(WCHAR);
        AuthData.User = ustrUsername.Buffer;
        AuthData.UserLength = ustrUsername.Length / sizeof(WCHAR);
        AuthData.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        Status = AcquireCredentialsHandle(
                        NULL,  //  AUTH_USERNAME_W,           // get the creds for user digest
                        WDIGEST_SP_NAME, // Package Name
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        &AuthData,    // Make NULL not to use any AuthData for cred
                        NULL,
                        NULL,
                        &ClientCred,
                        &Lifetime );
    }
    else
    {
        printf("ACH Using default credentials\n");
        Status = AcquireCredentialsHandle(
                        NULL,  //  AUTH_USERNAME_W,           // get the creds for user digest
                        WDIGEST_SP_NAME, // Package Name
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &ClientCred,
                        &Lifetime );
    }

    if (!NT_SUCCESS(Status)) {
        printf( "AcquireCredentialsHandle failed: for user %s: ", AUTH_USERNAME);
        PrintStatus( Status );
        // bPass = FALSE;
        // ZeroMemory(&ClientCred, sizeof(CredHandle));
        // goto CleanUp;
    }
    else
        bClientCred = TRUE;


    if ( !QuietMode ) {
        printf( "ClientCred: 0x%lx 0x%lx   ",
                ClientCred.dwLower, ClientCred.dwUpper );
        printf( "ServerCred: 0x%lx 0x%lx   ",
                ServerCred.dwLower, ServerCred.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }


    // Big time - call Accept with no parameters to get a challenge


    StringAllocate(&strChallenge, 0);

    StringCharDuplicate(&strMethod, "GET");
    StringAllocate(&strHEntity, 0);

    StringAllocate(&strOutBuffer, 4000);


    ZeroMemory(TempTokensIn, sizeof(TempTokensIn));
    ZeroMemory(TempTokensOut, sizeof(TempTokensOut));
    ZeroMemory(&InputBuffers, sizeof(SecBufferDesc));
    ZeroMemory(&OutputBuffers, sizeof(SecBufferDesc));


           // SASL first calls ISC with no-input
    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = 1;                         // no data passed in
    TempTokensIn[0].pvBuffer = cTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    Status = InitializeSecurityContext(&ClientCred,
                                       NULL,
                                       AUTH_URI_W,
                                       ClientContextReqFlags,
                                       NULL,
                                       SECURITY_NATIVE_DREP,
                                       NULL,    // &InputBuffers,   MSDN allows NULL for 1st call
                                       NULL,
                                       &ClientCtxtHandle,
                                       &OutputBuffers,
                                       &ClientContextRetFlags,
                                       &Lifetime);


    if (!NT_SUCCESS(Status))
    {
        printf("InitializeSecurityContext  SASL 1st call returned: ");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    printf("ISC Context Flags  Req  0x%lx    Ret 0x%lx\n", ClientContextReqFlags, ClientContextRetFlags);
    ISCRETFlags(ClientContextRetFlags);

    printf("InitializeSecurityContext SASL 1st call  Output buffer size %d\n",
           TempTokensOut[0].cbBuffer );


    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strChallenge.Length + 1;  // for NULL
    TempTokensIn[0].pvBuffer = strChallenge.Buffer;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    Status = AcceptSecurityContext(
                                   &ServerCred,
                                   NULL,
                                   &InputBuffers,
                                   ServerContextReqFlags,
                                   TargetDataRep,
                                   &ServerCtxtHandle,
                                   &OutputBuffers,
                                   &ServerContextRetFlags,
                                   &Lifetime);

    if (Status != SEC_I_CONTINUE_NEEDED)   // Indicates that this is the challenge
    {
        printf("SpAcceptLsaModeContext FAILED 0x%x\n", Status);
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    ZeroMemory(szChallenge, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';
    strncpy(szChallenge, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    szChallenge[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    printf("ASC Context Flags  Req  0x%lx    Ret 0x%lx\n", ServerContextReqFlags, ServerContextRetFlags);
    ASCRETFlags(ServerContextRetFlags);

    printf("Challenge Output Buffer is:\n%s\n\n", cOutputTemp);

    printf("Now call the SSPI InitializeSecCtxt to generate the ChallengeResponse\n");


    sprintf(cTemp, "username=\"%s\",%s,uri=\"%S\",nc=%0.8x",
              AUTH_USERNAME,
              szChallenge,
              AUTH_URI_W,
              1);


    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    Status = InitializeSecurityContext(&ClientCred,
                                       &ClientCtxtHandle,
                                       AUTH_URI_W,
                                       ClientContextReqFlags,
                                       NULL,
                                       SECURITY_NATIVE_DREP,
                                       &InputBuffers,
                                       NULL,
                                       &ClientCtxtHandle,
                                       &OutputBuffers,
                                       &ClientContextRetFlags,
                                       &Lifetime);


    if (Status != SEC_I_CONTINUE_NEEDED)   // Indicates that this is the challengeresponse - wait for mutual auth
    {
        printf("SpAcceptLsaModeContext FAILED 0x%x\n", Status);
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    printf("InitializeSecurityContext SUCCEEDED with Context Handle (0x%x,0x%x)\n",
           ClientCtxtHandle.dwLower, ClientCtxtHandle.dwUpper );


    printf("ISC Context Flags  Req  0x%lx    Ret 0x%lx\n", ClientContextReqFlags, ClientContextRetFlags); 
    ISCRETFlags(ClientContextRetFlags);


    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    ZeroMemory(szChallenge, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';
    strncpy(szISCChallengeResponse, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    szISCChallengeResponse[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    printf("ISC: Challenge Response Output Buffer is\n%s\n\n", szISCChallengeResponse);

    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cOutputTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cOutputTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    printf("Calling the AcceptSC with a ChallengeResponse (should talk to the DC)!\n");
    Status = AcceptSecurityContext(
                                   &ServerCred,
                                   &ServerCtxtHandle,
                                   &InputBuffers,
                                   ServerContextReqFlags,
                                   TargetDataRep,
                                   &ServerCtxtHandle,
                                   &OutputBuffers,
                                   &ServerContextRetFlags,
                                   &Lifetime);
                                   
    if (!NT_SUCCESS(Status))
    {
        printf("AcceptSecurityContext 2nd Call: ");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    strcpy(szASCChallengeResponse, (char *)InputBuffers.pBuffers[0].pvBuffer);


    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    ZeroMemory(szASCResponseAuth, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';
    strncpy(szASCResponseAuth, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    szASCResponseAuth[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    printf("ASC has accepted the Challenge Resposne and generated rspauth for mutual auth back to client\n");

    printf("ASC Context Flags  Req  0x%lx    Ret 0x%lx\n", ServerContextReqFlags, ServerContextRetFlags);
    ASCRETFlags(ServerContextRetFlags);

    printf("ASC: Response Auth Output Buffer is\n%s\n\n", szASCResponseAuth);


    printf("Now have a valid Security Context handle from ASC\n\n");

    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cOutputTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cOutputTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    Status = InitializeSecurityContext(&ClientCred,
                                       &ClientCtxtHandle,
                                       AUTH_URI_W,
                                       ClientContextReqFlags,
                                       NULL,
                                       SECURITY_NATIVE_DREP,
                                       &InputBuffers,
                                       NULL,
                                       &ClientCtxtHandle,
                                       &OutputBuffers,
                                       &ClientContextRetFlags,
                                       &Lifetime);


    if (!NT_SUCCESS(Status))
    {
        printf("InitializeSecurityContext on Response Auth FAILED: ");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    printf("InitializeSecurityContext SUCCEEDED with Context Handle (0x%x,0x%x)\n",
           ClientCtxtHandle.dwLower, ClientCtxtHandle.dwUpper );


    printf("ISC Context Flags  Req  0x%lx    Ret 0x%lx\n", ClientContextReqFlags, ClientContextRetFlags); 
    ISCRETFlags(ClientContextRetFlags);

    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    printf("\nISC: Mutual auth Output Buffer is\n%s\n\n", cOutputTemp);

    printf("Now have a valid Security Context handle from ISC and ASC\n\n");


    // Now get some info on the securitycontexts

    Status = QueryContextAttributes(&ServerCtxtHandle, SECPKG_ATTR_STREAM_SIZES, &StreamSizes);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    QueryContextAttributes SECPKG_ATTR_STREAM_SIZES error:   status 0x%x\n", Status);
        PrintStatus( Status );
    }
    else
    {
        printf("Server Context Stream Sizes: MaxBuf %lu   Blocksize %lu  Trailer %lu\n",
               StreamSizes.cbMaximumMessage, StreamSizes.cbBlockSize,
               StreamSizes.cbTrailer);
    }

    Status = QueryContextAttributes(&ClientCtxtHandle, SECPKG_ATTR_STREAM_SIZES, &StreamSizes);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    QueryContextAttributes SECPKG_ATTR_STREAM_SIZES error:   status 0x%x\n", Status);
        PrintStatus( Status );
    }
    else
    {
        printf("Client Context Stream Sizes: MaxBuf %lu   Blocksize %lu  Trailer %lu\n",
               StreamSizes.cbMaximumMessage, StreamSizes.cbBlockSize,
               StreamSizes.cbTrailer);
    }
 
    // Now have authenticated connection
    // Try MakeSignature and VerifySignature

    for (i = 0; i < 9; i++)
    {
        printf("Loop %d\n", i);
        ZeroMemory(cTemp, sizeof(cTemp));
        strcpy(cTemp, AUTH_NONCE);            // Create message to sign
    
        InputBuffers.ulVersion = SECBUFFER_VERSION;
        InputBuffers.cBuffers = 3;
        InputBuffers.pBuffers = TempTokensIn;
        
        TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
        TempTokensIn[0].cbBuffer = 0;  
        TempTokensIn[0].pvBuffer = NULL;
        TempTokensIn[1].BufferType = SECBUFFER_DATA;        // select some data to sign
        TempTokensIn[1].cbBuffer = strlen(AUTH_NONCE) + 1 - i;   // for NULL  use i to test non-blocksize buffers
        TempTokensIn[1].pvBuffer = cTemp;
        TempTokensIn[2].BufferType = SECBUFFER_PADDING;
        TempTokensIn[2].cbBuffer = STR_BUF_SIZE - TempTokensIn[1].cbBuffer;  // for NULL
        TempTokensIn[2].pvBuffer = cTemp + TempTokensIn[1].cbBuffer;
    
        if (TempTokensIn[1].cbBuffer)
        {
            printf("Input Message to process is %d bytes\n", TempTokensIn[1].cbBuffer);
            BinToHex((PBYTE)TempTokensIn[1].pvBuffer, TempTokensIn[1].cbBuffer, cTemp2);
            printf("Mesage: %s\n", cTemp2);
        }
    
        Status = EncryptMessage(&ClientCtxtHandle,
                               ulQOP,
                               &InputBuffers,
                               0);
        if (!NT_SUCCESS(Status))
        {
            printf("TestCredAPI: EncryptMessage FAILED: ");
            PrintStatus( Status );
            bPass = FALSE;
            goto CleanUp;
        }
    
        printf("Processed (sign/seal) Output Buffer for message length is %d\n",
                TempTokensIn[1].cbBuffer + TempTokensIn[2].cbBuffer);
        if (TempTokensIn[1].cbBuffer + TempTokensIn[2].cbBuffer)
        {
            printf("Message  is %d bytes\n", TempTokensIn[1].cbBuffer + TempTokensIn[2].cbBuffer);
            BinToHex((PBYTE)TempTokensIn[1].pvBuffer, TempTokensIn[1].cbBuffer + TempTokensIn[2].cbBuffer, cTemp2);
            printf("Mesage: %s\n", cTemp2);
        }
    
        // You now send Output buffer to Server - in this case the buffer is szOutSecBuf
    
        printf("Now verify that the 1st message is Authenticate\n");
        InputBuffers.ulVersion = SECBUFFER_VERSION;
        InputBuffers.cBuffers = 2;
        InputBuffers.pBuffers = TempTokensIn;
    
    
        TempTokensIn[0].BufferType = SECBUFFER_STREAM;
        TempTokensIn[0].cbBuffer = TempTokensIn[1].cbBuffer + TempTokensIn[2].cbBuffer;  
        TempTokensIn[0].pvBuffer = TempTokensIn[1].pvBuffer;
        TempTokensIn[1].BufferType = SECBUFFER_DATA;        // select some data to sign
        TempTokensIn[1].cbBuffer = 0;
        TempTokensIn[1].pvBuffer = NULL;
    
    
        Status = DecryptMessage(&ServerCtxtHandle,
                                 &InputBuffers,
                                 ulMessSeqNo,
                                 &ulQOP);                                   
        if (!NT_SUCCESS(Status))
        {
            printf("TestCredAPI: DecryptMessage 1st Call  FAILED :");
            PrintStatus( Status );
            bPass = FALSE;
            goto CleanUp;
        }
        printf("Now have a authenticated 1st message under context 0x%x\n", ServerCtxtHandle);
    
    
        printf("Processed (verify/unseal)  is %d bytes\n", TempTokensIn[1].cbBuffer);
        if (TempTokensIn[1].cbBuffer)
        {
            BinToHex((PBYTE)TempTokensIn[1].pvBuffer, TempTokensIn[1].cbBuffer, cTemp2);
            printf("Mesage: %s\n", cTemp2);
        }
    
    }

CleanUp:

    printf("Leaving test program\n");

    if (pPackageInfo)
    {
        FreeContextBuffer(pPackageInfo);
    }

    printf("About to call deletesecuritycontext\n");

    //
    // Free the security context handle
    //
    if (ServerCtxtHandle.dwLower || ServerCtxtHandle.dwUpper)
    {
        Status = DeleteSecurityContext(&ServerCtxtHandle);
        if (!NT_SUCCESS(Status))
        {
            printf("ERROR:  DeleteSecurityContext ServerCtxtHandle failed: ");
            PrintStatus(Status);
        }
    }

    if (ClientCtxtHandle.dwLower || ClientCtxtHandle.dwUpper)
    {
        Status = DeleteSecurityContext(&ClientCtxtHandle);
        if (!NT_SUCCESS(Status))
        {
            printf("ERROR:  DeleteSecurityContext ClientCtxtHandle failed: ");
            PrintStatus(Status);
        }
    }
    //
    // Free the credential handles
    //

    printf("Now calling to Free the ServerCred\n");
    if (bServerCred)
    {
        Status = FreeCredentialsHandle( &ServerCred );

        if (!NT_SUCCESS(Status))
        {
            printf( "FreeCredentialsHandle failed for ServerCred: " );
            PrintStatus(Status);
        }
    }

    printf("Now calling to Free the ServerCred\n");
    if (bClientCred)
    {
        Status = FreeCredentialsHandle(&ClientCred);

        if (!NT_SUCCESS(Status))
        {
            printf( "FreeCredentialsHandle failed for ClientCred: " );
            PrintStatus( Status );
        }
    }

    StringFree(&strChallenge);
    StringFree(&strMethod);
    StringFree(&strHEntity);
    StringFree(&strOutBuffer);


    if (bPass != TRUE)
        printf("FAILED test run with one or more tests failing.\n");
    else
        printf("All tests passed.\n");

    return 0;
}


void
PrintStatus(
    SECURITY_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = 0x%lx",NetStatus );

    switch (NetStatus) {

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;
    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;

    case SEC_I_CONTINUE_NEEDED:
        printf( " SEC_I_CONTINUE_NEEDED" ); break;
    }

    printf( "\n" );
}



void
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;
    NTSTATUS Status;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
    if (!NT_SUCCESS( Status )) {
        printf( "Can't convert time from GMT to Local time\n" );
        LocalTime = ConvertTime;
    }

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}





// Support Routines


//+-------------------------------------------------------------------------
//
//  Function:   StringAllocate
//
//  Synopsis:   Allocates cb chars to STRING Buffer
//
//  Arguments:  pString - pointer to String to allocate memory to
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
StringAllocate(
    IN PSTRING pString,
    IN USHORT cb
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringAllocate\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    cb = cb + 1;   // Add in extra room for the terminating NULL

    if (ARGUMENT_PRESENT(pString))
    {
        pString->Length = 0;

        pString->Buffer = (char *)DigestAllocateMemory((ULONG)(cb * sizeof(CHAR)));
        if (pString->Buffer)
        {
            pString->MaximumLength = cb;
        }
        else
        {
            pString->MaximumLength = 0;
            Status = STATUS_NO_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

CleanUp:
    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringAllocate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringFree
//
//  Synopsis:   Clears a String and releases the memory
//
//  Arguments:  pString - pointer to String to clear
//
//  Returns:    SEC_E_OK - released memory succeeded
//
//  Requires:
//
//  Effects:    de-allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
StringFree(
    IN PSTRING pString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringFree\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pString) &&
        (pString->Buffer != NULL))
    {
        DigestFreeMemory(pString->Buffer);
        pString->Length = 0;
        pString->MaximumLength = 0;
        pString->Buffer = NULL;
    }

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringFree\n"));
    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   StringCharDuplicate
//
//  Synopsis:   Duplicates a NULL terminated char. If the source string buffer is
//              NULL the destionation will be too.
//
//  Arguments:  Destination - Receives a copy of the source NULL Term char *
//              czSource - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCharDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cbSourceCz = 0;

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(czSource)) &&
        ((cbSourceCz = strlen(czSource)) != 0))
    {

        DestinationString->Buffer = (LPSTR) DigestAllocateMemory(cbSourceCz + sizeof(CHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = cbSourceCz;
            DestinationString->MaximumLength = cbSourceCz + sizeof(CHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                czSource,
                cbSourceCz
                );

            DestinationString->Buffer[cbSourceCz/sizeof(CHAR)] = '\0';
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            // DebugLog((DEB_ERROR, "NTDigest: StringCharDuplicate, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringCharDuplicate\n"));
    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   DigestAllocateMemory
//
//  Synopsis:   Allocate memory in either lsa mode or user mode
//
//  Effects:    Allocated chunk is zeroed out
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PVOID
DigestAllocateMemory(
    IN ULONG BufferSize
    )
{
    PVOID Buffer = NULL;
    // DebugLog((DEB_TRACE, "Entering DigestAllocateMemory\n"));

        Buffer = LocalAlloc(LPTR, BufferSize);

    // DebugLog((DEB_TRACE, "Leaving DigestAllocateMemory\n"));
    return Buffer;
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmFree
//
//  Synopsis:   Free memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
DigestFreeMemory(
    IN PVOID Buffer
    )
{
    // DebugLog((DEB_TRACE, "Entering DigestFreeMemory\n"));

            LocalFree(Buffer);

    // DebugLog((DEB_TRACE, "Leaving DigestFreeMemory\n"));
}




VOID
BinToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )
{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( UINT x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}




VOID
ISCRETFlags( ULONG ulFlags)
{
    printf("ISC Ret Flag (0x%x):", ulFlags);

    if (ulFlags & ISC_RET_DELEGATE)
    {
        printf(" Delegate");
    }
    if (ulFlags & ISC_RET_MUTUAL_AUTH)
    {
        printf(" Mutual_Auth");
    }
    if (ulFlags & ISC_RET_REPLAY_DETECT)
    {
        printf(" Replay_Detect");
    }
    if (ulFlags & ISC_RET_SEQUENCE_DETECT)
    {
        printf(" Seq_Detect");
    }
    if (ulFlags & ISC_RET_CONFIDENTIALITY)
    {
        printf(" Confident");
    }
    if (ulFlags & ISC_RET_ALLOCATED_MEMORY)
    {
        printf(" Alloc_Mem");
    }
    if (ulFlags & ISC_RET_CONNECTION)
    {
        printf(" Connection");
    }
    if (ulFlags & ISC_RET_INTEGRITY)
    {
        printf(" Integrity");
    }

    printf("\n");
}

VOID
ASCRETFlags( ULONG ulFlags)
{
    printf("ASC Ret Flag (0x%x):", ulFlags);

    if (ulFlags & ASC_RET_DELEGATE)
    {
        printf(" Delegate");
    }
    if (ulFlags & ASC_RET_MUTUAL_AUTH)
    {
        printf(" Mutual_Auth");
    }
    if (ulFlags & ASC_RET_REPLAY_DETECT)
    {
        printf(" Replay_Detect");
    }
    if (ulFlags & ASC_RET_SEQUENCE_DETECT)
    {
        printf(" Seq_Detect");
    }
    if (ulFlags & ASC_RET_CONFIDENTIALITY)
    {
        printf(" Confident");
    }
    if (ulFlags & ASC_RET_ALLOCATED_MEMORY)
    {
        printf(" Alloc_Mem");
    }
    if (ulFlags & ASC_RET_CONNECTION)
    {
        printf(" Connection");
    }
    if (ulFlags & ASC_RET_INTEGRITY)
    {
        printf(" Integrity");
    }

    printf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\testc\testglobal.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        global.h
//
// Contents:    global include file for NTDigest security package
//
//
// History:     KDamour 15Mar00   Stolen from msv_sspi\global.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_GLOBAL_H
#define NTDIGEST_GLOBAL_H


#ifndef UNICODE
#define UNICODE
#endif // UNICODE


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#include <windows.h>
#ifndef RPC_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H
#include <rpc.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>
// #include <dsysdbg.h>
#include <lsarpc.h>
#include <lsaitf.h>
#include <dns.h>
#include <dnsapi.h>
#include <lmcons.h>

#include <md5.h>
#include <hmac.h>

#include <pac.hxx>

// Local includes for NT Digest Access SSP
#include "wdigest.h"       /* Prototype functions for package */


//
// Macros for manipulating globals
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef NTDIGEST_GLOBAL
#define EXTERN
#else
#define EXTERN extern
#endif // NTDIGEST_GLOBAL


// Copies a CzString to a String (memory alloc and copy)
NTSTATUS StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource);


// Allocates cb bytes to STRING Buffer
NTSTATUS StringAllocate(IN PSTRING pString, IN USHORT cb);

// Clears a String and releases the memory
NTSTATUS StringFree(IN PSTRING pString);


// Allocate memory in LSA or user mode
PVOID DigestAllocateMemory(IN ULONG BufferSize);

// De-allocate memory from DigestAllocateMemory
VOID DigestFreeMemory(IN PVOID Buffer);



#ifdef __cplusplus
}
#endif // __cplusplus
#endif // NTDIGEST_GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\util.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        util.h
//
// Contents:    headerfile for util.cxx and parser.cxx
//
//
// History:     KDamour  15Mar00   Created
//
//------------------------------------------------------------------------

#ifndef DIGEST_UTIL_H
#define DIGEST_UTIL_H

#include "global.h"

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

// Allocates cb wide chars to UNICODE_STRING Buffer
NTSTATUS UnicodeStringAllocate(IN PUNICODE_STRING pString, IN USHORT cNumWChars);

// Duplicate a UnicodeString (memory alloc and copy)
NTSTATUS UnicodeStringDuplicate(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString);

// Copies a unicode string if destination has enough room to store it
NTSTATUS UnicodeStringCopy(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString);

//  Function to duplicate Unicode passwords with padding for cipher
NTSTATUS UnicodeStringDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString);

// Clears a UnicodeString and releases the memory
NTSTATUS UnicodeStringClear(OUT PUNICODE_STRING pString);

// Copies a SzUnicodeString to a String (memory alloc and copy)
NTSTATUS UnicodeStringWCharDuplicate(OUT PUNICODE_STRING DestinationString, IN OPTIONAL WCHAR *szSource);

// Decode a string into Unicode
NTSTATUS DecodeUnicodeString(
    IN PSTRING pstrSource,
    IN UINT CodePage,
    OUT PUNICODE_STRING pustrDestination
    );

// Encode a unicode string with a given charset
NTSTATUS EncodeUnicodeString(
    IN PUNICODE_STRING pustrSource,
    IN UINT CodePage,
    OUT PSTRING pstrDestination,
    IN OUT PBOOL pfUsedDefaultChar
    );

// Duplicates a String (memory alloc and copy)
NTSTATUS StringDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString);

// Copies a string if destination has enough room to store it
NTSTATUS StringCopy(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString);

// Reference a String - no buffer memory copied
NTSTATUS StringReference(
    OUT PSTRING pDestinationString,
    IN  PSTRING pSourceString
    );

// Reference a Unicode_String - no buffer memory copied
NTSTATUS UnicodeStringReference(
    OUT PUNICODE_STRING pDestinationString,
    IN  PUNICODE_STRING pSourceString
    );

// Copies a CzString to a String (memory alloc and copy)
NTSTATUS StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource,
    IN OPTIONAL USHORT uCnt);

// Duplicates a SID (memory alloc and copy)
NTSTATUS SidDuplicate(
    OUT PSID * DestinationSid,
    IN PSID SourceSid);

NTSTATUS CopyClientString(
    IN PWSTR SourceString,
    IN ULONG SourceLength,
    IN BOOLEAN DoUnicode,
    OUT PUNICODE_STRING DestinationString);

// Allocate memory in LSA or user mode
PVOID DigestAllocateMemory(IN ULONG BufferSize);

// De-allocate memory from DigestAllocateMemory
VOID DigestFreeMemory(IN PVOID Buffer);

// Allocates cb bytes to STRING Buffer
NTSTATUS StringAllocate(IN PSTRING pString, IN USHORT cb);

// Clears a String and releases the memory
NTSTATUS StringFree(IN PSTRING pString);

// Quick check on String struct allocations validity
NTSTATUS StringVerify(OUT PSTRING pString);

// Clears a Uniicde_String and releases the memory
NTSTATUS UnicodeStringFree(OUT PUNICODE_STRING pString);

// Hex Encoders and Decoders
VOID BinToHex(LPBYTE pSrc,UINT cSrc, LPSTR pDst);
VOID HexToBin(LPSTR pSrc,UINT cSrc, LPBYTE pDst);

// Parse input string into Parameter section of Digest
NTSTATUS DigestParser2(PSecBuffer pInputBuf, PSTR *pNameTable,UINT cNameTable, PDIGEST_PARAMETER pDigest);

//  Scan a Comma Deliminated STRING for an Item
NTSTATUS CheckItemInList(PCHAR pszItem, PSTRING pstrList, BOOL fOneItem);

// Helper function to DigestParser2
NTSTATUS DigestProcessEntry(
    IN PSTR pcBeginName,
    IN PSTR pcEndName,
    IN PSTR pcBeginValue,
    IN PSTR pcEndValue,
    IN PSTR *pNameTable,
    IN UINT cNameTable,
    IN BOOL fBSlashEncoded,
    OUT PDIGEST_PARAMETER pDigest);

// Check for backslash character in a counted string of chars
BOOL CheckBSlashChar(
    IN PSTR pcStr,
    IN USHORT len);

//  This routine selects a Buffer by indexed count in the BufferIndex
BOOLEAN SspGetTokenBufferByIndex(
    IN PSecBufferDesc TokenDescriptor,
    IN ULONG BufferIndex,
    OUT PSecBuffer * Token,
    IN BOOLEAN ReadonlyOK
    );

// determine strlen for a counted string buffer which may or may not be terminated
size_t strlencounted(const char *string, size_t maxcnt);

// determine Unicode strlen for a counted string buffer which may or may not be terminated
size_t ustrlencounted(const short *string, size_t maxcnt);

// Performs a percent encoding of the source string into the destination string RFC 2396
NTSTATUS BackslashEncodeString(IN PSTRING pstrSrc,  OUT PSTRING pstrDst);

// Print out the date and time from a given TimeStamp (converted to localtime)
NTSTATUS PrintTimeString(TimeStamp tsValue, BOOL fLocalTime);

// Printout the Hex representation of a buffer
NTSTATUS MyPrintBytes(void *pbuff, USHORT uNumBytes, PSTRING pstrOutput);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // DIGEST_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\sources.inc ===
C_DEFINES=$(C_DEFINES) -DSECURITY_WIN32 -DUNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\bndcache.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        bndcache.cxx
//
// Contents:    Binding cache for Kerberos Package
//
//
// History:     13-August-1996  Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#define BNDCACHE_ALLOCATE
#include <kerbp.h>

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitBindingCache
//
//  Synopsis:   Initializes the binding cache
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitBindingCache(
    VOID
    )
{
    NTSTATUS Status;

    Status = KerbInitializeList( &KerbBindingCache );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerberosBindingCacheInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeList( &KerbBindingCache );
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupBindingCache
//
//  Synopsis:   Frees the binding cache
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCleanupBindingCache(
    BOOLEAN FreeList
    )
{
    PKERB_BINDING_CACHE_ENTRY CacheEntry;

    if (KerberosBindingCacheInitialized)
    {
        KerbLockList(&KerbBindingCache);

        //
        // Go through the list of bindings and dereference them all
        //

        while (!IsListEmpty(&KerbBindingCache.List))
        {
            CacheEntry = CONTAINING_RECORD(
                            KerbBindingCache.List.Flink,
                            KERB_BINDING_CACHE_ENTRY,
                            ListEntry.Next
                            );

            DsysAssert( CacheEntry != NULL );

            KerbReferenceListEntry(
                &KerbBindingCache,
                &CacheEntry->ListEntry,
                TRUE
                );

            KerbDereferenceBindingCacheEntry(CacheEntry);
        }


        //
        // If we want to free the list, orphan the lock, and free the list
        // otherwise, proceed on w/ the "fresh" cache.
        //
        if ( FreeList )
        {
            KerbFreeList(&KerbBindingCache);
        }
        else
        {
            KerbUnlockList(&KerbBindingCache);
        }

    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceBindingCacheEntry
//
//  Synopsis:   Dereferences a binding cache entry
//
//  Effects:    Dereferences the binding cache entry to make it go away
//              when it is no longer being used.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   BindingCacheEntry - The binding cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbDereferenceBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry
    )
{
    if (KerbDereferenceListEntry(
            &BindingCacheEntry->ListEntry,
            &KerbBindingCache
            ) )
    {
        KerbFreeBindingCacheEntry(BindingCacheEntry);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceBindingCacheEntry
//
//  Synopsis:   References a binding cache entry
//
//  Effects:    Increments the reference count on the binding cache entry
//
//  Arguments:  BindingCacheEntry - binding cache entry  to reference
//
//  Requires:   The binding cache must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReferenceBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry,
    IN BOOLEAN RemoveFromList
    )
{
    KerbLockList(&KerbBindingCache);

    KerbReferenceListEntry(
        &KerbBindingCache,
        &BindingCacheEntry->ListEntry,
        RemoveFromList
        );

    KerbUnlockList(&KerbBindingCache);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateBindingCacheEntry
//
//  Synopsis:   References a binding cache entry by name
//
//  Effects:    Increments the reference count on the binding cache entry
//
//  Arguments:  RealmName - Contains the name of the realm for which to
//                      obtain a binding handle.
//              DesiredFlags - Flags desired for binding, such as PDC required
//              RemoveFromList - Remove cache entry from cache when found.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//
//
//--------------------------------------------------------------------------

PKERB_BINDING_CACHE_ENTRY
KerbLocateBindingCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN ULONG DesiredFlags,
    IN BOOLEAN RemoveFromList
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_BINDING_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE;

    if (DesiredFlags == 0)
    {
        DesiredFlags = KERB_NO_DC_FLAGS;
    }

    KerbLockList(&KerbBindingCache);

    //
    // Go through the binding cache looking for the correct entry
    //

    for (ListEntry = KerbBindingCache.List.Flink ;
         ListEntry !=  &KerbBindingCache.List ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_BINDING_CACHE_ENTRY, ListEntry.Next);

        DsysAssert( CacheEntry != NULL );

        if ( RtlEqualUnicodeString( &CacheEntry->RealmName, RealmName,TRUE ) &&
           ((DesiredFlags & CacheEntry->Flags) == DesiredFlags))
        {     
            Found = TRUE;

            //
            // Check to see if we should stop using this entry
            if (!RemoveFromList)
            {
                TimeStamp CurrentTime, Timeout;
                GetSystemTimeAsFileTime((PFILETIME)  &CurrentTime );

                if ((CacheEntry->DcFlags & DS_CLOSEST_FLAG) == 0)
                {
                    Timeout = KerbGlobalFarKdcTimeout;
                }
                else
                {
                    Timeout = KerbGlobalNearKdcTimeout;
                }     
                
                if (KerbGetTime(CacheEntry->DiscoveryTime) + KerbGetTime(Timeout) < KerbGetTime(CurrentTime))
                {
                    //
                    // This entry has timed out - it is not close by and we
                    // don't want to use it for too long, or its time to check
                    // for a close DC again.
                    //
                    //  Note:  This will have the sideeffect of checking for a new PDC
                    //

                    D_DebugLog((DEB_TRACE, 
                              "Purging KDC cache entry Realm: %wZ, Addr: %wZ, DcFlags %x\n",
                              &CacheEntry->RealmName,
                              &CacheEntry->KdcAddress,
                              CacheEntry->DcFlags                     
                              ));

                    RemoveFromList = TRUE;
                    Found = FALSE;
                }
                else
                {

                    D_DebugLog((DEB_TRACE,
                              "**Using** KDC cache entry Realm: %wZ, Addr: %wZ, DcFlags %x\n",
                              &CacheEntry->RealmName,
                              &CacheEntry->KdcAddress,
                              CacheEntry->DcFlags                     
                              ));


#ifdef CACHE_TRACE


                    
                    if ((CacheEntry->DcFlags & DS_CLOSEST_FLAG) == DS_CLOSEST_FLAG)
                    {
                        DebugLog((DEB_ERROR, "CLOSE DC "));
                    }
                    else 
                    {
                        DebugLog((DEB_ERROR, "FAR DC "));                        

                    }

                    if ((CacheEntry->DcFlags & DS_PDC_FLAG) == DS_PDC_FLAG)
                    {
                        
                        DebugLog((DEB_ERROR, "-- ** PDC **\n"));      
                    }
                    else 
                    {
                    
                        DebugLog((DEB_ERROR, "-- BDC\n"));    

                    }
#endif

                }

            }
            KerbReferenceBindingCacheEntry(
                CacheEntry,
                RemoveFromList
                );

            //
            // If we aren't returning this, dereference it now
            //

            if (!Found)
            {
                KerbDereferenceBindingCacheEntry( CacheEntry );
            }

            break;
        }
    }
    if (!Found)
    {
        CacheEntry = NULL;
    }

    KerbUnlockList(&KerbBindingCache);
    return(CacheEntry);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeBindingCacheEntry
//
//  Synopsis:   Frees memory associated with a binding cache entry
//
//  Effects:
//
//  Arguments:  BindingCacheEntry - The cache entry to free. It must be
//                      unlinked.
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry
    )
{
    KerbFreeString(&BindingCacheEntry->RealmName);
    KerbFreeString(&BindingCacheEntry->KdcAddress);

    KerbFree(BindingCacheEntry);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertBinding
//
//  Synopsis:   Inserts a binding into the binding cache
//
//  Effects:    bumps reference count on binding
//
//  Arguments:  CacheEntry - Cache entry to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInsertBinding(
    IN PKERB_BINDING_CACHE_ENTRY CacheEntry
    )
{
    KerbInsertListEntry(
        &CacheEntry->ListEntry,
        &KerbBindingCache
        );

    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCacheBinding
//
//  Synopsis:   Caches a binding in the binding cache
//
//  Effects:    creates a cache entry.
//
//  Arguments:  RealmName - The realm name of the KDC the binding is to.
//              KdcAddress - address of the KDC
//              AddressType - Type of address, from DsGetDCName flags
//              Flags - These were the desired flags that we asked for
//              DcFlags - These are the flags the dc has
//              CacheFlags - Special meaning so we don't use the locator bits
//              CacheEntry - Receives the new binding cache entry, referenced
//
//  Requires:
//
//  Returns:     STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:      Locks the binding cache for write access while adding
//              the cache entry. Removes a cache entry for the same domain 
//              before adding this one.
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCacheBinding(
    IN PUNICODE_STRING RealmName,
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Flags,
    IN ULONG DcFlags,
    IN ULONG CacheFlags,
    OUT PKERB_BINDING_CACHE_ENTRY * NewCacheEntry
    )
{
    PKERB_BINDING_CACHE_ENTRY CacheEntry = NULL;
    PKERB_BINDING_CACHE_ENTRY OldCacheEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DesiredFlags = KERB_NO_DC_FLAGS;
    
    D_DebugLog((DEB_TRACE, 
          "Adding Binding Cache Entry - %wZ : %wZ, DcFlags %x CacheFlags %x\n",
          RealmName,
          KdcAddress,
          DcFlags,
          CacheFlags
          ));

    Flags &= ~DS_FORCE_REDISCOVERY; //not a valid flag

    
    //
    // If we requested a PDC, and this is a PDC, then cache it
    // as a PDC.  Otherwise, we just got lucky, and we'll use 
    // the PDC naturally.
    //
    if ((Flags == DS_PDC_REQUIRED) && ((DcFlags & DS_PDC_FLAG) == DS_PDC_FLAG))
    {
        D_DebugLog((DEB_TRACE, "Caching as PDC\n"));      
        DesiredFlags = DS_PDC_REQUIRED;
    } 
    else 
    {
        D_DebugLog((DEB_TRACE, "Caching as BDC\n"));
        Flags &= ~DS_PDC_REQUIRED; // clear the flag.
        DcFlags &= ~DS_PDC_FLAG;

    }

    *NewCacheEntry = NULL;

    CacheEntry = (PKERB_BINDING_CACHE_ENTRY)
        KerbAllocate(sizeof(KERB_BINDING_CACHE_ENTRY));
    if (CacheEntry == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbInitializeListEntry(
        &CacheEntry->ListEntry
        );

    GetSystemTimeAsFileTime((PFILETIME)
        &CacheEntry->DiscoveryTime
        );

    Status = KerbDuplicateString(
                &CacheEntry->RealmName,
                RealmName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &CacheEntry->KdcAddress,
                KdcAddress
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    CacheEntry->AddressType = AddressType;
    CacheEntry->Flags = ((Flags == 0) ? KERB_NO_DC_FLAGS : Flags);
    CacheEntry->DcFlags = DcFlags;
    CacheEntry->CacheFlags = CacheFlags;        


    //
    // Before we insert this binding we want to remove any
    // previous instances of bindings to the same realm.
    //

    OldCacheEntry = KerbLocateBindingCacheEntry(
                        RealmName,
                        DesiredFlags,  // only hammer on PDC entries
                        TRUE    // remove from cache
                        );

    if (OldCacheEntry != NULL)
    {
        KerbDereferenceBindingCacheEntry( OldCacheEntry );
    }

    //
    // Insert the cache entry into the cache
    //

    Status = KerbInsertBinding(
                CacheEntry
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *NewCacheEntry = CacheEntry;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (NULL != CacheEntry)
        {
            KerbFreeBindingCacheEntry(CacheEntry);
        }
    }

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRemoveBindingCacheEntry
//
//  Synopsis:   removes an entry from the binding cache
//
//  Effects:
//
//  Arguments:  CacheEntry - entry to remove
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbRemoveBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY CacheEntry
    )
{
    KerbLockList(&KerbBindingCache);

    KerbReferenceBindingCacheEntry(
        CacheEntry,
        TRUE
        );

    KerbDereferenceBindingCacheEntry(
        CacheEntry
        );

    KerbUnlockList(&KerbBindingCache);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\credmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        credmgr.cxx
//
// Contents:    Code for managing credentials list for the Kerberos package
//
//
// History:     17-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#define CREDMGR_ALLOCATE
#include <kerbp.h>
#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitCredentialList
//
//  Synopsis:   Initializes the Credentials list
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbInitCredentialList(
    VOID
    )
{
    NTSTATUS Status;


    Status = KerbInitializeList( &KerbCredentialList );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    KerberosCredentialsInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeList( &KerbCredentialList);

    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCredentialList
//
//  Synopsis:   Frees the credentials list
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeCredentialList(
    VOID
    )
{
    PKERB_CREDENTIAL Credential;


    if (KerberosCredentialsInitialized)
    {
        KerbLockList(&KerbCredentialList);

        //
        // Go through the list of logon sessions and dereferences them all
        //

        while (!IsListEmpty(&KerbCredentialList.List))
        {
            Credential = CONTAINING_RECORD(
                            KerbCredentialList.List.Flink,
                            KERB_CREDENTIAL,
                            ListEntry.Next
                            );

            KerbReferenceListEntry(
                &KerbCredentialList,
                &Credential->ListEntry,
                TRUE
                );

            KerbDereferenceCredential(Credential);

        }

        KerbFreeList(&KerbCredentialList);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateCredential
//
//  Synopsis:   Allocates a credential structure
//
//  Effects:    Allocates a credential, but does not add it to the
//              list of credentials
//
//  Arguments:  NewCredential - receives a new credential allocated
//                  with KerbAllocate
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//              STATUS_INSUFFICIENT_RESOURCES if the allocation fails
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAllocateCredential(
    PKERB_CREDENTIAL * NewCredential
    )
{
    PKERB_CREDENTIAL Credential;
    SECPKG_CALL_INFO CallInfo;
    NTSTATUS Status = STATUS_SUCCESS;

    *NewCredential = NULL;

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {
        D_DebugLog((DEB_ERROR,"Failed to get call info. %ws, line %d\n",
            THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Credential = (PKERB_CREDENTIAL) KerbAllocate(
                        sizeof(KERB_CREDENTIAL) );

    if (Credential == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Credential->ClientProcess = CallInfo.ProcessId;

    KerbInitializeListEntry(
        &Credential->ListEntry
        );
    //
    // Set the references to 1 since we are returning a pointer to the
    // logon session
    //

    Credential->HandleCount = 1;

    *NewCredential = Credential;

Cleanup:
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertCredential
//
//  Synopsis:   Inserts a logon session into the list of logon sessions
//
//  Effects:    bumps reference count on logon session
//
//  Arguments:  Credential - Credential to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInsertCredential(
    IN PKERB_CREDENTIAL Credential
    )
{

    //
    // insert entry at tail of list.
    // reason: entries at the head are more likely to have _TGT flag set
    // and, those are the ones we want to satisfy from cache for repeat
    // high stress offenders...
    //

    Credential->CredentialTag = KERB_CREDENTIAL_TAG_ACTIVE;

    KerbInsertListEntryTail(
        &Credential->ListEntry,
        &KerbCredentialList
        );

    return(STATUS_SUCCESS);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbFreePrimaryCredentials
//
//  Synopsis:   frees a primary credentials structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreePrimaryCredentials(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN BOOLEAN FreeBaseStructure
    )
{
    if (Credentials != NULL)
    {
        KerbFreeString(&Credentials->DomainName);
        KerbFreeString(&Credentials->OldDomainName);
        KerbFreeString(&Credentials->UserName);
        KerbFreeString(&Credentials->OldUserName);

        RtlZeroMemory( &Credentials->OldHashPassword, sizeof(Credentials->OldHashPassword) );
        if (Credentials->ClearPassword.Buffer != NULL)
        {
            RtlZeroMemory(
                Credentials->ClearPassword.Buffer,
                Credentials->ClearPassword.Length
                );
            KerbFreeString(&Credentials->ClearPassword);
            RtlZeroMemory(&Credentials->ClearPassword, sizeof(Credentials->ClearPassword));
        }
        if (Credentials->Passwords != NULL)
        {
            KerbFreeStoredCred(Credentials->Passwords);
        }
        if (Credentials->OldPasswords != NULL)
        {
            KerbFreeStoredCred(Credentials->OldPasswords);
        }
        KerbPurgeTicketCache(&Credentials->ServerTicketCache);
        KerbPurgeTicketCache(&Credentials->AuthenticationTicketCache);

        KerbFreePKCreds(Credentials->PublicKeyCreds);
        Credentials->PublicKeyCreds = NULL;

        if (FreeBaseStructure)
        {
            KerbFree(Credentials);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCredential
//
//  Synopsis:   Frees a credential structure and all contained data
//
//  Effects:
//
//  Arguments:  Credential - The credential to free.
//
//  Requires:   This credential must be unlinked
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeCredential(
    IN PKERB_CREDENTIAL Credential
    )
{

    Credential->CredentialTag = KERB_CREDENTIAL_TAG_DELETE;

    if (Credential->SuppliedCredentials != NULL)
    {
        KerbFreePrimaryCredentials(Credential->SuppliedCredentials, TRUE);
    }
    DsysAssert(Credential->ListEntry.Next.Flink == NULL);
    KerbFreeString(&Credential->CredentialName);

    KerbFree(Credential);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTicketForCredential
//
//  Synopsis:   Obtains a TGT for a credential if it doesn't already
//              have one.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetTicketForCredential(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LocalLogonSession = NULL;
    BOOLEAN GetRestrictedTgt = FALSE;
    PKERB_TICKET_CACHE_ENTRY Tgt = NULL;
    BOOLEAN PrimaryLogonSessionCredential = FALSE;

    // 
    // We've got to make a determination w.r.t. whether this
    // is an attempt to renew our primary credential.
    // This will affect our logon session flags.
    //


    if (!ARGUMENT_PRESENT(LogonSession))
    {
      LocalLogonSession = KerbReferenceLogonSession(
                              &Credential->LogonId,
                              FALSE                   // don't unlink
                              );
      if (LocalLogonSession == NULL)
      {
          Status = STATUS_NO_SUCH_LOGON_SESSION;
          goto Cleanup;
      }

    }     
    else
    {   
        LocalLogonSession = LogonSession;
    }

    
    //
    // Here we make the assumption that if we didn't get a credential
    // and we also got a logon session, then we're dealing w/ the 
    // logon session's primary credential
    //
    if ((ARGUMENT_PRESENT(Credential)) && 
        (Credential->SuppliedCredentials == NULL) &&
        (!ARGUMENT_PRESENT(CredManCredentials)))

    {
        PrimaryLogonSessionCredential = TRUE;
        D_DebugLog((DEB_TRACE_CRED, "Getting Credentials for primary logon session - %x\n", LogonSession));
    }
    else
    {
        D_DebugLog((DEB_TRACE_CRED, "Got a credential && a logon session\n"));
    }

    Status = KerbGetTicketGrantingTicket(
                LocalLogonSession,
                Credential,
                CredManCredentials,
                SuppRealm,
                &Tgt,
                NULL            // don't return credential key
                );  


    if (!NT_SUCCESS(Status))
    {                                                                                  
        goto Cleanup;

    }

    KerbWriteLockLogonSessions(LocalLogonSession);

    //
    // Clear the logon deferred bit for the logon session, if set
    // Note:  This will only be cleared as a result of refreshing
    // logon session's primary cred tgt
    // 
    if (PrimaryLogonSessionCredential && 
       ((LocalLogonSession->LogonSessionFlags & KERB_LOGON_DEFERRED) != 0))
    {   
        LocalLogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;
    }                                                                  

    //
    // If we have a credential, be sure to set the TGT_avail bit for
    // those credentials.
    //
    if (ARGUMENT_PRESENT(Credential))
    {
        Credential->CredentialFlags |= KERB_CRED_TGT_AVAIL;
        if ((Credential->CredentialFlags & KERB_CRED_RESTRICTED) != 0)
        {
            GetRestrictedTgt = TRUE;
        }
    }

    if (ARGUMENT_PRESENT(CredManCredentials))
    {
        CredManCredentials->CredentialFlags |= KERB_CRED_TGT_AVAIL;
    }

    KerbUnlockLogonSessions(LocalLogonSession);

#ifdef RESTRICTED_TOKEN
    if (GetRestrictedTgt)
    {
        Status = KerbGetRestrictedTgtForCredential(
                    LocalLogonSession,
                    Credential
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to get restricted TGT for credential: 0x%x\n",Status));

            KerbRemoveTicketCacheEntry(Tgt);

            goto Cleanup;
        }
    }

#endif

Cleanup:

    //
    // Reset the bits if we failed
    //

    if (LocalLogonSession  && !NT_SUCCESS(Status))
    {
        KerbWriteLockLogonSessions(LocalLogonSession);

        //
        // Don't touch logon session flag, unless we're 
        // dealing w/ our own logon session.   This means
        // we don't have a TGT for our initial logon session, 
        // See RefreshTgt() -- only place we supply logon session
        //
        if (PrimaryLogonSessionCredential)
        {
            LocalLogonSession->LogonSessionFlags |= KERB_LOGON_DEFERRED;
            D_DebugLog((DEB_TRACE_CRED, "Toggling ON logon deferred bit for logon session %x\n", LogonSession));
        }

        //
        // Or, we expected it to be there with our (supplied) credential
        //
        if (ARGUMENT_PRESENT(Credential))
        {
            Credential->CredentialFlags &= ~KERB_CRED_TGT_AVAIL;
        }

        KerbUnlockLogonSessions(LocalLogonSession);
    }

    if (!ARGUMENT_PRESENT(LogonSession) && (LocalLogonSession != NULL))
    {
        KerbDereferenceLogonSession(LocalLogonSession);
    }
    if (Tgt != NULL)
    {
        KerbDereferenceTicketCacheEntry(
            Tgt
            );

    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceCredential
//
//  Synopsis:   Locates a logon session from the logon ID and references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  LogonId - LogonId of logon session to locate
//              RequiredFlags - Flags required
//              RemoveFromList - If TRUE, logon session will be delinked
//              Credential - Receives the referenced credential
//
//  Requires:
//
//  Returns:    NT status codes
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbReferenceCredential(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN ULONG RequiredFlags,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CREDENTIAL * Credential
    )
{
    PKERB_CREDENTIAL LocalCredential = NULL;
    BOOLEAN Found = FALSE;
    SECPKG_CALL_INFO CallInfo;
    BOOLEAN LocalRemoveFromList = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG DereferenceCount;

    *Credential = NULL;

    if(LsaFunctions->GetCallInfo(&CallInfo))
    {
        DereferenceCount = CallInfo.CallCount;
    } else {
        ASSERT((STATUS_INTERNAL_ERROR == STATUS_SUCCESS));
        return STATUS_INTERNAL_ERROR;
    }

    if( CallInfo.Attributes & SECPKG_CALL_CLEANUP )
    {
        CallInfo.Attributes |= SECPKG_CALL_IS_TCB;
        DebugLog((DEB_TRACE, "CredHandle %p leaked by ProcessId %x Deref count: %x\n",
                    CredentialHandle, CallInfo.ProcessId, DereferenceCount));
    }

    KerbLockList(&KerbCredentialList);

    //
    // Go through the list of logon sessions looking for the correct
    // LUID
    //

    __try {
        LocalCredential = (PKERB_CREDENTIAL)CredentialHandle;

        while( LocalCredential->CredentialTag == KERB_CREDENTIAL_TAG_ACTIVE )
        {
            if (((CallInfo.Attributes & SECPKG_CALL_IS_TCB) == 0) &&
                (LocalCredential->ClientProcess != CallInfo.ProcessId) )
            {
                D_DebugLog((DEB_ERROR,"Trying to reference a credential from another process! %ws, line %d\n", THIS_FILE, __LINE__));
                // FESTER
                D_DebugLog((DEB_ERROR, "Cred - %x \nClient process - %d  Call info Pid - %d\n", LocalCredential, LocalCredential->ClientProcess, CallInfo.ProcessId));
                Found = FALSE;
                Status = STATUS_PRIVILEGE_NOT_HELD;
                break;
            }

            KerbReferenceListEntry(
                    &KerbCredentialList,
                    &LocalCredential->ListEntry,
                    FALSE                   // don't remove
                    );

            Found = TRUE;
            break;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        D_DebugLog((DEB_ERROR,"Trying to reference invalid credential %ws, line %d\n", THIS_FILE, __LINE__));
        Found = FALSE;
    }

    if (!Found)
    {
        LocalCredential = NULL;
        Status = STATUS_INVALID_HANDLE;
    }
    else
    {
        ULONG MissingFlags = RequiredFlags - (LocalCredential->CredentialFlags & RequiredFlags);

        if (MissingFlags != 0)
        {
            D_DebugLog((DEB_TRACE,"Credential %p is missing flags: needs %x\n",
                Credential,
                MissingFlags));

            if ((MissingFlags &= KERB_CRED_TGT_AVAIL) != 0)
            {
                //
                // if this is a cred for a local account then no point in attempting to
                // get a TGT
                //
                if ((LocalCredential->CredentialFlags & KERB_CRED_LOCAL_ACCOUNT) == 0)
                {
                    DsysAssert(!RemoveFromList);

                    KerbUnlockList(&KerbCredentialList);

                    D_DebugLog((DEB_TRACE_CRED,"Getting missing TGT for credential %x\n", LocalCredential));

                    Status = KerbGetTicketForCredential(
                                NULL,
                                LocalCredential,
                                NULL,
                                NULL
                                );

                    KerbLockList(&KerbCredentialList);
                }
            }
            else
            {
                Status = SEC_E_NO_CREDENTIALS;
            }

        }


        if (NT_SUCCESS(Status))
        {


            //
            // Since there may be multiple outstanding handles using this
            // structure we don't want to really remove it from the list unless
            // the last one releases it.
            //

            if (RemoveFromList)
            {
                ASSERT( DereferenceCount != 0 );
                ASSERT ( (DereferenceCount <= LocalCredential->HandleCount) );

                if( DereferenceCount > LocalCredential->HandleCount ) {
                    LocalCredential->HandleCount = 0;
                } else {
                    LocalCredential->HandleCount -= DereferenceCount;
                }

                if (LocalCredential->HandleCount == 0)
                {
                    LocalRemoveFromList = TRUE;
                }
            }

            KerbReferenceListEntry(
                &KerbCredentialList,
                &LocalCredential->ListEntry,
                LocalRemoveFromList
                );
   
            KerbDereferenceCredential(LocalCredential);
        }
        else
        {
            //
            // Remove the earlier reference
            //

            KerbDereferenceCredential(LocalCredential);
            LocalCredential = NULL;
        }


        *Credential = LocalCredential;
    }

    KerbUnlockList(&KerbCredentialList);
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceCredential
//
//  Synopsis:   Dereferences a logon session - if reference count goes
//              to zero it frees the logon session
//
//  Effects:    decrements reference count
//
//  Arguments:  Credential - Logon session to dereference
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbDereferenceCredential(
    IN PKERB_CREDENTIAL Credential
    )
{
    if (KerbDereferenceListEntry(
            &Credential->ListEntry,
            &KerbCredentialList
            ) )
    {
        KerbFreeCredential(Credential);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeCredentials
//
//  Synopsis:   Purges the list of credentials associated with a logon session
//              by dereferencing and unlinking them.
//
//  Effects:    Unlinks all credential on the list
//
//  Arguments:  CredentialList - List of credentials to purge
//
//  Requires:
//
//  Returns:    none
//
//  Notes:  No longer used, as some system processes hold cred handles long
//          after logons go away.  Leads to refcounting disasters.
//
//
//--------------------------------------------------------------------------
/*

VOID
KerbPurgeCredentials(
    IN PLIST_ENTRY CredentialList
    )
{
    PKERB_CREDENTIAL Credential;

    KerbLockList(&KerbCredentialList);
    while (!IsListEmpty(CredentialList))
    {
        Credential = CONTAINING_RECORD(
                        CredentialList->Flink,
                        KERB_CREDENTIAL,
                        NextForThisLogonSession
                        );


        //
        // Remove it from the credential list
        //

        //RemoveEntryList(&Credential->NextForThisLogonSession);
        Credential->HandleCount = 0;

        //
        // Reference it to unlink it and then dereference it
        //

        KerbReferenceListEntry(
            &KerbCredentialList,
            &Credential->ListEntry,
            TRUE
            );

        KerbDereferenceCredential(Credential);

    }
    KerbUnlockList(&KerbCredentialList);

} */


//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateCredential
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PKERB_CREDENTIAL
KerbLocateCredential(
    IN PLUID LogonId,
    IN ULONG CredentialUseFlags,
    IN PKERB_PRIMARY_CREDENTIAL SuppliedCredentials,
    IN ULONG CredentialFlags,
    IN PUNICODE_STRING CredentialName
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_CREDENTIAL Credential = NULL;
    BOOLEAN Found = FALSE;
    SECPKG_CALL_INFO CallInfo;
    NT_OWF_PASSWORD HashPassword;

    if( SuppliedCredentials != NULL )
    {
        if( SuppliedCredentials->ClearPassword.Buffer != NULL )
        {
            RtlCalculateNtOwfPassword(
                    &SuppliedCredentials->ClearPassword,
                    &HashPassword
                    );
        } else {
            ZeroMemory( &HashPassword, sizeof(HashPassword) );
        }
    }


    //
    // Match both flags
    //

    CredentialUseFlags |= CredentialFlags;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {

        D_DebugLog((DEB_ERROR,"Failed to get client info:. %ws, line %d\n",
            THIS_FILE, __LINE__));
        return(NULL);
    }


    KerbLockList(&KerbCredentialList);

    //
    // Go through the list of logon sessions looking for the correct
    // LUID
    //

    for (ListEntry = KerbCredentialList.List.Flink ;
         ListEntry !=  &KerbCredentialList.List ;
         ListEntry = ListEntry->Flink )
    {
        Credential = CONTAINING_RECORD(ListEntry, KERB_CREDENTIAL, ListEntry.Next);

        if( (Credential->ClientProcess != CallInfo.ProcessId) )
        {
            continue;
        }

        if ( (Credential->CredentialFlags & KERB_CRED_MATCH_FLAGS) != CredentialUseFlags)
        {
            continue;
        }

        if(!RtlEqualLuid(
                &Credential->LogonId,
                LogonId
                ))
        {
            continue;
        }

        if(!RtlEqualUnicodeString(
                CredentialName,
                &Credential->CredentialName,
                FALSE
                ))
        {
            continue;
        }

        if( SuppliedCredentials != NULL )
        {
            //
            // credentials supplied, but candidate didn't have creds.  continue search.
            //

            if( Credential->SuppliedCredentials == NULL )
            {
                continue;
            }


            if(!RtlEqualUnicodeString(
                        &SuppliedCredentials->UserName,
                        &Credential->SuppliedCredentials->UserName,
                        FALSE
                        ))
            {
                if(!RtlEqualUnicodeString(
                            &SuppliedCredentials->UserName,
                            &Credential->SuppliedCredentials->OldUserName,
                            FALSE
                            ))
                {
                    continue;
                }
            }

            //
            // note: both candidate and input SuppliedCredentials ClearPassword
            // is actually encrypted via KerbHidePassword().
            //

            if(!RtlEqualMemory(
                        &HashPassword,
                        &Credential->SuppliedCredentials->OldHashPassword,
                        sizeof(HashPassword)
                        ))
            {
                continue;
            }


            //
            // optimize for UPN case:
            // check as typed versus as stored/updated first,
            // then check as typed versus as typed in original cred build.
            //

            if(!RtlEqualUnicodeString(
                        &SuppliedCredentials->DomainName,
                        &Credential->SuppliedCredentials->DomainName,
                        FALSE
                        ))
            {
                if(!RtlEqualUnicodeString(
                            &SuppliedCredentials->DomainName,
                            &Credential->SuppliedCredentials->OldDomainName,
                            FALSE
                            ))
                {
                    continue;
                }
            }


            if ((SuppliedCredentials->PublicKeyCreds != NULL) &&
                (Credential->SuppliedCredentials->PublicKeyCreds != NULL))
            {

                if(!RtlEqualUnicodeString(
                        &SuppliedCredentials->PublicKeyCreds->Pin,
                        &Credential->SuppliedCredentials->PublicKeyCreds->Pin,
                        FALSE
                        ))
                {
                    continue;
                }


                if (!KerbComparePublicKeyCreds(
                        SuppliedCredentials->PublicKeyCreds,
                        Credential->SuppliedCredentials->PublicKeyCreds
                        ))
                {
                    continue;
                }

                
            }    


        } else {

            //
            // credentials not supplied, but candidate has creds.  continue search
            //

            if( Credential->SuppliedCredentials != NULL )
            {
                continue;
            }

        }

        KerbReferenceListEntry(
                    &KerbCredentialList,
                    &Credential->ListEntry,
                    FALSE
                    );

        Credential->HandleCount++;
        Found = TRUE;
        break;

    }

    KerbUnlockList(&KerbCredentialList);

    if (!Found)
    {
        Credential = NULL;
    }
    return(Credential);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateCredential
//
//  Synopsis:   Creates a new credential and links it to the credential list
//              and the list for this logon session
//
//  Effects:
//
//  Arguments:  LogonId - LogonId for this logon session
//              LogonSession - LogonSession for the client
//              CredentialUseFlags - Flags indicating if the credential is
//                      inbound or outbound
//              SuppliedCredentials - (Optionally) supplied credentials to store
//                      in the credentials. If these are present, there need
//                      not be a password on the logon session. The field is
//                      zeroed when the primary creds are stuck in the
//                      credential structure.
//              CredentialFlags - Flags about how credentials are to be
//                      used, such as to not use a PAC or to use a null
//                      session.
//              NewCredential - Receives new credential, referenced and linked
//              ExpirationTime - Receives credential expiration time
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              STATUS_INSUFFICIENT_RESOURCES on allocation failure
//
//  Notes:      Readers and writers of this credential must hold the
//              credential lock
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateCredential(
    IN PLUID LogonId,
    IN PKERB_LOGON_SESSION LogonSession,
    IN ULONG CredentialUseFlags,
    IN PKERB_PRIMARY_CREDENTIAL * SuppliedCredentials,
    IN ULONG CredentialFlags,
    IN PUNICODE_STRING CredentialName,
    OUT PKERB_CREDENTIAL * NewCredential,
    OUT PTimeStamp ExpirationTime
    )
{
    NTSTATUS Status;
    PKERB_CREDENTIAL Credential = NULL;
    ULONG LogonSessionFlags = 0;
    UNICODE_STRING ServiceRealm = NULL_UNICODE_STRING;
    BOOLEAN FoundKdc = FALSE;
    BOOLEAN fLocalCredential = FALSE;


    //
    // Check to see if we already have a credential for this situation
    //

    Credential = KerbLocateCredential(
                    LogonId,
                    CredentialUseFlags,
                    *SuppliedCredentials,
                    CredentialFlags,
                    CredentialName
                    );
    if (Credential != NULL)
    {
        KerbReadLockLogonSessions(LogonSession);

        *ExpirationTime = LogonSession->Lifetime;

        KerbUnlockLogonSessions(LogonSession);

        *NewCredential = Credential;
        return(STATUS_SUCCESS);
    }

    Status = KerbAllocateCredential(&Credential);
    if (!NT_SUCCESS(Status))
    {
         goto Cleanup;
    }

    Credential->LogonId = *LogonId;

    //
    // Make sure the flags are valid
    //

    if ((CredentialUseFlags & ~SECPKG_CRED_BOTH) != 0)
    {
        D_DebugLog((DEB_ERROR,"Invalid credential use flags: 0x%x. %ws, line %d\n",CredentialUseFlags, THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Make sure the logon session is valid for acquiring credentials
    //

    KerbReadLockLogonSessions(LogonSession);

    LogonSessionFlags = LogonSession->LogonSessionFlags;
    *ExpirationTime = LogonSession->Lifetime;

    KerbUnlockLogonSessions(LogonSession);


    //
    // Make sure the logon session is not local only.
    // We do not handle the local only case.
    //
    if (((LogonSessionFlags & KERB_LOGON_LOCAL_ONLY) != 0) &&
        (*SuppliedCredentials == NULL ))
    {
        D_DebugLog((DEB_WARN, "Trying to acquire cred handle for local logon session\n"));
        fLocalCredential = TRUE;
/*
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
*/
    }

    Credential->SuppliedCredentials = *SuppliedCredentials;
    *SuppliedCredentials = NULL;

    Credential->CredentialName = *CredentialName;
    CredentialName->Buffer = NULL;

    Credential->CredentialFlags = CredentialUseFlags | CredentialFlags;
    if (fLocalCredential)
    {
        Credential->CredentialFlags |= KERB_CRED_LOCAL_ACCOUNT;
    }

    //
    // If we have no password, we must either not have deferred the logon
    // and we can't do inbound with no TGT.
    //

    if (((LogonSessionFlags & KERB_LOGON_NO_PASSWORD) != 0) &&
        ((LogonSessionFlags & KERB_LOGON_SMARTCARD) == 0) &&
        (Credential->SuppliedCredentials == NULL))
    {
        if (((CredentialUseFlags & SECPKG_CRED_OUTBOUND) != 0) &&
            ((LogonSessionFlags & KERB_LOGON_DEFERRED) != 0))
        {
            DebugLog((DEB_WARN,"Trying to acquire cred handle w/ no supplied creds for logon session with no pass or TGT\n"));
            Status = SEC_E_NO_CREDENTIALS;
            goto Cleanup;
        }
    }

    //
    // Check to see if this was a deferred logon - if so, try to
    // finish it now.
    //

    if (((CredentialFlags & KERB_CRED_NULL_SESSION) == 0) &&
        (((LogonSessionFlags & KERB_LOGON_DEFERRED) != 0) ||
         (Credential->SuppliedCredentials != NULL)))

    {
        //
        // If this is outbound, we need to get a TGT or supplied credentials
        //

        if ((CredentialUseFlags & SECPKG_CRED_OUTBOUND) != 0)
        {
            //
            // Get an authentication ticket
            //
#ifdef notdef
            Status = KerbGetTicketForCredential(
                        LogonSession,
                        Credential
                        );


            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to get TGT for credential: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__ ));
                goto Cleanup;

            }
#endif

        }
        else
        {
            //
            // Verify that a KDC actually exists for this users's realm -
            // otherwise we don't want to bother with Kerberos. If someone
            // is explicitly supplying credentials we probably want to
            // allow them to do it.
            //

            if (((CredentialUseFlags & SECPKG_CRED_INBOUND) != 0) &&
                ((LogonSessionFlags & KERB_LOGON_DEFERRED) != 0) &&
                ((CredentialFlags & KERB_CRED_NULL_SESSION) == 0) &&
                (Credential->SuppliedCredentials == NULL))
            {

                if ((LogonSessionFlags & KERB_LOGON_NO_PASSWORD) != 0)
                {
                    D_DebugLog((DEB_WARN,"Trying to get inbound cred with no pwd or tgt\n"));
                    Status = SEC_E_NO_CREDENTIALS;
                    goto Cleanup;
                }

                KerbReadLockLogonSessions(LogonSession);

                Status = KerbDuplicateString(
                            &ServiceRealm,
                            &LogonSession->PrimaryCredentials.DomainName
                            );
                KerbUnlockLogonSessions(LogonSession);

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                //
                // If there was no domain name, then assume there is a KDC.
                //

                if (ServiceRealm.Length == 0)
                {
                    FoundKdc = TRUE;
                }

                if (!FoundKdc)
                {
                    //
                    // If we are a DC, or f this domain is our worksatation
                    // domain, check to see if
                    // we have a DNS name. If we do, then at one point we were
                    // part of an NT5 domain. Otherwise call DsGetDCName to see
                    // if there is a KDC around
                    //

                    if ((KerbGlobalRole == KerbRoleDomainController) ||
                        KerbIsThisOurDomain(
                            &ServiceRealm
                            ))
                    {
                        FoundKdc = TRUE;
                    }
                }

                //
                // If we haven't found one yet, try looking for a KDC in
                // this domain
                //

                if (!FoundKdc)
                {
                    PKERB_BINDING_CACHE_ENTRY BindingHandle = NULL;

                    DsysAssert(ServiceRealm.MaximumLength >= ServiceRealm.Length + sizeof(WCHAR));
                    DsysAssert(ServiceRealm.Buffer[ServiceRealm.Length/sizeof(WCHAR)] == L'\0');

                    Status = KerbGetKdcBinding(
                                &ServiceRealm,
                                NULL,           // no account name
                                0,              // no desired flags,
                                FALSE,          // don't call kadmin
                                FALSE,
                                &BindingHandle
                                );
                    if (NT_SUCCESS(Status))
                    {
                        FoundKdc = TRUE;
                        KerbDereferenceBindingCacheEntry(BindingHandle);
                    }

                }
                if (!FoundKdc)
                {
                    D_DebugLog((DEB_ERROR,"Didn't find KDC for domain %wZ. %ws, line %d\n",
                        &ServiceRealm, THIS_FILE, __LINE__ ));
                    Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
                    goto Cleanup;
                }
            }
        }
    }
    else
    {
        Credential->CredentialFlags |= KERB_CRED_TGT_AVAIL;
    }


    //
    // Insert the credential into the list of credentials
    //

    KerbInsertCredential(Credential);

    //
    // Notice: the order of acquiring these locks is important.
    //
    
    *NewCredential = Credential;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Credential != NULL)
        {
            //
            // Make sure we haven't linked this one yet.
            //

            DsysAssert(Credential->ListEntry.ReferenceCount == 1);
            KerbFreeCredential(Credential);
        }

        //
        // Map the error if necessary. Normally STATUS_OBJECT_NAME_NOT_FOUND
        // gets mapped to SEC_E_UNKNOWN_TARGET, but this is an invalid
        // status to return from AcquireCredentialsHandle, so instead
        // return SEC_E_NO_CREDENTIALS.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            Status = SEC_E_NO_CREDENTIALS;
        }
    }
    KerbFreeString(&ServiceRealm);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\bndcache.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        bndcache.h
//
// Contents:    Prototypes and types for binding handle  cache
//
//
// History:     13-August-1996  Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __BNDCACHE_H__
#define __BNDCACHE_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines TKTCACHE_ALLOCATE
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef BNDCACHE_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN BOOLEAN KerberosBindingCacheInitialized;
EXTERN KERBEROS_LIST KerbBindingCache;


typedef struct _KERB_BINDING_CACHE_ENTRY {
    KERBEROS_LIST_ENTRY ListEntry;
    TimeStamp DiscoveryTime;
    UNICODE_STRING RealmName;
    UNICODE_STRING KdcAddress;
    ULONG AddressType;
    ULONG Flags;  // These are requested flags for DsGetDcName
    ULONG DcFlags; // These are flags returned by DsGetDcName
    ULONG CacheFlags; // Valid CacheFlags are listed below
} KERB_BINDING_CACHE_ENTRY, *PKERB_BINDING_CACHE_ENTRY;

//  Valid CacheFlags
#define KERB_BINDING_LOCAL              0x80000000
#define KERB_BINDING_NO_TCP             0x40000000
#define KERB_BINDING_NEGATIVE_ENTRY     0x20000000

#define KERB_NO_DC_FLAGS        0x10000000

VOID
KerbDereferenceBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry
    );

VOID
KerbReferenceBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry,
    IN BOOLEAN RemoveFromList
    );

NTSTATUS
KerbInitBindingCache(
    VOID
    );

VOID
KerbCleanupBindingCache(
    BOOLEAN FreeList
    );



PKERB_BINDING_CACHE_ENTRY
KerbLocateBindingCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN ULONG DesiredFlags,
    IN BOOLEAN RemoveFromCache
    );


VOID
KerbFreeBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry
    );

VOID
KerbRemoveBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY CacheEntry
    );

NTSTATUS
KerbCacheBinding(
    IN PUNICODE_STRING RealmName,
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Flags,
    IN ULONG DcFlags,
    IN ULONG CacheFlags,
    OUT PKERB_BINDING_CACHE_ENTRY * NewCacheEntry
    );

NTSTATUS
KerbRefreshBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY CacheEntry
    );


#endif // __TKTCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\credman.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        credman.cxx
//
// Contents:    Code for credentials APIs for the Kerberos package
//
//
// History:     23-Feb-2000   Created         Jeffspel
//
//------------------------------------------------------------------------


#include <kerb.hxx>
#include <kerbp.h>


#if DBG
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCredmanCred
//
//  Synopsis:   Frees credman cred
//
//  Arguments:
//
//  Requires:
//
//  Returns:    NTSTATUS, typically ignored, as failure to update the credman
//              should not be fatal.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreeCredmanCred(
    IN PKERB_CREDMAN_CRED CredToFree
    )
{
    DsysAssert(CredToFree);
    KerbFreePrimaryCredentials(CredToFree->SuppliedCredentials, TRUE);
    KerbFreeString(&CredToFree->CredmanDomainName);
    KerbFreeString(&CredToFree->CredmanUserName);
    KerbFree(CredToFree);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceCredmanCred
//
//  Synopsis:   Frees credman cred
//
//  Arguments:
//
//  Requires:
//
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbReferenceCredmanCred(
    IN PKERB_CREDMAN_CRED Cred,
    IN PKERB_LOGON_SESSION LogonSession,
    IN BOOLEAN Unlink
    )
{

    KerbReferenceListEntry(
            &LogonSession->CredmanCredentials,
            &Cred->ListEntry,
            Unlink
            );
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceCredmanCred
//
//  Synopsis:   Frees credman cred
//
//  Arguments:
//
//  Requires:
//
//  Returns:    NTSTATUS, typically ignored, as failure to update the credman
//              should not be fatal.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbDereferenceCredmanCred(
    IN PKERB_CREDMAN_CRED Cred,
    IN PKERBEROS_LIST CredmanList
    )
{

    if (KerbDereferenceListEntry(
            &Cred->ListEntry,
            CredmanList
            ))
    {
        KerbFreeCredmanCred(Cred);
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCredmanList
//
//  Synopsis:   Free a credman list from a logon session...
//
//  Arguments:
//
//  Requires:
//
//  Returns:    NTSTATUS, typically ignored, as failure to update the credman
//              should not be fatal.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreeCredmanList(
    KERBEROS_LIST CredmanList
    )
{
    PKERB_CREDMAN_CRED Cred;
    KerbLockList(&CredmanList);

    //
    // Go through the list of credman creds and dereferences them all
    //

    while (!IsListEmpty(&CredmanList.List))
    {

        Cred = CONTAINING_RECORD(
                    CredmanList.List.Flink,
                    KERB_CREDMAN_CRED,
                    ListEntry.Next
                    );


        // unlink cred from list
        KerbReferenceListEntry(
            &CredmanList,
            &Cred->ListEntry,
            TRUE
            );

        KerbDereferenceCredmanCred(
                Cred,
                &CredmanList
                );

    }

    RtlDeleteCriticalSection(&CredmanList.Lock);


}

//+-------------------------------------------------------------------------
//
//  Function:   KerbNotifyCredentialManager
//
//  Synopsis:   This function is used to notify the credential manager of a
//              password change event.   Note:  This will always be a MIT
//              session.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    NTSTATUS, typically ignored, as failure to update the credman
//              should not be fatal.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbNotifyCredentialManager(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CHANGEPASSWORD_REQUEST ChangeRequest,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING RealmName
    )
{

    UNICODE_STRING ClientNameU = {0};
    KERBERR KerbErr;

    // FESTER:
    // We should only expect to get pwd change notification on
    // an MIT Realm pwd change, in which case, there isn't a concept of a
    // Netbios name ....

    KerbErr = KerbConvertKdcNameToString(
                    &ClientNameU,
                    ClientName,
                    NULL
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        return;
    }


    LsaINotifyPasswordChanged(
        NULL,
        &ClientNameU,
        RealmName,
        NULL,
        &ChangeRequest->OldPassword,
        &ChangeRequest->NewPassword,
        ChangeRequest->Impersonating
        );

    KerbFreeString(&ClientNameU);

}





//+-------------------------------------------------------------------------
//
//  Function:   KerbComparePasswords
//
//  Synopsis:   Verifies that two stored credentials are identical, simply
//              through comparison of KERB_ETYPE_RC4_HMAC_NT keys
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//           NULL if the user name is not a marshalled cert, a pointer
//           to the
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOL
KerbComparePasswords(
    IN PKERB_STORED_CREDENTIAL PwdList1,
    IN PKERB_STORED_CREDENTIAL PwdList2
    )
{

    PKERB_ENCRYPTION_KEY Key1 = NULL;
    PKERB_ENCRYPTION_KEY Key2 = NULL;

    Key1 = KerbGetKeyFromList(
            PwdList1,
            KERB_ETYPE_RC4_HMAC_NT
            );

    if (NULL == Key1)
    {
        D_DebugLog((DEB_ERROR, "Cred1 missing RC4 key!\n"));
        DsysAssert(FALSE);
        return FALSE;
    }

    Key2 = KerbGetKeyFromList(
            PwdList2,
            KERB_ETYPE_RC4_HMAC_NT
            );

    if (NULL == Key2)
    {
        D_DebugLog((DEB_ERROR, "Cred2 missing RC4 key!\n"));
        DsysAssert(FALSE);
        return FALSE;
    }

    return (RtlEqualMemory(
                Key1->keyvalue.value,
                Key2->keyvalue.value,
                Key1->keyvalue.length
                ));

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckUserNameForCert
//
//  Synopsis:   Looks at the passed in user name and determines if that
//              user name is a marshalled cert.  If it is the function
//              opens the user cert store and then attempts to find the
//              cert in the store.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//           NULL if the user name is not a marshalled cert, a pointer
//           to the
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCheckUserNameForCert(
    IN PLUID ClientLogonId,
    IN BOOLEAN fImpersonateClient,
    IN UNICODE_STRING *pUserName,
    OUT PCERT_CONTEXT *ppCertContext
    )
{
    CRED_MARSHAL_TYPE MarshalType;
    PCERT_CREDENTIAL_INFO pCertCredInfo = NULL;
    HCERTSTORE hCertStore = NULL;
    CRYPT_HASH_BLOB HashBlob;
    LPWSTR rgwszUserName;
    WCHAR FastUserName[(UNLEN + 1) * sizeof(WCHAR)];
    LPWSTR SlowUserName = NULL;
    BOOLEAN fImpersonating = FALSE;
    HANDLE ClientTokenHandle = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    *ppCertContext = NULL;

    // Switch to stackalloc routine when available.
    if( pUserName->Length+sizeof(WCHAR) <= sizeof(FastUserName) )
    {
        rgwszUserName = FastUserName;
    } else {
        SlowUserName = (LPWSTR)KerbAllocate( pUserName->Length+sizeof(WCHAR) );
        if( SlowUserName == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        rgwszUserName = SlowUserName;
    }


    RtlCopyMemory(
        rgwszUserName,
        pUserName->Buffer,
        pUserName->Length);
    rgwszUserName[pUserName->Length / sizeof(WCHAR)] = L'\0';


    //
    // unmarshall the cert cred info from the user name field
    // of the cred man cred
    //
    if (!CredUnmarshalCredentialW(
            rgwszUserName,
            &MarshalType,
            (void**)&pCertCredInfo
            ))
    {
        goto Cleanup;
    }
    if (CertCredential != MarshalType)
    {
        goto Cleanup;
    }

    // first need to impersonate the user so that we can call the
    // credential manager as that user
    // TODO: check if this fails.
    // don't do this until new ImpersonateLuid() is available.
    //
    if (NULL == ClientLogonId)
    {
        if (fImpersonateClient)
        {
            Status = LsaFunctions->ImpersonateClient();

            if (!NT_SUCCESS (Status))
            {
                goto Cleanup;
            }
        }
        else
        {
            goto Cleanup;
        }
    }
    else
    {
        Status = LsaFunctions->OpenTokenByLogonId(
                                    ClientLogonId,
                                    &ClientTokenHandle
                                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Unable to get the client token handle.\n"));
            goto Cleanup;
        }

        if(!SetThreadToken(NULL, ClientTokenHandle))
        {
            D_DebugLog((DEB_ERROR,"Unable to impersonate the client token handle.\n"));
            Status = STATUS_CANNOT_IMPERSONATE;
            goto Cleanup;
        }
    }

    fImpersonating = TRUE;

    // open a cert store if necessary
    if (NULL == hCertStore)
    {
        hCertStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W,
                        0,
                        0,
                        CERT_SYSTEM_STORE_CURRENT_USER,
                        L"MY");
        if (NULL == hCertStore)
        {
            Status = SEC_E_NO_CREDENTIALS;
            D_DebugLog((DEB_ERROR,"Failed to open the user cert store even though a cert cred was found.\n"));
            goto Cleanup;
        }
    }

    // find the cert in the store which meets this hash
    HashBlob.cbData = sizeof(pCertCredInfo->rgbHashOfCert);
    HashBlob.pbData = pCertCredInfo->rgbHashOfCert;
    *ppCertContext = (PCERT_CONTEXT)CertFindCertificateInStore(
                                        hCertStore,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        0,
                                        CERT_FIND_HASH,
                                        &HashBlob,
                                        NULL);

    if (NULL == *ppCertContext)
    {
        Status = SEC_E_NO_CREDENTIALS;
        D_DebugLog((DEB_ERROR,"Failed to find cert in store even though a cert cred was found.\n"));
        goto Cleanup;
    }

Cleanup:
    if (NULL != hCertStore)
    {
        CertCloseStore(hCertStore, 0);
    }

    if (fImpersonating)
    {
        RevertToSelf();
    }

    if (NULL != pCertCredInfo)
    {
        CredFree (pCertCredInfo);
    }

    if(ClientTokenHandle != NULL)
    {
        CloseHandle( ClientTokenHandle );
    }

    if( SlowUserName )
    {
        KerbFree( SlowUserName );
    }

    return Status;
}

NTSTATUS
KerbInitPrimaryCreds(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PUNICODE_STRING UserString,
    IN PUNICODE_STRING DomainString,
    IN PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING PasswordString,    // either the password or if pin
    IN BOOLEAN PubKeyCreds,
    IN OPTIONAL PCERT_CONTEXT pCertContext,
    OUT PKERB_PRIMARY_CREDENTIAL * PrimaryCreds
    );

// check username for domain/ or @ format
NTSTATUS
CredpParseUserName(
    IN OUT LPWSTR ParseName,
    OUT PUNICODE_STRING pUserName,
    OUT PUNICODE_STRING pDomainName
    )

/*++

Routine Description:

    This routine separates a passed in user name into domain and username.  A user name must have one
    of the following two syntaxes:

        <DomainName>\<UserName>
        <UserName>@<DnsDomainName>

    The name is considered to have the first syntax if the string contains an \.
    A string containing a @ is ambiguous since <UserName> may contain an @.

    For the second syntax, the last @ in the string is used since <UserName> may
    contain an @ but <DnsDomainName> cannot.

    NOTE - The function does not allocate the UNICODE_STRING buffers
    so these should not be freed (RtlInitUnicodeString is used)

Arguments:

    ParseName - Name of user to validate - will be modified

    pUserName - Returned pointing to canonical name inside of ParseName

    pDomainName - Returned pointing to domain name inside of ParseName


Return Values:

    The following status codes may be returned:

        STATUS_INVALID_ACCOUNT_NAME - The user name is not valid.

--*/

{
    NTSTATUS Status;

    LPWSTR SlashPointer;
    LPWSTR AtPointer;

    LPWSTR pTmpUserName = NULL;
    LPWSTR pTmpDomainName = NULL;

    //
    // NULL is invalid
    //

    if ( ParseName == NULL ) {
        Status = STATUS_INVALID_ACCOUNT_NAME;
        goto Cleanup;
    }

    //
    // Classify the input account name.
    //
    // The name is considered to be <DomainName>\<UserName> if the string
    // contains an \.
    //

    SlashPointer = wcsrchr( ParseName, L'\\' );

    if ( SlashPointer != NULL )
    {
        //
        // point the output strings
        //

        pTmpDomainName = ParseName;

        //
        // Skip the backslash
        //

        *SlashPointer = L'\0';
        SlashPointer ++;

        pTmpUserName = SlashPointer;
    //
    // Otherwise the name must be a UPN
    //
    }
    else
    {
        //
        // A UPN has the syntax <AccountName>@<DnsDomainName>.
        // If there are multiple @ signs,
        //  use the last one since an AccountName can have an @ in it.
        //
        //

        AtPointer = wcsrchr( ParseName, L'@' );
        if ( AtPointer == NULL )
        {
            // must be just <username>
            pTmpUserName = ParseName;
        }
        else
        {
            pTmpUserName = ParseName;
            *AtPointer = L'\0';
            AtPointer ++;

            pTmpDomainName = AtPointer;
        }
    }

    RtlInitUnicodeString( pUserName, pTmpUserName );
    RtlInitUnicodeString( pDomainName, pTmpDomainName );

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:

    return Status;

}

NTSTATUS
CredpExtractMarshalledTargetInfo(
    IN  PUNICODE_STRING TargetServerName,
    OUT CREDENTIAL_TARGET_INFORMATIONW **pTargetInfo
    )
{
    PWSTR Candidate;
    ULONG CandidateSize;

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // LSA will set Length to include only the non-marshalled portion,
    // with MaximumLength trailing data to include marshalled portion.
    //

    if( (TargetServerName == NULL) ||
        (TargetServerName->Buffer == NULL) ||
        (TargetServerName->Length >= TargetServerName->MaximumLength) ||
        ((TargetServerName->MaximumLength - TargetServerName->Length) <
            (sizeof( CREDENTIAL_TARGET_INFORMATIONW )/(sizeof(ULONG_PTR)/2)) )
        )
    {
        return STATUS_SUCCESS;
    }


    RtlCopyMemory(
            &CandidateSize,
            (PBYTE)TargetServerName->Buffer + TargetServerName->MaximumLength - sizeof(ULONG),
            sizeof( CandidateSize )
            );

    if( CandidateSize >= TargetServerName->MaximumLength )
    {
        return STATUS_SUCCESS;
    }

    Candidate = (PWSTR)(
            (PBYTE)TargetServerName->Buffer + TargetServerName->MaximumLength - CandidateSize
            );

    Status = CredUnmarshalTargetInfo (
                    Candidate,
                    CandidateSize,
                    pTargetInfo
                    );

    if( !NT_SUCCESS(Status) )
    {
        if( Status == STATUS_INVALID_PARAMETER )
        {
            Status = STATUS_SUCCESS;
        }
    }

    return Status ;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckForPKINITEnhKeyUsage
//
//  Synopsis:   Checks if the passed in cert context contains the
//              PKINIT enhanced key usage.
//
//  Arguments:  pCertContext - cert context to check for enh key usage
//
//  Requires:
//
//  Returns:    TRUE is success, FALSE is failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOL
KerbCheckForPKINITEnhKeyUsage(
    IN PCERT_CONTEXT pCertContext
    )
{
    LPSTR pszClientAuthUsage = KERB_PKINIT_CLIENT_CERT_TYPE;
    PCERT_ENHKEY_USAGE pEnhKeyUsage = NULL;
    ULONG cbEnhKeyUsage = 0;
    ULONG i;
    BOOLEAN fRet = FALSE;

    if (!CertGetEnhancedKeyUsage(
            pCertContext,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            NULL,
            &cbEnhKeyUsage))
    {
        goto Cleanup;
    }

    // allocate space for the key usage structure
    pEnhKeyUsage = (PCERT_ENHKEY_USAGE)KerbAllocate(cbEnhKeyUsage);
    if (NULL == pEnhKeyUsage)
    {
        goto Cleanup;
    }

    if (!CertGetEnhancedKeyUsage(
            pCertContext,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            pEnhKeyUsage,
            &cbEnhKeyUsage))
    {
        goto Cleanup;
    }

    // enumerate through the enh key usages looking for the PKINIT one
    for (i=0;i<pEnhKeyUsage->cUsageIdentifier;i++)
    {
        if (0 == strcmp(pszClientAuthUsage, pEnhKeyUsage->rgpszUsageIdentifier[i]))
        {
            fRet = TRUE;
            goto Cleanup;
        }
    }
Cleanup:
    if (NULL != pEnhKeyUsage)
    {
        KerbFree(pEnhKeyUsage);
    }

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAddCertCredToPrimaryCredential
//
//  Synopsis:   Adds cert context and Pin info to the kerb credential
//              structure.
//
//  Arguments:  pCertContext - logon session
//              pCertCredInfo - cert cred manager info
//              pKerbCred - credential to be updated
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbAddCertCredToPrimaryCredential(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PUNICODE_STRING pTargetName,
    IN PCERT_CONTEXT pCertContext,
    IN PUNICODE_STRING pPin,
    IN ULONG CredFlags,
    IN OUT PKERB_PRIMARY_CREDENTIAL *ppCredMgrCred
    )

{
    UNICODE_STRING UserName = {0};
    UNICODE_STRING DomainName = {0};  // get the domain from the UPN in the cert
    PKERB_PRIMARY_CREDENTIAL pOldCred;
    PKERB_PRIMARY_CREDENTIAL pNewCred = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Get the client name from the cert.
    // Place it in the return location
    //
    Status = KerbGetPrincipalNameFromCertificate(pCertContext, &UserName);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Initialize the primary credentials structure
    //

    Status = KerbInitPrimaryCreds(
                pLogonSession,
                &UserName,
                &DomainName,
                pTargetName,
                pPin,
                TRUE,
                pCertContext,
                &pNewCred
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    pNewCred->PublicKeyCreds->InitializationInfo |= CredFlags;

    Status  = KerbInitializePkCreds(
                    pNewCred->PublicKeyCreds
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    pOldCred = *ppCredMgrCred;
    *ppCredMgrCred = pNewCred;
    pNewCred = NULL;

    
    KerbFreePrimaryCredentials(pOldCred, TRUE);  
Cleanup:
    KerbFreeString(&UserName);
    KerbFreePrimaryCredentials(pNewCred, TRUE);  

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAddPasswordCredToPrimaryCredential
//
//  Synopsis:   Adds cert context and Pin info to the kerb credential
//              structure.
//
//  Arguments:  pCertContext - logon session
//              pCertCredInfo - cert cred manager info
//              pKerbCred - credential to be updated
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbAddPasswordCredToPrimaryCredential(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pTargetDomainName,
    IN PUNICODE_STRING pTargetName,
    IN PUNICODE_STRING pPassword,
    IN OUT PKERB_PRIMARY_CREDENTIAL *ppCredMgrCred
    )
{
    PKERB_PRIMARY_CREDENTIAL pOldCred;
    PKERB_PRIMARY_CREDENTIAL pNewCred = NULL;
    UNICODE_STRING RevealedPassword;
    NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory(&RevealedPassword, sizeof(RevealedPassword));
    Status = KerbDuplicatePassword(
                &RevealedPassword,
                pPassword
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbRevealPassword( &RevealedPassword );

    //
    // Initialize the primary credentials structure
    //

    Status = KerbInitPrimaryCreds(
                pLogonSession,
                pUserName,
                pTargetDomainName,
                pTargetName,
                &RevealedPassword,
                FALSE,
                NULL,
                &pNewCred
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    pOldCred = *ppCredMgrCred;
    *ppCredMgrCred = pNewCred;
    pNewCred = NULL;

    
    KerbFreePrimaryCredentials(pOldCred, TRUE);
Cleanup:
    if ((0 != RevealedPassword.Length) && (NULL != RevealedPassword.Buffer))
    {
        RtlZeroMemory(RevealedPassword.Buffer, RevealedPassword.Length);
        KerbFreeString(&RevealedPassword);
    }
    RtlZeroMemory(&RevealedPassword, sizeof(RevealedPassword));

    KerbFreePrimaryCredentials(pNewCred, TRUE);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateCredmanCred
//
//  Synopsis:   Goes to the credential manager to try and find
//              credentials for the specific target
//
//  Arguments:
//              CredToAdd - PrimaryCredential to add to credman cred
//              ppNewCred - IN OUT built cred, free w/ KerbFreeCredmanCred
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbCreateCredmanCred(
    IN PKERB_PRIMARY_CREDENTIAL CredToAdd,
    IN OUT PKERB_CREDMAN_CRED * ppNewCred
    )
{

    NTSTATUS Status = STATUS_SUCCESS;

    *ppNewCred = NULL;

    *ppNewCred = (PKERB_CREDMAN_CRED) KerbAllocate(sizeof(KERB_CREDMAN_CRED));
    if (NULL == *ppNewCred)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    Status = KerbDuplicateStringEx(
                    &(*ppNewCred)->CredmanUserName,
                    &CredToAdd->UserName,
                    FALSE
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateStringEx(
                &(*ppNewCred)->CredmanDomainName,
                &CredToAdd->DomainName,
                FALSE
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    (*ppNewCred)->SuppliedCredentials = CredToAdd;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        KerbFreeCredmanCred(*ppNewCred);
        *ppNewCred = NULL;
    }


    return (Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAddCredmanCredToLogonSession
//
//  Synopsis:   Goes to the credential manager to try and find
//              credentials for the specific target
//
//  Arguments:  pLogonSession - logon session
//              CredToMatch - PrimaryCredential to look for in logon session
//
//  Requires:
//
//  Returns:
//
//  Notes:  CredToMatch freed in this function...
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAddCredmanCredToLogonSession(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PKERB_PRIMARY_CREDENTIAL CredToMatch,
    IN OUT PKERB_CREDMAN_CRED *NewCred
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CREDMAN_CRED CredmanCred = NULL;

    PLIST_ENTRY ListEntry;
    BOOLEAN PublicKeyCred = FALSE;
    BOOLEAN Found = FALSE;

    *NewCred = NULL;


    //
    // First, make a determination if the cred's already listed
    // Replace w/ new one if password has changed.
    //

    KerbLockList(&pLogonSession->CredmanCredentials);


    //
    // Go through the list of logon sessions looking for the correct
    // credentials, if they exist...
    //

    for (ListEntry = pLogonSession->CredmanCredentials.List.Flink ;
         (ListEntry != &pLogonSession->CredmanCredentials.List && !Found);
         ListEntry = ListEntry->Flink )
    {
        CredmanCred = CONTAINING_RECORD(ListEntry, KERB_CREDMAN_CRED, ListEntry.Next);



        // We only match on UserName / DomainName for credman creds
        if(!RtlEqualUnicodeString(
                &CredToMatch->UserName,
                &CredmanCred->CredmanUserName,
                TRUE
                ))
        {
            continue;
        }


        if(!RtlEqualUnicodeString(
                &CredToMatch->DomainName,
                &CredmanCred->CredmanDomainName,
                TRUE
                ))
        {
            continue;
        }

        //
        // Differentiate between pkiint & password based structures
        //
        if ((CredmanCred->SuppliedCredentials->PublicKeyCreds != NULL) &&
            (CredToMatch->PublicKeyCreds != NULL))

        {
            if (!KerbComparePublicKeyCreds(
                    CredToMatch->PublicKeyCreds,
                    CredmanCred->SuppliedCredentials->PublicKeyCreds
                    ))
            {
                continue;
            }

            PublicKeyCred = TRUE;
        }


        Found = TRUE;
        *NewCred = CredmanCred;


    } // FOR


    if (Found)
    {
        KerbReferenceCredmanCred(
            *NewCred,
            pLogonSession,
            FALSE
            );

        //
        // Found one.  Now we've got to compare the pwd information, and
        // change it, if needed...
        //
        if (!PublicKeyCred)
        {
            //
            // Compare the password list, as the pwd may have changed...
            // Note:  This has the by-product of tossing old tickets, but
            // that's desirable if the pwd's changed, so user knows the creds
            // are bogus.
            //
            if (!KerbComparePasswords(
                    (*NewCred)->SuppliedCredentials->Passwords,
                    CredToMatch->Passwords
                    ))
            {

                D_DebugLog((DEB_ERROR, "Changing credman cred password\n"));

                PKERB_PRIMARY_CREDENTIAL OldPwds = (*NewCred)->SuppliedCredentials;
                (*NewCred)->SuppliedCredentials = CredToMatch;
                KerbFreePrimaryCredentials(OldPwds, TRUE);

                (*NewCred)->CredentialFlags &= ~KERB_CRED_TGT_AVAIL;

            }
            else
            {
                KerbFreePrimaryCredentials(CredToMatch, TRUE);
            }

        }

        //
        //  Free up the cred to match, since we already have a copy stored w/ our credential
        //


    }
    else // new cred, so prepare CredmanCred to add to list...
    {

        Status = KerbCreateCredmanCred(
                    CredToMatch,
                    NewCred
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        KerbInsertListEntryTail(
            &((*NewCred)->ListEntry),
            &pLogonSession->CredmanCredentials
            );

        // add a ref for caller of this function.
        KerbReferenceCredmanCred(
            (*NewCred),
            pLogonSession,
            FALSE
            );


    }

    //
    // We need an initial TGT for this cred
    //
    if (((*NewCred)->CredentialFlags & KERB_CRED_TGT_AVAIL) == 0)
    {

        //
        // Get an initial TGT for this cred.
        //
        Status = KerbGetTicketGrantingTicket(
                    pLogonSession,
                    NULL,
                    (*NewCred),
                    NULL,
                    NULL,
                    NULL
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failed to get TGT for credman cred  - %x\n",Status));

            if( Status == STATUS_NO_LOGON_SERVERS )
            {
                //
                // negotiate treats NO_LOGON_SERVERS as a downgrade.
                // Nego allows downgrade for explicit creds, but not default creds.
                // Credman is basically explicit creds.  So over-ride the error code.
                //

                Status = SEC_E_TARGET_UNKNOWN;
            }

            goto Cleanup;
        }

        (*NewCred)->CredentialFlags |= KERB_CRED_TGT_AVAIL;

    }

Cleanup:

    KerbUnlockList(&pLogonSession->CredmanCredentials);



    return (Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckCredMgrForGivenTarget
//
//  Synopsis:   Goes to the credential manager to try and find
//              credentials for the specific target
//
//  Arguments:  pLogonSession - logon session
//              pTargetName - service name
//              pTargetDomainName - domain name
//              pTargetForestName - forest name
//              pKerbCred - credential to be allocated
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCheckCredMgrForGivenTarget(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PUNICODE_STRING SuppliedTargetName,
    IN PKERB_INTERNAL_NAME pTargetName,
    IN ULONG TargetInfoFlags,
    IN PUNICODE_STRING pTargetDomainName,
    IN PUNICODE_STRING pTargetForestName,
    IN OUT PKERB_CREDMAN_CRED *CredmanCred,
    IN OUT PBYTE *pbMarshalledTargetInfo,
    IN OUT ULONG *cbMarshalledTargetInfo
    )
{
    CREDENTIAL_TARGET_INFORMATIONW CredTargetInfo;
    ULONG cCreds = 0;
    PCREDENTIALW *rgpCreds = NULL;
    PENCRYPTED_CREDENTIALW *rgpEncryptedCreds = NULL;
    LPWSTR pwszTargetName = NULL;
    LPWSTR pwszDomainName = NULL;
    LPWSTR pwszForestName = NULL;
    BOOLEAN fImpersonating = FALSE;
    ULONG i;
    BOOLEAN fFoundCredManCred = FALSE;
    PCERT_CREDENTIAL_INFO pCertCredInfo = NULL;
    HCERTSTORE hCertStore = NULL;
    PCERT_CONTEXT pCertContext = NULL;
    CRYPT_HASH_BLOB HashBlob;
    UNICODE_STRING CredManUserName = {0};
    UNICODE_STRING CredManDomainName = {0};
    UNICODE_STRING CredManTargetName = {0};
    UNICODE_STRING Password = {0};
    CRED_MARSHAL_TYPE MarshalType;
    UNICODE_STRING RevealedPassword;
    HANDLE ClientTokenHandle = NULL;
    CREDENTIAL_TARGET_INFORMATIONW *pTargetInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PRIMARY_CREDENTIAL pCredMgrCred = NULL;

    RtlZeroMemory(&CredTargetInfo, sizeof(CredTargetInfo));
    RtlZeroMemory(&RevealedPassword, sizeof(RevealedPassword));

    *CredmanCred = NULL;

    Status = CredpExtractMarshalledTargetInfo(
                        SuppliedTargetName,
                        &pTargetInfo
                        );

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // allocate space for the names
    //
    if (NULL != pTargetName)
    {
        //
        // want to use the second part of the SPN
        //
        if (pTargetName->NameCount > 1)
        {
            pwszTargetName = (LPWSTR)KerbAllocate(pTargetName->Names[1].Length + sizeof(WCHAR));
            if (NULL == pwszTargetName)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            RtlCopyMemory(
                (PUCHAR)pwszTargetName,
                pTargetName->Names[1].Buffer,
                pTargetName->Names[1].Length);
            pwszTargetName[pTargetName->Names[1].Length / sizeof(WCHAR)] = L'\0';
            CredTargetInfo.DnsServerName = pwszTargetName;
            RtlInitUnicodeString(&CredManTargetName, pwszTargetName);
        }
    }

    if ((NULL != pTargetDomainName) && (0 != pTargetDomainName->Length) &&
        (NULL != pTargetDomainName->Buffer))
    {
        pwszDomainName = (LPWSTR)KerbAllocate(pTargetDomainName->Length + sizeof(WCHAR));
        if (NULL == pwszDomainName)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            (PUCHAR)pwszDomainName,
            pTargetDomainName->Buffer,
            pTargetDomainName->Length);
        pwszDomainName[pTargetDomainName->Length / sizeof(WCHAR)] = L'\0';
        CredTargetInfo.DnsDomainName = pwszDomainName;
    }

    if ((NULL != pTargetForestName) && (0 != pTargetForestName->Length) &&
        (NULL != pTargetForestName->Buffer))
    {
        pwszForestName = (LPWSTR)KerbAllocate(pTargetForestName->Length + sizeof(WCHAR));
        if (NULL == pwszForestName)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            (PUCHAR)pwszForestName,
            pTargetForestName->Buffer,
            pTargetForestName->Length);
        pwszForestName[pTargetForestName->Length / sizeof(WCHAR)] = L'\0';
        CredTargetInfo.DnsTreeName = pwszForestName;
    }


    CredTargetInfo.PackageName = KERBEROS_PACKAGE_NAME;

    //
    // if marshalled targetinfo supplied, use it instead.
    //

    if( pTargetInfo )
    {
        CredTargetInfo.TargetName = pTargetInfo->TargetName;
        CredTargetInfo.NetbiosServerName = pTargetInfo->NetbiosServerName;
        CredTargetInfo.DnsServerName = pTargetInfo->DnsServerName;
        CredTargetInfo.NetbiosDomainName = pTargetInfo->NetbiosDomainName;
        CredTargetInfo.DnsDomainName = pTargetInfo->DnsDomainName;
        CredTargetInfo.DnsTreeName = pTargetInfo->DnsTreeName;
        CredTargetInfo.Flags |= pTargetInfo->Flags;
    } else {

        //
        // copy the names in to the memory and set the names
        // in the PCREDENTIAL_TARGET_INFORMATIONW struct
        //

        if (pwszTargetName)
        {
            CredTargetInfo.Flags |= CRED_TI_SERVER_FORMAT_UNKNOWN;
        }
        if (pwszDomainName)
        {
            CredTargetInfo.Flags |= CRED_TI_DOMAIN_FORMAT_UNKNOWN;
        }

        CredTargetInfo.Flags |= TargetInfoFlags;
    }


    // need to specify a flag to indicate that we don't know what we are
    // doing and both types of names should be checked.

    Status = LsaFunctions->CrediReadDomainCredentials(
                            &pLogonSession->LogonId,
                            CREDP_FLAGS_IN_PROCESS,     // Allow password to be returned
                            &CredTargetInfo,
                            0,
                            &cCreds,
                            &rgpEncryptedCreds );

    rgpCreds = (PCREDENTIALW *) rgpEncryptedCreds;

    if (!NT_SUCCESS(Status))
    {
        // quiet these.
        if ((Status == STATUS_NOT_FOUND) ||(Status == STATUS_NO_SUCH_LOGON_SESSION) )
        {
            D_DebugLog((DEB_TRACE,"No credentials from the cred mgr!\n", Status));
        }
        else
        {
            DebugLog((DEB_WARN,"Failed to read credentials from the cred mgr 0x%x.\n", Status));
        }

        // indicate success so we proceed with default creds
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }




    //
    // now evaluate the creds which were returned to determine
    // which one we should use.
    //
    // First choice is a certificate which may be
    // used for PKINIT.
    //

    for(i=0;i<cCreds;i++)
    {
        // check if this is a cert type
        if (CRED_TYPE_DOMAIN_CERTIFICATE != (rgpCreds[i])->Type)
        {
            continue;
        }

        if( !fImpersonating )
        {
            //
            // no longer need to be impersonating prior to calling credmanager
            // only impersonate if doing Certificate operations.
            //

            Status = LsaFunctions->OpenTokenByLogonId(
                                        &pLogonSession->LogonId,
                                        &ClientTokenHandle
                                        );
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog((DEB_ERROR,"Unable to get the client token handle.\n"));
                goto Cleanup;
            }

            if(!SetThreadToken(NULL, ClientTokenHandle))
            {
                D_DebugLog((DEB_ERROR,"Unable to impersonate the client token handle.\n"));
                Status = STATUS_CANNOT_IMPERSONATE;
                goto Cleanup;
            }
            fImpersonating = TRUE;
        }

        // check for the prompt now flag
        if ((rgpCreds[i])->Flags & CRED_FLAGS_PROMPT_NOW)
        {
            Status = SEC_E_LOGON_DENIED;
            goto Cleanup;
        }

        //
        // unmarshal the cert cred info from the user name field
        // of the cred man cred
        //
        if (!CredUnmarshalCredentialW(
                (rgpCreds[i])->UserName,
                &MarshalType,
                (void**)&pCertCredInfo
                ))
        {
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
        if (CertCredential != MarshalType)
        {
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        // open a cert store if necessary
        if (NULL == hCertStore)
        {
            hCertStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
                            0,
                            0,
                            CERT_SYSTEM_STORE_CURRENT_USER,
                            L"MY");
            if (NULL == hCertStore)
            {
                D_DebugLog((DEB_ERROR,"Failed to open the user cert store even though a cert cred was found.\n"));
                break;
            }
        }

        // find the cert in the store which meets this hash
        HashBlob.cbData = sizeof(pCertCredInfo->rgbHashOfCert);
        HashBlob.pbData = pCertCredInfo->rgbHashOfCert;
        pCertContext = (PCERT_CONTEXT)CertFindCertificateInStore(
                                            hCertStore,
                                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                            0,
                                            CERT_FIND_HASH,
                                            &HashBlob,
                                            pCertContext);

        if (NULL != pCertContext)
        {
            // check if the PKINIT (SC Logon) OID is in the cert
            if (KerbCheckForPKINITEnhKeyUsage(pCertContext))
            {
                //
                // add the cert credential to the Kerb credential
                //
                // Cred man will no longer give us a pin..

                Status = KerbAddCertCredToPrimaryCredential(
                            pLogonSession,
                            &CredManTargetName,
                            pCertContext,
                            &Password,   // essentially, a NULL string
                            CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS,
                            &pCredMgrCred
                            );
                if (NT_SUCCESS(Status))
                {
                    fFoundCredManCred = TRUE;
                }
                else
                {
                    D_DebugLog((DEB_WARN,"Failed to add the cert cred to the credential.\n"));
                }
                break;
            }
            else
            {
                D_DebugLog((DEB_WARN,"Failed to find the PKINIT EKU in the cred mgr cert.\n"));
            }
        }
        else
        {
            D_DebugLog((DEB_WARN,"Failed to find a cert that the cred mgr iniddciated existed\n"));
        }
    }

    //
    // If we didn't find a cert we can use then try for a password cred.
    //

    if (!fFoundCredManCred)
    {
        for(i=0;i<cCreds;i++)
        {
            // check if this is a password cred type and pick the first one
            // that we find
            if (CRED_TYPE_DOMAIN_PASSWORD == (rgpCreds[i])->Type)
            {
                // check for the prompt now flag
                if ((rgpCreds[i])->Flags & CRED_FLAGS_PROMPT_NOW)
                {
                    Status = SEC_E_LOGON_DENIED;
                    goto Cleanup;
                }

                //
                // get the user name and domain name from the credential manager info
                //
                // NOTE - CredpParseUserName does not allocate the UNICODE_STRING
                // buffers so these should not be freed (RtlInitUnicodeString is used)
                //

                Status = CredpParseUserName(
                            (rgpCreds[i])->UserName,
                            &CredManUserName,
                            &CredManDomainName);
                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_WARN,"Failed to parse the add the cert cred to the credential.\n"));
                    fFoundCredManCred = TRUE;
                    break;
                }

                Password.Buffer = (LPWSTR)((rgpCreds[i])->CredentialBlob);
                Password.MaximumLength = (USHORT)(rgpCreds[i])->CredentialBlobSize;
                Password.Length = (USHORT)(rgpEncryptedCreds[i])->ClearCredentialBlobSize;

                // add the cert credential to the Kerb credential
                Status = KerbAddPasswordCredToPrimaryCredential(
                            pLogonSession,
                            &CredManUserName,
                            &CredManDomainName,
                            &CredManTargetName,
                            &Password,
                            &pCredMgrCred
                            );
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_WARN,"Failed to add the cred mgr password to the credential.\n"));

                }
            }
        }
    }


    //
    // We've built the credman cred, now go ahead and add it to the logon.
    //
    if (NT_SUCCESS(Status) && (NULL != pCredMgrCred))
    {

        Status = KerbAddCredmanCredToLogonSession(
                        pLogonSession,
                        pCredMgrCred, // note: freed by this fn
                        CredmanCred
                        );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failed to add credman cred to logon session\n"));
            goto Cleanup;
        }

    }



Cleanup:

    if( NT_SUCCESS(Status) )
    {
        SECPKG_CALL_INFO CallInfo;

        //
        // return a copy of the credential target info for kernel callers (MUP/DFS/RDR).
        //

        if( LsaFunctions->GetCallInfo(&CallInfo) &&
            (CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE)
            )
        {
            CredMarshalTargetInfo(
                            &CredTargetInfo,
                            (PUSHORT*)pbMarshalledTargetInfo,
                            cbMarshalledTargetInfo
                            );
        }
    }


    if (fImpersonating)
    {
        RevertToSelf();
    }

    if( ClientTokenHandle != NULL )
    {
        CloseHandle( ClientTokenHandle );
    }

    if (NULL != pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if (NULL != hCertStore)
    {
        CertCloseStore(hCertStore, 0);
    }

    if( pTargetInfo != NULL )
    {
        LocalFree( pTargetInfo );
    }

    if (NULL != pwszTargetName)
    {
        KerbFree(pwszTargetName);
    }

    if (NULL != pwszDomainName)
    {
        KerbFree(pwszDomainName);
    }

    if (NULL != pwszForestName)
    {
        KerbFree(pwszForestName);
    }

    if (NULL != rgpCreds)
    {
        //
        // Free the returned credentials
        //

        LsaFunctions->CrediFreeCredentials(
                                cCreds,
                                rgpEncryptedCreds );

    }

    if (NULL != pCertCredInfo)
    {
        CredFree(pCertCredInfo);
    }

    return Status;
}

NTSTATUS
CopyCredManCredentials(
    IN PLUID LogonId,
    CREDENTIAL_TARGET_INFORMATIONW* pTargetInfo,
    IN OUT PUNICODE_STRING pUserName,
    IN OUT PUNICODE_STRING pDomainName,
    IN OUT PUNICODE_STRING pPassword
    )

/*++

Routine Description:

    Look for a keyring credential entry for the specified domain, and copy to Context handle if found

Arguments:

    LogonId -- LogonId of the calling process.

    pTargetInfo -- Information on target to search for creds.

    Context - Points to the ContextHandle of the Context
        to be referenced.

Return Value:

    STATUS_SUCCESS -- All OK

    STATUS_NOT_FOUND - Credential couldn't be found.

    All others are real failures and should be returned to the caller.
--*/

{
    NTSTATUS Status;
    PCREDENTIALW *Credentials = NULL;
    PENCRYPTED_CREDENTIALW *EncryptedCredentials = NULL;
    ULONG CredentialCount;
    ULONG CredIndex;

    RtlInitUnicodeString(pUserName, NULL);
    RtlInitUnicodeString(pDomainName, NULL);
    RtlInitUnicodeString(pPassword, NULL);

    Status = LsaFunctions->CrediReadDomainCredentials(
                            LogonId,
                            CREDP_FLAGS_IN_PROCESS,     // Allow password to be returned
                            pTargetInfo,
                            0,  // no flags
                            &CredentialCount,
                            &EncryptedCredentials );

    Credentials = (PCREDENTIALW *) EncryptedCredentials;

    if(!NT_SUCCESS(Status))
    {
        //
        // Ideally, only STATUS_NO_SUCH_LOGON_SESSION should be converted to
        // STATUS_NOT_FOUND.  However, swallowing all failures and asserting
        // these specific two works around a bug in CrediReadDomainCredentials
        // which returns invalid parameter if the target is a user account name.
        // Eventually, CrediReadDomainCredentials should return a more appropriate
        // error in this case.
        //

        return STATUS_NOT_FOUND;
    }


    //
    // Loop through the list of credentials
    //

    for ( CredIndex=0; CredIndex<CredentialCount; CredIndex++ ) {

        UNICODE_STRING UserName;
        UNICODE_STRING DomainName;
        UNICODE_STRING TempString;

        //
        // only supports password credentials
        //

        if ( Credentials[CredIndex]->Type != CRED_TYPE_DOMAIN_PASSWORD ) {
            continue;
        }

        if ( Credentials[CredIndex]->Flags & CRED_FLAGS_PROMPT_NOW ) {
            Status = SEC_E_LOGON_DENIED;
            goto Cleanup;
        }

        //
        // Sanity check the credential
        //

        if ( Credentials[CredIndex]->UserName == NULL ) {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Convert the UserName to domain name and user name
        //

        Status = CredpParseUserName(
                        Credentials[CredIndex]->UserName,
                        &UserName,
                        &DomainName
                        );

        if(!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if( DomainName.Buffer )
        {
            Status = KerbDuplicateString(pDomainName, &DomainName);
            if ( !NT_SUCCESS( Status ) )
            {
                goto Cleanup;
            }
        }



        if( UserName.Buffer )
        {
            Status = KerbDuplicateString(pUserName, &UserName);
            if ( !NT_SUCCESS( Status ) )
            {
                goto Cleanup;
            }
        }


        //
        // Free the existing password and add the new one
        //

        TempString.Buffer = (LPWSTR)Credentials[CredIndex]->CredentialBlob;
        TempString.MaximumLength = (USHORT) Credentials[CredIndex]->CredentialBlobSize;
        TempString.Length = (USHORT) EncryptedCredentials[CredIndex]->ClearCredentialBlobSize;

        // zero length password must be treated as blank or will assume it should use the
        // password of the currently logged in user.

        if ( TempString.Length == 0 )
        {
            TempString.Buffer = L"";
        }

        Status = KerbDuplicatePassword(pPassword, &TempString);
        if ( !NT_SUCCESS( Status ) )
        {
            goto Cleanup;
        }

        goto Cleanup;
    }

    Status = STATUS_NOT_FOUND;

Cleanup:

    if(!NT_SUCCESS(Status))
    {
        KerbFreeString( pUserName );
        KerbFreeString( pDomainName );
        KerbFreeString( pPassword );

        pUserName->Buffer = NULL;
        pDomainName->Buffer = NULL;
        pPassword->Buffer = NULL;
    }

    //
    // Free the returned credentials
    //

    LsaFunctions->CrediFreeCredentials(
                            CredentialCount,
                            EncryptedCredentials );

    return Status;
}



NTSTATUS
KerbProcessUserNameCredential(
    IN  PUNICODE_STRING MarshalledUserName,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING Password
    )
{

    WCHAR FastUserName[ UNLEN+1 ];
    LPWSTR SlowUserName = NULL;
    LPWSTR TempUserName;
    CRED_MARSHAL_TYPE CredMarshalType;
    PUSERNAME_TARGET_CREDENTIAL_INFO pCredentialUserName = NULL;

    CREDENTIAL_TARGET_INFORMATIONW TargetInfo;
    ULONG CredTypes;

    SECPKG_CLIENT_INFO ClientInfo;
    NTSTATUS Status = STATUS_NOT_FOUND;


    if( (MarshalledUserName->Length+sizeof(WCHAR)) <= sizeof(FastUserName) )
    {
        TempUserName = FastUserName;
    } else {

        SlowUserName = (LPWSTR)KerbAllocate( MarshalledUserName->Length + sizeof(WCHAR) );
        if( SlowUserName == NULL )
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        TempUserName = SlowUserName;
    }


    //
    // copy the input to a NULL terminated string, then attempt to unmarshal it.
    //

    RtlCopyMemory(  TempUserName,
                    MarshalledUserName->Buffer,
                    MarshalledUserName->Length
                    );

    TempUserName[ MarshalledUserName->Length / sizeof(WCHAR) ] = L'\0';

    if(!CredUnmarshalCredentialW(
                        TempUserName,
                        &CredMarshalType,
                        (VOID**)&pCredentialUserName
                        ))
    {
        goto Cleanup;
    }

    if( (CredMarshalType != UsernameTargetCredential) )
    {
        goto Cleanup;
    }


    //
    // now query credential manager for a match.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    ZeroMemory( &TargetInfo, sizeof(TargetInfo) );

    CredTypes = CRED_TYPE_DOMAIN_PASSWORD;

    TargetInfo.Flags = CRED_TI_USERNAME_TARGET;
    TargetInfo.TargetName = pCredentialUserName->UserName;
    TargetInfo.PackageName = KERBEROS_PACKAGE_NAME;
    TargetInfo.CredTypeCount = 1;
    TargetInfo.CredTypes = &CredTypes;


    Status = CopyCredManCredentials(
                    &ClientInfo.LogonId,
                    &TargetInfo,
                    UserName,
                    DomainName,
                    Password
                    );

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbRevealPassword( Password );

Cleanup:

    if( pCredentialUserName != NULL )
    {
        CredFree( pCredentialUserName );
    }

    if( SlowUserName )
    {
        KerbFree( SlowUserName );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\credmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        credmgr.h
//
// Contents:    Structures and prototyps for Kerberos credential list
//
//
// History:     17-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __CREDMGR_H__
#define __CREDMGR_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines CREDMGR_ALLOCATE
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef CREDMGR_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN KERBEROS_LIST KerbCredentialList;
EXTERN BOOLEAN KerberosCredentialsInitialized;


#define KerbGetCredentialHandle(_Credential_) ((LSA_SEC_HANDLE)(_Credential_))


NTSTATUS
KerbInitCredentialList(
    VOID
    );

VOID
KerbFreeCredentialList(
    VOID
    );


NTSTATUS
KerbAllocateCredential(
    PKERB_CREDENTIAL * NewCredential
    );

NTSTATUS
KerbInsertCredential(
    IN PKERB_CREDENTIAL Credential
    );


NTSTATUS
KerbReferenceCredential(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN ULONG Flags,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CREDENTIAL * Credential
    );


VOID
KerbDereferenceCredential(
    IN PKERB_CREDENTIAL Credential
    );


VOID
KerbPurgeCredentials(
    IN PLIST_ENTRY CredentialList
    );

NTSTATUS
KerbCreateCredential(
    IN PLUID LogonId,
    IN PKERB_LOGON_SESSION LogonSession,
    IN ULONG CredentialUseFlags,
    IN PKERB_PRIMARY_CREDENTIAL * SuppliedCredentials,
    IN ULONG CredentialFlags,
    IN PUNICODE_STRING CredentialName,
    OUT PKERB_CREDENTIAL * NewCredential,
    OUT PTimeStamp ExpirationTime
    );

VOID
KerbFreePrimaryCredentials(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN BOOLEAN FreeBaseStructure
    );

NTSTATUS
KerbGetTicketForCredential(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm
    );
//
// Credential flags
//

#define KERB_CRED_INBOUND       SECPKG_CRED_INBOUND
#define KERB_CRED_OUTBOUND      SECPKG_CRED_OUTBOUND
#define KERB_CRED_TGT_AVAIL     0x80000000
#define KERB_CRED_NO_PAC        0x40000000
#define KERB_CRED_RESTRICTED    0x10000000
#define KERB_CRED_LOCAL_ACCOUNT 0x08000000     // set on local accounts so Cred Man may be used

#define KERB_CRED_NULL_SESSION  0x20000000



#define KERB_CRED_MATCH_FLAGS (KERB_CRED_INBOUND | KERB_CRED_OUTBOUND | KERB_CRED_NULL_SESSION | KERB_CRED_NO_PAC)
#endif // __CREDMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\credapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        credapi.cxx
//
// Contents:    Code for credentials APIs for the Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------


#include <kerb.hxx>
#include <kerbp.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

#define FILENO FILENO_CREDAPI

//+-------------------------------------------------------------------------
//
//  Function:   KerbCopyClientString
//
//  Synopsis:   Copies a string from the client and if necessary converts
//              from ansi to unicode
//
//  Effects:    allocates output with either KerbAllocate (unicode)
//              or RtlAnsiStringToUnicodeString
//
//  Arguments:  StringPointer - address of string in client process
//              StringLength - Lenght (in characters) of string
//              AnsiString - if TRUE, string is ansi
//              LocalString - receives allocated string
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCopyClientString(
    IN PVOID StringPointer,
    IN ULONG StringLength,
    IN BOOLEAN AnsiString,
    OUT PUNICODE_STRING LocalString,
    IN ULONG MaxLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID LocalBuffer = NULL;
    ULONG CharSize = sizeof(WCHAR);

    if (AnsiString)
    {
        CharSize = sizeof(CHAR);
    }

    if (StringLength > MaxLength)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    LocalBuffer = KerbAllocate(StringLength * CharSize);
    if (LocalBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->CopyFromClientBuffer(
                NULL,
                StringLength * CharSize,
                LocalBuffer,
                StringPointer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (AnsiString)
    {
        ANSI_STRING TempString;
        UNICODE_STRING TempOutputString = {0};

        TempString.Buffer = (PCHAR) LocalBuffer;
        TempString.MaximumLength = TempString.Length = (USHORT) StringLength;

        Status = RtlAnsiStringToUnicodeString(
                    &TempOutputString,
                    &TempString,
                    TRUE                // allocate destination
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        *LocalString = TempOutputString;
    }
    else
    {
        LocalString->Buffer = (LPWSTR) LocalBuffer;
        LocalString->Length = (USHORT) StringLength * sizeof(WCHAR);
        LocalString->MaximumLength = LocalString->Length;
        LocalBuffer = NULL;
    }

Cleanup:
    if (LocalBuffer)
    {
        KerbFree(LocalBuffer);
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitPrimaryCreds
//
//  Synopsis:   Allocates and initializes a PKERB_PRIMARY_CREDENTIAL
//              structure.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitPrimaryCreds(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PUNICODE_STRING UserString,
    IN PUNICODE_STRING DomainString,
    IN PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING PasswordString,    // either the password or if pin
    IN BOOLEAN PubKeyCreds,
    IN OPTIONAL PCERT_CONTEXT pCertContext,
    OUT PKERB_PRIMARY_CREDENTIAL * PrimaryCreds
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Where;
    PKERB_PRIMARY_CREDENTIAL NewCreds = NULL;

    // allocate the primary cred structure
    NewCreds = (PKERB_PRIMARY_CREDENTIAL) KerbAllocate(sizeof(KERB_PRIMARY_CREDENTIAL));
    if (NewCreds == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbInitTicketCache(
        &NewCreds->ServerTicketCache
        );
    KerbInitTicketCache(
        &NewCreds->AuthenticationTicketCache
        );

    KerbInitTicketCache(
        &NewCreds->S4UTicketCache
        );


    //
    // Fill in the fields
    //

    Status = KerbDuplicateString(
                &NewCreds->UserName,
                UserString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateString(
                &NewCreds->OldUserName,
                UserString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &NewCreds->DomainName,
                DomainString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateString(
                &NewCreds->OldDomainName,
                DomainString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if (!PubKeyCreds)
    {
        if (PasswordString->Buffer != NULL)
        {
            Status = KerbDuplicatePassword(
                        &NewCreds->ClearPassword,
                        PasswordString
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            KerbHidePassword(
                &NewCreds->ClearPassword
                );

            RtlCalculateNtOwfPassword(
                        &NewCreds->ClearPassword,
                        &NewCreds->OldHashPassword
                        );
        }


        if (PasswordString->Buffer != NULL)
        {
            Status = KerbBuildPasswordList(
                        PasswordString,
                        UserString,
                        DomainString,
                        NULL,               // no supplied salt
                        NULL,               // no old password list
                        PrincipalName,
                        UserAccount,
                        PRIMARY_CRED_CLEAR_PASSWORD,
                        &NewCreds->Passwords
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else
        {
            ULONG PasswordSize;
            ULONG Index;

            //
            // Compute the size of the passwords, which are assumed to be
            // marshalled in order.
            //

            if (LogonSession->PrimaryCredentials.Passwords != NULL)
            {
                PasswordSize = sizeof(KERB_STORED_CREDENTIAL) - sizeof(KERB_KEY_DATA) * ANYSIZE_ARRAY +
                                LogonSession->PrimaryCredentials.Passwords->CredentialCount * sizeof(KERB_KEY_DATA);

                for (Index = 0; Index < LogonSession->PrimaryCredentials.Passwords->CredentialCount ; Index++ )
                {
                    PasswordSize += LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length;
                }

                NewCreds->Passwords = (PKERB_STORED_CREDENTIAL) KerbAllocate(PasswordSize);

                if (NewCreds->Passwords == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
                NewCreds->Passwords->Revision = KERB_PRIMARY_CRED_REVISION;
                NewCreds->Passwords->Flags = 0;
                NewCreds->Passwords->OldCredentialCount = 0;

                //
                // Zero the salt so we don't accidentally re-use it.
                //

                RtlInitUnicodeString(
                    &NewCreds->Passwords->DefaultSalt,
                    NULL
                    );


                NewCreds->Passwords->CredentialCount = LogonSession->PrimaryCredentials.Passwords->CredentialCount;

                Where = (PUCHAR) &NewCreds->Passwords->Credentials[NewCreds->Passwords->CredentialCount];

                //
                // Copy all the old passwords.
                //


                for (Index = 0;
                     Index < (USHORT) (NewCreds->Passwords->CredentialCount) ;
                     Index++ )
                {
                    RtlInitUnicodeString(
                        &NewCreds->Passwords->Credentials[Index].Salt,
                        NULL
                        );
                    NewCreds->Passwords->Credentials[Index].Key =
                        LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key;
                    NewCreds->Passwords->Credentials[Index].Key.keyvalue.value = Where;
                    RtlCopyMemory(
                        Where,
                        LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.value,
                        LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length
                        );
                    Where += LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length;

                }
            }
            else
            {
                D_DebugLog((DEB_ERROR,"Didn't supply enough credentials - no password available. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = SEC_E_NO_CREDENTIALS;
                goto Cleanup;
            }
        }
    }
    else
    {
        // allocate the memory for the public key creds
        NewCreds->PublicKeyCreds  = (PKERB_PUBLIC_KEY_CREDENTIALS) KerbAllocate(sizeof(KERB_PUBLIC_KEY_CREDENTIALS));
        if (NULL == NewCreds->PublicKeyCreds)
        {
            D_DebugLog((DEB_ERROR,"Couldn't allocate public key creds\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


        // the password is now considered the pin for the smartcard
        if (NULL == pCertContext)
        {
            D_DebugLog((DEB_ERROR,"Didn't supply enough credentials - no cert context available. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_NO_CREDENTIALS;
            goto Cleanup;
        }

        RtlCopyLuid(&NewCreds->PublicKeyCreds->LogonId, &LogonSession->LogonId);

        (NewCreds->PublicKeyCreds)->CertContext = CertDuplicateCertificateContext(pCertContext);
        if (NULL == (NewCreds->PublicKeyCreds)->CertContext)
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        Status = KerbDuplicateString(
                    &((NewCreds->PublicKeyCreds)->Pin),
                    PasswordString
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    *PrimaryCreds = NewCreds;
    NewCreds = NULL;
    Status = STATUS_SUCCESS;

Cleanup:
    if (NewCreds != NULL)
    {
        KerbFreePrimaryCredentials( NewCreds, TRUE );
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCaptureSuppliedCreds
//
//  Synopsis:   Captures a SEC_WINNT_AUTH_IDENTITY structure from
//              the client
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session that supplies the missing
//                      elements of the supplied creds.
//              AuthorizationData - Client address of auth data
//              SuppliedCreds - Returns constructed credentials, NULL for
//                      null session credentials.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCaptureSuppliedCreds(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PVOID AuthorizationData,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    OUT PKERB_PRIMARY_CREDENTIAL * SuppliedCreds,
    OUT PULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSEC_WINNT_AUTH_IDENTITY_EXW IdentityEx = NULL;
    SEC_WINNT_AUTH_IDENTITY_W LocalIdentity = {0};
    PSEC_WINNT_AUTH_IDENTITY_W AuthIdentity = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W Credentials = NULL;
    BOOLEAN LogonSessionsLocked = FALSE;
    UNICODE_STRING UserString = {0};
    UNICODE_STRING DomainString = {0};
    UNICODE_STRING PasswordString = {0};
    BOOLEAN AnsiCreds = FALSE;
    BOOLEAN Marshalled = FALSE;
    ULONG CredSize;
    ULONG CredentialSize = 0;
    ULONG Offset = 0;
    PCERT_CONTEXT CertContext = NULL;
    BOOLEAN fSuppliedCertCred = FALSE;

    // WOW64
    SEC_WINNT_AUTH_IDENTITY32 Cred32 = {0};
    SEC_WINNT_AUTH_IDENTITY_EX32 CredEx32 = {0};
    HANDLE TokenHandle = NULL;
    ULONG CallInfoAttributes = 0;

#if _WIN64
    SECPKG_CALL_INFO CallInfo;

    LsaFunctions->GetCallInfo( &CallInfo );
    CallInfoAttributes = CallInfo.Attributes;
#endif

    *SuppliedCreds = NULL;
    *Flags = 0;



    if (ARGUMENT_PRESENT(AuthorizationData))
    {
       IdentityEx = (PSEC_WINNT_AUTH_IDENTITY_EXW) KerbAllocate(sizeof(SEC_WINNT_AUTH_IDENTITY_EXW));
       if (IdentityEx != NULL)
       {
          // We're being called from a WOW client!  Wow!
          if (CallInfoAttributes & SECPKG_CALL_WOWCLIENT)
          {
             Status = LsaFunctions->CopyFromClientBuffer(
                           NULL,
                           sizeof(Cred32),
                           IdentityEx,
                           AuthorizationData
                           );

             if (!NT_SUCCESS(Status))
             {
                D_DebugLog((DEB_ERROR, "Failed to capture WOW64 supplied cred structure - %x\n", Status));
                goto Cleanup;
             }
             else
             {
                RtlCopyMemory(&Cred32, IdentityEx, sizeof(Cred32));
             }
          }
          else
          {
              Status =  LsaFunctions->CopyFromClientBuffer(
                                           NULL,
                                           sizeof(SEC_WINNT_AUTH_IDENTITY),
                                           IdentityEx,
                                           AuthorizationData
                                           );

              if (!NT_SUCCESS(Status))
              {
                  D_DebugLog((DEB_ERROR,"Failed to copy auth data from %p client address: 0x%x. KLIN(%x)\n",
                          AuthorizationData, Status, KLIN(FILENO, __LINE__ )));
                  goto Cleanup;
              }
          }
       }
       else
       {
          Status = STATUS_INSUFFICIENT_RESOURCES;
          D_DebugLog((DEB_ERROR, "KLIN(%x) - Failed allocate\n", KLIN(FILENO, __LINE__)));
          goto Cleanup;
       }

       //
       // Check for extended structures
       //

       if (IdentityEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION)
       {
          if (CallInfoAttributes & SECPKG_CALL_WOWCLIENT)
          {
             Status = LsaFunctions->CopyFromClientBuffer(
                                       NULL,
                                       sizeof(CredEx32),
                                       &CredEx32,
                                       AuthorizationData
                                       );

             if (NT_SUCCESS(Status))
             {
                IdentityEx->Version = CredEx32.Version;
                IdentityEx->Length = (CredEx32.Length < sizeof(SEC_WINNT_AUTH_IDENTITY_EX) ?
                                      sizeof(SEC_WINNT_AUTH_IDENTITY_EX) : CredEx32.Length);

                IdentityEx->UserLength = CredEx32.UserLength;
                IdentityEx->User = (PWSTR) UlongToPtr(CredEx32.User);
                IdentityEx->DomainLength = CredEx32.DomainLength ;
                IdentityEx->Domain = (PWSTR) UlongToPtr( CredEx32.Domain );
                IdentityEx->PasswordLength = CredEx32.PasswordLength ;
                IdentityEx->Password = (PWSTR) UlongToPtr( CredEx32.Password );
                IdentityEx->Flags = CredEx32.Flags ;
                IdentityEx->PackageListLength = CredEx32.PackageListLength ;
                IdentityEx->PackageList = (PWSTR) UlongToPtr( CredEx32.PackageList );
             }
             else
             {
               D_DebugLog((DEB_ERROR, "Failed to capture WOW64 supplied credEX structure - %x\n", Status));
               goto Cleanup;
             }
          }
          else // not WOW64
          {

             Status = LsaFunctions->CopyFromClientBuffer(
                                     NULL,
                                     sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                                     IdentityEx,
                                     AuthorizationData
                                     );

              if (!NT_SUCCESS(Status))
              {
                D_DebugLog((DEB_ERROR, "Failed to capture supplied EX structure - %x\n", Status));
                goto Cleanup;
              }
          }

          AuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) &IdentityEx->User ;
          CredSize = IdentityEx->Length ;
          Offset = FIELD_OFFSET(SEC_WINNT_AUTH_IDENTITY_EXW, User);
       }
       else // not Extended version
       {
          AuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) IdentityEx ;
          if (CallInfoAttributes & SECPKG_CALL_WOWCLIENT)
          {
             AuthIdentity->User = (PWSTR) UlongToPtr(Cred32.User);
             AuthIdentity->UserLength = Cred32.UserLength;
             AuthIdentity->Domain = (PWSTR) UlongToPtr(Cred32.Domain);
             AuthIdentity->DomainLength = Cred32.DomainLength ;
             AuthIdentity->Password = (PWSTR) UlongToPtr(Cred32.Password);
             AuthIdentity->PasswordLength = Cred32.PasswordLength ;
             AuthIdentity->Flags = Cred32.Flags ;
          }
          CredSize = sizeof(SEC_WINNT_AUTH_IDENTITY_W);
       }



       //
       // Check for the no-pac flag
       //

       if ((AuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ONLY) != 0)
       {
        //
        // This may mean that we need to get a new TGT even though
        // we really just need to drop the PAC from an existing one.
        // This could cause problems in the smart card case
        // MMS 6/1/98
        //

          *Flags |= KERB_CRED_NO_PAC;
       }

       //
       // Check for ANSI structures.
       //

       if ((AuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) != 0)
       {
          AnsiCreds = TRUE;

          //
          // Turn off the marshalled flag because we don't support marshalling
          // with ansi.
          //

          AuthIdentity->Flags &= ~SEC_WINNT_AUTH_IDENTITY_MARSHALLED;
       }
       else if ((AuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) == 0)
       {
          Status = STATUS_INVALID_PARAMETER;
          goto Cleanup;
       }

       //
       // Check to see if this is a null session request.
       //

       if ((AuthIdentity->UserLength == 0) &&
           (AuthIdentity->DomainLength == 0) &&
           (AuthIdentity->PasswordLength == 0) )
       {
          if ((AuthIdentity->User != NULL)  &&
              (AuthIdentity->Domain != NULL)  &&
              (AuthIdentity->Password != NULL) )
          {
            //
            // Return NULL credentials in this case.
            //

             *Flags |= KERB_CRED_NULL_SESSION;
             Status = STATUS_SUCCESS;
             goto Cleanup;

          }

          if ((AuthIdentity->User == NULL)  &&
              (AuthIdentity->Domain == NULL)  &&
              (AuthIdentity->Password == NULL) &&
              (*Flags == 0))
           {
             //
             // Use default credentials
             //
               Status = STATUS_SUCCESS;
               D_DebugLog((DEB_TRACE_CRED, "Using default credentials\n"));
               goto Cleanup;

          }

       }

       //
       // If the identity is marshalled, copy it all at once.
       //

       if ((AuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED) != 0)
       {
          ULONG_PTR EndOfCreds;
          Marshalled = TRUE;

         //
         // Check for validity of the sizes.
         //

          if ((AuthIdentity->UserLength > UNLEN) ||
              (AuthIdentity->DomainLength > DNS_MAX_NAME_LENGTH) ||
              (AuthIdentity->PasswordLength > PWLEN))
          {
             D_DebugLog((DEB_ERROR,"Either UserLength, DomainLength pr PasswordLength in supplied credentials has invalid length. %ws, line %d\n", THIS_FILE, __LINE__));
             Status = STATUS_INVALID_PARAMETER;
             goto Cleanup;
          }

         //
         // The callers can set the length of field to n chars, but they
         // will really occupy n+1 chars (null-terminator).
         //

          CredentialSize = CredSize +
             (  AuthIdentity->UserLength +
                AuthIdentity->DomainLength +
                AuthIdentity->PasswordLength +
                (((AuthIdentity->User != NULL) ? 1 : 0) +
                 ((AuthIdentity->Domain != NULL) ? 1 : 0) +
                 ((AuthIdentity->Password != NULL) ? 1 : 0)) ) * sizeof(WCHAR);

          EndOfCreds = (ULONG_PTR) AuthorizationData + CredentialSize;

          //
          // Verify that all the offsets are valid and no overflow will happen
          //

          ULONG_PTR TmpUser = (ULONG_PTR) AuthIdentity->User;

          if ((TmpUser != NULL) &&
              ( (TmpUser < (ULONG_PTR) AuthorizationData) ||
                (TmpUser > EndOfCreds) ||
                ((TmpUser + (AuthIdentity->UserLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                ((TmpUser + (AuthIdentity->UserLength * sizeof(WCHAR))) < TmpUser)))
          {
             D_DebugLog((DEB_ERROR,"Username in supplied credentials has invalid pointer or length. %ws, line %d\n", THIS_FILE, __LINE__));
             Status = STATUS_INVALID_PARAMETER;
             goto Cleanup;
          }

          ULONG_PTR TmpDomain = (ULONG_PTR) AuthIdentity->Domain;

          if ((TmpDomain != NULL) &&
              ( (TmpDomain < (ULONG_PTR) AuthorizationData) ||
                (TmpDomain > EndOfCreds) ||
                ((TmpDomain + (AuthIdentity->DomainLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                ((TmpDomain + (AuthIdentity->DomainLength * sizeof(WCHAR))) < TmpDomain)))
          {
             D_DebugLog((DEB_ERROR,"Domainname in supplied credentials has invalid pointer or length. %ws, line %d\n", THIS_FILE, __LINE__));
             Status = STATUS_INVALID_PARAMETER;
             goto Cleanup;
          }

          ULONG_PTR TmpPassword = (ULONG_PTR) AuthIdentity->Password;

          if ((TmpPassword != NULL) &&
              ( (TmpPassword < (ULONG_PTR) AuthorizationData) ||
                (TmpPassword > EndOfCreds) ||
                ((TmpPassword + (AuthIdentity->PasswordLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                ((TmpPassword + (AuthIdentity->PasswordLength * sizeof(WCHAR))) < TmpPassword)))
          {
             D_DebugLog((DEB_ERROR,"Password in supplied credentials has invalid pointer or length. %ws, line %d\n", THIS_FILE, __LINE__));
             Status = STATUS_INVALID_PARAMETER;
             goto Cleanup;
          }

          //
          // Allocate a chunk of memory for the credentials
          //

          Credentials = (PSEC_WINNT_AUTH_IDENTITY_W) KerbAllocate(CredentialSize - Offset);
          if (Credentials == NULL)
          {
             Status = STATUS_INSUFFICIENT_RESOURCES;
             goto Cleanup;
          }

          RtlCopyMemory(
             Credentials,
             AuthIdentity,
             sizeof(SEC_WINNT_AUTH_IDENTITY_W)
             );

          //
          // Copy the credentials from the client
          //

          Status = LsaFunctions->CopyFromClientBuffer(
             NULL,
             CredentialSize - (Offset + sizeof(SEC_WINNT_AUTH_IDENTITY_W)),
             (PUCHAR) Credentials + sizeof(SEC_WINNT_AUTH_IDENTITY_W),
             (PUCHAR) AuthorizationData + Offset + sizeof(SEC_WINNT_AUTH_IDENTITY_W)
             );
          if (!NT_SUCCESS(Status))
          {
             D_DebugLog((DEB_ERROR,"Failed to copy whole auth identity: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
             goto Cleanup;
          }

          //
          // Now convert all the offsets to pointers.
          //

          if (Credentials->User != NULL)
          {
             Credentials->User = (LPWSTR) RtlOffsetToPointer(
                Credentials->User,
                (PUCHAR) Credentials - (PUCHAR) AuthorizationData - Offset
                );
             UserString.Buffer = Credentials->User;
             UserString.Length = UserString.MaximumLength =
                (USHORT) Credentials->UserLength * sizeof(WCHAR);
          }

          if (Credentials->Domain != NULL)
          {
             Credentials->Domain = (LPWSTR) RtlOffsetToPointer(
                Credentials->Domain,
                (PUCHAR) Credentials - (PUCHAR) AuthorizationData - Offset
                );
             DomainString.Buffer = Credentials->Domain;
             DomainString.Length = DomainString.MaximumLength = (USHORT) Credentials->DomainLength * sizeof(WCHAR);
          }

          if (Credentials->Password != NULL)
          {
             Credentials->Password = (LPWSTR) RtlOffsetToPointer(
                Credentials->Password,
                (PUCHAR) Credentials - (PUCHAR) AuthorizationData - Offset
                );
             PasswordString.Buffer = Credentials->Password;
             PasswordString.Length = PasswordString.MaximumLength = (USHORT)
             Credentials->PasswordLength * sizeof(WCHAR);

          }

       }
       else
       {
        //
        // Here we need to copy the pointer individually
        //

          if (AuthIdentity->User != NULL)
          {
             Status = KerbCopyClientString(
                AuthIdentity->User,
                AuthIdentity->UserLength,
                AnsiCreds,
                &UserString,
                UNLEN
                );

             if (!NT_SUCCESS(Status))
             {
                D_DebugLog((DEB_ERROR,"Failed to copy client user name. %ws, line %d\n", THIS_FILE, __LINE__));
                goto Cleanup;
             }
          }

          if (AuthIdentity->Domain != NULL)
          {
             Status = KerbCopyClientString(
                AuthIdentity->Domain,
                AuthIdentity->DomainLength,
                AnsiCreds,
                &DomainString,
                DNS_MAX_NAME_LENGTH
                );
             if (!NT_SUCCESS(Status))
             {
                D_DebugLog((DEB_ERROR,"Failed to copy client Domain name. %ws, line %d\n", THIS_FILE, __LINE__));
                goto Cleanup;
             }
          }

          if (AuthIdentity->Password != NULL)
          {
             Status = KerbCopyClientString(
                AuthIdentity->Password,
                AuthIdentity->PasswordLength,
                AnsiCreds,
                &PasswordString,
                PWLEN
                );

             if (!NT_SUCCESS(Status))
             {
                D_DebugLog((DEB_ERROR,"Failed to copy client Password name. %ws, line %d\n", THIS_FILE, __LINE__));
                goto Cleanup;
             }
          }

          Credentials = AuthIdentity;
       }

    }
    else
    {
       Credentials = &LocalIdentity;
       RtlZeroMemory(
          Credentials,
          sizeof(SEC_WINNT_AUTH_IDENTITY_W)
          );

    }

    //
    // Now build the supplied credentials.
    //

    KerbReadLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;

    //
    // Compute the size of the new credentials
    //


    //
    // If a field is not present, use the field from the logon session
    //

    if (Credentials->User == NULL)
    {
        UserString = LogonSession->PrimaryCredentials.UserName;
    }

    D_DebugLog((DEB_TRACE_CRED,"Using user %wZ\n",&UserString));

    if (Credentials->Domain == NULL)
    {
        ULONG Index;
        BOOLEAN Upn = FALSE;

        //
        // if it's a UPN and domain was NULL, supply an empty domain
        // rather than filling in the default.
        //

        for( Index = 0 ; Index < (UserString.Length/sizeof(WCHAR)) ; Index++ )
        {
            if( UserString.Buffer[ Index ] == L'@' )
            {
                Upn = TRUE;
                break;
            }
        }

        if( !Upn )
        {
            DomainString = LogonSession->PrimaryCredentials.DomainName;
        } else {
            RtlInitUnicodeString( &DomainString, L"" );
        }
    }
    else
    {
        if ((DomainString.Length > sizeof(WCHAR)) &&
            (DomainString.Buffer[-1 + DomainString.Length / sizeof(WCHAR)] == L'.') )
        {
            DomainString.Length -= sizeof(WCHAR);
        }
    }
    D_DebugLog((DEB_TRACE_CRED,"Using domain %wZ\n",&DomainString));

    if (Credentials->Password == NULL)
    {
        //
        // The password stored in the logon session is not a string
        // so don't copy it here.
        //

        PasswordString.Buffer = NULL;
        PasswordString.Length = 0;
    }

    //
    // Check if the user name holds a cert context thumbprint
    //

    Status = KerbCheckUserNameForCert(
                    &LogonSession->LogonId,
                    FALSE,
                    &UserString,
                    &CertContext
                    );

    if (NT_SUCCESS(Status))
    {
        if (NULL != CertContext)
        {
            fSuppliedCertCred = TRUE;
        }
    }
    else
    {
        goto Cleanup;
    }

    if (fSuppliedCertCred)
    {
        //
        // Generate the PK credentials for a smart card cert
        //
        Status = KerbAddCertCredToPrimaryCredential(
                    LogonSession,
                    PrincipalName,
                    CertContext,
                    &PasswordString,
                    CONTEXT_INITIALIZED_WITH_ACH,
                    SuppliedCreds
                    );
        if (NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else
    {
        // setup the primary creds structure
        Status = KerbInitPrimaryCreds(
                    LogonSession,
                    &UserString,
                    &DomainString,
                    PrincipalName,
                    &PasswordString,
                    FALSE,
                    NULL,
                    SuppliedCreds);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

Cleanup:
    if (NULL != CertContext)
    {
        CertFreeCertificateContext(CertContext);
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    //
    // Zero the password
    //

    if (PasswordString.Buffer != NULL)
    {
        RtlZeroMemory(
            PasswordString.Buffer,
            PasswordString.Length
            );

    }
    if (AuthIdentity != NULL)
    {
        if (AnsiCreds)
        {
            if ((AuthIdentity->Password != NULL) && (PasswordString.Buffer != NULL))
            {
                RtlZeroMemory(
                    PasswordString.Buffer,
                    PasswordString.Length
                    );
                RtlFreeUnicodeString(&PasswordString);
            }
            if ((AuthIdentity->User != NULL) && (UserString.Buffer != NULL))
            {
                RtlFreeUnicodeString(&UserString);
            }
            if ((AuthIdentity->Domain != NULL) && (DomainString.Buffer != NULL))
            {
                RtlFreeUnicodeString(&DomainString);
            }
        }
        else if (!Marshalled)
        {
            if ((AuthIdentity->Password != NULL) && (PasswordString.Buffer != NULL))
            {
                KerbFree(PasswordString.Buffer);
            }
            if ((AuthIdentity->User != NULL) && (UserString.Buffer != NULL))
            {
                KerbFree(UserString.Buffer);
            }
            if ((AuthIdentity->Domain != NULL) && (DomainString.Buffer != NULL))
            {
                KerbFree(DomainString.Buffer);
            }

        }
    }
    if ((Credentials != NULL)
        && (Credentials != AuthIdentity)
        && (Credentials != &LocalIdentity))
    {
        KerbFree(Credentials);
    }

    if (IdentityEx != NULL)
    {
        KerbFree(IdentityEx);
    }

    if( TokenHandle != NULL )
    {
        CloseHandle( TokenHandle );
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptCredentials
//
//  Synopsis:   This routine is called after another package has logged
//              a user on.  The other package provides a user name and
//              password and the Kerberos package will create a logon
//              session for this user.
//
//  Effects:    Creates a logon session
//
//  Arguments:  LogonType - Type of logon, such as network or interactive
//              Accountname - Name of the account that logged on
//              PrimaryCredentials - Primary Credentials for the account,
//                  containing a domain name, password, SID, etc.
//              SupplementalCredentials - Kerberos-Specific blob of
//                  supplemental Credentials.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LogonSession = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    PUNICODE_STRING RealmName;
    PUNICODE_STRING UserName;
    UNICODE_STRING TempRealm = {0};
    UNICODE_STRING TempUser = {0};
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN UsedAlternateName = FALSE;
    LUID SystemLogonId = SYSTEM_LUID;


    D_DebugLog((DEB_TRACE_API, "SpAcceptCredentials called\n"));

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }


    D_DebugLog((DEB_TRACE_CRED,"Accepting credentials for %wZ\\%wZ\n or %wZ@%wZ",
                &PrimaryCredentials->DomainName,
                &PrimaryCredentials->DownlevelName,
                &PrimaryCredentials->Upn,
                &PrimaryCredentials->DnsDomainName
                ));

    LogonSession = KerbReferenceLogonSession(
                        &PrimaryCredentials->LogonId,
                        FALSE                           // don't unlink
                        );

    //
    // If this is an update, locate the credentials & update the password
    //

    if ((PrimaryCredentials->Flags & PRIMARY_CRED_UPDATE) != 0)
    {
        KERB_ACCOUNT_TYPE AccountType;
        LUID SystemLuid = SYSTEM_LUID;

        if (LogonSession == NULL)
        {
            goto Cleanup;
        }

        if(RtlEqualLuid(&PrimaryCredentials->LogonId, &SystemLuid))
        {
            AccountType = MachineAccount;
        } else {
            AccountType = UserAccount;
        }

        KerbWriteLockLogonSessions(LogonSession);
        Status = KerbChangeCredentialsPassword(
                    &LogonSession->PrimaryCredentials,
                    &PrimaryCredentials->Password,
                    NULL,                               // no etype info
                    AccountType,
                    PrimaryCredentials->Flags
                    );

        if(NT_SUCCESS(Status))
        {
            if( AccountType == MachineAccount )
            {
                LogonSession->LogonSessionFlags &= ~(KERB_LOGON_LOCAL_ONLY | KERB_LOGON_NO_PASSWORD);
            }
        }

        KerbUnlockLogonSessions(LogonSession);

        goto Cleanup;

    }

    //
    // This is not an update.  If we got a Logon session back from the
    // reference call, bail out now.  This is an extra call because we
    // are doing an MIT logon
    //

    if ( LogonSession )
    {
        if (RtlEqualLuid(&PrimaryCredentials->LogonId,&SystemLogonId))
        {
           D_DebugLog(( DEB_ERROR, "Somebody created a logon session for machine account\n"));
        }

        D_DebugLog(( DEB_TRACE_CRED, "Skipping AcceptCred for %wZ\\%wZ (%x:%x)\n",
                &PrimaryCredentials->DomainName,
                &PrimaryCredentials->DownlevelName,
                PrimaryCredentials->LogonId.HighPart,
                PrimaryCredentials->LogonId.LowPart ));

        goto Cleanup;

    }


    //
    // Check to see if the domain is an alias for another realm.
    //


    if (RtlEqualLuid(&PrimaryCredentials->LogonId,&SystemLogonId))
    {
        KerbGlobalReadLock();
        if (KerbLookupMitRealm(
                        &KerbGlobalDnsDomainName,
                        &MitRealm,
                        &UsedAlternateName))
         {

            KerbErr = KerbConvertKdcNameToString(
                        &TempUser,
                        KerbGlobalMitMachineServiceName,
                        NULL
                        );
            KerbGlobalReleaseLock();

            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }
            UserName = &TempUser;

            RealmName = &MitRealm->RealmName;
        }
        else
        {
            KerbGlobalReleaseLock();
            UserName = &PrimaryCredentials->DownlevelName;
            Status = KerbGetOurDomainName(
                        &TempRealm
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            if (TempRealm.Length != 0)
            {
                RealmName = &TempRealm;
            }
            else
            {
                RealmName = &PrimaryCredentials->DomainName;
            }

        }

    }
    else
    {
        if (PrimaryCredentials->Upn.Length != 0)
        {
            // UPNs can't have a realm in credential.
            RealmName = &TempRealm;
            UserName = &PrimaryCredentials->Upn;
        }
        else
        {
            RealmName = &PrimaryCredentials->DomainName;
            UserName = &PrimaryCredentials->DownlevelName;
        }
    }

    Status = KerbCreateLogonSession(
                &PrimaryCredentials->LogonId,
                UserName,
                RealmName,
                &PrimaryCredentials->Password,
                &PrimaryCredentials->OldPassword,
                PrimaryCredentials->Flags,
                LogonType,
                &LogonSession
                );


    if (!NT_SUCCESS(Status))
    {
        //
        //  If we know about the logon session, that is o.k. because we
        // probably handled the logon.
        //

        if (Status == STATUS_OBJECT_NAME_EXISTS)
        {
            Status = STATUS_SUCCESS;
            if (RtlEqualLuid(&PrimaryCredentials->LogonId,&SystemLogonId))
            {
               D_DebugLog(( DEB_ERROR, "Somebody called AcquireCredentialsHandle before AcceptCredentials completed.\n"));
            }
        }
        goto Cleanup;
    }

Cleanup:

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    KerbFreeString(&TempRealm);
    KerbFreeString(&TempUser);

    D_DebugLog((DEB_TRACE_API, "SpAcceptCredentials returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpAcquireCredentialsHandle
//
//  Synopsis:   Contains Kerberos Code for AcquireCredentialsHandle which
//              creates a Credential associated with a logon session.
//
//  Effects:    Creates a KERB_CREDENTIAL
//
//  Arguments:  PrincipalName - Name of logon session for which to create credential
//              CredentialUseFlags - Flags indicating whether the Credentials
//                  is for inbound or outbound use.
//              LogonId - The logon ID of logon session for which to create
//                  a credential.
//              AuthorizationData - Unused blob of Kerberos-specific data
//              GetKeyFunction - Unused function to retrieve a session key
//              GetKeyArgument - Argument for GetKeyFunction
//              CredentialHandle - Receives handle to new credential
//              ExpirationTime - Receives expiration time for credential
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpAcquireCredentialsHandle(
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN ULONG CredentialUseFlags,
    IN OPTIONAL PLUID LogonId,
    IN PVOID AuthorizationData,
    IN PVOID GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PLSA_SEC_HANDLE CredentialHandle,
    OUT PTimeStamp ExpirationTime
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonIdToUse = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    PKERB_PRIMARY_CREDENTIAL SuppliedCreds = NULL;
    UNICODE_STRING CapturedPrincipalName = {0};
    ULONG CredentialFlags = 0;
    LUID SystemLogonId = SYSTEM_LUID;


    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        ClientInfo.ProcessID = 0;
        goto Cleanup;
    }

    //
    // Kerberos does not support acquiring Credentials handle by name
    // so first locate the logon session to use.
    //

    //
    // First get information about the caller.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to get client information: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // If the caller supplied a logon ID they must have the TCB privilege
    //

    if (ARGUMENT_PRESENT(LogonId) && ((LogonId->LowPart != 0) || (LogonId->HighPart != 0)))
    {
        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }
        LogonIdToUse = LogonId;
    }
    else
    {
        //
        // Use the callers logon id.
        //

        LogonIdToUse = &ClientInfo.LogonId;

    }

    D_DebugLog((DEB_TRACE_API, "SpAcquireCredentialsHandle for pid 0x%x, luid (%x:%x) called\n", ClientInfo.ProcessID,
                ((LogonIdToUse==NULL) ? 0xffffffff : LogonIdToUse->HighPart),
                ((LogonIdToUse==NULL) ? 0xffffffff : LogonIdToUse->LowPart)));

    //
    // Now try to reference the logon session with this logon id.
    //

    LogonSession = KerbReferenceLogonSession(
                        LogonIdToUse,
                        FALSE           // don't unlink
                        );

    if (LogonSession == NULL)
    {
        if (RtlEqualLuid(LogonIdToUse,&SystemLogonId))
        {
           D_DebugLog(( DEB_ERROR, "AcceptCredentials was not called for the machine account\n"));
        }
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

#if DBG
    KerbReadLockLogonSessions(LogonSession);
    D_DebugLog((DEB_TRACE_CTXT, "SpAcquireCredHandle: Acquiring creds for %wZ\\%wZ\n",
        &LogonSession->PrimaryCredentials.DomainName,
        &LogonSession->PrimaryCredentials.UserName ));
    KerbUnlockLogonSessions(LogonSession);
#endif

    //
    // Check for supplied Credentials
    //

    if (ARGUMENT_PRESENT(AuthorizationData))
    {
        Status = KerbCaptureSuppliedCreds(
                    LogonSession,
                    AuthorizationData,
                    PrincipalName,
                    &SuppliedCreds,
                    &CredentialFlags
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to capture auth data: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
    }


    //
    // if there was a supplied principal name, put it into the credential
    //

    if (ARGUMENT_PRESENT(PrincipalName) && (PrincipalName->Length != 0))
    {
        Status = KerbDuplicateString(
                    &CapturedPrincipalName,
                    PrincipalName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // We found the logon session. Good. Now create a new Credentials.
    //


    Status = KerbCreateCredential(
                LogonIdToUse,
                LogonSession,
                CredentialUseFlags,
                &SuppliedCreds,
                CredentialFlags,
                &CapturedPrincipalName,
                &Credential,
                ExpirationTime
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_WARN,"Failed to create credential: 0x%x\n",Status));
        goto Cleanup;
    }

    CapturedPrincipalName.Buffer = NULL;


    //
    // If the client is a restricted token, observe that here
    // Note:  This has been punted to Blackcomb
#ifdef RESTRICTED_TOKEN
    if (ClientInfo.Restricted)
    {
        Credential->CredentialFlags |= KERB_CRED_RESTRICTED;
        D_DebugLog((DEB_TRACE_API,"Adding token restrictions\n"));

        //
        // We don't let restricted processes accept connections
        //
        if ((CredentialUseFlags & SECPKG_CRED_INBOUND) != 0)
        {
            DebugLog((DEB_ERROR,"Restricted token trying to acquire inbound credentials - denied\n"));
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        Status = KerbAddRestrictionsToCredential(
                    LogonSession,
                    Credential
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to add restrictions to credential: 0x%x\n",Status));
            goto Cleanup;
        }
    }

#endif

    *CredentialHandle = KerbGetCredentialHandle(Credential);

    KerbUtcTimeToLocalTime(
        ExpirationTime,
        ExpirationTime
        );

    D_DebugLog((DEB_TRACE_API, "SpAcquireCredentialsHandle returning success, handle = 0x%x\n",*CredentialHandle));

Cleanup:
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    if (Credential != NULL)
    {
        KerbDereferenceCredential(Credential);
    }
    if (SuppliedCreds != NULL)
    {
        KerbFreePrimaryCredentials( SuppliedCreds, TRUE );
    }

    KerbFreeString(&CapturedPrincipalName);

    D_DebugLog((DEB_TRACE_API, "SpAcquireCredentialsHandle for pid 0x%x, luid (%x:%x) returned 0x%x\n",
        ClientInfo.ProcessID,
        ((LogonIdToUse==NULL) ? 0xffffffff : LogonIdToUse->HighPart),
        ((LogonIdToUse == NULL) ? 0xffffffff : LogonIdToUse->LowPart), KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpFreeCredentialsHandle
//
//  Synopsis:   Frees a credential created by AcquireCredentialsHandle.
//
//  Effects:    Unlinks the credential from the global list and the list
//              for this client.
//
//  Arguments:  CredentialHandle - Handle to the credential to free
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              SEC_E_INVALID_HANDLE if the handle is not valid
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpFreeCredentialsHandle(
    IN LSA_SEC_HANDLE CredentialHandle
    )
{
    NTSTATUS Status;
    PKERB_CREDENTIAL Credential;

    D_DebugLog((DEB_TRACE_API,"SpFreeCredentialsHandle 0x%x called\n",CredentialHandle));

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    Status = KerbReferenceCredential(
                    CredentialHandle,
                    0,                          // no flags
                    TRUE,                       // unlink handle
                    &Credential
                    );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"SpFreeCredentialsHandle: Failed to reference credential 0x%0x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now dereference the credential. If nobody else is using this credential
    // currently it will be freed.
    //

    KerbDereferenceCredential(Credential);
    Status = STATUS_SUCCESS;

Cleanup:

    D_DebugLog((DEB_TRACE_API, "SpFreeCredentialsHandle returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpQueryCredentialsAttributes
//
//  Synopsis:   Returns attributes of a credential
//
//  Effects:    allocate memory in client address space
//
//  Arguments:  CredentialHandle - handle to query
//              CredentialAttribute - Attribute to query:
//                      SECPKG_CRED_ATTR_NAMES - returns credential name
//              Buffer - points to structure in client's address space
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpQueryCredentialsAttributes(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN ULONG CredentialAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CREDENTIAL Credential = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    LUID LogonId;
    UNICODE_STRING FullServiceName = { 0 } ;
    SecPkgCredentials_NamesW Names;

#if _WIN64
    SECPKG_CALL_INFO CallInfo;
#endif

    Names.sUserName = NULL;

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE_API,"SpQueryCredentialsAttributes Called\n"));


    Status = KerbReferenceCredential(
                    CredentialHandle,
                    0,                          // no flags
                    FALSE,                       // don't unlink
                    &Credential
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

#if _WIN64
    if(!LsaFunctions->GetCallInfo( &CallInfo ))
    {
        Status = STATUS_INTERNAL_ERROR;
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes, failed to get callinfo 0x%lx\n", Status));
        goto Cleanup;
    }
#endif

    //
    // The logon id of the credential is constant, so it is o.k.
    // to use it without locking the credential
    //

    LogonId = Credential->LogonId;

    //
    // Get the associated logon session to get the name
    //

    LogonSession = KerbReferenceLogonSession(
                        &LogonId,
                        FALSE           // don't unlink
                        );
    if (LogonSession == NULL)
    {
        DebugLog((DEB_ERROR,"Failed to locate logon session for Credential. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;

    }

    if (CredentialAttribute != SECPKG_CRED_ATTR_NAMES)
    {
        D_DebugLog((DEB_WARN, "Asked for illegal info level in QueryCredAttr: %d\n",
                CredentialAttribute));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbReadLockLogonSessions(LogonSession);

    //
    // Figure out which credentials to use
    //

    if (Credential->SuppliedCredentials != NULL)
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }
    //
    // Build the full service name
    //


    if (!KERB_SUCCESS(KerbBuildEmailName(
                &PrimaryCredentials->DomainName,
                &PrimaryCredentials->UserName,
                &FullServiceName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    KerbUnlockLogonSessions(LogonSession);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Allocate memory in the client's address space
    //

    Status = LsaFunctions->AllocateClientBuffer(
                NULL,
                FullServiceName.MaximumLength,
                (PVOID *) &Names.sUserName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Copy the string there
    //

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                FullServiceName.MaximumLength,
                Names.sUserName,
                FullServiceName.Buffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Now copy the address of the string there
    //

#if _WIN64

    if( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
    {
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(ULONG),
                    Buffer,
                    &Names
                    );
    } else {

        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(Names),
                    Buffer,
                    &Names
                    );
    }

#else

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                sizeof(Names),
                Buffer,
                &Names
                );
#endif

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:

    if (Credential != NULL)
    {
        KerbDereferenceCredential(Credential);
    }
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    KerbFreeString(
        &FullServiceName
        );

    if (!NT_SUCCESS(Status))
    {
        if (Names.sUserName != NULL)
        {
            (VOID) LsaFunctions->FreeClientBuffer(
                        NULL,
                        Names.sUserName
                        );
        }
    }

    D_DebugLog((DEB_TRACE_API, "SpQueryCredentialsAttribute returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


NTSTATUS NTAPI
SpSaveCredentials(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN PSecBuffer Credentials
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    D_DebugLog((DEB_TRACE_API,"SpSaveCredentials Called\n"));
    D_DebugLog((DEB_TRACE_API,"SpSaveCredentials returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}


NTSTATUS NTAPI
SpGetCredentials(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN OUT PSecBuffer Credentials
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    D_DebugLog((DEB_TRACE_API,"SpGetCredentials Called\n"));
    D_DebugLog((DEB_TRACE_API,"SpGetCredentials returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}


NTSTATUS NTAPI
SpDeleteCredentials(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN PSecBuffer Key
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    D_DebugLog((DEB_TRACE_API,"SpDeleteCredentials Called\n"));
    D_DebugLog((DEB_TRACE_API,"SpDeleteCredentials returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\credman.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        credman.h
//
// Contents:    Structures and prototyps for accessing credential manager
//
//
// History:     23-Feb-2000   Created         Jeffspel
//
//------------------------------------------------------------------------

#ifndef __CREDMAN_H__
#define __CREDMGR_H__

VOID
KerbFreeCredmanList(KERBEROS_LIST CredmanList);

VOID
KerbDereferenceCredmanCred(
    IN PKERB_CREDMAN_CRED Cred,
    IN PKERBEROS_LIST CredmanList
    );


VOID
KerbReferenceCredmanCred(
    IN PKERB_CREDMAN_CRED Cred,
    IN PKERB_LOGON_SESSION LogonSession,
    IN BOOLEAN Unlink
    );
  
NTSTATUS
KerbCheckUserNameForCert(
    IN PLUID ClientLogonId,
    IN BOOLEAN fImpersonateClient,
    IN UNICODE_STRING *pUserName,
    OUT PCERT_CONTEXT *ppCertContext
    );

NTSTATUS
KerbAddCertCredToPrimaryCredential(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PUNICODE_STRING pTargetName,
    IN PCERT_CONTEXT pCertContext,
    IN PUNICODE_STRING pPin,
    IN ULONG CredFlags,
    IN OUT PKERB_PRIMARY_CREDENTIAL *ppCredMgrCred);

NTSTATUS
KerbCheckCredMgrForGivenTarget(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PUNICODE_STRING SuppliedTargetName,
    IN PKERB_INTERNAL_NAME pTargetName,
    IN ULONG TargetInfoFlags,
    IN PUNICODE_STRING pTargetDomainName,
    IN PUNICODE_STRING pTargetForestName,
    IN OUT PKERB_CREDMAN_CRED *CredmanCred,
    IN OUT PBYTE *pbMarshalledTargetInfo,
    IN OUT ULONG *cbMarshalledTargetInfo
    );

VOID
KerbNotifyCredentialManager(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CHANGEPASSWORD_REQUEST ChangeRequest,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING RealmName
    );

NTSTATUS
KerbProcessUserNameCredential(
    IN  PUNICODE_STRING MarshalledUserName,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING Password
    );


#endif // __CREDMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\ctxtapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtapi.cxx
//
// Contents:    Context APIs for Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include "kerbevt.h"
#include <gssapip.h>
#include <krbaudit.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif
UNICODE_STRING KerbTargetPrefix = {sizeof(L"krb5://")-sizeof(WCHAR),sizeof(L"krb5://"),L"krb5://" };

#define FILENO FILENO_CTXTAPI
//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteContext
//
//  Synopsis:   Deletes a Kerberos context
//
//  Effects:
//
//  Arguments:  ContextHandle - The context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_HANDLE
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpDeleteContext(
    IN LSA_SEC_HANDLE ContextHandle
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context;
    KERB_CONTEXT_STATE ContextState;
    ULONG ClientProcess = 0;

    D_DebugLog((DEB_TRACE_API,"SpDeleteContext 0x%x called\n",ContextHandle));

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        Context = NULL;
        goto Cleanup;
    }

    Status = KerbReferenceContext(
                    ContextHandle,
                    TRUE,                        // unlink handle
                    &Context
                    );

    if (Context == NULL)
    {
        D_DebugLog((DEB_ERROR,"SpDeleteContext: Context 0x%x not located. %ws, line %d\n",ContextHandle, THIS_FILE, __LINE__));
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    KerbReadLockContexts();

    // Need to copy out the context data else we'll end up holding the lock
    // for too long a time.
    //
    ContextState = Context->ContextState;

    ClientProcess = Context->ClientProcess;
    KerbUnlockContexts();

    // If this was a context that was dropped in the middle,
    // audit it as a logon failure.
    //

    if (ContextState == ApReplySentState)
    {
        LsaFunctions->AuditLogon(
            STATUS_UNFINISHED_CONTEXT_DELETED,
            STATUS_SUCCESS,
            &Context->ClientName,
            &Context->ClientRealm,
            NULL,                       // no workstation
            Context->UserSid,
            Network,
            &KerberosSource,
            &Context->LogonId
            );
    }
#endif // WIN32_CHICAGO

    //
    // Now dereference the Context. If nobody else is using this Context
    // currently it will be freed.
    //

    KerbDereferenceContext(Context);
    Status = STATUS_SUCCESS;

Cleanup:

    D_DebugLog((DEB_TRACE_LEAKS,"SpDeleteContext returned 0x%x, Context 0x%x, Pid 0x%x\n",KerbMapKerbNtStatusToNtStatus(Status), Context, ClientProcess));
    D_DebugLog((DEB_TRACE_API, "SpDeleteContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbProcessTargetNames
//
//  Synopsis:   Takes the target names from both the negotiate hint and
//              supplied by the caller and creates the real Kerberos target
//              name.
//
//  Effects:
//
//  Arguments:  TargetName - supplies the name passed in the TargetName
//                      parameter of InitializeSecurityContext.
//              SuppTargetName - If present, an alternate name passed in
//                      a security token.
//              Flags - flags to use when cracking a name. May be:
//                  KERB_CRACK_NAME_USE_WKSTA_REALM - if no realm can be
//                          determined, use the realm of the wksta
//                  KERB_CRACK_NAME_REALM_SUPPLIED - the caller has the
//                      realm name, so treat "@" in the name as a normal
//                      character, not a spacer.
//              UseSpnRealmSupplied - If the target name was an spn and it
//                      contained a realm, it's set to TRUE
//              FinalTarget - The processed name.  Must be freed with KerbFreeKdcName.
//              TargetRealm - If the name contains a realm portions, this is
//                      the realm. Should be freed using KerbFreeString.
//
//
//  Requires:
//
//  Returns:
//
//  Notes:      If the name has an "@" in it, it is converted into a standard
//              Kerberos V5 name - everything after the "@" is put in the
//              realm field, and everything before the @ is separted at the
//              "/" characters into different pieces of the name. Depending
//              on the number of pieces, it is passed as a KRB_NT_PRINCIPAL (1)
//              or KRB_NT_SRV_INSTANCE (2), or KRB_NT_SRV_XHST (3+)
//
//              If the name has an "\" in it, it is assumed to be an NT4
//              name & put as is into a KRB_NT_MS_PRINCIPAL_NAME name
//
//              If the name has neither a "\" or a "@" or a "/", it is
//              assumed to be a simple name & passed as KRB_NT_PRINCIPAL
//              in the caller's domain.
//
//
//
//--------------------------------------------------------------------------

#ifdef later
#define KERB_LOCALHOST_NAME L"localhost"
#endif

NTSTATUS
KerbProcessTargetNames(
    IN PUNICODE_STRING TargetName,
    IN OPTIONAL PUNICODE_STRING SuppTargetName,
    IN ULONG Flags,
    IN OUT PULONG ProcessFlags,
    OUT PKERB_INTERNAL_NAME * FinalTarget,
    OUT PUNICODE_STRING TargetRealm,
    OUT OPTIONAL PKERB_SPN_CACHE_ENTRY * SpnCacheEntry
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT NameType = 0;
    PKERB_INTERNAL_NAME OutputName = NULL;
    USHORT NameParts = 0, ExtraNameParts = 0;
    ULONG NameLength = 0;
    USHORT Index, NameIndex;
    PUNICODE_STRING RealTargetName;
    UNICODE_STRING SuppliedRealm = {0};
    UNICODE_STRING EmptyString = {0};
    UNICODE_STRING SidString = {0};
    UNICODE_STRING FirstNamePart = {0};
    PKERB_SPN_CACHE_ENTRY LocalCacheEntry = NULL;
#ifdef later
    UNICODE_STRING LocalhostName = {0};
    BOOLEAN ReplaceLocalhost = FALSE;
#endif
    BOOLEAN DoneParsing = FALSE;
    BOOLEAN PurgedEntry = FALSE;
    PKERB_MIT_REALM MitRealm;
    BOOLEAN UsedAlternateName;
    PUCHAR Where;

    PKERB_SID_CACHE_ENTRY CacheEntry = NULL;

    *ProcessFlags = 0;

    //
    // If a supplemental target name was supplied, use it as it is more likely
    // to be correct.
    //

    if (ARGUMENT_PRESENT(SuppTargetName) && (SuppTargetName->Length > 0))
    {
        RealTargetName = SuppTargetName;
    }
    else
    {
        RealTargetName = TargetName;
    }

    //
    // If this is an IP address, we don't handle it so bail now.
    //

    if (KerbIsIpAddress(RealTargetName))
    {
        D_DebugLog((DEB_ERROR,"Ip address passed as target name: %wZ. Failing InitSecCtxt\n",
            RealTargetName ));
        Status = SEC_E_TARGET_UNKNOWN;
        goto Cleanup;
    }

#ifdef later
    RtlInitUnicodeString(
        &LocalhostName,
        KERB_LOCALHOST_NAME
        );
#endif


    //
    // Initialize the first part of the name to the whole string
    //

    FirstNamePart.Buffer = RealTargetName->Buffer;
    FirstNamePart.Length = RealTargetName->Length;
    FirstNamePart.MaximumLength = FirstNamePart.Length;

    //
    // Check the characters in the name. Search backwards to front because
    // username may have "@" signs in them.
    //

    for ( Index = (RealTargetName->Length / sizeof(WCHAR)); Index-- > 0; )
    {
        switch(RealTargetName->Buffer[Index])
        {
        case L'@':

            //
            // If we have a realm name already, ignore this character.
            //

            if ((Flags & KERB_CRACK_NAME_REALM_SUPPLIED) != 0)
            {
                break;
            }

            //
            // If we haven't hit any other separators, this is user@domain kind
            // of name
            //


            if (NameType == 0)
            {
                NameType = KRB_NT_PRINCIPAL;
                NameParts++;

                SuppliedRealm.Buffer = &RealTargetName->Buffer[Index] + 1;
                SuppliedRealm.Length = RealTargetName->Length - (Index + 1) * sizeof(WCHAR);
                SuppliedRealm.MaximumLength = SuppliedRealm.Length;

                if (SuppliedRealm.Length == 0)
                {
                    Status = SEC_E_TARGET_UNKNOWN;
                    goto Cleanup;
                }

                FirstNamePart.Buffer = RealTargetName->Buffer;
                FirstNamePart.Length = Index * sizeof(WCHAR);
                FirstNamePart.MaximumLength = FirstNamePart.Length;
            }
//            else
//            {
//                Status = SEC_E_TARGET_UNKNOWN;
//                goto Cleanup;
//            }

            break;

        case L'/':

            //
            // All names that have a '/' separator are KRB_NT_SRV_INST
            // If we saw an @before this, we need to do something special.
            //

            NameType = KRB_NT_SRV_INST;
            NameParts ++;
            break;


        case '\\':

            //
            // If we have a realm name already, ignore this character.
            //

            if ((Flags & KERB_CRACK_NAME_REALM_SUPPLIED) != 0)
            {
                break;
            }

            //
            // If we hit a backslash, this is an NT4 style name, so treat it
            // as such.
            // Just for error checking purposes, make sure that the current
            // name type was 0
            //

            if (NameType != 0)
            {
                Status = SEC_E_TARGET_UNKNOWN;
                goto Cleanup;
            }
            NameType = KRB_NT_MS_PRINCIPAL;
            NameParts = 1;
            SuppliedRealm.Buffer = RealTargetName->Buffer;
            SuppliedRealm.Length = Index * sizeof(WCHAR);
            SuppliedRealm.MaximumLength = SuppliedRealm.Length;

            FirstNamePart.Buffer = &RealTargetName->Buffer[Index] + 1;
            FirstNamePart.Length = RealTargetName->Length - (Index + 1) * sizeof(WCHAR);
            FirstNamePart.MaximumLength = FirstNamePart.Length;

            if (SuppliedRealm.Length == 0 || FirstNamePart.Length == 0)
            {
                Status = SEC_E_TARGET_UNKNOWN;
                goto Cleanup;
            }

            DoneParsing = TRUE;

            break;

        default:
            break;

        }
        if (DoneParsing)
        {
            break;
        }
    }

    //
    // If we didn't exit early, then we were sent a name with no "@" sign.
    // If there were no separators, then it is a flat principal name
    //

    if (!DoneParsing && (NameType == 0))
    {
        if (NameParts == 0)
        {
            //
            // The name has no separators, so it is a flat principal name
            //

            NameType = KRB_NT_PRINCIPAL;
            NameParts = 1;
        }
    }

    //
    // For KRB_NT_SRV_INST, get the name parts correct and tell the caller
    // that a realm was supplied in the spn
    //

    if (NameType == KRB_NT_SRV_INST)
    {          
        if (SuppliedRealm.Length == 0)
        {
            // We have an spn of the form a/b..../n and the name parts needs
            // to be upped by one
            // If we had an spn of the form a/b@c, then the name
            // parts would be right.

            NameParts++;
        }
        else
        {
            // We need to filter this back to the caller so that the
            // name canonicalization bit is not set.

            *ProcessFlags |= KERB_GET_TICKET_NO_CANONICALIZE;
        }
    }

    //
    // Check for an MIT realm with the supplied realm - if the name type is
    // KRB_NT_PRINCIPAL, send it as a UPN unless we can find an MIT realm.
    // If we are not a member of a domain, then we can't default so use
    // the domain name supplied. Also, if we are using supplied credentials
    // we don't want to use the wksta realm.
    //

    if ((NameType == KRB_NT_PRINCIPAL) && (KerbGetGlobalRole() != KerbRoleStandalone) &&
        ((Flags & KERB_CRACK_NAME_USE_WKSTA_REALM) != 0))
    {
        BOOLEAN Result;
        Result = KerbLookupMitRealm(
                    &SuppliedRealm,
                    &MitRealm,
                    &UsedAlternateName
                    );
        //
        // If we didn't find a realm, use this as a UPN
        //

        if (!Result)
        {
            //
            // If the caller supplied the realm separately, then don't
            // send it as a UPN.
            //

            if ((Flags & KERB_CRACK_NAME_REALM_SUPPLIED) == 0)
            {
                NameType = KRB_NT_ENTERPRISE_PRINCIPAL;
                NameParts = 1;
                FirstNamePart = *RealTargetName;
                RtlInitUnicodeString(
                    &SuppliedRealm,
                    NULL
                    );
            }
        }
        //
        // For logon, its interesting to know if we're doing an MIT realm lookup
        //
        else 
        {      
            D_DebugLog((DEB_TRACE, "Using MIT realm in Process TargetName\n"));
            *ProcessFlags |= KERB_MIT_REALM_USED;
        }                       
    }

    NameLength = FirstNamePart.Length + NameParts * sizeof(WCHAR);


    D_DebugLog((DEB_TRACE_CTXT,
                "Parsed name %wZ (%wZ) into:\n\t name type 0x%x, name count %d, \n\t realm %wZ, \n\t first part %wZ\n",
                TargetName,
                SuppTargetName,
                NameType,
                NameParts,
                &SuppliedRealm,
                &FirstNamePart
                ));

#ifdef later
    //
    // If the name end in "localhost", replace it with our dns machine
    // name.
    //

    if ((NameType == KRB_NT_SRV_INST) &&
        (NameParts == 2) &&
        (RealTargetName->Length > LocalhostName.Length) &&
        RtlEqualMemory(
            RealTargetName->Buffer + (RealTargetName->Length - LocalhostName.Length ) / sizeof(WCHAR),
            LocalhostName.Buffer,
            LocalhostName.Length
            ))

    {
        NameLength -= LocalhostName.Length;
        KerbGlobalReadLock();
        NameLength += KerbGlobalMitMachineServiceName->Names[1].Length;

        //
        // Set the flag to indicate we need to replace the name, and that
        // the global lock is held.
        //

        ReplaceLocalhost = TRUE;
    }
#endif

    //
    // Create the output names
    //

    OutputName = (PKERB_INTERNAL_NAME) KerbAllocate(KERB_INTERNAL_NAME_SIZE(NameParts + ExtraNameParts) + NameLength);
    if (OutputName == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    OutputName->NameCount = NameParts + ExtraNameParts;
    OutputName->NameType = NameType;

    Where = (PUCHAR) OutputName + KERB_INTERNAL_NAME_SIZE(NameParts+ExtraNameParts);
    NameIndex = 0;

    //
    // If there is only one part of the name, handle that first
    //

    if (NameParts == 1)
    {
        OutputName->Names[0].Length = FirstNamePart.Length;
        OutputName->Names[0].MaximumLength = FirstNamePart.Length + sizeof(WCHAR);
        OutputName->Names[0].Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            FirstNamePart.Buffer,
            FirstNamePart.Length
            );
        OutputName->Names[0].Buffer[FirstNamePart.Length / sizeof(WCHAR)] = L'\0';
        Where += FirstNamePart.Length + sizeof(WCHAR);
        NameIndex = 1;

    }
    else
    {
        UNICODE_STRING TempName;

        //
        // Build up the name, piece by piece
        //

        DoneParsing = FALSE;
        NameIndex = 0;
        TempName.Buffer = FirstNamePart.Buffer;

        for ( Index = 0; Index <= FirstNamePart.Length / sizeof(WCHAR) ; Index++ )
        {
            //
            // If we hit the end or a separator, build a name part
            //

            if ((Index == FirstNamePart.Length / sizeof(WCHAR)) ||
                (FirstNamePart.Buffer[Index] == L'/') )
            {
#ifdef later
                if ((NameIndex == 1) && (ReplaceLocalhost))
                {
                    OutputName->Names[NameIndex].Length = KerbGlobalMitMachineServiceName->Names[1].Length;
                    OutputName->Names[NameIndex].MaximumLength = OutputName->Names[NameIndex].Length + sizeof(WCHAR);
                    OutputName->Names[NameIndex].Buffer = (LPWSTR) Where;

                    RtlCopyMemory(
                        Where,
                        KerbGlobalMitMachineServiceName->Names[1].Buffer,
                        OutputName->Names[NameIndex].Length
                        );
                    //
                    // Release the lock now
                    //

                    KerbGlobalReleaseLock();
                    ReplaceLocalhost = FALSE;
                }
                else
#endif
                {
                    OutputName->Names[NameIndex].Length = (USHORT) (&FirstNamePart.Buffer[Index] - TempName.Buffer) * sizeof(WCHAR);
                    OutputName->Names[NameIndex].MaximumLength = OutputName->Names[NameIndex].Length + sizeof(WCHAR);
                    OutputName->Names[NameIndex].Buffer = (LPWSTR) Where;

                    RtlCopyMemory(
                        Where,
                        TempName.Buffer,
                        OutputName->Names[NameIndex].Length
                        );
                }
                Where += OutputName->Names[NameIndex].Length;
                *(LPWSTR)Where = L'\0';
                Where += sizeof(WCHAR);


                NameIndex++;
                TempName.Buffer = &FirstNamePart.Buffer[Index+1];
            }
        }

        DsysAssert(NameParts == NameIndex);
    }

    //
    // Now that we've built the output name, check SPN Cache.
    //

    if ( ARGUMENT_PRESENT(SpnCacheEntry) &&
         NameType == KRB_NT_SRV_INST     &&
         SuppliedRealm.Length == 0 )

    {

        LocalCacheEntry = KerbLocateSpnCacheEntry(OutputName);

        if (NULL != LocalCacheEntry)
        {   
            DebugLog((DEB_TRACE_SPN_CACHE, "Found in SPN Cache %p ", LocalCacheEntry));
            D_KerbPrintKdcName(DEB_TRACE_SPN_CACHE, LocalCacheEntry->Spn);  

            *SpnCacheEntry = LocalCacheEntry;
            LocalCacheEntry = NULL;

            *ProcessFlags |= KERB_TARGET_USED_SPN_CACHE;  

        }

    }

    D_DebugLog((DEB_TRACE_CTXT,"Cracked name %wZ into: ", RealTargetName));
    D_KerbPrintKdcName(DEB_TRACE_CTXT,OutputName);

    if (((Flags & KERB_CRACK_NAME_USE_WKSTA_REALM) == 0) || SuppliedRealm.Length > 0)
    {
        Status = KerbDuplicateString(
                        TargetRealm,
                        &SuppliedRealm
                        );
    }
    else
    {
        if ((Flags & KERB_CRACK_NAME_USE_WKSTA_REALM) == 0)
        {
            DsysAssert(FALSE); // hey, this shouldn't ever be hit...
            RtlInitUnicodeString(
                TargetRealm,
                NULL
                );
        }
        else
        {
            //
            // There was no realm name provided, so use the wksta domain
            //
            Status = KerbGetOurDomainName(
                            TargetRealm
                            );
        }

    }
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *FinalTarget = OutputName;
    OutputName = NULL;

Cleanup:

#ifdef later
    if (ReplaceLocalhost)
    {
        KerbGlobalReleaseLock();
    }
#endif

    if ( LocalCacheEntry ) 
    {
        KerbDereferenceSpnCacheEntry( LocalCacheEntry );
    }

    
    if (OutputName != NULL)
    {
        KerbFree(OutputName);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbValidateChannelBindings
//
//  Synopsis:   Validates the channel bindings copied from the client.
//
//  Effects:
//
//  Arguments:  pBuffer -- Input buffer that contains channel bindings
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
KerbValidateChannelBindings(
    IN  PVOID pBuffer,
    IN  ULONG ulBufferLength
    )
{
    PSEC_CHANNEL_BINDINGS pClientBindings = (PSEC_CHANNEL_BINDINGS) pBuffer;
    DWORD                 dwBindingLength;
    DWORD                 dwInitiatorEnd;
    DWORD                 dwAcceptorEnd;
    DWORD                 dwApplicationEnd;

    //
    // If channel bindings were specified, they had better be there
    //

    if (pBuffer == NULL || ulBufferLength < sizeof(SEC_CHANNEL_BINDINGS))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure we got one contiguous buffer
    //

    dwBindingLength = sizeof(SEC_CHANNEL_BINDINGS)
                            + pClientBindings->cbInitiatorLength
                            + pClientBindings->cbAcceptorLength
                            + pClientBindings->cbApplicationDataLength;

    //
    // Make sure the lengths are valid and check for overflow
    //

    if (dwBindingLength > ulBufferLength)
    {
        return STATUS_INVALID_PARAMETER;
    }

    dwInitiatorEnd   = pClientBindings->dwInitiatorOffset + pClientBindings->cbInitiatorLength;
    dwAcceptorEnd    = pClientBindings->dwAcceptorOffset + pClientBindings->cbAcceptorLength;
    dwApplicationEnd = pClientBindings->dwApplicationDataOffset + pClientBindings->cbApplicationDataLength;

    if ((dwInitiatorEnd > dwBindingLength || dwInitiatorEnd < pClientBindings->dwInitiatorOffset)
         ||
        (dwAcceptorEnd > dwBindingLength || dwAcceptorEnd < pClientBindings->dwAcceptorOffset)
         ||
        (dwApplicationEnd > dwBindingLength || dwApplicationEnd < pClientBindings->dwApplicationDataOffset))
    {
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpInitLsaModeContext
//
//  Synopsis:   Kerberos implementation of InitializeSecurityContext. This
//              routine handles the client side of authentication by
//              acquiring a ticket to the specified target. If a context
//              handle is passed in, then the input buffer is used to
//              verify the authenticity of the server.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitLsaModeContext(
    IN OPTIONAL LSA_SEC_HANDLE CredentialHandle,
    IN OPTIONAL LSA_SEC_HANDLE ContextHandle,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ULONG ContextRequirements,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputBuffers,
    OUT PLSA_SEC_HANDLE NewContextHandle,
    IN OUT PSecBufferDesc OutputBuffers,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
{
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    PKERB_TICKET_CACHE_ENTRY TicketCacheEntry = NULL;
    ULONG TicketOptions = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    LUID LogonId;
    PUCHAR Request = NULL;
    ULONG RequestSize = 0;
    PUCHAR Reply = NULL;
    ULONG ReplySize;
    PSecBuffer OutputToken = NULL;
    PSecBuffer InputToken = NULL;
    UNICODE_STRING LocalTargetName;
    UNICODE_STRING TargetDomainName;
    PKERB_INTERNAL_NAME TargetInternalName = NULL;
    ULONG Index;
    PKERB_CONTEXT Context = NULL;
    ULONG Nonce = 0;
    ULONG ProcessFlags = 0;
    ULONG ReceiveNonce = 0;
    ULONG ContextFlags = 0;
    ULONG ContextAttribs = 0;
    TimeStamp ContextLifetime;
    BOOLEAN DoThirdLeg = FALSE;
    BOOLEAN GetAuthTicket = FALSE;
    BOOLEAN UseNullSession = FALSE;
    BOOLEAN GetServerTgt = FALSE;
    PKERB_ERROR ErrorMessage = NULL;
    PKERB_ERROR_METHOD_DATA ErrorData = NULL;
    PKERB_EXT_ERROR pExtendedError = NULL;
    PKERB_TGT_REPLY TgtReply = NULL;
    PKERB_SPN_CACHE_ENTRY SpnCacheEntry = NULL;
    ULONG ContextRetries = 0;
    KERB_CONTEXT_STATE ContextState = InvalidState;
    KERB_ENCRYPTION_KEY SubSessionKey = {0};
    BOOLEAN ClientAskedForDelegate = FALSE, ClientAskedForDelegateIfSafe = FALSE;
    ULONG ClientProcess = 0;
    PKERB_CREDMAN_CRED CredManCredentials = NULL;
    NTSTATUS InitialStatus = STATUS_SUCCESS;
    PSEC_CHANNEL_BINDINGS pChannelBindings = NULL;
    PBYTE pbMarshalledTargetInfo = NULL;
    ULONG cbMarshalledTargetInfo = 0;

    LUID NetworkServiceLuid = NETWORKSERVICE_LUID;


    KERB_INITSC_INFO InitSCTraceInfo;
    InitSCTraceInfo.EventTrace.Size = 0;

    D_DebugLog((DEB_TRACE_API,"SpInitLsaModeContext 0x%x called\n",ContextHandle));

    if( KerbEventTraceFlag ) // Event Trace: KerbInitSecurityContextStart {No Data}
    {
        InitSCTraceInfo.EventTrace.Guid       = KerbInitSCGuid;
        InitSCTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        InitSCTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
            InitSCTraceInfo.EventTrace.Size       = sizeof (EVENT_TRACE_HEADER);

        TraceEvent(
            KerbTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&InitSCTraceInfo
        );
    }
    
    
    //
    // Initialize the outputs.
    //

    *ContextAttributes = 0;
    *NewContextHandle = 0;
    *ExpirationTime = KerbGlobalHasNeverTime;
    *MappedContext = FALSE;
    ContextData->pvBuffer = NULL;
    ContextData->cbBuffer = 0;
    LocalTargetName.Buffer = NULL;
    LocalTargetName.Length = 0;
    TargetDomainName.Buffer = NULL;
    TargetDomainName.Length = 0;

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    //
    // Make sure we have at least one ip address
    //

    KerbGlobalReadLock();
    if (KerbGlobalNoTcpUdp)
    {
        Status = STATUS_NETWORK_UNREACHABLE;
    }
    KerbGlobalReleaseLock();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Delegate will mean delegate_if_safe for this
    // release (NT5)
    //

    if ( ContextRequirements & ISC_REQ_DELEGATE )
    {
        ClientAskedForDelegate = TRUE;
        ContextRequirements |= ISC_REQ_DELEGATE_IF_SAFE ;
        ContextRequirements &= ~(ISC_REQ_DELEGATE) ;
    }
    else if ( ContextRequirements & ISC_REQ_DELEGATE_IF_SAFE )
    {
        ClientAskedForDelegateIfSafe = TRUE;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Process the input tokens
    //
    /////////////////////////////////////////////////////////////////////

    //
    // First locate the output token.
    //

    for (Index = 0; Index < OutputBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(OutputBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            OutputToken = &OutputBuffers->pBuffers[Index];
            Status = LsaFunctions->MapBuffer(OutputToken,OutputToken);
            break;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to map output token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now locate the Input token.
    //

    for (Index = 0; Index < InputBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(InputBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            InputToken = &InputBuffers->pBuffers[Index];
            Status = LsaFunctions->MapBuffer(InputToken,InputToken);
            break;
        }

    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to map Input token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Check to see if we were passed an additional name
    //

    for (Index = 0; Index < InputBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(InputBuffers->pBuffers[Index]) == SECBUFFER_NEGOTIATION_INFO)
        {
            Status = LsaFunctions->MapBuffer(
                        &InputBuffers->pBuffers[Index],
                        &InputBuffers->pBuffers[Index]
                        );
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog( (DEB_ERROR, "Failed to map incoming SECBUFFER_NEGOTIATION_INFO. %x, %ws, %d", Status, THIS_FILE, __LINE__) );
                goto Cleanup;
            }
            LocalTargetName.Buffer = (LPWSTR) InputBuffers->pBuffers[Index].pvBuffer;

            //
            // We can only stick 64k in a the length field, so make sure the
            // buffer is not too big.
            //

            if (InputBuffers->pBuffers[Index].cbBuffer > 0xffff)
            {
                Status = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            LocalTargetName.Length =
                LocalTargetName.MaximumLength = (USHORT) InputBuffers->pBuffers[Index].cbBuffer;

            break;
        }
    }

    //
    // Process the target names
    //

    Status = KerbProcessTargetNames(
                TargetName,
                &LocalTargetName,
                0,                              // No flags
                &ProcessFlags,
                &TargetInternalName,
                &TargetDomainName,
                &SpnCacheEntry
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    // 
    // Check to see if we were passed channel bindings
    //

    for( Index = 0; Index < InputBuffers->cBuffers; Index++ )
    {
        if( BUFFERTYPE(InputBuffers->pBuffers[Index]) == SECBUFFER_CHANNEL_BINDINGS )
        {
            PVOID temp = NULL;

            Status = LsaFunctions->MapBuffer(
                        &InputBuffers->pBuffers[Index],
                        &InputBuffers->pBuffers[Index]
                        );

            if( !NT_SUCCESS(Status) )
            {
                D_DebugLog( (DEB_ERROR,
                           "Failed to map incoming SECBUFFER_CHANNEL_BINDINGS. %x, %ws, %d\n",
                           Status,
                           THIS_FILE,
                           __LINE__) );

                goto Cleanup;
            }

            pChannelBindings = (PSEC_CHANNEL_BINDINGS) InputBuffers->pBuffers[Index].pvBuffer;

            Status = KerbValidateChannelBindings(pChannelBindings,
                                                 InputBuffers->pBuffers[Index].cbBuffer);

            if (!NT_SUCCESS(Status))
            {
                pChannelBindings = NULL;
                goto Cleanup;
            }

            break;
        }
    }

    //////////////////////////////////////////////////////////////////////
    //
    // If the caller passed in a context handle, deal with updating an
    // existing context.
    //
    /////////////////////////////////////////////////////////////////////

    //
    // If the input context handle is no NULL then we are actually
    // finalizing an already-existing context. So be it.
    //

    //
    // Use "while" so we can break out.
    //

    while (ContextHandle != 0)
    {

        D_DebugLog((DEB_TRACE_CTXT,"SpInitLsaModeContext: Second call to Initialize\n"));
        if (InputToken == NULL)
        {
            D_DebugLog((DEB_ERROR,"Trying to complete a context with no input token! %ws, line %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // First reference the context.
        //

        Status = KerbReferenceContext(
                    ContextHandle,
                    FALSE,       // don't unlink
                    &Context
                    );
        if (Context == NULL)
        {
            D_DebugLog((DEB_ERROR,"Failed to reference context 0x%x. %ws, line %d\n",ContextHandle, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // Check the mode of the context to make sure we can finalize it.
        //

        KerbReadLockContexts();

        ContextState = Context->ContextState;
        if ((ContextState != ApRequestSentState) &&
            (ContextState != TgtRequestSentState))
        {
            D_DebugLog((DEB_ERROR,"Invalid context state: %d. %ws, line %d\n",
                Context->ContextState, THIS_FILE, __LINE__));
            Status = STATUS_INVALID_HANDLE;
            KerbUnlockContexts();
            goto Cleanup;
        }
        ContextRetries = Context->Retries;
        ContextFlags = Context->ContextFlags;
        ContextAttribs = Context->ContextAttributes;
        Nonce = Context->Nonce;
        CredentialHandle = Context->CredentialHandle;
        ClientProcess = Context->ClientProcess;
        KerbUnlockContexts();


        //
        // If we are not doing datagram, unpack the AP or TGT reply.
        //

        if ((ContextFlags & ISC_RET_DATAGRAM) == 0)
        {
            ////////////////////////////////////////////////////
            //
            // Handle a TGT reply - get out the TGT & the name of
            // the server
            //
            ////////////////////////////////////////////////////

            if (ContextState == TgtRequestSentState)
            {
                D_DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext calling KerbUnpackTgtReply\n"));

                KerbWriteLockContexts();
                if (!(Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER))
                {
                    Context->ContextAttributes |= KERB_CONTEXT_USER_TO_USER;
                    DebugLog((DEB_WARN, "SpInitLsaModeContext * use_sesion_key but USER2USER-OUTBOUND not set, added it now\n"));
                }
                KerbUnlockContexts();

                Status = KerbUnpackTgtReply(
                            Context,
                            (PUCHAR) InputToken->pvBuffer,
                            InputToken->cbBuffer,
                            &TargetInternalName,
                            &TargetDomainName,
                            &TgtReply
                            );

                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR,"Failed to unpack TGT reply: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));

                    //
                    // Check for an error message
                    //

                    Status = KerbReceiveErrorMessage(
                                (PUCHAR) InputToken->pvBuffer,
                                InputToken->cbBuffer,
                                Context,
                                &ErrorMessage,
                                &ErrorData
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }

                    KerbReportKerbError(
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        KLIN(FILENO,__LINE__),
                        ErrorMessage,
                        ((NULL != ErrorMessage) ? ErrorMessage->error_code : KRB_ERR_GENERIC),
                        pExtendedError,
                        FALSE
                        );

                    //
                    // Ahh. We have an error message. See if it is an
                    // error we can handle, and if so, Now we need to
                    // try to build a better AP request. Or, if we have
                    // already retried once, fail.
                    //


                    DebugLog((DEB_WARN, "SpInitLsaModeContext received KERB_ERROR message with error 0x%x, can't handle\n",
                            ErrorMessage->error_code ));
                    if ((ErrorMessage->error_code == KRB_ERR_GENERIC)
                        && (ErrorData != NULL)
                        && (ErrorData->bit_mask & data_value_present)
                        && (ErrorData->data_type == KERB_AP_ERR_TYPE_NTSTATUS)
                        && (ErrorData->data_value.length == sizeof(ULONG)))
                    {
                        Status = *((PULONG)ErrorData->data_value.value);
                    }
                    else
                    {
                        Status = KerbMapKerbError((KERBERR) ErrorMessage->error_code);
                        if (NT_SUCCESS(Status))
                        {
                            Status = STATUS_INTERNAL_ERROR;
                        }
                    }

                    goto Cleanup;
                }

                //
                // Break out so we generate a normal request now
                //

                break;
            }
            else // not user-to-user
            {

            ////////////////////////////////////////////////////
            //
            // This is the response to an AP request. It could be
            // an AP reply or an error. Handle both cases
            //
            ////////////////////////////////////////////////////


                //
                // Now unpack the AP reply
                //


                Status = KerbVerifyApReply(
                            Context,
                            (PUCHAR) InputToken->pvBuffer,
                            InputToken->cbBuffer,
                            &ReceiveNonce
                            );

                if (!NT_SUCCESS(Status))
                {

                    //
                    // Check for an error message
                    //

                    Status = KerbReceiveErrorMessage(
                                (PUCHAR) InputToken->pvBuffer,
                                InputToken->cbBuffer,
                                Context,
                                &ErrorMessage,
                                &ErrorData
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }

                    KerbReportKerbError(
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        KLIN(FILENO, __LINE__),
                        ErrorMessage,
                        ((NULL != ErrorMessage) ? ErrorMessage->error_code : KRB_ERR_GENERIC),
                        pExtendedError,
                        FALSE
                        );

                    DebugLog((DEB_WARN,"Failed to verify AP reply: 0x%x\n",ErrorMessage->error_code));

                    //
                    // Ahh. We have an error message. See if it is an
                    // error we can handle, and if so, Now we need to
                    // try to build a better AP request. Or, if we have
                    // already retried once, fail. We can't get a new ticket
                    // with user-to-user.
                    //
                    if ((ContextRetries != 0) ||
                        (((KERBERR) ErrorMessage->error_code != KRB_AP_ERR_SKEW) &&
                         ((KERBERR) ErrorMessage->error_code != KRB_AP_ERR_TKT_NYV) &&
                         ((KERBERR) ErrorMessage->error_code != KRB_AP_ERR_USER_TO_USER_REQUIRED) &&
                         ((KERBERR) ErrorMessage->error_code != KRB_AP_ERR_MODIFIED)) ||
                        (((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_MODIFIED) &&
                         ((ContextAttribs & KERB_CONTEXT_USER_TO_USER) != 0)))
                    {
                        if ((ErrorMessage->error_code == KRB_ERR_GENERIC) &&
                            (ErrorData != NULL) && (ErrorData->data_type == KERB_AP_ERR_TYPE_NTSTATUS) &&
                            ((ErrorData->bit_mask & data_value_present) != 0) &&
                             (ErrorData->data_value.value != NULL) &&
                             (ErrorData->data_value.length == sizeof(ULONG)))
                        {
                            Status = *((PULONG)ErrorMessage->error_data.value);

                            if (NT_SUCCESS(Status))
                            {
                                Status = STATUS_INTERNAL_ERROR;
                            }
                        }

                        if (ErrorMessage->error_code == KRB_AP_ERR_MODIFIED)
                        {
                            //
                            // If the server couldn't decrypt the ticket,
                            // then the target name is wrong for the server.
                            //
                            DebugLog((DEB_ERROR, "App modified error (NO CONTINUE, bail)\n"));
                            KerbReportApError(ErrorMessage);
                            Status = SEC_E_WRONG_PRINCIPAL;
                        }
                        else if (ErrorMessage->error_code == KRB_AP_ERR_TKT_NYV)
                        {
                           DebugLog((DEB_ERROR, "Not yet valid error - Check Time Skew\n"));
                           KerbReportApError(ErrorMessage);
                           Status = STATUS_TIME_DIFFERENCE_AT_DC;
                        }
                        else
                        {
                            DebugLog((DEB_ERROR, "InitSecContext Received KERB_ERROR message with error 0x%x, can't handle. %ws, line %d\n",
                                ErrorMessage->error_code, THIS_FILE, __LINE__ ));

                            Status = KerbMapKerbError((KERBERR) ErrorMessage->error_code);
                            if (NT_SUCCESS(Status))
                            {
                                Status = STATUS_INTERNAL_ERROR;
                            }
                        }
                        goto Cleanup;
                    }
                    else
                    {
                       //
                       // Check to see if the server supports skew
                       //

                        if ((ErrorMessage->error_code == KRB_AP_ERR_SKEW) &&
                            (ErrorData == NULL) || ((ErrorData != NULL) && (ErrorData->data_type != KERB_AP_ERR_TYPE_SKEW_RECOVERY)))
                        {
                            //
                            // The server doesn't support skew recovery.
                            //

                            D_DebugLog((DEB_WARN,"Skew error but server doesn't handle skew recovery.\n"));
                            Status = KerbMapKerbError((KERBERR) ErrorMessage->error_code);
                            goto Cleanup;
                        }


                        //
                        // Here's where we'll punt "not yet valid tickets" and friends...
                        //
                        if (ErrorMessage->error_code == KRB_AP_ERR_TKT_NYV)
                        {
                           KerbPurgeServiceTicketAndTgt(
                                 Context,
                                 CredentialHandle,
                                 CredManCredentials
                                 );

                           DebugLog((DEB_ERROR, "Purged all tickets due to NYV error!\n"));

                        }

                        KerbWriteLockContexts();
                        Context->Retries++;
                        KerbUnlockContexts();

                    }


                    ////////////////////////////////////////////////////
                    //
                    // We got an error we can handle. For user-to-user
                    // required, we received the TGT so we can get
                    // the appropriate ticket. For modified, we want
                    // to toss the old ticket & get a new one, hopefully
                    // with a better key.
                    //
                    ////////////////////////////////////////////////////
                    if ((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_USER_TO_USER_REQUIRED)
                    {
                        D_DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext received KRB_AP_ERR_USER_TO_USER_REQUIRED\n"));

                        if ((ErrorMessage->bit_mask & error_data_present) == 0)
                        {
                            DebugLog((DEB_ERROR,"Server requires user-to-user but didn't send TGT reply. %ws, line %d\n", THIS_FILE, __LINE__));
                            Status = STATUS_NO_TGT_REPLY;
                            goto Cleanup;
                        }
                        //
                        // Check for TGT reply
                        //
                        Status = KerbUnpackTgtReply(
                                    Context,
                                    ErrorMessage->error_data.value,
                                    ErrorMessage->error_data.length,
                                    &TargetInternalName,
                                    &TargetDomainName,
                                    &TgtReply
                                    );
                        if (!NT_SUCCESS(Status))
                        {
                            Status = STATUS_INVALID_PARAMETER;
                            goto Cleanup;
                        }

                        //
                        // Fall through into normal ticket handling
                        //

                        ContextFlags |= ISC_RET_USE_SESSION_KEY;

                        //
                        // Remove the old ticket cache entry
                        //

                        KerbWriteLockContexts();
                        TicketCacheEntry = Context->TicketCacheEntry;
                        Context->TicketCacheEntry = NULL;
                        KerbUnlockContexts();


                        if (TicketCacheEntry != NULL)
                        {

                            KerbFreeString(
                                &TargetDomainName
                                );
                            KerbFreeKdcName(
                                &TargetInternalName
                                );

                            //
                            // Get the target name from the old ticket
                            //
                            KerbReadLockTicketCache();
                            Status = KerbDuplicateString(
                                        &TargetDomainName,
                                        &TicketCacheEntry->DomainName
                                        );
                            if (NT_SUCCESS(Status))
                            {

                                Status = KerbDuplicateKdcName(
                                            &TargetInternalName,
                                            TicketCacheEntry->ServiceName
                                            );

                            }
                            KerbUnlockTicketCache();
                            if (!NT_SUCCESS(Status))
                            {
                                goto Cleanup;
                            }

                            //
                            // Free this ticket cache entry
                            //

                            KerbRemoveTicketCacheEntry(TicketCacheEntry);

                            //
                            // Remove the reference holding it to the context
                            //

                            KerbDereferenceTicketCacheEntry(TicketCacheEntry);

                            TicketCacheEntry = NULL;
                        }

                        break;
                    }
                    else if ((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_MODIFIED)
                    {
                        DebugLog((DEB_WARN, "App modified error (purge ticket!)\n"));

                        KerbWriteLockContexts();
                        TicketCacheEntry = Context->TicketCacheEntry;
                        Context->TicketCacheEntry = NULL;
                        KerbUnlockContexts();

                        if (TicketCacheEntry != NULL)
                        {

                            //
                            // Get rid of the old ticket in the context

                            KerbFreeString(
                                &TargetDomainName
                                );
                            KerbFreeKdcName(
                                &TargetInternalName
                                );

                            //
                            // Get the target name from the old ticket
                            //
                            KerbReadLockTicketCache();
                            Status = KerbDuplicateString(
                                        &TargetDomainName,
                                        &TicketCacheEntry->DomainName
                                        );
                            if (NT_SUCCESS(Status))
                            {

                                Status = KerbDuplicateKdcName(
                                            &TargetInternalName,
                                            TicketCacheEntry->ServiceName
                                            );

                            }
                            KerbUnlockTicketCache();
                            if (!NT_SUCCESS(Status))
                            {
                                goto Cleanup;
                            }
                            //
                            // Free this ticket cache entry
                            //

                            KerbRemoveTicketCacheEntry(TicketCacheEntry);

                            //
                            // Remove the reference holding it to the context
                            //

                            KerbDereferenceTicketCacheEntry(TicketCacheEntry);

                            TicketCacheEntry = NULL;
                        }

                    }

                    break;
                }
            }

            ////////////////////////////////////////////////////
            //
            // We successfully decrypted the AP reply. At this point
            // we want to finalize the context. For DCE style we send
            // a useless AP reply to the server.
            //
            ////////////////////////////////////////////////////

            //
            // If the caller wanted DCE style authentication, build another
            // AP reply
            //

            KerbWriteLockContexts();

            if ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0)
            {
                DoThirdLeg = TRUE;
            }
            else
            {
                DoThirdLeg = FALSE;
            }

            Context->ReceiveNonce = ReceiveNonce;

            KerbUnlockContexts();

            if (DoThirdLeg)
            {
                //
                // Build an AP reply to send back to the server.
                //

                Status = KerbBuildThirdLegApReply(
                            Context,
                            ReceiveNonce,
                            &Reply,
                            &ReplySize
                            );

                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR,"Failed to build AP reply: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }

                if (OutputToken == NULL)
                {
                    D_DebugLog((DEB_ERROR,"Output token missing. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status  = SEC_E_INVALID_TOKEN;
                    goto Cleanup;
                }

                //
                // Return the AP reply in the output buffer.
                //

                if ((ContextRequirements & ISC_REQ_ALLOCATE_MEMORY) == 0)
                {
                    if (OutputToken->cbBuffer < ReplySize)
                    {
                        ULONG ErrorData[3];

                        ErrorData[0] = ReplySize;
                        ErrorData[1] = OutputToken->cbBuffer;
                        ErrorData[2] = ClientProcess;


                        DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                            OutputToken->cbBuffer,ReplySize, THIS_FILE, __LINE__ ));
                        OutputToken->cbBuffer = ReplySize;
                        Status = STATUS_BUFFER_TOO_SMALL;

                        KerbReportNtstatus(
                            KERBEVT_INSUFFICIENT_TOKEN_SIZE,
                            Status,
                            NULL,
                            0,
                            ErrorData,
                            3
                            );


                        goto Cleanup;
                    }


                    RtlCopyMemory(
                        OutputToken->pvBuffer,
                        Reply,
                        ReplySize
                        );

                }
                else
                {
                    OutputToken->pvBuffer = Reply;
                    Reply = NULL;
                    *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
                }
                OutputToken->cbBuffer = ReplySize;
            }
            else
            {

                //
                // No return message, so set the return length to zero.
                //

                if (OutputToken != NULL)
                {
                    OutputToken->cbBuffer = 0;
                }

            }
        }
        else
        {
            //////////////////////////////////////////////////////////////////////
            //
            // We are doing datagram, so we don't expect anything from the
            // server but perhaps an error. If we get an error, handle it.
            // Otherwise, build an AP request to send to the server
            //
            /////////////////////////////////////////////////////////////////////

            //
            // We are doing datagram. Build the AP request for the
            // server side.
            //

            //
            // Check for an error message
            //

            if ((InputToken != NULL) && (InputToken->cbBuffer != 0))
            {
                Status = KerbReceiveErrorMessage(
                            (PUCHAR) InputToken->pvBuffer,
                            InputToken->cbBuffer,
                            Context,
                            &ErrorMessage,
                            &ErrorData
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                KerbReportKerbError(
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    KLIN(FILENO, __LINE__),
                    ErrorMessage,
                    ((NULL != ErrorMessage) ? ErrorMessage->error_code : KRB_ERR_GENERIC),
                    pExtendedError,
                    FALSE
                    );

                //
                // Check for a real error
                //

                if ((ErrorData != NULL) && (ErrorData->data_type == KERB_AP_ERR_TYPE_NTSTATUS) &&
                    ((ErrorData->bit_mask & data_value_present) != 0) &&
                     (ErrorData->data_value.value != NULL) &&
                    (ErrorData->data_value.length == sizeof(ULONG)))
                {
                    Status = *((PULONG)ErrorMessage->error_data.value);
                    if (NT_SUCCESS(Status))
                    {
                        Status = STATUS_INTERNAL_ERROR;
                    }
                    goto Cleanup;
                }


            }

            //
            // Get the associated credential
            //

            Status = KerbReferenceCredential(
                            CredentialHandle,
                            KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                            FALSE,
                            &Credential);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN,"Failed to locate credential: 0x%x\n",Status));
                goto Cleanup;
            }

            //
            // Get the logon id from the credentials so we can locate the
            // logon session.
            //

            LogonId = Credential->LogonId;


            //
            // Get the logon session
            //

            LogonSession = KerbReferenceLogonSession( &LogonId, FALSE );
            if (LogonSession == NULL)
            {
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                goto Cleanup;
            }

            KerbReadLockLogonSessions(LogonSession);

            if (Credential->SuppliedCredentials != NULL)
            {
                GetAuthTicket = TRUE;
            } else if (((Credential->CredentialFlags & KERB_CRED_NULL_SESSION) != 0) ||
                       ((ContextRequirements & ISC_REQ_NULL_SESSION) != 0))
            {
                UseNullSession = TRUE;
                ContextFlags |= ISC_RET_NULL_SESSION;
            }
            KerbUnlockLogonSessions(LogonSession);

            KerbReadLockContexts();

            TicketCacheEntry = Context->TicketCacheEntry;

            //
            // Get the session key to use from the context
            //

            if (Context->SessionKey.keyvalue.value != 0)
            {
                if (!KERB_SUCCESS(KerbDuplicateKey(
                        &SubSessionKey,
                        &Context->SessionKey
                        )))
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            Context->TicketCacheEntry = NULL;

            KerbUnlockContexts();


            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            D_DebugLog((DEB_TRACE_CTXT2,"Building AP request for datagram oriented context\n"));

            //
            // If we are building a null session, build the special null
            // session AP request
            //

            if (UseNullSession)
            {
                Status = KerbBuildNullSessionApRequest(
                            &Request,
                            &RequestSize
                            );
                //
                // Turn off all unsupported flags
                //

                ContextFlags &= (   ISC_RET_ALLOCATED_MEMORY |
                                    ISC_RET_CONNECTION |
                                    ISC_RET_DATAGRAM |
                                    ISC_RET_NULL_SESSION );

            }
            else
            {
                if (TicketCacheEntry == NULL)
                {
                    DebugLog((DEB_ERROR, "SpInitLsaModeContext does have service ticket\n"));

                    Status = STATUS_INTERNAL_ERROR;
                    goto Cleanup;
                }

                Status = KerbBuildApRequest(
                            LogonSession,
                            Credential,
                            CredManCredentials,
                            TicketCacheEntry,
                            ErrorMessage,
                            ContextAttribs,
                            &ContextFlags,
                            &Request,
                            &RequestSize,
                            &Nonce,
                            &SubSessionKey,
                            pChannelBindings
                            );
            }

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to build AP request: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }

            //
            // Return the AP request in the output buffer.
            //

            if ((ContextRequirements & ISC_REQ_ALLOCATE_MEMORY) == 0)
            {
                if (OutputToken->cbBuffer < RequestSize)
                {
                    ULONG ErrorData[3];

                    ErrorData[0] = RequestSize;
                    ErrorData[1] = OutputToken->cbBuffer;
                    ErrorData[2] = ClientProcess;

                    D_DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                              OutputToken->cbBuffer,RequestSize, THIS_FILE, __LINE__ ));
                    OutputToken->cbBuffer = RequestSize;
                    Status = STATUS_BUFFER_TOO_SMALL;

                    KerbReportNtstatus(
                        KERBEVT_INSUFFICIENT_TOKEN_SIZE,
                        Status,
                        NULL,
                        0,
                        ErrorData,
                        3
                        );

                    goto Cleanup;
                }

                RtlCopyMemory(
                    OutputToken->pvBuffer,
                    Request,
                    RequestSize
                    );

            }
            else
            {
                OutputToken->pvBuffer = Request;
                *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
                Request = NULL;
            }

            OutputToken->cbBuffer = RequestSize;
        }

        //
        //
        // We're done - we finalized.
        //

        Status = STATUS_SUCCESS;

        KerbReadLockContexts();
        Context->ContextFlags = ContextFlags;
        *ContextAttributes |= Context->ContextFlags;

        KerbUtcTimeToLocalTime(
            ExpirationTime,
            &Context->Lifetime
            );
        *NewContextHandle = ContextHandle;
        KerbUnlockContexts();


        goto Cleanup;

    }

    //////////////////////////////////////////////////////////////////////
    //
    // We need to create a request to the server, possibly a TGT request
    // or an AP request depending on what phase of the protocol we're in.
    //
    /////////////////////////////////////////////////////////////////////

    DsysAssert(!((Context != NULL) ^ ((ErrorMessage != NULL) || (TgtReply != NULL))));

    D_DebugLog((DEB_TRACE_CTXT,"SpInitLsaModeContext: First call to Initialize\n"));

    //
    // This is the case where we are constructing a new context.
    //


    //
    // Get the associated credential and its TGT, if needed
    //

    Status = KerbReferenceCredential(
                    CredentialHandle,
                    KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                    FALSE,
                    &Credential
                    );
    if (!NT_SUCCESS(Status))
    {
        InitialStatus = Status;

        Status = KerbReferenceCredential(
                        CredentialHandle,
                        KERB_CRED_OUTBOUND,
                        FALSE,
                        &Credential
                        );
        if( !NT_SUCCESS( Status ) || Credential->SuppliedCredentials != NULL)
        {
            Status = InitialStatus;
            D_DebugLog((DEB_WARN,"Failed to locate credential 0x%x\n",Status));
            goto Cleanup;
        }

        //
        // if we got here, only explicit or credman creds are allowed.
        // If the explicit creds failed to get a TGT from above, its also
        // time to bail, as explicit creds never should fall back to credman.
        //

    }

    //
    // Get the logon id from the credentials so we can locate the
    // logon session.
    //

    LogonId = Credential->LogonId;

    //
    // Get the logon session
    //

    LogonSession = KerbReferenceLogonSession( &LogonId, FALSE );
    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }


    KerbWriteLockLogonSessions(LogonSession);

    if (Credential->SuppliedCredentials != NULL)
    {
        GetAuthTicket = TRUE;
        // Ignore SPN cache for supplied credentials
        ProcessFlags &=  ~KERB_TARGET_UNKNOWN_SPN;
    }
    else if (((Credential->CredentialFlags & KERB_CRED_NULL_SESSION) != 0) ||
                ((ContextRequirements & ISC_REQ_NULL_SESSION) != 0))
    {
        UseNullSession = TRUE;
        ContextFlags |= ISC_RET_NULL_SESSION;
    }
    else
    {
        //
        // go to the credential manager to try and find
        // credentials for this specific target
        //

        ULONG ExtraTargetFlags = 0;


        if ((ContextRequirements & ISC_REQ_USE_SUPPLIED_CREDS) != 0)
        {
            ExtraTargetFlags = CRED_TI_ONLY_PASSWORD_REQUIRED;
        }

        Status = KerbCheckCredMgrForGivenTarget(
                    LogonSession,
                    Credential,
                    TargetName, // original targetname, may contain marshalled targetinfo
                    TargetInternalName,
                    ExtraTargetFlags,
                    &TargetDomainName,
                    NULL,
                    &CredManCredentials,
                    &pbMarshalledTargetInfo,
                    &cbMarshalledTargetInfo
                    );

        if (!NT_SUCCESS(Status))
        {
            KerbUnlockLogonSessions(LogonSession);
            D_DebugLog((DEB_ERROR,"Failed to get outbound ticket: 0x%x\n",Status));
            goto Cleanup;
        }

        if (CredManCredentials != NULL)
        {
            GetAuthTicket = TRUE;
            ProcessFlags &=  ~KERB_TARGET_UNKNOWN_SPN;
        }
        else
        {
            //
            // if this is a local account logon then we have to have a cred man
            // credential
            //
            if ((Credential->CredentialFlags & KERB_CRED_LOCAL_ACCOUNT) != 0)
            {
                KerbUnlockLogonSessions(LogonSession);

                D_DebugLog((DEB_WARN, "Trying to use a local logon session with Kerberos\n"));
                Status = SEC_E_NO_CREDENTIALS;
                goto Cleanup;
            }

            //
            // if no credman cred was found, we didn't use explicit creds,
            // and the initial credential reference for TGT_AVAIL failed, bail now.
            //
            if( !NT_SUCCESS( InitialStatus ) )
            {
                KerbUnlockLogonSessions(LogonSession);
                Status = InitialStatus;
                D_DebugLog((DEB_WARN,"Failed to locate credential 0x%x\n",Status));
                goto Cleanup;
            }
        }
    }

#if DBG
    D_DebugLog((DEB_TRACE_CTXT, "SpInitLsaModeContext: Initailizing context for %wZ\\%wZ\n",
        &LogonSession->PrimaryCredentials.DomainName,
        &LogonSession->PrimaryCredentials.UserName ));
#endif

    KerbUnlockLogonSessions(LogonSession);

    //////////////////////////////////////////////////////////////////////
    //
    // Process all the context requirements. We don't support all of them
    // and some of them are mutually exclusive. In general, we don't fail
    // if we're asked to do something we can't do, unless it seems mandatory,
    // like allocating memory.
    //
    /////////////////////////////////////////////////////////////////////

    //
    // Figure out the context flags
    //

    if ((ContextRequirements & ISC_REQ_MUTUAL_AUTH) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT,"Client wants mutual auth.\n"));
        ContextFlags |= ISC_RET_MUTUAL_AUTH;
    }


    if ((ContextRequirements & ISC_REQ_SEQUENCE_DETECT) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants sequence detect\n"));
        ContextFlags |= ISC_RET_SEQUENCE_DETECT | ISC_RET_INTEGRITY;
    }

    if ((ContextRequirements & ISC_REQ_REPLAY_DETECT) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants replay detect\n"));
        ContextFlags |= ISC_RET_REPLAY_DETECT | ISC_RET_INTEGRITY;
    }

    if ((ContextRequirements & ISC_REQ_INTEGRITY) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants integrity\n"));
        ContextFlags |= ISC_RET_INTEGRITY;
    }

    if ((ContextRequirements & ISC_REQ_CONFIDENTIALITY) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants privacy\n"));
        ContextFlags |= (ISC_RET_CONFIDENTIALITY |
                         ISC_RET_INTEGRITY |
                         ISC_RET_SEQUENCE_DETECT |
                         ISC_RET_REPLAY_DETECT );
    }

    if ((ContextRequirements & ISC_REQ_USE_DCE_STYLE) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants DCE style\n"));
        ContextFlags |= ISC_RET_USED_DCE_STYLE;
    }

    if ((ContextRequirements & ISC_REQ_EXTENDED_ERROR) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants extended error\n"));
        ContextFlags |= ISC_RET_EXTENDED_ERROR;
    }

    if ((ContextRequirements & ISC_REQ_DATAGRAM) != 0)
    {
        if ((ContextRequirements & ISC_REQ_CONNECTION) != 0)
        {
            D_DebugLog((DEB_ERROR,"Client wanted both data gram and connection. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_UNSUPPORTED_FUNCTION;
            goto Cleanup;
        }
        D_DebugLog((DEB_TRACE_CTXT, "Client wants Datagram style\n"));
        ContextFlags |= ISC_RET_DATAGRAM;
    }

    if ((ContextRequirements & ISC_REQ_USE_SESSION_KEY) != 0)
    {
        D_DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext Client wants sub-session key\n"));

        //
        // Can't do this with datagram because we need to be able to
        // start sealing messages after the first call to Initialize.
        //
        // With a null session there is no real ticket so we don't ever
        // need the server TGT either.
        //
        // Can't do DCE style because they don't have this.
        //


        if (!UseNullSession && (ContextRequirements & (ISC_REQ_DATAGRAM | ISC_REQ_USE_DCE_STYLE)) == 0)
        {
            //
            // If we are in the first call, get a server TGT
            //

            if (ContextState == InvalidState)
            {
                GetServerTgt = TRUE;
            }
            ContextFlags |= ISC_RET_USE_SESSION_KEY;
        }
        else
        {
            D_DebugLog((DEB_WARN,"Client wanted both datagram and session key, dropping session key\n"));
        }

    }

    if ((ContextRequirements & ISC_REQ_DELEGATE) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants Delegation\n"));
        if ((ContextFlags & ISC_RET_MUTUAL_AUTH) == 0)
        {
            D_DebugLog((DEB_WARN,"Can't do delegate without mutual\n"));
        }
        else
        {
            ContextFlags |= ISC_RET_DELEGATE;
        }
    }
    else if ((ContextRequirements & ISC_REQ_DELEGATE_IF_SAFE) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants Delegation, if safe\n"));
        if ((ContextFlags & ISC_RET_MUTUAL_AUTH) == 0)
        {
            D_DebugLog((DEB_WARN,"Can't do delegate without mutual\n"));
        }
        else
        {
            ContextFlags |= ISC_RET_DELEGATE_IF_SAFE;
        }
    }


    if ((ContextRequirements & ISC_REQ_CONNECTION) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants Connection style\n"));
        ContextFlags |= ISC_RET_CONNECTION;
    }

    if ((ContextRequirements & ISC_REQ_IDENTIFY) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants Identify level\n"));
        ContextFlags |= ISC_RET_IDENTIFY;
        if (((ContextRequirements & ISC_REQ_DELEGATE) != 0) ||
             ((ContextRequirements & ISC_REQ_DELEGATE_IF_SAFE) != 0))
        {
            D_DebugLog((DEB_WARN, "Client wants Delegation and Indentify, turning off delegation\n"));
            ContextFlags &= ~ISC_RET_DELEGATE;
            ContextFlags &= ~ISC_RET_DELEGATE_IF_SAFE;
        }

    }

    //////////////////////////////////////////////////////////////////////
    //
    // Get the ticket necessary to process the request. At this point:
    //  - TicketCacheEntry should contain the ticket to re-use
    //  - ErrorMessage should contain the error message, if there was one
    //
    /////////////////////////////////////////////////////////////////////

    //
    // Get the outbound ticket. If the credential has attached supplied
    // credentials, get an AS ticket instead.
    //

    if (GetServerTgt)
    {
        //
        // Nothing to do
        //

    }
    else if (!UseNullSession)
    {
        D_DebugLog((DEB_TRACE_CTXT,"SpInitLsaModeContext: Getting outbound ticket for %wZ (%wZ) or ",
            TargetName, &LocalTargetName  ));
        D_KerbPrintKdcName(DEB_TRACE_CTXT, TargetInternalName );

        //
        // If we got a skew error and we already have a cached ticket, don't
        // bother getting a new ticket.
        //

        KerbReadLockContexts();

        if (ErrorMessage != NULL)
        {
            if (((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_SKEW) &&
                (Context->TicketCacheEntry != NULL))
            {
                KerbReferenceTicketCacheEntry(Context->TicketCacheEntry);
                TicketCacheEntry = Context->TicketCacheEntry;
            }
            else
            {
                //
                // use2user assumes ticketTicketCacheEntry to be non null at
                // this point
                //

                DsysAssert((Context->TicketCacheEntry != NULL) || ((ContextAttribs & KERB_CONTEXT_USER_TO_USER) == 0));
            }
        }
        KerbUnlockContexts();

        //
        // If we don't have a ticket in the context, go ahead and get
        // a new ticket
        //

        if (TicketCacheEntry == NULL)
        {
            D_DebugLog((DEB_TRACE, "Getting service ticket\n"));
            Status = KerbGetServiceTicket(
                        LogonSession,
                        Credential,
                        CredManCredentials,
                        TargetInternalName,
                        &TargetDomainName,
                        SpnCacheEntry,
                        ProcessFlags,
                        TicketOptions,
                        0,                          // no enc type
                        ErrorMessage,
                        NULL,                       // no authorization data
                        TgtReply,                   // no tgt reply
                        &TicketCacheEntry,
                        NULL                        // don't return logon guid
                        );

            if (Status == STATUS_USER2USER_REQUIRED)
            {
                D_DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext failed to get serviceticket: STATUS_USER2USER_REQUIRED\n"));

                Status = STATUS_SUCCESS;

                ContextFlags |= ISC_RET_USE_SESSION_KEY;
                GetServerTgt = TRUE;
            }
            else if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN,"Failed to get outbound ticket: 0x%x\n",Status));
                goto Cleanup;
            }
        }

        //
        // fail user2user in data gram: not enough round trips to complete the protocol
        //

        if ((ContextFlags & ISC_RET_USE_SESSION_KEY) && (ContextFlags & ISC_RET_DATAGRAM))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext Client needed session key in datagram, dropping session key\n"));

            ContextFlags |= ~ISC_RET_USE_SESSION_KEY;

            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
    }
    else
    {
        //
        // Turn off all unsupported flags
        //

        ContextFlags &= (   ISC_RET_ALLOCATED_MEMORY |
                            ISC_RET_CONNECTION |
                            ISC_RET_DATAGRAM |
                            ISC_RET_NULL_SESSION );

    }

    //////////////////////////////////////////////////////////////////////
    //
    // Build the request - an AP request for standard Kerberos, or a TGT
    // request.
    //
    /////////////////////////////////////////////////////////////////////

    //
    // For datagram requests, there is no output.
    //

    if ((ContextFlags & ISC_RET_DATAGRAM) == 0)
    {

        //
        // This is the case where we are constructing a response.
        //

        if (OutputToken == NULL)
        {
            D_DebugLog((DEB_ERROR,"Trying to initialize a context with no output token! %ws, line %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        if (UseNullSession)
        {
            Status = KerbBuildNullSessionApRequest(
                        &Request,
                        &RequestSize
                        );
        }
        else if (GetServerTgt)
        {
            D_DebugLog((DEB_TRACE,"Building TGT request for "));
            KerbPrintKdcName(DEB_TRACE, TargetInternalName);

            if (((ContextRequirements & ISC_REQ_MUTUAL_AUTH) != 0) &&
                (!ARGUMENT_PRESENT(TargetName) || TargetName->Length == 0))
            {
                D_DebugLog((DEB_ERROR, "Client wanted mutual auth, but did not supply target name\n"));
                Status = SEC_E_UNSUPPORTED_FUNCTION;
                goto Cleanup;
            }

            Status = KerbBuildTgtRequest(
                            TargetInternalName,
                            &TargetDomainName,
                            &ContextAttribs,
                            &Request,
                            &RequestSize
                            );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

        }
        else
        {
            D_DebugLog((DEB_TRACE_CTXT2,"Building AP request for connection oriented context\n"));

            Status = KerbBuildApRequest(
                        LogonSession,
                        Credential,
                        CredManCredentials,
                        TicketCacheEntry,
                        ErrorMessage,
                        ContextAttribs,
                        &ContextFlags,
                        &Request,
                        &RequestSize,
                        &Nonce,
                        &SubSessionKey,
                        pChannelBindings
                        );

            //
            // Set the receive nonce to be the nonce, as the code below
            // expects it to be valid.
            //



            ReceiveNonce = Nonce;
        }

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to build AP request: 0x%x\n. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        if (OutputToken == NULL)
        {
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // Return the AP request in the output buffer.
        //

        if ((ContextRequirements & ISC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if (OutputToken->cbBuffer < RequestSize)
            {
                ULONG ErrorData[3];

                ErrorData[0] = RequestSize;
                ErrorData[1] = OutputToken->cbBuffer;
                ErrorData[2] = ClientProcess;


                D_DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                    OutputToken->cbBuffer,RequestSize, THIS_FILE, __LINE__ ));
                OutputToken->cbBuffer = RequestSize;
                Status = STATUS_BUFFER_TOO_SMALL;

                KerbReportNtstatus(
                    KERBEVT_INSUFFICIENT_TOKEN_SIZE,
                    Status,
                    NULL,
                    0,
                    ErrorData,
                    3
                    );


                goto Cleanup;

            }
            RtlCopyMemory(
                OutputToken->pvBuffer,
                Request,
                RequestSize
                );

        }
        else
        {
            OutputToken->pvBuffer = Request;
            if (OutputToken->pvBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;

            //
            // Set this to NULL so it won't be freed by us on cleanup.
            //

            Request = NULL;
        }

        OutputToken->cbBuffer = RequestSize;


    }
    else
    {
        //
        // All we do here is allocate a nonce for use in the context.
        //

        Nonce = KerbAllocateNonce();
        if (OutputToken != NULL)
        {
            OutputToken->cbBuffer = 0;
        }
    }


    //////////////////////////////////////////////////////////////////////
    //
    // If we haven't yet created a context, created one now. If we have,
    // update the context with the latest status.
    //
    /////////////////////////////////////////////////////////////////////

    //
    // Allocate a client context, if we don't already have one
    //

    if (Context == NULL)
    {
        Status = KerbCreateClientContext(
                    LogonSession,
                    Credential,
                    CredManCredentials,
                    TicketCacheEntry,
                    TargetName,
                    Nonce,
                    ContextFlags,
                    ContextAttribs,
                    &SubSessionKey,
                    &Context,
                    &ContextLifetime
                    );

        //CredManCredentials = NULL;
    }
    else
    {
        Status = KerbUpdateClientContext(
                    Context,
                    TicketCacheEntry,
                    Nonce,
                    ReceiveNonce,
                    ContextFlags,
                    ContextAttribs,
                    &SubSessionKey,
                    &ContextLifetime
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to create client context: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Keep track of network service session keys to detect whether network
    // logon session is for local network service
    //

    if (RtlEqualLuid(&LogonId, &NetworkServiceLuid))
    {
        FILETIME CurTime = {0};
        GetSystemTimeAsFileTime(&CurTime);

        //
        // use 2 times KerbGlobalSkewTime as ticket life time
        //

        KerbGetTime(*((TimeStamp*) &CurTime)) += 2 * KerbGetTime(KerbGlobalSkewTime);

        Status = KerbCreateSKeyEntry(&SubSessionKey, &CurTime);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR, "Failed to create session key entry: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
    }

    //
    // Hold on to the ticket for later use
    //

    KerbWriteLockContexts();
    if ((Context->TicketCacheEntry == NULL) && (TicketCacheEntry != NULL))
    {
        KerbReferenceTicketCacheEntry(TicketCacheEntry);
        Context->TicketCacheEntry = TicketCacheEntry;
    }
    ClientProcess = Context->ClientProcess;
    KerbUnlockContexts();

    //
    // update the context with the marshalled target info.
    //

    if( NT_SUCCESS(Status) && pbMarshalledTargetInfo )
    {
        if( Context->pbMarshalledTargetInfo == NULL )
        {
            Context->pbMarshalledTargetInfo = pbMarshalledTargetInfo;
            Context->cbMarshalledTargetInfo = cbMarshalledTargetInfo;
            pbMarshalledTargetInfo = NULL;
        }
    }

    //
    // Return the correct flags
    //

    *NewContextHandle = KerbGetContextHandle(Context);

    *ContextAttributes |= ContextFlags;

    KerbUtcTimeToLocalTime(
        ExpirationTime,
        &ContextLifetime
        );

    //
    // If mutual authentication was requested, ask for a continuation
    //

    if (((ContextFlags & ( ISC_RET_USED_DCE_STYLE |
                          ISC_RET_DATAGRAM |
                          ISC_RET_MUTUAL_AUTH )) != 0) ||
         GetServerTgt )
    {
        Status = SEC_I_CONTINUE_NEEDED;
    }

Cleanup:

    // Adjust for the new meaning of delegate/delegate-if-safe if they got munged somehow.
    if (ClientAskedForDelegateIfSafe && (*ContextAttributes & ISC_RET_DELEGATE))
    {
        (*ContextAttributes) &= ~ISC_RET_DELEGATE;
        (*ContextAttributes) |= ISC_RET_DELEGATE_IF_SAFE;
    }
    else if ((ClientAskedForDelegate) && (*ContextAttributes & ISC_RET_DELEGATE_IF_SAFE))
    {
        (*ContextAttributes) &= ~ISC_RET_DELEGATE_IF_SAFE;
        (*ContextAttributes) |= ISC_RET_DELEGATE;
    }

    if ( Status == STATUS_WRONG_PASSWORD )
    {
        //
        // don't leak WRONG_PASSWORD to the caller.
        //

        Status = STATUS_LOGON_FAILURE;
    }

    if ( KerbEventTraceFlag ) // Event Trace: KerbInitSecurityContextEnd {Status, CredSource, DomainName, UserName, Target, (ExtErr), (Klininfo)}
    {
        PCWSTR TraceStrings[] =
            {
            L"CredMan",
            L"Supplied",
            L"Context",
            L"LogonSession",
            L"None"
        };
        enum { TSTR_CREDMAN = 0, TSTR_SUPPLIED, TSTR_CONTEXT, TSTR_LOGONSESSION, TSTR_NONE };
        UNICODE_STRING UNICODE_NONE = { 4*sizeof(WCHAR), 4*sizeof(WCHAR), L"NONE" };

        UNICODE_STRING CredSource;
        PUNICODE_STRING trace_DomainName, trace_UserName, trace_target;

        trace_target = (Context != NULL) ? &Context->ServerPrincipalName : &UNICODE_NONE;

        if( Context != NULL && Context->CredManCredentials != NULL )
        {
            RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_CREDMAN] );
            trace_DomainName = &Context->CredManCredentials->SuppliedCredentials->DomainName;
            trace_UserName   = &Context->CredManCredentials->SuppliedCredentials->UserName;
        }
        else if( Credential != NULL && Credential->SuppliedCredentials != NULL )
        {
            RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_SUPPLIED] );
            trace_DomainName = &Credential->SuppliedCredentials->DomainName;
            trace_UserName   = &Credential->SuppliedCredentials->UserName;
        }
        else if( Context != NULL )
        {
            RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_CONTEXT] );
            trace_DomainName = &Context->ClientRealm;
            trace_UserName   = &Context->ClientName;
        }
        else if( LogonSession != NULL )
        {
            RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_LOGONSESSION] );
            trace_DomainName = &LogonSession->PrimaryCredentials.DomainName;
            trace_UserName   = &LogonSession->PrimaryCredentials.UserName;
        }
            else
        {
            RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_NONE] );
            trace_DomainName = &UNICODE_NONE;
            trace_UserName   = &UNICODE_NONE;
        }

        INSERT_ULONG_INTO_MOF(           Status,           InitSCTraceInfo.MofData, 0 );
        INSERT_UNICODE_STRING_INTO_MOF(  CredSource,       InitSCTraceInfo.MofData, 1 );
        INSERT_UNICODE_STRING_INTO_MOF( *trace_DomainName, InitSCTraceInfo.MofData, 3 );
        INSERT_UNICODE_STRING_INTO_MOF( *trace_UserName,   InitSCTraceInfo.MofData, 5 );
        INSERT_UNICODE_STRING_INTO_MOF( *trace_target,     InitSCTraceInfo.MofData, 7 );
        InitSCTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER) + 9*sizeof(MOF_FIELD);

        //Check for extended error
        if( pExtendedError != NULL )
        {
            INSERT_ULONG_INTO_MOF( pExtendedError->status,   InitSCTraceInfo.MofData, 9 );
            INSERT_ULONG_INTO_MOF( pExtendedError->klininfo, InitSCTraceInfo.MofData, 10 );
            InitSCTraceInfo.EventTrace.Size += 2*sizeof(MOF_FIELD);
        }

        // Set trace parameters
        InitSCTraceInfo.EventTrace.Guid       = KerbInitSCGuid;
        InitSCTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        InitSCTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

        TraceEvent(
            KerbTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&InitSCTraceInfo
        );
    }

    //
    // If we allocated a context, unlink it now
    //

    if (Context != NULL)
    {
        if (!NT_SUCCESS(Status))
        {
            //
            // Only unlink the context if we just created it
            //

            if (ContextHandle == 0)
            {
                KerbReferenceContextByPointer(
                    Context,
                    TRUE
                    );
                KerbDereferenceContext(Context);
            }
            else
            {
                //
                // Set the context to an invalid state.
                //

                KerbWriteLockContexts();
                Context->ContextState = InvalidState;
                KerbUnlockContexts();
            }
        }
        else
        {
            KerbWriteLockContexts();
            if (Status == STATUS_SUCCESS)
            {
                Context->ContextState = AuthenticatedState;
            }
            else if (!GetServerTgt)
            {
                Context->ContextState = ApRequestSentState;
            }
            else
            {
                Context->ContextState = TgtRequestSentState;

                //
                // mark the context as user2user
                //

                Context->ContextAttributes |= KERB_CONTEXT_USER_TO_USER;
                DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext (TGT in TGT reply) USER2USER-OUTBOUND set\n"));
            }
            KerbUnlockContexts();
        }
        KerbDereferenceContext(Context);
    }

    if ((Status == STATUS_SUCCESS) ||
        ((Status == SEC_I_CONTINUE_NEEDED) && ((ContextFlags & ISC_RET_DATAGRAM) != 0)))
    {
        NTSTATUS TempStatus;

        //
        // On real success we map the context to the callers address
        // space.
        //

        TempStatus = KerbMapContext(
                        Context,
                        MappedContext,
                        ContextData
                        );

        D_DebugLog((DEB_TRACE, "SpInitLsaModeContext called KerbMapContext ContextAttributes %#x, %#x\n", Context->ContextAttributes, TempStatus));

        if (!NT_SUCCESS(TempStatus))
        {
            Status = TempStatus;
        }

        //
        // Update the skew time with a success
        //

        KerbUpdateSkewTime(FALSE);
    }

    if (NULL != CredManCredentials)
    {
        KerbDereferenceCredmanCred(
            CredManCredentials,
            &LogonSession->CredmanCredentials
            );
    }

    if( pbMarshalledTargetInfo )
    {
        LocalFree( pbMarshalledTargetInfo );
    }

    if (TgtReply != NULL)
    {
        KerbFreeData(KERB_TGT_REPLY_PDU, TgtReply);
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    if (Credential != NULL)
    {
        KerbDereferenceCredential( Credential );
    }

    if (TicketCacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry( TicketCacheEntry );
    }

     if ( SpnCacheEntry != NULL )
     {
         KerbDereferenceSpnCacheEntry( SpnCacheEntry);
     }

    KerbFreeKerbError( ErrorMessage );
    if (NULL != pExtendedError)
    {
       KerbFree(pExtendedError);
    }

    if (ErrorData != NULL)
    {
       MIDL_user_free(ErrorData);
    }
    if (Request != NULL)
    {
        KerbFree(Request);
    }
    if (Reply != NULL)
    {
        KerbFree(Reply);
    }

    KerbFreeKey(&SubSessionKey);

    KerbFreeString( &TargetDomainName );
    KerbFreeKdcName( &TargetInternalName );

    D_DebugLog((DEB_TRACE_LEAKS,"SpInitLsaModeContext returned 0x%x, Context 0x%x, Pid 0x%x\n",KerbMapKerbNtStatusToNtStatus(Status), *NewContextHandle, ClientProcess));
    D_DebugLog((DEB_TRACE_API, "SpInitLsaModeContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


NTSTATUS NTAPI
SpApplyControlToken(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc ControlToken
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    D_DebugLog((DEB_TRACE_API,"SpApplyControlToken Called\n"));
    D_DebugLog((DEB_TRACE_API,"SpApplyControlToken returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}


#ifndef WIN32_CHICAGO //we don't do server side stuff
//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptLsaModeContext
//
//  Synopsis:   Kerberos support routine for AcceptSecurityContext call.
//              This routine accepts an AP request message from a client
//              and verifies that it is a valid ticket. If mutual
//              authentication is desired an AP reply is generated to
//              send back to the client.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
SpAcceptLsaModeContext(
    IN OPTIONAL LSA_SEC_HANDLE CredentialHandle,
    IN OPTIONAL LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc InputBuffers,
    IN ULONG ContextRequirements,
    IN ULONG TargetDataRep,
    OUT PLSA_SEC_HANDLE NewContextHandle,
    OUT PSecBufferDesc OutputBuffers,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
{
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS LastStatus = STATUS_SUCCESS;
    PKERB_AP_REQUEST Request = NULL;
    PUCHAR Reply = NULL;
    PSecBuffer InputToken = NULL;
    PSecBuffer OutputToken = NULL;
    ULONG Index;
    ULONG ReplySize;
    LUID LogonId;
    PKERB_ENCRYPTED_TICKET InternalTicket = NULL;
    PKERB_AUTHENTICATOR InternalAuthenticator = NULL;
    KERB_ENCRYPTION_KEY SessionKey;
    KERB_ENCRYPTION_KEY TicketKey;
    KERB_ENCRYPTION_KEY ServerKey;
    PKERB_CONTEXT Context = NULL;
    TimeStamp ContextLifetime;
    HANDLE TokenHandle = 0;
    ULONG ContextFlags = 0;
    ULONG ContextAttribs = KERB_CONTEXT_INBOUND;
    ULONG Nonce = 0;
    ULONG ReceiveNonce = 0;
    BOOLEAN UseSuppliedCreds = FALSE;
    ULONG_PTR LocalCredentialHandle = 0;
    PSID UserSid = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_CONTEXT_STATE ContextState = InvalidState;
    UNICODE_STRING ServiceDomain = {0};
    UNICODE_STRING ClientName = {0};
    UNICODE_STRING ClientDomain = {0};
    BOOLEAN IsTgtRequest = FALSE;
    ULONG ClientProcess = 0;
    PSEC_CHANNEL_BINDINGS pChannelBindings = NULL;

    KERB_ACCEPTSC_INFO AcceptSCTraceInfo;

    D_DebugLog((DEB_TRACE_API,"SpAcceptLsaModeContext 0x%x called\n",ContextHandle));

    if( KerbEventTraceFlag ) // Event Trace: KerbAcceptSecurityContextStart {No Data}
    {
    AcceptSCTraceInfo.EventTrace.Guid       = KerbAcceptSCGuid;
    AcceptSCTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
    AcceptSCTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
    AcceptSCTraceInfo.EventTrace.Size       = sizeof (EVENT_TRACE_HEADER);

    TraceEvent(
        KerbTraceLoggerHandle,
        (PEVENT_TRACE_HEADER)&AcceptSCTraceInfo
    );
    }

    //
    // Initialize the outputs.
    //

    *ContextAttributes = 0;
    *NewContextHandle = 0;
    *ExpirationTime = KerbGlobalHasNeverTime;
    *MappedContext = FALSE;
    ContextData->pvBuffer = NULL;
    ContextData->cbBuffer = 0;

    RtlZeroMemory(
        &SessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    TicketKey = SessionKey;
    ServerKey = TicketKey;

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    //
    // First locate the Input token.
    //

    for (Index = 0; Index < InputBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(InputBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            InputToken = &InputBuffers->pBuffers[Index];
            Status = LsaFunctions->MapBuffer(InputToken,InputToken);
            break;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to map Input token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Check to see if we were passed channel bindings
    //

    for( Index = 0; Index < InputBuffers->cBuffers; Index++ )
    {
        if( BUFFERTYPE(InputBuffers->pBuffers[Index]) == SECBUFFER_CHANNEL_BINDINGS )
        {
            PVOID temp = NULL;

            Status = LsaFunctions->MapBuffer(
                &InputBuffers->pBuffers[Index],
                &InputBuffers->pBuffers[Index]
                );

            if( !NT_SUCCESS(Status) )
            {
                goto Cleanup;
            }

            pChannelBindings = (PSEC_CHANNEL_BINDINGS) InputBuffers->pBuffers[Index].pvBuffer;

            Status = KerbValidateChannelBindings(pChannelBindings,
                                                 InputBuffers->pBuffers[Index].cbBuffer);

            if (!NT_SUCCESS(Status))
            {
                pChannelBindings = NULL;
                goto Cleanup;
            }

            break;
        }
    }

    //
    // Locate the output token
    //

    for (Index = 0; Index < OutputBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(OutputBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            OutputToken = &OutputBuffers->pBuffers[Index];
            Status = LsaFunctions->MapBuffer(OutputToken,OutputToken);
            break;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to map output token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // If the context handle is no NULL we are finalizing a context
    //

    if (ContextHandle != 0)
    {
        if (InputToken == NULL)
        {
            D_DebugLog((DEB_ERROR,"Trying to complete a context with no input token! %ws, line %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // First reference the context.
        //

        Status = KerbReferenceContext(
                    ContextHandle,
                    FALSE,       // don't unlink
                    &Context
                    );
        if (Context == NULL)
        {
            D_DebugLog((DEB_ERROR,"Failed to reference context 0x%x. %ws, line %d\n",ContextHandle, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // Check the mode of the context to make sure we can finalize it.
        //

        KerbReadLockContexts();

        ContextState = Context->ContextState;
        if (((ContextState != ApReplySentState) &&
             (ContextState != TgtReplySentState) &&
             (ContextState != ErrorMessageSentState)) ||
            ((Context->ContextAttributes & KERB_CONTEXT_INBOUND) == 0))
        {
            D_DebugLog((DEB_ERROR,"Invalid context state: %d. %ws, line %d\n",
                Context->ContextState, THIS_FILE, __LINE__));
            Status = STATUS_INVALID_HANDLE;
            KerbUnlockContexts();
            goto Cleanup;
        }

        if ((Context->ContextAttributes & KERB_CONTEXT_USED_SUPPLIED_CREDS) != 0)
        {
            UseSuppliedCreds = TRUE;
        }

        ContextFlags = Context->ContextFlags;
        LogonId = Context->LogonId;
        LocalCredentialHandle = Context->CredentialHandle;
        ClientProcess = Context->ClientProcess;
        KerbUnlockContexts();
    }

    if (CredentialHandle != 0)
    {
        if ((LocalCredentialHandle != 0) && (CredentialHandle != LocalCredentialHandle))
        {
            D_DebugLog((DEB_ERROR,"Different cred handle passsed to subsequent call to AcceptSecurityContext: 0x%x instead of 0x%x. %ws, line %d\n",
                CredentialHandle, LocalCredentialHandle, THIS_FILE, __LINE__ ));
            Status = STATUS_WRONG_CREDENTIAL_HANDLE;
            goto Cleanup;
        }
    }
    else
    {
        CredentialHandle = LocalCredentialHandle;
    }
    //
    // If we are finalizing a context, do that here
    //

    if (ContextState == ApReplySentState)
    {
        //
        // If we are doing datgram, then the finalize is actually an AP request
        //

        if ((ContextFlags & ISC_RET_DATAGRAM) != 0)
        {

            //
            // Get the logon session
            //

            LogonSession = KerbReferenceLogonSession( &LogonId, FALSE );
            if (LogonSession == NULL)
            {
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                goto Cleanup;
            }

            //
            // If we are using supplied creds, get the credentials. Copy
            // out the domain name so we can use it to verify the PAC.
            //

            Status = KerbReferenceCredential(
                            LocalCredentialHandle,
                            KERB_CRED_INBOUND,
                            FALSE,                   // don't dereference
                            &Credential
                            );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            if (UseSuppliedCreds)
            {
                KerbReadLockLogonSessions(LogonSession);
                Status = KerbDuplicateString(
                            &ServiceDomain,
                            &Credential->SuppliedCredentials->DomainName
                            );
                KerbUnlockLogonSessions(LogonSession);
            }
            else
            {
                KerbReadLockLogonSessions(LogonSession);
                Status = KerbDuplicateString(
                            &ServiceDomain,
                            &LogonSession->PrimaryCredentials.DomainName
                            );
                KerbUnlockLogonSessions(LogonSession);
            }
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            //
            // Verify the AP request
            //

            Status = KerbVerifyApRequest(
                        Context,
                        (PUCHAR) InputToken->pvBuffer,
                        InputToken->cbBuffer,
                        LogonSession,
                        Credential,
                        UseSuppliedCreds,
                        ((ContextRequirements & ASC_REQ_ALLOW_CONTEXT_REPLAY) == 0),
                        &Request,
                        &InternalTicket,
                        &InternalAuthenticator,
                        &SessionKey,
                        &TicketKey,
                        &ServerKey,
                        &ContextFlags,
                        &ContextAttribs,
                        &KerbErr,
                        pChannelBindings
                        );

            //
            // We don't allow user-to-user recovery with datagram
            //

            if ((Status == STATUS_REPARSE_OBJECT) // this is a TGT request
                || ((Status == SEC_E_NO_CREDENTIALS) && (KerbErr == KRB_AP_ERR_USER_TO_USER_REQUIRED)))
            {
                DebugLog((DEB_ERROR, "Won't allow user2user with Datagram. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = SEC_E_INVALID_TOKEN;
                KerbErr = KRB_AP_ERR_MSG_TYPE;
                goto ErrorReturn;
            }

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to verify AP request: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));

                //
                // Let the skew tracker know about the failure
                //

                if (KerbErr == KRB_AP_ERR_SKEW)
                {
                    KerbUpdateSkewTime(TRUE);
                }

                //
                // Go to ErrorReturn so we can return an error message
                //

                goto ErrorReturn;
            }

            //
            // Turn on the flag if it was called for
            //

            if ((ContextRequirements & ASC_REQ_ALLOW_CONTEXT_REPLAY) != 0)
            {
                ContextFlags |= ASC_RET_ALLOW_CONTEXT_REPLAY;
            }

            //
            // Record the success
            //

            KerbUpdateSkewTime(FALSE);

            //
            // Check if the caller wants to allow null sessions
            //

            if (((ContextFlags & ISC_RET_NULL_SESSION) != 0) &&
                ((ContextRequirements & ASC_REQ_ALLOW_NULL_SESSION) == 0))
            {
                D_DebugLog((DEB_ERROR,"Received null session but not allowed. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            //
            // Save away the ReceiveNonce if it was provided
            //


            if ((InternalAuthenticator!= NULL) &&
                ((InternalAuthenticator->bit_mask & KERB_AUTHENTICATOR_sequence_number_present) != 0))
            {

                //
                // If the number is unsigned, convert it as unsigned. Otherwise
                // convert as signed.
                //

                if (ASN1intxisuint32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number))
                {
                    ReceiveNonce = ASN1intx2uint32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number);
                }
                else
                {
                    ReceiveNonce = (ULONG) ASN1intx2int32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number);
                }
            }
            else
            {
                ReceiveNonce = 0;
            }

            //
            // Authentication succeeded, so build a token
            //

            Status = KerbCreateTokenFromTicket(
                        InternalTicket,
                        InternalAuthenticator,
                        ContextFlags,
                        &ServerKey,
                        &ServiceDomain,
                        &SessionKey,
                        &LogonId,
                        &UserSid,
                        &TokenHandle,
                        &ClientName,
                        &ClientDomain
                        );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to create token from ticket: 0x%x. %ws, line %d\n",
                    Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }


            Status = KerbUpdateServerContext(
                        Context,
                        InternalTicket,
                        Request,
                        &SessionKey,
                        &LogonId,
                        &UserSid,
                        ContextFlags,
                        ContextAttribs,
                        Nonce,
                        ReceiveNonce,
                        &TokenHandle,
                        &ClientName,
                        &ClientDomain,
                        &ContextLifetime
                        );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to create server context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }
        }
        else
        {
            //
            // Now unpack the AP reply
            //


            Status = KerbVerifyApReply(
                        Context,
                        (PUCHAR) InputToken->pvBuffer,
                        InputToken->cbBuffer,
                        &Nonce
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to verify AP reply: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }

            //
            // We're done - we finalized.
            //

            Status = STATUS_SUCCESS;

            if (OutputToken != NULL)
            {
                OutputToken->cbBuffer = 0;
            }

        }

        KerbReadLockContexts();
        *ContextAttributes = KerbMapContextFlags(Context->ContextFlags);

        KerbUtcTimeToLocalTime(
            ExpirationTime,
            &Context->Lifetime
        );

        if (OutputToken != NULL)
        {
            OutputToken->cbBuffer = 0;
        }

        *NewContextHandle = ContextHandle;
        KerbUnlockContexts();

        goto Cleanup;  // datagram and finalized contexts exit here.

    }

    //
    // Get the associated credential
    //

    Status = KerbReferenceCredential(
                    CredentialHandle,
                    KERB_CRED_INBOUND,
                    FALSE,
                    &Credential
                    );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_WARN,"Failed to locate credential 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Get the logon id from the credentials so we can locate the
    // logon session.
    //

    LogonId = Credential->LogonId;

    //
    // Get the logon session
    //

    LogonSession = KerbReferenceLogonSession( &LogonId, FALSE );
    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    KerbReadLockLogonSessions(LogonSession);
    if ((Credential->CredentialFlags & KERB_CRED_LOCAL_ACCOUNT) != 0)
    {
        D_DebugLog((DEB_WARN, "Trying to use a local logon session with Kerberos\n"));
        KerbUnlockLogonSessions(LogonSession);
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    if (Credential->SuppliedCredentials != NULL)
    {
        UseSuppliedCreds = TRUE;
        ContextAttribs |= KERB_CONTEXT_USED_SUPPLIED_CREDS;
        Status = KerbDuplicateString(
                    &ServiceDomain,
                    &Credential->SuppliedCredentials->DomainName
                    );

    }
    else
    {
        Status = KerbDuplicateString(
                    &ServiceDomain,
                    &LogonSession->PrimaryCredentials.DomainName
                    );
    }

#if DBG
    D_DebugLog((DEB_TRACE_CTXT, "SpAcceptLsaModeContext: Accepting context for %wZ\\%wZ\n",
        &LogonSession->PrimaryCredentials.DomainName,
        &LogonSession->PrimaryCredentials.UserName ));
#endif
    KerbUnlockLogonSessions(LogonSession);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If datagram was requested, note it now. There is no input
    // buffer on the first call using datagram.
    //

    if ((ContextRequirements & ASC_REQ_DATAGRAM) != 0)
    {

        D_DebugLog((DEB_TRACE_CTXT2, "Accepting datagram first call\n"));

        //
        // Verify that there is no input token or it is small. RPC passes
        // in two bytes for the DEC package that we can ignore.
        //

        if ((InputToken != NULL) &&
            (InputToken->cbBuffer > 4))
        {
            D_DebugLog((DEB_WARN, "Non null input token passed to AcceptSecurityContext for datagram\n"));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        ContextFlags |= ISC_RET_DATAGRAM;
        ReceiveNonce = 0;

        //
        // Build a server context
        //

        Status = KerbCreateEmptyContext(
                    Credential,
                    ContextFlags,
                    ContextAttribs,
                    &LogonId,
                    &Context,
                    &ContextLifetime
                    );

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to create server context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        if (OutputToken != NULL)
        {
            OutputToken->cbBuffer = 0;
        }
    }
    else
    {

        D_DebugLog((DEB_TRACE_CTXT2,"Accepting connection first call\n"));


        //
        // Unmarshall the AP request
        //


        if ((InputToken == NULL) ||
            (InputToken->cbBuffer == 0))
        {
            D_DebugLog((DEB_WARN, "Null input token passed to AcceptSecurityContext for datagram\n"));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }


        //
        // Verify the AP request
        //

        Status = KerbVerifyApRequest(
                    Context,
                    (PUCHAR) InputToken->pvBuffer,
                    InputToken->cbBuffer,
                    LogonSession,
                    Credential,
                    UseSuppliedCreds,
                    ((ContextRequirements & ASC_REQ_ALLOW_CONTEXT_REPLAY) == 0),
                    &Request,
                    &InternalTicket,
                    &InternalAuthenticator,
                    &SessionKey,
                    &TicketKey,
                    &ServerKey,
                    &ContextFlags,
                    &ContextAttribs,
                    &KerbErr,
                    pChannelBindings
                    );

        if (!NT_SUCCESS(Status))
        {
            //
            // Track time skew errors
            //

            if ((KerbErr == KRB_AP_ERR_SKEW) ||
                (KerbErr == KRB_AP_ERR_TKT_NYV))
            {
                KerbUpdateSkewTime(TRUE);
            }
            DebugLog((DEB_ERROR,"Failed to verify AP request: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto ErrorReturn;
        }

        ContextFlags |= ISC_RET_CONNECTION;

        //
        // Check if this was a user-to-user tgt request. If so, then
        // there was no AP request
        //

        if (Status == STATUS_REPARSE_OBJECT)
        {
            IsTgtRequest = TRUE;

            Status = KerbHandleTgtRequest(
                        LogonSession,
                        Credential,
                        UseSuppliedCreds,
                        (PUCHAR) InputToken->pvBuffer,
                        InputToken->cbBuffer,
                        ContextRequirements,
                        OutputToken,
                        &LogonId,
                        ContextAttributes,
                        &Context,
                        &ContextLifetime,
                        &KerbErr
                        );
            if (!NT_SUCCESS(Status))
            {
                goto ErrorReturn;
            }

            ContextFlags |= ISC_RET_USE_SESSION_KEY;

            D_DebugLog((DEB_TRACE_U2U, "SpAcceptLsaModeContext handled TGT request and use_session_key set, ContextAttributes %#x\n", Context->ContextAttributes));
        }
        else // not a user-to-user request
        {
            //
            // Track successful time if this wasn't an error recovery
            //

            if (ContextState != ErrorMessageSentState)
            {
                KerbUpdateSkewTime(FALSE);
            }
            if ((InternalAuthenticator != NULL) &&
                (InternalAuthenticator->bit_mask & KERB_AUTHENTICATOR_sequence_number_present))
            {
                //
                // If the number is unsigned, convert it as unsigned. Otherwise
                // convert as signed.
                //

                if (ASN1intxisuint32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number))
                {
                    ReceiveNonce = ASN1intx2uint32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number);
                }
                else
                {
                    ReceiveNonce = (ULONG) ASN1intx2int32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number);
                }
            }
            else
            {
                ReceiveNonce = 0;
            }

            //
            // Initialize the opposite direction nonce to the same value
            //

            Nonce = ReceiveNonce;

            //
            // Turn on the flag if it was called for
            //

            if ((ContextRequirements & ASC_REQ_ALLOW_CONTEXT_REPLAY) != 0)
            {
                ContextFlags |= ASC_RET_ALLOW_CONTEXT_REPLAY;
            }

            //
            // Check if the caller wants to allow null sessions
            //

            if (((ContextFlags & ISC_RET_NULL_SESSION) != 0) &&
                ((ContextRequirements & ASC_REQ_ALLOW_NULL_SESSION) == 0))
            {
                D_DebugLog((DEB_ERROR,"Received null session but not allowed. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            //
            // Authentication succeeded, so build a token
            //

            D_DebugLog((DEB_TRACE_CTXT2, "AcceptLsaModeContext: Creating token from ticket\n"));
            Status = KerbCreateTokenFromTicket(
                        InternalTicket,
                        InternalAuthenticator,
                        ContextFlags,
                        &ServerKey,
                        &ServiceDomain,
                        &SessionKey,
                        &LogonId,
                        &UserSid,
                        &TokenHandle,
                        &ClientName,
                        &ClientDomain
                        );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to create token from ticket: 0x%x. %ws, line %d\n",
                    Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }

            //
            // If the caller wants mutual authentication, build an AP reply
            //


            if (((ContextFlags & ISC_RET_MUTUAL_AUTH) != 0) ||
                ((ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
            {
                //
                // We require an output token in this case.
                //

                if (OutputToken == NULL)
                {
                    Status = SEC_E_INVALID_TOKEN;
                    goto Cleanup;
                }
                //
                // Build the reply message
                //

                D_DebugLog((DEB_TRACE_CTXT2,"SpAcceptLsaModeContext: Building AP reply\n"));
                Status = KerbBuildApReply(
                            InternalAuthenticator,
                            Request,
                            ContextFlags,
                            ContextAttribs,
                            &TicketKey,
                            &SessionKey,
                            &Nonce,
                            &Reply,
                            &ReplySize
                            );

                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"Failed to build AP reply: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }

                if (OutputToken == NULL)
                {
                    D_DebugLog((DEB_ERROR,"Output token missing. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status  = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // Return the AP reply in the output buffer.
                //

                if ((ContextRequirements & ISC_REQ_ALLOCATE_MEMORY) == 0)
                {
                    if (OutputToken->cbBuffer < ReplySize)
                    {
                        ULONG ErrorData[3];

                        ErrorData[0] = ReplySize;
                        ErrorData[1] = OutputToken->cbBuffer;
                        ErrorData[2] = ClientProcess;


                        D_DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                            OutputToken->cbBuffer,ReplySize, THIS_FILE, __LINE__ ));
                        OutputToken->cbBuffer = ReplySize;
                        Status = STATUS_BUFFER_TOO_SMALL;

                        KerbReportNtstatus(
                            KERBEVT_INSUFFICIENT_TOKEN_SIZE,
                            Status,
                            NULL,
                            0,
                            ErrorData,
                            3
                            );

                        goto Cleanup;
                    }

                    RtlCopyMemory(
                        OutputToken->pvBuffer,
                        Reply,
                        ReplySize
                        );

                }
                else
                {
                    OutputToken->pvBuffer = Reply;
                    Reply = NULL;
                    *ContextAttributes |= ASC_RET_ALLOCATED_MEMORY;
                }

                OutputToken->cbBuffer = ReplySize;


            }
            else
            {
                if (OutputToken != NULL)
                {
                    OutputToken->cbBuffer = 0;
                }
            }

            //
            // Build a server context if we don't already have one.
            //

            //
            // Turn on the flag if it was called for
            //

            if ((ContextRequirements & ASC_REQ_ALLOW_CONTEXT_REPLAY) != 0)
            {
                ContextFlags |= ASC_RET_ALLOW_CONTEXT_REPLAY;
            }

            if (Context == NULL)
            {

                Status = KerbCreateServerContext(
                            LogonSession,
                            Credential,
                            InternalTicket,
                            Request,
                            &SessionKey,
                            &LogonId,
                            &UserSid,
                            ContextFlags,
                            ContextAttribs,
                            Nonce,
                            ReceiveNonce,
                            &TokenHandle,
                            &ClientName,
                            &ClientDomain,
                            &Context,
                            &ContextLifetime
                            );
            }
            else
            {
                //
                // Update an existing context
                //

                Status = KerbUpdateServerContext(
                            Context,
                            InternalTicket,
                            Request,
                            &SessionKey,
                            &LogonId,
                            &UserSid,
                            ContextFlags,
                            ContextAttribs,
                            Nonce,
                            ReceiveNonce,
                            &TokenHandle,
                            &ClientName,
                            &ClientDomain,
                            &ContextLifetime
                            );
            }

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to create or update server context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }


        } // not a TGT request
    } // not datagram
    *NewContextHandle = KerbGetContextHandle(Context);
    KerbUtcTimeToLocalTime(
        ExpirationTime,
        &ContextLifetime
        );

#if DBG
    KerbReadLockContexts();
    ClientProcess = Context->ClientProcess;
    KerbUnlockContexts();
#endif // DBG

    *ContextAttributes |= KerbMapContextFlags(ContextFlags);

    if (IsTgtRequest || (((ContextFlags & ISC_RET_USED_DCE_STYLE) != 0) ||
        ((ContextFlags & ISC_RET_DATAGRAM) != 0)))
    {
        Status = SEC_I_CONTINUE_NEEDED;
    }

    goto Cleanup;

ErrorReturn:


    //
    // Generate a KERB_ERROR message if necessary, meaning that there was
    // an authentication failure.
    //

    if ((OutputToken != NULL ) &&
        (!KERB_SUCCESS(KerbErr) ||
         ((ContextRequirements & ASC_REQ_EXTENDED_ERROR) != 0) ||
         ((ContextFlags & ISC_RET_EXTENDED_ERROR) != 0)))
    {
        NTSTATUS TempStatus;
        PBYTE ErrorMessage = NULL;
        ULONG ErrorMessageSize;
        PBYTE ErrorData = NULL;
        ULONG ErrorDataSize = 0;


        //
        // Check whether it is an error we want the client to retry on.
        // For datagram, we can't handle this.
        //

        if (ContextRequirements & ASC_REQ_DATAGRAM)
        {
            goto Cleanup;
        }
        if (!(((ContextRequirements & ASC_REQ_EXTENDED_ERROR) != 0) ||
              (KerbErr == KRB_AP_ERR_USER_TO_USER_REQUIRED) ||
              (KerbErr == KRB_AP_ERR_SKEW) ||
              (KerbErr == KRB_AP_ERR_TKT_NYV) ||
              (KerbErr == KRB_AP_ERR_TKT_EXPIRED) ||
              (KerbErr == KRB_AP_ERR_MODIFIED) ))
        {
            goto Cleanup;
        }

        //
        // Create an empty context that can be used later
        //

        if (Context == NULL)
        {

            TempStatus = KerbCreateEmptyContext(
                            Credential,
                            ContextFlags,
                            ContextAttribs,
                            &LogonId,
                            &Context,
                            &ContextLifetime
                            );
            if (!NT_SUCCESS(TempStatus))
            {
                goto Cleanup;
            }

        }

        //
        // if the error code is one with error data, build the error data
        //
        switch ((UINT_PTR) KerbErr)
        {
        case (UINT_PTR) KRB_AP_ERR_USER_TO_USER_REQUIRED:
            NTSTATUS TempStatus;
            TempStatus = KerbBuildTgtErrorReply(
                            LogonSession,
                            Credential,
                            UseSuppliedCreds,
                            Context,
                            &ErrorDataSize,
                            &ErrorData
                            );
            D_DebugLog((DEB_TRACE_U2U, "SpAcceptLsaModeContext called KerbBuildTgtErrorReply %#x\n", TempStatus));

            if (TempStatus == STATUS_USER2USER_REQUIRED)
            {
                KerbErr = KRB_AP_ERR_NO_TGT;
            }
            else if (!NT_SUCCESS(TempStatus))
            {
                D_DebugLog((DEB_ERROR,"Failed to build tgt error reply: 0x%x. Ignoring. %ws, line %d\n",TempStatus, THIS_FILE, __LINE__));
            }

            break;
        case (UINT_PTR) KDC_ERR_NONE:
            //
            // In this case, return the KRB_ERR_GENERIC and the NTSTATUS code
            // in the error data
            //
            KerbErr = KRB_ERR_GENERIC;
            ErrorData = (PUCHAR) &Status;
            ErrorDataSize = sizeof(ULONG);
            break;
        }

        TempStatus = KerbBuildGssErrorMessage(
                        KerbErr,
                        ErrorData,
                        ErrorDataSize,
                        Context,
                        &ErrorMessageSize,
                        &ErrorMessage
                        );

        if ((ErrorData != NULL) && (ErrorData != (PUCHAR) &Status))
        {
            MIDL_user_free(ErrorData);
        }

        if (!NT_SUCCESS(TempStatus))
        {
            goto Cleanup;
        }

        *ContextAttributes |= ASC_RET_EXTENDED_ERROR;

        if ((ContextRequirements & ISC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if (OutputToken->cbBuffer < ErrorMessageSize)
            {
                D_DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                    OutputToken->cbBuffer,ErrorMessageSize, THIS_FILE, __LINE__ ));
                MIDL_user_free(ErrorMessage);
                goto Cleanup;
            }
            else
            {
                DsysAssert(OutputToken->pvBuffer != NULL);
                RtlCopyMemory(
                    OutputToken->pvBuffer,
                    ErrorMessage,
                    ErrorMessageSize
                    );
                OutputToken->cbBuffer = ErrorMessageSize;
                MIDL_user_free(ErrorMessage);
            }
        }
        else
        {
            DsysAssert(OutputToken->pvBuffer == NULL);
            OutputToken->cbBuffer = ErrorMessageSize;
            OutputToken->pvBuffer = ErrorMessage;
            ErrorMessage = NULL;
            *ContextAttributes |= ASC_RET_ALLOCATED_MEMORY;
        }
        *ContextAttributes |= ASC_RET_EXTENDED_ERROR;

        *NewContextHandle = KerbGetContextHandle(Context);
        KerbUtcTimeToLocalTime(
            ExpirationTime,
            &ContextLifetime
            );
        *ContextAttributes |= KerbMapContextFlags(ContextFlags);

        LastStatus = Status;

        //
        // now it is time to mark the context as user2user
        //

        if (KerbErr == KRB_AP_ERR_USER_TO_USER_REQUIRED)
        {
            DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext (TGT in error reply) USER2USER-INBOUND set\n"));

            KerbWriteLockContexts()
            Context->ContextAttributes |= KERB_CONTEXT_USER_TO_USER;
            KerbUnlockContexts();
        }

        Status = SEC_I_CONTINUE_NEEDED;
    }
Cleanup:
    if( KerbEventTraceFlag ) // Event Trace: KerbAcceptSecurityContextEnd {Status, CredSource, DomainName, UserName, Target, (ExtError), (klininfo)}
    {

    PCWSTR TraceStrings[] =
        {
        L"CredMan",
        L"Supplied",
        L"Context",
        L"LogonSession",
        L"None"
    };
    enum { TSTR_CREDMAN = 0, TSTR_SUPPLIED, TSTR_CONTEXT, TSTR_LOGONSESSION, TSTR_NONE };
    UNICODE_STRING UNICODE_NONE = { 4*sizeof(WCHAR), 4*sizeof(WCHAR), L"NONE" };

    UNICODE_STRING CredSource;
    PUNICODE_STRING trace_DomainName, trace_UserName, trace_target;

    trace_target = (Context!=NULL) ? &Context->ServerPrincipalName : &UNICODE_NONE;

    if( Context != NULL && Context->CredManCredentials != NULL )
    {
        RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_CREDMAN] );
        trace_DomainName = &Context->CredManCredentials->SuppliedCredentials->DomainName;
        trace_UserName   = &Context->CredManCredentials->SuppliedCredentials->UserName;
    }
    else if( Credential != NULL && Credential->SuppliedCredentials != NULL )
    {
        RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_SUPPLIED] );
        trace_DomainName = &Credential->SuppliedCredentials->DomainName;
        trace_UserName   = &Credential->SuppliedCredentials->UserName;
    }
    else if( Context != NULL )
    {
        RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_CONTEXT] );
        trace_DomainName = &Context->ClientRealm;
        trace_UserName   = &Context->ClientName;
    }
    else if( LogonSession != NULL )
    {
        RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_LOGONSESSION] );
        trace_DomainName = &LogonSession->PrimaryCredentials.DomainName;
        trace_UserName   = &LogonSession->PrimaryCredentials.UserName;
    }
    else
    {
        RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_NONE] );
        trace_DomainName = &UNICODE_NONE;
        trace_UserName   = &UNICODE_NONE;
    }

    INSERT_ULONG_INTO_MOF(           Status,           AcceptSCTraceInfo.MofData, 0 );
    INSERT_UNICODE_STRING_INTO_MOF(  CredSource,       AcceptSCTraceInfo.MofData, 1 );
    INSERT_UNICODE_STRING_INTO_MOF( *trace_DomainName, AcceptSCTraceInfo.MofData, 3 );
    INSERT_UNICODE_STRING_INTO_MOF( *trace_UserName,   AcceptSCTraceInfo.MofData, 5 );
    INSERT_UNICODE_STRING_INTO_MOF( *trace_target,     AcceptSCTraceInfo.MofData, 7 );
    AcceptSCTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER) + 9*sizeof(MOF_FIELD);

    // Set trace parameters
    AcceptSCTraceInfo.EventTrace.Guid       = KerbAcceptSCGuid;
    AcceptSCTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
    AcceptSCTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

    TraceEvent(
        KerbTraceLoggerHandle,
        (PEVENT_TRACE_HEADER)&AcceptSCTraceInfo
    );
    }

    //
    // First, handle auditing
    //

    if (Status == STATUS_SUCCESS)
    {

        //
        // Don't audit if we didn't create a token.
        //

        if (Context->UserSid != NULL)
        {
            UNICODE_STRING WorkstationName = {0};

            //
            // note that UserSid will only be non-Null if the ClientName, ClientRealm were updated in the context.
            // and the context is currently referenced, so the fields won't vanish under us.
            //

            if ((InternalTicket != NULL) &&
                ((InternalTicket->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) != 0))

            {
                (VOID) KerbGetClientNetbiosAddress(
                            &WorkstationName,
                            InternalTicket->KERB_ENCRYPTED_TICKET_client_addresses
                            );

                //
                // The following generates a successful audit event.
                // A new field (logon GUID) was added to this audit event.
                //
                // In order to send this new field to LSA, we had two options:
                //   1) add new function (AuditLogonEx) to LSA dispatch table
                //   2) define a private (LsaI) function to do the job
                //
                // option#2 was chosen because the logon GUID is a Kerberos only
                // feature.
                //
                (void) KerbAuditLogon(
                           Status,
                           Status,
                           InternalTicket,
                           Context->UserSid,
                           &WorkstationName,
                           &LogonId
                           );

                KerbFreeString(&WorkstationName);
            }
        }
    }
    else if (!NT_SUCCESS(Status) || (LastStatus != STATUS_SUCCESS))
    {
        if (Context != NULL)
        {
            LsaFunctions->AuditLogon(
                STATUS_LOGON_FAILURE,
                (LastStatus != STATUS_SUCCESS) ? LastStatus : Status,
                &Context->ClientName,
                &Context->ClientRealm,
                NULL,                   // no workstation
                NULL,                   // no sid instead of a bogus one
                Network,
                &KerberosSource,
                &LogonId
                );
        }
        else
        {
            UNICODE_STRING EmptyString = NULL_UNICODE_STRING;

            LsaFunctions->AuditLogon(
                (LastStatus != STATUS_SUCCESS) ? LastStatus : Status,
                STATUS_SUCCESS,
                &EmptyString,
                &EmptyString,
                NULL,                   // no workstation
                NULL,
                Network,
                &KerberosSource,
                &LogonId
                );
        }
    }

    if (Context != NULL)
    {
        if (!NT_SUCCESS(Status))
        {
            //
            // Only unlink the context if we just created it.
            //

            if (ContextHandle == 0)
            {
                KerbReferenceContextByPointer(
                    Context,
                    TRUE
                    );
                KerbDereferenceContext(Context);
            }
            else
            {
                //
                // Set the context to an invalid state.
                //

                KerbWriteLockContexts();
                Context->ContextState = InvalidState;
                KerbUnlockContexts();

            }

        }
        else
        {
            KerbWriteLockContexts();
            if (Status == STATUS_SUCCESS)
            {
                Context->ContextState = AuthenticatedState;
            }
            else
            {
                if ((*ContextAttributes & ASC_RET_EXTENDED_ERROR) != 0)
                {
                    Context->ContextState = ErrorMessageSentState;
                }
                else if (!IsTgtRequest)
                {
                    Context->ContextState = ApReplySentState;
                }
                else
                {
                    //
                    // else the HandleTgtRequest set the state
                    //

                    DsysAssert(Context->ContextState == TgtReplySentState);
                }
            }
            KerbUnlockContexts();
        }
        KerbDereferenceContext(Context);
    }

    if (Status == STATUS_SUCCESS)
    {
        //
        // On real success we map the context to the callers address
        // space.
        //

        Status = KerbMapContext(
                    Context,
                    MappedContext,
                    ContextData
                    );

        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext called KerbMapContext ContextAttributes %#x, %#x\n", Context->ContextAttributes, Status));
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    if (Credential != NULL)
    {
        KerbDereferenceCredential( Credential );
    }

    if (InternalTicket != NULL)
    {
        KerbFreeTicket( InternalTicket );
    }
    if (InternalAuthenticator != NULL)
    {
        KerbFreeAuthenticator(InternalAuthenticator);
    }
    if (Request != NULL)
    {
        KerbFreeApRequest(Request);
    }

    if (Reply != NULL)
    {
        KerbFree(Reply);
    }
    KerbFreeKey(&SessionKey);
    KerbFreeKey(&ServerKey);

    if (UserSid != NULL)
    {
        KerbFree(UserSid);
    }

    //
    // If there was a problem with the context or AP reply, the TokenHandle
    // will not be reset to NULL.  If it is NULL, close it so we don't leak
    //

    if ( TokenHandle != NULL )
    {
        D_DebugLog(( DEB_TRACE, "Closing token handle because context creation failed (%x)\n",
                        Status ));

        NtClose( TokenHandle );
    }

    //
    // Update performance counter
    //

#ifndef WIN32_CHICAGO
    if (ContextHandle == 0)
    {
        I_SamIIncrementPerformanceCounter(KerbServerContextCounter);
    }
#endif // WIN32_CHICAGO

    KerbFreeKey(&TicketKey);
    KerbFreeString(&ServiceDomain);
    KerbFreeString(&ClientDomain);
    KerbFreeString(&ClientName);

    D_DebugLog((DEB_TRACE_LEAKS,"SpAcceptLsaModeContext returned 0x%x, Context 0x%x, Pid 0x%x\n",KerbMapKerbNtStatusToNtStatus(Status), *NewContextHandle, ClientProcess));
    D_DebugLog((DEB_TRACE_API, "SpAcceptLsaModeContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));

}
#endif WIN32_CHICAGO //we don't do server side stuff
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\ctxtmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtmgr.cxx
//
// Contents:    Code for managing contexts list for the Kerberos package
//
//
// History:     17-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#define CTXTMGR_ALLOCATE
#include <kerbp.h>
#include "userapi.h"
#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    );

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitContextList
//
//  Synopsis:   Initializes the contexts list
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbInitContextList(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0;

    __try {
        RtlInitializeResource( &KerbContextResource );
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for(Index = 0 ; Index < KERB_USERLIST_COUNT ; Index++)
    {
        Status = KerbInitializeList( &KerbContextList[Index] );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    KerberosContextsInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        ULONG i;

        RtlDeleteResource( &KerbContextResource );

        for( i = 0 ; i < Index ; i++ )
        {
            KerbFreeList( &KerbContextList[i] );
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeContextList
//
//  Synopsis:   Frees the contexts list
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeContextList(
    VOID
    )
{
    PKERB_CONTEXT Context;
#if 0
    if (KerberosContextsInitialized)
    {
        KerbLockList(&KerbContextList);

        //
        // Go through the list of logon sessions and dereferences them all
        //

        while (!IsListEmpty(&KerbContextList.List))
        {
            Context = CONTAINING_RECORD(
                            KerbContextList.List.Flink,
                            KERB_CONTEXT,
                            ListEntry.Next
                            );

            KerbReferenceListEntry(
                &KerbContextList,
                &Context->ListEntry,
                TRUE
                );

            KerbDereferenceContext(Context);

        }

        KerbFreeList(&KerbContextList);
    }
#endif

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateContext
//
//  Synopsis:   Allocates a Context structure
//
//  Effects:    Allocates a Context, but does not add it to the
//              list of Contexts
//
//  Arguments:  NewContext - receives a new Context allocated
//                  with KerbAllocate
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//              STATUS_INSUFFICIENT_RESOURCES if the allocation fails
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAllocateContext(
    OUT PKERB_CONTEXT * NewContext,
    IN BOOLEAN UserMode
    )
{
    PKERB_CONTEXT Context;
    SECPKG_CALL_INFO CallInfo = {0};

    //
    // Get the client process ID if we are running in the LSA
    //

    if (!UserMode)
    {
        if (!LsaFunctions->GetCallInfo(&CallInfo))
        {
            D_DebugLog((DEB_ERROR,"Failed to get call info\n. %ws, line %d\n",
                THIS_FILE, __LINE__));
            DsysAssert(FALSE);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    Context = (PKERB_CONTEXT) KerbAllocate(
                        sizeof(KERB_CONTEXT) );

    if (Context == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Context->ClientProcess = CallInfo.ProcessId;
    Context->ContextState = IdleState;

    //
    // Set the references to 1 since we are returning a pointer to the
    // logon session
    //

    KerbInitializeListEntry(
        &Context->ListEntry
        );


    *NewContext = Context;
    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertContext
//
//  Synopsis:   Inserts a logon session into the list of logon sessions
//
//  Effects:    bumps reference count on logon session
//
//  Arguments:  Context - Context to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInsertContext(
    IN PKERB_CONTEXT Context
    )
{
    ULONG ListIndex;

    ListIndex = HandleToListIndex( Context->LsaContextHandle );

    Context->ContextTag = KERB_CONTEXT_TAG_ACTIVE;

    KerbInsertListEntry(
        &Context->ListEntry,
        &KerbContextList[ListIndex]
        );

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceContext
//
//  Synopsis:   Locates a context context handleand references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  ContextHandle - Handle of context to reference.
//              RemoveFromList - If TRUE, context will be delinked.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
KerbReferenceContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CONTEXT * FoundContext
    )
{
    PKERB_CONTEXT Context = NULL;
    BOOLEAN Found = FALSE;
    SECPKG_CLIENT_INFO ClientInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ListIndex = 0;
    BOOLEAN ListLocked = FALSE;


    if (KerberosState == KerberosLsaMode)
    {
        Status = LsaFunctions->GetClientInfo(&ClientInfo);
        if (!NT_SUCCESS(Status))
        {
            SECPKG_CALL_INFO CallInfo;
            //
            // Check to see if the call is terminating. If so, give it
            // TCB privilege because it is really the LSA doing this.
            //

            if (LsaFunctions->GetCallInfo(&CallInfo))
            {
                if ((CallInfo.Attributes & SECPKG_CALL_CLEANUP) != 0)
                {
                    Status = STATUS_SUCCESS;
                    RtlZeroMemory(
                        &ClientInfo,
                        sizeof(SECPKG_CLIENT_INFO)
                        );
                    ClientInfo.HasTcbPrivilege = TRUE;
                }

            }
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog((DEB_ERROR,"Failed to get client info: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                *FoundContext = NULL ;
                return(Status);
            }
        }

    }
    else
    {
        ClientInfo.HasTcbPrivilege = FALSE ;
        ClientInfo.ProcessID = GetCurrentProcessId();
    }


    //
    // Go through the list of logon sessions looking for the correct
    // context
    //

    __try {

        Context = (PKERB_CONTEXT)ContextHandle;

        while ( Context->ContextTag == KERB_CONTEXT_TAG_ACTIVE )
        {
            ListIndex = HandleToListIndex( Context->LsaContextHandle );
            KerbLockList(&KerbContextList[ListIndex]);
            ListLocked = TRUE;

            //
            // Make sure that if we aren't trying to remove it we are
            // from the correct process.
            //

            if (!ClientInfo.HasTcbPrivilege &&
                (Context->ClientProcess != ClientInfo.ProcessID) &&
                (KerberosState == KerberosLsaMode))
            {
                D_DebugLog((DEB_ERROR,"Trying to reference a context from another process! %ws, line %d\n", THIS_FILE, __LINE__));
                Found = FALSE;
                break;
            }

            //
            // If the context is expired, don't allow it to be referenced.
            //

            if (KerbGlobalEnforceTime && !RemoveFromList)
            {
                TimeStamp CurrentTime;
                TimeStamp ContextExpires;
                GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
                ContextExpires = Context->Lifetime;
                if (KerbGetTime(ContextExpires) < KerbGetTime(CurrentTime))
                {
                    D_DebugLog((DEB_WARN, "Trying to reference expired context\n"));
                    Found = FALSE;
                    Status = SEC_E_CONTEXT_EXPIRED;
                    break;
                }
            }


            KerbReferenceListEntry(
                &KerbContextList[ ListIndex ],
                &Context->ListEntry,
                RemoveFromList
                );

            Found = TRUE;
            break;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER )
    {
        D_DebugLog((DEB_ERROR,"Trying to reference invalid context %ws, line %d\n", THIS_FILE, __LINE__));
        Found = FALSE;
    }

    if( ListLocked )
    {
        KerbUnlockList(&KerbContextList[ListIndex]);
    }

    if (!Found)
    {
        Context = NULL;
    }

    *FoundContext = Context ;

    if ( Context )
    {
        return Status;
    }
    else if (NT_SUCCESS(Status))
    {
        return SEC_E_INVALID_HANDLE ;
    }
    else
    {
        return Status;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceContextByLsaHandle
//
//  Synopsis:   Locates a context by lsa context handle and references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  ContextHandle - Lsa Handle of context to reference.
//              RemoveFromList - If TRUE, context will be delinked.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
KerbReferenceContextByLsaHandle(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CONTEXT *FoundContext
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_CONTEXT Context = NULL;
    BOOLEAN Found = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ListIndex;

    ListIndex = HandleToListIndex( ContextHandle );

    KerbLockList(&KerbContextList[ListIndex]);


    //
    // Go through the list of logon sessions looking for the correct
    // context
    //

    for (ListEntry = KerbContextList[ListIndex].List.Flink ;
         ListEntry !=  &KerbContextList[ListIndex].List ;
         ListEntry = ListEntry->Flink )
    {
        Context = CONTAINING_RECORD(ListEntry, KERB_CONTEXT, ListEntry.Next);
        if (ContextHandle == Context->LsaContextHandle)
        {

            //
            // Make sure that if we aren't trying to remove it we are
            // from the correct process.
            //

            //
            // If the context is expired, don't allow it to be referenced.
            //

            if (KerbGlobalEnforceTime && !RemoveFromList )
            {
                TimeStamp CurrentTime;
                TimeStamp ContextExpires;
                GetSystemTimeAsFileTime((PFILETIME)  &CurrentTime );
                ContextExpires = Context->Lifetime;
                if (KerbGetTime(ContextExpires) < KerbGetTime(CurrentTime))
                {
                    D_DebugLog((DEB_WARN, "Trying to reference expired context\n"));
                    Found = FALSE;
                    Status = SEC_E_CONTEXT_EXPIRED;
                    break;
                }
            }


            KerbReferenceListEntry(
                &KerbContextList[ListIndex],
                &Context->ListEntry,
                RemoveFromList
                );


            Found = TRUE;
            break;
        }

    }


    KerbUnlockList(&KerbContextList[ListIndex]);

    if (!Found)
    {
        Context = NULL;
    }
    *FoundContext = Context ;

    if ( Context )
    {
        return Status;
    }
    else if (NT_SUCCESS(Status))
    {
        return SEC_E_INVALID_HANDLE ;
    }
    else
    {
        return Status;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceContextByPointer
//
//  Synopsis:   References a context by the context pointer itself.
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  Context - The context to reference.
//              RemoveFromList - If TRUE, context will be delinked
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReferenceContextByPointer(
    IN PKERB_CONTEXT Context,
    IN BOOLEAN RemoveFromList
    )
{
    ULONG ListIndex;

    ListIndex = HandleToListIndex( Context->LsaContextHandle );

    KerbLockList(&KerbContextList[ListIndex]);

    KerbReferenceListEntry(
        &KerbContextList[ListIndex],
        &Context->ListEntry,
        RemoveFromList
        );

    KerbUnlockList(&KerbContextList[ListIndex]);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeContext
//
//  Synopsis:   Frees a context that is unlinked
//
//  Effects:    frees all storage associated with the context
//
//  Arguments:  Context - context to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeContext(
    IN PKERB_CONTEXT Context
    )
{

#ifndef WIN32_CHICAGO
    if (Context->TokenHandle != NULL)
    {
        NtClose(Context->TokenHandle);
    }
#endif // WIN32_CHICAGO
    Context->ContextTag = KERB_CONTEXT_TAG_DELETE;

    KerbFreeKey(&Context->SessionKey);
    KerbFreeKey(&Context->TicketKey);
    if (Context->TicketCacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry(Context->TicketCacheEntry);
    }
    if (Context->UserSid != NULL)
    {
        KerbFree(Context->UserSid);
    }

    KerbFreeString(&Context->ClientName);
    KerbFreeString(&Context->ClientRealm);
    KerbFreeString(&Context->ClientPrincipalName);
    KerbFreeString(&Context->ServerPrincipalName);

    if( Context->pbMarshalledTargetInfo )
    {
        LocalFree( Context->pbMarshalledTargetInfo );
    }

    KerbFree(Context);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceContext
//
//  Synopsis:   Dereferences a logon session - if reference count goes
//              to zero it frees the logon session
//
//  Effects:    decrements reference count
//
//  Arguments:  Context - Logon session to dereference
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbDereferenceContext(
    IN PKERB_CONTEXT Context
    )
{
    ULONG ListIndex;

    ListIndex = HandleToListIndex( Context->LsaContextHandle );

    if (KerbDereferenceListEntry(
            &Context->ListEntry,
            &KerbContextList[ListIndex]
            ) )
    {
        KerbFreeContext(Context);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateEmptyContext
//
//  Synopsis:   Creates a context for the server of a datagram authentication
//              session. Since there is no input message, all the fields
//              are initialized to zero.
//
//  Effects:    Allocates and links a context.
//
//  Arguments:  Credential - Credential to hang this context off of
//              ContextFlags - Flags for the context
//              LogonId = LogonId of the creating logon session
//              NewContext - receives referenced context pointer,
//              ContextLifetime - Lifetime for the context.
//
//  Requires:
//
//  Returns:    NTSTATUS code
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateEmptyContext(
    IN PKERB_CREDENTIAL Credential,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN PLUID LogonId,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context = NULL;

    Status = KerbAllocateContext( &Context, FALSE );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Context->CredentialHandle = KerbGetCredentialHandle(Credential);
    Context->ContextFlags = ContextFlags;
    Context->ContextAttributes = ContextAttributes;
    Context->Lifetime = KerbGlobalWillNeverTime;
    Context->CredManCredentials = NULL;

    GetSystemTimeAsFileTime((PFILETIME)
                                   &(Context->StartTime)
                                   );

    Context->LogonId = *LogonId;
    *ContextLifetime = Context->Lifetime;


    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to insert context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    *NewContext = Context;


Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateClientContext
//
//  Synopsis:   Creates a context for the client of an authentication
//              session.
//
//  Effects:    Allocates and links a context.
//
//  Arguments:  LogonSession - Logon session to lock when accessing the credential
//              Credential - Credential to hang this context off of
//              TicketCacheEntry - Ticket around which to build this context
//              TargetName - target name supplied by client.
//              Nonce - Nonce used in AP request
//              SubSessionKey - subsession key to use, if present
//              ContextFlags - Flags passed in by client for authentication
//                      options.
//              NewContext - receives referenced context pointer,
//              ContextLifetime - Lifetime for the context.
//
//  Requires:
//
//  Returns:    NTSTATUS code
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateClientContext(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ULONG Nonce,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context = NULL;

    Status = KerbAllocateContext( &Context, FALSE );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if (ARGUMENT_PRESENT(TicketCacheEntry))
    {
        //
        // If we are doing datagram, reference the cache entry and
        // store a pointer to it in the context. The ticket cache cannot be
        // read locked at this point because the call to acquire a write
        // lock will block.
        //

        if ((ContextFlags & ISC_RET_DATAGRAM) != 0)
        {

            KerbReferenceTicketCacheEntry(TicketCacheEntry);
            Context->TicketCacheEntry = TicketCacheEntry;
        }

        KerbReadLockTicketCache();

        //
        // Duplicate the session key into the context
        //

        if (ARGUMENT_PRESENT(SubSessionKey) && (SubSessionKey->keyvalue.value != NULL))
        {
            if (!KERB_SUCCESS(KerbDuplicateKey(
                    &Context->SessionKey,
                    SubSessionKey
                    )))
            {
                KerbUnlockTicketCache();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
        else
        {
            //
            // For datagram, create a key
            //

            if ((ContextFlags & ISC_RET_DATAGRAM) != 0)
            {
                KERBERR KerbErr;

                SECPKG_CALL_INFO CallInfo;

                if (!LsaFunctions->GetCallInfo(&CallInfo))
                {
                    D_DebugLog((DEB_ERROR,"Failed to get client info: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    KerbUnlockTicketCache();
                    goto Cleanup;
                }


                //
                // If we are configured for strong encryption & we have said to
                // use it for datagram or this is an inprocess caller, then create
                // a strong key.
                //


                D_DebugLog((DEB_TRACE_CTXT,"Making exportable key for datagram client context\n"));
                if ((KerbGlobalStrongEncryptionPermitted &&
                        KerbGlobalUseStrongEncryptionForDatagram) ||
                    (CallInfo.Attributes & SECPKG_CALL_IN_PROC))
                {
                    KerbErr = KerbMakeKey(
                                TicketCacheEntry->SessionKey.keytype,
                                &Context->SessionKey
                                );
                }
                else
                {
                    KerbErr = KerbMakeExportableKey(
                                TicketCacheEntry->SessionKey.keytype,
                                &Context->SessionKey
                                );
                }

                if (!KERB_SUCCESS(KerbErr))
                {
                    Status = KerbMapKerbError(KerbErr);
                    KerbUnlockTicketCache();
                    goto Cleanup;
                }

            }
            else
            {
                if (!KERB_SUCCESS(KerbDuplicateKey(
                        &Context->SessionKey,
                        &TicketCacheEntry->SessionKey
                        )))
                {
                    KerbUnlockTicketCache();
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
            }
        }
        if (!KERB_SUCCESS(KerbDuplicateKey(
                &Context->TicketKey,
                &TicketCacheEntry->SessionKey
                )))
        {
            KerbUnlockTicketCache();
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Get the client's realm
        //

        Status = KerbDuplicateString(
                   &Context->ClientRealm,
                   &TicketCacheEntry->DomainName);
        if (!NT_SUCCESS(Status))
        {
            KerbUnlockTicketCache();
            goto Cleanup;
        }

        //
        // Get the client's name.
        //

        if (!KERB_SUCCESS(KerbConvertKdcNameToString(
                             &Context->ClientName,
                             TicketCacheEntry->ClientName,
                             NULL)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            KerbUnlockTicketCache();
            goto Cleanup;
        }


        Context->Lifetime = TicketCacheEntry->EndTime;
        Context->StartTime = TicketCacheEntry->StartTime;
        Context->RenewTime = TicketCacheEntry->RenewUntil;
        Context->EncryptionType = TicketCacheEntry->Ticket.encrypted_part.encryption_type;
        KerbUnlockTicketCache();

    }
    else
    {

        Context->Lifetime = KerbGlobalWillNeverTime;
        Context->RenewTime = KerbGlobalWillNeverTime;

        GetSystemTimeAsFileTime((PFILETIME)
                                   &(Context->StartTime)
                                   );

        Context->EncryptionType = KERB_ETYPE_NULL;
    }

    Context->Nonce = Nonce;

    //
    // For now, until the server sends us a separate nonce, use the one
    // we generated for receiving data
    //

    Context->ReceiveNonce = Nonce;

    Context->CredentialHandle = KerbGetCredentialHandle(Credential);

    //KerbReadLockLogonSessions(LogonSession); // FESTER:  Needed??
    if (ARGUMENT_PRESENT(CredManCredentials))
    {
        Context->ContextAttributes |= KERB_CONTEXT_USING_CREDMAN;
        Context->CredManCredentials = CredManCredentials; // don't ref, as we don't use it..
    }
    else if ((Credential->SuppliedCredentials != NULL))
    {
        Context->ContextAttributes |= KERB_CONTEXT_USED_SUPPLIED_CREDS;
    }
    //KerbUnlockLogonSessions(LogonSession);

    Context->ContextFlags = ContextFlags;
    Context->ContextAttributes = KERB_CONTEXT_OUTBOUND | ContextAttributes;


    //
    // if the caller supplied a target name, stash it in the context
    //

    if (ARGUMENT_PRESENT(TargetName))
    {
        Status = KerbDuplicateString(
            &Context->ServerPrincipalName,
            TargetName
            );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }


    *ContextLifetime = Context->Lifetime;

    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to insert context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    *NewContext = Context;


Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function: KerbCreateSKeyEntry
//
//  Synopsis: Create a session key entry
//
//  Effects:
//
//  Arguments: pSessionKey - session key that is used, mostly SubKey
//             pExpireTime - time that the session key expires
//
//  Requires: Memory allocator must zero out memory because KerbFreeSKeyEntry
//            relies on that behavior
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateSKeyEntry(
    IN KERB_ENCRYPTION_KEY* pSessionKey,
    IN FILETIME* pExpireTime
    )
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    KERB_SESSION_KEY_ENTRY* pSessionKeyEntry = NULL;

    if (!pSessionKey || !pExpireTime)
    {
        return STATUS_INVALID_PARAMETER;
    }

    pSessionKeyEntry = (KERB_SESSION_KEY_ENTRY*) KerbAllocate(sizeof(KERB_SESSION_KEY_ENTRY));

    if (!pSessionKeyEntry)
    {
        return STATUS_NO_MEMORY;
    }

    InitializeListHead(&pSessionKeyEntry->ListEntry); // so that un-linking always works

    NtStatus = KerbMapKerbError(KerbDuplicateKey(&pSessionKeyEntry->SessionKey, pSessionKey));

    if (NT_SUCCESS(NtStatus))
    {
        pSessionKeyEntry->ExpireTime = *pExpireTime;

        NtStatus = KerbInsertSKey(pSessionKeyEntry);
    }

    if (!NT_SUCCESS(NtStatus))
    {
        KerbFreeSKeyEntry(pSessionKeyEntry);
    }

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function: KerbDoesSKeyExist
//
//  Synopsis: check whether a session key entry exists the session key list
//
//  Effects:
//
//  Arguments: pKey - key to be located
//             pbExist - whether session key entry exists
//
//  Requires:
//
//  Returns: If an entry is found, ppSKeyEntry points to the entry
//           that contains pKey hence should be non null
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbDoesSKeyExist(
    IN KERB_ENCRYPTION_KEY* pKey,
    OUT BOOLEAN* pbExist
    )
{
    FILETIME CurrentTime = {0};
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    if (!pKey || !pbExist)
    {
        return STATUS_INVALID_PARAMETER;
    }

    *pbExist = FALSE;

    GetSystemTimeAsFileTime(&CurrentTime);

    DebugLog((DEB_TRACE_LOOPBACK, "KerbDoesSKeyExist, curtime %#x:%#x\n", CurrentTime.dwHighDateTime, CurrentTime.dwLowDateTime));

    if (RtlAcquireResourceShared(&KerbNetworkServiceSKeyLock, TRUE))
    {
        NtStatus = STATUS_SUCCESS;

        for (LIST_ENTRY* pListEntry = KerbNetworkServiceSKeyList.Flink;
             NT_SUCCESS(NtStatus) && pListEntry != &KerbNetworkServiceSKeyList;
             pListEntry = pListEntry->Flink)
        {
           KERB_SESSION_KEY_ENTRY* pSKeyEntry = CONTAINING_RECORD(pListEntry, KERB_SESSION_KEY_ENTRY, ListEntry);

           //
           // only keys that have not expired are checked
           //

           if (KerbGetTime(* (TimeStamp*)&pSKeyEntry->ExpireTime) > KerbGetTime(* (TimeStamp*)&CurrentTime))
           {
               BOOLEAN bEqual = FALSE;

               NtStatus = KerbEqualKey(&pSKeyEntry->SessionKey, pKey, &bEqual);

               if (NT_SUCCESS(NtStatus) && bEqual)
               {
                   //
                   // found it
                   //

                   DebugLog((DEB_TRACE_LOOPBACK, "KerbDoesSKeyExist, keyexpire %#x:%#x found\n", pSKeyEntry->ExpireTime.dwHighDateTime, pSKeyEntry->ExpireTime.dwLowDateTime));

                   *pbExist = TRUE;
                   break;
               }
           }
        }

        RtlReleaseResource(&KerbNetworkServiceSKeyLock);
    }

    return NtStatus;
}

//+-----------------------------------------------------------------------
//
// Function: KerbEqualKey
//
// Synopsis: Compare two keys
//
// Effects:
//
// Arguments: pKeyFoo - one key
//            pKeyBar - the other key
//
// Returns: NTSTATUS
//
// History:
//
//------------------------------------------------------------------------

NTSTATUS
KerbEqualKey(
    IN KERB_ENCRYPTION_KEY* pKeyFoo,
    IN KERB_ENCRYPTION_KEY* pKeyBar,
    OUT BOOLEAN* pbEqual
    )
{
    if (!pKeyFoo || !pKeyBar || !pbEqual)
    {
        return STATUS_INVALID_PARAMETER;
    }

    *pbEqual = (pKeyFoo->keytype == pKeyBar->keytype) &&
             (pKeyFoo->keyvalue.length == pKeyBar->keyvalue.length) &&
             (pKeyFoo->keyvalue.length == RtlCompareMemory(pKeyFoo->keyvalue.value, pKeyBar->keyvalue.value, pKeyFoo->keyvalue.length));

    return STATUS_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function: KerbInsertSessionKey
//
//  Synopsis: Insert an session key entry to KerbNetWorkSessionKeyList
//
//  Effects:
//
//  Arguments: pSKeyEntry - entry to be inserted
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInsertSKey(
    IN KERB_SESSION_KEY_ENTRY* pSKeyEntry
    )
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    if (!pSKeyEntry)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (RtlAcquireResourceExclusive(&KerbNetworkServiceSKeyLock, TRUE))
    {
        NtStatus = STATUS_SUCCESS;

        InsertHeadList(&KerbNetworkServiceSKeyList, &pSKeyEntry->ListEntry);
        RtlReleaseResource(&KerbNetworkServiceSKeyLock);
    }

#if DBG

    ULONG cSKeyEntries = 0;

    if (NT_SUCCESS(NtStatus))
    {
        cSKeyEntries = InterlockedIncrement(&KerbcSKeyEntries);
    }

    DebugLog((DEB_TRACE_LOOPBACK, "KerbInsertSKey, status 0x%x, keyexpire %#x:%#x, total %d keys\n", NtStatus, pSKeyEntry->ExpireTime.dwHighDateTime, pSKeyEntry->ExpireTime.dwLowDateTime, cSKeyEntries));

#endif

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function: KerbTrimSKeyList
//
//  Synopsis: Release session key entries that have expired
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbTrimSKeyList(
    VOID
    )
{
    FILETIME CurrentTime = {0};
    BOOLEAN bCleanUpNeeded = FALSE;

    GetSystemTimeAsFileTime(&CurrentTime);

    DebugLog((DEB_TRACE_LOOPBACK, "KerbTrimSKeyList, curtime %#x:%#x\n", CurrentTime.dwHighDateTime, CurrentTime.dwLowDateTime));

    if (RtlAcquireResourceShared(&KerbNetworkServiceSKeyLock, TRUE))
    {
        for (LIST_ENTRY* pListEntry = KerbNetworkServiceSKeyList.Flink;
             pListEntry != &KerbNetworkServiceSKeyList;
             pListEntry = pListEntry->Flink)
        {
           KERB_SESSION_KEY_ENTRY* pSKeyEntry = CONTAINING_RECORD(pListEntry, KERB_SESSION_KEY_ENTRY, ListEntry);

           if (KerbGetTime(* (TimeStamp*)&pSKeyEntry->ExpireTime) <= KerbGetTime(* (TimeStamp*)&CurrentTime))
           {
               bCleanUpNeeded = TRUE;
               break;
           }
        }

        if (bCleanUpNeeded)
        {
            RtlConvertSharedToExclusive(&KerbNetworkServiceSKeyLock);

            for (LIST_ENTRY* pListEntry = KerbNetworkServiceSKeyList.Flink;
                 pListEntry != &KerbNetworkServiceSKeyList;
                 /* updating pListEntry inside the loop */)
            {
               KERB_SESSION_KEY_ENTRY* pSKeyEntry = CONTAINING_RECORD(pListEntry, KERB_SESSION_KEY_ENTRY, ListEntry);

               //
               //  Update next link before pListEntry is deleted
               //

               pListEntry = pListEntry->Flink;

               //
               // only delete keys that expired
               //

               if (KerbGetTime(* (TimeStamp*)&pSKeyEntry->ExpireTime) <= KerbGetTime(* (TimeStamp*)&CurrentTime))
               {
                   KerbFreeSKeyEntry(pSKeyEntry);
               }
            }
        }

        RtlReleaseResource(&KerbNetworkServiceSKeyLock);
    }
}

//+-------------------------------------------------------------------------
//
//  Function: KerbNetworkServiceSKeyListCleanupCallback
//
//  Synopsis: Clean up network service session key list
//
//  Effects:
//
//  Arguments: pContext - the context parameter, see RtlCreateTimer
//             bTimeOut - whether a timeout has occurred
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbNetworkServiceSKeyListCleanupCallback(
    IN VOID* pContext,
    IN BOOLEAN bTimeOut
    )
{
    DebugLog((DEB_TRACE_LOOPBACK, "KerbNetworkServiceSKeyListCleanupCallback is called\n"));

    KerbTrimSKeyList();
}

//+-------------------------------------------------------------------------
//
//  Function: KerbFreeSKeyEntry
//
//  Synopsis: Free a session key entry
//
//  Effects:
//
//  Arguments: pSKeyEntry - session key entry to free
//
//  Requires: pSKeyEntry->ListEntry must have been initialized properly
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeSKeyEntry(
    IN KERB_SESSION_KEY_ENTRY* pSKeyEntry
    )
{
    if (pSKeyEntry)
    {
        RemoveEntryList(&pSKeyEntry->ListEntry);

#if DBG

        LONG cSKeyEntries = 0;

        cSKeyEntries = InterlockedDecrement(&KerbcSKeyEntries);

        DebugLog((DEB_TRACE_LOOPBACK, "KerbFreeSKeyEntry, keyexpire %#x:%#x, %d keys left\n", pSKeyEntry->ExpireTime.dwHighDateTime, pSKeyEntry->ExpireTime.dwLowDateTime, cSKeyEntries));

#endif

        KerbFreeKey(&pSKeyEntry->SessionKey);

        KerbFree(pSKeyEntry);
    }
}

//+-------------------------------------------------------------------------
//
//  Function: KerbCreateSKeyTimer
//
//  Synopsis: Create a timer and set the callback to clean up the session
//            key list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateSKeyTimer(
    VOID
    )
{
    NTSTATUS NtStatus;
    HANDLE hTimer = NULL;

    KerbhSKeyTimerQueue = NULL;

    NtStatus = RtlCreateTimerQueue(&KerbhSKeyTimerQueue);

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = RtlCreateTimer(
                        KerbhSKeyTimerQueue,
                        &hTimer,
                        KerbNetworkServiceSKeyListCleanupCallback,
                        NULL,  //  no context
                        KERB_DEFAULT_SKEWTIME * 60 * 1000,   // 5 min
                        KERB_DEFAULT_SKEWTIME * KERB_SKLIST_CALLBACK_FEQ * 60 * 1000,    // 50 min
                        0
                        );
    }

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function: KerbFreeSKeyTimer
//
//  Synopsis: Free network service key list timer queue
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeSKeyTimer(
    VOID
    )
{
    if (KerbhSKeyTimerQueue)
    {
        RtlDeleteTimerQueue(KerbhSKeyTimerQueue);
        KerbhSKeyTimerQueue = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateServerContext
//
//  Synopsis:   Creates a context for the server of an authentication
//              session.
//
//  Effects:    Allocates and links a context.
//
//  Arguments:  Context - Context to update
//              InternalTicket - Ticket used to create this context.
//              SessionKey - Session key from the ticket.
//              LogonId - Logon ID of the context
//              UserSid - User's sid, held onto by context
//              ContextFlags - SSPI Flags for this context
//              ContextAttributes - Internal attributes of context
//              TokenHandle - Handle the token for this context
//              ContextLifetime - Lifetime for the context.
//
//  Requires:
//
//  Returns:    NTSTATUS code
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbUpdateServerContext(
    IN PKERB_CONTEXT Context,
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AP_REQUEST ApRequest,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PLUID LogonId,
    IN PSID * UserSid,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN ULONG Nonce,
    IN ULONG ReceiveNonce,
    IN OUT PHANDLE TokenHandle,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientDomain,
    OUT PTimeStamp ContextLifetime
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    KerbWriteLockContexts();

    if (!KERB_SUCCESS(KerbDuplicateKey(
                        &Context->SessionKey,
                        SessionKey
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If this was not a null session and there is a ticket available,
    // pull interesting information out of the ticket
    //

    if (ARGUMENT_PRESENT(InternalTicket))
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &Context->Lifetime,
            &InternalTicket->endtime,
            0
            );

        if (InternalTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &Context->RenewTime,
                &InternalTicket->KERB_ENCRYPTED_TICKET_renew_until,
                0
                );

        }

        //
        // Stick the client name in the context
        //

        Context->ClientName = *ClientName;
        RtlInitUnicodeString(
            ClientName,
            NULL
            );

        Context->ClientRealm = *ClientDomain;
        RtlInitUnicodeString(
            ClientDomain,
            NULL
            );

        if (!KERB_SUCCESS(KerbDuplicateKey(
                &Context->TicketKey,
                &InternalTicket->key)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Copy the principal names from the ticket
        //

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToFullServiceString(
                &Context->ClientPrincipalName,
                &InternalTicket->client_name,
                InternalTicket->client_realm
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToFullServiceString(
                &Context->ServerPrincipalName,
                &ApRequest->ticket.server_name,
                ApRequest->ticket.realm
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


    }
    else
    {
        Context->Lifetime = KerbGlobalWillNeverTime;
        Context->RenewTime = KerbGlobalWillNeverTime;
        Context->EncryptionType = KERB_ETYPE_NULL;
    }


    //
    // If we generated a nonce to send to the client, use it. Otherwise use
    // the receive nonce from the AP req.
    //

    if (Nonce != 0)
    {
        Context->Nonce = Nonce;
    }
    else
    {
        Context->Nonce = ReceiveNonce;
    }

    Context->ReceiveNonce = ReceiveNonce;

    Context->LogonId = *LogonId;
    Context->ContextFlags |= ContextFlags;
    Context->TokenHandle = *TokenHandle;
    Context->UserSid = *UserSid;
    Context->ContextAttributes = KERB_CONTEXT_INBOUND;
    Context->ContextAttributes |= ContextAttributes;
    *ContextLifetime = Context->Lifetime;


    //
    // Null the token handle so the caller does not free it
    //

    *TokenHandle = NULL;
    *UserSid = NULL;
Cleanup:
    KerbUnlockContexts();
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateServerContext
//
//  Synopsis:   Creates a context for the server of an authentication
//              session.
//
//  Effects:    Allocates and links a context.
//
//  Arguments:  LogonSession - Logon session to lock when accessing the credential
//              Credential - Credential to hang this context off of
//              InternalTicket - Ticket used to create this context.
//              SessionKey - Session key from the ticket.
//              LogonId - Logon ID of the context
//              UserSid - User's SID, held on to in context.
//              ContextFlags - SSPI Flags for this context
//              ContextAttributes - Internal attributes of context
//              TokenHandle - Handle the token for this context
//              NewContext - receives referenced context pointer
//              ContextLifetime - Lifetime for the context.
//
//  Requires:
//
//  Returns:    NTSTATUS code
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateServerContext(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AP_REQUEST ApRequest,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PLUID LogonId,
    IN PSID * UserSid,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN ULONG Nonce,
    IN ULONG ReceiveNonce,
    IN OUT PHANDLE TokenHandle,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientDomain,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context = NULL;


    Status = KerbAllocateContext( &Context, FALSE );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if (!KERB_SUCCESS(KerbDuplicateKey(
                        &Context->SessionKey,
                        SessionKey
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If this wasn't a null session, stick the info from the ticket into
    // the context.
    //

    if (ARGUMENT_PRESENT(InternalTicket))
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &Context->Lifetime,
            &InternalTicket->endtime,
            0
            );
        if (InternalTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &Context->RenewTime,
                &InternalTicket->KERB_ENCRYPTED_TICKET_renew_until,
                0
                );

        }

        if (InternalTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &Context->StartTime,
                &InternalTicket->starttime,
                0
                );

        }
        else // use current time
        {
           GetSystemTimeAsFileTime((PFILETIME)
                             &(Context->StartTime)
                             );
        }


        Context->ClientName = *ClientName;
        RtlInitUnicodeString(
            ClientName,
            NULL
            );
        Context->ClientRealm = *ClientDomain;
        RtlInitUnicodeString(
            ClientDomain,
            NULL
            );

        if (!KERB_SUCCESS(KerbDuplicateKey(
                &Context->TicketKey,
                &InternalTicket->key)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Copy the principal names from the ticket
        //

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToFullServiceString(
                &Context->ClientPrincipalName,
                &InternalTicket->client_name,
                InternalTicket->client_realm
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToFullServiceString(
                &Context->ServerPrincipalName,
                &ApRequest->ticket.server_name,
                ApRequest->ticket.realm
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }
    else
    {
        Context->Lifetime = KerbGlobalWillNeverTime;
        Context->RenewTime = KerbGlobalWillNeverTime;

        GetSystemTimeAsFileTime((PFILETIME)
                                   &(Context->StartTime)
                                   );

        Context->EncryptionType = KERB_ETYPE_NULL;
    }

    //
    // If we generated a nonce to send to the client, use it. Otherwise use
    // the receive nonce from the AP req.
    //

//    if (Nonce != 0)
//    {
        Context->Nonce = Nonce;
//    }
//    else
//    {
//        Context->Nonce = ReceiveNonce;
//    }

    Context->ReceiveNonce = ReceiveNonce;
    Context->CredentialHandle = KerbGetCredentialHandle(Credential);
    Context->LogonId = *LogonId;
    Context->ContextFlags = ContextFlags;
    Context->TokenHandle = *TokenHandle;
    Context->UserSid = *UserSid;
    //
    // Null the token handle so the caller does not free it
    //

    *TokenHandle = NULL;
    *UserSid = NULL;

    Context->ContextAttributes = KERB_CONTEXT_INBOUND;
    Context->ContextAttributes |= ContextAttributes;

    KerbReadLockLogonSessions(LogonSession);
    if (Credential->SuppliedCredentials != NULL)
    {
        Context->ContextAttributes |= KERB_CONTEXT_USED_SUPPLIED_CREDS;
    }


    KerbUnlockLogonSessions(LogonSession);

    *ContextLifetime = Context->Lifetime;

    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to insert context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    *NewContext = Context;


Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbMapContext
//
//  Synopsis:   Maps a context to the caller's address space
//
//  Effects:
//
//  Arguments:  Context - The context to map
//              CopyToken - If TRUE, duplicate token to client
//              MappedContext - Set to TRUE on success
//              ContextData - Receives a buffer in the LSA's address space
//                      with the mapped context.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMapContext(
    IN PKERB_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
{
    NTSTATUS Status ;
    PKERB_PACKED_CONTEXT PackedContext = NULL ;
    ULONG ContextSize ;
    PUCHAR CopyTo ;
    ULONG CurrentOffset ;

    KerbWriteLockContexts();

    //
    // If we already mapped the context don't try to do it again. We may
    // be able to map user-mode contexts multiple times, though.
    //

    if (KerberosState == KerberosLsaMode)
    {
        if ((Context->ContextAttributes & KERB_CONTEXT_MAPPED) != 0)
        {
            KerbUnlockContexts();
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        Context->ContextAttributes |= KERB_CONTEXT_MAPPED;
    }


    ContextSize = sizeof(KERB_PACKED_CONTEXT) +
                        Context->ClientName.Length +
                        Context->ClientRealm.Length +
                        Context->SessionKey.keyvalue.length +
                        Context->cbMarshalledTargetInfo ;

    PackedContext = (PKERB_PACKED_CONTEXT) KerbAllocate( ContextSize );

    if (PackedContext == NULL)
    {
        Context->ContextAttributes &= ~(KERB_CONTEXT_MAPPED);

        KerbUnlockContexts();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    CurrentOffset = sizeof( KERB_PACKED_CONTEXT );
    CopyTo = (PUCHAR) ( PackedContext + 1 );

    PackedContext->ContextType = KERB_PACKED_CONTEXT_MAP ;
    PackedContext->Pad = 0 ;
    PackedContext->Lifetime = Context->Lifetime ;
    PackedContext->RenewTime = Context->RenewTime ;
    PackedContext->StartTime = Context->StartTime;

    PackedContext->ClientName.Length = Context->ClientName.Length ;
    PackedContext->ClientName.MaximumLength = Context->ClientName.Length ;
    PackedContext->ClientName.Buffer = CurrentOffset ;

    RtlCopyMemory(
        CopyTo,
        Context->ClientName.Buffer,
        Context->ClientName.Length );

    CurrentOffset += Context->ClientName.Length ;
    CopyTo += Context->ClientName.Length ;

    PackedContext->ClientRealm.Length = Context->ClientRealm.Length ;
    PackedContext->ClientRealm.MaximumLength = Context->ClientRealm.Length ;
    PackedContext->ClientRealm.Buffer = CurrentOffset ;

    RtlCopyMemory(
        CopyTo,
        Context->ClientRealm.Buffer,
        Context->ClientRealm.Length );

    CurrentOffset += Context->ClientRealm.Length ;
    CopyTo += Context->ClientRealm.Length ;

    PackedContext->LsaContextHandle = (ULONG) Context->LsaContextHandle ;
    PackedContext->LogonId = Context->LogonId ;

    PackedContext->CredentialHandle = 0 ;
    PackedContext->SessionKeyType = Context->SessionKey.keytype ;
    PackedContext->SessionKeyOffset = CurrentOffset ;
    PackedContext->SessionKeyLength = Context->SessionKey.keyvalue.length ;

    RtlCopyMemory(
        CopyTo,
        Context->SessionKey.keyvalue.value,
        Context->SessionKey.keyvalue.length );

    CurrentOffset += PackedContext->SessionKeyLength ;
    CopyTo += PackedContext->SessionKeyLength;

    if( Context->pbMarshalledTargetInfo )
    {
        PackedContext->MarshalledTargetInfo = CurrentOffset;
        PackedContext->MarshalledTargetInfoLength = Context->cbMarshalledTargetInfo;

        RtlCopyMemory(
            CopyTo,
            Context->pbMarshalledTargetInfo,
            Context->cbMarshalledTargetInfo );

        CurrentOffset += PackedContext->MarshalledTargetInfoLength;
        CopyTo += PackedContext->MarshalledTargetInfoLength;
    }

    PackedContext->Nonce = Context->Nonce ;
    PackedContext->ReceiveNonce = Context->ReceiveNonce ;
    PackedContext->ContextFlags = Context->ContextFlags ;
    PackedContext->ContextAttributes = Context->ContextAttributes ;
    PackedContext->EncryptionType = Context->EncryptionType ;

    KerbUnlockContexts();

    //
    // If there is a token in the context, copy it also
    //

#ifndef WIN32_CHICAGO
    if ((KerberosState == KerberosLsaMode)  && (Context->TokenHandle != NULL))
    {
        HANDLE duplicateHandle;

        Status = LsaFunctions->DuplicateHandle(
                    Context->TokenHandle,
                    &duplicateHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to duplicate handle: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        PackedContext->TokenHandle = HandleToUlong(duplicateHandle);
        NtClose(Context->TokenHandle);
        Context->TokenHandle = NULL;
    }
    else
    {
         PackedContext->TokenHandle = NULL;
    }
#endif // WIN32_CHICAGO


    ContextData->pvBuffer = PackedContext;
    ContextData->cbBuffer = ContextSize;


    *MappedContext = TRUE;


    Status = STATUS_SUCCESS;

Cleanup:


    if (!NT_SUCCESS(Status))
    {
        if (PackedContext != NULL)
        {
            KerbFree(PackedContext);
        }
    }

    return(Status);
}
#if 0
NTSTATUS
KerbMapContext(
    IN PKERB_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT PackedContext = NULL;
    ULONG ContextSize;

    KerbWriteLockContexts();

    //
    // If we already mapped the context don't try to do it again. We may
    // be able to map user-mode contexts multiple times, though.
    //

    if (KerberosState == KerberosLsaMode)
    {
        if ((Context->ContextAttributes & KERB_CONTEXT_MAPPED) != 0)
        {
            KerbUnlockContexts();
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        Context->ContextAttributes |= KERB_CONTEXT_MAPPED;
    }


    ContextSize = sizeof(KERB_CONTEXT) +
                        Context->ClientName.Length +
                        Context->ClientRealm.Length +
                        Context->SessionKey.keyvalue.length;

    PackedContext = (PKERB_CONTEXT) KerbAllocate(ContextSize);

    if (PackedContext == NULL)
    {
        KerbUnlockContexts();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    RtlCopyMemory(
        PackedContext,
        Context,
        sizeof(KERB_CONTEXT)
        );

    PackedContext->ClientName.Buffer = (LPWSTR) sizeof(KERB_CONTEXT);
    RtlCopyMemory(
        PackedContext+1,
        Context->ClientName.Buffer,
        Context->ClientName.Length
        );
    PackedContext->ClientName.MaximumLength = PackedContext->ClientName.Length;


    PackedContext->ClientRealm.Buffer = (LPWSTR) (sizeof(KERB_CONTEXT) + PackedContext->ClientName.Length);
    RtlCopyMemory(
        (PUCHAR) PackedContext + (UINT_PTR) PackedContext->ClientRealm.Buffer,
        Context->ClientRealm.Buffer,
        Context->ClientRealm.Length
        );
    PackedContext->ClientRealm.MaximumLength = PackedContext->ClientRealm.Length;

    RtlZeroMemory(
        &PackedContext->TicketKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    RtlZeroMemory(
        &PackedContext->ClientPrincipalName,
        sizeof(UNICODE_STRING)
        );

    RtlZeroMemory(
        &PackedContext->ServerPrincipalName,
        sizeof(UNICODE_STRING)
        );

    //
    // Pack in the session key
    //

    PackedContext->SessionKey.keyvalue.value = (PUCHAR) PackedContext->ClientRealm.Buffer + PackedContext->ClientRealm.MaximumLength;

    RtlCopyMemory(
        PackedContext->SessionKey.keyvalue.value + (UINT_PTR) PackedContext,
        Context->SessionKey.keyvalue.value,
        Context->SessionKey.keyvalue.length
        );

    KerbUnlockContexts();

    //
    // If there is a token in the context, copy it also
    //

#ifndef WIN32_CHICAGO
    if ((KerberosState == KerberosLsaMode)  && (Context->TokenHandle != NULL))
    {
        Status = LsaFunctions->DuplicateHandle(
                    Context->TokenHandle,
                    &PackedContext->TokenHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to duplicate handle: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
        NtClose(Context->TokenHandle);
        Context->TokenHandle = NULL;
    }
    else
    {
         PackedContext->TokenHandle = NULL;
    }
#endif // WIN32_CHICAGO


    ContextData->pvBuffer = PackedContext;
    ContextData->cbBuffer = ContextSize;


    *MappedContext = TRUE;


    Status = STATUS_SUCCESS;

Cleanup:


    if (!NT_SUCCESS(Status))
    {
        if (PackedContext != NULL)
        {
            KerbFree(PackedContext);
        }
    }

    return(Status);

}
#endif


#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTokenUser
//
//  Synopsis:   Returns user field from a token
//
//  Effects:    allocates memory with LocalAlloc
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetTokenUser(
    HANDLE Token,
    PTOKEN_USER * pTokenUser
    )
{
    PTOKEN_USER LocalTokenUser = NULL;
    NTSTATUS Status;
    ULONG TokenUserSize = 0;

    //
    // Query the token user.  First pass in NULL to get back the
    // required size.
    //

    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                NULL,
                0,
                &TokenUserSize
                );

    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        DsysAssert(Status != STATUS_SUCCESS);
        return(Status);
    }

    //
    // Now allocate the required ammount of memory and try again.
    //

    LocalTokenUser = (PTOKEN_USER) LocalAlloc(0,TokenUserSize);
    if (LocalTokenUser == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                LocalTokenUser,
                TokenUserSize,
                &TokenUserSize
                );

    if (NT_SUCCESS(Status))
    {
        *pTokenUser = LocalTokenUser;
    }
    else
    {
        LocalFree(LocalTokenUser);
    }
    return(Status);
}
#endif // WIN32_CHICAGO



#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateTokenDacl
//
//  Synopsis:   Modifies DACL on the context token to grant access to the
//              the caller.
//
//  Effects:
//
//  Arguments:  Token - Token to modify
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateTokenDacl(
    HANDLE Token
    )
{
    NTSTATUS Status;
    PTOKEN_USER ProcessTokenUser = NULL;
    PTOKEN_USER ThreadTokenUser = NULL;
    PTOKEN_USER ImpersonationTokenUser = NULL;
    HANDLE ProcessToken = NULL;
    HANDLE ImpersonationToken = NULL;
    BOOL fInsertImpersonatingUser = FALSE;
    ULONG AclLength;
    PACL NewDacl = NULL;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    //
    // it's possible that the current thread is impersonating a user.
    // if that's the case, get it's token user, and revert to insure we
    // can open the process token.
    //

    Status = NtOpenThreadToken(
                            NtCurrentThread(),
                            TOKEN_QUERY | TOKEN_IMPERSONATE,
                            TRUE,
                            &ImpersonationToken
                            );

    if( NT_SUCCESS(Status) )
    {
        //
        // stop impersonating.
        //

        RevertToSelf();

        //
        // get the token user for the impersonating user.
        //

        Status = KerbGetTokenUser(
                    ImpersonationToken,
                    &ImpersonationTokenUser
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Open the process token to find out the user sid
    //

    Status = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_QUERY,
                &ProcessToken
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbGetTokenUser(
                ProcessToken,
                &ProcessTokenUser
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now get the token user for the thread.
    //
    Status = KerbGetTokenUser(
                Token,
                &ThreadTokenUser
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    AclLength = 4 * sizeof( ACCESS_ALLOWED_ACE ) - 4 * sizeof( ULONG ) +
                RtlLengthSid( ProcessTokenUser->User.Sid ) +
                RtlLengthSid( ThreadTokenUser->User.Sid ) +
                RtlLengthSid( KerbGlobalLocalSystemSid ) +
                RtlLengthSid( KerbGlobalAliasAdminsSid ) +
                sizeof( ACL );

    //
    // determine if we need to add impersonation token sid onto the token Dacl.
    //

    if( ImpersonationTokenUser &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, ProcessTokenUser->User.Sid ) &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, ThreadTokenUser->User.Sid )
        )
    {
        AclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof( ULONG )) +
                RtlLengthSid( ImpersonationTokenUser->User.Sid );

        fInsertImpersonatingUser = TRUE;
    }

    NewDacl = (PACL) LocalAlloc(0, AclLength );

    if (NewDacl == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = RtlCreateAcl( NewDacl, AclLength, ACL_REVISION2 );
    DsysAssert(NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ProcessTokenUser->User.Sid
                 );
    DsysAssert( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ThreadTokenUser->User.Sid
                 );
    DsysAssert( NT_SUCCESS( Status ));

    if( fInsertImpersonatingUser )
    {
        Status = RtlAddAccessAllowedAce (
                     NewDacl,
                     ACL_REVISION2,
                     TOKEN_ALL_ACCESS,
                     ImpersonationTokenUser->User.Sid
                     );
        DsysAssert( NT_SUCCESS( Status ));
    }

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 KerbGlobalAliasAdminsSid
                 );
    DsysAssert( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 KerbGlobalLocalSystemSid
                 );
    DsysAssert( NT_SUCCESS( Status ));

    Status = RtlCreateSecurityDescriptor (
                 &SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    DsysAssert( NT_SUCCESS( Status ));

    Status = RtlSetDaclSecurityDescriptor(
                 &SecurityDescriptor,
                 TRUE,
                 NewDacl,
                 FALSE
                 );

    DsysAssert( NT_SUCCESS( Status ));

    Status = NtSetSecurityObject(
                 Token,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    DsysAssert( NT_SUCCESS( Status ));


Cleanup:

    if( ImpersonationToken != NULL ) {

        //
        // put the thread token back if we were impersonating.
        //

        SetThreadToken( NULL, ImpersonationToken );
        NtClose( ImpersonationToken );
    }

    if (ThreadTokenUser != NULL) {
        LocalFree( ThreadTokenUser );
    }

    if (ProcessTokenUser != NULL) {
        LocalFree( ProcessTokenUser );
    }

    if (ImpersonationTokenUser != NULL) {
        LocalFree( ImpersonationTokenUser );
    }

    if (NewDacl != NULL) {
        LocalFree( NewDacl );
    }

    if (ProcessToken != NULL)
    {
        NtClose(ProcessToken);
    }

    return( Status );
}
#endif // WIN32_CHICAGO


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateUserModeContext
//
//  Synopsis:   Creates a user-mode context to support impersonation and
//              message integrity and privacy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_CONTEXT * NewContext
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context = NULL;
    PKERB_PACKED_CONTEXT PackedContext ;
    UNICODE_STRING String ;
    KERB_ENCRYPTION_KEY Key ;


    if (MarshalledContext->cbBuffer < sizeof(KERB_PACKED_CONTEXT))
    {
        D_DebugLog((DEB_ERROR,"Invalid buffer size for marshalled context: was 0x%x, needed 0x%x. %ws, line %d\n",
            MarshalledContext->cbBuffer, sizeof(KERB_CONTEXT), THIS_FILE, __LINE__));
        return(STATUS_INVALID_PARAMETER);
    }

    PackedContext = (PKERB_PACKED_CONTEXT) MarshalledContext->pvBuffer;


    Status = KerbAllocateContext( &Context, TRUE );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Context->Lifetime = PackedContext->Lifetime ;
    Context->RenewTime = PackedContext->RenewTime ;
    Context->StartTime = PackedContext->StartTime;

    String.Length = PackedContext->ClientName.Length ;
    String.MaximumLength = PackedContext->ClientName.MaximumLength ;
    String.Buffer = (PWSTR)((PUCHAR) PackedContext + PackedContext->ClientName.Buffer );

    Status = KerbDuplicateString(
                &Context->ClientName,
                &String );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup ;
    }

    String.Length = PackedContext->ClientRealm.Length ;
    String.MaximumLength = PackedContext->ClientRealm.MaximumLength ;
    String.Buffer = (PWSTR)((PUCHAR) PackedContext + PackedContext->ClientRealm.Buffer );

    Status = KerbDuplicateString(
                &Context->ClientRealm,
                &String );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup ;
    }

    Context->LogonId = PackedContext->LogonId ;
    Context->TokenHandle = (HANDLE) ULongToPtr(PackedContext->TokenHandle);
    Context->CredentialHandle = NULL ;
    Context->Nonce = PackedContext->Nonce ;
    Context->ReceiveNonce = PackedContext->ReceiveNonce ;
    Context->ContextFlags = PackedContext->ContextFlags ;
    Context->ContextAttributes = PackedContext->ContextAttributes ;
    Context->EncryptionType = PackedContext->EncryptionType ;

    Key.keytype = PackedContext->SessionKeyType ;
    Key.keyvalue.value = (PUCHAR) ((PUCHAR) PackedContext + PackedContext->SessionKeyOffset );
    Key.keyvalue.length = PackedContext->SessionKeyLength ;

    if (!KERB_SUCCESS(KerbDuplicateKey(
            &Context->SessionKey,
            &Key)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    //
    // Null out string buffers that aren't meant to be copied.
    //

    Context->ClientPrincipalName.Buffer = NULL;
    Context->ServerPrincipalName.Buffer = NULL;
    Context->TicketKey.keyvalue.value = NULL;
    Context->UserSid = NULL;
    Context->TicketCacheEntry = NULL;


    //
    // Modify the DACL on the token to grant access to the caller
    //

#ifndef WIN32_CHICAGO
    if (Context->TokenHandle != NULL)
    {
        Status = KerbCreateTokenDacl(
                    Context->TokenHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
#endif // WIN32_CHICAGO
    //
    // We didn't copy the ticket here, so don't store the entry
    //

    Context->TicketCacheEntry = NULL;

    KerbInitializeListEntry(
        &Context->ListEntry
        );


    if( ContextHandle != 0 )
    {
        Context->LsaContextHandle = ContextHandle;
    } else {
        Context->LsaContextHandle = (ULONG_PTR)Context;
    }


    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to insert context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    *NewContext = Context;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);

}

#if 0
NTSTATUS
KerbCreateUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_CONTEXT * NewContext
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context = NULL;
    PKERB_CONTEXT LsaContext;

    if (MarshalledContext->cbBuffer < sizeof(KERB_CONTEXT))
    {
        D_DebugLog((DEB_ERROR,"Invalid buffer size for marshalled context: was 0x%x, needed 0x%x. %ws, line %d\n",
            MarshalledContext->cbBuffer, sizeof(KERB_CONTEXT), THIS_FILE, __LINE__));
        return(STATUS_INVALID_PARAMETER);
    }

    LsaContext = (PKERB_CONTEXT) MarshalledContext->pvBuffer;

    //
    // Normalize the client name.
    //

    LsaContext->ClientName.Buffer = (LPWSTR) ((PUCHAR) LsaContext->ClientName.Buffer + (UINT_PTR) LsaContext);
    LsaContext->ClientRealm.Buffer = (LPWSTR) ((PUCHAR) LsaContext->ClientRealm.Buffer + (UINT_PTR) LsaContext);
    LsaContext->SessionKey.keyvalue.value = (PUCHAR) LsaContext->SessionKey.keyvalue.value + (UINT_PTR) LsaContext;

    Status = KerbAllocateContext( &Context, TRUE );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *Context = *LsaContext;

    //
    // Null out string buffers that aren't meant to be copied.
    //

    Context->ClientName.Buffer = NULL;
    Context->ClientRealm.Buffer = NULL;
    Context->SessionKey.keyvalue.value = NULL;
    Context->UserSid = NULL;
    Context->TicketCacheEntry = NULL;


    //
    // Modify the DACL on the token to grant access to the caller
    //

#ifndef WIN32_CHICAGO
    if (Context->TokenHandle != NULL)
    {
        Status = KerbCreateTokenDacl(
                    Context->TokenHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
#endif // WIN32_CHICAGO
    //
    // We didn't copy the ticket here, so don't store the entry
    //

    Context->TicketCacheEntry = NULL;

    KerbInitializeListEntry(
        &Context->ListEntry
        );

    Context->LsaContextHandle = ContextHandle;

    Status = KerbDuplicateString(
                    &Context->ClientName,
                    &LsaContext->ClientName
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                    &Context->ClientRealm,
                    &LsaContext->ClientRealm
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbDuplicateKey(
            &Context->SessionKey,
            &LsaContext->SessionKey)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to insert context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    *NewContext = Context;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);

}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateClientContext
//
//  Synopsis:   updates context with latest info
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbUpdateClientContext(
    IN PKERB_CONTEXT Context,
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN ULONG Nonce,
    IN ULONG ReceiveNonce,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    OUT PTimeStamp ContextLifetime
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KerbWriteLockContexts();

    if (ARGUMENT_PRESENT(TicketCacheEntry))
    {
        KerbReadLockTicketCache();

        //
        // Duplicate the session key into the context
        //

        KerbFreeKey(
            &Context->SessionKey
            );

        if (ARGUMENT_PRESENT(SubSessionKey) && (SubSessionKey->keyvalue.value != NULL))
        {
            if (!KERB_SUCCESS(KerbDuplicateKey(
                    &Context->SessionKey,
                    SubSessionKey
                    )))
            {
                KerbUnlockTicketCache();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
        else
        {
            if (!KERB_SUCCESS(KerbDuplicateKey(
                    &Context->SessionKey,
                    &TicketCacheEntry->SessionKey
                    )))
            {
                KerbUnlockTicketCache();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }

        KerbFreeKey(
            &Context->TicketKey
            );

        if (!KERB_SUCCESS(KerbDuplicateKey(
                &Context->TicketKey,
                &TicketCacheEntry->SessionKey
                )))
        {
            KerbUnlockTicketCache();
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Context->Lifetime = TicketCacheEntry->EndTime;
        Context->RenewTime = TicketCacheEntry->RenewUntil;
        Context->EncryptionType = TicketCacheEntry->Ticket.encrypted_part.encryption_type;
        KerbUnlockTicketCache();
    }
    else
    {

        Context->Lifetime = KerbGlobalWillNeverTime;
        Context->RenewTime = KerbGlobalWillNeverTime;
        Context->EncryptionType = KERB_ETYPE_NULL;
    }

    Context->Nonce = Nonce;

    //
    // If the server sent us a nonce for receiving data, use it. Otherwise use
    // the nonce we generated.
    //

//    if (ReceiveNonce != 0)
//    {
        Context->ReceiveNonce = ReceiveNonce;
//    }
//    else
//    {
//        Context->ReceiveNonce = Nonce;
//    }

    //
    // delegation flags are not additive, turn it off before updating it
    //

    Context->ContextFlags &= ~(ISC_RET_DELEGATE_IF_SAFE | ISC_RET_DELEGATE);

    Context->ContextFlags |= ContextFlags;


    Context->ContextAttributes |= KERB_CONTEXT_OUTBOUND | ContextAttributes;

    *ContextLifetime = Context->Lifetime;

Cleanup:
    KerbUnlockContexts();
    return(Status);

}

ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    )
{
    ASSERT( (KERB_USERLIST_COUNT != 0) );
    ASSERT( (KERB_USERLIST_COUNT & 1) == 0 );

    ULONG Number ;
    ULONG Hash;
    ULONG HashFinal;

    Number       = (ULONG)ContextHandle;

    Hash         = Number;
    Hash        += Number >> 8;
    Hash        += Number >> 16;
    Hash        += Number >> 24;

    HashFinal    = Hash;
    HashFinal   += Hash >> 4;

    //
    // insure power of two if not one.
    //

    return ( HashFinal & (KERB_USERLIST_COUNT-1) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\gssapip.h ===
/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef __GSSAPIP_H__
#define __GSSAPIP_H__

#include "gssapi.h"


/** helper macros **/

#define g_OID_equal(o1,o2) \
   (((o1)->length == (o2)->length) && \
    (memcmp((o1)->elements,(o2)->elements,(int) (o1)->length) == 0))

#define TWRITE_STR(ptr, str, len) \
   memcpy((ptr), (char *) (str), (len)); \
   (ptr) += (len);


/** helper functions **/

int
g_token_size(
    gss_OID      mech,
    unsigned int body_size
    );

void
g_make_token_header(
    gss_OID         mech,
    int             body_size,
    unsigned char **buf,
    int             tok_type
    );

int
g_verify_token_header(
    gss_OID         mech,
    int            *body_size,
    unsigned char **buf,
    int             tok_type,
    int             toksize
    );

int
der_read_length(
     unsigned char **buf,
     int *bufsize
     );

#endif /* __GSSAPIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbdbg.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbdbg.h
//
// Contents:    Debug information for Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERBDBG_H__
#define __KERBDBG_H__

//
//  NOTE:  DO not remove RETAIL_LOG_SUPPORT from sources,
//  or you'll be busted in DBG builds.
//

#ifdef RETAIL_LOG_SUPPORT

#ifndef WIN32_CHICAGO
DECLARE_DEBUG2(Kerb);
#undef DebugLog
#define DebugLog(_x_) KerbDebugPrint _x_
#endif // WIN32_CHICAGO

#define WSZ_KERBDEBUGLEVEL      L"KerbDebugLevel"
#define WSZ_FILELOG             L"LogToFile"

VOID
KerbWatchKerbParamKey(PVOID,BOOLEAN);

#define KerbPrintKdcName(Level,Name) KerbPrintKdcNameEx(KerbInfoLevel, (Level),(Name))

#define DEB_TRACE_API           0x00000008
#undef  DEB_TRACE_CRED
#define DEB_TRACE_CRED          0x00000010
#define DEB_TRACE_CTXT          0x00000020
#define DEB_TRACE_LSESS         0x00000040
#define DEB_TRACE_TCACHE        0x00000080
#define DEB_TRACE_LOGON         0x00000100
#define DEB_TRACE_KDC           0x00000200
#define DEB_TRACE_CTXT2         0x00000400
#define DEB_TRACE_TIME          0x00000800
#define DEB_TRACE_USER          0x00001000
#define DEB_TRACE_LEAKS         0x00002000
#define DEB_TRACE_SOCK          0x00004000
#define DEB_TRACE_SPN_CACHE     0x00008000
#define DEB_S4U_ERROR           0x00010000
#define DEB_TRACE_U2U           0x00200000
#define DEB_TRACE_LOOPBACK      0x00080000
#undef DEB_TRACE_LOCKS
#define DEB_TRACE_LOCKS         0x01000000
#define DEB_USE_LOG_FILE        0x02000000

//  For extended errors
#define DEB_USE_EXT_ERRORS      0x10000000

#define EXT_ERROR_ON(s)         (s & DEB_USE_EXT_ERRORS)


#ifndef WIN32_CHICAGO
VOID
KerbInitializeDebugging(
    VOID
    );
#endif // WIN32_CHICAGO


#else // RETAIL_LOG_SUPPORT

#define DebugLog(_x_)
#define KerbInitializeDebugging()
#define KerbPrintKdcName(_x_)
#define KerbWatchKerbParamKey()
#define EXT_ERROR_ON(s)                 FALSE

#endif // RETAIL_LOG_SUPPORT

#if DBG

#define D_DebugLog(_x_) DebugLog(_x_) // don't use all debug spew in retail builds
#define D_KerbPrintKdcName(l,n)  KerbPrintKdcName(l,n)
#else
#define D_KerbPrintKdcName(l,n)
#define D_DebugLog(_x_)
#endif

#endif // __KERBDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\gssapi.h ===
/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _GSSAPI_H_
#define _GSSAPI_H_

/*
 * Determine platform-dependent configuration.
 */

#define GSS_SIZEOF_INT 4
#define GSS_SIZEOF_LONG 4
#define GSS_SIZEOF_SHORT 2


#include <stddef.h>

/*
#include <sys/types.h>

/*
 * The following type must be defined as the smallest natural unsigned integer
 * supported by the platform that has at least 32 bits of precision.
 */
#if (GSS_SIZEOF_SHORT == 4)
typedef unsigned short gss_uint32;
#elif (GSS_SIZEOF_INT == 4)
typedef unsigned int gss_uint32;
#elif (GSS_SIZEOF_LONG == 4)
typedef unsigned long gss_uint32;
#endif

#ifdef  OM_STRING
/*
 * We have included the xom.h header file.  Use the definition for
 * OM_object identifier.
 */
typedef OM_object_identifier    gss_OID_desc, *gss_OID;
#else   /* OM_STRING */
/*
 * We can't use X/Open definitions, so roll our own.
 */
typedef gss_uint32      OM_uint32;

typedef struct gss_OID_desc_struct {
      OM_uint32 length;
      void      SEC_FAR *elements;
} gss_OID_desc, SEC_FAR *gss_OID;
#endif  /* OM_STRING */

#endif /* _GSSAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\ctxtmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtmgr.h
//
// Contents:    Structures and prototyps for Kerberos context list
//
//
// History:     17-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __CTXTMGR_H__
#define __CTXTMGR_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines CTXTMGR_ALLOCATE
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef CTXTMGR_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

#ifdef WIN32_CHICAGO
EXTERN CRITICAL_SECTION KerbContextResource;
#else // WIN32_CHICAGO
EXTERN RTL_RESOURCE KerbContextResource;
#endif // WIN32_CHICAGO

#define     KERB_USERLIST_COUNT         (16)    // count of lists

EXTERN KERBEROS_LIST KerbContextList[ KERB_USERLIST_COUNT ];
EXTERN BOOLEAN KerberosContextsInitialized;

#define KerbGetContextHandle(_Context_) ((LSA_SEC_HANDLE)(_Context_))

//
// Context flags - these are attributes of a context and are stored in
// the ContextAttributes field of a KERB_CONTEXT.
//

#define KERB_CONTEXT_MAPPED                     0x1
#define KERB_CONTEXT_OUTBOUND                   0x2
#define KERB_CONTEXT_INBOUND                    0x4
#define KERB_CONTEXT_USED_SUPPLIED_CREDS        0x8
#define KERB_CONTEXT_USER_TO_USER               0x10
#define KERB_CONTEXT_REQ_SERVER_NAME            0x20
#define KERB_CONTEXT_REQ_SERVER_REALM           0x40
#define KERB_CONTEXT_IMPORTED                   0x80
#define KERB_CONTEXT_EXPORTED                   0x100
#define KERB_CONTEXT_USING_CREDMAN              0x200

//
// NOTICE: The logon session resource, credential resource, and context
// resource must all be acquired carefully to prevent deadlock. They
// can only be acquired in this order:
//
// 1. Logon Sessions
// 2. Credentials
// 3. Contexts
//

#if DBG
#ifdef WIN32_CHICAGO
#define KerbWriteLockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Write locking Contexts\n")); \
    EnterCriticalSection(&KerbContextResource); \
    KerbGlobalContextsLocked = GetCurrentThreadId(); \
}
#define KerbReadLockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Read locking Contexts\n")); \
    EnterCriticalSection(&KerbContextResource); \
    KerbGlobalContextsLocked = GetCurrentThreadId(); \
}
#define KerbUnlockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Unlocking Contexts\n")); \
    KerbGlobalContextsLocked = 0; \
    LeaveCriticalSection(&KerbContextResource); \
}
#else // WIN32_CHICAGO
#define KerbWriteLockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Write locking Contexts\n")); \
    RtlAcquireResourceExclusive(&KerbContextResource,TRUE); \
    KerbGlobalContextsLocked = GetCurrentThreadId(); \
}
#define KerbReadLockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Read locking Contexts\n")); \
    RtlAcquireResourceShared(&KerbContextResource, TRUE); \
    KerbGlobalContextsLocked = GetCurrentThreadId(); \
}
#define KerbUnlockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Unlocking Contexts\n")); \
    KerbGlobalContextsLocked = 0; \
    RtlReleaseResource(&KerbContextResource); \
}
#endif // WIN32_CHICAGO
#else
#ifdef WIN32_CHICAGO
#define KerbWriteLockContexts() \
    EnterCriticalSection(&KerbContextResource)
#define KerbReadLockContexts() \
    EnterCriticalSection(&KerbContextResource)
#define KerbUnlockContexts() \
    LeaveCriticalSection(&KerbContextResource)
#else // WIN32_CHICAGO
#define KerbWriteLockContexts() \
    RtlAcquireResourceExclusive(&KerbContextResource,TRUE);
#define KerbReadLockContexts() \
    RtlAcquireResourceShared(&KerbContextResource, TRUE);
#define KerbUnlockContexts() \
    RtlReleaseResource(&KerbContextResource);
#endif // WIN32_CHICAGO
#endif

NTSTATUS
KerbInitContextList(
    VOID
    );

VOID
KerbFreeContextList(
    VOID
    );


NTSTATUS
KerbAllocateContext(
    PKERB_CONTEXT * NewContext
    );

NTSTATUS
KerbInsertContext(
    IN PKERB_CONTEXT Context
    );


SECURITY_STATUS
KerbReferenceContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CONTEXT * FoundContext
    );


VOID
KerbDereferenceContext(
    IN PKERB_CONTEXT Context
    );

VOID
KerbReferenceContextByPointer(
    IN PKERB_CONTEXT Context,
    IN BOOLEAN RemoveFromList
    );

NTSTATUS
KerbCreateClientContext(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ULONG Nonce,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    );

NTSTATUS
KerbCreateServerContext(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AP_REQUEST ApRequest,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PLUID LogonId,
    IN OUT PSID * UserSid,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN ULONG Nonce,
    IN ULONG ReceiveNonce,
    IN OUT PHANDLE TokenHandle,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientDomain,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    );

NTSTATUS
KerbUpdateServerContext(
    IN PKERB_CONTEXT Context,
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AP_REQUEST ApRequest,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PLUID LogonId,
    IN OUT PSID * UserSid,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN ULONG Nonce,
    IN ULONG ReceiveNonce,
    IN OUT PHANDLE TokenHandle,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientDomain,
    OUT PTimeStamp ContextLifetime
    );

NTSTATUS
KerbCreateEmptyContext(
    IN PKERB_CREDENTIAL Credential,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN PLUID LogonId,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    );

NTSTATUS
KerbMapContext(
    IN PKERB_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    );

NTSTATUS
KerbCreateUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_CONTEXT * NewContext
    );

SECURITY_STATUS
KerbReferenceContextByLsaHandle(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CONTEXT * FoundContext
    );

NTSTATUS
KerbUpdateClientContext(
    IN PKERB_CONTEXT Context,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN ULONG Nonce,
    IN ULONG ReceiveNonce,
    IN ULONG ContextFlags,
    IN ULONG ContextAttribs,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    OUT PTimeStamp ContextLifetime
    );

NTSTATUS
KerbCreateSKeyEntry(
    IN KERB_ENCRYPTION_KEY* pSessionKey,
    IN FILETIME* pExpireTime
    );

NTSTATUS
KerbDoesSKeyExist(
    IN KERB_ENCRYPTION_KEY* pKey,
    OUT BOOLEAN* pbExist
    );

NTSTATUS
KerbEqualKey(
    IN KERB_ENCRYPTION_KEY* pKeyFoo,
    IN KERB_ENCRYPTION_KEY* pKeyBar,
    OUT BOOLEAN* pbEqual
    );

NTSTATUS
KerbInsertSKey(
    IN KERB_SESSION_KEY_ENTRY* pSKeyEntry
    );

VOID
KerbTrimSKeyList(
    VOID
    );

VOID
KerbNetworkServiceSKeyListCleanupCallback(
    IN VOID* pContext,
    IN BOOLEAN bTimeOut
    );

NTSTATUS
KerbCreateSKeyTimer(
    VOID
    );

VOID
KerbFreeSKeyTimer(
    VOID
    );

VOID
KerbFreeSKeyEntry(
    IN KERB_SESSION_KEY_ENTRY* pSKeyEntry
    );

NTSTATUS
KerbProcessTargetNames(
    IN PUNICODE_STRING TargetName,
    IN OPTIONAL PUNICODE_STRING SuppTargetName,
    IN ULONG Flags,
    IN OUT ULONG *ProcessFlags,
    OUT PKERB_INTERNAL_NAME * FinalTarget,
    OUT PUNICODE_STRING TargetRealm,
    OUT OPTIONAL PKERB_SPN_CACHE_ENTRY * SpnCacheEntry
    );

#define KERB_CRACK_NAME_USE_WKSTA_REALM         0x1
#define KERB_CRACK_NAME_REALM_SUPPLIED          0x2

#endif // __CTXTMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbdefs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbdefs.h
//
// Contents:    defines for all internal Kerberos lists
//
//
// History:     03-May-1999     ChandanS          Created
//
//------------------------------------------------------------------------

#ifndef __KERBDEFS_H__
#define __KERBDEFS_H__

//
// All Kerberos list structures are defined here
//

typedef struct _KERBEROS_LIST {
    LIST_ENTRY List;
    RTL_CRITICAL_SECTION Lock;
} KERBEROS_LIST, *PKERBEROS_LIST;

typedef struct _KERBEROS_LIST_ENTRY {
    LIST_ENTRY Next;
    ULONG ReferenceCount;
} KERBEROS_LIST_ENTRY, *PKERBEROS_LIST_ENTRY;

typedef struct _KERB_TICKET_CACHE_ENTRY {
    KERBEROS_LIST_ENTRY ListEntry;
    volatile LONG Linked;
    PKERB_INTERNAL_NAME ServiceName;
    PKERB_INTERNAL_NAME TargetName;
    UNICODE_STRING DomainName;
    UNICODE_STRING TargetDomainName;
    UNICODE_STRING AltTargetDomainName;
    UNICODE_STRING ClientDomainName;
    PKERB_INTERNAL_NAME ClientName;
    ULONG TicketFlags;
    ULONG CacheFlags;
    KERB_ENCRYPTION_KEY SessionKey;
    TimeStamp KeyExpirationTime;
    TimeStamp StartTime;
    TimeStamp EndTime;
    TimeStamp RenewUntil;
    KERB_TICKET Ticket;
    TimeStamp TimeSkew;
} KERB_TICKET_CACHE_ENTRY, *PKERB_TICKET_CACHE_ENTRY;

typedef struct _KERB_TICKET_CACHE {
    LIST_ENTRY CacheEntries;
} KERB_TICKET_CACHE, *PKERB_TICKET_CACHE;


#define CSP_DATA_INITIALIZED                        0x01
#define CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS     0x02
#define CONTEXT_INITIALIZED_WITH_ACH                0x04

typedef struct _KERB_PUBLIC_KEY_CREDENTIALS {
    UNICODE_STRING Pin;
    LUID    LogonId; // logon id used in impersonation...                          
    PCCERT_CONTEXT CertContext;
    HCRYPTPROV hProv;
    ULONG InitializationInfo;
    ULONG CspDataLength;
    BYTE CspData[1];
} KERB_PUBLIC_KEY_CREDENTIALS, *PKERB_PUBLIC_KEY_CREDENTIALS;

typedef struct _KERB_PRIMARY_CREDENTIAL {
    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;
    UNICODE_STRING ClearPassword;           // this is only present until a ticket has been obtained.

    UNICODE_STRING OldUserName;             // original user name in explicit
    UNICODE_STRING OldDomainName;           // original domain name in explicit cred
    NT_OWF_PASSWORD OldHashPassword;        // hash of encrypted ClearPassword

    PKERB_STORED_CREDENTIAL Passwords;
    PKERB_STORED_CREDENTIAL OldPasswords;
    KERB_TICKET_CACHE ServerTicketCache;
    KERB_TICKET_CACHE S4UTicketCache;
    KERB_TICKET_CACHE AuthenticationTicketCache;
    PKERB_PUBLIC_KEY_CREDENTIALS PublicKeyCreds;
} KERB_PRIMARY_CREDENTIAL, *PKERB_PRIMARY_CREDENTIAL;

typedef struct _KERB_LOGON_SESSION {
    KERBEROS_LIST_ENTRY ListEntry;
    LIST_ENTRY SspCredentials;
    KERBEROS_LIST CredmanCredentials;
    LUID LogonId;                               // constant
    TimeStamp Lifetime;
    RTL_CRITICAL_SECTION Lock;
    KERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    ULONG LogonSessionFlags;
} KERB_LOGON_SESSION, *PKERB_LOGON_SESSION;


#define KERB_CREDENTIAL_TAG_ACTIVE (ULONG)'AdrC'
#define KERB_CREDENTIAL_TAG_DELETE (ULONG)'DdrC'

typedef struct _KERB_CREDENTIAL {
    KERBEROS_LIST_ENTRY ListEntry;
    ULONG HandleCount;
    LIST_ENTRY NextForThisLogonSession;
    LUID LogonId;                               // constant
    TimeStamp Lifetime;
    UNICODE_STRING CredentialName;
    ULONG CredentialFlags;
    ULONG ClientProcess;                        // constant
    PKERB_PRIMARY_CREDENTIAL SuppliedCredentials;
    PKERB_AUTHORIZATION_DATA AuthData;
    ULONG CredentialTag;
} KERB_CREDENTIAL, *PKERB_CREDENTIAL;

typedef struct _KERB_CREDMAN_CRED {
    KERBEROS_LIST_ENTRY ListEntry;
    ULONG CredentialFlags;
    UNICODE_STRING CredmanUserName;  // added since TGT information can overwrite primary credentials...
    UNICODE_STRING CredmanDomainName;
    PKERB_PRIMARY_CREDENTIAL SuppliedCredentials;
} KERB_CREDMAN_CRED, *PKERB_CREDMAN_CRED;


typedef enum _KERB_CONTEXT_STATE {
    IdleState,
    TgtRequestSentState,
    TgtReplySentState,
    ApRequestSentState,
    ApReplySentState,
    AuthenticatedState,
    ErrorMessageSentState,
    InvalidState
} KERB_CONTEXT_STATE, *PKERB_CONTEXT_STATE;


#define KERB_CONTEXT_TAG_ACTIVE (ULONG)'AxtC'
#define KERB_CONTEXT_TAG_DELETE (ULONG)'DxtC'

typedef struct _KERB_CONTEXT {
    KERBEROS_LIST_ENTRY ListEntry;
    TimeStamp Lifetime;             // end time/expiration time
    TimeStamp RenewTime;            // time to renew until
    TimeStamp StartTime;
    UNICODE_STRING ClientName;
    UNICODE_STRING ClientRealm;
    union {
        ULONG ClientProcess;
        LSA_SEC_HANDLE LsaContextHandle;
    };
    LUID LogonId;
    HANDLE TokenHandle;
    ULONG_PTR CredentialHandle;
    KERB_ENCRYPTION_KEY SessionKey;
    ULONG Nonce;
    ULONG ReceiveNonce;
    ULONG ContextFlags;
    ULONG ContextAttributes;
    ULONG EncryptionType;
    PSID UserSid;
    KERB_CONTEXT_STATE ContextState;
    ULONG Retries;
    KERB_ENCRYPTION_KEY TicketKey;
    PKERB_TICKET_CACHE_ENTRY TicketCacheEntry;  // for clients, is ticket to server, for servers, is TGT used in user-to-user
    UNICODE_STRING ClientPrincipalName;
    UNICODE_STRING ServerPrincipalName;
    PKERB_CREDMAN_CRED CredManCredentials;

    //
    // marshalled target info for DFS/RDR.
    //

    PBYTE pbMarshalledTargetInfo;
    ULONG cbMarshalledTargetInfo;

    ULONG ContextTag;
} KERB_CONTEXT, *PKERB_CONTEXT;

typedef struct _KERB_PACKED_CONTEXT {
    ULONG   ContextType ;               // Indicates the type of the context
    ULONG   Pad;                        // Pad data
    TimeStamp Lifetime;                 // Matches basic context above
    TimeStamp RenewTime ;
    TimeStamp StartTime;
    UNICODE_STRING32 ClientName ;
    UNICODE_STRING32 ClientRealm ;
    ULONG LsaContextHandle ;
    LUID LogonId ;
    ULONG TokenHandle ;
    ULONG CredentialHandle ;
    ULONG SessionKeyType ;
    ULONG SessionKeyOffset ;
    ULONG SessionKeyLength ;
    ULONG Nonce ;
    ULONG ReceiveNonce ;
    ULONG ContextFlags ;
    ULONG ContextAttributes ;
    ULONG EncryptionType ;
    KERB_CONTEXT_STATE ContextState ;
    ULONG Retries ;
    ULONG MarshalledTargetInfo; // offset
    ULONG MarshalledTargetInfoLength;
} KERB_PACKED_CONTEXT, * PKERB_PACKED_CONTEXT ;

typedef struct _KERB_SESSION_KEY_ENTRY {
    LIST_ENTRY ListEntry;
    KERB_ENCRYPTION_KEY SessionKey;
    FILETIME ExpireTime;                   // time when SessionKey expires
} KERB_SESSION_KEY_ENTRY, * PKERB_SESSION_KEY_ENTRY;

#define KERB_PACKED_CONTEXT_MAP     0
#define KERB_PACKED_CONTEXT_EXPORT  1

#endif // __KERBDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\gssutil.cxx ===
/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include <kerb.hxx>
#include <kerbp.h>
#include "gssapiP.h"
// #include <memory.h>

#define VALID_INT_BITS    0x7fffffff


/* XXXX this code currently makes the assumption that a mech oid will
   never be longer than 127 bytes.  This assumption is not inherent in
   the interfaces, so the code can be fixed if the OSI namespace
   balloons unexpectedly. */

/* Each token looks like this:

0x60                            tag for APPLICATION 0, SEQUENCE
                                        (constructed, definite-length)
        <length>                possible multiple bytes, need to parse/generate
        0x06                    tag for OBJECT IDENTIFIER
                <moid_length>   compile-time constant string (assume 1 byte)
                <moid_bytes>    compile-time constant string
        <inner_bytes>           the ANY containing the application token
                                        bytes 0,1 are the token type
                                        bytes 2,n are the token data

For the purposes of this abstraction, the token "header" consists of
the sequence tag and length octets, the mech OID DER encoding, and the
first two inner bytes, which indicate the token type.  The token
"body" consists of everything else.

*/

int
der_length_size(
    int length
    )
{
   if (length < (1<<7))
      return(1);
   else if (length < (1<<8))
      return(2);
   else if (length < (1<<16))
      return(3);
   else if (length < (1<<24))
      return(4);
   else
      return(5);

}

void
der_write_length(
     unsigned char **buf,
     int length
     )
{
   if (length < (1<<7)) {
      *(*buf)++ = (unsigned char) length;
   } else {
      *(*buf)++ = (unsigned char) (der_length_size(length)+127);

      if (length >= (1<<24))
         *(*buf)++ = (unsigned char) (length>>24);
      if (length >= (1<<16))
         *(*buf)++ = (unsigned char) ((length>>16)&0xff);
      if (length >= (1<<8))
         *(*buf)++ = (unsigned char) ((length>>8)&0xff);
      *(*buf)++ = (unsigned char) (length&0xff);
   }
}

/* returns decoded length, or < 0 on failure.  Advances buf and
   decrements bufsize */

int
der_read_length(
     unsigned char **buf,
     int *bufsize
     )
{
   unsigned char sf;
   int ret;

   if (*bufsize < 1)
      return(-1);
   sf = *(*buf)++;
   (*bufsize)--;
   if (sf & 0x80) {
      if ((sf &= 0x7f) > ((*bufsize)-1))
         return(-1);
      if (sf > sizeof(int))
          return (-1);
      ret = 0;
      for (; sf; sf--) {
         ret = (ret<<8) + (*(*buf)++);
         (*bufsize)--;
      }
   } else {
      ret = sf;
   }

   return(ret);
}

/* returns the length of a token, given the mech oid and the body size */

int
g_token_size(
     gss_OID mech,
     unsigned int body_size
     )
{
   /* set body_size to sequence contents size */
   body_size += 4 + (int) mech->length;         /* NEED overflow check */
   return(1 + der_length_size(body_size) + body_size);
}

/* fills in a buffer with the token header.  The buffer is assumed to
   be the right size.  buf is advanced past the token header */

void
g_make_token_header(
     gss_OID mech,
     int body_size,
     unsigned char **buf,
     int tok_type
     )
{
   *(*buf)++ = 0x60;
   der_write_length(buf, 4 + mech->length + body_size);
   *(*buf)++ = 0x06;
   *(*buf)++ = (unsigned char) mech->length;
   TWRITE_STR(*buf, mech->elements, ((int) mech->length));
   *(*buf)++ = (unsigned char) ((tok_type>>8)&0xff);
   *(*buf)++ = (unsigned char) (tok_type&0xff);
}

/* given a buffer containing a token, reads and verifies the token,
   leaving buf advanced past the token header, and setting body_size
   to the number of remaining bytes */

int
g_verify_token_header(
     gss_OID mech,
     int *body_size,
     unsigned char **buf,
     int tok_type,
     int toksize
     )
{
   int seqsize;
   gss_OID_desc toid;

   if ((toksize-=1) < 0)
      return(0);
   if (*(*buf)++ != 0x60)
      return(0);

   if ((seqsize = der_read_length(buf, &toksize)) < 0)
      return(0);

   if (seqsize != toksize)
      return(0);

   if ((toksize-=1) < 0)
      return(0);
   if (*(*buf)++ != 0x06)
      return(0);

   if ((toksize-=1) < 0)
      return(0);
   toid.length = *(*buf)++;

   if ((toid.length & VALID_INT_BITS) != toid.length) /* Overflow??? */
      return(0);
   if ((toksize-= (int) toid.length) < 0)
      return(0);
   toid.elements = *buf;
   (*buf)+=toid.length;

   if (! g_OID_equal(&toid, mech))
      return(0);

   if ((toksize-=2) < 0)
      return(0);

   if ((*(*buf)++ != ((tok_type>>8)&0xff)) ||
       (*(*buf)++ != (tok_type&0xff)))
      return(0);

   *body_size = toksize;

   return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbfunc.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        kerbfunc.h
//
// Contents:    prototypes for Kerberos export functions
//
//
// History:     21-Jan-94   MikeSw      Created
//
//------------------------------------------------------------------------

#ifndef __KERBFUNC_H__
#define __KERBFUNC_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
SpInitializeFn                  SpInitialize;
SpGetInfoFn                     SpGetInfo;


LSA_AP_LOGON_USER_EX2           LsaApLogonUserEx2;

SpAcceptCredentialsFn           SpAcceptCredentials;
SpAcquireCredentialsHandleFn    SpAcquireCredentialsHandle;
SpAcquireCredentialsHandleFn    SpAcquireCredentialsHandle2;
SpFreeCredentialsHandleFn       SpFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes;
SpSaveCredentialsFn             SpSaveCredentials;
SpGetCredentialsFn              SpGetCredentials;
SpDeleteCredentialsFn           SpDeleteCredentials;

SpInitLsaModeContextFn          SpInitLsaModeContext;
SpDeleteContextFn               SpDeleteContext;
SpAcceptLsaModeContextFn        SpAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         LsaApLogonTerminated;
SpApplyControlTokenFn           SpApplyControlToken;
LSA_AP_CALL_PACKAGE             LsaApCallPackage;
LSA_AP_CALL_PACKAGE             LsaApCallPackageUntrusted;
LSA_AP_CALL_PACKAGE_PASSTHROUGH LsaApCallPackagePassthrough;
SpShutdownFn                    SpShutdown;
SpGetUserInfoFn                 SpGetUserInfo;
SpQueryContextAttributesFn      SpQueryLsaModeContextAttributes;

SpInstanceInitFn                SpInstanceInit;
SpInitUserModeContextFn         SpInitUserModeContext;
SpMakeSignatureFn               SpMakeSignature;
SpVerifySignatureFn             SpVerifySignature;
SpSealMessageFn                 SpSealMessage;
SpUnsealMessageFn               SpUnsealMessage;
SpGetContextTokenFn             SpGetContextToken;
SpQueryContextAttributesFn      SpQueryContextAttributes;
SpDeleteContextFn               SpDeleteUserModeContext;
SpCompleteAuthTokenFn           SpCompleteAuthToken;
SpFormatCredentialsFn           SpFormatCredentials;
SpMarshallSupplementalCredsFn   SpMarshallSupplementalCreds;
SpExportSecurityContextFn       SpExportSecurityContext;
SpImportSecurityContextFn       SpImportSecurityContext;
SpGetExtendedInformationFn      SpGetExtendedInformation;


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __KERBFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerblist.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerblist.cxx
//
// Contents:    Common list code for the Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//              03-May-1999   ChandanS
//                            Changes from code review
//
//------------------------------------------------------------------------


#include <kerb.hxx>
#include <kerbp.h>

#if DBG
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeList
//
//  Synopsis:   Initializes a kerberos list by initializing the lock
//              and the list entry.
//
//  Effects:
//
//  Arguments:  List - List to initialize
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success or errors from
//              RtlInitializeResources
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializeList(
    IN PKERBEROS_LIST List
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    InitializeListHead(&List->List);

    Status = RtlInitializeCriticalSection(
                &List->Lock
                );

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeList
//
//  Synopsis:   Frees a kerberos list by deleting the associated
//              critical section.
//
//  Effects:    List - the list to free.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    none
//
//  Notes:      The list must be empty before freeing it.
//
//
//--------------------------------------------------------------------------



VOID
KerbFreeList(
    IN PKERBEROS_LIST List
    )
{
    //
    // Make sure the list is empty first
    //

//    if (IsListEmpty(&List->List))
//    {
//        RtlDeleteCriticalSection(&List->Lock);
//    }
//    else
//    {
//        DsysAssert(FALSE);
//    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeListEntry
//
//  Synopsis:   Initializes a newly created list entry for later
//              insertion onto the list.
//
//  Effects:    The reference count is set to one and the links are set
//              to NULL.
//
//  Arguments:  ListEntry - the list entry to initialize
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbInitializeListEntry(
    IN OUT PKERBEROS_LIST_ENTRY ListEntry
    )
{
    ListEntry->ReferenceCount = 1;
    ListEntry->Next.Flink = ListEntry->Next.Blink = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertListEntry
//
//  Synopsis:   Inserts an entry into a kerberos list
//
//  Effects:    increments the reference count on the entry - if the
//              list entry was formly referenced it remains referenced.
//
//  Arguments:  ListEntry - the entry to insert
//              List - the list in which to insert the ListEntry
//
//  Requires:
//
//  Returns:    nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbInsertListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    )
{
    ListEntry->ReferenceCount++;

    RtlEnterCriticalSection(&List->Lock);

    KerbValidateList(List);

    InsertHeadList(
        &List->List,
        &ListEntry->Next
        );

    KerbValidateList(List);


    RtlLeaveCriticalSection(&List->Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertListEntryTail
//
//  Synopsis:   Inserts an entry into a kerberos list at the end
//
//  Effects:    increments the reference count on the entry - if the
//              list entry was formly referenced it remains referenced.
//
//  Arguments:  ListEntry - the entry to insert
//              List - the list in which to insert the ListEntry
//
//  Requires:
//
//  Returns:    nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbInsertListEntryTail(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    )
{
    ListEntry->ReferenceCount++;

    RtlEnterCriticalSection(&List->Lock);

    KerbValidateList(List);

    InsertTailList(
        &List->List,
        &ListEntry->Next
        );

    KerbValidateList(List);


    RtlLeaveCriticalSection(&List->Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceListEntry
//
//  Synopsis:   References a list entry. If the flag RemoveFromList
//              has been specified, the entry is unlinked from the
//              list.
//
//  Effects:    bumps the reference count on the entry (unless it is
//              being removed from the list)
//
//  Arguments:
//
//  Requires:   The list must be locked when calling this routine
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReferenceListEntry(
    IN PKERBEROS_LIST List,
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    )
{
    KerbValidateList(List);


    //
    // If it has already been removed from the list
    // don't do it again.
    //

    if (RemoveFromList && ((ListEntry->Next.Flink != NULL) &&
                           (ListEntry->Next.Blink != NULL)))
    {
        RemoveEntryList(&ListEntry->Next);
        ListEntry->Next.Flink = NULL;
        ListEntry->Next.Blink = NULL;
    }
    else if ((ListEntry->Next.Flink !=NULL) && (ListEntry->Next.Blink != NULL))
    {
        RemoveEntryList( &ListEntry->Next );
        InsertHeadList(
            &List->List,
            &ListEntry->Next
            );

        ListEntry->ReferenceCount++;
    }
    else
    {
        //
        // This is valid since several callers may have gotten a valid list
        // entry and may want to delete it indepenently for whatever reason.
        //

        ListEntry->ReferenceCount++;
    }

    KerbValidateList(List);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceListEntry
//
//  Synopsis:   Dereferences a list entry and returns a flag indicating
//              whether the entry should be freed.
//
//  Effects:    decrements reference count on list entry
//
//  Arguments:  ListEntry - the list entry to dereference
//              List - the list containing the list entry
//
//  Requires:
//
//  Returns:    TRUE - the list entry should be freed
//              FALSE - the list entry is still referenced
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
KerbDereferenceListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    )
{
    BOOLEAN DeleteEntry = FALSE;

    RtlEnterCriticalSection(&List->Lock);
    KerbValidateList(List);

    ListEntry->ReferenceCount -= 1;
    if (ListEntry->ReferenceCount == 0)
    {
        DeleteEntry = TRUE;
    }

    KerbValidateList(List);

    RtlLeaveCriticalSection(&List->Lock);
    return(DeleteEntry);
}


#if DBG
//+-------------------------------------------------------------------------
//
//  Function:   KerbValidateListEx
//
//  Synopsis:   Validates that a list is valid
//
//  Effects:    traverses a list to make sure it is has no loops
//
//  Arguments:  List - The list to validate
//
//  Requires:
//
//  Returns:    none
//
//  Notes:      This routine assumes there are less than 50000 entries
//              in the list.
//
//
//--------------------------------------------------------------------------

VOID
KerbValidateListEx(
    IN PKERBEROS_LIST List
    )
{
    ULONG Entries = 0;
    PLIST_ENTRY ListEntry;

    for (ListEntry = List->List.Flink ;
         ListEntry != &List->List ;
         ListEntry = ListEntry->Flink )
    {
        if (++Entries > 50000) {
            DebugLog((DEB_ERROR,"List 0x%x is looping - more than 50,000 entries found. %ws, line %d\n", List, THIS_FILE, __LINE__));
            DbgBreakPoint();
            break;
        }
    }

}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerblist.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerblist.h
//
// Contents:    structure and protypes needed for generic Kerberos lists
//
//
// History:     16-Apr-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBLIST_H__
#define __KERBLIST_H__


//
// Generic list entry structure allowing common code for inserting
// logon sessions, credentials, and contexts.
//

NTSTATUS
KerbInitializeList(
    IN PKERBEROS_LIST List
    );

VOID
KerbFreeList(
    IN PKERBEROS_LIST List
    );

VOID
KerbInsertListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    );

VOID
KerbInsertListEntryTail(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    );

VOID
KerbReferenceListEntry(
    IN PKERBEROS_LIST List,
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    );

BOOLEAN
KerbDereferenceListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    );


VOID
KerbInitializeListEntry(
    IN OUT PKERBEROS_LIST_ENTRY ListEntry
    );

VOID
KerbValidateListEx(
    IN PKERBEROS_LIST List
    );

#if DBG
#define KerbValidateList(_List_) KerbValidateListEx(_List_)
#else
#define KerbValidateList(_List_)
#endif // DBG


#define KerbLockList(_List_) RtlEnterCriticalSection(&(_List_)->Lock)
#define KerbUnlockList(_List_) RtlLeaveCriticalSection(&(_List_)->Lock)

#endif // __KERBLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerberos.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerberos.cxx
//
// Contents:    main entrypoints for the Kerberos security package
//
//
// History:     16-April-1996 Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------


#include <kerb.hxx>
#define KERBP_ALLOCATE
#include <kerbp.h>
#include <userapi.h>
#include <safeboot.h>
#include <spncache.h>
#include <wow64t.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
HANDLE g_hParamEvent = NULL;
HKEY   g_hKeyParams = NULL;
#endif

#ifndef WIN32_CHICAGO
#ifdef RETAIL_LOG_SUPPORT

DEFINE_DEBUG2(Kerb);
extern DWORD KSuppInfoLevel; // needed to adjust values for common2 dir
HANDLE g_hWait = NULL;

DEBUG_KEY   KerbDebugKeys[] = { {DEB_ERROR,         "Error"},
                                {DEB_WARN,          "Warn"},
                                {DEB_TRACE,         "Trace"},
                                {DEB_TRACE_API,     "API"},
                                {DEB_TRACE_CRED,    "Cred"},
                                {DEB_TRACE_CTXT,    "Ctxt"},
                                {DEB_TRACE_LSESS,   "LSess"},
                                {DEB_TRACE_LOGON,   "Logon"},
                                {DEB_TRACE_KDC,     "KDC"},
                                {DEB_TRACE_CTXT2,   "Ctxt2"},
                                {DEB_TRACE_TIME,    "Time"},
                                {DEB_TRACE_LOCKS,   "Locks"},
                                {DEB_TRACE_LEAKS,   "Leaks"},
                                {DEB_TRACE_SPN_CACHE, "SPN"},
                                {DEB_TRACE_LOOPBACK,  "LoopBack"},
                                {DEB_TRACE_U2U,       "U2U"},
                                {0,                  NULL},
                              };


VOID
KerbInitializeDebugging(
    VOID
    )
{
    KerbInitDebug(KerbDebugKeys);

}

////////////////////////////////////////////////////////////////////
//
//  Name:       KerbGetKerbRegParams
//
//  Synopsis:   Gets the debug paramaters from the registry
//
//  Arguments:  HKEY to HKLM/System/CCS/LSA/Kerberos
//
//  Notes:      Sets KerbInfolevel for debug spew
//
void
KerbGetKerbRegParams(HKEY ParamKey)
{

    DWORD       cbType, tmpInfoLevel = KerbInfoLevel, cbSize;
    DWORD       dwErr;

    cbSize = sizeof(tmpInfoLevel);

    dwErr = RegQueryValueExW(
        ParamKey,
        WSZ_KERBDEBUGLEVEL,
        NULL,
        &cbType,
        (LPBYTE)&tmpInfoLevel,
        &cbSize
        );
    if (dwErr != ERROR_SUCCESS)
    {
        if (dwErr ==  ERROR_FILE_NOT_FOUND)
        {
            // no registry value is present, don't want info
            // so reset to defaults
#if DBG
            KSuppInfoLevel = KerbInfoLevel = DEB_ERROR;

#else // fre
            KSuppInfoLevel = KerbInfoLevel = 0;
#endif
        }else{
            D_DebugLog((DEB_WARN, "Failed to query DebugLevel: 0x%x\n", dwErr));
        }

    }

    // TBD:  Validate flags?
    KSuppInfoLevel = KerbInfoLevel = tmpInfoLevel;

    cbSize = sizeof(tmpInfoLevel);

    dwErr = RegQueryValueExW(
               ParamKey,
               WSZ_FILELOG,
               NULL,
               &cbType,
               (LPBYTE)&tmpInfoLevel,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
       KerbSetLoggingOption((BOOL) tmpInfoLevel);
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
       KerbSetLoggingOption(FALSE);
    }

    cbSize = sizeof(tmpInfoLevel);

    dwErr = RegQueryValueExW(
               ParamKey,
               KERB_PARAMETER_RETRY_PDC,
               NULL,
               &cbType,
               (LPBYTE)&tmpInfoLevel,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
        if( tmpInfoLevel != 0 )
        {
            KerbGlobalRetryPdc = TRUE;
        } else {
            KerbGlobalRetryPdc = FALSE;
        }

    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
       KerbGlobalRetryPdc = FALSE;
    }


    return;
}

////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWaitCleanup
//
//  Synopsis:   Cleans up wait from KerbWatchParamKey()
//
//  Arguments:  <none>
//
//  Notes:      .
//
void
KerbWaitCleanup()
{

    NTSTATUS Status = STATUS_SUCCESS;

    if (NULL != g_hWait) {
        Status = RtlDeregisterWait(g_hWait);
        if (NT_SUCCESS(Status) && NULL != g_hParamEvent ) {
            CloseHandle(g_hParamEvent);
        }
    }
}



////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
KerbWatchKerbParamKey(PVOID    pCtxt,
                  BOOLEAN  fWaitStatus)
{
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;

    if (NULL == g_hKeyParams)  // first time we've been called.
    {
        lRes = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    KERB_PARAMETER_PATH,
                    0,
                    KEY_READ,
                    &g_hKeyParams);

        if (ERROR_SUCCESS != lRes)
        {
            D_DebugLog((DEB_WARN,"Failed to open kerberos key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != g_hWait)
    {
        Status = RtlDeregisterWait(g_hWait);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }

    }

    lRes = RegNotifyChangeKeyValue(
                g_hKeyParams,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                (HANDLE) pCtxt,
                TRUE);

    if (ERROR_SUCCESS != lRes)
    {
        D_DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }

    KerbGetKerbRegParams(g_hKeyParams);

Reregister:

    Status = RtlRegisterWait(&g_hWait,
                             (HANDLE) pCtxt,
                             KerbWatchKerbParamKey,
                             (HANDLE) pCtxt,
                             INFINITE,
                             WT_EXECUTEINPERSISTENTIOTHREAD|
                             WT_EXECUTEONLYONCE);

}

#endif // RETAIL_LOG_SUPPORT

NTSTATUS NTAPI
SpCleanup(
    VOID
    );


BOOL
DllMain(
    HINSTANCE Module,
    ULONG Reason,
    PVOID Context
    )
{
    if ( Reason == DLL_PROCESS_ATTACH )
    {
        DisableThreadLibraryCalls( Module );
    }
    else if ( Reason == DLL_PROCESS_DETACH )
    {
#if RETAIL_LOG_SUPPORT
        KerbUnloadDebug();
        KerbWaitCleanup();
#endif
    }

    return TRUE ;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpLsaModeInitialize
//
//  Synopsis:   This function is called by the LSA when this DLL is loaded.
//              It returns security package function tables for all
//              security packages in the DLL.
//
//  Effects:
//
//  Arguments:  LsaVersion - Version number of the LSA
//              PackageVersion - Returns version number of the package
//              Tables - Returns array of function tables for the package
//              TableCount - Returns number of entries in array of
//                      function tables.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Tables,
    OUT PULONG TableCount
    )
{
    KerbInitializeDebugging();

#ifdef RETAIL_LOG_SUPPORT

    g_hParamEvent = CreateEvent(NULL,
                           FALSE,
                           FALSE,
                           NULL);

    if (NULL == g_hParamEvent)
    {
        D_DebugLog((DEB_WARN, "CreateEvent for ParamEvent failed - 0x%x\n", GetLastError()));
    } else {
        KerbWatchKerbParamKey(g_hParamEvent, FALSE);
    }

#endif // RETAIL_LOG_SUPPORT

    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        D_DebugLog((DEB_ERROR,"Invalid LSA version: %d. %ws, line %d\n",LsaVersion, THIS_FILE, __LINE__));
        return(STATUS_INVALID_PARAMETER);
    }

    KerberosFunctionTable.InitializePackage = NULL;;
    KerberosFunctionTable.LogonUser = NULL;
    KerberosFunctionTable.CallPackage = LsaApCallPackage;
    KerberosFunctionTable.LogonTerminated = LsaApLogonTerminated;
    KerberosFunctionTable.CallPackageUntrusted = LsaApCallPackageUntrusted;
    KerberosFunctionTable.LogonUserEx2 = LsaApLogonUserEx2;
    KerberosFunctionTable.Initialize = SpInitialize;
    KerberosFunctionTable.Shutdown = SpShutdown;
    KerberosFunctionTable.GetInfo = SpGetInfo;
    KerberosFunctionTable.AcceptCredentials = SpAcceptCredentials;
    KerberosFunctionTable.AcquireCredentialsHandle = SpAcquireCredentialsHandle;
    KerberosFunctionTable.FreeCredentialsHandle = SpFreeCredentialsHandle;
    KerberosFunctionTable.QueryCredentialsAttributes = SpQueryCredentialsAttributes;
    KerberosFunctionTable.SaveCredentials = SpSaveCredentials;
    KerberosFunctionTable.GetCredentials = SpGetCredentials;
    KerberosFunctionTable.DeleteCredentials = SpDeleteCredentials;
    KerberosFunctionTable.InitLsaModeContext = SpInitLsaModeContext;
    KerberosFunctionTable.AcceptLsaModeContext = SpAcceptLsaModeContext;
    KerberosFunctionTable.DeleteContext = SpDeleteContext;
    KerberosFunctionTable.ApplyControlToken = SpApplyControlToken;
    KerberosFunctionTable.GetUserInfo = SpGetUserInfo;
    KerberosFunctionTable.GetExtendedInformation = SpGetExtendedInformation;
    KerberosFunctionTable.QueryContextAttributes = SpQueryLsaModeContextAttributes;
    KerberosFunctionTable.CallPackagePassthrough = LsaApCallPackagePassthrough;


    *PackageVersion = SECPKG_INTERFACE_VERSION;

    *TableCount = 1;
    *Tables = &KerberosFunctionTable;

    // initialize event tracing (a/k/a WMI tracing, software tracing)
    KerbInitializeTrace();

    return(STATUS_SUCCESS);
}
#endif // WIN32_CHICAGO



//+-------------------------------------------------------------------------
//
//  Function:   SpInitialize
//
//  Synopsis:   Initializes the Kerberos package
//
//  Effects:
//
//  Arguments:  PackageId - Contains ID for this package assigned by LSA
//              Parameters - Contains machine-specific information
//              FunctionTable - Contains table of LSA helper routines
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpInitialize(
    IN ULONG_PTR PackageId,
    IN PSECPKG_PARAMETERS Parameters,
    IN PLSA_SECPKG_FUNCTION_TABLE FunctionTable
    )
{
    NTSTATUS Status;
    UNICODE_STRING TempUnicodeString;
#ifndef WIN32_CHICAGO
    WCHAR SafeBootEnvVar[sizeof(SAFEBOOT_MINIMAL_STR_W) + sizeof(WCHAR)];
#endif // WIN32_CHICAGO
    UNICODE_STRING DnsString = {0};;
#ifdef WIN32_CHICAGO
    PKERB_LOGON_SESSION LogonSession = NULL;
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
    RtlInitializeResource(&KerberosGlobalResource);
#endif // WIN32_CHICAGO
    KerberosPackageId = PackageId;
    LsaFunctions = FunctionTable;


#ifndef WIN32_CHICAGO
    KerberosState = KerberosLsaMode;
#else // WIN32_CHICAGO
    KerberosState = KerberosUserMode;
#endif // WIN32_CHICAGO


    RtlInitUnicodeString(
        &KerbPackageName,
        MICROSOFT_KERBEROS_NAME_W
        );

#ifndef WIN32_CHICAGO
    // Check is we are in safe boot.

    //
    // Does environment variable exist
    //

    RtlZeroMemory( SafeBootEnvVar, sizeof( SafeBootEnvVar ) );

    KerbGlobalSafeModeBootOptionPresent = FALSE;

    if ( GetEnvironmentVariable(L"SAFEBOOT_OPTION", SafeBootEnvVar, sizeof(SafeBootEnvVar)/sizeof(SafeBootEnvVar[0]) ) )
    {
        if ( !wcscmp( SafeBootEnvVar, SAFEBOOT_MINIMAL_STR_W ) )
        {
            KerbGlobalSafeModeBootOptionPresent = TRUE;
        }
    }
#endif // WIN32_CHICAGO


    Status = KerbInitializeEvents();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Init data for the kdc calling routine
    //

#ifndef WIN32_CHICAGO
    Status = KerbInitKdcData();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // init global LSA policy handle.
    //

    Status = LsaIOpenPolicyTrusted(
                &KerbGlobalPolicyHandle
                );

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

#endif // WIN32_CHICAGO

    //
    // Get information about encryption
    //

    if ((Parameters->MachineState & SECPKG_STATE_ENCRYPTION_PERMITTED) != 0)
    {
        KerbGlobalEncryptionPermitted = TRUE;
    }
    if ((Parameters->MachineState & SECPKG_STATE_STRONG_ENCRYPTION_PERMITTED) != 0)
    {
        KerbGlobalStrongEncryptionPermitted = TRUE;
    }

    //
    // Get our global role
    //

    if ((Parameters->MachineState & SECPKG_STATE_DOMAIN_CONTROLLER) != 0)
    {
        //
        // We will behave like a member workstation/server until the DS
        // says we are ready to act as a DC
        //

        KerbGlobalRole = KerbRoleWorkstation;
    }
    else if ((Parameters->MachineState & SECPKG_STATE_WORKSTATION) != 0)
    {
        KerbGlobalRole = KerbRoleWorkstation;
    }
    else
    {
        KerbGlobalRole = KerbRoleStandalone;
    }

    //
    // Fill in various useful constants
    //

    KerbSetTime(&KerbGlobalWillNeverTime, MAXTIMEQUADPART);
    KerbSetTime(&KerbGlobalHasNeverTime, 0);

    //
    // compute blank password hashes.
    //

    Status = RtlCalculateLmOwfPassword( "", &KerbGlobalNullLmOwfPassword );
    ASSERT( NT_SUCCESS(Status) );

    RtlInitUnicodeString(&TempUnicodeString, NULL);
    Status = RtlCalculateNtOwfPassword(&TempUnicodeString,
                                       &KerbGlobalNullNtOwfPassword);
    ASSERT( NT_SUCCESS(Status) );

    RtlInitUnicodeString(
        &KerbGlobalKdcServiceName,
        KDC_PRINCIPAL_NAME
        );

    //
    // At some point we may want to read the registry here to
    // find out whether we need to enforce times, currently times
    // are always enforced.
    //

    KerbGlobalEnforceTime = FALSE;

    //
    // Get the machine Name
    //


    Status = KerbSetComputerName();

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog((DEB_ERROR,"KerbSetComputerName failed\n"));
        goto Cleanup;
    }

    //
    // Initialize the logon session list. This has to be done because
    // KerbSetDomainName will try to acess the logon session list
    //

    Status = KerbInitLogonSessionList();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize logon session list: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    Status = KerbInitNetworkServiceLoopbackDetection();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to initialize network service loopback detection: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    Status = KerbCreateSKeyTimer();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to initialize network service session key list timer: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    Status = KerbInitTicketHandling();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize ticket handling: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    Status = KerbInitializeLogonSidCache();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize sid cache: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }
#endif


    //
    // Update all global structures referencing the domain name
    //

    Status = KerbSetDomainName(
                &Parameters->DomainName,
                &Parameters->DnsDomainName,
                Parameters->DomainSid,
                Parameters->DomainGuid
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Initialize the internal Kerberos lists
    //


    Status = KerbInitCredentialList();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize credential list: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    Status = KerbInitContextList();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize context list: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }
    Status = KerbInitTicketCaching();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize ticket cache: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;

    }

    Status = KerbInitBindingCache();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize binding cache: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    Status = KerbInitSpnCache();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize SPN cache: 0x%x. %ws, line %d\n",
                  Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    Status = KerbInitializeMitRealmList();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize MIT realm list: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    Status = KerbInitializePkinit();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize PKINT: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }
#endif // WIN32_CHICAGO

    Status = KerbInitializeSockets(
                MAKEWORD(1,1),          // we want version 1.1
                1,                      // we need at least 1 socket
                &KerbGlobalNoTcpUdp
                );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize sockets: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    Status = KerbRegisterForDomainChange();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to register for domain change notification: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Check to see if there is a CSP registered for replacing the StringToKey calculation
    //
    CheckForOutsideStringToKey();

    //
    // Register to update the machine sid cache
    //

    KerbWaitGetMachineSid();

    //
    // See if there are any "join hints" to process
    //
    ReadInitialDcRecord(
       &KerbGlobalInitialDcRecord,
       &KerbGlobalInitialDcAddressType,
       &KerbGlobalInitialDcFlags
       );


#endif // WIN32_CHICAGO

    KerbGlobalSocketsInitialized = TRUE;
    KerbGlobalInitialized = TRUE;

Cleanup:
    KerbFreeString(
        &DnsString
        );
    //
    // If we failed to initialize, shutdown
    //

    if (!NT_SUCCESS(Status))
    {
        SpCleanup();
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpCleanup
//
//  Synopsis:   Function to shutdown the Kerberos package.
//
//  Effects:    Forces the freeing of all credentials, contexts and
//              logon sessions and frees all global data
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:      STATUS_SUCCESS in all cases
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpCleanup(
    VOID
    )
{
    KerbGlobalInitialized = FALSE;
#ifndef WIN32_CHICAGO
    KerbUnregisterForDomainChange();
#endif // WIN32_CHICAGO
    KerbFreeLogonSessionList();
    KerbFreeContextList();
    KerbFreeTicketCache();
    // KerbFreeCredentialList();

    KerbFreeNetworkServiceSKeyListAndLock();
    KerbFreeSKeyTimer();

    KerbFreeString(&KerbGlobalDomainName);
    KerbFreeString(&KerbGlobalDnsDomainName);
    KerbFreeString(&KerbGlobalMachineName);
    KerbFreeString((PUNICODE_STRING) &KerbGlobalKerbMachineName);
    KerbFreeString(&KerbGlobalMachineServiceName);
    KerbFreeKdcName(&KerbGlobalInternalMachineServiceName);
    KerbFreeKdcName(&KerbGlobalMitMachineServiceName);

    KerbCleanupTicketHandling();
#ifndef WIN32_CHICAGO
    if( KerbGlobalPolicyHandle != NULL )
    {
        LsarClose( &KerbGlobalPolicyHandle );
        KerbGlobalPolicyHandle = NULL;
    }

    if (KerbGlobalDomainSid != NULL)
    {
        KerbFree(KerbGlobalDomainSid);
    }
#endif // WIN32_CHICAGO

    if (KerbGlobalSocketsInitialized)
    {
        KerbCleanupSockets();
    }
    KerbCleanupBindingCache(FALSE);
    KerbUninitializeMitRealmList();
#ifndef WIN32_CHICAGO
    KerbFreeKdcData();
//    RtlDeleteResource(&KerberosGlobalResource);
#endif // WIN32_CHICGAO

    KerbShutdownEvents();
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   SpShutdown
//
//  Synopsis:   Exported function to shutdown the Kerberos package.
//
//  Effects:    Forces the freeing of all credentials, contexts and
//              logon sessions and frees all global data
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:      STATUS_SUCCESS in all cases
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpShutdown(
    VOID
    )
{
#if 0
    SpCleanup();
#endif
    return(STATUS_SUCCESS);
}


#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   SpGetInfo
//
//  Synopsis:   Returns information about the package
//
//  Effects:    returns pointers to global data
//
//  Arguments:  PackageInfo - Receives kerberos package information
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS in all cases
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpGetInfo(
    OUT PSecPkgInfo PackageInfo
    )
{
    PackageInfo->wVersion = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    PackageInfo->wRPCID = RPC_C_AUTHN_GSS_KERBEROS;
    PackageInfo->fCapabilities = KERBEROS_CAPABILITIES;
    PackageInfo->cbMaxToken       = KerbGlobalMaxTokenSize;
    PackageInfo->Name             = KERBEROS_PACKAGE_NAME;
    PackageInfo->Comment          = KERBEROS_PACKAGE_COMMENT;
    return(STATUS_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpGetExtendedInformation
//
//  Synopsis:   returns additional information about the package
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
SpGetExtendedInformation(
    IN  SECPKG_EXTENDED_INFORMATION_CLASS Class,
    OUT PSECPKG_EXTENDED_INFORMATION * ppInformation
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSECPKG_EXTENDED_INFORMATION Information = NULL ;
    PSECPKG_SERIALIZED_OID SerializedOid;
    ULONG Size ;

    switch(Class) {
    case SecpkgGssInfo:
        DsysAssert(gss_mech_krb5_new->length >= 2);
        DsysAssert(gss_mech_krb5_new->length < 127);

        //
        // We need to leave space for the oid and the BER header, which is
        // 0x6 and then the length of the oid.
        //

        Information = (PSECPKG_EXTENDED_INFORMATION)
                            KerbAllocate(sizeof(SECPKG_EXTENDED_INFORMATION) +
                            gss_mech_krb5_new->length - 2);
        if (Information == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Information->Class = SecpkgGssInfo;
        Information->Info.GssInfo.EncodedIdLength = gss_mech_krb5_new->length + 2;
        Information->Info.GssInfo.EncodedId[0] = 0x6;   // BER OID type
        Information->Info.GssInfo.EncodedId[1] = (UCHAR) gss_mech_krb5_new->length;
        RtlCopyMemory(
            &Information->Info.GssInfo.EncodedId[2],
            gss_mech_krb5_new->elements,
            gss_mech_krb5_new->length
            );

            *ppInformation = Information;
            Information = NULL;
        break;
    case SecpkgContextThunks:
        //
        // Note - we don't need to add any space for the thunks as there
        // is only one, and the structure has space for one. If any more
        // thunks are added, we will need to add space for those.
        //

        Information = (PSECPKG_EXTENDED_INFORMATION)
                            KerbAllocate(sizeof(SECPKG_EXTENDED_INFORMATION));
        if (Information == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Information->Class = SecpkgContextThunks;
        Information->Info.ContextThunks.InfoLevelCount = 1;
        Information->Info.ContextThunks.Levels[0] = SECPKG_ATTR_NATIVE_NAMES;
        *ppInformation = Information;
        Information = NULL;
        break;

    case SecpkgWowClientDll:

        //
        // This indicates that we're smart enough to handle wow client processes
        //

        Information = (PSECPKG_EXTENDED_INFORMATION)
                            KerbAllocate( sizeof( SECPKG_EXTENDED_INFORMATION ) +
                                          (MAX_PATH * sizeof(WCHAR) ) );

        if ( Information == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES ;
            goto Cleanup ;
        }

        Information->Class = SecpkgWowClientDll ;
        Information->Info.WowClientDll.WowClientDllPath.Buffer = (PWSTR) (Information + 1);
        Size = ExpandEnvironmentStrings(
                    L"%SystemRoot%\\" WOW64_SYSTEM_DIRECTORY_U L"\\Kerberos.DLL",
                    Information->Info.WowClientDll.WowClientDllPath.Buffer,
                    MAX_PATH );
        Information->Info.WowClientDll.WowClientDllPath.Length = (USHORT) (Size * sizeof(WCHAR));
        Information->Info.WowClientDll.WowClientDllPath.MaximumLength = (USHORT) ((Size + 1) * sizeof(WCHAR) );
        *ppInformation = Information ;
        Information = NULL ;

        break;

    case SecpkgExtraOids:
        Size = sizeof( SECPKG_EXTENDED_INFORMATION ) +
                2 * sizeof( SECPKG_SERIALIZED_OID ) ;

        Information = (PSECPKG_EXTENDED_INFORMATION)
                            KerbAllocate( Size );


        if ( Information == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES ;
            goto Cleanup ;
        }
        Information->Class = SecpkgExtraOids ;
        Information->Info.ExtraOids.OidCount = 2 ;

        SerializedOid = Information->Info.ExtraOids.Oids;

        SerializedOid->OidLength = gss_mech_krb5_spnego->length + 2;
        SerializedOid->OidAttributes = SECPKG_CRED_BOTH ;
        SerializedOid->OidValue[ 0 ] = 0x06 ; // BER OID type
        SerializedOid->OidValue[ 1 ] = (UCHAR) gss_mech_krb5_spnego->length;
        RtlCopyMemory(
            &SerializedOid->OidValue[2],
            gss_mech_krb5_spnego->elements,
            gss_mech_krb5_spnego->length
            );

        SerializedOid++ ;

        SerializedOid->OidLength = gss_mech_krb5_u2u->length + 2;
        SerializedOid->OidAttributes = SECPKG_CRED_INBOUND ;
        SerializedOid->OidValue[ 0 ] = 0x06 ; // BER OID type
        SerializedOid->OidValue[ 1 ] = (UCHAR) gss_mech_krb5_u2u->length;
        RtlCopyMemory(
            &SerializedOid->OidValue[2],
            gss_mech_krb5_u2u->elements,
            gss_mech_krb5_u2u->length
            );

        *ppInformation = Information ;
        Information = NULL ;
        break;

    default:
        return(STATUS_INVALID_INFO_CLASS);
    }
Cleanup:
    if (Information != NULL)
    {
        KerbFree(Information);
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   LsaApInitializePackage
//
//  Synopsis:   Obsolete pacakge initialize function, supported for
//              compatibility only. This function has no effect.
//
//  Effects:    none
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsaApInitializePackage(
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PLSA_STRING Database OPTIONAL,
    IN PLSA_STRING Confidentiality OPTIONAL,
    OUT PLSA_STRING *AuthenticationPackageName
    )
{
    return(STATUS_SUCCESS);
}

BOOLEAN
KerbIsInitialized(
    VOID
    )
{
    return KerbGlobalInitialized;
}

NTSTATUS
KerbKdcCallBack(
    VOID
    )
{
    PKERB_BINDING_CACHE_ENTRY CacheEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    KerbGlobalWriteLock();

    KerbGlobalRole = KerbRoleDomainController;

    Status = KerbLoadKdc();


    //
    // Purge the binding cache of entries for this domain
    //

    CacheEntry = KerbLocateBindingCacheEntry(
                    &KerbGlobalDnsDomainName,
                    0,
                    TRUE
                    );
    if (CacheEntry != NULL)
    {
        KerbDereferenceBindingCacheEntry(CacheEntry);
    }
    CacheEntry = KerbLocateBindingCacheEntry(
                    &KerbGlobalDomainName,
                    0,
                    TRUE
                    );
    if (CacheEntry != NULL)
    {
        KerbDereferenceBindingCacheEntry(CacheEntry);
    }

    //
    // PurgeSpnCache, because we may now have "better" state,
    // e.g. right after DCPromo our SPNs may not have replicated.
    //
    KerbCleanupSpnCache();


    KerbGlobalReleaseLock();

    return Status;
}

#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbp.h
//
// Contents:    global include file for Kerberos security package
//
//
// History:     16-April-1996       Created     MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERBP_H__
#define __KERBP_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines KERBP_ALLOCATE
//

typedef enum _KERBEROS_MACHINE_ROLE {
    KerbRoleRealmlessWksta,
    KerbRoleStandalone,
    KerbRoleWorkstation,
    KerbRoleDomainController
} KERBEROS_MACHINE_ROLE, *PKERBEROS_MACHINE_ROLE;


typedef enum _KERBEROS_STATE {
    KerberosLsaMode = 1,
    KerberosUserMode
} KERBEROS_STATE, *PKERBEROS_STATE;

#define ISC_REQ_DELEGATE_IF_SAFE ISC_REQ_RESERVED1
#define ISC_RET_DELEGATE_IF_SAFE ISC_RET_RESERVED1

#include "kerbdbg.h"
#include "kerbdefs.h"
#include "kerblist.h"
#include "spncache.h"
#include "kerbs4u.h"
#include "bndcache.h"
#include "kerbtick.h"
#include "kerbutil.h"
#include "kerblist.h"
#include "tktcache.h"
#include "logonses.h"
#include "credmgr.h"
#include "ctxtmgr.h"
#include "kerbfunc.h"
#include "logonapi.h"
#include "krbtoken.h"
#include "rpcutil.h"
#include "timesync.h"
#include "sidcache.h"
#ifndef WIN32_CHICAGO
#include "pkauth.h"
#include "tktlogon.h"
#include "userlist.h"
#endif // WIN32_CHICAGO
#include "mitutil.h"
#include "krbevent.h"
#include "credman.h"

#ifdef WIN32_CHICAGO
#include <kerbstub.h>
#include <debug.h>
#endif // WIN32_CHICAGO

#ifdef _WIN64
#include "kerbwow.h"
#endif // _WIN64

//
// Macros for package information
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef KERBP_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif // KERBP_ALLOCATE

//

#define KERBEROS_CAPABILITIES ( SECPKG_FLAG_INTEGRITY | \
                                SECPKG_FLAG_PRIVACY | \
                                SECPKG_FLAG_TOKEN_ONLY | \
                                SECPKG_FLAG_DATAGRAM | \
                                SECPKG_FLAG_CONNECTION | \
                                SECPKG_FLAG_MULTI_REQUIRED | \
                                SECPKG_FLAG_EXTENDED_ERROR | \
                                SECPKG_FLAG_IMPERSONATION | \
                                SECPKG_FLAG_ACCEPT_WIN32_NAME | \
                                SECPKG_FLAG_NEGOTIABLE | \
                                SECPKG_FLAG_GSS_COMPATIBLE | \
                                SECPKG_FLAG_LOGON | \
                                SECPKG_FLAG_MUTUAL_AUTH | \
                                SECPKG_FLAG_DELEGATION )

#define KERBEROS_MAX_TOKEN 12000
#ifdef WIN32_CHICAGO
#define KERBEROS_PACKAGE_NAME "Kerberos"
#define KERBEROS_PACKAGE_COMMENT "Microsoft Kerberos V1.0"
#else
#define KERBEROS_PACKAGE_NAME L"Kerberos"
#define KERBEROS_PACKAGE_COMMENT L"Microsoft Kerberos V1.0"
#endif

#define NETLOGON_STARTED_EVENT L"\\NETLOGON_SERVICE_STARTED"

//
// Global state variables
//

EXTERN PLSA_SECPKG_FUNCTION_TABLE LsaFunctions;
EXTERN PSECPKG_DLL_FUNCTIONS UserFunctions;

EXTERN SECPKG_FUNCTION_TABLE KerberosFunctionTable;
EXTERN SECPKG_USER_FUNCTION_TABLE KerberosUserFunctionTable;

EXTERN ULONG_PTR KerberosPackageId;
EXTERN BOOLEAN KerbGlobalInitialized;
EXTERN BOOLEAN KerbGlobalSocketsInitialized;
EXTERN UNICODE_STRING KerbGlobalMachineName;
EXTERN STRING KerbGlobalKerbMachineName;
EXTERN UNICODE_STRING KerbGlobalKdcServiceName;
EXTERN UNICODE_STRING KerbPackageName;
EXTERN BOOLEAN KerbKdcStarted;
EXTERN BOOLEAN KerbAfdStarted;
EXTERN BOOLEAN KerbNetlogonStarted;
EXTERN BOOLEAN KerbGlobalDomainIsPreNT5;
EXTERN HMODULE KerbKdcHandle;
EXTERN PKDC_VERIFY_PAC_ROUTINE KerbKdcVerifyPac;
EXTERN PKDC_GET_TICKET_ROUTINE KerbKdcGetTicket;
EXTERN PKDC_GET_TICKET_ROUTINE KerbKdcChangePassword;
EXTERN PKDC_FREE_MEMORY_ROUTINE KerbKdcFreeMemory;
EXTERN BOOLEAN KerbGlobalEncryptionPermitted;
EXTERN BOOLEAN KerbGlobalStrongEncryptionPermitted;
EXTERN BOOLEAN KerbGlobalEnforceTime;
EXTERN BOOLEAN KerbGlobalMachineNameChanged;
#ifndef WIN32_CHICAGO
EXTERN BOOLEAN KerbGlobalSafeModeBootOptionPresent;
#endif // WIN32_CHICAGO

//
// Registry driven globals (see Kerberos\readme.txt for details on these)
//

EXTERN ULONG KerbGlobalKdcWaitTime;
EXTERN ULONG KerbGlobalKdcCallTimeout;
EXTERN ULONG KerbGlobalKdcCallBackoff;
EXTERN ULONG KerbGlobalKdcSendRetries;
EXTERN ULONG KerbGlobalMaxDatagramSize;
EXTERN ULONG KerbGlobalDefaultPreauthEtype;
EXTERN ULONG KerbGlobalMaxReferralCount;
EXTERN ULONG KerbGlobalMaxTokenSize;
EXTERN ULONG KerbGlobalKdcOptions;
EXTERN BOOLEAN KerbGlobalUseSidCache;
EXTERN BOOLEAN KerbGlobalUseStrongEncryptionForDatagram;
EXTERN BOOLEAN KerbGlobalRetryPdc;
EXTERN TimeStamp KerbGlobalFarKdcTimeout;
EXTERN TimeStamp KerbGlobalNearKdcTimeout;
EXTERN TimeStamp KerbGlobalSkewTime;
EXTERN TimeStamp KerbGlobalSpnCacheTimeout;
EXTERN BOOLEAN KerbGlobalUseClientIpAddresses;
EXTERN DWORD KerbGlobalTgtRenewalInterval;


#ifndef WIN32_CHICAGO
EXTERN ULONG KerbGlobalLoggingLevel;
#endif // WIN32_CHICAGO

//
// Globals used for handling domain change or that are affected by domain
// change
//

#ifndef WIN32_CHICAGO
#define KerbGlobalReadLock() RtlAcquireResourceShared(&KerberosGlobalResource, TRUE)
#define KerbGlobalWriteLock() RtlAcquireResourceExclusive(&KerberosGlobalResource, TRUE)
#define KerbGlobalReleaseLock() RtlReleaseResource(&KerberosGlobalResource)
EXTERN RTL_RESOURCE KerberosGlobalResource;
EXTERN PSID KerbGlobalDomainSid;
#else // WIN32_CHICAGO
#define KerbGlobalReadLock()
#define KerbGlobalWriteLock()
#define KerbGlobalReleaseLock()

#endif // WIN32_CHICAGO

EXTERN UNICODE_STRING KerbGlobalDomainName;
EXTERN UNICODE_STRING KerbGlobalDnsDomainName;
EXTERN PKERB_INTERNAL_NAME KerbGlobalInternalMachineServiceName;
EXTERN PKERB_INTERNAL_NAME KerbGlobalMitMachineServiceName;
EXTERN UNICODE_STRING KerbGlobalMachineServiceName;
EXTERN KERBEROS_MACHINE_ROLE KerbGlobalRole;
EXTERN UNICODE_STRING KerbGlobalInitialDcRecord;
EXTERN ULONG KerbGlobalInitialDcFlags;
EXTERN ULONG KerbGlobalInitialDcAddressType;
EXTERN PSOCKADDR_IN KerbGlobalIpAddresses;    // also protected by same lock
EXTERN BOOLEAN KerbGlobalNoTcpUdp;            // also protected by same lock
EXTERN ULONG KerbGlobalIpAddressCount;        // also protected by same lock
EXTERN BOOLEAN KerbGlobalIpAddressesInitialized;        // also protected by same lock

//
#ifdef WIN32_CHICAGO
// The capabilities of the security package
//

EXTERN ULONG KerbGlobalCapabilities;
#endif // WIN32_CHICAGO

#if DBG
EXTERN ULONG KerbGlobalLogonSessionsLocked;
EXTERN ULONG KerbGlobalCredentialsLocked;
EXTERN ULONG KerbGlobalContextsLocked;
#endif
//
// Useful globals
//

EXTERN TimeStamp KerbGlobalWillNeverTime;
EXTERN TimeStamp KerbGlobalHasNeverTime;


EXTERN KERBEROS_STATE KerberosState;

//
// handle to LSA policy -- trusted.
//

EXTERN LSAPR_HANDLE KerbGlobalPolicyHandle;

//
// SAM and Domain handles for validation interface.
//

EXTERN SAMPR_HANDLE KerbGlobalSamHandle;
EXTERN SAMPR_HANDLE KerbGlobalDomainHandle;

//
// Null copies of Lanman and NT OWF password.
//

EXTERN LM_OWF_PASSWORD KerbGlobalNullLmOwfPassword;
EXTERN NT_OWF_PASSWORD KerbGlobalNullNtOwfPassword;


//
// Useful macros
//

//
// Macro to return the type field of a SecBuffer
//

#define BUFFERTYPE(_x_) ((_x_).BufferType & ~SECBUFFER_ATTRMASK)

//
// Time to wait for the KDC to start, in seconds
//


#endif // __KERBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbpass.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbpass.cxx
//
// Contents:    Code for changing the Kerberos password on a KDC
//
//
// History:     17-October-1998         MikeSw  Created
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <kerbpass.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[] = TEXT(__FILE__);
#endif

#define FILENO FILENO_KERBPASS


#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateLogonSessionPasswords
//
//  Synopsis:   If the caller of this API is changing the password
//              of its own account, update the passwords.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbUpdateLogonSessionPasswords(
    IN PKERB_LOGON_SESSION TempLogonSession,
    IN PUNICODE_STRING NewPassword
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PKERB_LOGON_SESSION LogonSession = NULL;
    BOOLEAN LockHeld = FALSE;

    //
    // Get the logon session for the caller so we can compare the name of
    // the account of the changed password to the name of the account of the
    // caller.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    LogonSession = KerbReferenceLogonSession(
                        &ClientInfo.LogonId,
                        FALSE                   // don't remove
                        );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Now compare the names
    //

    KerbWriteLockLogonSessions(
        LogonSession
        );
    KerbReadLockLogonSessions(
        TempLogonSession
        );
    LockHeld = TRUE;

    if (RtlEqualUnicodeString(
            &LogonSession->PrimaryCredentials.UserName,
            &TempLogonSession->PrimaryCredentials.UserName,
            TRUE) &&                    // case insensitive
        RtlEqualUnicodeString(
            &LogonSession->PrimaryCredentials.DomainName,
            &TempLogonSession->PrimaryCredentials.DomainName,
            TRUE))                      // case insensitive
    {
        KerbWriteLockLogonSessions(LogonSession);

        Status = KerbChangeCredentialsPassword(
                    &LogonSession->PrimaryCredentials,
                    NewPassword,
                    NULL,               // no etype info
                    UserAccount,
                    PRIMARY_CRED_CLEAR_PASSWORD
                    );

        KerbUnlockLogonSessions(LogonSession);

        if (NT_SUCCESS(Status))
        {
            SECPKG_PRIMARY_CRED PrimaryCredentials = {0};

            PrimaryCredentials.LogonId = ClientInfo.LogonId;
            PrimaryCredentials.Password = *NewPassword;
            PrimaryCredentials.Flags = PRIMARY_CRED_UPDATE | PRIMARY_CRED_CLEAR_PASSWORD;

            //
            // Update all the other packages
            //

            KerbUnlockLogonSessions(TempLogonSession);
            KerbUnlockLogonSessions(LogonSession);
            LockHeld = FALSE;

            (VOID) LsaFunctions->UpdateCredentials(
                        &PrimaryCredentials,
                        NULL        // no supplemental credentials
                        );
        }
    }
Cleanup:
    if (LockHeld)
    {
        KerbUnlockLogonSessions(TempLogonSession);
        KerbUnlockLogonSessions(LogonSession);
    }

    return(Status);
}

#endif // WIN32_CHICAGO



#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbGetKpasswdTicket
//
//  Synopsis:   Gets a ticket for the kpasswd/changepw service in the
//              realm of the logon session.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetKpasswdTicket(
    IN PKERB_LOGON_SESSION LogonSession,
    OUT PKERB_TICKET_CACHE_ENTRY * KpasswdTicket,
    OUT PUNICODE_STRING ClientRealm,
    OUT PKERB_INTERNAL_NAME * ClientName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_INTERNAL_NAME KpasswdName = NULL;
    UNICODE_STRING CorrectRealm = {0};
    ULONG RetryCount = KERB_CLIENT_REFERRAL_MAX;
    BOOLEAN MitLogon;

    RtlInitUnicodeString(
        ClientRealm,
        NULL
        );

    //
    // Build the service name for the ticket
    //

    Status = KerbBuildKpasswdName(
                &KpasswdName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // We don't know exactly what realm to change the password on. If the
    // client presesnted a UPN, we may need to chase that down first.
    // This is similar code to KerbGetTicketGrantingTicket.
    //

    //
    // We start off assuming that the domain name is the domain name
    // supplied by the client.
    //

    KerbReadLockLogonSessions( LogonSession );
    Status = KerbGetClientNameAndRealm(
                &LogonSession->LogonId,
                &LogonSession->PrimaryCredentials,
                FALSE,
                NULL,
                &MitLogon,
                FALSE,                                  // default to wksta realm for UPN
                ClientName,
                ClientRealm
                );

            

    KerbUnlockLogonSessions( LogonSession );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

GetTicketRestart:

    //
    // Try to get the ticket now.
    //

    Status = KerbGetAuthenticationTicket(
                LogonSession,
                NULL,                   // credential
                NULL,
                KpasswdName,
                ClientRealm,
                *ClientName,
                KERB_GET_AUTH_TICKET_NO_CANONICALIZE,  // no name canonicalization
                0,                      // no cache flags
                KpasswdTicket,
                NULL,                   // no credential key,
                &CorrectRealm
                );

    //
    // If it failed but gave us another realm to try, go there
    //

    if (!NT_SUCCESS(Status) && (CorrectRealm.Length != 0))
    {
        if (--RetryCount != 0)
        {
            KerbFreeString(ClientRealm);
            *ClientRealm = CorrectRealm;
            CorrectRealm.Buffer = NULL;

            goto GetTicketRestart;
        }
    }
Cleanup:
    KerbFreeKdcName( &KpasswdName );
    KerbFreeString(&CorrectRealm);

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKerbPriv
//
//  Synopsis:   Builds a kerb-priv message with none of the optional
//              fields.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbBuildKerbPriv(
    IN PBYTE Data,
    IN ULONG DataSize,
    IN PKERB_ENCRYPTION_KEY Key,
    IN OPTIONAL PULONG Nonce,
    OUT PKERB_MESSAGE_BUFFER PrivMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_PRIV_MESSAGE Priv = {0};
    KERB_ENCRYPTED_PRIV PrivBody = {0};
    KERB_MESSAGE_BUFFER PackedBody = {0};
    PKERB_HOST_ADDRESSES Addresses = NULL;
    PKERB_HOST_ADDRESSES OurAddress = NULL;

    Status = KerbBuildHostAddresses(
                TRUE,
                TRUE,
                &Addresses
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Look for the first IP address in the list
    //

    OurAddress = Addresses;
    while (OurAddress != NULL)
    {
        if (OurAddress->value.address_type == KERB_ADDRTYPE_INET)
        {
            break;
        }
        OurAddress = OurAddress->next;
    }

    if (OurAddress == NULL)
    {
        DebugLog((DEB_ERROR,"No IP addresses. %ws, line %d\n",THIS_FILE, __LINE__));
        Status = STATUS_NO_IP_ADDRESSES;
        goto Cleanup;
    }

    //
    // Get the client address
    //

    PrivBody.user_data.length = (int) DataSize;
    PrivBody.user_data.value = Data;

    PrivBody.sender_address.addr_type = OurAddress->value.address_type;
    PrivBody.sender_address.address.length = OurAddress->value.address.length;
    PrivBody.sender_address.address.value = OurAddress->value.address.value;

    if (ARGUMENT_PRESENT(Nonce))
    {
        PrivBody.KERB_ENCRYPTED_PRIV_sequence_number = (int) *Nonce;
        PrivBody.bit_mask |= KERB_ENCRYPTED_PRIV_sequence_number_present;
    }

    //
    // Now pack the priv_body
    //

    KerbErr = KerbPackData(
                &PrivBody,
                KERB_ENCRYPTED_PRIV_PDU,
                &PackedBody.BufferSize,
                &PackedBody.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Now encrypt the body
    //

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                Key->keytype,
                PackedBody.BufferSize,
                &Priv.encrypted_part.cipher_text.length,
                &Priv.encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbEncryptDataEx(
                &Priv.encrypted_part,
                PackedBody.BufferSize,
                PackedBody.Buffer,
                Key->keytype,
                KERB_PRIV_SALT,
                Key
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Finally, pack the outer priv message.
    //

    Priv.version = KERBEROS_VERSION;
    Priv.message_type = KRB_PRIV;

    KerbErr = KerbPackData(
                &Priv,
                KERB_PRIV_MESSAGE_PDU,
                &PrivMessage->BufferSize,
                &PrivMessage->Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

Cleanup:
    KerbFreeHostAddresses(Addresses);
    if (Priv.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Priv.encrypted_part.cipher_text.value);
    }
    if (PackedBody.Buffer != NULL)
    {
        MIDL_user_free(PackedBody.Buffer);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKpasswdRequest
//
//  Synopsis:   Builds a kpasswd request - build the AP REQ, KERB_PRIV,
//              and then combines them in the request.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbBuildKpasswdRequest(
    IN PKERB_TICKET_CACHE_ENTRY KpasswdTicket,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING NewPassword,
    OUT PKERB_MESSAGE_BUFFER RequestMessage,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PULONG Nonce
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_MESSAGE_BUFFER ApRequest = {0};
    KERB_MESSAGE_BUFFER PrivMessage = {0};
    PKERB_KPASSWD_REQ KpasswdRequest;
    KERBERR KerbErr = KDC_ERR_NONE;
    STRING AnsiPassword = {0};

    RtlZeroMemory(
        SessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );

    *Nonce = KerbAllocateNonce();

    //
    // Make a sub-session key for the AP request and for encrypting
    // the KERB_PRIV message.
    //

    KerbErr = KerbMakeKey(
                KpasswdTicket->SessionKey.keytype,
                SessionKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Build the AP request first
    //

    KerbReadLockTicketCache();

    KerbErr = KerbCreateApRequest(
                KpasswdTicket->ClientName,
                &KpasswdTicket->ClientDomainName,
                &KpasswdTicket->SessionKey,
                SessionKey,
                *Nonce,
                &KpasswdTicket->Ticket,
                0,                      // no ap options
                NULL,                   // no checksum
                &KpasswdTicket->TimeSkew,
                FALSE,                  // not a KDC request
                &ApRequest.BufferSize,
                &ApRequest.Buffer
                );

    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to create AP request for kpasswd: 0x%x, %ws line %d\n",
            KerbErr, THIS_FILE, __LINE__ ));

        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // convert the password to UTF-8
    //

    KerbErr = KerbUnicodeStringToKerbString(
                &AnsiPassword,
                NewPassword
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Build the kerb_priv message
    //

    Status = KerbBuildKerbPriv(
                (PUCHAR) AnsiPassword.Buffer,
                AnsiPassword.Length,
                SessionKey,
                Nonce,
                &PrivMessage
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to build Kerb-priv: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now build the request itself.
    //

    RequestMessage->BufferSize = PrivMessage.BufferSize + ApRequest.BufferSize +
                        FIELD_OFFSET(KERB_KPASSWD_REQ,Data);
    RequestMessage->Buffer = (PBYTE) MIDL_user_allocate(RequestMessage->BufferSize);
    if (RequestMessage->Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KpasswdRequest = (PKERB_KPASSWD_REQ) RequestMessage->Buffer;
    SET_SHORT(KpasswdRequest->MessageLength, (USHORT) RequestMessage->BufferSize);
    SET_SHORT(KpasswdRequest->Version, KERB_KPASSWD_VERSION);
    SET_SHORT(KpasswdRequest->ApReqLength, (USHORT) ApRequest.BufferSize);

    RtlCopyMemory(
        KpasswdRequest->Data,
        ApRequest.Buffer,
        ApRequest.BufferSize
        );
    RtlCopyMemory(
        (PBYTE) KpasswdRequest->Data + ApRequest.BufferSize,
        PrivMessage.Buffer,
        PrivMessage.BufferSize
        );

Cleanup:
    if (PrivMessage.Buffer != NULL)
    {
        MIDL_user_free(PrivMessage.Buffer);
    }
    if (ApRequest.Buffer != NULL)
    {
        MIDL_user_free(ApRequest.Buffer);
    }
    RtlEraseUnicodeString((PUNICODE_STRING) &AnsiPassword);
    KerbFreeString((PUNICODE_STRING) &AnsiPassword);

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildSetPasswordRequest
//
//  Synopsis:   Builds a kpasswd request to set a password - build the
//              AP REQ, KERB_PRIV,
//              and then combines them in the request.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbBuildSetPasswordRequest(
    IN PKERB_TICKET_CACHE_ENTRY KpasswdTicket,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING NewPassword,
    OUT PKERB_MESSAGE_BUFFER RequestMessage,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PULONG Nonce
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_MESSAGE_BUFFER ApRequest = {0};
    KERB_MESSAGE_BUFFER PrivMessage = {0};
    KERB_MESSAGE_BUFFER EncodedData = {0};
    PKERB_KPASSWD_REQ KpasswdRequest;
    KERBERR KerbErr = KDC_ERR_NONE;
    STRING AnsiPassword = {0};
    KERB_CHANGE_PASSWORD_DATA ChangeData = {0};

    RtlZeroMemory(
        SessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );

    *Nonce = KerbAllocateNonce();


    //
    // Build the encoded data
    //
    //
    // convert the password to UTF-8
    //

    KerbErr = KerbUnicodeStringToKerbString(
                &AnsiPassword,
                NewPassword
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    ChangeData.new_password.value = (PUCHAR) AnsiPassword.Buffer;
    ChangeData.new_password.length = AnsiPassword.Length;

    //
    // Convert the names
    //

    KerbErr = KerbConvertUnicodeStringToRealm(
                &ChangeData.target_realm,
                ClientRealm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &ChangeData.target_name,
                ClientName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    ChangeData.bit_mask = target_name_present | target_realm_present;

    //
    // Asn.1 encode the data for sending
    //

    KerbErr = KerbPackData(
                &ChangeData,
                KERB_CHANGE_PASSWORD_DATA_PDU,
                &EncodedData.BufferSize,
                &EncodedData.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to pack kerb change password data: 0x%xx, file %ws, line %d\n",
            KerbErr,
            THIS_FILE,
            __LINE__
            ));

        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Make a sub-session key for the AP request and for encrypting
    // the KERB_PRIV message.
    //

    KerbErr = KerbMakeKey(
                KpasswdTicket->SessionKey.keytype,
                SessionKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    //
    // Build the AP request first
    //

    KerbReadLockTicketCache();

    KerbErr = KerbCreateApRequest(
                KpasswdTicket->ClientName,
                &KpasswdTicket->ClientDomainName,
                &KpasswdTicket->SessionKey,
                SessionKey,
                *Nonce,
                &KpasswdTicket->Ticket,
                0,                      // no ap options
                NULL,                   // no checksum
                &KpasswdTicket->TimeSkew,
                FALSE,                  // not a KDC request
                &ApRequest.BufferSize,
                &ApRequest.Buffer
                );

    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to create AP request for kpasswd: 0x%x, %ws line %d\n",
            KerbErr, THIS_FILE, __LINE__ ));

        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    //
    // Build the kerb_priv message
    //

    Status = KerbBuildKerbPriv(
                EncodedData.Buffer,
                EncodedData.BufferSize,
                SessionKey,
                Nonce,
                &PrivMessage
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to build Kerb-priv: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now build the request itself.
    //

    RequestMessage->BufferSize = PrivMessage.BufferSize + ApRequest.BufferSize +
                        FIELD_OFFSET(KERB_KPASSWD_REQ,Data);
    RequestMessage->Buffer = (PBYTE) MIDL_user_allocate(RequestMessage->BufferSize);
    if (RequestMessage->Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KpasswdRequest = (PKERB_KPASSWD_REQ) RequestMessage->Buffer;
    SET_SHORT(KpasswdRequest->MessageLength, (USHORT) RequestMessage->BufferSize);

    //
    // Use the special version for setting passwords
    //

    SET_SHORT(KpasswdRequest->Version, KERB_KPASSWD_SET_VERSION);
    SET_SHORT(KpasswdRequest->ApReqLength, (USHORT) ApRequest.BufferSize);

    RtlCopyMemory(
        KpasswdRequest->Data,
        ApRequest.Buffer,
        ApRequest.BufferSize
        );
    RtlCopyMemory(
        (PBYTE) KpasswdRequest->Data + ApRequest.BufferSize,
        PrivMessage.Buffer,
        PrivMessage.BufferSize
        );

Cleanup:
    if (PrivMessage.Buffer != NULL)
    {
        MIDL_user_free(PrivMessage.Buffer);
    }
    if (ApRequest.Buffer != NULL)
    {
        MIDL_user_free(ApRequest.Buffer);
    }
    if (EncodedData.Buffer != NULL)
    {
        MIDL_user_free(EncodedData.Buffer);
    }
    RtlEraseUnicodeString((PUNICODE_STRING) &AnsiPassword);
    KerbFreeString((PUNICODE_STRING) &AnsiPassword);

    KerbFreeRealm(&ChangeData.target_realm);
    KerbFreePrincipalName(
        &ChangeData.target_name
        );

    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyPrivMessage
//
//  Synopsis:   Verifies that a priv message is correct and returns the
//              user data from the message.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbVerifyPrivMessage(
    IN PKERB_PRIV_MESSAGE PrivMessage,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    OUT PKERB_MESSAGE_BUFFER PrivData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_ENCRYPTED_PRIV PrivBody = NULL;

    //
    // Now decrypt the KERB_PRIV message
    //

    if (PrivMessage->version != KERBEROS_VERSION)
    {
        DebugLog((DEB_ERROR,"Bad version in kpasswd priv message: %d, %ws, line %d\n",
            PrivMessage->version, THIS_FILE, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (PrivMessage->message_type != KRB_PRIV)
    {
        DebugLog((DEB_ERROR,"Bad message type in kpasswd priv message: %d, %ws, line %d\n",
            PrivMessage->message_type, THIS_FILE, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbErr = KerbDecryptDataEx(
                &PrivMessage->encrypted_part,
                SessionKey,
                KERB_PRIV_SALT,
                (PULONG) &PrivMessage->encrypted_part.cipher_text.length,
                PrivMessage->encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt priv message from kpasswd: 0x%x, %ws, line %d\n",
            KerbErr, THIS_FILE, __LINE__));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Now decode the kerb priv body
    //

    KerbErr = KerbUnpackData(
                PrivMessage->encrypted_part.cipher_text.value,
                (ULONG) PrivMessage->encrypted_part.cipher_text.length,
                KERB_ENCRYPTED_PRIV_PDU,
                (PVOID *) &PrivBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unpack priv body from kpasswd: 0x%x, %ws, line %d\n",
            KerbErr, THIS_FILE, __LINE__));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // There is nothing in the body we want to verify (although other clients
    // verify the sender's address).
    //

    if (PrivBody->user_data.length != 0)
    {
        PrivData->BufferSize = PrivBody->user_data.length;
        PrivData->Buffer = (PBYTE) MIDL_user_allocate(PrivData->BufferSize);
        if (PrivData->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            PrivData->Buffer,
            PrivBody->user_data.value,
            PrivBody->user_data.length
            );
    }
Cleanup:

    if (PrivBody != NULL)
    {
        KerbFreeData(
            KERB_ENCRYPTED_PRIV_PDU,
            PrivBody
            );
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbHandleKpasswdReply
//
//  Synopsis:   Unpacks the reply from the kpasswd service and converts
//              the error to an NT status code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbHandleKpasswdReply(
    IN PKERB_TICKET_CACHE_ENTRY KpasswdTicket,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PKERB_MESSAGE_BUFFER ReplyMessage
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_KPASSWD_REP KpasswdReply;
    PKERB_ERROR ErrorMessage = NULL;
    PKERB_AP_REPLY ApReply = NULL;
    PKERB_ENCRYPTED_AP_REPLY ApReplyBody = NULL;
    PKERB_PRIV_MESSAGE PrivMessage = NULL;
    KERB_MESSAGE_BUFFER PrivData = {0};
    USHORT ResultCode = 0;

    //
    // First check to see if this is a reply
    //

    if (ReplyMessage->BufferSize > sizeof(KERB_KPASSWD_REP))
    {
        USHORT Version;
        USHORT Length;
        KpasswdReply = (PKERB_KPASSWD_REP) ReplyMessage->Buffer;
        GET_SHORT(Version, KpasswdReply->Version );
        GET_SHORT(Length, KpasswdReply->MessageLength);

        //
        // Verify these values are correct
        //

        if ((Version != KERB_KPASSWD_VERSION) ||
            (Length != (USHORT) ReplyMessage->BufferSize))
        {
            //
            // It must be a kerb_error message, so unpack it.
            //

            KerbErr = KerbUnpackKerbError(
                        ReplyMessage->Buffer,
                        ReplyMessage->BufferSize,
                        &ErrorMessage
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }
        }
        else
        {
            USHORT ApRepLength;
            ULONG PrivLength;

            //
            // It is a well formed kpasswd reply, so unpack that
            //

            GET_SHORT(ApRepLength, KpasswdReply->ApRepLength);
            if (ApRepLength > ReplyMessage->BufferSize - FIELD_OFFSET(KERB_KPASSWD_REP,Data))
            {
                DebugLog((DEB_ERROR,"ApReq length in kpasswd rep is wrong: %d vs %d, %ws, line %d\n",
                    ApRepLength,
                    FIELD_OFFSET(KERB_KPASSWD_REP,Data), THIS_FILE, __LINE__
                    ));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;

            }

            //
            // Now unpack the AP reply
            //

            Status = KerbUnpackApReply(
                        KpasswdReply->Data,
                        ApRepLength,
                        &ApReply
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }

            //
            // Now try to unpack the remainder as  KERB_PRIV. If that fails,
            // try it as a KERB_ERROR
            //

            PrivLength = ReplyMessage->BufferSize - (ApRepLength + FIELD_OFFSET(KERB_KPASSWD_REP,Data));

            KerbErr = KerbUnpackData(
                        (PBYTE) KpasswdReply->Data + ApRepLength,
                        PrivLength,
                        KERB_PRIV_MESSAGE_PDU,
                        (PVOID *) &PrivMessage
                        );

            //
            // If that didn't work, try it as a kerb error message
            //

            if (!KERB_SUCCESS(KerbErr))
            {
                KerbErr = KerbUnpackKerbError(
                            (PBYTE) KpasswdReply->Data + ApRepLength,
                            PrivLength,
                            &ErrorMessage
                            );
                if (!KERB_SUCCESS(KerbErr))
                {
                    DebugLog((DEB_ERROR,"Failed to unpack data from kpasswd rep: 0x%x, %ws line %d\n",
                        KerbErr, THIS_FILE, __LINE__ ));

                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }
            }

        }
    }

    //
    // If we have an AP reply, verify it
    //

    if (ApReply != NULL)
    {
        KerbReadLockTicketCache();

        KerbErr = KerbDecryptDataEx(
                    &ApReply->encrypted_part,
                    &KpasswdTicket->SessionKey,
                    KERB_AP_REP_SALT,
                    (PULONG) &ApReply->encrypted_part.cipher_text.length,
                    ApReply->encrypted_part.cipher_text.value
                    );
        KerbUnlockTicketCache();

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR, "Failed to decrypt AP reply: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
            if (KerbErr == KRB_ERR_GENERIC)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                Status = STATUS_LOGON_FAILURE;
            }
            goto Cleanup;
        }

        //
        // Decode the contents now
        //

        if (!KERB_SUCCESS(KerbUnpackApReplyBody(
                            ApReply->encrypted_part.cipher_text.value,
                            ApReply->encrypted_part.cipher_text.length,
                            &ApReplyBody)))
        {
            DebugLog((DEB_ERROR, "Failed to unpack AP reply body. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // If we got a priv-message, verify it
    //

    if (PrivMessage != NULL)
    {
        Status = KerbVerifyPrivMessage(
                    PrivMessage,
                    SessionKey,
                    &PrivData
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to verify priv message while changing password: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        if (PrivData.BufferSize >= sizeof(USHORT))
        {
            GET_SHORT(ResultCode, PrivData.Buffer);
        }
    }
    else
    {
        //
        // Process the error message
        //

        if (ErrorMessage == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        // TBD:  Extended errors, client side
        KerbReportKerbError(
            NULL,
            NULL,
            NULL,
            NULL,
            KLIN(FILENO, __LINE__),
            ErrorMessage,
            ErrorMessage->error_code,
            NULL,
            FALSE
            );

        Status = KerbMapKerbError(ErrorMessage->error_code);

        if ((ErrorMessage->bit_mask & error_data_present) != 0)
        {
            if (ErrorMessage->error_data.length >= sizeof(USHORT))
            {
                GET_SHORT(ResultCode, ErrorMessage->error_data.value);
            }
        }

    }

    //
    // Convert the result code & status into a real status
    //

    if (NT_SUCCESS(Status) || (Status == STATUS_INSUFFICIENT_RESOURCES))
    {
        switch(ResultCode) {
        case KERB_KPASSWD_SUCCESS:
            Status = STATUS_SUCCESS;
            break;
        case KERB_KPASSWD_MALFORMED:
            Status = STATUS_INVALID_PARAMETER;
            break;
        case KERB_KPASSWD_ERROR:
            Status = STATUS_UNSUCCESSFUL;
            break;
        case KERB_KPASSWD_AUTHENTICATION:
            Status = STATUS_MUTUAL_AUTHENTICATION_FAILED;
            break;
        case KERB_KPASSWD_POLICY:
            Status = STATUS_PASSWORD_RESTRICTION;
            break;
        case KERB_KPASSWD_AUTHORIZATION:
            Status = STATUS_ACCESS_DENIED;
            break;
        default:
            Status = STATUS_UNSUCCESSFUL;

        }
    }

Cleanup:

    if (ErrorMessage != NULL)
    {
        KerbFreeKerbError(ErrorMessage);
    }
    if (ApReplyBody != NULL)
    {
        KerbFreeApReplyBody(ApReplyBody);
    }
    if (ApReply != NULL)
    {
        KerbFreeApReply(ApReply);
    }

    if (PrivData.Buffer != NULL)
    {
        MIDL_user_free(PrivData.Buffer);
    }                                   

    if (PrivMessage != NULL)
    {
        KerbFreeData(
            KERB_PRIV_MESSAGE_PDU,
            PrivMessage
            );
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbChangePassword
//
//  Synopsis:   Uses the kerberos change password protocol to change
//              a password. It is called through the LsaCallAuthenticationPackage
//              interface
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbChangePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PKERB_CHANGEPASSWORD_REQUEST ChangePasswordRequest = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;
    LUID DummyLogonId = {0};
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_TICKET_CACHE_ENTRY KpasswdTicket = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING  ValidatedAccountName;
    UNICODE_STRING  ValidatedDomainName;
    LPWSTR          ValidatedOldPasswordBuffer;
    LPWSTR          ValidatedNewPasswordBuffer;
    UNICODE_STRING RealmName = {0};
    KERB_MESSAGE_BUFFER KpasswdRequest = {0};
    KERB_MESSAGE_BUFFER KpasswdReply = {0};
    KERB_ENCRYPTION_KEY SessionKey = {0};
    ULONG Nonce = 0;
    BOOLEAN PasswordBufferValidated = FALSE;
    BOOLEAN CalledPDC = FALSE;
    ULONG StructureSize = sizeof(KERB_CHANGEPASSWORD_REQUEST);

    KERB_CHANGEPASS_INFO ChangePassTraceInfo;
    if( KerbEventTraceFlag ) // Event Trace: KerbChangePasswordStart {No Data}
    {
        ChangePassTraceInfo.EventTrace.Guid       = KerbChangePassGuid;
    ChangePassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
    ChangePassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
    ChangePassTraceInfo.EventTrace.Size       = sizeof(EVENT_TRACE_HEADER);

    TraceEvent( KerbTraceLoggerHandle, (PEVENT_TRACE_HEADER)&ChangePassTraceInfo );
    }

    *ReturnBufferSize = 0;
    *ProtocolReturnBuffer = NULL;
    *ProtocolStatus = STATUS_PENDING;

#if _WIN64

    SECPKG_CALL_INFO              CallInfo;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        StructureSize = sizeof(KERB_CHANGEPASSWORD_REQUEST_WOW64);
    }

#endif  // _WIN64


    //
    // Sanity checks.
    //

    if ( SubmitBufferSize < StructureSize )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ChangePasswordRequest = (PKERB_CHANGEPASSWORD_REQUEST) ProtocolSubmitBuffer;

    ASSERT( ChangePasswordRequest->MessageType == KerbChangePasswordMessage );

#if _WIN64

    KERB_CHANGEPASSWORD_REQUEST LocalChangePasswordRequest;

    //
    // Thunk 32-bit pointers if this is a WOW caller
    //

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PKERB_CHANGEPASSWORD_REQUEST_WOW64 ChangePasswordRequestWOW =
            (PKERB_CHANGEPASSWORD_REQUEST_WOW64) ChangePasswordRequest;

        LocalChangePasswordRequest.MessageType   = ChangePasswordRequest->MessageType;
        LocalChangePasswordRequest.Impersonating = ChangePasswordRequest->Impersonating;

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangePasswordRequest.DomainName,
                                       &ChangePasswordRequestWOW->DomainName);

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangePasswordRequest.AccountName,
                                       &ChangePasswordRequestWOW->AccountName);

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangePasswordRequest.OldPassword,
                                       &ChangePasswordRequestWOW->OldPassword);

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangePasswordRequest.NewPassword,
                                       &ChangePasswordRequestWOW->NewPassword);

        ChangePasswordRequest = &LocalChangePasswordRequest;
    }

#endif  // _WIN64

    RELOCATE_ONE( &ChangePasswordRequest->DomainName );
    RELOCATE_ONE( &ChangePasswordRequest->AccountName );
    RELOCATE_ONE_ENCODED( &ChangePasswordRequest->OldPassword );
    RELOCATE_ONE_ENCODED( &ChangePasswordRequest->NewPassword );

    //
    // save away copies of validated buffers to check later.
    //

    RtlCopyMemory( &ValidatedDomainName, &ChangePasswordRequest->DomainName, sizeof(ValidatedDomainName) );
    RtlCopyMemory( &ValidatedAccountName, &ChangePasswordRequest->AccountName, sizeof(ValidatedAccountName) );

    ValidatedOldPasswordBuffer = ChangePasswordRequest->OldPassword.Buffer;
    ValidatedNewPasswordBuffer = ChangePasswordRequest->NewPassword.Buffer;

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &ChangePasswordRequest->OldPassword.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    //
    // Check to see if the OldPassword will run over the buffer for the New
    // Password
    //

    if ((ChangePasswordRequest->OldPassword.Buffer +
        (ChangePasswordRequest->OldPassword.Length/sizeof(WCHAR)) )>
        ChangePasswordRequest->NewPassword.Buffer)
    {
        Status = STATUS_ILL_FORMED_PASSWORD;
        goto Cleanup;
    }

    if (Seed != 0) {

        __try {
            RtlRunDecodeUnicodeString(
                Seed,
                &ChangePasswordRequest->OldPassword
                );

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &ChangePasswordRequest->NewPassword.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    if (Seed != 0) {

        __try {
            RtlRunDecodeUnicodeString(
                Seed,
                &ChangePasswordRequest->NewPassword
                );

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    //
    // sanity check that we didn't whack over buffers.
    //

    if( !RtlCompareMemory(
                        &ValidatedDomainName,
                        &ChangePasswordRequest->DomainName,
                        sizeof(ValidatedDomainName)
                        )
                        ||
        !RtlCompareMemory(
                        &ValidatedAccountName,
                        &ChangePasswordRequest->AccountName,
                        sizeof(ValidatedAccountName)
                        )
                        ||
        (ValidatedOldPasswordBuffer != ChangePasswordRequest->OldPassword.Buffer)
                        ||
        (ValidatedNewPasswordBuffer != ChangePasswordRequest->NewPassword.Buffer)
                        ) {

            Status= STATUS_INVALID_PARAMETER;
            goto Cleanup;
    }

    //
    // Validate IN params, to not exceed  KERB_MAX_UNICODE_STRING, as we add a NULL
    // to UNICODE buffers when we're duping strings.
    //
    if (ChangePasswordRequest->OldPassword.Length > KERB_MAX_UNICODE_STRING ||
        ChangePasswordRequest->NewPassword.Length > KERB_MAX_UNICODE_STRING ||
        ChangePasswordRequest->AccountName.Length > KERB_MAX_UNICODE_STRING ||
        ChangePasswordRequest->DomainName.Length > KERB_MAX_UNICODE_STRING)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }                
   

    PasswordBufferValidated = TRUE;

    //
    // The protocol requires a ticket to the kadmin/changepw service. We
    // need to create a logon session to use the KerbGetAuthenticationTicket
    // routine.
    //

    Status = NtAllocateLocallyUniqueId( &DummyLogonId );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    Status = KerbCreateLogonSession(
                &DummyLogonId,
                &ChangePasswordRequest->AccountName,
                &ChangePasswordRequest->DomainName,
                &ChangePasswordRequest->OldPassword,
                NULL,                       // no old password
                PRIMARY_CRED_CLEAR_PASSWORD,
                Interactive,                    // LogonType
                &LogonSession
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }




    //
    // Now get a ticket for the kpasswd service
    //

    Status = KerbGetKpasswdTicket(
                LogonSession,
                &KpasswdTicket,
                &RealmName,
                &ClientName
                );


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    

    Status = KerbBuildKpasswdRequest(
                KpasswdTicket,
                &RealmName,
                &ChangePasswordRequest->NewPassword,
                &KpasswdRequest,
                &SessionKey,
                &Nonce
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to build kpasswd request: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Call the KDC
    //

    Status = KerbMakeSocketCall(
                &RealmName,
                NULL,           // no account name
                FALSE,          // don't call PDC
                FALSE,          // don't use TCP
                TRUE,
                &KpasswdRequest,
                &KpasswdReply,
                NULL, // no optional binding cache info
                0,    // no additonal flags
                &CalledPDC
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to call kpasswd service: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    //
    // Unpack the reply and return the error from it.
    //

    Status = KerbHandleKpasswdReply(
                KpasswdTicket,
                &SessionKey,
                &KpasswdReply
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Change password reply failed: 0x%x, %ws, line %d\n",
                  Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    //
    // Update the password in the logon session, if need be.
    //

    Status = KerbUpdateLogonSessionPasswords(
                LogonSession,
                &ChangePasswordRequest->NewPassword
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Update credential manager password
    //
    KerbNotifyCredentialManager(
            LogonSession,
            ChangePasswordRequest,
            ClientName,
            &RealmName
            );
   


Cleanup:
    if( KerbEventTraceFlag ) // Event Trace: KerbChangePasswordEnd {Status, AccountName, DomainName}
    {
    INSERT_ULONG_INTO_MOF( Status, ChangePassTraceInfo.MofData, 0 );
    ChangePassTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER) + 1*sizeof(MOF_FIELD);
        
    if( ChangePasswordRequest != NULL )
    {
        INSERT_UNICODE_STRING_INTO_MOF( ChangePasswordRequest->AccountName,  ChangePassTraceInfo.MofData, 1 );
        INSERT_UNICODE_STRING_INTO_MOF( ChangePasswordRequest->DomainName, ChangePassTraceInfo.MofData, 3 );
        ChangePassTraceInfo.EventTrace.Size += 4*sizeof(MOF_FIELD);
    }

    ChangePassTraceInfo.EventTrace.Guid       = KerbChangePassGuid; 
    ChangePassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
    ChangePassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

    TraceEvent( KerbTraceLoggerHandle, (PEVENT_TRACE_HEADER) &ChangePassTraceInfo );
    }

    KerbFreeString(&RealmName);

    KerbFreeKdcName(&ClientName);

    if (KpasswdTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry( KpasswdTicket );
    }

    if (LogonSession != NULL)
    {
        KerbReferenceLogonSessionByPointer(
            LogonSession,
            TRUE                        // dereference
            );
        KerbDereferenceLogonSession( LogonSession );
        KerbDereferenceLogonSession( LogonSession );
    }

    //
    // Don't let the password stay in the page file.
    //

    if ( PasswordBufferValidated ) {
        RtlEraseUnicodeString( &ChangePasswordRequest->OldPassword );
        RtlEraseUnicodeString( &ChangePasswordRequest->NewPassword );
    }

    if (KpasswdRequest.Buffer != NULL)
    {
        MIDL_user_free(KpasswdRequest.Buffer);
    }

    if (KpasswdReply.Buffer != NULL)
    {
        MIDL_user_free(KpasswdReply.Buffer);
    }

    if (SessionKey.keyvalue.value != NULL)
    {
        MIDL_user_free(SessionKey.keyvalue.value);
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbSetPasswordEx
//
//  Synopsis:   Uses the kerberos set password protocol to set an account
//              password. It uses the identity of the caller to authenticate
//              the request. It is called through the
//              LsaCallAuthenticationPackage interface
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbSetPassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PKERB_SETPASSWORD_EX_REQUEST SetPasswordRequest = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;
    LUID DummyLogonId = {0};
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    PKERB_TICKET_CACHE_ENTRY KpasswdTicket = NULL;
    KERB_PRIMARY_CREDENTIAL PrimaryCreds = {0};
    KERB_MESSAGE_BUFFER KpasswdRequest = {0};
    KERB_MESSAGE_BUFFER KpasswdReply = {0};
    KERB_ENCRYPTION_KEY SessionKey = {0};
    ULONG Nonce = 0;
    BOOLEAN PasswordBufferValidated = FALSE;
    BOOLEAN CalledPDC = FALSE;
    SECPKG_CLIENT_INFO ClientInfo;
    PKERB_INTERNAL_NAME KpasswdName = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_BINDING_CACHE_ENTRY OptionalBindingHandle = NULL;
    UNICODE_STRING ClientRealm = {0};
    PLUID LogonId;
    ULONG StructureSize   = sizeof(KERB_SETPASSWORD_REQUEST);
    ULONG StructureSizeEx = sizeof(KERB_SETPASSWORD_EX_REQUEST);

    KERB_SETPASS_INFO SetPassTraceInfo;
    if( KerbEventTraceFlag ) // Event Trace: KerbSetPasswordStart {No Data}
    {
        SetPassTraceInfo.EventTrace.Guid       = KerbSetPassGuid;
        SetPassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        SetPassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
        SetPassTraceInfo.EventTrace.Size       = sizeof(EVENT_TRACE_HEADER);      
        TraceEvent( KerbTraceLoggerHandle, (PEVENT_TRACE_HEADER)&SetPassTraceInfo );
    }

    *ReturnBufferSize = 0;
    *ProtocolReturnBuffer = NULL;
    *ProtocolStatus = STATUS_PENDING;

    SetPasswordRequest = (PKERB_SETPASSWORD_EX_REQUEST) ProtocolSubmitBuffer;
    
    ASSERT( (SetPasswordRequest->MessageType == KerbSetPasswordExMessage 
            || SetPasswordRequest->MessageType == KerbSetPasswordMessage) );

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    Status = LsaFunctions->GetCallInfo(&CallInfo);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        //
        // These levels are not supported for WOW
        //

        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

#endif  // _WIN64

    //
    // Sanity checks.
    //

    if (SubmitBufferSize < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (SetPasswordRequest->MessageType == KerbSetPasswordExMessage)
    {
        if (SubmitBufferSize < StructureSizeEx)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }               

        RELOCATE_ONE( &SetPasswordRequest->KdcAddress );
        RELOCATE_ONE( &SetPasswordRequest->ClientName );
        RELOCATE_ONE( &SetPasswordRequest->ClientRealm );
    }

    //
    // Note: although the struct members may be different, the type
    // remains the same between EX and normal version of SETPASSWORD_REQUEST
    // structure.
    //

    RELOCATE_ONE( &SetPasswordRequest->AccountRealm );
    RELOCATE_ONE( &SetPasswordRequest->AccountName );
    RELOCATE_ONE_ENCODED( &SetPasswordRequest->Password );

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &SetPasswordRequest->Password.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    if (Seed != 0) {

        __try {
            RtlRunDecodeUnicodeString(
                Seed,
                &SetPasswordRequest->Password
                );

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    if (SetPasswordRequest->AccountName.Length > KERB_MAX_UNICODE_STRING ||
        SetPasswordRequest->AccountRealm.Length > KERB_MAX_UNICODE_STRING ||
        SetPasswordRequest->Password.Length > KERB_MAX_UNICODE_STRING)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }    

    if (SetPasswordRequest->MessageType == KerbSetPasswordExMessage)
    {
        if(SetPasswordRequest->ClientRealm.Length > KERB_MAX_UNICODE_STRING ||
           SetPasswordRequest->ClientName.Length > KERB_MAX_UNICODE_STRING)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    PasswordBufferValidated = TRUE;
    
    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( (SetPasswordRequest->Flags & KERB_SETPASS_USE_LOGONID) != 0)
    {
        //
        // Verify the caller has TCB privilege if they want access to someone
        // elses ticket cache.
        //

        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }

        LogonId = &SetPasswordRequest->LogonId;
    }
    else if ( (SetPasswordRequest->Flags & KERB_SETPASS_USE_CREDHANDLE) != 0)
    { 
        //
        // Get the associated credential
        //

        Status = KerbReferenceCredential(
                        SetPasswordRequest->CredentialsHandle.dwUpper,
                        KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                        FALSE,
                        &Credential);

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to locate credential: 0x%x\n",Status));
            goto Cleanup;
        }

        //
        // Get the logon id from the credentials so we can locate the
        // logon session.
        //

        DummyLogonId = Credential->LogonId;
        LogonId = &DummyLogonId;
    }
    else
    {
        LogonId = &ClientInfo.LogonId;
    }

    //
    // The protocol requires a ticket to the kadmin/changepw service. We
    // need to get the caller's logon session to use to get this
    // ticket.
    //


    LogonSession = KerbReferenceLogonSession(
                    LogonId,
                    FALSE                       // don't unlink
                    );

    if (LogonSession == NULL)
    {
        DebugLog((DEB_ERROR,"Can't locate caller's logon session\n"));
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Now get a ticket for the kpasswd service
    //

    Status = KerbBuildKpasswdName(
                &KpasswdName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = KerbGetServiceTicket(
                LogonSession,
                Credential,             // no credential
                NULL,
                KpasswdName,
                &SetPasswordRequest->AccountRealm,
	        NULL,
                TRUE,                   // don't do name canonicalization
                0,                      // no ticket options
                0,                      // no encryption type
                NULL,                   // no error message
                NULL,                   // no authorizatoin data,
                NULL,                   // no tgt reply
                &KpasswdTicket,
                NULL                    // don't return logon guid
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Parse the names to get the real kerberos names
    //


    PrimaryCreds.UserName = SetPasswordRequest->AccountName;
    PrimaryCreds.DomainName = SetPasswordRequest->AccountRealm;

    Status = KerbGetClientNameAndRealm(
                LogonId,
                &PrimaryCreds,
                FALSE,
                NULL,
                NULL,
                FALSE,                                  // default to wksta realm for UPN
                &ClientName,
                &ClientRealm
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get client name and realm: 0x%x file %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Build the set password request
    //

    Status = KerbBuildSetPasswordRequest(
                KpasswdTicket,
                ClientName,
                &ClientRealm,
                &SetPasswordRequest->Password,
                &KpasswdRequest,
                &SessionKey,
                &Nonce
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to build kpasswd request: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Here we may possibly need to set the target KDC
    // This KDC is not gaurenteed to succeeed, and retry logic
    // will occur on a failed SetPwd request..
    //
    if (SetPasswordRequest->MessageType == KerbSetPasswordExMessage 
        && SetPasswordRequest->KdcAddress.Buffer != NULL)
    {
        OptionalBindingHandle = (PKERB_BINDING_CACHE_ENTRY) 
                                  KerbAllocate(sizeof(KERB_BINDING_CACHE_ENTRY));

        if (NULL == OptionalBindingHandle)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
       
        OptionalBindingHandle->AddressType = SetPasswordRequest->KdcAddressType;
       
        RtlCopyMemory(
           &(OptionalBindingHandle->KdcAddress),
           &(SetPasswordRequest->KdcAddress),
           sizeof(UNICODE_STRING)
           );

        RtlCopyMemory(
           &(OptionalBindingHandle->RealmName),
           &(SetPasswordRequest->AccountRealm),
           sizeof(UNICODE_STRING)
           );                                
    } 

    //
    // Call the KDC
    //

    Status = KerbMakeSocketCall(
                &ClientRealm,
                NULL,           // no account name
                FALSE,          // don't call PDC
                FALSE,          // don't use TCP
                TRUE,
                &KpasswdRequest,
                &KpasswdReply,
                OptionalBindingHandle,
                0, // no additional flags
                &CalledPDC
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to call kpasswd service: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    //
    // Unpack the reply and return the error from it.
    //

    Status = KerbHandleKpasswdReply(
                KpasswdTicket,
                &SessionKey,
                &KpasswdReply
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Change password reply failed: 0x%x, %ws, line %d\n",
                Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

Cleanup:

    if( KerbEventTraceFlag ) // Event Trace: KerbSetPasswordEnd {Status, AccountName, AccountRealm, (ClientName), (ClientRealm), (KdcAddress)}
    {
        INSERT_ULONG_INTO_MOF( Status, SetPassTraceInfo.MofData, 0 );
        SetPassTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER) + 1*sizeof(MOF_FIELD);
        
        if( SetPasswordRequest != NULL )
        {
            INSERT_UNICODE_STRING_INTO_MOF(SetPasswordRequest->AccountName, SetPassTraceInfo.MofData, 1);
            INSERT_UNICODE_STRING_INTO_MOF(SetPasswordRequest->AccountRealm, SetPassTraceInfo.MofData, 3);

            SetPassTraceInfo.EventTrace.Size += 4 * sizeof(MOF_FIELD);
        
            if (SetPasswordRequest->MessageType == KerbSetPasswordExMessage)
            {
                INSERT_UNICODE_STRING_INTO_MOF(SetPasswordRequest->ClientName,  SetPassTraceInfo.MofData, 5);
                INSERT_UNICODE_STRING_INTO_MOF(SetPasswordRequest->ClientRealm, SetPassTraceInfo.MofData, 7);
                INSERT_UNICODE_STRING_INTO_MOF(SetPasswordRequest->KdcAddress,  SetPassTraceInfo.MofData, 9);

                SetPassTraceInfo.EventTrace.Size += 6 * sizeof(MOF_FIELD);
            }
        }

        SetPassTraceInfo.EventTrace.Guid       = KerbSetPassGuid;   
        SetPassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        SetPassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

        TraceEvent( KerbTraceLoggerHandle, (PEVENT_TRACE_HEADER) &SetPassTraceInfo );
    }

    KerbFreeKdcName( &KpasswdName );
    KerbFreeKdcName( &ClientName );
    KerbFreeString( &ClientRealm );
    KerbFreeKey( &SessionKey );

    if (KpasswdTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry( KpasswdTicket );
    }

    if (Credential != NULL)
    {
        KerbDereferenceCredential(Credential);
    }

    if (NULL != OptionalBindingHandle)
    {
       KerbFree(OptionalBindingHandle);
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    //
    // Don't let the password stay in the page file.
    //

    if ( PasswordBufferValidated )
    {
        RtlEraseUnicodeString( &SetPasswordRequest->Password );
    }

    if (KpasswdRequest.Buffer != NULL)
    {
        MIDL_user_free(KpasswdRequest.Buffer);
    }

    if (KpasswdReply.Buffer != NULL)
    {
        MIDL_user_free(KpasswdReply.Buffer);
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}


#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbpass.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbpass.cxx
//
// Contents:    Code for changing the Kerberos password on a KDC
//
//
// History:     17-October-1998         MikeSw  Created
//
//------------------------------------------------------------------------

#ifndef __KERBPASS_H__
#define __KERBPASS_H__

#include <kpasswd.h>

NTSTATUS NTAPI
KerbChangePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbSetPassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

#endif // __KERBPASS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbs4u.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        kerbs4u.h
//
// Contents:    Structures and prototyps for Service4User protocol
//
//
// History:     13 - March - 2000   Created         Todds
//
//------------------------------------------------------------------------

#ifndef __KERBS4U_H__
#define __KERBS4U_H__






                                       
                                       
NTSTATUS
KerbS4UToSelfLogon(
        IN PVOID ProtocolSubmitBuffer,
        IN PVOID ClientBufferBase,
        IN ULONG SubmitBufferSize,
        OUT PKERB_LOGON_SESSION * NewLogonSession,
        OUT PLUID LogonId,
        OUT PKERB_TICKET_CACHE_ENTRY * WorkstationTicket,
        OUT PKERB_INTERNAL_NAME * S4UClientName,
        OUT PUNICODE_STRING S4UClientRealm
        );















#endif // __KERBS4U_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbs4u.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 2001
//
// File:        kerbs4u.cxx
//
// Contents:    Code for doing S4UToSelf() logon.
//
//
// History:     14-March-2001   Created         Todds
//
//------------------------------------------------------------------------
#include <kerb.hxx>
#include <kerbp.h>


#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

 
 



//+-------------------------------------------------------------------------
//
//  Function:   KerbInitGlobalS4UCred
//
//  Synopsis:   Create a KERB_CREDENTIAL structure w/ bogus password for AS 
//              location of client.
//              
//
//  Effects:
//
//  Arguments:  
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitGlobalS4UCred()
{

    return STATUS_SUCCESS; // TBD: Come up w/ scheme for global cred..

}






















//+-------------------------------------------------------------------------
//
//  Function:   KerbGetS4UClientIdentity
//
//  Synopsis:   Attempt to gets TGT for an S4U client for name 
//              location purposes.  
//              
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the 
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetS4UClientRealm(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_INTERNAL_NAME * S4UClientName,
    IN OUT PUNICODE_STRING S4UTargetRealm
    // TBD:  Place for credential handle?
    )
{
    NTSTATUS Status = STATUS_SUCCESS, LookupStatus = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_INTERNAL_NAME KdcServiceKdcName = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING CorrectRealm = {0};
    ULONG RetryCount = KERB_CLIENT_REFERRAL_MAX;
    ULONG RequestFlags = 0;
    BOOLEAN UsingSuppliedCreds = FALSE;
    BOOLEAN MitRealmLogon = FALSE;
    BOOLEAN UsedPrimaryLogonCreds = FALSE;
    PKERB_TICKET_CACHE_ENTRY    TicketCacheEntry = NULL;

    
    RtlInitUnicodeString(
      S4UTargetRealm,
      NULL
      );

    //
    // Use our server credentials to start off the AS_REQ process.
    // We may get a referral elsewhere, however.
    //
    
    Status = KerbGetClientNameAndRealm(
                 NULL,
                 &LogonSession->PrimaryCredentials,
                 UsingSuppliedCreds,
                 NULL,
                 &MitRealmLogon,
                 TRUE,
                 &ClientName,
                 &ClientRealm
                 );
 

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get client name & realm: 0x%x, %ws line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }



GetTicketRestart:

    KerbErr = KerbBuildFullServiceKdcName(
                 &ClientRealm,
                 &KerbGlobalKdcServiceName,
                 KRB_NT_SRV_INST,
                 &KdcServiceKdcName
                 );
    
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }         

    Status = KerbGetAuthenticationTicket(
                 LogonSession,
                 NULL, // KerbGlobalS4UCred,
                 NULL,
                 KdcServiceKdcName,
                 &ClientRealm,
                 (*S4UClientName),
                 RequestFlags,
                 KERB_TICKET_CACHE_PRIMARY_TGT,
                 &TicketCacheEntry,
                 NULL,
                 &CorrectRealm
                 );
    //
    // If it failed but gave us another realm to try, go there
    //
    
    if (!NT_SUCCESS(Status) && (CorrectRealm.Length != 0))
    {
        if (--RetryCount != 0)
        {
           KerbFreeKdcName(&KdcServiceKdcName);
           KerbFreeString(&ClientRealm);
           ClientRealm = CorrectRealm;
           CorrectRealm.Buffer = NULL;

           //
           // TBD:  MIT realm support?  See KerbGetTicketGrantingTicket()
           // S4UToSelf
           goto GetTicketRestart;
        }
        else
        {
           // Tbd:  Log error here?  Max referrals reached..
           goto Cleanup;
        }
    
     }

    //
    // TBD: S4UToSelf()
    // in KerbGetTgt, we'll be happy to crack the UPN given the xxx@foo.com syntax
    // Here, we should just fail out..  Right?
    //


    // 
    // If we get STATUS_WRONG_PASSWORD, we succeeded in finding the 
    // client realm.  Otherwise, we're hosed.  As the password we used
    // is bogus, we should never succeed, btw...
    //                              
    DsysAssert(!NT_SUCCESS(Status));

    if (Status == STATUS_WRONG_PASSWORD)
    {                            
        // fester:  define new debug level / trace level
        DebugLog((DEB_ERROR, "Found client"));
        KerbPrintKdcName(DEB_ERROR, (*S4UClientName));
        DebugLog((DEB_ERROR, "\nin realm %wZ\n", &ClientRealm));

        *S4UTargetRealm = ClientRealm;
        Status = STATUS_SUCCESS;
    }
     
    
     

Cleanup:

    
    // if we succeeded, we got the correct realm,
    // and we need to pass that back to caller
    if (!NT_SUCCESS(Status))
    {
        KerbFreeString(&ClientRealm);
    }  
    
    KerbFreeKdcName(&KdcServiceKdcName);
    KerbFreeKdcName(&ClientName);

    if (NULL != TicketCacheEntry)
    {
        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
        // fester:       make sure we toss this...
        DsysAssert(TicketCacheEntry->ListEntry.ReferenceCount == 1);
    }
    

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildS4UPreauth
//
//  Synopsis:   Attempt to gets TGT for an S4U client for name 
//              location purposes.  
//              
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the 
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildS4UPreauth(
    IN OUT PKERB_PA_DATA_LIST * PreAuthData,
    IN PKERB_INTERNAL_NAME S4UClientName,
    IN PUNICODE_STRING S4UClientRealm
    )
{
    KERBERR KerbErr;
    KERB_PA_FOR_USER  S4UserPA = {0};
    PKERB_PA_DATA_LIST ListElement = NULL;
    
    *PreAuthData = NULL;

    KerbErr = KerbConvertKdcNameToPrincipalName(
                    &S4UserPA.client_name,
                    S4UClientName
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup; 
    }

    KerbErr = KerbConvertUnicodeStringToRealm(
                            &S4UserPA.client_realm,
                            S4UClientRealm
                            );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup; 
    }

    ListElement = (PKERB_PA_DATA_LIST) KerbAllocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        goto Cleanup;
    }

    KerbErr = KerbPackData(
                    &S4UserPA,
                    KERB_PA_FOR_USER_PDU,
                    (PULONG) &ListElement->value.preauth_data.length,
                    (PUCHAR *) &ListElement->value.preauth_data.value
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup; 
    } 

    ListElement->value.preauth_data_type = KRB5_PADATA_S4U;   
    ListElement->next = NULL;
  
    *PreAuthData = ListElement;

Cleanup:

    KerbFreePrincipalName(&S4UserPA.client_name);
    KerbFreeRealm(&S4UserPA.client_realm);  
    return KerbErr;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTgtToS4URealm
//
//  Synopsis:   We need a TGT to the client realm under the caller's cred's
//              so we can make a S4U TGS_REQ.
//              
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the 
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetTgtToS4URealm(
    IN PKERB_LOGON_SESSION CallerLogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PUNICODE_STRING S4UClientRealm,
    IN OUT PKERB_TICKET_CACHE_ENTRY * S4UTgt,
    IN ULONG Flags,
    IN ULONG TicketOptions,
    IN ULONG EncryptionType
    )
{ 

    NTSTATUS    Status;
    ULONG       RetryFlags = 0;
    BOOLEAN     CrossRealm = FALSE, CacheTicket = TRUE;
    BOOLEAN     TicketCacheLocked = FALSE, LogonSessionsLocked = FALSE;

    PKERB_TICKET_CACHE_ENTRY    TicketGrantingTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY    LastTgt = NULL;
    PKERB_TICKET_CACHE_ENTRY    TicketCacheEntry = NULL;

    PKERB_KDC_REPLY             KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY   KdcReplyBody = NULL;
    PKERB_INTERNAL_NAME         TargetTgtKdcName = NULL;
    UNICODE_STRING              ClientRealm = NULL_UNICODE_STRING;
    PKERB_PRIMARY_CREDENTIAL    PrimaryCredentials = NULL;



    *S4UTgt = NULL;

    if ((Credential != NULL) && (Credential->SuppliedCredentials != NULL))
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else
    {   
        PrimaryCredentials = &CallerLogonSession->PrimaryCredentials;
    }



    Status = KerbGetTgtForService(
                    CallerLogonSession,
                    Credential,
                    NULL,
                    NULL,
                    S4UClientRealm,
                    0,
                    &TicketGrantingTicket,
                    &CrossRealm
                    );


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If this isn't cross realm, then we've got a TGT to the realm.
    // return it and bail.
    //
    if (!CrossRealm)
    {
        DebugLog((DEB_ERROR, "We have a TGT for %wZ\n", S4UClientRealm));
        *S4UTgt = TicketGrantingTicket;
        TicketGrantingTicket = NULL;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
            S4UClientRealm,
            &KerbGlobalKdcServiceName,
            KRB_NT_SRV_INST,
            &TargetTgtKdcName
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    //
    // Copy out the client realm name which is used when obtaining the ticket
    //

    Status = KerbDuplicateString(
                &ClientRealm,
                &PrimaryCredentials->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Do some referral chasing to get our ticket grantin ticket.
    //
    while (!RtlEqualUnicodeString(
                S4UClientRealm,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
    {

        //
        // If we just got two TGTs for the same domain, then we must have
        // gotten as far as we can. Chances our our RealTargetRealm is a
        // variation of what the KDC hands out.
        //

        if ((LastTgt != NULL) &&
             RtlEqualUnicodeString(
                &LastTgt->TargetDomainName,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
        {

            KerbUnlockTicketCache();
            
            KerbSetTicketCacheEntryTarget(
                S4UClientRealm,
                LastTgt
                );

            KerbReadLockTicketCache();
            TicketCacheLocked = TRUE;
            D_DebugLog((DEB_TRACE_CTXT, "Got two TGTs for same realm (%wZ), bailing out of referral loop\n",
                &LastTgt->TargetDomainName));
            break;
        }

        D_DebugLog((DEB_TRACE_CTXT, "Getting referral TGT for \n"));
        D_KerbPrintKdcName(DEB_TRACE_CTXT, TargetTgtKdcName);
        D_KerbPrintKdcName(DEB_TRACE_CTXT, TicketGrantingTicket->ServiceName);
        
        KerbUnlockTicketCache();
        TicketCacheLocked = FALSE;

        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;


        Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetTgtKdcName,
                    FALSE,
                    TicketOptions,
                    EncryptionType,
                    NULL,
                    NULL,                       // no PA data here.
                    NULL,                       // no tgt reply since target is krbtgt
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x :",
                Status ));
            KerbPrintKdcName(DEB_WARN, TargetTgtKdcName );
            DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));

            //
            // We want to map cross-domain failures to failures indicating
            // that a KDC could not be found. This means that for Kerberos
            // logons, the negotiate code will retry with a different package
            //

            // if (Status == STATUS_NO_TRUST_SAM_ACCOUNT)
            // {
            //     Status = STATUS_NO_LOGON_SERVERS;
            // }
            goto Cleanup;
        }

        //
        // Now we have a ticket - lets cache it
        //
        KerbWriteLockLogonSessions(CallerLogonSession);
        LogonSessionsLocked = TRUE;


        Status = KerbCacheTicket(
                    &PrimaryCredentials->AuthenticationTicketCache,
                    KdcReply,
                    KdcReplyBody,
                    NULL,                               // no target name
                    NULL,                               // no targe realm
                    0,                                  // no flags
                    CacheTicket,
                    &TicketCacheEntry
                    );

        KerbUnlockLogonSessions(CallerLogonSession);
        LogonSessionsLocked = FALSE;


        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (LastTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }
        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        KerbReadLockTicketCache();
        TicketCacheLocked = TRUE;
        

    }     // ** WHILE ** 
    

    *S4UTgt = TicketGrantingTicket;
    TicketGrantingTicket = NULL;

Cleanup:

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(CallerLogonSession);
    }

    KerbFreeTgsReply( KdcReply );
    KerbFreeKdcReplyBody( KdcReplyBody );
    KerbFreeKdcName( &TargetTgtKdcName );

    if (TicketGrantingTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }  

    KerbFreeString( &ClientRealm );
    return Status;
}




























                      
//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildS4UPreauth
//
//  Synopsis:   Attempt to gets TGT for an S4U client for name 
//              location purposes.  
//              
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the 
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetS4UServiceTicket(
    IN PKERB_LOGON_SESSION CallerLogonSession,
    IN PKERB_LOGON_SESSION NewLogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PKERB_INTERNAL_NAME S4UClientName,
    IN PUNICODE_STRING S4UClientRealm,
    IN OUT PKERB_TICKET_CACHE_ENTRY * S4UTicket,
    IN ULONG Flags,
    IN ULONG TicketOptions,
    IN ULONG EncryptionType
    )
{
    NTSTATUS                    Status; 
    KERBERR                     KerbErr;
    PKERB_TICKET_CACHE_ENTRY    TicketCacheEntry = NULL;
    PKERB_TICKET_CACHE_ENTRY    TicketGrantingTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY    S4UTgt = NULL;
    PKERB_TICKET_CACHE_ENTRY    LastTgt = NULL;
    PKERB_KDC_REPLY             KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY   KdcReplyBody = NULL;
    PKERB_PA_DATA_LIST          S4UPaDataList = NULL;
    BOOLEAN                     LogonSessionsLocked = FALSE;
    BOOLEAN                     TicketCacheLocked = FALSE;
    BOOLEAN                     CrossRealm = FALSE;

    PKERB_INTERNAL_NAME RealTargetName = NULL;
    PKERB_INTERNAL_NAME TargetName = NULL;

    UNICODE_STRING RealTargetRealm = NULL_UNICODE_STRING;
    PKERB_INTERNAL_NAME TargetTgtKdcName = NULL;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials = NULL;
    BOOLEAN UsedCredentials = FALSE;
    UNICODE_STRING ClientRealm = NULL_UNICODE_STRING;
    BOOLEAN CacheTicket = ((Flags & KERB_GET_TICKET_NO_CACHE) == 0);
    BOOLEAN PurgeTgt = FALSE;
    ULONG ReferralCount = 0;
    ULONG RetryFlags = 0;
    KERBEROS_MACHINE_ROLE Role;

    BOOLEAN fMITRetryAlreadyMade = FALSE;
    BOOLEAN TgtRetryMade = FALSE;
    BOOLEAN PurgedEntry = FALSE;
    
  
    //
    // Peform S4U TGS_REQ for ourselves
    //
    Flags |= KERB_GET_TICKET_S4U;

    // HACK
    TicketOptions |= (KERB_KDC_OPTIONS_name_canonicalize | KERB_KDC_OPTIONS_cname_in_pa_data);

    //
    // Get our own name, and other globals.
    // 
    KerbGlobalReadLock();
    Role = KerbGetGlobalRole(); 

    Status = KerbDuplicateKdcName(
                    &TargetName,
                    KerbGlobalMitMachineServiceName
                    );

    KerbGlobalReleaseLock();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Check to see if the credential has any primary credentials
    //
TGTRetry:

    KerbReadLockLogonSessions(CallerLogonSession);
    LogonSessionsLocked = TRUE;

    if ((Credential != NULL) && (Credential->SuppliedCredentials != NULL))
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
        UsedCredentials = TRUE;
    }
    else
    {   
        PrimaryCredentials = &CallerLogonSession->PrimaryCredentials;
    }

    //
    // Here we make sure we have a ticket to the KDC of the user's account
    //
    if ((Flags & KERB_GET_TICKET_NO_CACHE) == 0)
    {
        //
        // TBD:  Create a S4U Ticket cache to hang off of the
        //       service logon session.
        //       These tickets have a lifetime of 10 minutes.
        //
        
        TicketCacheEntry = KerbLocateTicketCacheEntry(
                                &PrimaryCredentials->S4UTicketCache,
                                S4UClientName,
                                S4UClientRealm
                                );

    }
    
    

    //
    // TBD:  More for here?
    //
    if (TicketCacheEntry != NULL)
    {
        
        ULONG TicketFlags;
        ULONG CacheTicketFlags;
        ULONG CacheEncryptionType;


        //
        // Check if the flags are present
        //

        KerbReadLockTicketCache();
        CacheTicketFlags = TicketCacheEntry->TicketFlags;
        CacheEncryptionType = TicketCacheEntry->Ticket.encrypted_part.encryption_type;
        KerbUnlockTicketCache();

        TicketFlags = KerbConvertKdcOptionsToTicketFlags(TicketOptions);

        if (((CacheTicketFlags & TicketFlags) != TicketFlags) ||
            ((EncryptionType != 0) && (CacheEncryptionType != EncryptionType)))

        {
            KerbDereferenceTicketCacheEntry(TicketCacheEntry);
            TicketCacheEntry = NULL;
        }
        else
        {
            //
            // Check the ticket time
            //

            if (KerbTicketIsExpiring(TicketCacheEntry, TRUE))
            {
                KerbDereferenceTicketCacheEntry(TicketCacheEntry);
                TicketCacheEntry = NULL;
            }
            else
            {
                *S4UTicket = TicketCacheEntry;
                TicketCacheEntry = NULL;
                goto Cleanup;
            }

        }
     
    }


    //
    // Get a krbtgt/S4URealm ticket
    //
    Status = KerbGetTgtToS4URealm(
                    CallerLogonSession,
                    Credential,
                    S4UClientRealm,
                    &TicketGrantingTicket,
                    Flags,          // tbd:  support for these options?
                    TicketOptions,
                    EncryptionType
                    );    


    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Cannot get S4U Tgt - %x\n", Status));
        goto Cleanup;
    }  


    //
    // Build the preauth for our TGS req
    //

    Status = KerbBuildS4UPreauth(
                &S4UPaDataList,
                S4UClientName,
                S4UClientRealm
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KerbBuildS4UPreauth failed - %x\n",Status));
        goto Cleanup;
    } 


    //
    // If the caller wanted any special options, don't cache this ticket.
    //
    if ((TicketOptions != 0) || (EncryptionType != 0) || ((Flags & KERB_GET_TICKET_NO_CACHE) != 0))
    {
        CacheTicket = FALSE;
    }

    
    //
    // Copy out the client realm name which is used when obtaining the ticket
    //

    Status = KerbDuplicateString(
                &ClientRealm,
                &PrimaryCredentials->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbUnlockLogonSessions(CallerLogonSession);
    LogonSessionsLocked = FALSE;

ReferralRestart:
    
    //
    // This is our first S4U TGS_REQ.  We'll 
    // eventually transit back to our realm.
    // Note:  If we get back a referral, the KDC reply
    // is a TGT to another realm, so keep trying, but
    // be sure to use that TGT.
    //


    Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,            
                    TargetName, // TBD:  right name?
                    Flags,
                    TicketOptions,
                    EncryptionType,
                    NULL,
                    S4UPaDataList,
                    NULL,
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

        
    //
    // We're done w/ S4UTgt.  Deref, and check
    // for errors
    //

    if (TicketGrantingTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);

        //
        // Check for bad option TGT purging
        //
        if (((RetryFlags & KERB_RETRY_WITH_NEW_TGT) != 0) && !TgtRetryMade)
        {
            DebugLog((DEB_WARN, "Doing TGT retry - %p\n", TicketGrantingTicket));

            //
            // Unlink && purge bad tgt
            //
            KerbRemoveTicketCacheEntry(TicketGrantingTicket);
            KerbDereferenceTicketCacheEntry(TicketGrantingTicket); // free from list
            TgtRetryMade = TRUE;
            TicketGrantingTicket = NULL;
            goto TGTRetry;
        }                 

        TicketGrantingTicket = NULL;

    }


    if (!NT_SUCCESS(Status))
    {

       
        //
        // Check for the MIT retry case
        //

        if (((RetryFlags & KERB_MIT_NO_CANONICALIZE_RETRY) != 0) 
            && (!fMITRetryAlreadyMade) &&
            (Role != KerbRoleRealmlessWksta))
        {

            Status = KerbMITGetMachineDomain(
                CallerLogonSession,
                TargetName,
                S4UClientRealm,
                &TicketGrantingTicket
                );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed Query policy information %ws, line %d\n", THIS_FILE, __LINE__));
                goto Cleanup;
            }

            fMITRetryAlreadyMade = TRUE;

            goto TGTRetry;
        }

        DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x : \n",
                  Status ));
        KerbPrintKdcName(DEB_WARN, TargetName );
        DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Check for referral info in the name
    // Should be there if S4Urealm != Our Realm

    Status = KerbGetReferralNames(
                KdcReplyBody,
                TargetName,
                &RealTargetRealm
                );
    
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If this is not a referral ticket, just cache it and return
    // the cache entry.
    //
    if (RealTargetRealm.Length == 0)
    {

        //
        // Now we have a ticket - lets cache it
        //

        KerbWriteLockLogonSessions(CallerLogonSession);
        LogonSessionsLocked = TRUE;


        Status = KerbCacheTicket(
                        &PrimaryCredentials->S4UTicketCache,
                        KdcReply,
                        KdcReplyBody,
                        TargetName,
                        S4UClientRealm,
                        0,
                        CacheTicket,
                        &TicketCacheEntry
                        );

        KerbUnlockLogonSessions(CallerLogonSession);
        LogonSessionsLocked = FALSE;


        if (!NT_SUCCESS(Status))
            {
            goto Cleanup;
        }

        *S4UTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        //
        // We're done, so get out of here.
        //

        goto Cleanup;
    }


    //
    // The server referred us to another domain. Get the service's full
    // name from the ticket and try to find a TGT in that domain.
    //
    Status = KerbDuplicateKdcName(
                    &RealTargetName,
                    TargetName
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE_CTXT, "Got referral ticket for service \n"));
    D_KerbPrintKdcName(DEB_TRACE_CTXT,TargetName);
    D_DebugLog((DEB_TRACE_CTXT, "in realm \n"));
    D_KerbPrintKdcName(DEB_TRACE_CTXT,RealTargetName);

    //
    // Turn the KDC reply (xrealm tgt w/ s4u pac) into something we can use,
    // but *don't* cache it.
    // 
    Status = KerbCacheTicket(
                    NULL,
                    KdcReply,
                    KdcReplyBody,
                    NULL,                               // no target name
                    NULL,                               // no targe realm
                    0,                                  // no flags
                    FALSE,                              // just create entry
                    &TicketCacheEntry
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    TicketGrantingTicket = TicketCacheEntry;
    TicketCacheEntry = NULL;


    //
    // cleanup
    //
    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KdcReply = NULL;
    KdcReplyBody = NULL;
                                        

    //
    // Now we are in a case where we have a realm to aim for and a TGT. While
    // we don't have a TGT for the target realm, get one.
    //

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                &RealTargetRealm,
                &KerbGlobalKdcServiceName,
                KRB_NT_SRV_INST,
                &TargetTgtKdcName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    
    //
    // Referral chasing code block - very important to get right
    // If we know the "real" target realm, eg. from GC, then
    // we'll walk trusts until we hit "real" target realm.
    //
    while (!RtlEqualUnicodeString(
                &RealTargetRealm,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
    {

        //
        // If we just got two TGTs for the same domain, then we must have
        // gotten as far as we can. Chances our our RealTargetRealm is a
        // variation of what the KDC hands out.
        //

        if ((LastTgt != NULL) &&
             RtlEqualUnicodeString(
                &LastTgt->TargetDomainName,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
        {

            KerbUnlockTicketCache();

            KerbSetTicketCacheEntryTarget(
                &RealTargetRealm,
                LastTgt
                );

            KerbReadLockTicketCache();
            D_DebugLog((DEB_TRACE_CTXT, "Got two TGTs for same realm (%wZ), bailing out of referral loop\n",
                &LastTgt->TargetDomainName));
            break;
        }

        D_DebugLog((DEB_TRACE_CTXT, "Getting referral TGT for \n"));
        D_KerbPrintKdcName(DEB_TRACE_CTXT, TargetTgtKdcName);
        D_KerbPrintKdcName(DEB_TRACE_CTXT, TicketGrantingTicket->ServiceName);
        
        KerbUnlockTicketCache();
        TicketCacheLocked = FALSE;

        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;


        Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetTgtKdcName,
                    FALSE,
                    TicketOptions,
                    EncryptionType,
                    NULL,
                    S4UPaDataList,
                    NULL,                       // no tgt reply since target is krbtgt
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x :",
                Status ));
            KerbPrintKdcName(DEB_WARN, TargetTgtKdcName );
            DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));

            //
            // We want to map cross-domain failures to failures indicating
            // that a KDC could not be found. This means that for Kerberos
            // logons, the negotiate code will retry with a different package
            //

            // if (Status == STATUS_NO_TRUST_SAM_ACCOUNT)
            // {
            //     Status = STATUS_NO_LOGON_SERVERS;
            // }
            goto Cleanup;
        }

        //
        // Now we have a ticket - don't cache it, however
        //
        
        Status = KerbCacheTicket(
                    &PrimaryCredentials->AuthenticationTicketCache,
                    KdcReply,
                    KdcReplyBody,
                    NULL,                               // no target name
                    NULL,                               // no targe realm
                    0,                                  // no flags
                    FALSE,
                    &TicketCacheEntry
                    );
        
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (LastTgt != NULL)
        {
            KerbFreeTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }
        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        KerbReadLockTicketCache();
        TicketCacheLocked = TRUE;
        

    }     // ** WHILE ** 


    //
    // Now we must have a TGT to our service's domain. Get a ticket
    // to the service.
    //
    
    // FESTER : put assert in to make sure this tgt is to our realm.


    //
    // Cleanup old state
    //

    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KdcReply = NULL;
    KdcReplyBody = NULL;
    
    Status = KerbGetTgsTicket(
                &ClientRealm,
                TicketGrantingTicket,
                TargetName,
                FALSE,
                TicketOptions,
                EncryptionType,
                NULL,
                S4UPaDataList,
                NULL,
                &KdcReply,
                &KdcReplyBody,
                &RetryFlags
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x ",
            Status ));
        KerbPrintKdcName(DEB_WARN, RealTargetName);
        DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now that we are in the domain to which we were referred, check for referral
    // info in the name
    //

    KerbFreeString(&RealTargetRealm);
    Status = KerbGetReferralNames(
                KdcReplyBody,
                RealTargetName,
                &RealTargetRealm
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If this is not a referral ticket, just cache it and return
    // the cache entry.
    //
    if (RealTargetRealm.Length != 0)
    {
        //
        // To prevent loops, we limit the number of referral we'll take
        //


        if (ReferralCount > KerbGlobalMaxReferralCount)
        {
            DebugLog((DEB_ERROR,"Maximum referral count exceeded for name: "));
            KerbPrintKdcName(DEB_ERROR,RealTargetName);
            Status = STATUS_MAX_REFERRALS_EXCEEDED;
            goto Cleanup;
        }

        ReferralCount++;

        //
        // Don't cache the interdomain TGT, as it has PAC info in it.
        //

        Status = KerbCacheTicket(
                    NULL,
                    KdcReply,
                    KdcReplyBody,
                    NULL,                       // no target name
                    NULL,                       // no target realm
                    0,                          // no flags
                    FALSE,
                    &TicketCacheEntry
                    ); 

        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (LastTgt != NULL)
        {
            KerbFreeTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }

        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;
    
        D_DebugLog((DEB_TRACE_CTXT, "Restart referral:%wZ", &RealTargetRealm));

        goto ReferralRestart;                                                      
    }

    //
    // Now we have a ticket - lets cache it
    //

    //
    // Before doing anything, verify that the client name on the ticket
    // is equal to the client name requested during the S4u
    //
    // TBD:  Once ticket cache code is ready for this, implement it.
    //       Also verify PAC information is correct.
    //
    KerbWriteLockLogonSessions(CallerLogonSession);
    LogonSessionsLocked = TRUE;


    Status = KerbCacheTicket(
                &PrimaryCredentials->S4UTicketCache,
                KdcReply,
                KdcReplyBody,
                TargetName,
                S4UClientRealm,
                0,                                      // no flags
                CacheTicket,
                &TicketCacheEntry
                );

    KerbUnlockLogonSessions(CallerLogonSession);
    LogonSessionsLocked = FALSE;

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *S4UTicket = TicketCacheEntry;
    TicketCacheEntry = NULL;

Cleanup:

   
    KerbFreeTgsReply( KdcReply );
    KerbFreeKdcReplyBody( KdcReplyBody );
    KerbFreeKdcName( &TargetTgtKdcName );
    KerbFreeString( &RealTargetRealm );
    KerbFreeKdcName(&RealTargetName);
    KerbFreePreAuthData(S4UPaDataList);

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(CallerLogonSession);
    }

    KerbFreeString(&RealTargetRealm);

    //
    // We never cache TGTs in this routine
    // so it's just a blob of memory
    //
    if (TicketGrantingTicket != NULL)
    {
       KerbFreeTicketCacheEntry(TicketGrantingTicket);
    }
    if (LastTgt != NULL)
    {
        KerbFreeTicketCacheEntry(LastTgt);
        LastTgt = NULL;
    }


    
    //
    // If we still have a pointer to the ticket cache entry, free it now.
    //

    if (TicketCacheEntry != NULL)
    {
        KerbRemoveTicketCacheEntry( TicketCacheEntry );
        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
    }
    KerbFreeString(&ClientRealm);
    return(Status);
}
                                                           

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateS4ULogonSession
//
//  Synopsis:   Creates a logon session to accompany the S4ULogon.  
//              
//
//  Effects:
//
//  Arguments:  
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbCreateS4ULogonSession(
    IN PKERB_INTERNAL_NAME S4UClientName,
    IN PUNICODE_STRING S4UClientRealm,
    IN PLUID pLuid,
    IN OUT PKERB_LOGON_SESSION * LogonSession
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING S4UClient = {0};

    *LogonSession = NULL;    

    DsysAssert(S4UClientName->NameCount == 1);
    DsysAssert(S4UClientName->NameType == KRB_NT_ENTERPRISE_PRINCIPAL);
    
    if (!KERB_SUCCESS( KerbConvertKdcNameToString(
                            &S4UClient,
                            S4UClientName,
                            NULL
                            )) )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = KerbCreateLogonSession(
                    pLuid,
                    &S4UClient,
                    S4UClientRealm,  // do we need this?
                    NULL,
                    NULL,
                    KERB_LOGON_S4U_SESSION, // fester
                    Network,
                    LogonSession
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KerbCreateLogonSession failed %x %ws, line %d\n", Status, THIS_FILE, __LINE__));
        goto Cleanup;
    } 

Cleanup:

    KerbFreeString(&S4UClient);
    return Status;

}










//+-------------------------------------------------------------------------
//
//  Function:   KerbS4UToSelfLogon
//
//  Synopsis:   Attempt to gets TGT for an S4U client for name 
//              location purposes.  
//              
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the 
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbS4UToSelfLogon(
        IN PVOID ProtocolSubmitBuffer,
        IN PVOID ClientBufferBase,
        IN ULONG SubmitBufferSize,
        OUT PKERB_LOGON_SESSION * NewLogonSession,
        OUT PLUID LogonId,
        OUT PKERB_TICKET_CACHE_ENTRY * WorkstationTicket,
        OUT PKERB_INTERNAL_NAME * S4UClientName,
        OUT PUNICODE_STRING S4UClientRealm
        )
{
    NTSTATUS Status;
    KERBERR  KerbErr;
    
    PKERB_S4U_LOGON     LogonInfo = NULL;
    PKERB_LOGON_SESSION CallerLogonSession = NULL;
    PKERB_INTERNAL_NAME KdcServiceKdcName = NULL;
    SECPKG_CLIENT_INFO  ClientInfo;
    ULONG_PTR           Offset;
    ULONG               Flags = KERB_CRACK_NAME_USE_WKSTA_REALM, ProcessFlags = 0;

    // fester:

    UNICODE_STRING DummyRealm = {0};


    if (!KerbRunningServer())
    {
        D_DebugLog((DEB_ERROR, "Not running server, no S4u!\n"));
        return SEC_E_UNSUPPORTED_FUNCTION;
    }                                          

    *NewLogonSession = NULL;
    *WorkstationTicket = NULL;
    *S4UClientName = NULL;
    
    RtlInitUnicodeString(
        S4UClientRealm,
        NULL
        );


    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get client information: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    } 
    
    //
    // TBD:  Any other validation code here?
    //

    LogonInfo = (PKERB_S4U_LOGON) ProtocolSubmitBuffer;
    RELOCATE_ONE(&LogonInfo->ClientUpn);
    NULL_RELOCATE_ONE(&LogonInfo->ClientRealm);

    //
    // TBD:  put in cache code here, so we can easily locate a ticket we have
    // gotten in the "recent" past.  
    //



    //
    // Tbd:  Any special name rules to put in here?
    // e.g. if we get a UPN and a realm, which takes
    // precedence?
    //
    
    // 
    // TBD:  Convert client name (unicode) into client name (internal)
    //
    Status = KerbProcessTargetNames(
                    &LogonInfo->ClientUpn,
                    NULL,
                    Flags,
                    &ProcessFlags,
                    S4UClientName,
                    &DummyRealm,
	            NULL
                    );


    // Dummy Realm == info after @ sign
    //DsysAssert(DummyRealm.Length == 0); 
    DsysAssert((*S4UClientName)->NameType ==  KRB_NT_ENTERPRISE_PRINCIPAL);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }             
                                                               
    CallerLogonSession = KerbReferenceLogonSession(
                            &ClientInfo.LogonId,
                            FALSE
                            );

    if (NULL == CallerLogonSession)
    {
        D_DebugLog((DEB_ERROR, "Failed to locate caller's logon session - %x\n", ClientInfo.LogonId));
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        DsysAssert(FALSE);
        goto Cleanup;
    } 

    //
    // First, we need to get the client's realm from the UPN
    //

    if (LogonInfo->ClientRealm.Length == 0)
    {     
   
        Status = KerbGetS4UClientRealm(
                    CallerLogonSession,
                    S4UClientName,
                    S4UClientRealm
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else
    {
        Status = KerbDuplicateString(
                    S4UClientRealm,
                    &LogonInfo->ClientRealm
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }             
    }




    //
    // Allocate a locally unique ID for this logon session. We will
    // create it in the LSA just before returning.
    //

    Status = NtAllocateLocallyUniqueId( LogonId );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    Status = KerbCreateS4ULogonSession(
                    (*S4UClientName),
                    S4UClientRealm,
                    LogonId,
                    NewLogonSession
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create logon session 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    Status = KerbGetS4UServiceTicket(
                    CallerLogonSession,
                    (*NewLogonSession),
                    NULL, // tbd: need to put credential here?
                    (*S4UClientName),
                    S4UClientRealm,
                    WorkstationTicket,
                    0, // no flags
                    0, // no ticketoptions
                    0  // no enctype
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }  


    
Cleanup:

    if (!NT_SUCCESS(Status))
    {
        //
        // TBD:  Negative cache here, based on client name
        //
        KerbFreeString(S4UClientRealm);
        KerbFreeKdcName(S4UClientName);
        *S4UClientName = NULL;
                                       
    }   

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbtick.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbtick.cxx
//
// Contents:    Routines for obtaining and manipulating tickets
//
//
// History:     23-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//              15-Oct-1999   ChandanS 
//                            Send more choice of encryption types.
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <userapi.h>    // for GSS support routines
#include <kerbpass.h>
#include <krbaudit.h>

extern "C"
{
#include <stdlib.h>     // abs()
}

#include <utils.hxx>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif
#define FILENO FILENO_KERBTICK


#ifndef WIN32_CHICAGO // We don't do server side stuff
#include <authen.hxx>

CAuthenticatorList * Authenticators;
#endif // WIN32_CHICAGO // We don't do server side stuff

#include <lsaitf.h>


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTgtForService
//
//  Synopsis:   Gets a TGT for the domain of the specified service. If a
//              cached one is available, it uses that one. Otherwise it
//              calls the KDC to acquire it.
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session for which to acquire a ticket
//              Credentials - If present & contains supp. creds, use them
//                      for the ticket cache
//              SuppRealm - This is a supplied realm for which to acquire
//                      a TGT, this may or may not be the same as the
//                      TargetDomain.
//              TargetDomain - Realm of service for which to acquire a TGT
//              NewCacheEntry - Receives a referenced ticket cache entry for
//                      TGT
//              CrossRealm - TRUE if target is known to be in a different realm
//
//  Requires:   The primary credentials be locked
//
//  Returns:    Kerberos errors, NT status codes.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetTgtForService(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN PUNICODE_STRING TargetDomain,
    IN ULONG TargetFlags,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry,
    OUT PBOOLEAN CrossRealm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_TICKET_CACHE_ENTRY CacheEntry;
    BOOLEAN DoRetry = TRUE;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;

    *CrossRealm = FALSE;
    *NewCacheEntry = NULL;


    if (ARGUMENT_PRESENT(Credential) && (Credential->SuppliedCredentials != NULL))
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else if (ARGUMENT_PRESENT(CredManCredentials))
    {
        PrimaryCredentials = CredManCredentials->SuppliedCredentials;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }



    if (TargetDomain->Length != 0)
    {
        CacheEntry = KerbLocateTicketCacheEntryByRealm(
                        &PrimaryCredentials->AuthenticationTicketCache,
                        TargetDomain,
                        0
                        );

        if (CacheEntry != NULL)
        {
            *NewCacheEntry = CacheEntry;
            goto Cleanup;
        }
    }

    //
    // Well, we didn't find one to the other domain. Return a TGT for our
    // domain.
    //

Retry:

    CacheEntry = KerbLocateTicketCacheEntryByRealm(
                    &PrimaryCredentials->AuthenticationTicketCache,
                    SuppRealm,
                    KERB_TICKET_CACHE_PRIMARY_TGT
                    );


    if (CacheEntry != NULL)
    {

        //
        // The first pass, make sure the ticket has a little bit of life.
        // The second pass, we don't ask for as much
        //

        if (!KerbTicketIsExpiring(CacheEntry, DoRetry))
        {
            Status = STATUS_SUCCESS;
            *NewCacheEntry = CacheEntry;

            //
            // If the TGT is not for the domain of the service,
            // this is cross realm.  If we used the SPN cache, we're
            // obviously missing a ticket, and we need to restart the
            // referral process.
            //
            //

            if ((TargetDomain->Length != 0) &&
                (TargetFlags & KERB_TARGET_USED_SPN_CACHE) == 0)
            {
                *CrossRealm = TRUE;
            }
            goto Cleanup;
        }
    }


    //
    // Try to obtain a new TGT
    //

    if (DoRetry)
    {
        //
        // Unlock the logon session so we can try to get a new TGT
        //

        KerbUnlockLogonSessions(LogonSession);

        Status = KerbRefreshPrimaryTgt(
                    LogonSession,
                    Credential,
                    CredManCredentials,
                    SuppRealm,
                    CacheEntry
                    );

        if (CacheEntry != NULL)
        {
            // pull the old TGT from the list, as its been replaced
            if (NT_SUCCESS(Status))
            {
                KerbRemoveTicketCacheEntry(CacheEntry);
            }

            KerbDereferenceTicketCacheEntry(CacheEntry);
            CacheEntry = NULL;
        }

        KerbReadLockLogonSessions(LogonSession);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to refresh primary TGT: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__ ));
            goto Cleanup;
        }
        DoRetry = FALSE;
        goto Retry;
    }

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

Cleanup:
    if (!NT_SUCCESS(Status) && (CacheEntry != NULL))
    {
        KerbDereferenceTicketCacheEntry(CacheEntry);
        *NewCacheEntry = NULL;
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKerbCred
//
//  Synopsis:   Builds a marshalled KERB_CRED structure
//
//  Effects:    allocates destination with MIDL_user_allocate
//
//  Arguments:  Ticket - The ticket of the session key to seal the
//                      encrypted portion (OPTIONAL)
//              DelegationTicket - The ticket to marshall into the cred message
//              MarshalledKerbCred - Receives a marshalled KERB_CRED structure
//              KerbCredSizes - Receives size, in bytes, of marshalled
//                      KERB_CRED.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildKerbCred(
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY Ticket,
    IN PKERB_TICKET_CACHE_ENTRY DelegationTicket,
    OUT PUCHAR * MarshalledKerbCred,
    OUT PULONG KerbCredSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KERB_CRED KerbCred;
    KERB_CRED_INFO_LIST CredInfo;
    KERB_ENCRYPTED_CRED EncryptedCred;
    KERB_CRED_TICKET_LIST TicketList;
    PUCHAR MarshalledEncryptPart = NULL;
    ULONG MarshalledEncryptSize;
    ULONG ConvertedFlags;

    //
    // Initialize the structures so they can be freed later.
    //

    *MarshalledKerbCred = NULL;
    *KerbCredSize = 0;

    RtlZeroMemory(
        &KerbCred,
        sizeof(KERB_CRED)
        );

    RtlZeroMemory(
        &EncryptedCred,
        sizeof(KERB_ENCRYPTED_CRED)
        );
    RtlZeroMemory(
        &CredInfo,
        sizeof(KERB_CRED_INFO_LIST)
        );
    RtlZeroMemory(
        &TicketList,
        sizeof(KERB_CRED_TICKET_LIST)
        );

    KerbCred.version = KERBEROS_VERSION;
    KerbCred.message_type = KRB_CRED;

    //
    // First stick the ticket into the ticket list.
    //

    KerbReadLockTicketCache();

    TicketList.next= NULL;
    TicketList.value = DelegationTicket->Ticket;
    KerbCred.tickets = &TicketList;

    //
    // Now build the KERB_CRED_INFO for this ticket
    //

    CredInfo.value.key = DelegationTicket->SessionKey;
    KerbConvertLargeIntToGeneralizedTime(
        &CredInfo.value.endtime,
        NULL,
        &DelegationTicket->EndTime
        );
    CredInfo.value.bit_mask |= endtime_present;

    KerbConvertLargeIntToGeneralizedTime(
        &CredInfo.value.starttime,
        NULL,
        &DelegationTicket->StartTime
        );
    CredInfo.value.bit_mask |= KERB_CRED_INFO_starttime_present;

    KerbConvertLargeIntToGeneralizedTime(
        &CredInfo.value.KERB_CRED_INFO_renew_until,
        NULL,
        &DelegationTicket->RenewUntil
        );
    CredInfo.value.bit_mask |= KERB_CRED_INFO_renew_until_present;

    ConvertedFlags = KerbConvertUlongToFlagUlong(DelegationTicket->TicketFlags);
    CredInfo.value.flags.value = (PUCHAR) &ConvertedFlags;
    CredInfo.value.flags.length = 8 * sizeof(ULONG);
    CredInfo.value.bit_mask |= flags_present;

    //
    // The following fields are marked as optional but treated
    // as mandatory by the MIT implementation of Kerberos and
    // therefore we provide them.
    //

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &CredInfo.value.principal_name,
                DelegationTicket->ClientName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    CredInfo.value.bit_mask |= principal_name_present;

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &CredInfo.value.service_name,
                DelegationTicket->ServiceName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    CredInfo.value.bit_mask |= service_name_present;

    //
    // We are assuming that because we are sending a TGT the
    // client realm is the same as the serve realm. If we ever
    // send non-tgt or cross-realm tgt, this needs to be fixed.
    //

    KerbErr = KerbConvertUnicodeStringToRealm(
                &CredInfo.value.principal_realm,
                &DelegationTicket->ClientDomainName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    //
    // The realms are the same, so don't allocate both
    //

    CredInfo.value.service_realm = CredInfo.value.principal_realm;
    CredInfo.value.bit_mask |= principal_realm_present | service_realm_present;

    EncryptedCred.ticket_info = &CredInfo;


    //
    // Now encrypted the encrypted cred into the cred
    //

    if (!KERB_SUCCESS(KerbPackEncryptedCred(
            &EncryptedCred,
            &MarshalledEncryptSize,
            &MarshalledEncryptPart
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If we are doing DES encryption, then we are talking with an non-NT
    // server. Hence, don't encrypt the kerb-cred.
    //
    // Additionally, if service ticket == NULL, don't encrypt kerb cred
    //

    if (!ARGUMENT_PRESENT(Ticket))
    {
       KerbCred.encrypted_part.cipher_text.length = MarshalledEncryptSize;
       KerbCred.encrypted_part.cipher_text.value = MarshalledEncryptPart;
       KerbCred.encrypted_part.encryption_type = 0;
       MarshalledEncryptPart = NULL;
    }
    else if( KERB_IS_DES_ENCRYPTION(Ticket->SessionKey.keytype))
    {
       KerbCred.encrypted_part.cipher_text.length = MarshalledEncryptSize;
       KerbCred.encrypted_part.cipher_text.value = MarshalledEncryptPart;
       KerbCred.encrypted_part.encryption_type = 0;
       MarshalledEncryptPart = NULL;
    }
    else
    {
        //
        // Now get the encryption overhead
        //

        KerbErr = KerbAllocateEncryptionBufferWrapper(
                    Ticket->SessionKey.keytype,
                    MarshalledEncryptSize,
                    &KerbCred.encrypted_part.cipher_text.length,
                    &KerbCred.encrypted_part.cipher_text.value
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }



        //
        // Encrypt the data.
        //

        KerbErr = KerbEncryptDataEx(
                    &KerbCred.encrypted_part,
                    MarshalledEncryptSize,
                    MarshalledEncryptPart,
                    Ticket->SessionKey.keytype,
                    KERB_CRED_SALT,
                    &Ticket->SessionKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // Now we have to marshall the whole KERB_CRED
    //

    if (!KERB_SUCCESS(KerbPackKerbCred(
            &KerbCred,
            KerbCredSize,
            MarshalledKerbCred
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

Cleanup:
    KerbUnlockTicketCache();

    KerbFreePrincipalName(&CredInfo.value.service_name);

    KerbFreePrincipalName(&CredInfo.value.principal_name);

    KerbFreeRealm(&CredInfo.value.principal_realm);

    if (MarshalledEncryptPart != NULL)
    {
        MIDL_user_free(MarshalledEncryptPart);
    }
    if (KerbCred.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(KerbCred.encrypted_part.cipher_text.value);
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetDelegationTgt
//
//  Synopsis:   Gets a TGT to delegate to another service. This TGT
//              is marked as forwarded and does not include any
//              client addresses
//
//  Effects:
//
//  Arguments:
//
//  Requires:   Logon sesion must be read-locked
//
//  Returns:
//
//  Notes:      This gets a delegation TGT & caches it under the realm name
//              "$$Delegation Ticket$$". When we look for it again later,
//              it should be discoverable under the same name.
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetDelegationTgt(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN LONG EncryptionType,
    OUT PKERB_TICKET_CACHE_ENTRY * DelegationTgt
    )
{
    PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket = NULL;
    PKERB_INTERNAL_NAME TgsName = NULL;
    UNICODE_STRING TgsRealm = {0};
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    BOOLEAN LogonSessionLocked = TRUE;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING CacheName;
    BOOLEAN CacheTicket = TRUE;
    ULONG RetryFlags = 0;

    RtlInitUnicodeString(
        &CacheName,
        L"$$Delegation Ticket$$"
        );


    *DelegationTgt = KerbLocateTicketCacheEntryByRealm(
                            &Credentials->AuthenticationTicketCache,
                            &CacheName,
                            KERB_TICKET_CACHE_DELEGATION_TGT
                            );
    if (*DelegationTgt != NULL )
    {
        KerbReadLockTicketCache();
        if (EncryptionType != (*DelegationTgt)->Ticket.encrypted_part.encryption_type)
        {
            KerbUnlockTicketCache();
            KerbDereferenceTicketCacheEntry(*DelegationTgt);
            *DelegationTgt = NULL;
            CacheTicket = FALSE;
        }
        else
        {
            KerbUnlockTicketCache();
            goto Cleanup;
        }
    }

    TicketGrantingTicket = KerbLocateTicketCacheEntryByRealm(
                                &Credentials->AuthenticationTicketCache,
                                &Credentials->DomainName,       // take the logon TGT
                                0
                                );


    if ((TicketGrantingTicket == NULL) ||
        ((TicketGrantingTicket->TicketFlags & KERB_TICKET_FLAGS_forwardable) == 0) )
    {
        DebugLog((DEB_WARN,"Trying to delegate but no forwardable TGT\n"));
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    //
    // Get the TGT service name from the TGT
    //

    KerbReadLockTicketCache();

    Status = KerbDuplicateKdcName(
                &TgsName,
                TicketGrantingTicket->ServiceName
                );
    if (NT_SUCCESS(Status))
    {
        Status = KerbDuplicateString(
                    &TgsRealm,
                    &TicketGrantingTicket->DomainName
                    );
    }
    KerbUnlockTicketCache();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbUnlockLogonSessions(LogonSession);
    LogonSessionLocked = FALSE;

    //
    // Now try to get the ticket.
    //


    Status = KerbGetTgsTicket(
                &TgsRealm,
                TicketGrantingTicket,
                TgsName,
                TRUE, // no name canonicalization, no GC lookups.
                KERB_KDC_OPTIONS_forwarded | KERB_DEFAULT_TICKET_FLAGS,
                EncryptionType,                 // no encryption type
                NULL,                           // no authorization data
                NULL,                           // no pa data
                NULL,                           // no tgt reply
                &KdcReply,
                &KdcReplyBody,
                &RetryFlags
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    KerbReadLockLogonSessions(LogonSession);
    LogonSessionLocked = TRUE;

    Status = KerbCacheTicket(
                &Credentials->AuthenticationTicketCache,
                KdcReply,
                KdcReplyBody,
                NULL,           // no target name
                &CacheName,
                KERB_TICKET_CACHE_DELEGATION_TGT,
                CacheTicket,                    // Cache the ticket
                DelegationTgt
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:
    KerbFreeTgsReply (KdcReply);
    KerbFreeKdcReplyBody (KdcReplyBody);

    if (TicketGrantingTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }
    KerbFreeKdcName(&TgsName);
    KerbFreeString(&TgsRealm);

    if (!LogonSessionLocked)
    {
        KerbReadLockLogonSessions(LogonSession);
    }

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildGssChecskum
//
//  Synopsis:   Builds the GSS checksum to go in an AP request
//
//  Effects:    Allocates a checksum with KerbAllocate
//
//  Arguments:  ContextFlags - Requested context flags
//              LogonSession - LogonSession to be used for delegation
//              GssChecksum - Receives the new checksum
//              ApOptions - Receives the requested AP options
//
//  Requires:
//
//  Returns:
//
//  Notes:      The logon session is locked when this is called.
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildGssChecksum(
    IN  PKERB_LOGON_SESSION      LogonSession,
    IN  PKERB_PRIMARY_CREDENTIAL PrimaryCredentials,
    IN  PKERB_TICKET_CACHE_ENTRY Ticket,
    IN  OUT PULONG               ContextFlags,
    OUT PKERB_CHECKSUM           GssChecksum,
    OUT PULONG                   ApOptions,
    IN  PSEC_CHANNEL_BINDINGS    pChannelBindings
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_GSS_CHECKSUM ChecksumBody = NULL;
    PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket = NULL;
    ULONG ChecksumSize = GSS_CHECKSUM_SIZE;
    ULONG KerbCredSize = 0 ;
    PUCHAR KerbCred = NULL;
    BOOLEAN OkAsDelegate = FALSE, OkToTrustMitKdc = FALSE;
    LONG EncryptionType = 0;
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN UsedAlternateName;
    ULONG BindHash[4];

    *ApOptions = 0;

    //
    // If we are doing delegation, built a KERB_CRED message to return
    //

    if (*ContextFlags & (ISC_RET_DELEGATE | ISC_RET_DELEGATE_IF_SAFE))
    {
        KerbReadLockTicketCache();
        OkAsDelegate = ((Ticket->TicketFlags & KERB_TICKET_FLAGS_ok_as_delegate) != 0) ? TRUE : FALSE;
        EncryptionType = Ticket->Ticket.encrypted_part.encryption_type;
        if (KerbLookupMitRealm(
                           &Ticket->DomainName,
                           &MitRealm,
                           &UsedAlternateName))
        {
            if ((MitRealm->Flags & KERB_MIT_REALM_TRUSTED_FOR_DELEGATION) != 0)
            {
                OkToTrustMitKdc = TRUE;
            }
        }
        KerbUnlockTicketCache();

        if (OkAsDelegate || OkToTrustMitKdc)
        {
            D_DebugLog((DEB_TRACE,"Asked for delegate if safe, and getting delegation TGT\n"));

            //
            // Check to see if we have a TGT
            //

            Status = KerbGetDelegationTgt(
                        LogonSession,
                        PrimaryCredentials,
                        EncryptionType,
                        &TicketGrantingTicket
                        );
            if (!NT_SUCCESS(Status))
            {
                //
                // Turn off the delegate flag for building the token.
                //

                *ContextFlags &= ~ISC_RET_DELEGATE;
                *ContextFlags &= ~ISC_RET_DELEGATE_IF_SAFE;
                DebugLog((DEB_WARN,"Failed to get delegation TGT: 0x%x\n",Status));
                Status = STATUS_SUCCESS;
            }
            else
            {


                //
                // Build the KERB_CRED message
                //

                Status = KerbBuildKerbCred(
                            Ticket,
                            TicketGrantingTicket,
                            &KerbCred,
                            &KerbCredSize
                            );
                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR,"Failed to build KERB_CRED: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }
                //ChecksumSize= sizeof(KERB_GSS_CHECKSUM) - ANYSIZE_ARRAY * sizeof(UCHAR) + KerbCredSize;
                ChecksumSize = GSS_DELEGATE_CHECKSUM_SIZE + KerbCredSize;

                //
                // And if only the DELEGATE_IF_SAFE flag was on, turn on the
                // real delegate flag:
                //
                *ContextFlags |= ISC_RET_DELEGATE ;
            }

        }
        else
        {

            //
            // Turn off the delegate flag for building the token.
            //

            *ContextFlags &= ~ISC_RET_DELEGATE;
            *ContextFlags &= ~ISC_RET_DELEGATE_IF_SAFE;
        }


    }

    ChecksumBody = (PKERB_GSS_CHECKSUM) KerbAllocate(ChecksumSize);
    if (ChecksumBody == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Convert the requested flags to AP options.
    //


    if ((*ContextFlags & ISC_RET_MUTUAL_AUTH) != 0)
    {
        *ApOptions |= KERB_AP_OPTIONS_mutual_required;
        ChecksumBody->GssFlags |= GSS_C_MUTUAL_FLAG;
    }

    if ((*ContextFlags & ISC_RET_USE_SESSION_KEY) != 0)
    {
        *ApOptions |= KERB_AP_OPTIONS_use_session_key;
    }

    if ((*ContextFlags & ISC_RET_USED_DCE_STYLE) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_DCE_STYLE;
    }

    if ((*ContextFlags & ISC_RET_SEQUENCE_DETECT) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_SEQUENCE_FLAG;
    }

    if ((*ContextFlags & ISC_RET_REPLAY_DETECT) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_REPLAY_FLAG;
    }

    if ((*ContextFlags & ISC_RET_CONFIDENTIALITY) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_CONF_FLAG;
    }

    if ((*ContextFlags & ISC_RET_INTEGRITY) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_INTEG_FLAG;
    }

    if ((*ContextFlags & ISC_RET_IDENTIFY) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_IDENTIFY_FLAG;
    }

    if ((*ContextFlags & ISC_RET_EXTENDED_ERROR) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_EXTENDED_ERROR_FLAG;
    }

    if ((*ContextFlags & ISC_RET_DELEGATE) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_DELEG_FLAG;
        ChecksumBody->Delegation = 1;
        ChecksumBody->DelegationLength = (USHORT) KerbCredSize;
        RtlCopyMemory(
            ChecksumBody->DelegationInfo,
            KerbCred,
            KerbCredSize
            );
    }

    ChecksumBody->BindLength = 0x10;

    //
    // (viz. Windows Bugs 94818)
    // If channel bindings are absent, BindHash should be {0,0,0,0}
    //
    if( pChannelBindings == NULL )
    {
        RtlZeroMemory( ChecksumBody->BindHash, ChecksumBody->BindLength );
    }
    else
    {
        Status = KerbComputeGssBindHash( pChannelBindings, (PUCHAR)BindHash );

        if( !NT_SUCCESS(Status) )
        {
            goto Cleanup;
        }

        RtlCopyMemory( ChecksumBody->BindHash, BindHash, ChecksumBody->BindLength );
    }

    GssChecksum->checksum_type = GSS_CHECKSUM_TYPE;
    GssChecksum->checksum.length = ChecksumSize;
    GssChecksum->checksum.value = (PUCHAR) ChecksumBody;
    ChecksumBody = NULL;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (ChecksumBody != NULL)
        {
            KerbFree(ChecksumBody);
        }
    }
    if (TicketGrantingTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }

    if (KerbCred != NULL)
    {
        MIDL_user_free(KerbCred);
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildApRequest
//
//  Synopsis:   Builds an AP request message from a logon session and a
//              ticket cache entry.
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session used to build this AP request
//              Credential - Optional credential for use with supplemental credentials
//              TicketCacheEntry - Ticket with which to build the AP request
//              ErrorMessage - Optionally contains error message from last AP request
//              ContextFlags - Flags passed in by client indicating
//                      authentication requirements. If the flags can't
//                      be supported they will be turned off.
//              MarshalledApReqest - Receives a marshalled AP request allocated
//                      with KerbAllocate
//              ApRequestSize - Length of the AP reques structure in bytes
//              Nonce - Nonce used for this request. if non-zero, then the
//                      nonce supplied by the caller will be used.
//              SubSessionKey - if generated, returns a sub-session key in AP request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbBuildApRequest(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN OPTIONAL PKERB_ERROR ErrorMessage,
    IN ULONG ContextAttributes,
    IN OUT PULONG ContextFlags,
    OUT PUCHAR * MarshalledApRequest,
    OUT PULONG ApRequestSize,
    OUT PULONG Nonce,
    IN OUT PKERB_ENCRYPTION_KEY SubSessionKey,
    IN PSEC_CHANNEL_BINDINGS pChannelBindings
    )
{
    NTSTATUS Status;
    ULONG ApOptions = 0;
    KERBERR KerbErr;
    KERB_CHECKSUM GssChecksum = {0};
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials = NULL;
    TimeStamp ServerTime;
    ULONG RequestSize;
    PUCHAR RequestWithHeader = NULL;
    PUCHAR RequestStart;
    gss_OID MechId;
    BOOLEAN LogonSessionLocked = FALSE;
    BOOLEAN StrongEncryptionPermitted = KerbGlobalStrongEncryptionPermitted;



    *ApRequestSize = 0;
    *MarshalledApRequest = NULL;

#ifndef WIN32_CHICAGO
    {
        SECPKG_CALL_INFO CallInfo;

        if (!StrongEncryptionPermitted && LsaFunctions->GetCallInfo(&CallInfo))
        {
            if (CallInfo.Attributes & SECPKG_CALL_IN_PROC )
            {
                StrongEncryptionPermitted = TRUE;
            }
        }
    }
#endif

    //
    // If we have an error message, use it to compute a skew time to adjust
    // local time by
    //

    if (ARGUMENT_PRESENT(ErrorMessage))
    {
        TimeStamp CurrentTime;
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);

        KerbWriteLockTicketCache();

        //
        // Update the skew cache the first time we fail to a server
        //

        if ((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_SKEW)
        {
            if (KerbGetTime(TicketCacheEntry->TimeSkew) == 0)
            {
                KerbUpdateSkewTime(TRUE);
            }
        }
        KerbConvertGeneralizedTimeToLargeInt(
            &ServerTime,
            &ErrorMessage->server_time,
            ErrorMessage->server_usec
            );
        KerbSetTime(&TicketCacheEntry->TimeSkew, KerbGetTime(ServerTime) - KerbGetTime(CurrentTime));
        KerbUnlockTicketCache();
    }

    //
    // Allocate a nonce if we don't have one already.
    //

    if (*Nonce == 0)
    {
        *Nonce = KerbAllocateNonce();
    }

    D_DebugLog((DEB_TRACE,"BuildApRequest using nonce 0x%x\n",*Nonce));
    KerbReadLockLogonSessions(LogonSession);
    LogonSessionLocked = TRUE;

    if (ARGUMENT_PRESENT(Credential))
    {
        if (Credential->SuppliedCredentials != NULL)
        {
            PrimaryCredentials = Credential->SuppliedCredentials;
        }
    }

    // use cred manager creds if present
    if (ARGUMENT_PRESENT(CredManCredentials))
    {
        PrimaryCredentials = CredManCredentials->SuppliedCredentials;
    }

    if (PrimaryCredentials == NULL)
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }

    //
    // get the GSS checksum
    //

    Status = KerbBuildGssChecksum(
                LogonSession,
                PrimaryCredentials,
                TicketCacheEntry,
                ContextFlags,
                &GssChecksum,
                &ApOptions,
                pChannelBindings
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to build GSS checksum: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // If are an export client, create a subsession key. For datagram,
    // the caller passes in a pre-generated session key.
    //

    //
    // For datagram, they subsession key has already been set so we don't need
    // to create one here.
    //

    if ((((*ContextFlags & ISC_RET_DATAGRAM) == 0)) ||
        (((*ContextFlags & (ISC_RET_USED_DCE_STYLE | ISC_RET_MUTUAL_AUTH)) == 0) && !KerbGlobalUseStrongEncryptionForDatagram))
    {
        KERBERR KerbErr;

        //
        // First free the Subsession key, if there was one.
        //


        KerbFreeKey(SubSessionKey);

        if (!StrongEncryptionPermitted)
        {
            D_DebugLog((DEB_TRACE_CTXT,"Making exportable key on client\n"));

            //
            // First free the Subsession key, if there was one.
            //


            KerbErr = KerbMakeExportableKey(
                        TicketCacheEntry->SessionKey.keytype,
                        SubSessionKey
                        );
        }
        else
        {

            KerbErr = KerbMakeKey(
                        TicketCacheEntry->SessionKey.keytype,
                        SubSessionKey
                        );
        }
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
    }

    //
    // Create the AP request
    //


    KerbReadLockTicketCache();

    KerbErr = KerbCreateApRequest(
                TicketCacheEntry->ClientName,
                &TicketCacheEntry->ClientDomainName,
                &TicketCacheEntry->SessionKey,
                (SubSessionKey->keyvalue.value != NULL) ? SubSessionKey : NULL,
                *Nonce,
                &TicketCacheEntry->Ticket,
                ApOptions,
                &GssChecksum,
                &TicketCacheEntry->TimeSkew,
                FALSE,                          // not a KDC request
                ApRequestSize,
                MarshalledApRequest
                );

    KerbUnlockTicketCache();
    KerbUnlockLogonSessions(LogonSession);
    LogonSessionLocked = FALSE;

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to create AP request: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    //
    // If we aren't doing DCE style, add in the GSS token headers now
    //

    if ((*ContextFlags & ISC_RET_USED_DCE_STYLE) != 0)
    {
       goto Cleanup;
    }

    //
    // Pick the correct OID
    //


    if ((ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechId = gss_mech_krb5_u2u;
    }
    else
    {
        MechId = gss_mech_krb5_new;
    }

    RequestSize = g_token_size(MechId, *ApRequestSize);
    RequestWithHeader = (PUCHAR) KerbAllocate(RequestSize);
    if (RequestWithHeader == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // the g_make_token_header will reset this to point to the end of the
    // header
    //

    RequestStart = RequestWithHeader;

    g_make_token_header(
        MechId,
        *ApRequestSize,
        &RequestStart,
        KG_TOK_CTX_AP_REQ
        );

    DsysAssert(RequestStart - RequestWithHeader + *ApRequestSize == RequestSize);

    RtlCopyMemory(
        RequestStart,
        *MarshalledApRequest,
        *ApRequestSize
        );

    KerbFree(*MarshalledApRequest);
    *MarshalledApRequest = RequestWithHeader;
    *ApRequestSize = RequestSize;
    RequestWithHeader = NULL;

Cleanup:

    if (LogonSessionLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }
    if (GssChecksum.checksum.value != NULL)
    {
        KerbFree(GssChecksum.checksum.value);
    }
    if (!NT_SUCCESS(Status) && (*MarshalledApRequest != NULL))
    {
        KerbFree(*MarshalledApRequest);
        *MarshalledApRequest = NULL;
    }
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildNullSessionApRequest
//
//  Synopsis:   builds an AP request for a null session
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbBuildNullSessionApRequest(
    OUT PUCHAR * MarshalledApRequest,
    OUT PULONG ApRequestSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KERB_AP_REQUEST ApRequest;
    UNICODE_STRING NullString = CONSTANT_UNICODE_STRING(L"");
    UCHAR TempBuffer[1];
    ULONG RequestSize;
    PUCHAR RequestWithHeader = NULL;
    PUCHAR RequestStart;

    RtlZeroMemory(
        &ApRequest,
        sizeof(KERB_AP_REQUEST)
        );


    TempBuffer[0] = '\0';

    //
    // Fill in the AP request structure.
    //

    ApRequest.version = KERBEROS_VERSION;
    ApRequest.message_type = KRB_AP_REQ;

    //
    // Fill in mandatory fields - ASN1/OSS requires this
    //

    if (!KERB_SUCCESS(KerbConvertStringToPrincipalName(
            &ApRequest.ticket.server_name,
            &NullString,
            KRB_NT_UNKNOWN
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbConvertUnicodeStringToRealm(
            &ApRequest.ticket.realm,
            &NullString
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ApRequest.ticket.encrypted_part.cipher_text.length = 1;
    ApRequest.ticket.encrypted_part.cipher_text.value = TempBuffer;
    ApRequest.authenticator.cipher_text.length = 1;
    ApRequest.authenticator.cipher_text.value = TempBuffer;


    //
    // Now marshall the request
    //

    KerbErr = KerbPackApRequest(
                &ApRequest,
                ApRequestSize,
                MarshalledApRequest
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to pack AP request: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Since we never do null sessions with user-to-user, we don't have
    // to worry about which mech id to use
    //

    RequestSize = g_token_size((gss_OID) gss_mech_krb5_new, *ApRequestSize);

    RequestWithHeader = (PUCHAR) KerbAllocate(RequestSize);
    if (RequestWithHeader == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // the g_make_token_header will reset this to point to the end of the
    // header
    //

    RequestStart = RequestWithHeader;

    g_make_token_header(
        (gss_OID) gss_mech_krb5_new,
        *ApRequestSize,
        &RequestStart,
        KG_TOK_CTX_AP_REQ
        );

    DsysAssert(RequestStart - RequestWithHeader + *ApRequestSize == RequestSize);

    RtlCopyMemory(
        RequestStart,
        *MarshalledApRequest,
        *ApRequestSize
        );

    KerbFree(*MarshalledApRequest);
    *MarshalledApRequest = RequestWithHeader;
    *ApRequestSize = RequestSize;
    RequestWithHeader = NULL;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (*MarshalledApRequest != NULL)
        {
            MIDL_user_free(*MarshalledApRequest);
            *MarshalledApRequest = NULL;
        }
    }
    KerbFreeRealm(&ApRequest.ticket.realm);
    KerbFreePrincipalName(&ApRequest.ticket.server_name);
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeSocketCall
//
//  Synopsis:   Contains logic for sending a message to a KDC in the
//              specified realm on a specified port
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMakeSocketCall(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN BOOLEAN CallPDC,
    IN BOOLEAN UseTcp,
    IN BOOLEAN CallKpasswd,
    IN PKERB_MESSAGE_BUFFER RequestMessage,
    IN PKERB_MESSAGE_BUFFER ReplyMessage,
    IN OPTIONAL PKERB_BINDING_CACHE_ENTRY OptionalBindingHandle,
    IN ULONG AdditionalFlags,
    OUT PBOOLEAN CalledPDC
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Retries;
    PKERB_BINDING_CACHE_ENTRY BindingHandle = NULL;
    ULONG DesiredFlags;
    ULONG Timeout = KerbGlobalKdcCallTimeout;


    //
    // If the caller wants a PDC, so be it
    //

    *CalledPDC = FALSE;

    if (CallPDC)
    {
        DesiredFlags = DS_PDC_REQUIRED;
    }
    else
    {
        DesiredFlags = 0;
    }

    //
    // Now actually get the ticket. We will retry twice.
    //
    if ((AdditionalFlags & DS_FORCE_REDISCOVERY) != 0)
    {
       DesiredFlags |= DS_FORCE_REDISCOVERY;
       D_DebugLog((DEB_TRACE,"KerbMakeSocketCall() caller wants rediscovery!\n"));
    }

    Retries = 0;
    do
    {


        //
        // don't force retry the first time
        //

        if (Retries > 0)
        {
            DesiredFlags |= DS_FORCE_REDISCOVERY;
            Timeout += KerbGlobalKdcCallBackoff;
        }

        // Use ADSI supplied info, then retry using cached version
        if (ARGUMENT_PRESENT(OptionalBindingHandle) && (Retries == 0))
        {
           BindingHandle = OptionalBindingHandle;
        }
        else
        {
           Status = KerbGetKdcBinding(
                    RealmName,
                    AccountName,
                    DesiredFlags,
                    CallKpasswd,
                    UseTcp,
                    &BindingHandle
                    );
        }

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_WARN,"Failed to get KDC binding for %wZ: 0x%x\n",
                RealmName, Status));
            goto Cleanup;
        }

        //
        // If the KDC doesn't support TCP, don't use TCP. Otherwise
        // use it if the sending buffer is too big, or if it was already
        // set.
        //

        if ((BindingHandle->CacheFlags & KERB_BINDING_NO_TCP) != 0)
        {
            UseTcp = FALSE;
        }
        else
        {
            if  (RequestMessage->BufferSize > KerbGlobalMaxDatagramSize)
            {
                UseTcp = TRUE;
            }
        }

        //
        // Lock the binding while we make the call
        //

        if (!*CalledPDC)
        {
            *CalledPDC = (BindingHandle->Flags & DS_PDC_REQUIRED) ? TRUE : FALSE;
        }

#ifndef WIN32_CHICAGO
        if ((BindingHandle->CacheFlags & KERB_BINDING_LOCAL) != 0)
        {
            KERB_MESSAGE_BUFFER KdcReplyMessage = {0};
            if (!CallKpasswd)
            {

                D_DebugLog((DEB_TRACE,"Calling kdc directly\n"));

                DsysAssert(KerbKdcGetTicket != NULL);
                KerbErr = (*KerbKdcGetTicket)(
                            NULL,           // no context,
                            NULL,           // no client address
                            NULL,           // no server address
                            RequestMessage,
                            &KdcReplyMessage
                            );
            }
            else
            {
                DsysAssert(KerbKdcChangePassword != NULL);
                KerbErr = (*KerbKdcChangePassword)(
                            NULL,           // no context,
                            NULL,           // no client address
                            NULL,           // no server address
                            RequestMessage,
                            &KdcReplyMessage
                            );
            }
            if (KerbErr != KDC_ERR_NOT_RUNNING)
            {
                //
                // Copy the data so it can be freed with MIDL_user_free.
                //

                ReplyMessage->BufferSize = KdcReplyMessage.BufferSize;
                ReplyMessage->Buffer = (PUCHAR) MIDL_user_allocate(
                        KdcReplyMessage.BufferSize);
                if (ReplyMessage->Buffer != NULL)
                {
                    RtlCopyMemory(
                        ReplyMessage->Buffer,
                        KdcReplyMessage.Buffer,
                        KdcReplyMessage.BufferSize
                        );
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
                (*KerbKdcFreeMemory)(KdcReplyMessage.Buffer);
                goto Cleanup;

            }
            else
            {
                //
                // The KDC said it wasn't running.
                //

                KerbKdcStarted = FALSE;
                Status = STATUS_NETLOGON_NOT_STARTED;

                //
                // Get rid of the binding handle so we don't use it again.
                // Don't whack supplied optional binding handle though
                //
                if (BindingHandle != OptionalBindingHandle)
                {
                   KerbRemoveBindingCacheEntry( BindingHandle );
                }

            }

        }

        else
#endif // WIN32_CHICAGO
        {
            DebugLog((DEB_TRACE,"Calling kdc %wZ for realm %S\n",&BindingHandle->KdcAddress, RealmName->Buffer));
            Status =  KerbCallKdc(
                        &BindingHandle->KdcAddress,
                        BindingHandle->AddressType,
                        Timeout,
                        !UseTcp,
                        CallKpasswd ? KERB_KPASSWD_PORT : KERB_KDC_PORT,
                        RequestMessage,
                        ReplyMessage
                        );

            if (!NT_SUCCESS(Status) )
            {
                //
                // If the request used UDP and we got an invalid buffer size error,
                // try again with TCP.
                //

                if ((Status == STATUS_INVALID_BUFFER_SIZE) && (!UseTcp)) {

                    if ((BindingHandle->CacheFlags & KERB_BINDING_NO_TCP) == 0)
                    {

                        UseTcp = TRUE;
                        Status =  KerbCallKdc(
                                    &BindingHandle->KdcAddress,
                                    BindingHandle->AddressType,
                                    Timeout,
                                    !UseTcp,
                                    CallKpasswd ? KERB_KPASSWD_PORT : KERB_KDC_PORT,
                                    RequestMessage,
                                    ReplyMessage
                                    );
                    }

                }

                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"Failed to get make call to KDC %wZ: 0x%x. %ws, line %d\n",
                        &BindingHandle->KdcAddress,Status, THIS_FILE, __LINE__));
                    //
                    // The call itself failed, so the binding handle was bad.
                    // Free it now, unless supplied as optional binding handle.
                    //
                    if (BindingHandle != OptionalBindingHandle)
                    {
                       KerbRemoveBindingCacheEntry( BindingHandle );
                    }

                }

            }

        }

        if (BindingHandle != OptionalBindingHandle)
        {
           KerbDereferenceBindingCacheEntry( BindingHandle );
           Retries++;
        }

        BindingHandle = NULL;

        } while ( !NT_SUCCESS(Status) && (Retries < KerbGlobalKdcSendRetries) );


Cleanup:
    if ((BindingHandle != NULL) && (BindingHandle != OptionalBindingHandle))
    {
        KerbDereferenceBindingCacheEntry(BindingHandle);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeKdcCall
//
//  Synopsis:   Contains logic for calling a KDC including binding and
//              retrying.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMakeKdcCall(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN BOOLEAN CallPDC,
    IN BOOLEAN UseTcp,
    IN PKERB_MESSAGE_BUFFER RequestMessage,
    IN PKERB_MESSAGE_BUFFER ReplyMessage,
    IN ULONG AdditionalFlags,
    OUT PBOOLEAN CalledPDC
    )
{

   if (ARGUMENT_PRESENT(AccountName))
   {
      D_DebugLog((DEB_ERROR, "[trace info] Making DsGetDcName w/ account name\n"));
   }

   return(KerbMakeSocketCall(
            RealmName,
            AccountName,
            CallPDC,
            UseTcp,
            FALSE,                      // don't call Kpasswd
            RequestMessage,
            ReplyMessage,
            NULL, // optional binding cache handle, for kpasswd only
            AdditionalFlags,
            CalledPDC
            ));
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbComputeTgsChecksum
//
//  Synopsis:   computes the checksum of a TGS request body by marshalling
//              the request and the checksumming it.
//
//  Effects:    Allocates destination with KerbAllocate().
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbComputeTgsChecksum(
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG ChecksumType,
    OUT PKERB_CHECKSUM Checksum
    )
{
    PCHECKSUM_FUNCTION ChecksumFunction;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    KERB_MESSAGE_BUFFER MarshalledRequestBody = {0, NULL};
    NTSTATUS Status;

    RtlZeroMemory(
        Checksum,
        sizeof(KERB_CHECKSUM)
        );

    Status = CDLocateCheckSum(
                ChecksumType,
                &ChecksumFunction
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Allocate enough space for the checksum
    //

    Checksum->checksum.value = (PUCHAR) KerbAllocate(ChecksumFunction->CheckSumSize);
    if (Checksum->checksum.value == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Checksum->checksum.length = ChecksumFunction->CheckSumSize;
    Checksum->checksum_type = (int) ChecksumType;

    // don't av here.

    if ((ChecksumType == KERB_CHECKSUM_REAL_CRC32) ||
        (ChecksumType == KERB_CHECKSUM_CRC32))
    {
        if (ChecksumFunction->Initialize)
        {
            Status = ChecksumFunction->Initialize(
                    0,
                    &CheckBuffer
                    );
        }
        else
        {
            Status = STATUS_CRYPTO_SYSTEM_INVALID;
        }
    }
    else
    {
        if (ChecksumFunction->InitializeEx2)
        {
            Status = ChecksumFunction->InitializeEx2(
                    Key->keyvalue.value,
                    (ULONG) Key->keyvalue.length,
                    NULL,
                    KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                    &CheckBuffer
                    );
        }
        else if (ChecksumFunction->InitializeEx)
        {
            Status = ChecksumFunction->InitializeEx(
                    Key->keyvalue.value,
                    (ULONG) Key->keyvalue.length,
                    KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                    &CheckBuffer
                    );
        }
        else
        {
            Status = STATUS_CRYPTO_SYSTEM_INVALID;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbPackData(
                        RequestBody,
                        KERB_MARSHALLED_REQUEST_BODY_PDU,
                        &MarshalledRequestBody.BufferSize,
                        &MarshalledRequestBody.Buffer
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now checksum the buffer
    //

    ChecksumFunction->Sum(
        CheckBuffer,
        MarshalledRequestBody.BufferSize,
        MarshalledRequestBody.Buffer
        );

    ChecksumFunction->Finalize(
        CheckBuffer,
        Checksum->checksum.value
        );


Cleanup:
    if (CheckBuffer != NULL)
    {
        ChecksumFunction->Finish(&CheckBuffer);
    }
    if (MarshalledRequestBody.Buffer != NULL)
    {
        MIDL_user_free(MarshalledRequestBody.Buffer);
    }
    if (!NT_SUCCESS(Status) && (Checksum->checksum.value != NULL))
    {
        MIDL_user_free(Checksum->checksum.value);
        Checksum->checksum.value = NULL;
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTgsTicket
//
//  Synopsis:   Gets a ticket to the specified target with the specified
//              options.
//
//  Effects:
//
//  Arguments:  ClientRealm
//              TicketGrantingTicket - TGT to use for the TGS request
//              TargetName - Name of the target for which to obtain a ticket.
//              TicketOptions - Optionally contains requested KDC options flags
//              Flags
//              TicketOptions
//              EncryptionType - Optionally contains requested encryption type
//              AuthorizationData - Optional authorization data to stick
//                      in the ticket.
//              KdcReply - the ticket to be used for getting a ticket with
//                      the enc_tkt_in_skey flag.
//              ReplyBody - Receives the kdc reply.
//              pRetryFlags
//
//  Requires:
//
//  Returns:    Kerberos errors and NT errors
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetTgsTicket(
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket,
    IN PKERB_INTERNAL_NAME TargetName,
    IN ULONG Flags,
    IN OPTIONAL ULONG TicketOptions,
    IN OPTIONAL ULONG EncryptionType,
    IN OPTIONAL PKERB_AUTHORIZATION_DATA AuthorizationData,
    IN OPTIONAL PKERB_PA_DATA_LIST PADataList,
    IN OPTIONAL PKERB_TGT_REPLY TgtReply,
    OUT PKERB_KDC_REPLY * KdcReply,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody,
    OUT PULONG pRetryFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_KDC_REQUEST TicketRequest;
    PKERB_KDC_REQUEST_BODY RequestBody = &TicketRequest.request_body;
    PKERB_SPN_CACHE_ENTRY SpnCacheEntry = NULL;
    PULONG CryptVector = NULL;
    ULONG EncryptionTypeCount = 0;
    PKERB_EXT_ERROR pExtendedError = NULL;
    ULONG Nonce;
    KERB_PA_DATA_LIST ApRequest = {0};
    KERBERR KerbErr;
    KERB_MESSAGE_BUFFER RequestMessage = {0, NULL};
    KERB_MESSAGE_BUFFER ReplyMessage = {0, NULL};
    BOOLEAN DoRetryGetTicket = FALSE;
    BOOLEAN RetriedOnce = FALSE;
    UNICODE_STRING TempDomainName = NULL_UNICODE_STRING;
    KERB_CHECKSUM RequestChecksum = {0};
    BOOLEAN CalledPdc;
    KERB_TICKET_LIST TicketList;
    ULONG KdcOptions = 0;
    ULONG KdcFlagOptions;
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN UsedAlternateName = FALSE;
    BOOLEAN UseTcp = FALSE;
    BOOLEAN fMitRealmPossibleRetry = FALSE;

    KERB_ENCRYPTED_DATA EncAuthData = {0};

#ifdef RESTRICTED_TOKEN

     if (AuthorizationData != NULL)
     {
         Status = KerbBuildEncryptedAuthData(
                    &EncAuthData,
                    TicketGrantingTicket,
                    AuthorizationData
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to encrypt auth data: 0x%x\n",Status));
            goto Cleanup;
        }
     }
#endif

    //
    // This is the retry point if we need to retry getting a TGS ticket
    //

RetryGetTicket:

    RtlZeroMemory(
        &ApRequest,
        sizeof(KERB_PA_DATA_LIST)
        );

    RtlZeroMemory(
        &RequestChecksum,
        sizeof(KERB_CHECKSUM)
        );

    RtlZeroMemory(
        &TicketRequest,
        sizeof(KERB_KDC_REQUEST)
        );

    *KdcReply = NULL;
    *ReplyBody = NULL;

    //
    // Fill in the ticket request with the defaults.
    //

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &KerbGlobalWillNeverTime // use HasNeverTime instead
        );

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &KerbGlobalHasNeverTime // use HasNeverTime instead
        );

    //
    // If the caller supplied kdc options, use those
    //

    if (TicketOptions != 0)
    {
        KdcOptions = TicketOptions;
    }
    else
    {
        //
        // Some missing (TGT) ticket options will result in a ticket not being
        // granted.  Others (such as name_canon.) will be usable by W2k KDCs
        // Make sure we can modify these so we can turn "on" various options
        // later.
        //
        KdcOptions = (KERB_DEFAULT_TICKET_FLAGS &
                      TicketGrantingTicket->TicketFlags) |
                      KerbGlobalKdcOptions;
    }

    Nonce = KerbAllocateNonce();

    RequestBody->nonce = Nonce;
    if (AuthorizationData != NULL)
    {
        RequestBody->enc_authorization_data = EncAuthData;
        RequestBody->bit_mask |= enc_authorization_data_present;
    }

    //
    // Build crypt vector.
    //

    //
    // First get the count of encryption types
    //

    (VOID) CDBuildIntegrityVect( &EncryptionTypeCount, NULL );

    //
    // Now allocate the crypt vector
    //

    CryptVector = (PULONG) KerbAllocate(sizeof(ULONG) * EncryptionTypeCount );
    if (CryptVector == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now get the list of encrypt types
    //

    (VOID) CDBuildIntegrityVect( &EncryptionTypeCount, CryptVector );

    if (EncryptionTypeCount == 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If caller didn't specify a favorite etype, send all that we support
    //

    if (EncryptionType != 0)
    {
        //
        // Swap the first one with the encryption type requested.
        // do this only if the first isn't already what is requested.
        //

        UINT i = 0;
        ULONG FirstOne = CryptVector[0];
        if (CryptVector[i] != EncryptionType)
        {

            CryptVector[i] = EncryptionType;
            for ( i = 1; i < EncryptionTypeCount;i++)
            {
                if (CryptVector[i] == EncryptionType)
                {
                    CryptVector[i] = FirstOne;
                    break;
                }
            }
        }
    }

    //
    // convert the array to a crypt list in the request
    //

    if (!KERB_SUCCESS(KerbConvertArrayToCryptList(
                        &RequestBody->encryption_type,
                        CryptVector,
                        EncryptionTypeCount)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If a TGT reply is present, stick the TGT into the ticket in the
    // additional tickets field and include set the enc_tkt_in_skey option.
    // The ticket that comes back will be encrypted with the session key
    // from the supplied TGT.
    //

    if (ARGUMENT_PRESENT( TgtReply ))
    {
        D_DebugLog((DEB_TRACE_U2U, "KerbGetTgsTicket setting KERB_KDC_OPTIONS_enc_tkt_in_skey\n"));

        TicketList.next = NULL;
        TicketList.value = TgtReply->ticket;
        RequestBody->additional_tickets = &TicketList;
        RequestBody->bit_mask |= additional_tickets_present;
        KdcOptions |= KERB_KDC_OPTIONS_enc_tkt_in_skey;
    }

    //
    // Fill in the strings in the ticket request
    //

    if (!KERB_SUCCESS(KerbConvertKdcNameToPrincipalName(
                        &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                        TargetName
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;


    //
    // Copy the domain name so we don't need to hold the lock
    //

    Status = KerbDuplicateString(
                &TempDomainName,
                &TicketGrantingTicket->TargetDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Check if this is an MIT kdc or if the spn had a realm in it (e.g,
    // a/b/c@realm - if so, turn off name canonicalization
    //

    if ((Flags & KERB_GET_TICKET_NO_CANONICALIZE) != 0)
    {
        KdcOptions &= ~KERB_KDC_OPTIONS_name_canonicalize;
    }
    else if (KerbLookupMitRealm(
                &TempDomainName,
                &MitRealm,
                &UsedAlternateName
                ))
    {
        //
        // So the user is getting a ticket from an MIT realm. This means
        // if the MIT realm flags don't indicate that name canonicalization
        // is supported then we don't ask for name canonicalization
        //

        if ((MitRealm->Flags & KERB_MIT_REALM_DOES_CANONICALIZE) == 0)
        {
            fMitRealmPossibleRetry = TRUE;
            KdcOptions &= ~KERB_KDC_OPTIONS_name_canonicalize;
        }

        else
        {
            KdcOptions |= KERB_KDC_OPTIONS_name_canonicalize;
        }

    }

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KdcOptions);
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions;

    //
    // Marshall the request and compute a checksum of it
    //

    if (!KERB_SUCCESS(KerbConvertUnicodeStringToRealm(
                        &RequestBody->realm,
                        &TempDomainName
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbReadLockTicketCache();

    //
    // Now compute a checksum of that data
    //

    Status = KerbComputeTgsChecksum(
                RequestBody,
                &TicketGrantingTicket->SessionKey,
                (MitRealm != NULL) ? MitRealm->ApReqChecksumType : KERB_DEFAULT_AP_REQ_CSUM,
                &RequestChecksum
                );
    if (!NT_SUCCESS(Status))
    {
        KerbUnlockTicketCache();
        goto Cleanup;
    }

    //
    // Create the AP request to the KDC for the ticket to the service
    //

RetryWithTcp:

    //
    // Lock the ticket cache while we access the cached tickets
    //

    KerbErr = KerbCreateApRequest(
                TicketGrantingTicket->ClientName,
                ClientRealm,
                &TicketGrantingTicket->SessionKey,
                NULL,                           // no subsessionkey
                Nonce,
                &TicketGrantingTicket->Ticket,
                0,                              // no AP options
                &RequestChecksum,
                &TicketGrantingTicket->TimeSkew, // server time
                TRUE,                           // kdc request
                (PULONG) &ApRequest.value.preauth_data.length,
                &ApRequest.value.preauth_data.value
                );

    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to create authenticator: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ApRequest.next = NULL;
    ApRequest.value.preauth_data_type = KRB5_PADATA_TGS_REQ;
    TicketRequest.KERB_KDC_REQUEST_preauth_data = &ApRequest;
    TicketRequest.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;

    // Insert additonal preauth into list
    if (ARGUMENT_PRESENT(PADataList))
    {
        // better be NULL padatalist
        ApRequest.next = PADataList;
    }
    else
    {
        ApRequest.next = NULL;
    }

    //
    // Marshall the request
    //

    TicketRequest.version = KERBEROS_VERSION;
    TicketRequest.message_type = KRB_TGS_REQ;

    //
    // Pack the request
    //

    KerbErr = KerbPackTgsRequest(
                &TicketRequest,
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now actually get the ticket. We will retry once.
    //

    Status = KerbMakeKdcCall(
                &TempDomainName,
                NULL,           // **NEVER* call w/ account
                FALSE,          // don't require PDC
                UseTcp,
                &RequestMessage,
                &ReplyMessage,
                0, // no additional flags (yet)
                &CalledPdc
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to call KDC for TGS request: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    KerbErr = KerbUnpackTgsReply(
                ReplyMessage.Buffer,
                ReplyMessage.BufferSize,
                KdcReply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        PKERB_ERROR ErrorMessage = NULL;
        D_DebugLog((DEB_WARN,"Failed to unpack KDC reply: 0x%x\n",
            KerbErr ));

        //
        // Try to unpack it as  kerb_error
        //

        KerbErr =  KerbUnpackKerbError(
                        ReplyMessage.Buffer,
                        ReplyMessage.BufferSize,
                        &ErrorMessage
                        );
        if (KERB_SUCCESS(KerbErr))
        {
           if (ErrorMessage->bit_mask & error_data_present)
           {
               KerbUnpackErrorData(
                   ErrorMessage,
                   &pExtendedError
                   );
           }

           KerbErr = (KERBERR) ErrorMessage->error_code;

           KerbReportKerbError(
                TargetName,
                &TempDomainName,
                NULL,
                NULL,
                KLIN(FILENO, __LINE__),
                ErrorMessage,
                KerbErr,
                pExtendedError,
                FALSE
                );


            //
            // Check for time skew. If we got a skew error, record the time
            // skew between here and the KDC in the ticket so we can retry
            // with the correct time.
            //

            if (KerbErr == KRB_AP_ERR_SKEW)
            {
                TimeStamp CurrentTime;
                TimeStamp KdcTime;

                //
                // Only update failures with the same ticket once
                //

                if (KerbGetTime(TicketGrantingTicket->TimeSkew) == 0)
                {
                    KerbUpdateSkewTime(TRUE);
                }

                GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);


                KerbConvertGeneralizedTimeToLargeInt(
                    &KdcTime,
                    &ErrorMessage->server_time,
                    ErrorMessage->server_usec
                    );

                KerbWriteLockTicketCache();

#if 0
                D_DebugLog(( DEB_WARN, "KDC time : \n" ));
                DebugDisplayTime( DEB_WARN, (PFILETIME)&KdcTime);
                D_DebugLog(( DEB_WARN, "Current time : \n" ));
                DebugDisplayTime( DEB_WARN, (PFILETIME)&CurrentTime);
#endif
                KerbSetTime(&TicketGrantingTicket->TimeSkew, KerbGetTime(KdcTime) - KerbGetTime(CurrentTime));

                KerbUnlockTicketCache();
                DoRetryGetTicket = TRUE;
            }
            else if ((KerbErr == KRB_ERR_RESPONSE_TOO_BIG) && (!UseTcp))
            {
                //
                // The KDC response was too big to fit in a datagram. If
                // we aren't already using TCP use it now.
                //
                UseTcp = TRUE;
                KerbFreeKerbError(ErrorMessage);
                ErrorMessage = NULL;
                MIDL_user_free(ReplyMessage.Buffer);
                ReplyMessage.Buffer = NULL;
                KerbReadLockTicketCache();
                goto RetryWithTcp;

            }
            else if (KerbErr == KDC_ERR_S_PRINCIPAL_UNKNOWN)
            {
                if (EXT_CLIENT_INFO_PRESENT(pExtendedError) && (STATUS_USER2USER_REQUIRED == pExtendedError->status))
                {
                    DebugLog((DEB_WARN, "KerbGetTgsTicket received KDC_ERR_S_PRINCIPAL_UNKNOWN and STATUS_USER2USER_REQUIRED\n"));
                    Status = STATUS_USER2USER_REQUIRED;
                    KerbFreeKerbError(ErrorMessage);
                    goto Cleanup;
                }
                //
                // This looks to be the MIT Realm retry case, where name canonicalization
                // is not on and the PRINCIPAL_UNKNOWN was returned by the MIT KDC
                //
                else if (fMitRealmPossibleRetry)
                {
                    *pRetryFlags |= KERB_MIT_NO_CANONICALIZE_RETRY;
                    D_DebugLog((DEB_TRACE,"KerbCallKdc: this is the MIT retry case\n"));
                }
            }

            //
            // Semi-hack here.  Bad option rarely is returned, and usually
            // indicates your TGT is about to expire.  TKT_EXPIRED is also
            // potentially recoverable. Check the e_data to
            // see if we should blow away TGT to fix TGS problem.
            //
            else if ((KerbErr == KDC_ERR_BADOPTION) ||
                     (KerbErr == KRB_AP_ERR_TKT_EXPIRED))
            {
                if (NULL != pExtendedError)
                {
                    Status = pExtendedError->status;
                    if (Status == STATUS_TIME_DIFFERENCE_AT_DC)
                    {
                        *pRetryFlags |= KERB_RETRY_WITH_NEW_TGT;
                        D_DebugLog((DEB_TRACE, "Hit bad option retry case - %x \n", KerbErr));
                    }
                }
            }
            //
            // Per bug 315833, we purge on these errors as well
            //
            else if ((KerbErr == KDC_ERR_C_OLD_MAST_KVNO) ||
                     (KerbErr == KDC_ERR_CLIENT_REVOKED) ||
                     (KerbErr == KDC_ERR_TGT_REVOKED) ||
                     (KerbErr == KDC_ERR_NEVER_VALID) ||
                     (KerbErr == KRB_AP_ERR_BAD_INTEGRITY))
            {
                *pRetryFlags |= KERB_RETRY_WITH_NEW_TGT;
                D_DebugLog((DEB_TRACE, "Got error requiring new tgt\n"));
            }
            else if (KerbErr == KDC_ERR_NONE)
            {
                DebugLog((DEB_ERROR, "KerbGetTgsTicket KerbCallKdc: error KDC_ERR_NONE\n"));
                KerbErr = KRB_ERR_GENERIC;
            }

            KerbFreeKerbError(ErrorMessage);
            DebugLog((DEB_WARN,"KerbCallKdc: error 0x%x\n",KerbErr));
            Status = KerbMapKerbError(KerbErr);
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    //
    // Now unpack the reply body:
    //

    KerbReadLockTicketCache();

    KerbErr = KerbUnpackKdcReplyBody(
                &(*KdcReply)->encrypted_part,
                &TicketGrantingTicket->SessionKey,
                KERB_ENCRYPTED_TGS_REPLY_PDU,
                ReplyBody
                );

    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to decrypt KDC reply body: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Verify the nonce is correct:
    //

    if (RequestBody->nonce != (*ReplyBody)->nonce)
    {
        D_DebugLog((DEB_ERROR,"AS Nonces don't match: 0x%x vs 0x%x. %ws, line %d\n",
            RequestBody->nonce,
            (*ReplyBody)->nonce, THIS_FILE, __LINE__));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }


Cleanup:

    if (EncAuthData.cipher_text.value != NULL)
    {
        MIDL_user_free(EncAuthData.cipher_text.value);
    }
    if (RequestChecksum.checksum.value != NULL)
    {
        KerbFree(RequestChecksum.checksum.value);
    }

    if (CryptVector != NULL)
    {
        KerbFree(CryptVector);
        CryptVector = NULL;
    }

    KerbFreeCryptList(
        RequestBody->encryption_type
        );


    if (ReplyMessage.Buffer != NULL)
    {
        MIDL_user_free(ReplyMessage.Buffer);
        ReplyMessage.Buffer = NULL;
    }

    if (RequestMessage.Buffer != NULL)
    {
        MIDL_user_free(RequestMessage.Buffer);
        RequestMessage.Buffer = NULL;
    }

    if (ApRequest.value.preauth_data.value != NULL)
    {
        MIDL_user_free(ApRequest.value.preauth_data.value);
        ApRequest.value.preauth_data.value = NULL;
    }


    KerbFreePrincipalName(
        &RequestBody->KERB_KDC_REQUEST_BODY_server_name
        );

    KerbFreeRealm(
        &RequestBody->realm
        );
    KerbFreeString(
        &TempDomainName
        );

    if (RequestMessage.Buffer != NULL)
    {
        MIDL_user_free(RequestMessage.Buffer);
    }

    if (ApRequest.value.preauth_data.value != NULL)
    {
        MIDL_user_free(ApRequest.value.preauth_data.value);
        ApRequest.value.preauth_data.value = NULL;
    }

    if (NULL != pExtendedError)
    {
       KerbFreeData(KERB_EXT_ERROR_PDU, pExtendedError);
       pExtendedError = NULL;
    }

    //
    // If we should retry getting the ticket and we haven't already retried
    // once, try again.
    //

    if (DoRetryGetTicket && !RetriedOnce)
    {
        RetriedOnce = TRUE;
        goto RetryGetTicket;
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetReferralNames
//
//  Synopsis:   Gets the referral names from a KDC reply. If none are present,
//              returned strings are empty.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetReferralNames(
    IN PKERB_ENCRYPTED_KDC_REPLY KdcReply,
    IN PKERB_INTERNAL_NAME OriginalTargetName,
    OUT PUNICODE_STRING ReferralRealm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST PaEntry;
    PKERB_PA_SERV_REFERRAL ReferralInfo = NULL;
    KERBERR KerbErr;
    PKERB_INTERNAL_NAME TargetName = NULL;
    PKERB_INTERNAL_NAME KpasswdName = NULL;

    RtlInitUnicodeString(
        ReferralRealm,
        NULL
        );


    PaEntry = (PKERB_PA_DATA_LIST) KdcReply->encrypted_pa_data;

    //
    // Search the list for the referral infromation
    //

    while (PaEntry != NULL)
    {
        if (PaEntry->value.preauth_data_type == KRB5_PADATA_REFERRAL_INFO)
        {
            break;
        }
        PaEntry = PaEntry->next;
    }
    if (PaEntry == NULL)
    {

        //
        // Check to see if the server name is krbtgt - if it is, then
        // this is a referral.
        //

        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &TargetName,
                    &KdcReply->server_name
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        //
        // Build the service name for the ticket
        //

        Status = KerbBuildKpasswdName(
                    &KpasswdName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if ((TargetName->NameCount == 2) &&
             RtlEqualUnicodeString(
                    &KerbGlobalKdcServiceName,
                    &TargetName->Names[0],
                    FALSE                               // not case sensitive
                    ) &&
            !(KerbEqualKdcNames(
                OriginalTargetName,
                TargetName) ||
             KerbEqualKdcNames(
                OriginalTargetName,
                KpasswdName) ))
        {
                //
                // This is a referral, so set the referral name to the
                // second portion of the name
                //

                Status = KerbDuplicateString(
                            ReferralRealm,
                            &TargetName->Names[1]
                            );
        }

        KerbFreeKdcName(&TargetName);
        KerbFreeKdcName(&KpasswdName);

        return(Status);
    }

    //
    // Now try to unpack the data
    //

    KerbErr = KerbUnpackData(
                PaEntry->value.preauth_data.value,
                PaEntry->value.preauth_data.length,
                KERB_PA_SERV_REFERRAL_PDU,
                (PVOID *) &ReferralInfo
                );
    if (!KERB_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to decode referral info: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
            ReferralRealm,
            &ReferralInfo->referred_server_realm
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

Cleanup:

    KerbFreeKdcName(&TargetName);
    KerbFreeKdcName(&KpasswdName);

    if (ReferralInfo != NULL)
    {
        KerbFreeData(
            KERB_PA_SERV_REFERRAL_PDU,
            ReferralInfo
            );
    }
    if (!NT_SUCCESS(Status))
    {
        KerbFreeString(
            ReferralRealm
            );
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMITGetMachineDomain
//
//  Synopsis:   Determines if the machine is in a Windows 2000 domain and
//              if it is then the function attempts to get a TGT for this
//              domain with the passed in credentials.
//
//  Effects:
//
//  Arguments:  LogonSession - the logon session to use for ticket caching
//                      and the identity of the caller.
//              Credential - the credential of the caller
//              TargetName - Name of the target for which to obtain a ticket.
//              TargetDomainName - Domain name of target
//              ClientRealm - the realm of the machine which the retry will use
//              TicketGrantingTicket - Will be freed if non-NULL
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMITGetMachineDomain(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_INTERNAL_NAME TargetName,
    IN OUT PUNICODE_STRING TargetDomainName,
    IN OUT PKERB_TICKET_CACHE_ENTRY *TicketGrantingTicket
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    PLSAPR_POLICY_INFORMATION Policy = NULL;

    Status = I_LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &Policy
                );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed Query policy information %ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    DnsDomainInfo = &Policy->PolicyDnsDomainInfo;

    //
    // make sure the computer is a member of an NT domain
    //

    if ((DnsDomainInfo->DnsDomainName.Length != 0) && (DnsDomainInfo->Sid != NULL))
    {
        //
        // make the client realm the domain of the computer
        //

        KerbFreeString(TargetDomainName);
        RtlZeroMemory(TargetDomainName, sizeof(UNICODE_STRING));

        Status = KerbDuplicateString(
                    TargetDomainName,
                    (PUNICODE_STRING)&DnsDomainInfo->DnsDomainName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        (VOID) RtlUpcaseUnicodeString( TargetDomainName,
                                       TargetDomainName,
                                       FALSE);

        if (*TicketGrantingTicket != NULL)
        {
            KerbDereferenceTicketCacheEntry(*TicketGrantingTicket);
            *TicketGrantingTicket = NULL;
        }
    }
    else
    {
        Status = STATUS_NO_TRUST_SAM_ACCOUNT;
    }

Cleanup:

    if (Policy != NULL)
    {
        I_LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            Policy
            );
    }

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetServiceTicket
//
//  Synopsis:   Gets a ticket to a service and handles cross-domain referrals
//
//  Effects:
//
//  Arguments:  LogonSession - the logon session to use for ticket caching
//                      and the identity of the caller.
//              TargetName - Name of the target for which to obtain a ticket.
//              TargetDomainName - Domain name of target
//              Flags - Flags about the request
//              TicketOptions - KDC options flags
//              EncryptionType - optional Requested encryption type
//              ErrorMessage - Error message from an AP request containing hints
//                      for next ticket.
//              AuthorizationData - Optional authorization data to stick
//                      in the ticket.
//              TgtReply - TGT to use for getting a ticket with enc_tkt_in_skey
//              TicketCacheEntry - Receives a referenced ticket cache entry.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetServiceTicket(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_INTERNAL_NAME TargetName,
    IN PUNICODE_STRING TargetDomainName,
    IN OPTIONAL PKERB_SPN_CACHE_ENTRY SpnCacheEntry,
    IN ULONG Flags,
    IN OPTIONAL ULONG TicketOptions,
    IN OPTIONAL ULONG EncryptionType,
    IN OPTIONAL PKERB_ERROR ErrorMessage,
    IN OPTIONAL PKERB_AUTHORIZATION_DATA AuthorizationData,
    IN OPTIONAL PKERB_TGT_REPLY TgtReply,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry,
    OUT LPGUID pLogonGuid OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS AuditStatus = STATUS_SUCCESS;
    PKERB_TICKET_CACHE_ENTRY TicketCacheEntry = NULL;
    PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY LastTgt = NULL;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    BOOLEAN LogonSessionsLocked = FALSE;
    BOOLEAN TicketCacheLocked = FALSE;
    BOOLEAN CrossRealm = FALSE;
    PKERB_INTERNAL_NAME RealTargetName = NULL;
    UNICODE_STRING RealTargetRealm = NULL_UNICODE_STRING;
    PKERB_INTERNAL_NAME TargetTgtKdcName = NULL;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials = NULL;
    BOOLEAN UsedCredentials = FALSE;
    UNICODE_STRING ClientRealm = NULL_UNICODE_STRING;
    UNICODE_STRING SpnTargetRealm = NULL_UNICODE_STRING;
    BOOLEAN CacheTicket = TRUE;
    BOOLEAN PurgeTgt = FALSE;
    ULONG ReferralCount = 0;
    ULONG RetryFlags = 0;
    KERBEROS_MACHINE_ROLE Role;
    BOOLEAN fMITRetryAlreadyMade = FALSE;
    BOOLEAN TgtRetryMade = FALSE;
    BOOLEAN CacheBasedFailure = FALSE;
    GUID LogonGuid = { 0 };


    Role = KerbGetGlobalRole();

    //
    // Check to see if the credential has any primary credentials
    //
TGTRetry:

    KerbReadLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;

    if ((Credential != NULL) && (Credential->SuppliedCredentials != NULL))
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
        UsedCredentials = TRUE;
    }
    else if (CredManCredentials != NULL)
    {
        PrimaryCredentials = CredManCredentials->SuppliedCredentials;
        UsedCredentials = TRUE;
    }
    else
    {

        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }


    //
    // Make sure the name is not zero length
    //

    if ((TargetName->NameCount == 0) ||
        (TargetName->Names[0].Length == 0))
    {
        D_DebugLog((DEB_ERROR,"Kdc GetServiceTicket: trying to crack zero length name.\n"));
        Status = SEC_E_TARGET_UNKNOWN;
        goto Cleanup;
    }

    //
    // First check the ticket cache for this logon session. We don't look
    // for the target principal name because we can't be assured that this
    // is a valid principal name for the target. If we are doing user-to-
    // user, don't use the cache because the tgt key may have changed
    //


    if ((TgtReply == NULL) && ((Flags & KERB_GET_TICKET_NO_CACHE) == 0))
    {
        TicketCacheEntry = KerbLocateTicketCacheEntry(
                                &PrimaryCredentials->ServerTicketCache,
                                TargetName,
                                TargetDomainName
                                );

    }
    else
    {
        //
        // We don't want to cache user-to-user tickets
        //

        CacheTicket = FALSE;
    }

    if (TicketCacheEntry != NULL)
    {
        //
        // If we were given an error message that indicated a bad password
        // through away the cached ticket
        //


        //
        // If we were given an error message that indicated a bad password
        // through away the cached ticket
        //

        if (ARGUMENT_PRESENT(ErrorMessage) && ((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_MODIFIED))
        {
            KerbRemoveTicketCacheEntry(TicketCacheEntry);
            KerbDereferenceTicketCacheEntry(TicketCacheEntry);
            TicketCacheEntry = NULL;
        }
        else
        {

            ULONG TicketFlags;
            ULONG CacheTicketFlags;
            ULONG CacheEncryptionType;


            //
            // Check if the flags are present
            //

            KerbReadLockTicketCache();
            CacheTicketFlags = TicketCacheEntry->TicketFlags;
            CacheEncryptionType = TicketCacheEntry->Ticket.encrypted_part.encryption_type;
            KerbUnlockTicketCache();

            TicketFlags = KerbConvertKdcOptionsToTicketFlags(TicketOptions);

            if (((CacheTicketFlags & TicketFlags) != TicketFlags) ||
                ((EncryptionType != 0) && (CacheEncryptionType != EncryptionType)))

            {
                KerbDereferenceTicketCacheEntry(TicketCacheEntry);
                TicketCacheEntry = NULL;
            }
            else
            {
            //
            // Check the ticket time
            //

                if (KerbTicketIsExpiring(TicketCacheEntry, TRUE))
                {
                    KerbDereferenceTicketCacheEntry(TicketCacheEntry);
                    TicketCacheEntry = NULL;
                }
                else
                {
                    *NewCacheEntry = TicketCacheEntry;
                    TicketCacheEntry = NULL;
                    goto Cleanup;
                }
            }
        }
    }

    //
    // If the caller wanted any special options, don't cache this ticket.
    //

    if ((TicketOptions != 0) || (EncryptionType != 0) || ((Flags & KERB_GET_TICKET_NO_CACHE) != 0))
    {
        CacheTicket = FALSE;
    }

    //
    // No cached entry was found so go ahead and call the KDC to
    // get the ticket.
    //


    //
    // Determine the state of the SPNCache using information in the credential.
    // Only do this if we've not been handed 
    //
    if ( ARGUMENT_PRESENT(SpnCacheEntry) && TargetDomainName->Buffer == NULL )
    {      
        Status = KerbGetSpnCacheStatus(
                    SpnCacheEntry,
                    PrimaryCredentials,
                    &SpnTargetRealm
                    );       

        if (NT_SUCCESS( Status ))
        {
            KerbFreeString(&RealTargetRealm);                       
            RealTargetRealm = SpnTargetRealm;                      
            RtlZeroMemory(&SpnTargetRealm, sizeof(UNICODE_STRING));
    
            D_DebugLog((DEB_TRACE_SPN_CACHE, "Found SPN cache entry - %wZ\n", &RealTargetRealm));
            D_KerbPrintKdcName(DEB_TRACE_SPN_CACHE, TargetName); 

        }
        else if ( Status != STATUS_NO_MATCH )
        {
            D_DebugLog((DEB_TRACE_SPN_CACHE, "KerbGetSpnCacheStatus failed %x\n", Status));
            D_DebugLog((DEB_TRACE_SPN_CACHE,  "TargetName: \n"));
            D_KerbPrintKdcName(DEB_TRACE_SPN_CACHE, TargetName);
            CacheBasedFailure = TRUE;
            goto Cleanup;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // First get a TGT to the correct KDC. If a principal name was provided,
    // use it instead of the target name.
    //

    Status = KerbGetTgtForService(
                LogonSession,
                Credential,
                CredManCredentials,
                NULL,
                (RealTargetRealm.Buffer == NULL ? TargetDomainName : &RealTargetRealm),
                Flags,
                &TicketGrantingTicket,
                &CrossRealm
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to get TGT for service: 0x%x :",
                    Status ));
        KerbPrintKdcName( DEB_ERROR, TargetName );
        DebugLog((DEB_ERROR, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Copy out the client realm name which is used when obtaining the ticket
    //

    Status = KerbDuplicateString(
                &ClientRealm,
                &PrimaryCredentials->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbUnlockLogonSessions(LogonSession);
    LogonSessionsLocked = FALSE;

ReferralRestart:
    

    D_DebugLog((DEB_TRACE, "KerbGetServiceTicket ReferralRestart, ClientRealm %wZ, TargetName ", &ClientRealm));
    D_KerbPrintKdcName(DEB_TRACE, TargetName);

    //
    // If this is not cross realm (meaning we have a TGT to the corect domain),
    // try to get a ticket directly to the service
    //

    if (!CrossRealm)
    {
        Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetName,
                    Flags,
                    TicketOptions,
                    EncryptionType,
                    AuthorizationData,
                    NULL,                           // no pa data
                    TgtReply,                       // This is for the service directly, so use TGT
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

        if (!NT_SUCCESS(Status))
        {

            //
            // Check for bad option TGT purging
            //
            if (((RetryFlags & KERB_RETRY_WITH_NEW_TGT) != 0) && !TgtRetryMade)
            {
                DebugLog((DEB_WARN, "Doing TGT retry - %p\n", TicketGrantingTicket));

                //
                // Unlink && purge bad tgt
                //
                KerbRemoveTicketCacheEntry(TicketGrantingTicket);
                KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
                TicketGrantingTicket = NULL;
                TgtRetryMade = TRUE;
                goto TGTRetry;
            }

            //
            // Check for the MIT retry case
            //

            if (((RetryFlags & KERB_MIT_NO_CANONICALIZE_RETRY) != 0)
                && (!fMITRetryAlreadyMade) &&
                (Role != KerbRoleRealmlessWksta))
            {

                Status = KerbMITGetMachineDomain(LogonSession,
                                TargetName,
                                TargetDomainName,
                                &TicketGrantingTicket
                                );

                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR,"Failed Query policy information %ws, line %d\n", THIS_FILE, __LINE__));
                    goto Cleanup;
                }

                fMITRetryAlreadyMade = TRUE;

                goto TGTRetry;
            }

            DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x : \n",
                Status ));
            KerbPrintKdcName(DEB_WARN, TargetName );
            DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // Check for referral info in the name
        //
        KerbFreeString(&RealTargetRealm);
        Status = KerbGetReferralNames(
                    KdcReplyBody,
                    TargetName,
                    &RealTargetRealm
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // If this is not a referral ticket, just cache it and return
        // the cache entry.
        //

        if (RealTargetRealm.Length == 0)
        {

            //
            // Now we have a ticket - lets cache it
            //

            KerbReadLockLogonSessions(LogonSession);
            LogonSessionsLocked = TRUE;


            Status = KerbCacheTicket(
                        &PrimaryCredentials->ServerTicketCache,
                        KdcReply,
                        KdcReplyBody,
                        TargetName,
                        TargetDomainName,
                        0,
                        CacheTicket,
                        &TicketCacheEntry
                        );

            KerbUnlockLogonSessions(LogonSession);
            LogonSessionsLocked = FALSE;


            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            *NewCacheEntry = TicketCacheEntry;
            TicketCacheEntry = NULL;

            //
            // We're done, so get out of here.
            //

            goto Cleanup;
        }


        //
        // The server referred us to another domain. Get the service's full
        // name from the ticket and try to find a TGT in that domain.
        //

        Status = KerbDuplicateKdcName(
                    &RealTargetName,
                    TargetName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        D_DebugLog((DEB_TRACE_CTXT, "Got referral ticket for service \n"));
        D_KerbPrintKdcName(DEB_TRACE_CTXT,TargetName);
        D_DebugLog((DEB_TRACE_CTXT, "in realm \n"));
        D_KerbPrintKdcName(DEB_TRACE_CTXT,RealTargetName);

        //
        // Cache the interdomain TGT
        //

        KerbReadLockLogonSessions(LogonSession);
        LogonSessionsLocked = TRUE;

        Status = KerbCacheTicket(
                    &PrimaryCredentials->AuthenticationTicketCache,
                    KdcReply,
                    KdcReplyBody,
                    NULL,                       // no target name
                    NULL,                       // no target realm
                    0,                          // no flags
                    CacheTicket,
                    &TicketCacheEntry
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
        TicketCacheEntry = NULL;

        //
        // Derefence the old ticket-granting ticket
        //

        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
        TicketGrantingTicket = NULL;

        //
        // Now look for a TGT for the principal
        //

        Status = KerbGetTgtForService(
                    LogonSession,
                    Credential,
                    CredManCredentials,
                    NULL,
                    &RealTargetRealm,
                    KERB_TARGET_REFERRAL,
                    &TicketGrantingTicket,
                    &CrossRealm
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failed to get TGT for service: 0x%x\n",
                        Status ));
            KerbPrintKdcName( DEB_ERROR, TargetName );
            DebugLog((DEB_ERROR, "%ws, line %d\n", THIS_FILE, __LINE__));
            goto Cleanup;
        }

        KerbUnlockLogonSessions(LogonSession);
        LogonSessionsLocked = FALSE;

    }
    else
    {
        //
        // Set the real names to equal the supplied names
        //

        Status = KerbDuplicateKdcName(
                    &RealTargetName,
                    TargetName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Don't overwrite if we're doing a referral, or if we're missing
        // a TGT for the target domain name.
        //
        if (RealTargetRealm.Buffer == NULL)
        {
            Status = KerbDuplicateString(
                            &RealTargetRealm,
                            TargetDomainName
                            );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    }

    //
    // Now we are in a case where we have a realm to aim for and a TGT. While
    // we don't have a TGT for the target realm, get one.
    //

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                &RealTargetRealm,
                &KerbGlobalKdcServiceName,
                KRB_NT_SRV_INST,
                &TargetTgtKdcName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;


    //
    // Referral chasing code block - very important to get right
    // If we know the "real" target realm, eg. from GC, then
    // we'll walk trusts until we hit "real" target realm.
    //
    while (!RtlEqualUnicodeString(
                &RealTargetRealm,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
    {

        //
        // If we just got two TGTs for the same domain, then we must have
        // gotten as far as we can. Chances our our RealTargetRealm is a
        // variation of what the KDC hands out.
        //

        if ((LastTgt != NULL) &&
             RtlEqualUnicodeString(
                &LastTgt->TargetDomainName,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
        {

            KerbUnlockTicketCache();

            KerbSetTicketCacheEntryTarget(
                &RealTargetRealm,
                LastTgt
                );

            KerbReadLockTicketCache();
            D_DebugLog((DEB_TRACE_CTXT, "Got two TGTs for same realm (%wZ), bailing out of referral loop\n",
                &LastTgt->TargetDomainName));
            break;
        }

        D_DebugLog((DEB_TRACE_CTXT, "Getting referral TGT for \n"));
        D_KerbPrintKdcName(DEB_TRACE_CTXT, TargetTgtKdcName);
        D_KerbPrintKdcName(DEB_TRACE_CTXT, TicketGrantingTicket->ServiceName);

        KerbUnlockTicketCache();
        TicketCacheLocked = FALSE;

        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;


        Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetTgtKdcName,
                    FALSE,
                    TicketOptions,
                    EncryptionType,
                    AuthorizationData,
                    NULL,                       // no pa data
                    NULL,                       // no tgt reply since target is krbtgt
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x :",
                Status ));
            KerbPrintKdcName(DEB_WARN, TargetTgtKdcName );
            DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));

            //
            // We want to map cross-domain failures to failures indicating
            // that a KDC could not be found. This means that for Kerberos
            // logons, the negotiate code will retry with a different package
            //

            // if (Status == STATUS_NO_TRUST_SAM_ACCOUNT)
            // {
            //     Status = STATUS_NO_LOGON_SERVERS;
            // }
            goto Cleanup;
        }

        //
        // Now we have a ticket - lets cache it
        //
        KerbReadLockLogonSessions(LogonSession);
        LogonSessionsLocked = TRUE;


        Status = KerbCacheTicket(
                    &PrimaryCredentials->AuthenticationTicketCache,
                    KdcReply,
                    KdcReplyBody,
                    NULL,                               // no target name
                    NULL,                               // no targe realm
                    0,                                  // no flags
                    CacheTicket,
                    &TicketCacheEntry
                    );

        KerbUnlockLogonSessions(LogonSession);
        LogonSessionsLocked = FALSE;


        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (LastTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }
        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        KerbReadLockTicketCache();
        TicketCacheLocked = TRUE;


    }     // ** WHILE **

    DsysAssert(TicketCacheLocked);
    KerbUnlockTicketCache();
    TicketCacheLocked = FALSE;

    //
    // Now we must have a TGT to the destination domain. Get a ticket
    // to the service.
    //

    //
    // Cleanup old state
    //

    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KdcReply = NULL;
    KdcReplyBody = NULL;
    RetryFlags = 0;

    Status = KerbGetTgsTicket(
                &ClientRealm,
                TicketGrantingTicket,
                RealTargetName,
                FALSE,
                TicketOptions,
                EncryptionType,
                AuthorizationData,
                NULL,                           // no pa data
                TgtReply,
                &KdcReply,
                &KdcReplyBody,
                &RetryFlags
                );

    if (!NT_SUCCESS(Status))
    {
        //
        // Check for bad option TGT purging
        //
        if (((RetryFlags & KERB_RETRY_WITH_NEW_TGT) != 0) && !TgtRetryMade)
        {
            DebugLog((DEB_WARN, "Doing TGT retry - %p\n", TicketGrantingTicket));

            //
            // Unlink && purge bad tgt
            //
            KerbRemoveTicketCacheEntry(TicketGrantingTicket); // free from list
            KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
            TicketGrantingTicket = NULL;
            TgtRetryMade = TRUE;
            goto TGTRetry;
        }

        DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x ",
            Status ));
        KerbPrintKdcName(DEB_WARN, RealTargetName);
        DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now that we are in the domain to which we were referred, check for referral
    // info in the name
    //

    KerbFreeString(&RealTargetRealm);
    Status = KerbGetReferralNames(
                KdcReplyBody,
                RealTargetName,
                &RealTargetRealm
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If this is not a referral ticket, just cache it and return
    // the cache entry.
    //
    if (RealTargetRealm.Length != 0)
    {
        //
        // To prevent loops, we limit the number of referral we'll take
        //


        if (ReferralCount > KerbGlobalMaxReferralCount)
        {
            D_DebugLog((DEB_ERROR,"Maximum referral count exceeded for name: "));
            KerbPrintKdcName(DEB_ERROR,RealTargetName);
            Status = STATUS_MAX_REFERRALS_EXCEEDED;
            goto Cleanup;
        }

        ReferralCount++;

        //
        // Cache the interdomain TGT
        //

        KerbReadLockLogonSessions(LogonSession);
        LogonSessionsLocked = TRUE;


        Status = KerbCacheTicket(
                    &PrimaryCredentials->AuthenticationTicketCache,
                    KdcReply,
                    KdcReplyBody,
                    NULL,                       // no target name
                    NULL,                       // no target realm
                    0,                          // no flags
                    CacheTicket,
                    &TicketCacheEntry
                    );


        KerbUnlockLogonSessions(LogonSession);
        LogonSessionsLocked = FALSE;

        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (LastTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }

        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        D_DebugLog((DEB_TRACE_CTXT, "Restart referral:%wZ", &RealTargetRealm));

        goto ReferralRestart;
    }


    

    KerbReadLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;

    Status = KerbCacheTicket(
                &PrimaryCredentials->ServerTicketCache,
                KdcReply,
                KdcReplyBody,
                TargetName,
                TargetDomainName,
                TgtReply ? KERB_TICKET_CACHE_TKT_ENC_IN_SKEY : 0,
                CacheTicket,
                &TicketCacheEntry
                );

    KerbUnlockLogonSessions(LogonSession);
    LogonSessionsLocked = FALSE;

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *NewCacheEntry = TicketCacheEntry;
    TicketCacheEntry = NULL;

Cleanup:

    if ( NT_SUCCESS( Status ) )
    {
        //
        // Generate the logon GUID
        //
        AuditStatus = KerbGetLogonGuid(
                          PrimaryCredentials,
                          KdcReplyBody,
                          &LogonGuid
                          );

        //
        // return the logon GUID if requested
        //
        if ( NT_SUCCESS(AuditStatus) && pLogonGuid )
        {
            *pLogonGuid = LogonGuid;
        }

        //
        // generate SE_AUDITID_LOGON_USING_EXPLICIT_CREDENTIALS
        // if explicit credentials were used for this logon.
        //
        if ( UsedCredentials )
        {
            (void) KerbGenerateAuditForLogonUsingExplicitCreds(
                       LogonSession,
                       PrimaryCredentials,
                       &LogonGuid
                       );
        }
    }

    //
    // Bad or unlocatable SPN -- Don't update if we got the value from the cache, though.
    //
    if (( TargetName->NameType == KRB_NT_SRV_INST ) &&
        ( NT_SUCCESS(Status) || Status == STATUS_NO_TRUST_SAM_ACCOUNT ) &&
        ( !CacheBasedFailure ))
    {
        NTSTATUS Tmp;
        ULONG UpdateValue = KERB_SPN_UNKNOWN;
        PUNICODE_STRING Realm = NULL;

        if ( NT_SUCCESS( Status ))
        {
            Realm = &(*NewCacheEntry)->TargetDomainName;
            UpdateValue = KERB_SPN_KNOWN;
        } 
        
        Tmp = KerbUpdateSpnCacheEntry(
                    SpnCacheEntry,
                    TargetName,
                    PrimaryCredentials,
                    UpdateValue,
                    Realm
                    );
    }

    KerbFreeTgsReply( KdcReply );
    KerbFreeKdcReplyBody( KdcReplyBody );
    KerbFreeKdcName( &TargetTgtKdcName );
    KerbFreeString( &RealTargetRealm );
    KerbFreeString( &SpnTargetRealm );

    KerbFreeKdcName(&RealTargetName);

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    KerbFreeString(&RealTargetRealm);


    if (TicketGrantingTicket != NULL)
    {
        if (Status == STATUS_WRONG_PASSWORD)
        {
            KerbRemoveTicketCacheEntry(
                TicketGrantingTicket
                );
        }
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }
    if (LastTgt != NULL)
    {
        KerbDereferenceTicketCacheEntry(LastTgt);
        LastTgt = NULL;
    }


    KerbFreeString(&ClientRealm);

    //
    // If we still have a pointer to the ticket cache entry, free it now.
    //

    if (TicketCacheEntry != NULL)
    {
        KerbRemoveTicketCacheEntry( TicketCacheEntry );
        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRenewTicket
//
//  Synopsis:   renews a ticket
//
//  Effects:    Tries to renew a ticket
//
//  Arguments:  LogonSession - LogonSession for user, contains ticket caches
//                      and locks
//              Credentials - Present if the ticket being renewed is hanging
//                      off a credential structure.
//              Ticket - Ticket to renew
//              NewTicket - Receives the renewed ticket
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbRenewTicket(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_TICKET_CACHE_ENTRY Ticket,
    IN BOOLEAN IsTgt,
    OUT PKERB_TICKET_CACHE_ENTRY *NewTicket
    )
{
    NTSTATUS Status;
    PKERB_INTERNAL_NAME ServiceName = NULL;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    UNICODE_STRING ServiceRealm = NULL_UNICODE_STRING;
    BOOLEAN TicketCacheLocked = FALSE;
    PKERB_PRIMARY_CREDENTIAL PrimaryCreds;
    ULONG CacheFlags = 0;
    ULONG RetryFlags = 0;


    *NewTicket = NULL;

    //
    // Copy the names out of the input structures so we can
    // unlock the structures while going over the network.
    //

    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // If the renew time is not much bigger than the end time, don't bother
    // renewing
    //

    if (KerbGetTime(Ticket->EndTime) + KerbGetTime(KerbGlobalSkewTime) >= KerbGetTime(Ticket->RenewUntil))
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
    CacheFlags = Ticket->CacheFlags;

    Status = KerbDuplicateString(
                &ServiceRealm,
                &Ticket->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = KerbDuplicateKdcName(
                &ServiceName,
                Ticket->ServiceName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if ((Ticket->TicketFlags & KERB_TICKET_FLAGS_renewable) == 0)
    {
        Status = STATUS_ILLEGAL_FUNCTION;
        D_DebugLog((DEB_ERROR,"Trying to renew a non renewable ticket to"));
        D_KerbPrintKdcName(DEB_ERROR,ServiceName);
        D_DebugLog((DEB_ERROR, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    KerbUnlockTicketCache();
    TicketCacheLocked = FALSE;


    Status = KerbGetTgsTicket(
                &ServiceRealm,
                Ticket,
                ServiceName,
                FALSE,
                KERB_KDC_OPTIONS_renew,
                0,                              // no encryption type
                NULL,                           // no authorization data
                NULL,                           // no pa data
                NULL,                           // no tgt reply
                &KdcReply,
                &KdcReplyBody,
                &RetryFlags
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x ",
            Status ));
        KerbPrintKdcName(DEB_WARN, ServiceName);
        DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    KerbReadLockLogonSessions(LogonSession);

    if ((Credentials != NULL) && (Credentials->SuppliedCredentials != NULL))
    {
        PrimaryCreds = Credentials->SuppliedCredentials;
    }
    else if (CredManCredentials != NULL)
    {
        PrimaryCreds = CredManCredentials->SuppliedCredentials;
    }
    else
    {
        PrimaryCreds = &LogonSession->PrimaryCredentials;
    }


    Status = KerbCacheTicket(
                (IsTgt ? &PrimaryCreds->AuthenticationTicketCache :
                    &PrimaryCreds->ServerTicketCache),
                KdcReply,
                KdcReplyBody,
                ServiceName,
                &ServiceRealm,
                CacheFlags,
                TRUE,
                NewTicket
                );

    KerbUnlockLogonSessions(LogonSession);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
Cleanup:
    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KerbFreeKdcName(&ServiceName);
    KerbFreeString(&ServiceRealm);
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbRefreshPrimaryTgt
//
//  Synopsis:   Obtains a new TGT for a logon session or credential
//
//
//  Effects:    does a new AS exchange with the KDC to get a TGT for the client
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbRefreshPrimaryTgt(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY OldTgt
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    if (ARGUMENT_PRESENT(OldTgt))
    {
        PKERB_TICKET_CACHE_ENTRY NewTgt = NULL;

        DebugLog((DEB_WARN,"Attempting to renew primary TGT \n"));
        Status = KerbRenewTicket(
                    LogonSession,
                    Credentials,
                    CredManCredentials,
                    OldTgt,
                    TRUE,               // it is a TGT
                    &NewTgt
                    );
        if (NT_SUCCESS(Status))
        {
            KerbDereferenceTicketCacheEntry(NewTgt);
        }
        else
        {
            DebugLog((DEB_WARN,"Failed to renew primary tgt: 0x%x\n",Status));
        }

    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Getting new TGT for account\n"));
        Status = KerbGetTicketForCredential(
                    LogonSession,
                    Credentials,
                    CredManCredentials,
                    SuppRealm
                    );

    }
    return(Status);
}

#ifndef WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyApRequest
//
//  Synopsis:   Verifies that an AP request message is valid
//
//  Effects:    decrypts ticket in AP request
//
//  Arguments:  RequestMessage - Marshalled AP request message
//              RequestSize - Size in bytes of request message
//              LogonSession - Logon session for server
//              Credential - Credential for server containing
//                      supplied credentials
//              UseSuppliedCreds - If TRUE, use creds from credential
//              ApRequest - Receives unmarshalled AP request
//              NewTicket - Receives ticket from AP request
//              NewAuthenticator - receives new authenticator from AP request
//              SessionKey -receives the session key from the ticket
//              ContextFlags - receives the requested flags for the
//                      context.
//              pChannelBindings - pChannelBindings supplied by app to check
//                      against hashed ones in AP_REQ
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbVerifyApRequest(
    IN OPTIONAL PKERB_CONTEXT Context,
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN BOOLEAN UseSuppliedCreds,
    IN BOOLEAN CheckForReplay,
    OUT PKERB_AP_REQUEST  * ApRequest,
    OUT PKERB_ENCRYPTED_TICKET * NewTicket,
    OUT PKERB_AUTHENTICATOR * NewAuthenticator,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PKERB_ENCRYPTION_KEY TicketKey,
    OUT PKERB_ENCRYPTION_KEY ServerKey,
    OUT PULONG ContextFlags,
    OUT PULONG ContextAttributes,
    OUT PKERBERR ReturnKerbErr,
    IN PSEC_CHANNEL_BINDINGS pChannelBindings
    )
{

    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_AP_REQUEST Request = NULL;
    UNICODE_STRING ServerName[3] = {0};
    ULONG NameCount = 0;
    BOOLEAN UseSubKey = FALSE;
    BOOLEAN LockAcquired = FALSE;
    PKERB_GSS_CHECKSUM GssChecksum;
    PKERB_ENCRYPTION_KEY LocalServerKey;
    BOOLEAN TryOldPassword = TRUE;
    BOOLEAN TicketCacheLocked = FALSE;
    PKERB_STORED_CREDENTIAL PasswordList;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    ULONG StrippedRequestSize = RequestSize;
    PUCHAR StrippedRequest = RequestMessage;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    ULONG ApOptions = 0;
    BOOLEAN StrongEncryptionPermitted = KerbGlobalStrongEncryptionPermitted;
    ULONG BindHash[4];

    *ApRequest = NULL;
    *ContextFlags = 0;
    *NewTicket = NULL;
    *NewAuthenticator = NULL;
    *ReturnKerbErr = KDC_ERR_NONE;

    RtlZeroMemory(
        SessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    *TicketKey = *SessionKey;
    *ServerKey = *SessionKey;


#ifndef WIN32_CHICAGO
    {
        SECPKG_CALL_INFO CallInfo;

        if (!StrongEncryptionPermitted && LsaFunctions->GetCallInfo(&CallInfo))
        {
            if (CallInfo.Attributes & SECPKG_CALL_IN_PROC )
            {
                StrongEncryptionPermitted = TRUE;
            }
        }
    }
#endif

    //
    // First unpack the KDC request.
    //

    //
    // Verify the GSSAPI header
    //

    if (!g_verify_token_header(
            (gss_OID) gss_mech_krb5_new,
            (INT *) &StrippedRequestSize,
            &StrippedRequest,
            KG_TOK_CTX_AP_REQ,
            RequestSize
            ))
    {

        StrippedRequestSize = RequestSize;
        StrippedRequest = RequestMessage;

        //
        // Check if this is user-to-user kerberos
        //


        if (g_verify_token_header(
                gss_mech_krb5_u2u,
                (INT *) &StrippedRequestSize,
                &StrippedRequest,
                KG_TOK_CTX_TGT_REQ,
                RequestSize))
        {
            //
            // Return now because there is no AP request. Return a distinct
            // success code so the caller knows to reparse the request as
            // a TGT request.
            //

            D_DebugLog((DEB_TRACE_U2U, "KerbVerifyApRequest got TGT reqest\n"));

            return(STATUS_REPARSE_OBJECT);
        }
        else
        {
            StrippedRequestSize = RequestSize;
            StrippedRequest = RequestMessage;

            if (!g_verify_token_header(         // check for a user-to-user AP request
                gss_mech_krb5_u2u,
                (INT *) &StrippedRequestSize,
                &StrippedRequest,
                KG_TOK_CTX_AP_REQ,
                RequestSize))
            {
                //
                // BUG 454895: remove when not needed for compatibility
                //

                //
                // if that didn't work, just use the token as it is.
                //
                StrippedRequest = RequestMessage;
                StrippedRequestSize = RequestSize;
                D_DebugLog((DEB_WARN,"Didn't find GSS header on AP request\n"));

            }
        }
    }


    KerbErr = KerbUnpackApRequest(
                StrippedRequest,
                StrippedRequestSize,
                &Request
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to unpack AP request: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Check for a null session
    //

    if ((Request->version == KERBEROS_VERSION) &&
        (Request->message_type == KRB_AP_REQ) &&
        (Request->ticket.encrypted_part.cipher_text.length == 1) &&
        (*Request->ticket.encrypted_part.cipher_text.value == '\0') &&
        (Request->authenticator.cipher_text.length == 1) &&
        (*Request->authenticator.cipher_text.value == '\0'))
    {
        //
        // We have a null session. Not much to do here.
        //

        Status = STATUS_SUCCESS;

        RtlZeroMemory(
            SessionKey,
            sizeof(KERB_ENCRYPTION_KEY)
            );
        *ContextFlags |= ISC_RET_NULL_SESSION;
        goto Cleanup;

    }

    KerbReadLockLogonSessions(LogonSession);

    if ( UseSuppliedCreds )
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }
    LockAcquired = TRUE;

    //
    // Check for existence of a password and use_session_key
    //


    ApOptions = KerbConvertFlagsToUlong( &Request->ap_options);

    D_DebugLog((DEB_TRACE,"Request AP options = 0x%x\n",ApOptions));

    if ((ApOptions & KERB_AP_OPTIONS_use_session_key) == 0)
    {
        if (PrimaryCredentials->Passwords == NULL)
        {
            D_DebugLog((DEB_TRACE_U2U, "KerbVerifyApRequest no password and use_session_key is not requested, returning KRB_AP_ERR_USER_TO_USER_REQUIRED\n"));

            Status = SEC_E_NO_CREDENTIALS;
            *ReturnKerbErr = KRB_AP_ERR_USER_TO_USER_REQUIRED;
            goto Cleanup;
        }
    }

    if (!KERB_SUCCESS(KerbBuildFullServiceName(
                &PrimaryCredentials->DomainName,
                &PrimaryCredentials->UserName,
                &ServerName[NameCount++]
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ServerName[NameCount++] = PrimaryCredentials->UserName;

    if (Credential->CredentialName.Length != 0)
    {
        ServerName[NameCount++] = Credential->CredentialName;
    }

    //
    // Get ticket info for the server
    //

    //
    // Now Check the ticket
    //

    PasswordList = PrimaryCredentials->Passwords;

Retry:
    //
    // If this is use_session key, get the key from the tgt
    //

    if ((ApOptions & KERB_AP_OPTIONS_use_session_key) != 0)
    {
        TryOldPassword = FALSE;

        D_DebugLog((DEB_TRACE_U2U, "KerbVerifyApRequest verifying ticket with TGT session key\n"));

        *ContextAttributes |= KERB_CONTEXT_USER_TO_USER;

        //
        // If we have a context, try to get the TGT from it.
        //

        if (ARGUMENT_PRESENT(Context))
        {
            KerbReadLockContexts();
            CacheEntry = Context->TicketCacheEntry;
            KerbUnlockContexts();
        }

        //
        // If there is no TGT in the context, try getting one from the
        // logon session.
        //

        if (CacheEntry == NULL)
        {
            //
            // Locate the TGT for the principal
            //

            CacheEntry = KerbLocateTicketCacheEntryByRealm(
                            &PrimaryCredentials->AuthenticationTicketCache,
                            &PrimaryCredentials->DomainName,                    // get initial ticket
                            0
                            );
        }
        else
        {
            KerbReferenceTicketCacheEntry(
                CacheEntry
                );
        }
        if (CacheEntry == NULL)
        {
            D_DebugLog((DEB_WARN, "Tried to request TGT on credential without a TGT\n"));
            *ReturnKerbErr = KRB_AP_ERR_NO_TGT;
            Status = SEC_E_NO_CREDENTIALS;
            goto Cleanup;

        }
        KerbReadLockTicketCache();
        TicketCacheLocked = TRUE;
        LocalServerKey = &CacheEntry->SessionKey;

    }
    else
    {
        LocalServerKey = KerbGetKeyFromList(
                            PasswordList,
                            Request->ticket.encrypted_part.encryption_type
                            );

        if (LocalServerKey == NULL)
        {
            D_DebugLog((DEB_ERROR, "Couldn't find server key of type 0x%x. %ws, line %d\n",
                        Request->ticket.encrypted_part.encryption_type, THIS_FILE, __LINE__ ));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
    }

    KerbErr = KerbCheckTicket(
                &Request->ticket,
                &Request->authenticator,
                LocalServerKey,
                Authenticators,
                &KerbGlobalSkewTime,
                NameCount,
                ServerName,
                &PrimaryCredentials->DomainName,
                CheckForReplay,
                FALSE,                  // not a KDC request
                NewTicket,
                NewAuthenticator,
                TicketKey,
                SessionKey,
                &UseSubKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Return this error, since it is an authentication failure.
        //

        *ReturnKerbErr = KerbErr;

        DebugLog((DEB_ERROR,"Failed to check ticket: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));

        //
        // If the error is that it was modified, try again with the old
        // password.
        //

        if ((KerbErr == KRB_AP_ERR_MODIFIED) &&
            TryOldPassword
            &&
            (PrimaryCredentials->OldPasswords != NULL))
        {
            PasswordList = PrimaryCredentials->OldPasswords;
            TryOldPassword = FALSE;
            goto Retry;
        }

        //
        // If the error was a clock skew error but the caller didn't ask
        // for mutual auth, then don't bother returning a Kerberos error.
        //

        Status = KerbMapKerbError(KerbErr);

        goto Cleanup;
    }

    //
    // Copy the key that was used.
    //

    if (!KERB_SUCCESS(KerbDuplicateKey(
                        ServerKey,
                        LocalServerKey)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Get the context flags out of the authenticator and the AP request
    //

    if ((((*NewAuthenticator)->bit_mask & checksum_present) != 0) &&
        ((*NewAuthenticator)->checksum.checksum_type == GSS_CHECKSUM_TYPE) &&
        ((*NewAuthenticator)->checksum.checksum.length >= GSS_CHECKSUM_SIZE))
    {
        GssChecksum = (PKERB_GSS_CHECKSUM) (*NewAuthenticator)->checksum.checksum.value;

        if (GssChecksum->GssFlags & GSS_C_MUTUAL_FLAG)
        {
            //
            // Make sure this is also present in the AP request
            //

            if ((ApOptions & KERB_AP_OPTIONS_mutual_required) == 0)
            {
                DebugLog((DEB_ERROR,"Sent AP_mutual_req but not GSS_C_MUTUAL_FLAG. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (GssChecksum->GssFlags & GSS_C_DCE_STYLE)
        {
            *ContextFlags |= ISC_RET_USED_DCE_STYLE;
        }
        if (GssChecksum->GssFlags & GSS_C_REPLAY_FLAG)
        {
            *ContextFlags |= ISC_RET_REPLAY_DETECT;
        }
        if (GssChecksum->GssFlags & GSS_C_SEQUENCE_FLAG)
        {
            *ContextFlags |= ISC_RET_SEQUENCE_DETECT;
        }
        if (GssChecksum->GssFlags & GSS_C_CONF_FLAG)
        {
            *ContextFlags |= (ISC_RET_CONFIDENTIALITY |
                             ISC_RET_INTEGRITY |
                             ISC_RET_SEQUENCE_DETECT |
                             ISC_RET_REPLAY_DETECT );
        }
        if (GssChecksum->GssFlags & GSS_C_INTEG_FLAG)
        {
            *ContextFlags |= ISC_RET_INTEGRITY;
        }
        if (GssChecksum->GssFlags & GSS_C_IDENTIFY_FLAG)
        {
            *ContextFlags |= ISC_RET_IDENTIFY;
        }
        if (GssChecksum->GssFlags & GSS_C_DELEG_FLAG)
        {
            *ContextFlags |= ISC_RET_DELEGATE;
        }
        if (GssChecksum->GssFlags & GSS_C_EXTENDED_ERROR_FLAG)
        {
            *ContextFlags |= ISC_RET_EXTENDED_ERROR;
        }

        if( pChannelBindings != NULL )
        {
            Status = KerbComputeGssBindHash( pChannelBindings, (PUCHAR)BindHash );

            if( !NT_SUCCESS(Status) )
            {
                goto Cleanup;
            }

            if( RtlCompareMemory( BindHash,
                                  GssChecksum->BindHash,
                                  GssChecksum->BindLength )
                    != GssChecksum->BindLength )
            {
                Status = STATUS_BAD_BINDINGS;
                goto Cleanup;
            }
        }
    }

    if ((ApOptions & KERB_AP_OPTIONS_use_session_key) != 0)
    {
        *ContextFlags |= ISC_RET_USE_SESSION_KEY;
    }

    if ((ApOptions & KERB_AP_OPTIONS_mutual_required) != 0)
    {
        *ContextFlags |= ISC_RET_MUTUAL_AUTH;
    }
    else if ((*ContextFlags & ISC_RET_USED_DCE_STYLE) == 0)
    {
        //
        // Make sure we can support the encryption type the client is using.
        // This is only relevant if they are trying to do encryption
        //

        if (!StrongEncryptionPermitted &&
            !KerbIsKeyExportable(
                SessionKey
                ) &&
            (((*ContextFlags) & ISC_RET_CONFIDENTIALITY) != 0))
        {
            DebugLog((DEB_ERROR,"Client is trying to strong encryption but we can't support it. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_STRONG_CRYPTO_NOT_SUPPORTED;
        }
    }

    *ApRequest = Request;
    Request = NULL;

Cleanup:

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (CacheEntry)
    {
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }

    if (LockAcquired)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    //
    // If the caller didn't ask for mutual-auth, then don't bother
    // returning a KerbErr for an error that probably can't be fixed
    // anyways.
    //

    if ((Request != NULL)
        /* && (*ReturnKerbErr == KRB_AP_ERR_MODIFIED) */ )
    {

        //
        // If the client didn't want mutual-auth, then it won't be expecting
        // a response message so don't bother with the kerb error. By setting
        // KerbErr to NULL we won't send a message back to the client.
        //

        if ((ApOptions & KERB_AP_OPTIONS_mutual_required) == 0)
        {
            *ReturnKerbErr = KDC_ERR_NONE;
        }

    }

    KerbFreeApRequest(Request);
    KerbFreeString(&ServerName[0]);
    if (!NT_SUCCESS(Status))
    {
        KerbFreeKey(TicketKey);
    }
    return(Status);
}
#endif // WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbMarshallApReply
//
//  Synopsis:   Takes a reply and reply body and encrypts and marshalls them
//              into a return message
//
//  Effects:    Allocates output buffer
//
//  Arguments:  Reply - The outer reply to marshall
//              ReplyBody - The reply body to marshall
//              EncryptionType - Encryption algorithm to use
//              SessionKey - Session key to encrypt reply
//              ContextFlags - Flags for context
//              PackedReply - Recives marshalled reply buffer
//              PackedReplySize - Receives size in bytes of marshalled reply
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbMarshallApReply(
    IN PKERB_AP_REPLY Reply,
    IN PKERB_ENCRYPTED_AP_REPLY ReplyBody,
    IN ULONG EncryptionType,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    OUT PUCHAR * PackedReply,
    OUT PULONG PackedReplySize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG PackedApReplySize;
    PUCHAR PackedApReply = NULL;
    ULONG ReplySize;
    PUCHAR ReplyWithHeader = NULL;
    PUCHAR ReplyStart;
    KERBERR KerbErr;
    gss_OID_desc * MechId;


    if (!KERB_SUCCESS(KerbPackApReplyBody(
                        ReplyBody,
                        &PackedApReplySize,
                        &PackedApReply
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now encrypt the response
    //
    KerbErr = KerbAllocateEncryptionBufferWrapper(
                EncryptionType,
                PackedApReplySize,
                &Reply->encrypted_part.cipher_text.length,
                &Reply->encrypted_part.cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to get encryption overhead. 0x%x. %ws, line %d\n", KerbErr, THIS_FILE, __LINE__));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    if (!KERB_SUCCESS(KerbEncryptDataEx(
                        &Reply->encrypted_part,
                        PackedApReplySize,
                        PackedApReply,
                        EncryptionType,
                        KERB_AP_REP_SALT,
                        SessionKey
                        )))
    {
        D_DebugLog((DEB_ERROR,"Failed to encrypt AP Reply. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now pack the reply into the output buffer
    //

    if (!KERB_SUCCESS(KerbPackApReply(
                        Reply,
                        PackedReplySize,
                        PackedReply
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If we aren't doing DCE style, add in the GSS token headers now
    //

    if ((ContextFlags & ISC_RET_USED_DCE_STYLE) != 0)
    {
        goto Cleanup;
    }


    if ((ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechId = gss_mech_krb5_u2u;
    }
    else
    {
        MechId = gss_mech_krb5_new;
    }

    ReplySize = g_token_size(
                    MechId,
                    *PackedReplySize);

    ReplyWithHeader = (PUCHAR) KerbAllocate(ReplySize);
    if (ReplyWithHeader == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // the g_make_token_header will reset this to point to the end of the
    // header
    //

    ReplyStart = ReplyWithHeader;

    g_make_token_header(
        MechId,
        *PackedReplySize,
        &ReplyStart,
        KG_TOK_CTX_AP_REP
        );

    DsysAssert(ReplyStart - ReplyWithHeader + *PackedReplySize == ReplySize);

    RtlCopyMemory(
            ReplyStart,
            *PackedReply,
            *PackedReplySize
            );

    KerbFree(*PackedReply);
    *PackedReply = ReplyWithHeader;
    *PackedReplySize = ReplySize;
    ReplyWithHeader = NULL;

Cleanup:
    if (Reply->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->encrypted_part.cipher_text.value);
        Reply->encrypted_part.cipher_text.value = NULL;
    }
    if (PackedApReply != NULL)
    {
        MIDL_user_free(PackedApReply);
    }
    if (!NT_SUCCESS(Status) && (*PackedReply != NULL))
    {
        KerbFree(*PackedReply);
        *PackedReply = NULL;
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildApReply
//
//  Synopsis:   Builds an AP reply message if mutual authentication is
//              desired.
//
//  Effects:    InternalAuthenticator - Authenticator from the AP request
//                  this reply is for.
//              Request - The AP request to which to reply.
//              ContextFlags - Contains context flags from the AP request.
//              SessionKey - The session key to use to build the reply,.
//                      receives the new session key (if KERB_AP_USE_SKEY
//                      is negotiated).
//              NewReply - Receives the AP reply.
//              NewReplySize - Receives the size of the AP reply.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS, STATUS_INSUFFICIENT_MEMORY, or errors from
//              KIEncryptData
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildApReply(
    IN PKERB_AUTHENTICATOR InternalAuthenticator,
    IN PKERB_AP_REQUEST Request,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PULONG Nonce,
    OUT PUCHAR * NewReply,
    OUT PULONG NewReplySize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_AP_REPLY Reply = {0};
    KERB_ENCRYPTED_AP_REPLY ReplyBody = {0};
    KERB_ENCRYPTION_KEY NewSessionKey = {0};
    BOOLEAN StrongEncryptionPermitted = KerbGlobalStrongEncryptionPermitted;

    *NewReply = NULL;
    *NewReplySize = 0;

#ifndef WIN32_CHICAGO
    {
        SECPKG_CALL_INFO CallInfo;

        if (!StrongEncryptionPermitted && LsaFunctions->GetCallInfo(&CallInfo))
        {
            if (CallInfo.Attributes & SECPKG_CALL_IN_PROC )
            {
                StrongEncryptionPermitted = TRUE;
            }
        }
    }
#endif

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_AP_REP;



    ReplyBody.client_time = InternalAuthenticator->client_time;
    ReplyBody.client_usec = InternalAuthenticator->client_usec;

    //
    // Generate a new nonce for the reply
    //

    *Nonce = KerbAllocateNonce();


    D_DebugLog((DEB_TRACE,"BuildApReply using nonce 0x%x\n",*Nonce));

    if (*Nonce != 0)
    {
        ReplyBody.KERB_ENCRYPTED_AP_REPLY_sequence_number = (int) *Nonce;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_AP_REPLY_sequence_number_present;

    }

    //
    // If the client wants to use a session key, create one now
    //

    if ((InternalAuthenticator->bit_mask & KERB_AUTHENTICATOR_subkey_present) != 0 )
    {
        KERBERR KerbErr;
        //
        // If the client sent us an export-strength subkey, use it
        //

        if (KerbIsKeyExportable(
                &InternalAuthenticator->KERB_AUTHENTICATOR_subkey
                ))
        {
            D_DebugLog((DEB_TRACE_CTXT,"Client sent exportable key, using it on server on server\n"));
            if (!KERB_SUCCESS(KerbDuplicateKey(
                                &NewSessionKey,
                                &InternalAuthenticator->KERB_AUTHENTICATOR_subkey
                                )))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
        else
        {

            //
            // If we are export-strength, create our own key. Otherwise use
            // the client's key.
            //

            if (!StrongEncryptionPermitted)
            {

                D_DebugLog((DEB_TRACE_CTXT,"Client sent strong key, making exportable key on server\n"));

                KerbErr = KerbMakeExportableKey(
                            Request->authenticator.encryption_type,
                            &NewSessionKey
                            );

            }
            else
            {
                D_DebugLog((DEB_TRACE_CTXT,"Client sent strong key, using it on server on server\n"));
                KerbErr = KerbDuplicateKey(
                            &NewSessionKey,
                            &InternalAuthenticator->KERB_AUTHENTICATOR_subkey
                            );
            }

            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }

        }
        ReplyBody.KERB_ENCRYPTED_AP_REPLY_subkey = NewSessionKey;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_AP_REPLY_subkey_present;
    }
    else
    {
        KERBERR KerbErr;
        //
        // Create a subkey ourselves if we are export strength
        //

        if (!StrongEncryptionPermitted)
        {
            D_DebugLog((DEB_TRACE_CTXT,"Client sent no key, making exportable on server\n"));
            KerbErr = KerbMakeExportableKey(
                        Request->authenticator.encryption_type,
                        &NewSessionKey
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }

        }
        else
        {
            KerbErr = KerbMakeKey(
                        Request->authenticator.encryption_type,
                        &NewSessionKey
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }

        }
        ReplyBody.KERB_ENCRYPTED_AP_REPLY_subkey = NewSessionKey;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_AP_REPLY_subkey_present;
    }

    Status = KerbMarshallApReply(
                &Reply,
                &ReplyBody,
                Request->authenticator.encryption_type,
                TicketKey,
                ContextFlags,
                ContextAttributes,
                NewReply,
                NewReplySize
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If they asked for a session key, replace our current session key
    // with it.
    //

    if (NewSessionKey.keyvalue.value != NULL)
    {
        KerbFreeKey(SessionKey);
        *SessionKey = NewSessionKey;
        RtlZeroMemory(
            &NewSessionKey,
            sizeof(KERB_ENCRYPTION_KEY)
            );
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeKey(&NewSessionKey);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildThirdLegApReply
//
//  Synopsis:   Builds a third leg AP reply message if DCE-style
//               authentication is desired.
//
//  Effects:    Context - Context for which to build this message.
//              NewReply - Receives the AP reply.
//              NewReplySize - Receives the size of the AP reply.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS, STATUS_INSUFFICIENT_MEMORY, or errors from
//              KIEncryptData
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildThirdLegApReply(
    IN PKERB_CONTEXT Context,
    IN ULONG ReceiveNonce,
    OUT PUCHAR * NewReply,
    OUT PULONG NewReplySize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_AP_REPLY Reply;
    KERB_ENCRYPTED_AP_REPLY ReplyBody;
    TimeStamp CurrentTime;

    RtlZeroMemory(
        &Reply,
        sizeof(KERB_AP_REPLY)
        );
    RtlZeroMemory(
        &ReplyBody,
        sizeof(KERB_ENCRYPTED_AP_REPLY)
        );
    *NewReply = NULL;
    *NewReplySize = 0;


    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_AP_REP;


    GetSystemTimeAsFileTime((PFILETIME)
        &CurrentTime
        );

        KerbConvertLargeIntToGeneralizedTimeWrapper(
        &ReplyBody.client_time,
        &ReplyBody.client_usec,
        &CurrentTime
        );


    ReplyBody.KERB_ENCRYPTED_AP_REPLY_sequence_number = ReceiveNonce;
    ReplyBody.bit_mask |= KERB_ENCRYPTED_AP_REPLY_sequence_number_present;

    D_DebugLog((DEB_TRACE,"Building third leg AP reply with nonce 0x%x\n",ReceiveNonce));
    //
    // We already negotiated context flags so don't bother filling them in
    // now.
    //


    KerbReadLockContexts();

    Status = KerbMarshallApReply(
                &Reply,
                &ReplyBody,
                Context->EncryptionType,
                &Context->TicketKey,
                Context->ContextFlags,
                Context->ContextAttributes,
                NewReply,
                NewReplySize
                );
    KerbUnlockContexts();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyApReply
//
//  Synopsis:   Verifies an AP reply corresponds to an AP request
//
//  Effects:    Decrypts the AP reply
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_LOGON_FAILURE
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbVerifyApReply(
    IN PKERB_CONTEXT Context,
    IN PUCHAR PackedReply,
    IN ULONG PackedReplySize,
    OUT PULONG Nonce
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_AP_REPLY Reply = NULL;
    PKERB_ENCRYPTED_AP_REPLY ReplyBody = NULL;
    BOOLEAN ContextsLocked = FALSE;
    ULONG StrippedReplySize = PackedReplySize;
    PUCHAR StrippedReply = PackedReply;
    gss_OID_desc * MechId;
    BOOLEAN StrongEncryptionPermitted = KerbGlobalStrongEncryptionPermitted;


#ifndef WIN32_CHICAGO
    {
        SECPKG_CALL_INFO CallInfo;

        if (!StrongEncryptionPermitted && LsaFunctions->GetCallInfo(&CallInfo))
        {
            if (CallInfo.Attributes & SECPKG_CALL_IN_PROC )
            {
                StrongEncryptionPermitted = TRUE;
            }
        }
    }
#endif

    //
    // Verify the GSSAPI header
    //

    KerbReadLockContexts();
    if ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) == 0)
    {
        if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
        {
            MechId = gss_mech_krb5_u2u;
        }
        else
        {
            MechId = gss_mech_krb5_new;
        }
        if (!g_verify_token_header(
                (gss_OID) MechId,
                (INT *) &StrippedReplySize,
                &StrippedReply,
                KG_TOK_CTX_AP_REP,
                PackedReplySize
                ))
        {
            //
            // BUG 454895: remove when not needed for compatibility
            //

            //
            // if that didn't work, just use the token as it is.
            //

            StrippedReply = PackedReply;
            StrippedReplySize = PackedReplySize;
            D_DebugLog((DEB_WARN,"Didn't find GSS header on AP Reply\n"));

        }
    }
    KerbUnlockContexts();

    if (!KERB_SUCCESS(KerbUnpackApReply(
                        StrippedReply,
                        StrippedReplySize,
                        &Reply
                        )))
    {
        D_DebugLog((DEB_WARN,"Failed to unpack AP reply\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if ((Reply->version != KERBEROS_VERSION) ||
        (Reply->message_type != KRB_AP_REP))
    {
        D_DebugLog((DEB_ERROR,"Illegal version or message as AP reply: 0x%x, 0x%x. %ws, line %d\n",
            Reply->version, Reply->message_type, THIS_FILE, __LINE__ ));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }


    //
    // Now decrypt the encrypted part.
    //

    KerbWriteLockContexts();
    ContextsLocked = TRUE;
    KerbReadLockTicketCache();

    KerbErr = KerbDecryptDataEx(
                &Reply->encrypted_part,
                &Context->TicketKey,
                KERB_AP_REP_SALT,
                (PULONG) &Reply->encrypted_part.cipher_text.length,
                Reply->encrypted_part.cipher_text.value
                );
    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to decrypt AP reply: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        if (KerbErr == KRB_ERR_GENERIC)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }


    //
    // Decode the contents now
    //

    if (!KERB_SUCCESS(KerbUnpackApReplyBody(
                        Reply->encrypted_part.cipher_text.value,
                        Reply->encrypted_part.cipher_text.length,
                        &ReplyBody)))
    {
        DebugLog((DEB_ERROR, "Failed to unpack AP reply body. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    if ((ReplyBody->bit_mask & KERB_ENCRYPTED_AP_REPLY_sequence_number_present) != 0)
    {
        *Nonce = ReplyBody->KERB_ENCRYPTED_AP_REPLY_sequence_number;

        D_DebugLog((DEB_TRACE,"Verifying AP reply: AP nonce = 0x%x, context nonce = 0x%x, receive nonce = 0x%x\n",
             *Nonce,
             Context->Nonce,
             Context->ReceiveNonce
             ));
        //
        // If this is a third-leg AP reply, verify the nonce.
        //

        if ((Context->ContextAttributes & KERB_CONTEXT_INBOUND) != 0)
        {
            if (*Nonce != Context->Nonce)
            {
                D_DebugLog((DEB_ERROR,"Nonce in third-leg AP rep didn't match context: 0x%x vs 0x%x\n",
                    *Nonce, Context->Nonce ));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }
        }

    }
    else
    {
        *Nonce = 0;
    }

    //
    // Check to see if a new session key was sent back. If it was, stick it
    // in the context.
    //


    if ((ReplyBody->bit_mask & KERB_ENCRYPTED_AP_REPLY_subkey_present) != 0)
    {
        if (!StrongEncryptionPermitted)
        {
            if (!KerbIsKeyExportable(&ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey))
            {
                D_DebugLog((DEB_ERROR,"Server did not accept client's export strength key. %ws, line %d\n", THIS_FILE, __LINE__));

                Status = STATUS_STRONG_CRYPTO_NOT_SUPPORTED;
                goto Cleanup;
            }
        }
        KerbFreeKey(&Context->SessionKey);
        if (!KERB_SUCCESS(KerbDuplicateKey(
            &Context->SessionKey,
            &ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey
            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


    }


    Status = STATUS_SUCCESS;

Cleanup:
    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }

    if (Reply != NULL)
    {
        KerbFreeApReply(Reply);
    }
    if (ReplyBody != NULL)
    {
        KerbFreeApReplyBody(ReplyBody);
    }
    return(Status);
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbInitTicketHandling
//
//  Synopsis:   Initializes ticket handling, such as authenticator list
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:   NTSTATUS code
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitTicketHandling(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TimeStamp MaxAuthenticatorAge;
#ifndef WIN32_CHICAGO
    LPNET_CONFIG_HANDLE ConfigHandle = NULL;
    BOOL TempBool;
#endif // WIN32_CHICAGO
    ULONG SkewTimeInMinutes = KERB_DEFAULT_SKEWTIME;
    NET_API_STATUS NetStatus = ERROR_SUCCESS;
    ULONG FarKdcTimeout = KERB_BINDING_FAR_DC_TIMEOUT;
    ULONG NearKdcTimeout = KERB_BINDING_NEAR_DC_TIMEOUT;
    ULONG SpnCacheTimeout = KERB_SPN_CACHE_TIMEOUT;
    //
    // Initialize the kerberos token source
    //

    RtlCopyMemory(
        KerberosSource.SourceName,
        "Kerberos",
        sizeof("Kerberos")
        );

    NtAllocateLocallyUniqueId(&KerberosSource.SourceIdentifier);

    KerbGlobalKdcWaitTime = KERB_KDC_WAIT_TIME;
    KerbGlobalKdcCallTimeout = KERB_KDC_CALL_TIMEOUT;
    KerbGlobalKdcCallBackoff = KERB_KDC_CALL_TIMEOUT_BACKOFF;
    KerbGlobalMaxDatagramSize = KERB_MAX_DATAGRAM_SIZE;
    KerbGlobalKdcSendRetries = KERB_MAX_RETRIES;
    KerbGlobalMaxReferralCount = KERB_MAX_REFERRAL_COUNT;
    KerbGlobalUseSidCache = KERB_DEFAULT_USE_SIDCACHE;
    KerbGlobalUseStrongEncryptionForDatagram = KERB_DEFAULT_USE_STRONG_ENC_DG;
    KerbGlobalDefaultPreauthEtype = KERB_ETYPE_RC4_HMAC_NT;
    KerbGlobalMaxTokenSize = KERBEROS_MAX_TOKEN;

#ifndef WIN32_CHICAGO
    //
    // Set the max authenticator age to be less than the allowed skew time
    // on debug builds so we can have widely varying time on machines but
    // don't build up a huge list of authenticators.
    //

    NetStatus = NetpOpenConfigDataWithPath(
                    &ConfigHandle,
                    NULL,               // no server name
                    KERB_PARAMETER_PATH,
                    TRUE                // read only
                    );
    if (NetStatus == ERROR_SUCCESS)
    {
        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_SKEWTIME,
                        KERB_DEFAULT_SKEWTIME,
                        &SkewTimeInMinutes
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_MAX_TOKEN_SIZE,
                        KERBEROS_MAX_TOKEN,
                        &KerbGlobalMaxTokenSize
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        //
        // Get the far timeout for the kdc
        //

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_FAR_KDC_TIMEOUT,
                        KERB_BINDING_FAR_DC_TIMEOUT,
                        &FarKdcTimeout
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        //
        // Get the near timeout for the kdc
        //
        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_NEAR_KDC_TIMEOUT,
                        KERB_BINDING_NEAR_DC_TIMEOUT,
                        &NearKdcTimeout
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        //
        // Get the near timeout for the kdc
        //
        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_SPN_CACHE_TIMEOUT,
                        KERB_SPN_CACHE_TIMEOUT,
                        &SpnCacheTimeout
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }


        //
        // Get the wait time for the service to start
        //

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_START_TIME,
                        KERB_KDC_WAIT_TIME,
                        &KerbGlobalKdcWaitTime
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_KDC_CALL_TIMEOUT,
                        KERB_KDC_CALL_TIMEOUT,
                        &KerbGlobalKdcCallTimeout
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_MAX_UDP_PACKET,
                        KERB_MAX_DATAGRAM_SIZE,
                        &KerbGlobalMaxDatagramSize
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_KDC_BACKOFF_TIME,
                        KERB_KDC_CALL_TIMEOUT_BACKOFF,
                        &KerbGlobalKdcCallBackoff
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }
        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_MAX_REFERRAL_COUNT,
                        KERB_MAX_REFERRAL_COUNT,
                        &KerbGlobalMaxReferralCount
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }


        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_KDC_SEND_RETRIES,
                        KERB_MAX_RETRIES,
                        &KerbGlobalKdcSendRetries
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }


        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_LOG_LEVEL,
                        KERB_DEFAULT_LOGLEVEL,
                        &KerbGlobalLoggingLevel
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_DEFAULT_ETYPE,
                        KerbGlobalDefaultPreauthEtype,
                        &KerbGlobalDefaultPreauthEtype
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }


        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_REQUEST_OPTIONS,
                        KERB_ADDITIONAL_KDC_OPTIONS,
                        &KerbGlobalKdcOptions
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }


        NetStatus = NetpGetConfigBool(
                        ConfigHandle,
                        KERB_PARAMETER_USE_SID_CACHE,
                        KERB_DEFAULT_USE_SIDCACHE,
                        &TempBool
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }
        KerbGlobalUseSidCache = (BOOLEAN)( TempBool != 0 );

        //
        // BUG 454981: get this from the same place as NTLM
        //

        NetStatus = NetpGetConfigBool(
                        ConfigHandle,
                        KERB_PARAMETER_STRONG_ENC_DG,
                        KERB_DEFAULT_USE_STRONG_ENC_DG,
                        &TempBool
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }
        KerbGlobalUseStrongEncryptionForDatagram = (BOOLEAN)(TempBool != 0 );

        //
        // Bug 356539: configuration key to regulate whether clients request
        //             addresses in tickets
        //

        NetStatus = NetpGetConfigBool(
                        ConfigHandle,
                        KERB_PARAMETER_CLIENT_IP_ADDRESSES,
                        KERB_DEFAULT_CLIENT_IP_ADDRESSES,
                        &TempBool
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }
        KerbGlobalUseClientIpAddresses = (BOOLEAN)( TempBool != 0 );

        //
        // Bug 353767: configuration key to regulate the TGT renewal interval
        //             - set to 10 hours less 5 minutes by default
        //

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_TGT_RENEWAL_INTERVAL,
                        KERB_DEFAULT_TGT_RENEWAL_INTERVAL,
                        &KerbGlobalTgtRenewalInterval
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }
    }
#endif // WIN32_CHICAGO


    KerbSetTimeInMinutes(&KerbGlobalSkewTime, SkewTimeInMinutes);
    KerbSetTimeInMinutes(&MaxAuthenticatorAge, SkewTimeInMinutes);
    KerbSetTimeInMinutes(&KerbGlobalFarKdcTimeout,FarKdcTimeout);
    KerbSetTimeInMinutes(&KerbGlobalNearKdcTimeout, NearKdcTimeout);
    KerbSetTimeInMinutes(&KerbGlobalSpnCacheTimeout, SpnCacheTimeout);
#ifndef WIN32_CHICAGO
    Authenticators = new CAuthenticatorList( MaxAuthenticatorAge );
    if (Authenticators == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
#endif WIN32_CHICAGO


    //
    // Initialize the time skew code
    //

    Status = KerbInitializeSkewState();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
Cleanup:
#ifndef WIN32_CHICAGO
    if (ConfigHandle != NULL)
    {
        NetpCloseConfigData( ConfigHandle );
    }
#endif // WIN32_CHICAGO

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupTicketHandling
//
//  Synopsis:   cleans up ticket handling state, such as the
//              list of authenticators.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbCleanupTicketHandling(
    VOID
    )
{
#ifndef WIN32_CHICAGO
    if (Authenticators != NULL)
    {
        delete Authenticators;
    }
#endif // WIN32_CHICAGO
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildTgtRequest
//
//  Synopsis:   Creates a tgt request for user-to-user authentication
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildTgtRequest(
    IN PKERB_INTERNAL_NAME TargetName,
    IN PUNICODE_STRING TargetRealm,
    OUT PULONG ContextAttributes,
    OUT PUCHAR * MarshalledTgtRequest,
    OUT PULONG TgtRequestSize
    )
{
    KERB_TGT_REQUEST Request = {0};
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PBYTE TempRequest = NULL;
    PBYTE RequestStart;
    ULONG TempRequestSize = 0;

    //
    // First build the request
    //

    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_TGT_REQ;
    if (TargetName->NameCount > 0)
    {
        KerbErr = KerbConvertKdcNameToPrincipalName(
                    &Request.KERB_TGT_REQUEST_server_name,
                    TargetName
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
        Request.bit_mask |= KERB_TGT_REQUEST_server_name_present;
    }
    else
    {
        *ContextAttributes |= KERB_CONTEXT_REQ_SERVER_NAME;
    }

    if (TargetRealm->Length > 0)
    {
        KerbErr = KerbConvertUnicodeStringToRealm(
                        &Request.server_realm,
                        TargetRealm
                        );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
        Request.bit_mask |= server_realm_present;
    }
    else
    {
        *ContextAttributes |= KERB_CONTEXT_REQ_SERVER_REALM;
    }

    //
    // Encode the request
    //

    KerbErr = KerbPackData(
                &Request,
                KERB_TGT_REQUEST_PDU,
                &TempRequestSize,
                &TempRequest
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Now add on the space for the OID
    //

    *TgtRequestSize = g_token_size(
                        gss_mech_krb5_u2u,
                        TempRequestSize
                        );
    *MarshalledTgtRequest = (PBYTE) MIDL_user_allocate(
                                        *TgtRequestSize
                                        );
    if (*MarshalledTgtRequest == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Add the token ID & mechanism
    //

    RequestStart = *MarshalledTgtRequest;

    g_make_token_header(
        gss_mech_krb5_u2u,
        TempRequestSize,
        &RequestStart,
        KG_TOK_CTX_TGT_REQ
        );

    RtlCopyMemory(
        RequestStart,
        TempRequest,
        TempRequestSize
        );

    Status = STATUS_SUCCESS;

Cleanup:

    if (TempRequest != NULL )
    {
        MIDL_user_free(TempRequest);
    }
    KerbFreePrincipalName(
        &Request.KERB_TGT_REQUEST_server_name
        );
    if ((Request.bit_mask & server_realm_present) != 0)
    {
        KerbFreeRealm(
            &Request.server_realm
            );
    }

    return(Status);


}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildTgtReply
//
//  Synopsis:   Builds a TGT reply with the appropriate options set
//
//  Effects:
//
//  Arguments:
//
//  Requires:   The logonsession / credential must be LOCKD!
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS
KerbBuildTgtReply(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credentials,
    IN PUNICODE_STRING pSuppRealm,
    OUT PKERBERR ReturnedError,
    OUT PBYTE * MarshalledReply,
    OUT PULONG ReplySize,
    OUT PKERB_TICKET_CACHE_ENTRY * TgtUsed
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_TICKET_CACHE_ENTRY* TicketGrantingTicket = NULL;
    KERB_TGT_REPLY Reply = {0};
    UNICODE_STRING TempName = {0};
    BOOLEAN CrossRealm = FALSE;

    *TgtUsed = NULL;                    ;

    D_DebugLog((DEB_TRACE_U2U, "KerbBuildTgtReply SuppRealm %wZ\n", pSuppRealm));

    Status = KerbGetTgtForService(
                LogonSession,
                Credentials,
                NULL,       // no credman on the server side
                pSuppRealm, // SuppRealm is the server's realm
                &TempName,  // no target realm
                KERB_TICKET_CACHE_PRIMARY_TGT,
                &TicketGrantingTicket,
                &CrossRealm
                );

    if (!NT_SUCCESS(Status) || CrossRealm)
    {
        DebugLog((DEB_ERROR, "KerbBuildTgtReply failed to get TGT, CrossRealm ? %s\n", CrossRealm ? "true" : "false"));
        *ReturnedError = KRB_AP_ERR_NO_TGT;
        Status = STATUS_USER2USER_REQUIRED;
        goto Cleanup;
    }

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_TGT_REP;

    KerbReadLockTicketCache();
    Reply.ticket = TicketGrantingTicket->Ticket;

    //
    // Marshall the output
    //

    KerbErr = KerbPackData(
                &Reply,
                KERB_TGT_REPLY_PDU,
                ReplySize,
                MarshalledReply
                );

    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    *TgtUsed = TicketGrantingTicket;
    TicketGrantingTicket = NULL;
Cleanup:

    if (TicketGrantingTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }

    KerbFreeString(&TempName);

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildTgtErrorReply
//
//  Synopsis:   Builds a TgtReply message for use in a KERB_ERROR message
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbBuildTgtErrorReply(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN BOOLEAN UseSuppliedCreds,
    IN OUT PKERB_CONTEXT Context,
    OUT PULONG ReplySize,
    OUT PBYTE * Reply
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    PKERB_TICKET_CACHE_ENTRY TgtUsed = NULL, OldTgt = NULL;

    KerbReadLockLogonSessions(LogonSession);

    if ( UseSuppliedCreds )
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }

    Status = KerbBuildTgtReply(
                 LogonSession,
                 Credential,
                 &PrimaryCredentials->DomainName,
                 &KerbErr,
                 Reply,
                 ReplySize,
                 &TgtUsed
                 );
    KerbUnlockLogonSessions(LogonSession);

    //
    // Store the cache entry in the context
    //

    if (NT_SUCCESS(Status))
    {
        KerbWriteLockContexts();
        OldTgt = Context->TicketCacheEntry;
        Context->TicketCacheEntry = TgtUsed;

        //
        // On the error path, do not set KERB_CONTEXT_USER_TO_USER because the
        // client do not expect user2user at this moment
        //
        // Context->ContextAttributes |= KERB_CONTEXT_USER_TO_USER;
        //

        KerbUnlockContexts();

        DebugLog((DEB_TRACE_U2U, "KerbHandleTgtRequest (TGT in error reply) saving ASC context->TicketCacheEntry, TGT is %p, was %p\n", TgtUsed, OldTgt));

        TgtUsed = NULL;

        if (OldTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(OldTgt);
        }
    }

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbHandleTgtRequest
//
//  Synopsis:   Processes a request for a TGT. It will verify the supplied
//              principal names and marshall a TGT response structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbHandleTgtRequest(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN BOOLEAN UseSuppliedCreds,
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN ULONG ContextRequirements,
    IN PSecBuffer OutputToken,
    IN PLUID LogonId,
    OUT PULONG ContextAttributes,
    OUT PKERB_CONTEXT * Context,
    OUT PTimeStamp ContextLifetime,
    OUT PKERBERR ReturnedError
    )
{
    ULONG StrippedRequestSize;
    PUCHAR StrippedRequest;
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_TGT_REQUEST Request = NULL;
    BOOLEAN LockAcquired = FALSE;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    PKERB_TICKET_CACHE_ENTRY pOldTgt = NULL;
    ULONG ReplySize = 0;
    PBYTE MarshalledReply = NULL;
    ULONG FinalSize;
    PBYTE ReplyStart;
    PKERB_TICKET_CACHE_ENTRY TgtUsed = NULL;

    D_DebugLog((DEB_TRACE,"Handling TGT request\n"));
    StrippedRequestSize = RequestSize;
    StrippedRequest = RequestMessage;

    *ReturnedError = KDC_ERR_NONE;

    //
    // We need an output  token
    //

    if (OutputToken == NULL)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    //
    // Check if this is user-to-user kerberos
    //

    if (g_verify_token_header(
            gss_mech_krb5_u2u,
            (INT *) &StrippedRequestSize,
            &StrippedRequest,
            KG_TOK_CTX_TGT_REQ,
            RequestSize))
    {
        *ContextAttributes |= ASC_RET_USE_SESSION_KEY;

    }
    else
    {
        Status = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Decode the tgt request message.
    //

    KerbErr = KerbUnpackData(
                StrippedRequest,
                StrippedRequestSize,
                KERB_TGT_REQUEST_PDU,
                (PVOID *) &Request
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to decode TGT request: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    KerbReadLockLogonSessions(LogonSession);

    if ( UseSuppliedCreds )
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }
    LockAcquired = TRUE;

    //
    // Check the supplied principal name and realm to see if it matches
    // out credentials
    //

    //
    // We don't need to verify the server name because the client can do
    // that.
    //

    //
    // Allocate a context
    //

    Status = KerbCreateEmptyContext(
                Credential,
                ASC_RET_USE_SESSION_KEY,        // indicating user-to-user
                KERB_CONTEXT_USER_TO_USER | KERB_CONTEXT_INBOUND,
                LogonId,
                Context,
                ContextLifetime
                );

    DebugLog((DEB_TRACE_U2U, "KerbHandleTgtRequest (TGT in TGT reply) USER2USER-INBOUND set %#x\n", Status));

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Put it in the context for later use
    //

    Status = KerbBuildTgtReply(
        LogonSession,
        Credential,
        &PrimaryCredentials->DomainName,
        ReturnedError,
        &MarshalledReply,
        &ReplySize,
        &TgtUsed
        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Put it in the context for later use
    //

    KerbWriteLockContexts();
    pOldTgt = (*Context)->TicketCacheEntry;
    (*Context)->TicketCacheEntry = TgtUsed;
    KerbUnlockContexts();

    DebugLog((DEB_TRACE_U2U, "KerbHandleTgtRequest (TGT in TGT reply) saving ASC context->TicketCacheEntry, TGT is %p, was %p\n", TgtUsed, pOldTgt));
    TgtUsed = NULL;

    if (pOldTgt)
    {
        KerbDereferenceTicketCacheEntry(pOldTgt);
    }

    //
    // Now build the output message
    //

    FinalSize = g_token_size(
                    gss_mech_krb5_u2u,
                    ReplySize
                    );


    if ((ContextRequirements & ASC_REQ_ALLOCATE_MEMORY) == 0)
    {
        if (OutputToken->cbBuffer < FinalSize)
        {
            D_DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                OutputToken->cbBuffer,ReplySize, THIS_FILE, __LINE__ ));
            Status = STATUS_BUFFER_TOO_SMALL;
            goto Cleanup;
        }

    }
    else
    {
        OutputToken->pvBuffer = KerbAllocate(FinalSize);
        if (OutputToken->pvBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
    }

    ReplyStart = (PUCHAR) OutputToken->pvBuffer;
    g_make_token_header(
        gss_mech_krb5_u2u,
        ReplySize,
        &ReplyStart,
        KG_TOK_CTX_TGT_REP
        );

    RtlCopyMemory(
        ReplyStart,
        MarshalledReply,
        ReplySize
        );

    OutputToken->cbBuffer = FinalSize;
    KerbWriteLockContexts();
    (*Context)->ContextState = TgtReplySentState;
    KerbUnlockContexts();

Cleanup:
    if (LockAcquired)
    {
        KerbUnlockLogonSessions(LogonSession);
    }
    if (CacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }

    if (TgtUsed != NULL)
    {
        KerbDereferenceTicketCacheEntry(TgtUsed);
    }
    if (MarshalledReply != NULL)
    {
        MIDL_user_free(MarshalledReply);
    }
    if (Request != NULL)
    {
        KerbFreeData(KERB_TGT_REQUEST_PDU, Request);
    }

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackTgtReply
//
//  Synopsis:   Unpacks a TGT reply and verifies contents, sticking
//              reply into context.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbUnpackTgtReply(
    IN PKERB_CONTEXT Context,
    IN PUCHAR ReplyMessage,
    IN ULONG ReplySize,
    OUT PKERB_INTERNAL_NAME * TargetName,
    OUT PUNICODE_STRING TargetRealm,
    OUT PKERB_TGT_REPLY * Reply
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING LocalTargetRealm = {0};
    PUCHAR StrippedReply = ReplyMessage;
    ULONG StrippedReplySize = ReplySize;
    ULONG ContextAttributes;

    *Reply = NULL;
    KerbReadLockContexts();
    ContextAttributes = Context->ContextAttributes;
    KerbUnlockContexts();

    D_DebugLog((DEB_TRACE_U2U, "KerbUnpackTgtReply is User2User set in ContextAttributes? %s\n", ContextAttributes & KERB_CONTEXT_USER_TO_USER ? "yes" : "no"));

    //
    // Verify the OID header on the response. If this wasn't a user-to-user
    // context then the message came from a KERB_ERROR message and won't
    // have the OID header.
    //

    if ((ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        if (!g_verify_token_header(
                gss_mech_krb5_u2u,
                (INT *) &StrippedReplySize,
                &StrippedReply,
                KG_TOK_CTX_TGT_REP,
                ReplySize))
        {
            D_DebugLog((DEB_WARN, "Failed to verify u2u token header\n"));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }
    }
    else
    {
        StrippedReply = ReplyMessage;
        StrippedReplySize = ReplySize;

        //
        // this is an error tgt reply
        //

        KerbWriteLockContexts();
        Context->ContextFlags |= ISC_RET_USE_SESSION_KEY;

        //
        // KERB_CONTEXT_USER_TO_USER needs to be set
        //

        Context->ContextAttributes |= KERB_CONTEXT_USER_TO_USER;
        KerbUnlockContexts();

        DebugLog((DEB_TRACE_U2U, "KerbUnpackTgtReply (TGT in error reply) USER2USER-OUTBOUND set\n"));
    }

    //
    // Decode the response
    //

    KerbErr = KerbUnpackData(
                StrippedReply,
                StrippedReplySize,
                KERB_TGT_REPLY_PDU,
                (PVOID *) Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Pull the target name & realm out of the TGT reply message
    //

    KerbErr = KerbConvertRealmToUnicodeString(
                    &LocalTargetRealm,
                    &(*Reply)->ticket.realm
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    //
    // If we were asked to get the server & realm name, use them now
    //

    //
    // BUG 455793: we also use them if we weren't passed a target name on this
    // call. Since we don't require names to be passed, though, this is
    // a security problem, as mutual authentication is no longer guaranteed.
    //

    if (((ContextAttributes & KERB_CONTEXT_REQ_SERVER_REALM) != 0)  ||
        (TargetRealm->Length == 0))
    {
        KerbFreeString(
            TargetRealm
            );
        *TargetRealm = LocalTargetRealm;
        LocalTargetRealm.Buffer = NULL;
    }

    if (((ContextAttributes & KERB_CONTEXT_REQ_SERVER_NAME) != 0) ||
        (((*TargetName)->NameCount == 1) && ((*TargetName)->Names[0].Length == 0)))
    {
        ULONG ProcessFlags = 0;
        UNICODE_STRING TempRealm = {0};

        KerbFreeKdcName(
            TargetName
            );

        Status = KerbProcessTargetNames(
                    &Context->ServerPrincipalName,
                    NULL,                               // no local target name
                    0,                                  // no flags
                    &ProcessFlags,
                    TargetName,
                    &TempRealm,
                    NULL
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        KerbFreeString(&TempRealm);

    }


Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (*Reply != NULL)
        {
            KerbFreeData(
                KERB_TGT_REPLY_PDU,
                *Reply
                );
            *Reply = NULL;
        }
    }

    if (LocalTargetRealm.Buffer != NULL)
    {
        KerbFreeString(
            &LocalTargetRealm
            );
    }

    return(Status);


}


//+-------------------------------------------------------------------------
//
//  Function:   KerbComputeGssBindHash
//
//  Synopsis:   Computes the Channel Bindings Hash for GSSAPI
//
//  Effects:
//
//  Arguments:
//
//  Requires:   At least 16 bytes allocated to HashBuffer
//
//  Returns:
//
//  Notes:
// (viz. RFC1964)
// MD5 hash of channel bindings, taken over all non-null
// components of bindings, in order of declaration.
// Integer fields within channel bindings are represented
// in little-endian order for the purposes of the MD5
// calculation.
//
//--------------------------------------------------------------------------

NTSTATUS
KerbComputeGssBindHash(
    IN PSEC_CHANNEL_BINDINGS pChannelBindings,
    OUT PUCHAR HashBuffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCHECKSUM_FUNCTION MD5Check = NULL;
    PCHECKSUM_BUFFER MD5ScratchBuffer = NULL;

    //
    // Locate the MD5 Hash Function
    //
    Status = CDLocateCheckSum(KERB_CHECKSUM_MD5, &MD5Check);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure Locating MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );

        goto Cleanup;
    }

    //
    // Initialize the Buffer
    //
    Status = MD5Check->Initialize(0, &MD5ScratchBuffer);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure initializing MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );

        goto Cleanup;
    }

    //
    // Build the MD5 hash
    //
    Status = MD5Check->Sum(MD5ScratchBuffer,
                           sizeof(DWORD),
                           (PUCHAR) &pChannelBindings->dwInitiatorAddrType );

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure building MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );
    }

    Status = MD5Check->Sum(MD5ScratchBuffer,
                           sizeof(DWORD),
                           (PUCHAR) &pChannelBindings->cbInitiatorLength );

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure building MD5: 0x%x. %ws, line %d\n",
                    Status,
                    THIS_FILE,
                    __LINE__) );
    }

    if( pChannelBindings->cbInitiatorLength )
    {
        Status = MD5Check->Sum(MD5ScratchBuffer,
                               pChannelBindings->cbInitiatorLength,
                               (PUCHAR) pChannelBindings + pChannelBindings->dwInitiatorOffset);

        if( !NT_SUCCESS(Status) )
        {
            D_DebugLog( (DEB_ERROR,
                       "Failure building MD5: 0x%x. %ws, line %d\n",
                        Status,
                        THIS_FILE,
                        __LINE__) );
        }
    }

    Status = MD5Check->Sum(MD5ScratchBuffer,
                           sizeof(DWORD),
                           (PUCHAR) &pChannelBindings->dwAcceptorAddrType);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure building MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );
    }

    Status = MD5Check->Sum(MD5ScratchBuffer,
                           sizeof(DWORD),
                           (PUCHAR) &pChannelBindings->cbAcceptorLength);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure building MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );
    }

    if( pChannelBindings->cbAcceptorLength)
    {
        Status = MD5Check->Sum(MD5ScratchBuffer,
                               pChannelBindings->cbAcceptorLength,
                               (PUCHAR) pChannelBindings + pChannelBindings->dwAcceptorOffset);

        if( !NT_SUCCESS(Status) )
        {
            D_DebugLog( (DEB_ERROR,
                       "Failure building MD5: 0x%x. %ws, line %d\n",
                       Status,
                       THIS_FILE,
                       __LINE__) );
        }
    }

    Status = MD5Check->Sum(MD5ScratchBuffer,
                           sizeof(DWORD),
                           (PUCHAR) &pChannelBindings->cbApplicationDataLength);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure building MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );
    }

    if( pChannelBindings->cbApplicationDataLength)
    {
        Status = MD5Check->Sum(MD5ScratchBuffer,
                               pChannelBindings->cbApplicationDataLength,
                               (PUCHAR) pChannelBindings + pChannelBindings->dwApplicationDataOffset);

        if( !NT_SUCCESS(Status) )
        {
            D_DebugLog( (DEB_ERROR,
                       "Failure building MD5: 0x%x. %ws, line %d\n",
                       Status,
                       THIS_FILE,
                       __LINE__) );
        }
    }


    //
    // Copy the hash results into the checksum field
    //
    DsysAssert( MD5Check->CheckSumSize == 4*sizeof(ULONG) );

    Status = MD5Check->Finalize( MD5ScratchBuffer, HashBuffer );

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure Finalizing MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );

        goto Cleanup;
    }

Cleanup:

    if( MD5Check != NULL )
    {
        MD5Check->Finish( &MD5ScratchBuffer );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbtick.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   kerbtick.h
//
//  Contents:   Structures for ticket request and creation
//
//  Classes:
//
//  Functions:
//
//  History:    22-April-1996   Created         MikeSw
//
//----------------------------------------------------------------------------

#ifndef __KERBTICK_H__
#define __KERBTICK_H__

//
// Macros used for building tickets
//

#define KERB_ENCRYPT_SIZE(_x_) (sizeof(KERB_ENCRYPTED_DATA) - 1 + (_x_))

//
// Structures used for AP (authentication protocol) exchanges with a server
//




//#define KERB_AP_INTEGRITY   0x80000000  // Integrity Request
//#define KERB_AP_PRIVACY     0x40000000  // Privacy
//#define KERB_AP_THREE_LEG   0x20000000  // Mutual Auth 3-leg
//#define KERB_AP_RETURN_EE   0x10000000  // Return extended error info
//#define KERB_AP_USE_SKEY    0x00000002  // Use session key
//#define KERB_AP_MUTUAL_REQ  0x00000004

//
// Structure used to store GSS checksum
//

typedef struct _KERB_GSS_CHECKSUM {
    ULONG BindLength;
    ULONG BindHash[4];
    ULONG GssFlags;
    USHORT Delegation;
    USHORT DelegationLength;
    UCHAR DelegationInfo[ANYSIZE_ARRAY];
} KERB_GSS_CHECKSUM, *PKERB_GSS_CHECKSUM;

#define GSS_C_DELEG_FLAG        0x01
#define GSS_C_MUTUAL_FLAG       0x02
#define GSS_C_REPLAY_FLAG       0x04
#define GSS_C_SEQUENCE_FLAG     0x08
#define GSS_C_CONF_FLAG         0x10
#define GSS_C_INTEG_FLAG        0x20
#define GSS_C_ANON_FLAG         0x40
#define GSS_C_DCE_STYLE         0x1000
#define GSS_C_IDENTIFY_FLAG     0x2000
#define GSS_C_EXTENDED_ERROR_FLAG 0x4000

#define GSS_CHECKSUM_TYPE       0x8003
#define GSS_CHECKSUM_SIZE       24

// This was added due to sizeof() byte alignment issues on 
// the KREB_GSS_CHECKSUM structure.
#define GSS_DELEGATE_CHECKSUM_SIZE 28


//
// KerbGetTgsTicket retry flags
//

#define KERB_MIT_NO_CANONICALIZE_RETRY 0x00000001  // for MIT no canonicalize retry case
#define KERB_RETRY_WITH_NEW_TGT        0x00000002


//
// Default flags for use in ticket requests
//

#define KERB_DEFAULT_TICKET_FLAGS (KERB_KDC_OPTIONS_forwardable | \
                                        KERB_KDC_OPTIONS_renewable | \
                                        KERB_KDC_OPTIONS_renewable_ok | \
                                        KERB_KDC_OPTIONS_name_canonicalize )
                                        

//
// These flags don't have to be in the TGT in order to be honored.  Reg. 
// configurable.
//
#define KERB_ADDITIONAL_KDC_OPTIONS     (KERB_KDC_OPTIONS_name_canonicalize)


NTSTATUS
KerbGetReferralNames(
    IN PKERB_ENCRYPTED_KDC_REPLY KdcReply,
    IN PKERB_INTERNAL_NAME OriginalTargetName,
    OUT PUNICODE_STRING ReferralRealm
    );

NTSTATUS
KerbMITGetMachineDomain(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_INTERNAL_NAME TargetName,
    IN OUT PUNICODE_STRING TargetDomainName,
    IN OUT PKERB_TICKET_CACHE_ENTRY *TicketGrantingTicket
    );



NTSTATUS
KerbGetTgtForService(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN PUNICODE_STRING TargetDomain,
    IN ULONG TargetFlags,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry,
    OUT PBOOLEAN CrossRealm
    );


NTSTATUS
KerbGetTgsTicket(
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket,
    IN PKERB_INTERNAL_NAME TargetName,
    IN ULONG Flags,
    IN OPTIONAL ULONG TicketOptions,
    IN OPTIONAL ULONG EncryptionType,
    IN OPTIONAL PKERB_AUTHORIZATION_DATA AuthorizationData,
    IN OPTIONAL PKERB_PA_DATA_LIST PADataList,
    IN OPTIONAL PKERB_TGT_REPLY TgtReply,
    OUT PKERB_KDC_REPLY * KdcReply,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody,
    OUT PULONG pRetryFlags
    );


NTSTATUS
KerbGetServiceTicket(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_INTERNAL_NAME TargetName,
    IN PUNICODE_STRING TargetDomainName,
    IN OPTIONAL PKERB_SPN_CACHE_ENTRY SpnCacheEntry,
    IN ULONG Flags,
    IN OPTIONAL ULONG TicketOptions,
    IN OPTIONAL ULONG EncryptionType,
    IN OPTIONAL PKERB_ERROR ErrorMessage,
    IN OPTIONAL PKERB_AUTHORIZATION_DATA AuthorizationData,
    IN OPTIONAL PKERB_TGT_REPLY TgtReply,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry,
    OUT LPGUID pLogonGuid OPTIONAL
    );

#define KERB_GET_TICKET_NO_CACHE                0x1
#define KERB_GET_TICKET_NO_CANONICALIZE         0x2
#define KERB_GET_TICKET_S4U                     0x4

#define KERB_TARGET_USED_SPN_CACHE              0x1000
#define KERB_TARGET_UNKNOWN_SPN                 0x2000
#define KERB_MIT_REALM_USED                     0x4000
#define KERB_TARGET_REFERRAL                    0x8000

NTSTATUS
KerbBuildApRequest(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN OPTIONAL PKERB_ERROR ErrorMessage,
    IN ULONG ContextAttributes,
    IN OUT PULONG ContextFlags,
    OUT PUCHAR * MarshalledApRequest,
    OUT PULONG ApRequestSize,
    OUT PULONG Nonce,
    OUT PKERB_ENCRYPTION_KEY SubSessionKey,
    IN PSEC_CHANNEL_BINDINGS pChannelBindings
    );

NTSTATUS
KerbBuildNullSessionApRequest(
    OUT PUCHAR * MarshalledApRequest,
    OUT PULONG ApRequestSize
    );


NTSTATUS
KerbVerifyApRequest(
    IN OPTIONAL PKERB_CONTEXT Context,
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN BOOLEAN UseSuppliedCreds,
    IN BOOLEAN CheckForReplay,
    OUT PKERB_AP_REQUEST  * ApRequest,
    OUT PKERB_ENCRYPTED_TICKET * NewTicket,
    OUT PKERB_AUTHENTICATOR * NewAuthenticator,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PKERB_ENCRYPTION_KEY TicketKey,
    OUT PKERB_ENCRYPTION_KEY ServerKey,
    OUT PULONG ContextFlags,
    OUT PULONG ContextAttributes,
    OUT PKERBERR KerbError,
    IN PSEC_CHANNEL_BINDINGS pChannelBindings
    );

NTSTATUS
KerbComputeGssBindHash(
    IN PSEC_CHANNEL_BINDINGS pChannelBindings,
    OUT PUCHAR HashBuffer
    );

//
// From credapi.cxx
//

NTSTATUS
KerbCaptureSuppliedCreds(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PVOID AuthorizationData,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    OUT PKERB_PRIMARY_CREDENTIAL * SuppliedCreds,
    OUT PULONG Flags
    );

NTSTATUS
KerbBuildApReply(
    IN PKERB_AUTHENTICATOR InternalAuthenticator,
    IN PKERB_AP_REQUEST Request,
    IN ULONG ContextFlags,
    IN ULONG ContextAtributes,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PULONG Nonce,
    OUT PUCHAR * NewReply,
    OUT PULONG NewReplySize
    );

NTSTATUS
KerbBuildThirdLegApReply(
    IN PKERB_CONTEXT Context,
    IN ULONG ReceiveNonce,
    OUT PUCHAR * NewReply,
    OUT PULONG NewReplySize
    );

NTSTATUS
KerbVerifyApReply(
    IN PKERB_CONTEXT Context,
    IN PUCHAR PackedReply,
    IN ULONG PackedReplySize,
    OUT PULONG ReceiveNonce
    );

NTSTATUS
KerbInitTicketHandling(
    VOID
    );

VOID
KerbCleanupTicketHandling(
    VOID
    );


NTSTATUS
KerbMakeSocketCall(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN BOOLEAN CallPDC,
    IN BOOLEAN UseTcp,
    IN BOOLEAN CallKpasswd,
    IN PKERB_MESSAGE_BUFFER RequestMessage,
    IN PKERB_MESSAGE_BUFFER ReplyMessage,
    IN OPTIONAL PKERB_BINDING_CACHE_ENTRY OptionalBindingHandle,
    IN ULONG AdditionalFlags,
    OUT PBOOLEAN CalledPDC
    );


NTSTATUS
KerbRenewTicket(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_PRIMARY_CREDENTIAL CredManCredentials,
    IN PKERB_TICKET_CACHE_ENTRY Ticket,
    IN BOOLEAN IsTgt,
    OUT PKERB_TICKET_CACHE_ENTRY *NewTicket
    );

NTSTATUS
KerbRefreshPrimaryTgt(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY OldTgt
    );


NTSTATUS
KerbHandleTgtRequest(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN BOOLEAN UseSuppliedCreds,
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN ULONG ContextRequirements,
    IN PSecBuffer OutputToken,
    IN PLUID LogonId,
    OUT PULONG ContextAttributes,
    OUT PKERB_CONTEXT * Context,
    OUT PTimeStamp ContextLifetime,
    OUT PKERBERR ReturnedError
    );

NTSTATUS
KerbBuildTgtRequest(
    IN PKERB_INTERNAL_NAME TargetName,
    IN PUNICODE_STRING TargetRealm,
    OUT PULONG ContextAttributes,
    OUT PUCHAR * MarshalladTgtRequest,
    OUT PULONG TgtRequestSize
    );

NTSTATUS
KerbUnpackTgtReply(
    IN PKERB_CONTEXT Context,
    IN PUCHAR ReplyMessage,
    IN ULONG ReplySize,
    OUT PKERB_INTERNAL_NAME * TargetName,
    OUT PUNICODE_STRING TargetRealm,
    OUT PKERB_TGT_REPLY * Reply
    );

NTSTATUS
KerbBuildTgtErrorReply(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credentials,
    IN BOOLEAN UseSuppliedCreds,
    IN OUT PKERB_CONTEXT Context,
    OUT PULONG ReplySize,
    OUT PBYTE * Reply
    );

NTSTATUS
KerbBuildKerbCred(
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY Ticket,
    IN PKERB_TICKET_CACHE_ENTRY DelegationTicket,
    OUT PUCHAR * MarshalledKerbCred,
    OUT PULONG KerbCredSize
    );


#endif // __KERBTICK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbwow.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbwow.cxx
//
// Contents:    Code for 32-64 bit interop for the Kerberos package
//
//
// History:     25-Oct-2000     JSchwart        Created
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>

#ifdef _WIN64

#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

#define FILENO FILENO_KERBWOW



//
// WOW versions of public Kerberos logon buffer structures.  These MUST
// be kept in sync with their public counterparts!
//

typedef struct _KERB_INTERACTIVE_LOGON_WOW64
{
    KERB_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING_WOW64 LogonDomainName;
    UNICODE_STRING_WOW64 UserName;
    UNICODE_STRING_WOW64 Password;
}
KERB_INTERACTIVE_LOGON_WOW64, *PKERB_INTERACTIVE_LOGON_WOW64;


typedef struct _KERB_INTERACTIVE_UNLOCK_LOGON_WOW64
{
    KERB_INTERACTIVE_LOGON_WOW64 Logon;
    LUID LogonId;
}
KERB_INTERACTIVE_UNLOCK_LOGON_WOW64, *PKERB_INTERACTIVE_UNLOCK_LOGON_WOW64;


typedef struct _KERB_SMART_CARD_LOGON_WOW64
{
    KERB_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING_WOW64 Pin;
    ULONG CspDataLength;
    ULONG CspData;
}
KERB_SMART_CARD_LOGON_WOW64, *PKERB_SMART_CARD_LOGON_WOW64;


typedef struct _KERB_SMART_CARD_UNLOCK_LOGON_WOW64
{
    KERB_SMART_CARD_LOGON_WOW64 Logon;
    LUID LogonId;
}
KERB_SMART_CARD_UNLOCK_LOGON_WOW64, *PKERB_SMART_CARD_UNLOCK_LOGON_WOW64;


typedef struct _KERB_TICKET_LOGON_WOW64
{
    KERB_LOGON_SUBMIT_TYPE MessageType;
    ULONG Flags;
    ULONG ServiceTicketLength;
    ULONG TicketGrantingTicketLength;
    ULONG ServiceTicket;
    ULONG TicketGrantingTicket;
}
KERB_TICKET_LOGON_WOW64, *PKERB_TICKET_LOGON_WOW64;

typedef struct _KERB_TICKET_UNLOCK_LOGON_WOW64
{
    KERB_TICKET_LOGON_WOW64 Logon;
    LUID LogonId;
}
KERB_TICKET_UNLOCK_LOGON_WOW64, *PKERB_TICKET_UNLOCK_LOGON_WOW64;


//
// WOW versions of public Kerberos profile buffer structures.  These MUST
// be kept in sync with their public counterparts!
//

typedef struct _KERB_INTERACTIVE_PROFILE_WOW64
{
    KERB_PROFILE_BUFFER_TYPE MessageType;
    USHORT                   LogonCount;
    USHORT                   BadPasswordCount;
    LARGE_INTEGER            LogonTime;
    LARGE_INTEGER            LogoffTime;
    LARGE_INTEGER            KickOffTime;
    LARGE_INTEGER            PasswordLastSet;
    LARGE_INTEGER            PasswordCanChange;
    LARGE_INTEGER            PasswordMustChange;
    UNICODE_STRING_WOW64     LogonScript;
    UNICODE_STRING_WOW64     HomeDirectory;
    UNICODE_STRING_WOW64     FullName;
    UNICODE_STRING_WOW64     ProfilePath;
    UNICODE_STRING_WOW64     HomeDirectoryDrive;
    UNICODE_STRING_WOW64     LogonServer;
    ULONG                    UserFlags;
}
KERB_INTERACTIVE_PROFILE_WOW64, *PKERB_INTERACTIVE_PROFILE_WOW64;

typedef struct _KERB_SMART_CARD_PROFILE_WOW64
{
    KERB_INTERACTIVE_PROFILE_WOW64 Profile;
    ULONG CertificateSize;
    ULONG CertificateData;
}
KERB_SMART_CARD_PROFILE_WOW64, *PKERB_SMART_CARD_PROFILE_WOW64;

typedef struct KERB_CRYPTO_KEY_WOW64
{
    LONG KeyType;
    ULONG Length;
    ULONG Value;
}
KERB_CRYPTO_KEY_WOW64, *PKERB_CRYPTO_KEY_WOW64;

typedef struct _KERB_TICKET_PROFILE_WOW64
{
    KERB_INTERACTIVE_PROFILE_WOW64 Profile;
    KERB_CRYPTO_KEY_WOW64 SessionKey;
}
KERB_TICKET_PROFILE_WOW64, *PKERB_TICKET_PROFILE_WOW64;

typedef struct _KERB_INTERNAL_NAME_WOW64
{
    SHORT                NameType;
    USHORT               NameCount;
    UNICODE_STRING_WOW64 Names[ANYSIZE_ARRAY];
}
KERB_INTERNAL_NAME_WOW64, *PKERB_INTERNAL_NAME_WOW64;

typedef struct _KERB_EXTERNAL_NAME_WOW64
{
    SHORT                NameType;
    USHORT               NameCount;
    UNICODE_STRING_WOW64 Names[ANYSIZE_ARRAY];
}
KERB_EXTERNAL_NAME_WOW64, *PKERB_EXTERNAL_NAME_WOW64;

typedef struct _KERB_EXTERNAL_TICKET_WOW64
{
    ULONG                     ServiceName;
    ULONG                     TargetName;
    ULONG                     ClientName;
    UNICODE_STRING_WOW64      DomainName;
    UNICODE_STRING_WOW64      TargetDomainName;
    UNICODE_STRING_WOW64      AltTargetDomainName;
    KERB_CRYPTO_KEY_WOW64     SessionKey;
    ULONG                     TicketFlags;
    ULONG                     Flags;
    LARGE_INTEGER             KeyExpirationTime;
    LARGE_INTEGER             StartTime;
    LARGE_INTEGER             EndTime;
    LARGE_INTEGER             RenewUntil;
    LARGE_INTEGER             TimeSkew;
    ULONG                     EncodedTicketSize;
    ULONG                     EncodedTicket;
}
KERB_EXTERNAL_TICKET_WOW64, *PKERB_EXTERNAL_TICKET_WOW64;

typedef struct _KERB_EXTERNAL_TICKET_EX_WOW64
{
    PKERB_EXTERNAL_NAME_WOW64      ClientName;
    PKERB_EXTERNAL_NAME_WOW64      ServiceName;
    PKERB_EXTERNAL_NAME_WOW64      TargetName;
    UNICODE_STRING_WOW64           ClientRealm;
    UNICODE_STRING_WOW64           ServerRealm;
    UNICODE_STRING_WOW64           TargetDomainName;
    UNICODE_STRING_WOW64           AltTargetDomainName;
    KERB_CRYPTO_KEY_WOW64          SessionKey;
    ULONG                          TicketFlags;
    ULONG                          Flags;
    LARGE_INTEGER                  KeyExpirationTime;
    LARGE_INTEGER                  StartTime;
    LARGE_INTEGER                  EndTime;
    LARGE_INTEGER                  RenewUntil;
    LARGE_INTEGER                  TimeSkew;
    PKERB_NET_ADDRESSES            TicketAddresses;
    PKERB_AUTH_DATA                AuthorizationData;
    _KERB_EXTERNAL_TICKET_EX_WOW64 * SecondTicket;
    ULONG                          EncodedTicketSize;
    PUCHAR                         EncodedTicket;
}
KERB_EXTERNAL_TICKET_EX_WOW64, *PKERB_EXTERNAL_TICKET_EX_WOW64;


#define RELOCATE_WOW_UNICODE_STRING(WOWString, NativeString, Offset)  \
            NativeString.Length        = WOWString.Length;                             \
            NativeString.MaximumLength = WOWString.MaximumLength;                      \
            NativeString.Buffer        = (LPWSTR) ((LPBYTE) UlongToPtr(WOWString.Buffer) + Offset);


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutWOWString
//
//  Synopsis:   Copies a UNICODE_STRING into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutWOWString(
    IN PUNICODE_STRING        InputString,
    OUT PUNICODE_STRING_WOW64 OutputString,
    IN LONG_PTR               Offset,
    IN OUT PBYTE              * Where
    )
{
    OutputString->Length = OutputString->MaximumLength = InputString->Length;
    OutputString->Buffer = PtrToUlong (*Where + Offset);
    RtlCopyMemory(
        *Where,
        InputString->Buffer,
        InputString->Length
        );
    *Where += InputString->Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutWOWKdcName
//
//  Synopsis:   Copies a Kdc name to a buffer
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutKdcName.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutWOWKdcName(
    IN  PKERB_INTERNAL_NAME         InputName,
    OUT PULONG                      OutputName,
    IN  LONG_PTR                    Offset,
    IN  OUT PBYTE                 * Where
    )
{
    ULONG Index;
    PKERB_INTERNAL_NAME_WOW64 LocalName = (PKERB_INTERNAL_NAME_WOW64) *Where;

    if (!ARGUMENT_PRESENT(InputName))
    {
        *OutputName = NULL;
        return;
    }

    *Where += sizeof(KERB_INTERNAL_NAME_WOW64) - sizeof(UNICODE_STRING_WOW64) +
                InputName->NameCount * sizeof(UNICODE_STRING_WOW64);

    LocalName->NameType  = InputName->NameType;
    LocalName->NameCount = InputName->NameCount;

    for (Index = 0; Index < InputName->NameCount ; Index++ )
    {
        LocalName->Names[Index].Length =
            LocalName->Names[Index].MaximumLength =
            InputName->Names[Index].Length;

        LocalName->Names[Index].Buffer = PtrToUlong(*Where + Offset);

        RtlCopyMemory(*Where,
                      InputName->Names[Index].Buffer,
                      InputName->Names[Index].Length);

        *Where += InputName->Names[Index].Length;
    }

    *Where = (PBYTE) ROUND_UP_POINTER(*Where, sizeof(ULONG));

    *OutputName = PtrToUlong((PBYTE) LocalName + Offset);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutKdcNameAsWOWString
//
//  Synopsis:   Copies a KERB_INTERNAL_NAME into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutKdcNameAsString.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutKdcNameAsWOWString(
    IN PKERB_INTERNAL_NAME    InputName,
    OUT PUNICODE_STRING_WOW64 OutputName,
    IN LONG_PTR               Offset,
    IN OUT PBYTE              * Where
    )
{
    USHORT Index;

    OutputName->Buffer = PtrToUlong (*Where + Offset);
    OutputName->Length = 0;
    OutputName->MaximumLength = 0;

    for (Index = 0; Index < InputName->NameCount ; Index++ )
    {
        RtlCopyMemory(
            *Where,
            InputName->Names[Index].Buffer,
            InputName->Names[Index].Length
            );
        *Where += InputName->Names[Index].Length;
        OutputName->Length += InputName->Names[Index].Length;
        if (Index == (InputName->NameCount - 1))
        {
            *((LPWSTR) *Where) = L'\0';
            OutputName->MaximumLength = OutputName->Length + sizeof(WCHAR);
        }
        else
        {
            *((LPWSTR) *Where) = L'/';
            OutputName->Length += sizeof(WCHAR);
        }
        *Where += sizeof(WCHAR);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutWOWClientString
//
//  Synopsis:   Copies a string into a buffer that will be copied to the
//              32-bit client's address space
//
//  Effects:
//
//  Arguments:  Where - Location in local buffer to place string.
//              Delta - Difference in addresses of local and client buffers.
//              OutString - Receives 'put' string
//              InString - String to 'put'
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutClientString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutWOWClientString(
    IN OUT PUCHAR * Where,
    IN LONG_PTR Delta,
    IN PUNICODE_STRING_WOW64 OutString,
    IN PUNICODE_STRING InString
    )
{
    if (InString->Length == 0)
    {
        OutString->Buffer = 0;
        OutString->Length = OutString->MaximumLength = 0;
    }
    else
    {
        RtlCopyMemory(*Where,
                      InString->Buffer,
                      InString->Length);

        OutString->Buffer = PtrToUlong(*Where + Delta);
        OutString->Length = InString->Length;
        *Where += InString->Length;
        *(LPWSTR) (*Where) = L'\0';
        *Where += sizeof(WCHAR);
        OutString->MaximumLength = OutString->Length + sizeof(WCHAR);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbWOWNameLength
//
//  Synopsis:   returns length in bytes of variable portion
//              of KERB_INTERNAL_NAME
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbNameLength.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

ULONG
KerbWOWNameLength(
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Length = 0;
    ULONG Index;

    if (!ARGUMENT_PRESENT(Name))
    {
        return 0;
    }

    Length = sizeof(KERB_INTERNAL_NAME_WOW64)
                - sizeof(UNICODE_STRING_WOW64)
                + Name->NameCount * sizeof(UNICODE_STRING_WOW64);

    for (Index = 0; Index < Name->NameCount ;Index++ )
    {
        Length += Name->Names[Index].Length;
    }

    Length = ROUND_UP_COUNT(Length, sizeof(ULONG));

    return Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertWOWLogonBuffer
//
//  Synopsis:   Converts logon buffers passed in from WOW clients to 64-bit
//
//  Effects:
//
//  Arguments:  ProtocolSubmitBuffer -- original 32-bit logon buffer
//              pSubmitBufferSize    -- size of the 32-bit logon buffer
//              MessageType          -- format of the logon buffer
//              ppTempSubmitBuffer   -- filled in with the converted buffer
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine allocates the converted buffer and returns it
//              on success.  It is the caller's responsibility to free it.
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbConvertWOWLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    IN     KERB_LOGON_SUBMIT_TYPE  MessageType,
    OUT    PVOID                   *ppTempSubmitBuffer
    )
{
    NTSTATUS  Status       = STATUS_SUCCESS;
    PVOID     pTempBuffer  = NULL;
    ULONG     dwBufferSize = *pSubmitBufferSize;

    switch (MessageType)
    {
        case KerbInteractiveLogon:
        case KerbWorkstationUnlockLogon:
        {
            PKERB_INTERACTIVE_LOGON        Logon;
            PKERB_INTERACTIVE_LOGON_WOW64  LogonWOW;
            DWORD                          dwOffset;
            DWORD                          dwWOWOffset;

            //
            // Scale up the size and add on 3 PVOIDs for the worst-case
            // scenario to align the three embedded UNICODE_STRINGs
            //

            dwBufferSize += sizeof(KERB_INTERACTIVE_LOGON)
                                - sizeof(KERB_INTERACTIVE_LOGON_WOW64);

            if (dwBufferSize < sizeof(KERB_INTERACTIVE_LOGON))
            {
                DebugLog((DEB_ERROR,
                          "Submit buffer to logon too small: %d. %ws, line %d\n",
                          dwBufferSize,
                          THIS_FILE,
                          __LINE__));

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            pTempBuffer = KerbAllocate(dwBufferSize);

            if (pTempBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            Logon    = (PKERB_INTERACTIVE_LOGON) pTempBuffer;
            LogonWOW = (PKERB_INTERACTIVE_LOGON_WOW64) ProtocolSubmitBuffer;

            Logon->MessageType = LogonWOW->MessageType;

            dwOffset    = sizeof(KERB_INTERACTIVE_LOGON);
            dwWOWOffset = sizeof(KERB_INTERACTIVE_LOGON_WOW64);

            if (MessageType == KerbWorkstationUnlockLogon)
            {
                if (dwBufferSize < sizeof(KERB_INTERACTIVE_UNLOCK_LOGON))
                {
                    DebugLog((DEB_ERROR,
                              "Submit buffer to logon too small: %d. %ws, line %d\n",
                              dwBufferSize,
                              THIS_FILE,
                              __LINE__));

                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // One additional field for this type (a LUID)
                //

                PKERB_INTERACTIVE_UNLOCK_LOGON        Unlock;
                PKERB_INTERACTIVE_UNLOCK_LOGON_WOW64  UnlockWOW;

                Unlock = (PKERB_INTERACTIVE_UNLOCK_LOGON) pTempBuffer;
                UnlockWOW = (PKERB_INTERACTIVE_UNLOCK_LOGON_WOW64) ProtocolSubmitBuffer;

                Unlock->LogonId = UnlockWOW->LogonId;

                dwOffset    = sizeof(KERB_INTERACTIVE_UNLOCK_LOGON);
                dwWOWOffset = sizeof(KERB_INTERACTIVE_UNLOCK_LOGON_WOW64);
            }

            //
            // Copy the variable-length data
            //

            RtlCopyMemory((LPBYTE) Logon + dwOffset,
                          (LPBYTE) LogonWOW + dwWOWOffset,
                          *pSubmitBufferSize - dwWOWOffset);

            //
            // Set up the pointers in the native struct
            //

            RELOCATE_WOW_UNICODE_STRING(LogonWOW->LogonDomainName,
                                        Logon->LogonDomainName,
                                        dwOffset - dwWOWOffset);

            RELOCATE_WOW_UNICODE_STRING(LogonWOW->UserName,
                                        Logon->UserName,
                                        dwOffset - dwWOWOffset);

            RELOCATE_WOW_UNICODE_STRING(LogonWOW->Password,
                                        Logon->Password,
                                        dwOffset - dwWOWOffset);

            break;
        }

        case KerbSmartCardLogon:
        case KerbSmartCardUnlockLogon:
        {
            PKERB_SMART_CARD_LOGON        Logon;
            PKERB_SMART_CARD_LOGON_WOW64  LogonWOW;
            DWORD                         dwOffset;
            DWORD                         dwWOWOffset;

            //
            // Scale up the size and add on 2 PVOIDs for the worst-case
            // scenario to align the embedded UNICODE_STRING and CspData
            //

            dwBufferSize += sizeof(KERB_SMART_CARD_LOGON)
                                - sizeof(KERB_SMART_CARD_LOGON_WOW64);

            if (dwBufferSize < sizeof(KERB_SMART_CARD_LOGON))
            {
                DebugLog((DEB_ERROR,
                          "Submit buffer to logon too small: %d. %ws, line %d\n",
                          dwBufferSize,
                          THIS_FILE,
                          __LINE__));

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            pTempBuffer = KerbAllocate(dwBufferSize);

            if (pTempBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            Logon    = (PKERB_SMART_CARD_LOGON) pTempBuffer;
            LogonWOW = (PKERB_SMART_CARD_LOGON_WOW64) ProtocolSubmitBuffer;

            Logon->MessageType   = LogonWOW->MessageType;
            Logon->CspDataLength = LogonWOW->CspDataLength;

            dwOffset    = sizeof(KERB_SMART_CARD_LOGON);
            dwWOWOffset = sizeof(KERB_SMART_CARD_LOGON_WOW64);

            if (MessageType == KerbSmartCardUnlockLogon)
            {
                if (dwBufferSize < sizeof(KERB_SMART_CARD_UNLOCK_LOGON))
                {
                    DebugLog((DEB_ERROR,
                              "Submit buffer to logon too small: %d. %ws, line %d\n",
                              dwBufferSize,
                              THIS_FILE,
                              __LINE__));

                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // One additional field for this type (a LUID)
                //

                PKERB_SMART_CARD_UNLOCK_LOGON        Unlock;
                PKERB_SMART_CARD_UNLOCK_LOGON_WOW64  UnlockWOW;

                Unlock = (PKERB_SMART_CARD_UNLOCK_LOGON) pTempBuffer;
                UnlockWOW = (PKERB_SMART_CARD_UNLOCK_LOGON_WOW64) ProtocolSubmitBuffer;

                Unlock->LogonId = UnlockWOW->LogonId;

                dwOffset    = sizeof(KERB_SMART_CARD_UNLOCK_LOGON);
                dwWOWOffset = sizeof(KERB_SMART_CARD_UNLOCK_LOGON_WOW64);
            }

            //
            // Copy the variable-length data
            //

            RtlCopyMemory((LPBYTE) Logon + dwOffset,
                          (LPBYTE) LogonWOW + dwWOWOffset,
                          *pSubmitBufferSize - dwWOWOffset);

            //
            // Set up the pointers in the native struct
            //

            RELOCATE_WOW_UNICODE_STRING(LogonWOW->Pin,
                                        Logon->Pin,
                                        dwOffset - dwWOWOffset);

            Logon->CspData = (PUCHAR) ((LPBYTE) UlongToPtr(LogonWOW->CspData) + (dwOffset - dwWOWOffset));

            break;
        }

        case KerbTicketLogon:
        case KerbTicketUnlockLogon:
        {
            PKERB_TICKET_LOGON        Logon;
            PKERB_TICKET_LOGON_WOW64  LogonWOW;
            DWORD                     dwOffset;
            DWORD                     dwWOWOffset;

            //
            // Scale up the size and add on 2 PVOIDs for the worst-case
            // scenario to align the two embedded pointers
            //

            dwBufferSize += sizeof(KERB_TICKET_LOGON)
                                - sizeof(KERB_TICKET_LOGON_WOW64);

            if (dwBufferSize < sizeof(KERB_TICKET_LOGON))
            {
                DebugLog((DEB_ERROR,
                          "Submit buffer to logon too small: %d. %ws, line %d\n",
                          dwBufferSize,
                          THIS_FILE,
                          __LINE__));

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            pTempBuffer = KerbAllocate(dwBufferSize);

            if (pTempBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            Logon    = (PKERB_TICKET_LOGON) pTempBuffer;
            LogonWOW = (PKERB_TICKET_LOGON_WOW64) ProtocolSubmitBuffer;

            Logon->MessageType                = LogonWOW->MessageType;
            Logon->Flags                      = LogonWOW->Flags;
            Logon->ServiceTicketLength        = LogonWOW->ServiceTicketLength;
            Logon->TicketGrantingTicketLength = LogonWOW->TicketGrantingTicketLength;

            dwOffset    = sizeof(KERB_TICKET_LOGON);
            dwWOWOffset = sizeof(KERB_TICKET_LOGON_WOW64);

            if (MessageType == KerbTicketUnlockLogon)
            {
                if (dwBufferSize < sizeof(KERB_TICKET_UNLOCK_LOGON))
                {
                    DebugLog((DEB_ERROR,
                              "Submit buffer to logon too small: %d. %ws, line %d\n",
                              dwBufferSize,
                              THIS_FILE,
                              __LINE__));

                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // One additional field for this type (a LUID)
                //

                PKERB_TICKET_UNLOCK_LOGON        Unlock;
                PKERB_TICKET_UNLOCK_LOGON_WOW64  UnlockWOW;

                Unlock = (PKERB_TICKET_UNLOCK_LOGON) pTempBuffer;
                UnlockWOW = (PKERB_TICKET_UNLOCK_LOGON_WOW64) ProtocolSubmitBuffer;

                Unlock->LogonId = UnlockWOW->LogonId;

                dwOffset    = sizeof(KERB_TICKET_UNLOCK_LOGON);
                dwWOWOffset = sizeof(KERB_TICKET_UNLOCK_LOGON_WOW64);
            }

            //
            // Copy the variable-length data
            //

            RtlCopyMemory((LPBYTE) Logon + dwOffset,
                          (LPBYTE) LogonWOW + dwWOWOffset,
                          *pSubmitBufferSize - dwWOWOffset);

            //
            // Set up the pointers in the native struct
            //

            Logon->ServiceTicket = (PUCHAR) ((LPBYTE) UlongToPtr(LogonWOW->ServiceTicket)
                                                          + (dwOffset - dwWOWOffset));

            Logon->TicketGrantingTicket = (PUCHAR) ((LPBYTE) UlongToPtr(LogonWOW->TicketGrantingTicket)
                                                                 + (dwOffset - dwWOWOffset));

            break;
        }

        default:

            DebugLog((DEB_ERROR,
                      "Invalid info class to logon: %d. %ws, line %d\n",
                      MessageType,
                      THIS_FILE,
                      __LINE__));

            Status = STATUS_INVALID_INFO_CLASS;
            goto Cleanup;
    }

    *pSubmitBufferSize  = dwBufferSize;
    *ppTempSubmitBuffer = pTempBuffer;

    return STATUS_SUCCESS;


Cleanup:

    ASSERT(!NT_SUCCESS(Status));

    if (pTempBuffer)
    {
        KerbFree(pTempBuffer);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateInteractiveWOWProfile
//
//  Synopsis:   This allocates and fills in the interactive profile for
//              a WOW64 client.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:      This code is (effectively) duplicated in
//              KerbAllocateInteractiveBuffer.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------


NTSTATUS
KerbAllocateInteractiveWOWBuffer(
    OUT PKERB_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET LogonTicket,
    IN OPTIONAL PKERB_INTERACTIVE_LOGON KerbLogonInfo,
    IN  PUCHAR *pClientBufferBase,
    IN  BOOLEAN BuildSmartCardProfile,
    IN  BOOLEAN BuildTicketProfile
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_INTERACTIVE_PROFILE_WOW64 LocalProfileBuffer = NULL;
    PKERB_SMART_CARD_PROFILE_WOW64 SmartCardProfile = NULL;
    PKERB_TICKET_PROFILE_WOW64 TicketProfile = NULL;
    LONG_PTR Delta = 0;
    PUCHAR Where = NULL;

    if (BuildSmartCardProfile)
    {
        *ProfileBufferSize = sizeof(KERB_SMART_CARD_PROFILE_WOW64) +
                LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->cbCertEncoded;
    }
    else if (BuildTicketProfile)
    {
        *ProfileBufferSize = sizeof(KERB_TICKET_PROFILE_WOW64) +
                LogonTicket->key.keyvalue.length;
    }
    else
    {
        *ProfileBufferSize = sizeof(KERB_INTERACTIVE_PROFILE_WOW64);
    }

    *ProfileBufferSize +=
        UserInfo->LogonScript.Length + sizeof(WCHAR) +
        UserInfo->HomeDirectory.Length + sizeof(WCHAR) +
        UserInfo->HomeDirectoryDrive.Length + sizeof(WCHAR) +
        UserInfo->FullName.Length + sizeof(WCHAR) +
        UserInfo->ProfilePath.Length + sizeof(WCHAR) +
        UserInfo->LogonServer.Length + sizeof(WCHAR);

    LocalProfileBuffer = (PKERB_INTERACTIVE_PROFILE_WOW64) KerbAllocate(*ProfileBufferSize);

    if (LocalProfileBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->AllocateClientBuffer(
                NULL,
                *ProfileBufferSize,
                (PVOID *) pClientBufferBase
                );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup;
    }

    Delta = (LONG_PTR) (*pClientBufferBase - (PUCHAR) LocalProfileBuffer) ;

    //
    // Don't walk over smart card data
    //

    if (BuildSmartCardProfile)
    {
        Where = (PUCHAR) ((PKERB_SMART_CARD_PROFILE_WOW64) LocalProfileBuffer + 1);
    }
    else if (BuildTicketProfile)
    {
        Where = (PUCHAR) ((PKERB_TICKET_PROFILE_WOW64) LocalProfileBuffer + 1);
    }
    else
    {
        Where = (PUCHAR) (LocalProfileBuffer + 1);
    }

    //
    // Copy the scalar fields into the profile buffer.
    //

    LocalProfileBuffer->MessageType = KerbInteractiveProfile;
    LocalProfileBuffer->LogonCount = UserInfo->LogonCount;
    LocalProfileBuffer->BadPasswordCount= UserInfo->BadPasswordCount;
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->LogonTime,
                              LocalProfileBuffer->LogonTime );
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->LogoffTime,
                              LocalProfileBuffer->LogoffTime );
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->KickOffTime,
                              LocalProfileBuffer->KickOffTime );
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordLastSet,
                              LocalProfileBuffer->PasswordLastSet );
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordCanChange,
                              LocalProfileBuffer->PasswordCanChange );
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordMustChange,
                              LocalProfileBuffer->PasswordMustChange );
    LocalProfileBuffer->UserFlags = UserInfo->UserFlags;

    //
    // Copy the Unicode strings into the profile buffer.
    //

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->LogonScript,
                           &UserInfo->LogonScript );

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->HomeDirectory,
                           &UserInfo->HomeDirectory );

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->HomeDirectoryDrive,
                           &UserInfo->HomeDirectoryDrive );

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->FullName,
                           &UserInfo->FullName );

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->ProfilePath,
                           &UserInfo->ProfilePath );

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->LogonServer,
                           &UserInfo->LogonServer );

    if (BuildSmartCardProfile)
    {
        LocalProfileBuffer->MessageType = KerbSmartCardProfile;
        SmartCardProfile = (PKERB_SMART_CARD_PROFILE_WOW64) LocalProfileBuffer;
        SmartCardProfile->CertificateSize = LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->cbCertEncoded;
        SmartCardProfile->CertificateData = PtrToUlong(Where + Delta);

        RtlCopyMemory(Where,
                      LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->pbCertEncoded,
                      SmartCardProfile->CertificateSize);

        Where += SmartCardProfile->CertificateSize;
    }
    else if (BuildTicketProfile)
    {
        LocalProfileBuffer->MessageType = KerbTicketProfile;
        TicketProfile = (PKERB_TICKET_PROFILE_WOW64) LocalProfileBuffer;

        //
        // If the key is exportable or we are domestic, return the key
        //

        if (KerbGlobalStrongEncryptionPermitted || KerbIsKeyExportable(&LogonTicket->key))
        {
            TicketProfile->SessionKey.KeyType = LogonTicket->key.keytype;
            TicketProfile->SessionKey.Length = LogonTicket->key.keyvalue.length;
            TicketProfile->SessionKey.Value = PtrToUlong(Where + Delta);

            RtlCopyMemory(Where,
                          LogonTicket->key.keyvalue.value,
                          LogonTicket->key.keyvalue.length);

            Where += TicketProfile->SessionKey.Length;
        }
    }

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        LsaFunctions->FreeClientBuffer(NULL, *pClientBufferBase);

        if (LocalProfileBuffer != NULL)
        {
            KerbFree(LocalProfileBuffer);
        }
    }
    else
    {
        *ProfileBuffer = (PKERB_INTERACTIVE_PROFILE) LocalProfileBuffer;
    }

    return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPackExternalWOWTicket
//
//  Synopsis:   This allocates and fills in the external ticket for
//              a WOW64 client.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPackExternalTicket.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------

NTSTATUS
KerbPackExternalWOWTicket(
    IN  PKERB_TICKET_CACHE_ENTRY  pCacheEntry,
    IN  PKERB_MESSAGE_BUFFER      pEncodedTicket,
    OUT PKERB_EXTERNAL_TICKET     *pTicketResponse,
    OUT PBYTE                     *pClientTicketResponse,
    OUT PULONG                    pTicketSize
    )
{
    PKERB_EXTERNAL_TICKET_WOW64 TicketResponseWOW       = NULL;
    PBYTE                       ClientTicketResponseWOW = NULL;
    ULONG                       ulTicketSize;
    ULONG                       Offset;
    PUCHAR                      Where;
    NTSTATUS                    Status;

    ulTicketSize = sizeof(KERB_EXTERNAL_TICKET_WOW64) +
                      pCacheEntry->DomainName.Length +
                      pCacheEntry->TargetDomainName.Length +
                      pCacheEntry->AltTargetDomainName.Length +
                      pCacheEntry->SessionKey.keyvalue.length +
                      KerbWOWNameLength(pCacheEntry->ServiceName) +
                      KerbWOWNameLength(pCacheEntry->TargetName) +
                      KerbWOWNameLength(pCacheEntry->ClientName) +
                      pEncodedTicket->BufferSize;

    //
    // Now allocate two copies of the structure - one in our process,
    // one in the client's process. We then build the structure in our
    // process but with pointer valid in the client's process
    //

    TicketResponseWOW = (PKERB_EXTERNAL_TICKET_WOW64) KerbAllocate(ulTicketSize);

    if (TicketResponseWOW == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->AllocateClientBuffer(NULL,
                                                ulTicketSize,
                                                (PVOID *) &ClientTicketResponseWOW);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Offset = (ULONG) (ClientTicketResponseWOW - (PBYTE) TicketResponseWOW);

    Where = ((PUCHAR) (TicketResponseWOW + 1));

    //
    // Copy the non-pointer fields
    //

    TicketResponseWOW->TicketFlags        = pCacheEntry->TicketFlags;
    TicketResponseWOW->Flags              = 0;
    TicketResponseWOW->KeyExpirationTime  = pCacheEntry->KeyExpirationTime;
    TicketResponseWOW->StartTime          = pCacheEntry->StartTime;
    TicketResponseWOW->EndTime            = pCacheEntry->EndTime;
    TicketResponseWOW->RenewUntil         = pCacheEntry->RenewUntil;
    TicketResponseWOW->TimeSkew           = pCacheEntry->TimeSkew;
    TicketResponseWOW->SessionKey.KeyType = pCacheEntry->SessionKey.keytype;


    //
    // Copy the structure to the client's address space
    //

    //
    // These are 32-bit PVOID (i.e., ULONG) aligned
    //

    //
    // Make sure the two name types are the same
    //

    DsysAssert(sizeof(KERB_INTERNAL_NAME_WOW64) == sizeof(KERB_EXTERNAL_NAME_WOW64));
    DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME_WOW64,NameType) == FIELD_OFFSET(KERB_EXTERNAL_NAME_WOW64,NameType));
    DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME_WOW64,NameCount) == FIELD_OFFSET(KERB_EXTERNAL_NAME_WOW64,NameCount));
    DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME_WOW64,Names) == FIELD_OFFSET(KERB_EXTERNAL_NAME_WOW64,Names));

    KerbPutWOWKdcName(pCacheEntry->ServiceName,
                      &TicketResponseWOW->ServiceName,
                      Offset,
                      &Where);

    KerbPutWOWKdcName(pCacheEntry->TargetName,
                      &TicketResponseWOW->TargetName,
                      Offset,
                      &Where);

    KerbPutWOWKdcName(pCacheEntry->ClientName,
                      &TicketResponseWOW->ClientName,
                      Offset,
                      &Where);

    //
    // From here on, they are WCHAR aligned
    //

    KerbPutWOWString(&pCacheEntry->DomainName,
                     &TicketResponseWOW->DomainName,
                     Offset,
                     &Where);

    KerbPutWOWString(&pCacheEntry->TargetDomainName,
                     &TicketResponseWOW->TargetDomainName,
                     Offset,
                     &Where);

    KerbPutWOWString(&pCacheEntry->AltTargetDomainName,
                     &TicketResponseWOW->AltTargetDomainName,
                     Offset,
                     &Where);

    //
    // And from here they are BYTE aligned
    //

    TicketResponseWOW->SessionKey.Value = PtrToUlong(Where + Offset);

    RtlCopyMemory(Where,
                  pCacheEntry->SessionKey.keyvalue.value,
                  pCacheEntry->SessionKey.keyvalue.length);

    Where += pCacheEntry->SessionKey.keyvalue.length;

    TicketResponseWOW->SessionKey.Length = pCacheEntry->SessionKey.keyvalue.length;

    TicketResponseWOW->EncodedTicketSize = pEncodedTicket->BufferSize;
    TicketResponseWOW->EncodedTicket     = PtrToUlong(Where + Offset);

    RtlCopyMemory(Where,
                  pEncodedTicket->Buffer,
                  pEncodedTicket->BufferSize);

    Where += pEncodedTicket->BufferSize;

    DsysAssert(Where - ((PUCHAR) TicketResponseWOW) == (LONG_PTR) ulTicketSize);

    *pTicketResponse       = (PKERB_EXTERNAL_TICKET) TicketResponseWOW;
    *pClientTicketResponse = ClientTicketResponseWOW;
    *pTicketSize           = ulTicketSize;

    return STATUS_SUCCESS;

Cleanup:

    if (TicketResponseWOW != NULL)
    {
        KerbFree(TicketResponseWOW);
    }

    if (ClientTicketResponseWOW != NULL)
    {
        LsaFunctions->FreeClientBuffer(NULL, ClientTicketResponseWOW);
    }

    *pTicketResponse       = NULL;
    *pClientTicketResponse = NULL;
    *pTicketSize           = 0;

    return Status;
}

#endif  // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbutil.cxx
//
// Contents:    Utility functions for Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#ifndef WIN32_CHICAGO
#include <nb30.h>
#else // WIN32_CHICAGO
#define NCBNAMSZ 16
#endif // WIN32_CHICAGO
#include <userapi.h>            // for gss support routines

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

GUID GUID_NULL = {0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};




//+-------------------------------------------------------------------------
//
//  Function:   KerbSplitFullServiceName
//
//  Synopsis:   Splits a full service name into a domain name and a
//              service name. The output strings point into the input
//              string's buffer and should not be freed
//
//  Effects:
//
//  Arguments:  FullServiceName - The full service name in a domain\service
//                      format
//              DomainName - Receives the domain portion of the full service
//                      name in a 'domain' format
//              ServiceName - Receives the service name in a 'service' format
//
//  Requires:
//
//  Returns:    STATUS_INVALID_PARAMETER if the service name does not
//                      match the correct format.
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbSplitFullServiceName(
    IN PUNICODE_STRING FullServiceName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING ServiceName
    )
{
    UNICODE_STRING TempDomainName;
    UNICODE_STRING TempServiceName;

    TempDomainName = *FullServiceName;

    //
    // Find the split between domain and service name
    //

    TempDomainName.Length = 0;
    while ((TempDomainName.Length < FullServiceName->Length) &&
           (TempDomainName.Buffer[TempDomainName.Length/sizeof(WCHAR)] != L'\\') &&
           (TempDomainName.Buffer[TempDomainName.Length/sizeof(WCHAR)] != L'@') )
    {
        TempDomainName.Length += sizeof(WCHAR);
    }

    //
    // In this case, there is no separator
    //

    if (TempDomainName.Length == FullServiceName->Length)
    {
        *ServiceName = *FullServiceName;
        EMPTY_UNICODE_STRING( DomainName );
        return(STATUS_SUCCESS);
    }

    //
    // If the separator is an "@" switch the doman & service portion
    //

    if (TempDomainName.Buffer[TempDomainName.Length/sizeof(WCHAR)] == L'@')
    {
        TempServiceName = TempDomainName;

        TempDomainName.Buffer = TempServiceName.Buffer + TempServiceName.Length/sizeof(WCHAR) + 1;
        TempServiceName.MaximumLength = TempServiceName.Length;

        //
        // The Domain name is everything else
        //

        TempDomainName.Length = FullServiceName->Length - TempServiceName.Length - sizeof(WCHAR);
        TempDomainName.MaximumLength = TempDomainName.Length;
    }
    else
    {
        TempServiceName.Buffer = TempDomainName.Buffer + TempDomainName.Length/sizeof(WCHAR) + 1;
        TempDomainName.MaximumLength = TempDomainName.Length;

        //
        // The service name is everything else
        //

        TempServiceName.Length = FullServiceName->Length - TempDomainName.Length - sizeof(WCHAR);
        TempServiceName.MaximumLength = TempServiceName.Length;

    }

    *ServiceName = TempServiceName;
    *DomainName = TempDomainName;

    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbSplitEmailName
//
//  Synopsis:   Splits a full service name into a domain name and a
//              service name. The output strings point into the input
//              string's buffer and should not be freed
//
//  Effects:
//
//  Arguments:  EmailName - The full service name in a domain\service
//                      format
//              DomainName - Receives the domain portion of the full service
//                      name in a 'domain' format
//              ServiceName - Receives the service name in a 'service' format
//
//  Requires:
//
//  Returns:    STATUS_INVALID_PARAMETER if the service name does not
//                      match the correct format.
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbSplitEmailName(
    IN PUNICODE_STRING EmailName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING ServiceName
    )
{
    UNICODE_STRING TempServiceName;
    UNICODE_STRING TempDomainName;

    TempServiceName = *EmailName;

    //
    // Find the split between service and domain name
    //

    TempServiceName.Length = 0;
    while ((TempServiceName.Length < EmailName->Length) &&
           (TempServiceName.Buffer[TempServiceName.Length/sizeof(WCHAR)] != L'@'))
    {
        TempServiceName.Length += sizeof(WCHAR);
    }

    if (TempServiceName.Length == EmailName->Length)
    {
        DebugLog((DEB_ERROR,"Failed to find @ separator in email name: %wZ. %ws, line %d\n",EmailName, THIS_FILE, __LINE__ ));
        return(STATUS_INVALID_PARAMETER);
    }

    TempDomainName.Buffer = TempServiceName.Buffer + TempServiceName.Length/sizeof(WCHAR) + 1;
    TempServiceName.MaximumLength = TempServiceName.Length;

    //
    // The domain name is everything else
    //

    TempDomainName.Length = EmailName->Length - TempServiceName.Length - sizeof(WCHAR);
    TempDomainName.MaximumLength = TempDomainName.Length;

    *ServiceName = TempServiceName;
    *DomainName = TempDomainName;

    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateNonce
//
//  Synopsis:   Allocates a locally unique number
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    the nonce
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG
KerbAllocateNonce(
    VOID
    )
{
    LUID TempLuid;
    TimeStamp CurrentTime;

    NtAllocateLocallyUniqueId(&TempLuid);
    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
#ifndef WIN32_CHICAGO
    return(0x7fffffff & (TempLuid.LowPart ^ TempLuid.HighPart ^ CurrentTime.LowPart ^ CurrentTime.HighPart));
#else // WIN32_CHICAGO
    return(0x7fffffff & ((ULONG)(TempLuid.LowPart ^ TempLuid.HighPart ^ CurrentTime)));
#endif // WIN32_CHICAGO
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocate
//
//  Synopsis:   Allocate memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PVOID
KerbAllocate(
    IN ULONG BufferSize
    )
{
    PVOID pBuffer = NULL;
    if (KerberosState == KerberosLsaMode)
    {
        pBuffer = LsaFunctions->AllocateLsaHeap(BufferSize);
        // Lsa helper routine zeroes the memory.
    }
    else
    {
        DsysAssert(KerberosState == KerberosUserMode);
        pBuffer = LocalAlloc(0,BufferSize);
        if (pBuffer)
        {
            RtlZeroMemory (pBuffer, BufferSize);
        }
    }

    return pBuffer;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFree
//
//  Synopsis:   Free memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFree(
    IN PVOID Buffer
    )
{
    if (ARGUMENT_PRESENT(Buffer))
    {
        if (KerberosState == KerberosLsaMode)
        {
            LsaFunctions->FreeLsaHeap(Buffer);
        }
        else
        {
            DsysAssert(KerberosState == KerberosUserMode);
            LocalFree(Buffer);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbStringToUnicodeString()
//
//  Synopsis:   Takes a ansi string and (1) unicodes it, (2) copies it
//
//  Effects:
//
//  Arguments: pDest must be initialized unicode string
//
//  Requires:
//
//  Returns:   Free .buffer using KerbFree()
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOLEAN
KerbMbStringToUnicodeString(PUNICODE_STRING     pDest,
                            char *              pszString)
{
    USHORT cbNewString;
    USHORT cbOriginalString;

    cbOriginalString = strlen(pszString) + 1;

    cbNewString = cbOriginalString * sizeof(WCHAR);

    pDest->Buffer = NULL;
    pDest->Buffer = (PWSTR) KerbAllocate(cbNewString);
    if (NULL == pDest->Buffer)
    {
        return FALSE;
    }


    if (pDest->Buffer)
    {
        if (MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED,
                                pszString, cbOriginalString,
                                pDest->Buffer, cbOriginalString))
        {


           pDest->Length = cbNewString;
           pDest->MaximumLength = cbNewString;
        }
        else
        {
           KerbFree(pDest->Buffer);
           pDest->Buffer = NULL;
           return FALSE;
        }
    }
    return TRUE;
}




#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbWaitForEvent
//
//  Synopsis:   Wait up to Timeout seconds for EventName to be triggered.
//
//  Effects:
//
//  Arguments:      EventName - Name of event to wait on
//                  Timeout - Timeout for event (in seconds).
//
//  Requires:
//
//  Returns:        STATUS_SUCCESS - Indicates Event was set.
//                  STATUS_NETLOGON_NOT_STARTED - Timeout occurred.
//
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbWaitForEvent(
    IN LPWSTR EventName,
    IN ULONG Timeout
    )
{
    NTSTATUS Status;

    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventNameString;
    LARGE_INTEGER LocalTimeout;


    //
    // Create an event for us to wait on.
    //

    RtlInitUnicodeString( &EventNameString, EventName);
    InitializeObjectAttributes( &EventAttributes, &EventNameString, 0, 0, NULL);

    Status = NtCreateEvent(
                   &EventHandle,
                   SYNCHRONIZE,
                   &EventAttributes,
                   NotificationEvent,
                   (BOOLEAN) FALSE      // The event is initially not signaled
                   );

    if ( !NT_SUCCESS(Status)) {

        //
        // If the event already exists, the server beat us to creating it.
        // Just open it.
        //

        if( Status == STATUS_OBJECT_NAME_EXISTS ||
            Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = NtOpenEvent( &EventHandle,
                                  SYNCHRONIZE,
                                  &EventAttributes );

        }
        if ( !NT_SUCCESS(Status)) {
            KdPrint(("[MSV1_0] OpenEvent failed %lx\n", Status ));
            return Status;
        }
    }


    //
    // Wait for NETLOGON to initialize.  Wait a maximum of Timeout seconds.
    //

    LocalTimeout.QuadPart = ((LONGLONG)(Timeout)) * (-10000000);
    Status = NtWaitForSingleObject( EventHandle, (BOOLEAN)FALSE, &LocalTimeout);
    (VOID) NtClose( EventHandle );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        if ( Status == STATUS_TIMEOUT ) {
            Status = STATUS_NETLOGON_NOT_STARTED;   // Map to an error condition
        }
        return Status;
    }

    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbWaitForKdc
//
//  Synopsis:   Wait up to Timeout seconds for the netlogon service to start.
//
//  Effects:
//
//  Arguments:  Timeout - Timeout for netlogon (in seconds).
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
//              STATUS_NETLOGON_NOT_STARTED - Timeout occurred.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbWaitForKdc(
    IN ULONG Timeout
    )
{
    NTSTATUS Status;
    ULONG NetStatus;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    LPQUERY_SERVICE_CONFIG AllocServiceConfig = NULL;
    QUERY_SERVICE_CONFIG DummyServiceConfig;
    DWORD ServiceConfigSize;
    BOOLEAN AutoStart = FALSE;


    //
    // If the KDC service is currently running,
    //  skip the rest of the tests.
    //

    Status = KerbWaitForEvent( KDC_START_EVENT, 0 );

    if ( NT_SUCCESS(Status) ) {
        KerbKdcStarted = TRUE;
        return Status;
    }


    //
    // Open a handle to the KDC Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        DebugLog((DEB_ERROR, " KerbWaitForKdc: OpenSCManager failed: "
                      "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        SERVICE_KDC,
                        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        D_DebugLog((DEB_ERROR, "KerbWaitForKdc: OpenService failed: "
                      "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }


    //
    // If the KDC service isn't configured to be automatically started
    //  by the service controller, don't bother waiting for it to start -
    // just check to see if it is started.
    //
    // ?? Pass "DummyServiceConfig" and "sizeof(..)" since QueryService config
    //  won't allow a null pointer, yet.

    if ( QueryServiceConfig(
            ServiceHandle,
            &DummyServiceConfig,
            sizeof(DummyServiceConfig),
            &ServiceConfigSize )) {

        ServiceConfig = &DummyServiceConfig;

    } else {

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_INSUFFICIENT_BUFFER ) {
            D_DebugLog((DEB_ERROR,"KerbWaitForKdc: QueryServiceConfig failed: "
                      "%lu. %ws, line %d\n", NetStatus, THIS_FILE, __LINE__));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        AllocServiceConfig = (LPQUERY_SERVICE_CONFIG) KerbAllocate( ServiceConfigSize );
        ServiceConfig = AllocServiceConfig;

        if ( AllocServiceConfig == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !QueryServiceConfig(
                ServiceHandle,
                ServiceConfig,
                ServiceConfigSize,
                &ServiceConfigSize )) {

            D_DebugLog((DEB_ERROR, "KerbWaitForKdc: QueryServiceConfig "
                      "failed again: %lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }
    }

    if ( ServiceConfig->dwStartType == SERVICE_AUTO_START ) {

        AutoStart = TRUE;
    }



    //
    // Loop waiting for the KDC service to start.
    //

    for (;;) {


        //
        // Query the status of the KDC service.
        //

        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

            D_DebugLog((DEB_ERROR, "KerbWaitForKdc: QueryServiceStatus failed: "
                          "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__ ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the KDC service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            Status = STATUS_SUCCESS;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If KDC failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){
#if DBG
                D_DebugLog((DEB_ERROR, "KerbWaitForKdc: "
                          "KDC service couldn't start: %lu %lx. %ws, line %d\n",
                          ServiceStatus.dwWin32ExitCode,
                          ServiceStatus.dwWin32ExitCode, THIS_FILE, __LINE__ ));
                if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
                    D_DebugLog((DEB_ERROR, "         Service specific error code: %lu %lx. %ws, line %d\n",
                              ServiceStatus.dwServiceSpecificExitCode,
                              ServiceStatus.dwServiceSpecificExitCode,
                              THIS_FILE, __LINE__ ));
                }
#endif // DBG
                Status = STATUS_NETLOGON_NOT_STARTED;
                goto Cleanup;
            }

            //
            // If KDC has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If KDC is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
            D_DebugLog((DEB_ERROR, "KerbWaitForKdc: "
                      "Invalid service state: %lu. %ws, line %d\n",
                      ServiceStatus.dwCurrentState, THIS_FILE, __LINE__ ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;

        }


        //
        // If the service wasn't auto start, don't bother waiting and
        // retrying
        //

        if ((ServiceStatus.dwCurrentState) != SERVICE_START_PENDING && !AutoStart) {
            break;
        }

        //
        // Wait a second for the KDC service to start.
        //  If it has successfully started, just return now.
        //

        Status = KerbWaitForEvent( KDC_START_EVENT, 1 );

        if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
            goto Cleanup;
        }

        //
        // If we've waited long enough for KDC to start,
        //  time out now.
        //

        if ( (--Timeout) == 0 ) {
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }


    }

    /* NOT REACHED */

Cleanup:
    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    if ( AllocServiceConfig != NULL ) {
        KerbFree( AllocServiceConfig );
    }
    if (NT_SUCCESS(Status)) {
        KerbKdcStarted = TRUE;
    } else {
        KerbKdcStarted = FALSE;
    }
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbWaitForService
//
//  Synopsis:   Wait up to Timeout seconds for the service to start.
//
//  Effects:
//
//  Arguments:  ServiceName - Name of service to wait for
//              ServiceEvent - Optionally has event name signalling that
//                      service is started
//              Timeout - Timeout for netlogon (in seconds).
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
//              STATUS_NETLOGON_NOT_STARTED - Timeout occurred.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbWaitForService(
    IN LPWSTR ServiceName,
    IN OPTIONAL LPWSTR ServiceEvent,
    IN ULONG Timeout
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NetStatus;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    LPQUERY_SERVICE_CONFIG AllocServiceConfig = NULL;
    QUERY_SERVICE_CONFIG DummyServiceConfig;
    DWORD ServiceConfigSize;
    BOOLEAN AutoStart = FALSE;

    if (ARGUMENT_PRESENT(ServiceEvent))
    {
        //
        // If the KDC service is currently running,
        //  skip the rest of the tests.
        //

        Status = KerbWaitForEvent( ServiceEvent, 0 );

        if ( NT_SUCCESS(Status) ) {
            return Status;
        }


    }


    //
    // Open a handle to the Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        D_DebugLog((DEB_ERROR, " KerbWaitForService: OpenSCManager failed: "
                      "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        ServiceName,
                        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        D_DebugLog((DEB_ERROR, "KerbWaitForService: OpenService failed: "
                      "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }


    //
    // If the KDC service isn't configured to be automatically started
    //  by the service controller, don't bother waiting for it to start -
    // just check to see if it is started.
    //
    // ?? Pass "DummyServiceConfig" and "sizeof(..)" since QueryService config
    //  won't allow a null pointer, yet.

    if ( QueryServiceConfig(
            ServiceHandle,
            &DummyServiceConfig,
            sizeof(DummyServiceConfig),
            &ServiceConfigSize )) {

        ServiceConfig = &DummyServiceConfig;

    } else {

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_INSUFFICIENT_BUFFER ) {
            D_DebugLog((DEB_ERROR,"KerbWaitForService: QueryServiceConfig failed: "
                      "%lu. %ws, line %d\n", NetStatus, THIS_FILE, __LINE__));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        AllocServiceConfig = (LPQUERY_SERVICE_CONFIG) KerbAllocate( ServiceConfigSize );
        ServiceConfig = AllocServiceConfig;

        if ( AllocServiceConfig == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !QueryServiceConfig(
                ServiceHandle,
                ServiceConfig,
                ServiceConfigSize,
                &ServiceConfigSize )) {

            D_DebugLog((DEB_ERROR, "KerbWaitForService: QueryServiceConfig "
                      "failed again: %lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }
    }

    if ( ServiceConfig->dwStartType == SERVICE_AUTO_START ) {

        AutoStart = TRUE;
    }



    //
    // Loop waiting for the KDC service to start.
    //

    for (;;) {


        //
        // Query the status of the KDC service.
        //

        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

            D_DebugLog((DEB_ERROR, "KerbWaitForService: QueryServiceStatus failed: "
                          "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__ ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the KDC service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            Status = STATUS_SUCCESS;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If KDC failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){
#if DBG
                D_DebugLog((DEB_ERROR, "KerbWaitForService: "
                          "%ws service couldn't start: %lu %lx. %ws, line %d\n",
                          ServiceName,
                          ServiceStatus.dwWin32ExitCode,
                          ServiceStatus.dwWin32ExitCode, THIS_FILE, __LINE__ ));
                if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
                    D_DebugLog((DEB_ERROR, "         Service specific error code: %lu %lx. %ws, line %d\n",
                              ServiceStatus.dwServiceSpecificExitCode,
                              ServiceStatus.dwServiceSpecificExitCode,
                              THIS_FILE, __LINE__ ));
                }
#endif // DBG
                Status = STATUS_NETLOGON_NOT_STARTED;
                goto Cleanup;
            }

            //
            // If service has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If service is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
            D_DebugLog((DEB_ERROR, "KerbWaitForService: "
                      "Invalid service state: %lu. %ws, line %d\n",
                      ServiceStatus.dwCurrentState, THIS_FILE, __LINE__ ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;

        }


        //
        // If the service wasn't auto start, don't bother waiting and
        // retrying
        //

        if (!AutoStart) {
            break;
        }

        //
        // Wait a second for the KDC service to start.
        //  If it has successfully started, just return now.
        //

        if (ARGUMENT_PRESENT(ServiceEvent))
        {
            Status = KerbWaitForEvent( ServiceEvent, 1 );

            if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
                goto Cleanup;
            }

        }
        else
        {
            Sleep(1000);
        }

        //
        // If we've waited long enough for KDC to start,
        //  time out now.
        //

        if ( (--Timeout) == 0 ) {
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }


    }

    /* NOT REACHED */

Cleanup:
    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    if ( AllocServiceConfig != NULL ) {
        KerbFree( AllocServiceConfig );
    }
    return Status;
}
#endif // WIN32_CHICAGO




//+-------------------------------------------------------------------------
//
//  Function:   KerbMapContextFlags
//
//  Synopsis:   Maps the ISC_RET_xx flags to ASC_RET_xxx flags
//
//  Effects:
//
//  Arguments:  ContextFlags - Flags to map
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

struct _KERB_FLAG_MAPPING {
    ULONG InitFlag;
    ULONG AcceptFlag;
}  KerbContextFlagMappingTable[] = {
     {ISC_RET_EXTENDED_ERROR, ASC_RET_EXTENDED_ERROR},
     {ISC_RET_INTEGRITY , ASC_RET_INTEGRITY },
     {ISC_RET_IDENTIFY, ASC_RET_IDENTIFY },
     {ISC_RET_NULL_SESSION, ASC_RET_NULL_SESSION }
};

#define KERB_CONTEXT_FLAG_IDENTICAL 0xFFF & ~( ISC_RET_USED_COLLECTED_CREDS | ISC_RET_USED_SUPPLIED_CREDS)

ULONG
KerbMapContextFlags(
    IN ULONG ContextFlags
    )
{
    ULONG OutputFlags;
    ULONG Index;

    //
    // First copy the identical flags
    //

    OutputFlags = ContextFlags & KERB_CONTEXT_FLAG_IDENTICAL;
    for (Index = 0; Index < sizeof(KerbContextFlagMappingTable) / (2 * sizeof(ULONG)) ;Index++ )
    {
        if ((ContextFlags & KerbContextFlagMappingTable[Index].InitFlag) != 0)
        {
            OutputFlags |= KerbContextFlagMappingTable[Index].AcceptFlag;
        }
    }
    return(OutputFlags);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbIsIpAddress
//
//  Synopsis:   Checks to see if a target name is an IP address
//
//  Effects:    none
//
//  Arguments:  TargetName - Name to check
//
//  Requires:
//
//  Returns:    TRUE if the name is an ip address
//
//  Notes:      IP address consist of only digits and periods, possibly
//              with a terminating '$'.
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbIsIpAddress(
    IN PUNICODE_STRING TargetName
    )
{
    ULONG Index;
    ULONG  PeriodCount = 0;

    //
    // Null names are not IP addresses.
    //

    if (!ARGUMENT_PRESENT(TargetName) || (TargetName->Length == 0))
    {
        return(FALSE);
    }

    for (Index = 0; Index < TargetName->Length/sizeof(WCHAR) ; Index++ )
    {
        switch(TargetName->Buffer[Index])
        {
        case L'0':
        case L'1':
        case L'2':
        case L'3':
        case L'4':
        case L'5':
        case L'6':
        case L'7':
        case L'8':
        case L'9':
            continue;
        case L'$':
            //
            // Only allow this at the end.
            //

            if (Index != (TargetName->Length/sizeof(WCHAR) -1) )
            {
                return(FALSE);
            }
            continue;
        case L'.':
            PeriodCount++;
            break;
        default:
            return(FALSE);
        }
    }

    //
    // We require a period in the name, so return the FoundPeriod flag
    //

    if (PeriodCount == 3)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbHidePassword
//
//  Synopsis:   obscures a password in memory
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbHidePassword(
    IN OUT PUNICODE_STRING Password
    )
{
    LsaFunctions->LsaProtectMemory(
                        Password->Buffer,
                        (ULONG)Password->MaximumLength
                        );
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbRevealPassword
//
//  Synopsis:   Reveals a password that has been hidden
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbRevealPassword(
    IN OUT PUNICODE_STRING HiddenPassword
    )
{
    LsaFunctions->LsaUnprotectMemory(
                        HiddenPassword->Buffer,
                        (ULONG)HiddenPassword->MaximumLength
                        );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicatePassword
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.  The MaximumLength contains
//              room for encryption padding data.
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DestinationString->Buffer = NULL;
    DestinationString->Length =
                        DestinationString->MaximumLength =
                        0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {
        USHORT PaddingLength;

        PaddingLength = RTL_ENCRYPT_MEMORY_SIZE - (SourceString->Length % RTL_ENCRYPT_MEMORY_SIZE);

        if( PaddingLength == RTL_ENCRYPT_MEMORY_SIZE )
        {
            PaddingLength = 0;
        }

        DestinationString->Buffer = (LPWSTR) MIDL_user_allocate(
                                                    SourceString->Length +
                                                    PaddingLength
                                                    );

        if (DestinationString->Buffer != NULL)
        {
            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + PaddingLength;

            if( DestinationString->MaximumLength == SourceString->MaximumLength )
            {
                //
                // duplicating an already padded buffer -- pickup the original
                // pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->MaximumLength
                    );
            } else {

                //
                // duplicating an unpadded buffer -- pickup only the string
                // and fill the rest with pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->Length
                    );
            }
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    return Status;
}



#ifdef notdef
// use this if we ever need to map errors in kerb to something else.

//+-------------------------------------------------------------------------
//
//  Function:   KerbMapKerbNtStatusToNtStatus
//
//  Synopsis:   Maps an NT status code to a security status
//              Here's the package's chance to send back generic NtStatus
//              errors
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMapKerbNtStatusToNtStatus(
    IN NTSTATUS Status
    )
{
    return(Status);
}
#endif


void * __cdecl
operator new(
    size_t nSize
    )
{
    return((LPVOID)LocalAlloc(LPTR, nSize));
}

void  __cdecl
operator delete(
    void *pv
    )
{
    LocalFree((HLOCAL)pv);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbExtractDomainName
//
//  Synopsis:   Extracts the domain name from a principal name
//
//  Effects:    Allocates the destination string
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbExtractDomainName(
    OUT PUNICODE_STRING DomainName,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN PUNICODE_STRING TicketSourceDomain
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING TempPrincipal;
    UNICODE_STRING TempDomain = NULL_UNICODE_STRING;

    EMPTY_UNICODE_STRING( DomainName );

    //
    // We do different things depending on the name type:
    // - for NT_MS_PRINCIPAL we call KerbSplitFullServiceName, then do the
    //      same as for other name types
    // - For all other names, if the first portion is "krbtgt" then
    //      we use the second portion of the name, otherwise the
    //      TicketSourceRealm
    //

    if (PrincipalName->NameType == KRB_NT_MS_PRINCIPAL)
    {
        if (PrincipalName->NameCount != 1)
        {
            D_DebugLog((DEB_ERROR,"Principal name has more than one name. %ws, line %d\n", THIS_FILE, __LINE__ ));
            Status = STATUS_TOO_MANY_PRINCIPALS;
            return(Status);
        }
        else
        {
            Status = KerbSplitFullServiceName(
                        &PrincipalName->Names[0],
                        &TempDomain,
                        &TempPrincipal
                        );
            if (!NT_SUCCESS(Status))
            {
                return(Status);
            }

        }
    }
    else
    {

        //
        // The principal name is the first portion. If there are exactly
        // two portions, the domain name is the second portion
        //

        TempPrincipal = PrincipalName->Names[0];
        if (PrincipalName->NameCount == 2)
        {
            TempDomain = PrincipalName->Names[1];
        }
        else
        {
            TempDomain = *TicketSourceDomain;
        }

    }

    //
    // Check to see if the principal is "krbtgt" - if it is, the domain
    // is TempDomain - otherwise it is TicketSourceDomain.
    //

    if (RtlEqualUnicodeString(
            &TempPrincipal,
            &KerbGlobalKdcServiceName,
            TRUE                      // case insensitive
            ))
    {
        Status = KerbDuplicateString(
                    DomainName,
                    &TempDomain
                    );
    }
    else
    {
        Status = KerbDuplicateString(
                    DomainName,
                    TicketSourceDomain
                    );
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUtcTimeToLocalTime
//
//  Synopsis:   Converts system time (used internally) to local time, which
//              is returned to callers.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbUtcTimeToLocalTime(
    OUT PTimeStamp LocalTime,
    IN PTimeStamp SystemTime
    )
{
#ifndef WIN32_CHICAGO
    NTSTATUS Status;
    Status = RtlSystemTimeToLocalTime(
                    SystemTime,
                    LocalTime
                    );
    DsysAssert(NT_SUCCESS(Status));
#else
    BOOL Result;
    Result = FileTimeToLocalFileTime(
                (PFILETIME) SystemTime,
                (PFILETIME) LocalTime
                );
    DsysAssert(Result);
#endif

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertKdcOptionsToTicketFlags
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KerbConvertKdcOptionsToTicketFlags(
    IN ULONG KdcOptions
    )
{
    ULONG TicketFlags = 0;

    if ((KdcOptions & KERB_KDC_OPTIONS_forwardable) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_forwardable;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_forwarded) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_forwarded;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_proxiable) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_proxiable;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_proxy) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_proxy;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_postdated) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_postdated;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_allow_postdate) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_may_postdate;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_renewable) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_renewable;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_cname_in_pa_data) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_cname_in_pa_data;
    }


    return(TicketFlags);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetAddressListFromWinsock
//
//  Synopsis:   gets the list of addresses from a winsock ioctl
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetAddressListFromWinsock(
    OUT LPSOCKET_ADDRESS_LIST * SocketAddressList
    )
{
    ULONG BytesReturned = 150;
    LPSOCKET_ADDRESS_LIST AddressList = NULL;
    INT i,j;
    ULONG NetStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    SOCKET AddressSocket = INVALID_SOCKET;

#ifdef WIN32_CHICAGO
    j = 0;
    AddressList = (LPSOCKET_ADDRESS_LIST) MIDL_user_allocate(sizeof(SOCKET_ADDRESS_LIST));
    if (AddressList == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
#else // WIN32_CHICAGO
    AddressSocket = WSASocket( AF_INET,
                           SOCK_DGRAM,
                           0, // PF_INET,
                           NULL,
                           0,
                           0 );

    if ( AddressSocket == INVALID_SOCKET ) {

        NetStatus = WSAGetLastError();
        D_DebugLog((DEB_ERROR,"WSASocket failed with %ld. %ws, line %d\n", NetStatus, THIS_FILE, __LINE__ ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    for (;;) {

        //
        // Allocate a buffer that should be big enough.
        //

        if ( AddressList != NULL ) {
            MIDL_user_free( AddressList );
        }

        AddressList = (LPSOCKET_ADDRESS_LIST) MIDL_user_allocate( BytesReturned );

        if ( AddressList == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Get the list of IP addresses
        //

        NetStatus = WSAIoctl( AddressSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL, // No input buffer
                              0,    // No input buffer
                              (PVOID) AddressList,
                              BytesReturned,
                              &BytesReturned,
                              NULL, // No overlapped,
                              NULL );   // Not async

        if ( NetStatus != 0 ) {
            NetStatus = WSAGetLastError();
            //
            // If the buffer isn't big enough, try again.
            //
            if ( NetStatus == WSAEFAULT ) {
                continue;
            }

            D_DebugLog((DEB_ERROR,"KerbGetAddressListFromWinsock: Cannot WSAIoctl SIO_ADDRESS_LIST_QUERY %ld %ld. %ws, line %d\n",
                      NetStatus, BytesReturned, THIS_FILE, __LINE__));
            Status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        break;
    }

    //
    // Weed out any zero IP addresses and other invalid addresses
    //

    for ( i = 0, j = 0; i < AddressList->iAddressCount; i++ ) {
        PSOCKET_ADDRESS SocketAddress;

        //
        // Copy this address to the front of the list.
        //
        AddressList->Address[j] = AddressList->Address[i];

        //
        // If the address isn't valid,
        //  skip it.
        //
        SocketAddress = &AddressList->Address[j];

        if ( SocketAddress->iSockaddrLength == 0 ||
             SocketAddress->lpSockaddr == NULL ||
             SocketAddress->lpSockaddr->sa_family != AF_INET ||
             ((PSOCKADDR_IN)(SocketAddress->lpSockaddr))->sin_addr.s_addr == 0 ) {


        } else {

            //
            // Otherwise keep it.
            //

            j++;
        }
    }
#endif // WIN32_CHICAGO

    AddressList->iAddressCount = j;
    *SocketAddressList = AddressList;
    AddressList = NULL;

Cleanup:
    if (AddressList != NULL)
    {
        MIDL_user_free(AddressList);
    }

    if ( AddressSocket != INVALID_SOCKET ) {
        closesocket(AddressSocket);
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildHostAddresses
//
//  Synopsis:   Builds a list of host addresses to go in a KDC request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbBuildHostAddresses(
    IN BOOLEAN IncludeIpAddresses,
    IN BOOLEAN IncludeNetbiosAddresses,
    OUT PKERB_HOST_ADDRESSES * HostAddresses
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_HOST_ADDRESSES Addresses = NULL;
    PKERB_HOST_ADDRESSES TempAddress = NULL;
    BOOLEAN LockHeld = FALSE;

#ifndef WIN32_CHICAGO

    KerbGlobalReadLock();
    LockHeld = TRUE;

    //
    // Check to see if we've gotten out addresses from Netlogon yet.
    //
    if ( IncludeIpAddresses &&
         KerbGlobalIpAddressCount == 0)
    {
        LPSOCKET_ADDRESS_LIST SocketAddressList = NULL;
        KerbGlobalReleaseLock();
        LockHeld = FALSE;

        //
        // We haven't get them now
        //

        Status = KerbGetAddressListFromWinsock(
                    &SocketAddressList
                    );

        if (NT_SUCCESS(Status))
        {
            Status = KerbUpdateGlobalAddresses(
                        SocketAddressList->Address,
                        SocketAddressList->iAddressCount
                        );
            MIDL_user_free(SocketAddressList);
        }
        else
        {
            KerbGlobalWriteLock();
            KerbGlobalIpAddressesInitialized = TRUE;
            KerbGlobalReleaseLock();
        }
        KerbGlobalReadLock();
        LockHeld = TRUE;
    }

    //
    // On failure don't bother inserting the IP addresses
    //

    if ( Status == STATUS_SUCCESS &&
         IncludeIpAddresses ) {

        ULONG Index;

        for (Index = 0; Index < KerbGlobalIpAddressCount ; Index++ )
        {

            TempAddress = (PKERB_HOST_ADDRESSES) KerbAllocate(sizeof(KERB_HOST_ADDRESSES));
            if (TempAddress == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            TempAddress->value.address_type = KERB_ADDRTYPE_INET;
            TempAddress->value.address.length = 4;
            TempAddress->value.address.value = (PUCHAR) KerbAllocate(4);
            if (TempAddress->value.address.value == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory
               (
                TempAddress->value.address.value,
                &KerbGlobalIpAddresses[Index].sin_addr.S_un.S_addr,
                4
                );
            TempAddress->next = Addresses;
            Addresses = TempAddress;
            TempAddress = NULL;

        }
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

#endif // WIN32_CHICAGO

    //
    // Insert the netbios address (if it will fit)
    //

    if (IncludeNetbiosAddresses &&
        KerbGlobalKerbMachineName.Length < NCBNAMSZ)
    {
        TempAddress = (PKERB_HOST_ADDRESSES) KerbAllocate(sizeof(KERB_HOST_ADDRESSES));
        if (TempAddress == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        TempAddress->value.address_type = KERB_ADDRTYPE_NETBIOS;
        TempAddress->value.address.length = NCBNAMSZ;
        TempAddress->value.address.value = (PUCHAR) KerbAllocate(NCBNAMSZ);
        if (TempAddress->value.address.value == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            TempAddress->value.address.value,
            KerbGlobalKerbMachineName.Buffer,
            KerbGlobalKerbMachineName.Length
            );
        memset(
            TempAddress->value.address.value + KerbGlobalKerbMachineName.Length,
            ' ',        // space
            NCBNAMSZ - KerbGlobalKerbMachineName.Length
            );

        TempAddress->next = Addresses;
        Addresses = TempAddress;
        TempAddress = NULL;

    }

    *HostAddresses = Addresses;
    Addresses = NULL;

Cleanup:

    if (LockHeld)
    {
        KerbGlobalReleaseLock();
    }
    if (TempAddress != NULL)
    {
        if (TempAddress->value.address.value != NULL)
        {
            KerbFree(TempAddress->value.address.value);
        }
        KerbFree(TempAddress);
    }
    if (Addresses != NULL)
    {
        //KerbFreeHostAddresses(Addresses);
        while (Addresses != NULL)
        {
            TempAddress = Addresses;
            Addresses = Addresses->next;
            if (TempAddress->value.address.value != NULL)
            {
                KerbFree(TempAddress->value.address.value);
            }
            KerbFree(TempAddress);
        }
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildGssErrorMessage
//
//  Synopsis:   Builds an error message with GSS framing, if necessary
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildGssErrorMessage(
    IN KERBERR Error,
    IN PBYTE ErrorData,
    IN ULONG ErrorDataSize,
    IN PKERB_CONTEXT Context,
    OUT PULONG ErrorMessageSize,
    OUT PBYTE * ErrorMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PBYTE RawErrorMessage = NULL;
    ULONG RawErrorMessageSize = 0;
    PBYTE EncodedErrorData = NULL;
    ULONG EncodedErrorDataSize = 0;
    PBYTE MessageStart = NULL;
    KERB_ERROR_METHOD_DATA ApErrorData = {0};
    PKERB_INTERNAL_NAME Spn = NULL;
    gss_OID MechId;


    //
    // First, convert the error data to a specified type
    //

    if (Error == KRB_AP_ERR_SKEW)
    {
        ApErrorData.data_type = KERB_AP_ERR_TYPE_SKEW_RECOVERY;
        ApErrorData.data_value.value = NULL;
        ApErrorData.data_value.length = 0;

        KerbErr = KerbPackData(
                    &ApErrorData,
                    KERB_ERROR_METHOD_DATA_PDU,
                    &EncodedErrorDataSize,
                    &EncodedErrorData
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
    }
    else if (ErrorDataSize != 0)
    {
        if (Error == KRB_AP_ERR_USER_TO_USER_REQUIRED)
        {
            EncodedErrorData = ErrorData;
            EncodedErrorDataSize = ErrorDataSize;
        }
        else
        {

            ApErrorData.data_type = KERB_AP_ERR_TYPE_NTSTATUS;
            ApErrorData.data_value.value = ErrorData;
            ApErrorData.data_value.length = ErrorDataSize;
            ApErrorData.bit_mask |= data_value_present;

            KerbErr = KerbPackData(
                        &ApErrorData,
                        KERB_ERROR_METHOD_DATA_PDU,
                        &EncodedErrorDataSize,
                        &EncodedErrorData
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }
        }
    }

    //
    // First build the error message
    //
    KerbGlobalReadLock();

    if (Context->ServerPrincipalName.Buffer != NULL)
    {
       KerbErr = KerbConvertStringToKdcName(
                     &Spn,
                     &Context->ServerPrincipalName
                     );

       if (!KERB_SUCCESS(KerbErr))
       {
          Status = KerbMapKerbError(KerbErr);
          goto Cleanup;
       }
    }
    else
    {
       Spn = KerbGlobalInternalMachineServiceName;
    }

    KerbErr = KerbBuildErrorMessageEx(
                Error,
                NULL, // no extended error
                &KerbGlobalDnsDomainName,
                Spn,
                NULL,               // no client realm
                EncodedErrorData,
                EncodedErrorDataSize,
                &RawErrorMessageSize,
                &RawErrorMessage
                );

    KerbGlobalReleaseLock();
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Figure out what OID to use
    //

    KerbReadLockContexts();

    //
    // For DCE style we don't use an OID
    //

    if ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0)
    {
        KerbUnlockContexts();
        *ErrorMessage = RawErrorMessage;
        *ErrorMessageSize = RawErrorMessageSize;
        RawErrorMessage = NULL;
        goto Cleanup;
    }

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechId = gss_mech_krb5_u2u;
    }
    else
    {
        MechId = gss_mech_krb5_new;
    }
    KerbUnlockContexts();

    *ErrorMessageSize = g_token_size(MechId, RawErrorMessageSize);

    *ErrorMessage = (PBYTE) KerbAllocate(*ErrorMessageSize);
    if (*ErrorMessage == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // the g_make_token_header will reset this to point to the end of the
    // header
    //


    MessageStart = *ErrorMessage;

    g_make_token_header(
        MechId,
        RawErrorMessageSize,
        &MessageStart,
        KG_TOK_CTX_ERROR
        );

    RtlCopyMemory(
        MessageStart,
        RawErrorMessage,
        RawErrorMessageSize
        );

Cleanup:
    if (RawErrorMessage != NULL)
    {
        MIDL_user_free(RawErrorMessage);
    }
    if (EncodedErrorData != ErrorData)
    {
        MIDL_user_free(EncodedErrorData);
    }

    if (Spn != NULL && Context->ServerPrincipalName.Buffer != NULL)
    {
       MIDL_user_free(Spn);
    }


    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbReceiveErrorMessage
//
//  Synopsis:   Unpacks an error message from a context request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbReceiveErrorMessage(
    IN PBYTE ErrorMessage,
    IN ULONG ErrorMessageSize,
    IN PKERB_CONTEXT Context,
    OUT PKERB_ERROR * DecodedErrorMessage,
    OUT PKERB_ERROR_METHOD_DATA * ErrorData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PBYTE MessageStart = NULL;
    ULONG MessageSize = 0;
    BOOLEAN VerifiedHeader = FALSE;
    gss_OID MechId = NULL;

    KerbReadLockContexts();

    //
    // For DCE style we don't use an OID
    //

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechId = gss_mech_krb5_u2u;
    }
    else
    {
        MechId = gss_mech_krb5_new;
    }
    KerbUnlockContexts();

    //
    // First try pull off the header
    //

    MessageSize = ErrorMessageSize;
    MessageStart = ErrorMessage;

    if (!g_verify_token_header(
            MechId,
            (INT *) &MessageSize,
            &MessageStart,
            KG_TOK_CTX_ERROR,
            ErrorMessageSize
            ))
    {
            //
            // If we couldn't find the header, try it without
            // a header
            //

            MessageSize = ErrorMessageSize;
            MessageStart = ErrorMessage;
    }
    else
    {
        VerifiedHeader = TRUE;
    }


    KerbErr = KerbUnpackKerbError(
                MessageStart,
                MessageSize,
                DecodedErrorMessage
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (((*DecodedErrorMessage)->bit_mask & error_data_present) != 0)
    {
        KerbUnpackErrorMethodData(
           *DecodedErrorMessage,
           ErrorData
           );
    }
    else
    {
        Status = KerbMapKerbError(KerbErr);
    }
Cleanup:
    return(Status);
}

#ifndef WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackErrorMethodData
//
//  Synopsis:   This routine unpacks extended error information from
//              a KERB_ERROR message
//
//  Effects:
//
//  Arguments:    Unpacked error message.  Returns extended error to
//                be freed using KerbFree
//
//  Requires:
//
//  Returns:   NTSTATUS
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbUnpackErrorMethodData(
   IN PKERB_ERROR  ErrorMessage,
   IN OUT OPTIONAL PKERB_ERROR_METHOD_DATA * ppErrorData
   )
{

    PKERB_ERROR_METHOD_DATA pErrorData = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;

    if (ARGUMENT_PRESENT(ppErrorData))
    {
       *ppErrorData = NULL;
    }

    if ((ErrorMessage->bit_mask & error_data_present) == 0)
    {
       return (KRB_ERR_GENERIC);
    }

    KerbErr = KerbUnpackData(
                 ErrorMessage->error_data.value,
                 ErrorMessage->error_data.length,
                 KERB_ERROR_METHOD_DATA_PDU,
                 (void**) &pErrorData
                 );

    if (KERB_SUCCESS(KerbErr) && ARGUMENT_PRESENT(ppErrorData) && (NULL != pErrorData))
    {
        *ppErrorData = pErrorData;
        pErrorData = NULL;
    }

    if (pErrorData)
    {
        KerbFreeData(KERB_ERROR_METHOD_DATA_PDU, pErrorData);
    }

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetDnsHostName
//
//  Synopsis:   This routine gets DnsHostName of this machine.
//
//  Effects:
//
//  Arguments:      DnsHostName - Returns the DNS Host Name of the machine.
//        Will return a NULL string if this machine has no DNS host name.
//        Free this buffer using KerbFreeString.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetDnsHostName(
    OUT PUNICODE_STRING DnsHostName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    WCHAR LocalDnsUnicodeHostName[DNS_MAX_NAME_BUFFER_LENGTH+1];
    ULONG LocalDnsUnicodeHostNameLen = DNS_MAX_NAME_BUFFER_LENGTH+1;
    LPWSTR ConfiguredDnsName = LocalDnsUnicodeHostName;
    UNICODE_STRING HostName;


    RtlInitUnicodeString(
        DnsHostName,
        NULL
        );
    //
    // Get the DNS host name.
    //
    if (!GetComputerNameEx(
            ComputerNameDnsHostname,
            ConfiguredDnsName,
            &LocalDnsUnicodeHostNameLen))
    {
        goto Cleanup;
    }


    ConfiguredDnsName = &LocalDnsUnicodeHostName[LocalDnsUnicodeHostNameLen];
    *ConfiguredDnsName = L'.';
    ConfiguredDnsName++;

    //
    // Now get the DNS domain name
    //

    LocalDnsUnicodeHostNameLen = DNS_MAX_NAME_BUFFER_LENGTH - LocalDnsUnicodeHostNameLen;

    if (!GetComputerNameEx(
            ComputerNameDnsDomain,
            ConfiguredDnsName,
            &LocalDnsUnicodeHostNameLen
            ))
    {
        goto Cleanup;
    }


    RtlInitUnicodeString(
        &HostName,
        LocalDnsUnicodeHostName
        );

    Status = RtlDowncaseUnicodeString(
                &HostName,
                &HostName,
                FALSE           // don't allocate destination
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = KerbDuplicateString(
                DnsHostName,
                &HostName
                );


Cleanup:
    return Status;
}

#endif // WIN32_CHICAGO


//+-------------------------------------------------------------------------
//
//  Function:   KerbIsThisOurDomain
//
//  Synopsis:   Compares a domain name to the local domain anme
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbIsThisOurDomain(
    IN PUNICODE_STRING DomainName
    )
{
    BOOLEAN Result;
    KerbGlobalReadLock();

    Result = KerbCompareUnicodeRealmNames(
                    DomainName,
                    &KerbGlobalDnsDomainName
                    ) ||
             RtlEqualUnicodeString(
                    DomainName,
                    &KerbGlobalDomainName,
                    TRUE
                    );

    KerbGlobalReleaseLock();
    return(Result);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetOurDomainName
//
//  Synopsis:   Copies the machines dns domain name, if available,
//              netbios otherwise.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetOurDomainName(
    OUT PUNICODE_STRING DomainName
    )
{
    NTSTATUS Status;
    KerbGlobalReadLock();

    if (KerbGlobalDnsDomainName.Length != 0)
    {
        Status = KerbDuplicateString(
                    DomainName,
                    &KerbGlobalDnsDomainName
                    );
    }
    else
    {
        Status = KerbDuplicateString(
                    DomainName,
                    &KerbGlobalDomainName
                    );
    }

    KerbGlobalReleaseLock();
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetGlobalRole
//
//  Synopsis:   Returns the current role of the machine
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBEROS_MACHINE_ROLE
KerbGetGlobalRole(
    VOID
    )
{
    KERBEROS_MACHINE_ROLE Role;
    KerbGlobalReadLock();
    Role = KerbGlobalRole;
    KerbGlobalReleaseLock();
    return(Role);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbSetComputerName
//
//  Synopsis:   Sets all computer-name related global variables
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbSetComputerName(
    VOID
    )
{
    UNICODE_STRING LocalMachineName;
    STRING LocalKerbMachineName;

    UNICODE_STRING OldMachineName;
    STRING OldKerbMachineName;

    ULONG ComputerNameLength;
    NTSTATUS Status;
    BOOLEAN LockHeld = FALSE;
#ifdef WIN32_CHICAGO
    CHAR TempAnsiBuffer[MAX_COMPUTERNAME_LENGTH + 1];
    ComputerNameLength = sizeof(TempAnsiBuffer);
#endif

    LocalMachineName.Buffer = NULL;
    LocalKerbMachineName.Buffer = NULL;

#ifndef WIN32_CHICAGO
    ComputerNameLength = 0;
    if (GetComputerNameW(
            NULL,
            &ComputerNameLength
            ))
    {
        D_DebugLog((DEB_ERROR,"Succeeded to get computer name when failure expected! %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    LocalMachineName.Buffer = (LPWSTR) KerbAllocate(
                                                (ComputerNameLength * sizeof(WCHAR))
                                                );
    if (LocalMachineName.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
    if (!GetComputerNameW(
            LocalMachineName.Buffer,
            &ComputerNameLength
            ))
#else // WIN32_CHICAGO

    if (!GetComputerName(
            TempAnsiBuffer,
            &ComputerNameLength
            ))
#endif // WIN32_CHICAGO
    {
        D_DebugLog((DEB_ERROR,"Failed to get computer name: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    LocalMachineName.Length = (USHORT)(ComputerNameLength * sizeof(WCHAR));
    LocalMachineName.MaximumLength = LocalMachineName.Length + sizeof(WCHAR);
#else
    RtlCreateUnicodeStringFromAsciiz (&LocalMachineName, TempAnsiBuffer);
//    KerbFree (TempAnsiBuffer);
#endif // WIN32_CHICAGO

    //
    // Build the ansi format
    //

    if (!KERB_SUCCESS(KerbUnicodeStringToKerbString(
            &LocalKerbMachineName,
            &LocalMachineName
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // free the current globals, and update to point at new values.
    //

    KerbGlobalWriteLock();
    LockHeld = TRUE;

    OldMachineName = KerbGlobalMachineName;
    OldKerbMachineName = KerbGlobalKerbMachineName;

    KerbGlobalMachineName = LocalMachineName;
    KerbGlobalKerbMachineName = LocalKerbMachineName;

    //
    // now, see if the netbios machine name changed versus the prior
    // value.
    //

    if( OldMachineName.Buffer != NULL )
    {
        if(!RtlEqualUnicodeString( &OldMachineName, &LocalMachineName, FALSE ))
        {
            D_DebugLog((DEB_WARN,"Netbios computer name change detected.\n"));
            KerbGlobalMachineNameChanged = TRUE;
        }
    }

    KerbGlobalReleaseLock();
    LockHeld = FALSE;


    LocalMachineName.Buffer = NULL;
    LocalKerbMachineName.Buffer = NULL;

    KerbFreeString( &OldMachineName );
    KerbFreeString( (PUNICODE_STRING)&OldKerbMachineName );

    Status = STATUS_SUCCESS;

Cleanup:

    if( LockHeld )
    {
        KerbGlobalReleaseLock();
    }

    KerbFreeString( &LocalMachineName );
    KerbFreeString( (PUNICODE_STRING)&LocalKerbMachineName );

    return Status;
}



//
//
// Routine Description:
//
//  This function checks the system to see if
//  we are running on the personal version of
//  the operating system.
//
//  The personal version is denoted by the product
//  id equal to WINNT, which is really workstation,
//  and the product suite containing the personal
//  suite string.
//

BOOLEAN
KerbRunningPersonal(
    VOID
    )
{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = VER_SUITE_PERSONAL;
    OsVer.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION( ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL );
    VER_SET_CONDITION( ConditionMask, VER_SUITENAME, VER_AND );

    return RtlVerifyVersionInfo( &OsVer,
                                 VER_PRODUCT_TYPE | VER_SUITENAME,
                                 ConditionMask) == STATUS_SUCCESS;
}

BOOLEAN
KerbRunningServer(
    VOID
    )
{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wProductType = VER_NT_DOMAIN_CONTROLLER;

    VER_SET_CONDITION( ConditionMask, VER_PRODUCT_TYPE, VER_GREATER_EQUAL );

    return RtlVerifyVersionInfo( &OsVer,
                                 VER_PRODUCT_TYPE ,
                                 ConditionMask) == STATUS_SUCCESS;
}









//+-------------------------------------------------------------------------
//
//  Function:   KerbSetDomainName
//
//  Synopsis:   Sets all domain-name related global variables
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbSetDomainName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING DnsDomainName,
    IN PSID DomainSid,
    IN GUID DomainGuid
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AcquiredLock = FALSE;
    UNICODE_STRING TempDomainName = {0};
    UNICODE_STRING TempDnsDomainName = {0};
    UNICODE_STRING TempMachineServiceName = {0};
    PKERB_INTERNAL_NAME TempMitMachineServiceName = NULL;
    PKERB_INTERNAL_NAME TempInternalMachineServiceName = NULL;
    PSID TempDomainSid = NULL;
    UNICODE_STRING TempString;
    WCHAR MachineAccountName[CNLEN+2];  // for null and '$'
    UNICODE_STRING DnsString = {0};
    UNICODE_STRING SystemDomain = {0};
    PSID MachineSid = NULL;
#ifndef WIN32_CHICAGO
    LUID SystemLogonId = SYSTEM_LUID;
    PKERB_LOGON_SESSION SystemLogonSession = NULL;
#endif



    //
    // Copy the domain name / sid
    //

    Status = KerbDuplicateString(
                &TempDomainName,
                DomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &TempDnsDomainName,
                DnsDomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If we are in an NT domain, uppercase the dns domain name
    //
#ifndef WIN32_CHICAGO
    if (DomainSid != NULL)
#endif
    {
        Status = RtlUpcaseUnicodeString(
                    &TempDnsDomainName,
                    &TempDnsDomainName,
                    FALSE   // don't allocate
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

#ifndef WIN32_CHICAGO

    if (DomainSid != NULL)
    {
        Status = KerbDuplicateSid(
                    &TempDomainSid,
                    DomainSid
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }
#endif

    //
    // Create the new machine names
    //

    KerbGlobalReadLock();

    ASSERT( (KerbGlobalMachineName.Length <= (CNLEN*sizeof(WCHAR)) ) );

    RtlCopyMemory(
        MachineAccountName,
        KerbGlobalMachineName.Buffer,
        KerbGlobalMachineName.Length
        );

    MachineAccountName[KerbGlobalMachineName.Length/sizeof(WCHAR)] = SSI_ACCOUNT_NAME_POSTFIX_CHAR;
    MachineAccountName[1+KerbGlobalMachineName.Length/sizeof(WCHAR)] = L'\0';

    KerbGlobalReleaseLock();

    RtlInitUnicodeString(
        &TempString,
        MachineAccountName
        );

    Status = KerbDuplicateString(
                &TempMachineServiceName,
                &TempString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Get the machine sid to use in the name
    //

#ifndef WIN32_CHICAGO
    if (KerbGlobalUseSidCache)
    {
        KerbGetMachineSid( &MachineSid );
    }
#endif // WIN32_CHICAGO
    //
    // Create the KERB_INTERNAL_NAME version of the name
    //

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcNameWithSid(
            &TempDnsDomainName,
            &TempMachineServiceName,
            MachineSid,
            (MachineSid == NULL) ? KRB_NT_PRINCIPAL : KRB_NT_PRINCIPAL_AND_ID,
            &TempInternalMachineServiceName)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


#ifndef WIN32_CHICAGO

    //
    // Now build the MIT version of our machine service name
    //

    Status = KerbGetDnsHostName(
                &DnsString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &TempString,
        KERB_HOST_STRING
        );


    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                &DnsString,
                &TempString,
                KRB_NT_SRV_HST,
                &TempMitMachineServiceName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Find the system logon session.
    //

    SystemLogonSession = KerbReferenceLogonSession(
                            &SystemLogonId,
                            FALSE               // don't unlink
                            );

    if (SystemLogonSession != NULL)
    {
        Status = KerbDuplicateString(
                    &SystemDomain,
                    DnsDomainName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }


    //
    // Acquire the global lock so we can update the data
    //

    if (!KerbGlobalWriteLock())
    {
        D_DebugLog((DEB_ERROR,"Failed to acquire global resource. Not changing domain. %ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }
    AcquiredLock = TRUE;
#endif // WIN32_CHICAGO

    //
    // Copy all the data to the global structures
    //

    // If we're NT4, we don't have a dns domain name
    // If we're joined to an MIT domain, we don't have a domain GUID and we
    // have a dns domain name

    if ((DomainGuid == GUID_NULL) && (TempDnsDomainName.Length == 0))
    {
        KerbGlobalDomainIsPreNT5 = TRUE;
    }
    else
    {
        KerbGlobalDomainIsPreNT5 = FALSE;
    }

    KerbFreeString(&KerbGlobalDomainName);
    KerbGlobalDomainName = TempDomainName;
    TempDomainName.Buffer = NULL;

    KerbFreeString(&KerbGlobalDnsDomainName);
    KerbGlobalDnsDomainName = TempDnsDomainName;
    TempDnsDomainName.Buffer = NULL;

    KerbFreeString(&KerbGlobalMachineServiceName);
    KerbGlobalMachineServiceName = TempMachineServiceName;
    TempMachineServiceName.Buffer = NULL;

    KerbFreeKdcName(&KerbGlobalInternalMachineServiceName);
    KerbGlobalInternalMachineServiceName = TempInternalMachineServiceName;
    TempInternalMachineServiceName = NULL;

#ifndef WIN32_CHICAGO

    KerbFreeKdcName(&KerbGlobalMitMachineServiceName);
    KerbGlobalMitMachineServiceName = TempMitMachineServiceName;
    TempMitMachineServiceName = NULL;



    if (KerbGlobalDomainSid != NULL)
    {
        KerbFree(KerbGlobalDomainSid);
    }
    KerbGlobalDomainSid = TempDomainSid;
    TempDomainSid = NULL;

    //
    // Update the role on non DCs. The role of a DC never changes.
    // Demotion requires a reboot so that the domain controller role
    // will not change.
    //

    if (KerbGlobalRole != KerbRoleDomainController)
    {

        if (KerbRunningPersonal())
        {
            KerbGlobalRole = KerbRoleRealmlessWksta;
        }
        else if (DomainSid == NULL )
        {
            // No machine account, nor associate w/ MIT realm
            if (DnsDomainName->Length == 0 )
            {
                KerbGlobalRole = KerbRoleRealmlessWksta;
            }
            // Member of MIT realm, but not a domain
            else
            {
                KerbGlobalRole = KerbRoleStandalone;
            }
        }
        else
        {
            KerbGlobalRole = KerbRoleWorkstation;
        }
    }

    //
    // Update the system logon session, if there is one
    //

    if (SystemLogonSession != NULL)
    {
        KerbWriteLockLogonSessions(SystemLogonSession);

        KerbFreeString(&SystemLogonSession->PrimaryCredentials.DomainName);
        SystemLogonSession->PrimaryCredentials.DomainName = SystemDomain;
        SystemDomain.Buffer = NULL;
        KerbPurgeTicketCache(&SystemLogonSession->PrimaryCredentials.ServerTicketCache);
        KerbPurgeTicketCache(&SystemLogonSession->PrimaryCredentials.AuthenticationTicketCache);
        SystemLogonSession->LogonSessionFlags |= KERB_LOGON_DEFERRED;

        KerbUnlockLogonSessions(SystemLogonSession);

    }
#endif

Cleanup:

#ifndef WIN32_CHICAGO
    if (AcquiredLock)
    {
        KerbGlobalReleaseLock();
    }
#endif // WIN32_CHICAGO

    KerbFreeString(
        &DnsString
        );
    KerbFreeString(
        &SystemDomain
        );
    KerbFreeString(
        &TempDomainName
        );
    KerbFreeString(
        &TempDnsDomainName
        );
    KerbFreeString(
        &TempMachineServiceName
        );
    KerbFreeKdcName(
        &TempInternalMachineServiceName
        );

#ifndef WIN32_CHICAGO

    if (MachineSid != NULL)
    {
        KerbFree(MachineSid);
    }

    KerbFreeKdcName(
        &TempMitMachineServiceName
        );

    if (TempDomainSid != NULL)
    {
        KerbFree(TempDomainSid);
    }
    if (SystemLogonSession != NULL)
    {
        KerbDereferenceLogonSession(SystemLogonSession);
    }
#endif

    return(Status);

}

#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbLoadKdc
//
//  Synopsis:   Loads kdcsvc.dll and gets the address of important functions
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS if kdcsvc.dll could be loaded and the
//              necessary entrypoints found.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbLoadKdc(
    VOID
    )
{
    NTSTATUS Status  = STATUS_SUCCESS;
    KerbKdcHandle = LoadLibraryA("kdcsvc.dll");
    if (KerbKdcHandle == NULL) {
        D_DebugLog((DEB_WARN,"Failed to load kdcsvc.dll: %d\n",GetLastError()));
        return(STATUS_DLL_NOT_FOUND);
    }

    KerbKdcVerifyPac = (PKDC_VERIFY_PAC_ROUTINE) GetProcAddress(
                                                    KerbKdcHandle,
                                                    KDC_VERIFY_PAC_NAME
                                                    );
    if (KerbKdcVerifyPac == NULL)
    {
        D_DebugLog((DEB_WARN, "Failed to get proc address for KdcVerifyPac: %d\n",
            GetLastError()));
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }

    KerbKdcGetTicket = (PKDC_GET_TICKET_ROUTINE) GetProcAddress(
                                                    KerbKdcHandle,
                                                    KDC_GET_TICKET_NAME
                                                    );
    if (KerbKdcGetTicket == NULL)
    {
        D_DebugLog((DEB_WARN,"Failed to get proc address for KdcGetTicket: %d\n",
            GetLastError()));
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }

    KerbKdcChangePassword = (PKDC_GET_TICKET_ROUTINE) GetProcAddress(
                                                    KerbKdcHandle,
                                                    KDC_CHANGE_PASSWORD_NAME
                                                    );
    if (KerbKdcChangePassword == NULL)
    {
        D_DebugLog((DEB_WARN,"Failed to get proc address for KdcChangePassword: %d\n",
            GetLastError()));
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }

    KerbKdcFreeMemory = (PKDC_FREE_MEMORY_ROUTINE) GetProcAddress(
                                                    KerbKdcHandle,
                                                    KDC_FREE_MEMORY_NAME
                                                    );
    if (KerbKdcFreeMemory == NULL)
    {
        D_DebugLog((DEB_WARN,"Failed to get proc address for KdcFreeMemory: %d\n",
            GetLastError()));
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (KerbKdcHandle != NULL)
        {
            FreeLibrary(KerbKdcHandle);
            KerbKdcHandle = NULL;
        }
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbDomainChangeCallback
//
//  Synopsis:   Function to be called when domain changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID NTAPI
KerbDomainChangeCallback(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_INFORMATION Policy = NULL;



    //
    // We only care about domain dns information
    //

    if (ChangedInfoClass != PolicyNotifyDnsDomainInformation)
    {
        return;
    }


    //
    // Get the new domain information
    //


    Status = I_LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &Policy
                );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to query domain dns information %x - not updating. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // update computer name info.
    //

    Status = KerbSetComputerName();

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to set computer name: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    Status = KerbSetDomainName(
                (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.Name,
                (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.DnsDomainName,
                (PSID) Policy->PolicyDnsDomainInfo.Sid,
                (GUID) Policy->PolicyDnsDomainInfo.DomainGuid
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to set domain name: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Domain Name has changed. So, the cache in the registry will
    // have changed too. And we haven't rebooted yet.
    //

    KerbSetKdcData(TRUE, FALSE);


    if (KerbGetGlobalRole() != KerbRoleDomainController)
    {
        //
        // If we aren't in a domain anymore, flush the machine account sid
        // cache.
        //

        if (Policy->PolicyDnsDomainInfo.Sid == NULL)
        {
            KerbWriteMachineSid(
                NULL
                );
        }
        else
        {
            (VOID) LsaFunctions->RegisterNotification(
                        KerbUpdateMachineSidWorker,
                        NULL,                           // no parameter
                        NOTIFIER_TYPE_IMMEDIATE,
                        0,                              // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        0,              // no inteval
                        NULL            // no wait event
                        );
        }
    }

Cleanup:

    if (Policy != NULL)
    {
        I_LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            Policy
            );
    }
    return;

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbRegisterForDomainChange
//
//  Synopsis:   Register with the LSA to be notified of domain changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbRegisterForDomainChange(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    Status = I_LsaIRegisterPolicyChangeNotificationCallback(
                KerbDomainChangeCallback,
                PolicyNotifyDnsDomainInformation
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to register for domain change notification: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
    }
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbUnregisterForDomainChange
//
//  Synopsis:   Unregister for domain change notification
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbUnregisterForDomainChange(
    VOID
    )
{
    (VOID) I_LsaIUnregisterPolicyChangeNotificationCallback(
                KerbDomainChangeCallback,
                PolicyNotifyDnsDomainInformation
                );

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateGlobalAddresses
//
//  Synopsis:   Updates the global array of addresses with information from
//              netlogon.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes: Ideally, we should also have called WSAProviderConfigChange to be
//         notified of when tcp is added/removed. But, we can take advantage
//         of the fact that netlogon is registered for changes in ipaddress
//         so, even though, change of ipaddress & xports notifications are
//         async, we will get to know of it, so, it suffices to rely on
//         netlogon rather than register for a notification change.
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbUpdateGlobalAddresses(
    IN PSOCKET_ADDRESS NewAddresses,
    IN ULONG NewAddressCount
    )
{
    PSOCKADDR_IN GlobalIpAddresses = NULL;
    ULONG Index;
    ULONG AddressCount = 0;
    WSAPROTOCOL_INFO *lpProtocolBuf = NULL;
    DWORD dwBufLen = 0;
    INT protocols[2];
    int nRet = 0;
    BOOLEAN NoTcpInstalled = FALSE;

    GlobalIpAddresses = (PSOCKADDR_IN) KerbAllocate(sizeof(SOCKADDR_IN) * NewAddressCount);
    if (GlobalIpAddresses == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    for (Index = 0; Index < NewAddressCount ; Index++ )
    {
        if ((NewAddresses[Index].iSockaddrLength == sizeof(SOCKADDR)) &&
            (NewAddresses[Index].lpSockaddr->sa_family == AF_INET))
        {
            RtlCopyMemory(
                &GlobalIpAddresses[AddressCount++],
                NewAddresses[Index].lpSockaddr,
                sizeof(SOCKADDR_IN)
                );
        }
        else
        {
            D_DebugLog((DEB_ERROR,"Netlogon handed us a address of length or type %d, %d. %ws, line %d\n",
                NewAddresses[Index].iSockaddrLength,
                NewAddresses[Index].lpSockaddr->sa_family,
                THIS_FILE, __LINE__ ));
        }
    }

    //
    // winsock is already initialized by now, or we would not have
    // gotten so far. Check if TCP s an available xport
    //

    protocols[0] = IPPROTO_TCP;
    protocols[1] = NULL;
    nRet = WSAEnumProtocols(protocols, lpProtocolBuf, &dwBufLen);
    if (nRet == 0)
    {
        //
        // Tcp is not installed as a xport.
        //

        D_DebugLog((DEB_TRACE_SOCK,"WSAEnumProtocols returned 0x%x. %ws, line %d\n", nRet, THIS_FILE, __LINE__ ));
        NoTcpInstalled = TRUE;
    }
    //
    // Copy them into the global for others to use
    //

    KerbGlobalWriteLock();
    if (KerbGlobalIpAddresses != NULL)
    {
        KerbFree(KerbGlobalIpAddresses);
    }
    KerbGlobalIpAddresses = GlobalIpAddresses;
    KerbGlobalIpAddressCount = AddressCount;
    KerbGlobalIpAddressesInitialized = TRUE;
    KerbGlobalNoTcpUdp = NoTcpInstalled;
    KerbGlobalReleaseLock();

    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateMachineSidWorker
//
//  Synopsis:   Calls the LSA to lookup the machine sid
//
//  Effects:
//
//  Arguments:  EventHandle - if not NULL and not INVALID_HANDLE_VALUE,
//                      containst the event handle being waited on. If
//                      NULL, then the routine should retry on failure
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KerbUpdateMachineSidWorker(
    PVOID EventHandle
    )
{
    PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains = NULL;
    LSAPR_TRANSLATED_SIDS TranslatedSids = {0};
    ULONG MappedCount = 0;
    UNICODE_STRING MachineAccountName = {0};
    NTSTATUS Status = STATUS_SUCCESS;
    PSID MachineSid = NULL;
    PKERB_INTERNAL_NAME MachineServiceName = NULL;
    KERBERR KerbErr;

    //
    // If we aren't running, don't do anything
    //

    if (!KerbGlobalInitialized)
    {
        return((ULONG) STATUS_SUCCESS);
    }

    KerbGlobalReadLock();
    KerbErr = KerbBuildFullServiceName(
                &KerbGlobalDomainName,
                &KerbGlobalMachineServiceName,
                &MachineAccountName
                );
    KerbGlobalReleaseLock();

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    Status = LsarLookupNames(
                KerbGlobalPolicyHandle,
                1,                      // name count,
                (PLSAPR_UNICODE_STRING) &MachineAccountName,
                &ReferencedDomains,
                &TranslatedSids,
                LsapLookupWksta,
                &MappedCount
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if ((MappedCount == 0) ||
        (TranslatedSids.Entries != 1) ||
        ((TranslatedSids.Sids[0].Use != SidTypeUser) &&
         (TranslatedSids.Sids[0].Use != SidTypeComputer)) ||
        (TranslatedSids.Sids[0].DomainIndex != 0))
    {
        Status = STATUS_NONE_MAPPED;
        goto Cleanup;
    }

    //
    // Build the sid.
    //

    MachineSid = KerbMakeDomainRelativeSid(
                    (PSID) ReferencedDomains->Domains[TranslatedSids.Sids[0].DomainIndex].Sid,
                    TranslatedSids.Sids[0].RelativeId
                    );
    if (MachineSid == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    //
    // We have a SID - cache it.
    //

    KerbWriteMachineSid( MachineSid );

    //
    // Update the global machine service name
    //


    //
    // Create the KERB_INTERNAL_NAME version of the name
    //

    KerbGlobalWriteLock();


    if (!KERB_SUCCESS(KerbBuildFullServiceKdcNameWithSid(
            &KerbGlobalDnsDomainName,
            &KerbGlobalMachineServiceName,
            MachineSid,
            KRB_NT_PRINCIPAL_AND_ID,
            &MachineServiceName)))
    {
        KerbGlobalReleaseLock();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Cache it for use next time
    //

    KerbCacheLogonSid(
        &KerbGlobalMachineServiceName,
        &KerbGlobalDnsDomainName,
        &KerbGlobalDnsDomainName,
        MachineSid
        );

    KerbFreeKdcName(&KerbGlobalInternalMachineServiceName);
    KerbGlobalInternalMachineServiceName = MachineServiceName;
    MachineServiceName = NULL;
    KerbGlobalReleaseLock();

Cleanup:


    //
    // If the name couldn't be mapped, try again later
    //

    if ((Status == STATUS_NONE_MAPPED) &&
        (KerbGetGlobalRole() == KerbRoleWorkstation) &&
        (EventHandle == NULL))
    {
        (VOID) LsaFunctions->RegisterNotification(
                    KerbUpdateMachineSidWorker,
                    INVALID_HANDLE_VALUE,           // no parameter
                    NOTIFIER_TYPE_INTERVAL,
                    0,                              // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    60,                             // 1 minute
                    NULL                            // no wait event
                    );
    }

    if ((EventHandle != NULL) &&
        (EventHandle != INVALID_HANDLE_VALUE))
    {
        NtClose(EventHandle);
    }

    if (MachineServiceName != NULL)
    {
        KerbFreeKdcName(&MachineServiceName);
    }

    if (TranslatedSids.Entries != 0)
    {
        LsaIFree_LSAPR_TRANSLATED_SIDS(
            &TranslatedSids
            );
    }

    if (ReferencedDomains != NULL)
    {
        LsaIFree_LSAPR_REFERENCED_DOMAIN_LIST(
            ReferencedDomains
            );
    }
    return((ULONG) Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbWaitGetMachineSid
//
//  Synopsis:   This procedure registers a notification to wait for
//              SAM to start and then to get the machine sid.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbWaitGetMachineSid(
    VOID
    )
{
    NTSTATUS Status;
    UNICODE_STRING EventName;
    HANDLE EventHandle = NULL;
    OBJECT_ATTRIBUTES EventAttributes;
    KERBEROS_MACHINE_ROLE Role;


    //
    // If we aren't using SIDs, don't bother
    //

    if (!KerbGlobalUseSidCache)
    {
        return;
    }

    //
    // For a domain controller, wait for SAM to start
    //

    Role = KerbGetGlobalRole();
    if (Role == KerbRoleDomainController)
    {
        //
        // open SAM event
        //

        RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
        InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

        Status = NtOpenEvent( &EventHandle,
                                SYNCHRONIZE|EVENT_MODIFY_STATE,
                                &EventAttributes );

        if ( !NT_SUCCESS(Status)) {

            if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

                //
                // SAM hasn't created this event yet, let us create it now.
                // SAM opens this event to set it.
                //

                Status = NtCreateEvent(
                               &EventHandle,
                               SYNCHRONIZE|EVENT_MODIFY_STATE,
                               &EventAttributes,
                               NotificationEvent,
                               FALSE // The event is initially not signaled
                               );

                if( Status == STATUS_OBJECT_NAME_EXISTS ||
                    Status == STATUS_OBJECT_NAME_COLLISION ) {

                    //
                    // second change, if the SAM created the event before we
                    // do.
                    //

                    Status = NtOpenEvent( &EventHandle,
                                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                                            &EventAttributes );

                }
            }

            if ( !NT_SUCCESS(Status)) {

                //
                // could not make the event handle
                //

                D_DebugLog((DEB_ERROR,
                    "KerbWaitGetMachineSid couldn't make the event handle : "
                    "%lx. %ws, line %d\n", Status, THIS_FILE, __LINE__));

                goto Cleanup;
            }
        }

        //
        // Register a notification to be called back.
        //

        if (LsaFunctions->RegisterNotification(
                    KerbUpdateMachineSidWorker,
                    EventHandle,
                    NOTIFIER_TYPE_HANDLE_WAIT,
                    0,                              // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    0,                            // no inteval
                    EventHandle
                    ) != NULL)
        {
            EventHandle = NULL;
        }

    }
    else if (Role == KerbRoleWorkstation)
    {
        PSID MachineSid;

        //
        // On a workstation, if we don't have a machine sid, wait a while
        // (for the network to start, and then try
        //

        RtlInitUnicodeString( &EventName, L"\\NETLOGON_SERVICE_STARTED");
        InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

        Status = NtOpenEvent( &EventHandle,
                                SYNCHRONIZE|EVENT_MODIFY_STATE,
                                &EventAttributes );

        if ( !NT_SUCCESS(Status)) {

            if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

                //
                // SAM hasn't created this event yet, let us create it now.
                // SAM opens this event to set it.
                //

                Status = NtCreateEvent(
                               &EventHandle,
                               SYNCHRONIZE|EVENT_MODIFY_STATE,
                               &EventAttributes,
                               NotificationEvent,
                               FALSE // The event is initially not signaled
                               );

                if( Status == STATUS_OBJECT_NAME_EXISTS ||
                    Status == STATUS_OBJECT_NAME_COLLISION ) {

                    //
                    // second change, if the SAM created the event before we
                    // do.
                    //

                    Status = NtOpenEvent( &EventHandle,
                                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                                            &EventAttributes );

                }
            }

            if ( !NT_SUCCESS(Status)) {

                //
                // could not make the event handle
                //

                D_DebugLog((DEB_ERROR,
                    "KerbWaitGetMachineSid couldn't make the event handle : "
                    "%lx. %ws, line %d\n", Status, THIS_FILE, __LINE__));

                goto Cleanup;
            }
        }

        if (!NT_SUCCESS(KerbGetMachineSid(&MachineSid)))
        {

            if (LsaFunctions->RegisterNotification(
                        KerbUpdateMachineSidWorker,
                        NULL,                           // no parameter
                        NOTIFIER_TYPE_INTERVAL,
                        0,                              // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        2*60,                           // 2 minute interval
                        EventHandle
                        ) != NULL)
            {
                EventHandle = NULL;
            }
        }
        else
        {
            KerbFree(MachineSid);
        }

    }
Cleanup:
    if (EventHandle != NULL)
    {
        NtClose(EventHandle);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTokenInformation
//
//  Synopsis:   Allocates and returns token information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetTokenInformation(
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS InformationClass,
    IN OUT PVOID * Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BufferSize = 0;

    //
    // First retrieve the restricted sids
    //


    Status = NtQueryInformationToken(
                TokenHandle,
                InformationClass,
                NULL,
                0,
                &BufferSize
                );
    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        goto Cleanup;
    }

    *Buffer =  KerbAllocate(BufferSize);
    if (*Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = NtQueryInformationToken(
                TokenHandle,
                InformationClass,
                *Buffer,
                BufferSize,
                &BufferSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
Cleanup:

    return(Status);
}

#ifdef RESTRICTED_TOKEN
//+-------------------------------------------------------------------------
//
//  Function:   KerbCaptureTokenRestrictions
//
//  Synopsis:   Captures the restrictions of a restricted token
//
//  Effects:
//
//  Arguments:  TokenHandle - token handle open for TOKEN_QUERY access
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCaptureTokenRestrictions(
    IN HANDLE TokenHandle,
    OUT PKERB_AUTHORIZATION_DATA Restrictions
    )
{
    PTOKEN_GROUPS Groups = NULL;
    PTOKEN_GROUPS RestrictedSids = NULL;
    PTOKEN_PRIVILEGES Privileges = NULL;
    PTOKEN_PRIVILEGES DeletePrivileges = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BufferSize = 0;
    ULONG Index,Index2,LastIndex;
    KERB_TOKEN_RESTRICTIONS TokenRestrictions = {0};

    Status = KerbGetTokenInformation(
                    TokenHandle,
                    TokenRestrictedSids,
                    (PVOID *) &RestrictedSids
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbGetTokenInformation(
                    TokenHandle,
                    TokenGroups,
                    (PVOID *) &Groups
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbGetTokenInformation(
                    TokenHandle,
                    TokenPrivileges,
                    (PVOID *) &Privileges
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now build the list of just the restricted privileges & groups
    //

    //
    // First, find what groups are restricted.
    //

    LastIndex = 0;
    for (Index = 0; Index < Groups->GroupCount ; Index++ )
    {
        if ((Groups->Groups[Index].Attributes & SE_GROUP_USE_FOR_DENY_ONLY) != 0)
        {
            if (LastIndex != Index)
            {
                Groups->Groups[LastIndex].Sid = Groups->Groups[Index].Sid;
                Groups->Groups[LastIndex].Attributes = 0;
            }
            LastIndex++;
        }
    }
    Groups->GroupCount = LastIndex;
    if (LastIndex != 0)
    {
        TokenRestrictions.GroupsToDisable = (PPAC_TOKEN_GROUPS) Groups;
        TokenRestrictions.Flags |= KERB_TOKEN_RESTRICTION_DISABLE_GROUPS;
    }

    //
    // Add the restricted sids
    //

    if (RestrictedSids->GroupCount != 0)
    {
        for (Index = 0; Index < RestrictedSids->GroupCount ; Index++ )
        {
            RestrictedSids->Groups[Index].Attributes = 0;
        }
        TokenRestrictions.RestrictedSids = (PPAC_TOKEN_GROUPS) RestrictedSids;
        TokenRestrictions.Flags |= KERB_TOKEN_RESTRICTION_RESTRICT_SIDS;
    }

    //
    // Now make a list of all the privileges that _aren't_ enabled
    //

    DeletePrivileges = (PTOKEN_PRIVILEGES) KerbAllocate(
                            sizeof(TOKEN_PRIVILEGES) +
                            sizeof(LUID_AND_ATTRIBUTES) *
                                (1 + SE_MAX_WELL_KNOWN_PRIVILEGE - SE_MIN_WELL_KNOWN_PRIVILEGE)
                            );
    if (DeletePrivileges == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    DeletePrivileges->PrivilegeCount = 0;
    //
    // Find out what privileges haven't been enabled
    //

    LastIndex = 0;
    for (Index = SE_MIN_WELL_KNOWN_PRIVILEGE; Index <= SE_MAX_WELL_KNOWN_PRIVILEGE ; Index++ )
    {
        LUID TempLuid;
        BOOLEAN Found = FALSE;
        TempLuid = RtlConvertUlongToLuid(Index);
        for (Index2 = 0; Index2 < Privileges->PrivilegeCount ; Index2++ )
        {
            if (RtlEqualLuid(&Privileges->Privileges[Index2].Luid,&TempLuid) &&
                ((Privileges->Privileges[Index2].Attributes & SE_PRIVILEGE_ENABLED) != 0))
            {
                Found = TRUE;
                break;
            }
        }
        if (!Found)
        {
            DeletePrivileges->Privileges[LastIndex].Luid = TempLuid;
            DeletePrivileges->Privileges[LastIndex].Attributes = 0;
            LastIndex++;
        }
    }
    DeletePrivileges->PrivilegeCount = LastIndex;
    if (LastIndex != 0)
    {
        TokenRestrictions.PrivilegesToDelete = (PPAC_TOKEN_PRIVILEGES) DeletePrivileges;
        TokenRestrictions.Flags |= KERB_TOKEN_RESTRICTION_DELETE_PRIVS;
    }

    Restrictions->value.auth_data_type = KERB_AUTH_DATA_TOKEN_RESTRICTIONS;
    Status = PAC_EncodeTokenRestrictions(
                &TokenRestrictions,
                &Restrictions->value.auth_data.value,
                &Restrictions->value.auth_data.length
                );

Cleanup:
    if (Groups != NULL)
    {
        KerbFree(Groups);
    }
    if (RestrictedSids != NULL)
    {
        KerbFree(RestrictedSids);
    }
    if (Privileges != NULL)
    {
        KerbFree(Privileges);
    }
    if (DeletePrivileges != NULL)
    {
        KerbFree(DeletePrivileges);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAddRestrictionsToCredential
//
//  Synopsis:   Captures client'st token restrictions and sticks them in
//              the credential
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbAddRestrictionsToCredential(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA AuthData = NULL;
    BOOLEAN CrossRealm;
    PKERB_TICKET_CACHE_ENTRY ExistingTgt = NULL;
    HANDLE ClientToken = NULL;
    PKERB_INTERNAL_NAME ServiceName = NULL;
    UNICODE_STRING ServiceRealm = NULL_UNICODE_STRING;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    BOOLEAN TicketCacheLocked = FALSE;
    PKERB_TICKET_CACHE_ENTRY NewTicket = NULL;
    ULONG CacheFlags = 0;
    BOOLEAN UseSuppliedCreds = FALSE;

    //
    // Capture the existing TGT
    //

    Status = LsaFunctions->ImpersonateClient();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_QUERY,
                TRUE,                   // open as self
                &ClientToken
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    RevertToSelf();

    //
    // Capture the restrictions for this token
    //

    AuthData = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));
    if (AuthData == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Status = KerbCaptureTokenRestrictions(
                ClientToken,
                AuthData
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to capture token restrictions: 0x%x\n",Status));
        goto Cleanup;
    }

    KerbWriteLockLogonSessions(LogonSession);
    Credential->AuthData = AuthData;

    //
    // Turn off tgt avail to force us to get a new tgt
    //

    Credential->CredentialFlags &= ~KERB_CRED_TGT_AVAIL;
    AuthData = NULL;
    KerbUnlockLogonSessions(LogonSession);

Cleanup:
    if (AuthData != NULL)
    {
        if (AuthData->value.auth_data.value != NULL)
        {
            MIDL_user_free(AuthData->value.auth_data.value);
        }
        MIDL_user_free(AuthData);
    }
    if (ClientToken != NULL)
    {
        NtClose(ClientToken);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildTokenRestrictionAuthData
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildEncryptedAuthData(
    OUT PKERB_ENCRYPTED_DATA EncryptedAuthData,
    IN PKERB_TICKET_CACHE_ENTRY Ticket,
    IN PKERB_AUTHORIZATION_DATA PlainAuthData
    )
{
    KERBERR KerbErr;
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_MESSAGE_BUFFER PackedAuthData = {0};


    KerbErr = KerbPackData(
                &PlainAuthData,
                PKERB_AUTHORIZATION_DATA_LIST_PDU,
                &PackedAuthData.BufferSize,
                &PackedAuthData.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    KerbReadLockTicketCache();

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                Ticket->SessionKey.keytype,
                PackedAuthData.BufferSize,
                &EncryptedAuthData->cipher_text.length,
                &EncryptedAuthData->cipher_text.value
                );
    if (KERB_SUCCESS(KerbErr))
    {
        KerbErr = KerbEncryptDataEx(
                    EncryptedAuthData,
                    PackedAuthData.BufferSize,
                    PackedAuthData.Buffer,
                    Ticket->SessionKey.keytype,
                    KERB_NON_KERB_SALT,
                    &Ticket->SessionKey
                    );
    }
    KerbUnlockTicketCache();
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

Cleanup:
    if (PackedAuthData.Buffer != NULL)
    {
        MIDL_user_free(PackedAuthData.Buffer);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetRestrictedTgtForCredential
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetRestrictedTgtForCredential(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA AuthData = NULL;
    BOOLEAN CrossRealm;
    PKERB_TICKET_CACHE_ENTRY ExistingTgt = NULL;
    PKERB_INTERNAL_NAME ServiceName = NULL;
    UNICODE_STRING ServiceRealm = NULL_UNICODE_STRING;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    BOOLEAN TicketCacheLocked = FALSE;
    PKERB_TICKET_CACHE_ENTRY NewTicket = NULL;
    ULONG CacheFlags = 0, RetryFlags = 0;
    BOOLEAN UseSuppliedCreds = FALSE;

    //
    // First get an old TGT
    //

    KerbReadLockLogonSessions(LogonSession);

    if (Credential->SuppliedCredentials == NULL)
    {
        ULONG Flags;

        //
        // We don't have supplied creds, but we need them, so copy
        // from the logon session.
        //

        Status = KerbCaptureSuppliedCreds(
                    LogonSession,
                    NULL,                       // no auth data
                    NULL,                       // no principal name
                    &Credential->SuppliedCredentials,
                    &Flags
                    );

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to capture dummy supplied creds: 0x%x\n",Status));
            KerbUnlockLogonSessions(LogonSession);
            goto Cleanup;
        }
        AuthData = Credential->AuthData;
    }
    else
    {
        UseSuppliedCreds = FALSE;
    }

    DsysAssert(Credential->SuppliedCredentials != NULL);

    Status = KerbGetTgtForService(
                LogonSession,
                (UseSuppliedCreds) ? Credential : NULL,
                NULL,
                NULL, // no SuppRealm
                &Credential->SuppliedCredentials->DomainName,
                &ExistingTgt,
                &CrossRealm
                );
    KerbUnlockLogonSessions(LogonSession);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Now get a new TGT with this ticket
    //

    //
    // Copy the names out of the input structures so we can
    // unlock the structures while going over the network.
    //

    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // If the renew time is not much bigger than the end time, don't bother
    // renewing
    //


    Status = KerbDuplicateString(
                &ServiceRealm,
                &ExistingTgt->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = KerbDuplicateKdcName(
                &ServiceName,
                ExistingTgt->ServiceName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    CacheFlags = ExistingTgt->CacheFlags;

    KerbUnlockTicketCache();

    TicketCacheLocked = FALSE;

    Status = KerbGetTgsTicket(
                &ServiceRealm,
                ExistingTgt,
                ServiceName,
                FALSE,
                0,                              // no ticket optiosn
                0,                              // no encryption type
                AuthData,                       // no authorization data
                NULL,                           // no tgt reply
                &KdcReply,
                &KdcReplyBody,
                &RetryFlags
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to get restricted tgs ticket: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Now we want to purge the existing ticket cache and add this ticket
    //

    KerbPurgeTicketCache(
        &Credential->SuppliedCredentials->AuthenticationTicketCache
        );
    KerbPurgeTicketCache(
        &Credential->SuppliedCredentials->ServerTicketCache
        );

    KerbReadLockLogonSessions(LogonSession);

    Status = KerbCacheTicket(
                &Credential->SuppliedCredentials->AuthenticationTicketCache,
                KdcReply,
                KdcReplyBody,
                ServiceName,
                &ServiceRealm,
                CacheFlags,
                TRUE,                   // link this in
                &NewTicket
                );

    KerbUnlockLogonSessions(LogonSession);

Cleanup:
    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }
    if (ExistingTgt != NULL)
    {
        KerbDereferenceTicketCacheEntry(ExistingTgt);
    }
    if (NewTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(NewTicket);
    }
    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KerbFreeKdcName(&ServiceName);
    KerbFreeString(&ServiceRealm);
    return(Status);
}
#endif
#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbtrace.h ===
#ifndef _KERBTRACE_H
#define _KERBTRACE_H
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    kerbtrace.h

Abstract:

    Defines appropriate stuff for event tracing a/k/a wmi tracing a/k/a software tracing 

Author:

    15 June 2000   t-ryanj      (* largely stolen from kdctrace.h *)
    
Revision History:

--*/

//
//
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
}
#endif // __cplusplus

EXTERN_C BOOLEAN          KerbEventTraceFlag;
EXTERN_C TRACEHANDLE      KerbTraceRegistrationHandle;
EXTERN_C TRACEHANDLE      KerbTraceLoggerHandle;

EXTERN_C
ULONG
KerbInitializeTrace();


// be careful with INSERT_ULONG_INTO_MOF; it evaluates its arguments more than once 
#define INSERT_ULONG_INTO_MOF( x, MOF, Start )       \
         (MOF)[(Start)].DataPtr   = (ULONGLONG)&(x); \
	 (MOF)[(Start)].Length    = sizeof(ULONG);
	 
// be careful with INSERT_UNICODE_STRING_INTO_MOF; it evaluates its arguments more than once
#define INSERT_UNICODE_STRING_INTO_MOF( USTRING, MOF, Start )       \
         (MOF)[(Start)].DataPtr   = (ULONGLONG)&((USTRING).Length); \
	 (MOF)[(Start)].Length    = sizeof      ((USTRING).Length); \
	 (MOF)[(Start)+1].DataPtr = (ULONGLONG)  (USTRING).Buffer;  \
	 (MOF)[(Start)+1].Length  =              (USTRING).Length;
	 
typedef struct _KERB_LOGON_INFO 
// Start {No Data}, End {Status, LogonType, (UserName), (LogonDomain)}
{
    EVENT_TRACE_HEADER EventTrace;       
    MOF_FIELD MofData[7];
} KERB_LOGON_INFO, *PKERB_LOGON_INFO;

typedef struct _KERB_INITSC_INFO
// Start {No Data}, End {Status, CredSource, DomainName, UserName, Target, (KerbExtError), (Klininfo)}
{
    EVENT_TRACE_HEADER EventTrace;
    MOF_FIELD MofData[11];
} KERB_INITSC_INFO, *PKERB_INITSC_INFO;

typedef struct _KERB_ACCEPTSC_INFO
// Start {No Data}, End {Status, CredSource, DomainName, UserName, Target}
{
    EVENT_TRACE_HEADER EventTrace;    
    MOF_FIELD MofData[9];
} KERB_ACCEPTSC_INFO, *PKERB_ACCEPTSC_INFO;

typedef struct _KERB_SETPASS_INFO
// Start {No Data}, End {Status, AccountName, AccountRealm, (ClientName), (ClientRealm), (KdcAddress)}
{
    EVENT_TRACE_HEADER EventTrace;
    MOF_FIELD MofData[11];
} KERB_SETPASS_INFO, *PKERB_SETPASS_INFO;

typedef struct _KERB_CHANGEPASS_INFO
// Start {No Data}, End {Status, AccountName, AccountRealm}
{
    EVENT_TRACE_HEADER EventTrace;
    MOF_FIELD MofData[5];
} KERB_CHANGEPASS_INFO, *PKERB_CHANGEPASS_INFO;

// Control Guid
DEFINE_GUID ( /* bba3add2-c229-4cdb-ae2b-57eb6966b0c4 */
    KerbControlGuid,
    0xbba3add2,
    0xc229,
    0x4cdb,
    0xae, 0x2b, 0x57, 0xeb, 0x69, 0x66, 0xb0, 0xc4
  );


// LogonUser Guid
DEFINE_GUID ( /* 8a3b8d86-db1e-47a9-9264-146e097b3c64 */
    KerbLogonGuid,
    0x8a3b8d86,
    0xdb1e,
    0x47a9,
    0x92, 0x64, 0x14, 0x6e, 0x09, 0x7b, 0x3c, 0x64
  );

// InitializeSecurityContext Guid
DEFINE_GUID ( /* 52e82f1a-7cd4-47ed-b5e5-fde7bf64cea6 */
    KerbInitSCGuid,
    0x52e82f1a,
    0x7cd4,
    0x47ed,
    0xb5, 0xe5, 0xfd, 0xe7, 0xbf, 0x64, 0xce, 0xa6
  );

// AcceptSecurityContext Guid
DEFINE_GUID ( /* 94acefe3-9e56-49e3-9895-7240a231c371 */
    KerbAcceptSCGuid,
    0x94acefe3,
    0x9e56,
    0x49e3,
    0x98, 0x95, 0x72, 0x40, 0xa2, 0x31, 0xc3, 0x71
  );

DEFINE_GUID ( /* 94c79108-b23b-4418-9b7f-e6d75a3a0ab2 */
    KerbSetPassGuid,
    0x94c79108,
    0xb23b,
    0x4418,
    0x9b, 0x7f, 0xe6, 0xd7, 0x5a, 0x3a, 0x0a, 0xb2
  );

DEFINE_GUID ( /* c55e606b-334a-488b-b907-384abaa97b04 */
    KerbChangePassGuid,
    0xc55e606b,
    0x334a,
    0x488b,
    0xb9, 0x07, 0x38, 0x4a, 0xba, 0xa9, 0x7b, 0x04
  );

#endif /* _KERBTRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbwow.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 2000
//
// File:        kerbwow.h
//
// Contents:    prototypes for 32-64 bit interop for the Kerberos package
//
//
// History:     25-Oct-2000     JSchwart        Created
//
//------------------------------------------------------------------------

#ifndef __KERBWOW_H__
#define __KERBWOW_H__

#ifdef _WIN64

//
// WOW versions of native structures
//

typedef UNICODE_STRING32     UNICODE_STRING_WOW64;
typedef UNICODE_STRING_WOW64 *PUNICODE_STRING_WOW64;

typedef struct _SECHANDLE_WOW64
{
    ULONG dwLower;
    ULONG dwUpper;
}
SECHANDLE_WOW64, *PSECHANDLE_WOW64;


typedef struct _KERB_TICKET_CACHE_INFO_WOW64
{
    UNICODE_STRING_WOW64 ServerName;
    UNICODE_STRING_WOW64 RealmName;
    LARGE_INTEGER        StartTime;
    LARGE_INTEGER        EndTime;
    LARGE_INTEGER        RenewTime;
    LONG                 EncryptionType;
    ULONG                TicketFlags;
}
KERB_TICKET_CACHE_INFO_WOW64, *PKERB_TICKET_CACHE_INFO_WOW64;


typedef struct _KERB_TICKET_CACHE_INFO_EX_WOW64
{
    UNICODE_STRING_WOW64 ClientName;
    UNICODE_STRING_WOW64 ClientRealm;
    UNICODE_STRING_WOW64 ServerName;
    UNICODE_STRING_WOW64 ServerRealm;
    LARGE_INTEGER        StartTime;
    LARGE_INTEGER        EndTime;
    LARGE_INTEGER        RenewTime;
    LONG                 EncryptionType;
    ULONG                TicketFlags;
}
KERB_TICKET_CACHE_INFO_EX_WOW64, *PKERB_TICKET_CACHE_INFO_EX_WOW64;

typedef struct _KERB_CHANGE_MACH_PWD_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING_WOW64       NewPassword;
    UNICODE_STRING_WOW64       OldPassword;
}
KERB_CHANGE_MACH_PWD_REQUEST_WOW64, *PKERB_CHANGE_MACH_PWD_REQUEST_WOW64;


typedef struct _KERB_CHANGEPASSWORD_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING_WOW64       DomainName;
    UNICODE_STRING_WOW64       AccountName;
    UNICODE_STRING_WOW64       OldPassword;
    UNICODE_STRING_WOW64       NewPassword;
    BOOLEAN                    Impersonating;
}
KERB_CHANGEPASSWORD_REQUEST_WOW64, *PKERB_CHANGEPASSWORD_REQUEST_WOW64;


typedef struct _KERB_PURGE_TKT_CACHE_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID                       LogonId;
    UNICODE_STRING_WOW64       ServerName;
    UNICODE_STRING_WOW64       RealmName;
}
KERB_PURGE_TKT_CACHE_REQUEST_WOW64, *PKERB_PURGE_TKT_CACHE_REQUEST_WOW64;


typedef struct _KERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
    ULONG Flags;
    KERB_TICKET_CACHE_INFO_EX_WOW64 TicketTemplate;
}
KERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64, *PKERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64;


typedef struct _KERB_QUERY_TKT_CACHE_RESPONSE_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE   MessageType;
    ULONG                        CountOfTickets;
    KERB_TICKET_CACHE_INFO_WOW64 Tickets[ANYSIZE_ARRAY];
}
KERB_QUERY_TKT_CACHE_RESPONSE_WOW64, *PKERB_QUERY_TKT_CACHE_RESPONSE_WOW64;


typedef struct _KERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE      MessageType;
    ULONG                           CountOfTickets;
    KERB_TICKET_CACHE_INFO_EX_WOW64 Tickets[ANYSIZE_ARRAY];
}
KERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64, *PKERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64;


typedef struct _KERB_SETPASSWORD_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID                       LogonId;
    SECHANDLE_WOW64            CredentialsHandle;
    ULONG                      Flags;
    UNICODE_STRING_WOW64       DomainName;
    UNICODE_STRING_WOW64       AccountName;
    UNICODE_STRING_WOW64       Password;
}
KERB_SETPASSWORD_REQUEST_WOW64, *PKERB_SETPASSWORD_REQUEST_WOW64;


typedef struct _KERB_SETPASSWORD_EX_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID                       LogonId;
    SECHANDLE_WOW64            CredentialsHandle;
    ULONG                      Flags;
    UNICODE_STRING_WOW64       AccountRealm;
    UNICODE_STRING_WOW64       AccountName;
    UNICODE_STRING_WOW64       Password;
    UNICODE_STRING_WOW64       ClientRealm;
    UNICODE_STRING_WOW64       ClientName;
    BOOLEAN                    Impersonating;
    UNICODE_STRING_WOW64       KdcAddress;
    ULONG                      KdcAddressType;
}
KERB_SETPASSWORD_EX_REQUEST_WOW64, *PKERB_SETPASSWORD_EX_REQUEST_WOW64;


typedef struct _KERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING_WOW64 RealmName;
    UNICODE_STRING_WOW64 KdcAddress;
    ULONG AddressType;                  //dsgetdc.h DS_NETBIOS_ADDRESS||DS_INET_ADDRESS
}
KERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64, *PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64;

//
// WOW helper macros
//

#define UNICODE_STRING_FROM_WOW_STRING(pUnicodeString, pWOWString)                       \
            (pUnicodeString)->Length        = (pWOWString)->Length;                      \
            (pUnicodeString)->MaximumLength = (pWOWString)->MaximumLength;               \
            (pUnicodeString)->Buffer        = (LPWSTR) UlongToPtr((pWOWString)->Buffer);


//
// WOW helper functions
//

NTSTATUS
KerbConvertWOWLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    IN     KERB_LOGON_SUBMIT_TYPE  MessageType,
    OUT    PVOID                   *ppTempSubmitBuffer
    );

NTSTATUS
KerbAllocateInteractiveWOWBuffer(
    OUT PKERB_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET LogonTicket,
    IN OPTIONAL PKERB_INTERACTIVE_LOGON KerbLogonInfo,
    IN  PUCHAR *PClientBufferBase,
    IN  BOOLEAN BuildSmartCardProfile,
    IN  BOOLEAN BuildTicketProfile
    );

NTSTATUS
KerbPackExternalWOWTicket(
    PKERB_TICKET_CACHE_ENTRY  pCacheEntry,
    PKERB_MESSAGE_BUFFER      pEncodedTicket,
    PKERB_EXTERNAL_TICKET     *pTicketResponse,
    PBYTE                     *pClientTicketResponse,
    PULONG                    pTicketSize
    );

VOID
KerbPutWOWString(
    IN PUNICODE_STRING        InputString,
    OUT PUNICODE_STRING_WOW64 OutputString,
    IN LONG_PTR               Offset,
    IN OUT PBYTE              * Where
    );

VOID
KerbPutKdcNameAsWOWString(
    IN PKERB_INTERNAL_NAME    InputName,
    OUT PUNICODE_STRING_WOW64 OutputName,
    IN LONG_PTR               Offset,
    IN OUT PBYTE              * Where
    );


#endif  // _WIN64
#endif  // __KERBWOW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbutil.h
//
// Contents:    prototypes for Kerberos utility functions
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERBUTIL_H__
#define __KERBUTIL_H__


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous macros                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// RELOCATE_ONE - Relocate a single pointer in a client buffer.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = (((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase));   \
        if ( Offset >= SubmitBufferSize ||                                  \
             Offset + (_q)->Length > SubmitBufferSize ||                    \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length ;                                \
    }

//
// NULL_RELOCATE_ONE - Relocate a single (possibly NULL) pointer in a client
//  buffer.
//
// This macro special cases a NULL pointer then calls RELOCATE_ONE.  Hence
// it has all the restrictions of RELOCATE_ONE.
//
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define NULL_RELOCATE_ONE( _q ) \
    {                                                                       \
        if ( (_q)->Buffer == NULL ) {                                       \
            if ( (_q)->Length != 0 ) {                                      \
                Status = STATUS_INVALID_PARAMETER;                          \
                goto Cleanup;                                               \
            }                                                               \
        } else if ( (_q)->Length == 0 ) {                                   \
            (_q)->Buffer = NULL;                                            \
        } else {                                                            \
            RELOCATE_ONE( _q );                                             \
        }                                                                   \
    }


//
// RELOCATE_ONE_ENCODED - Relocate a unicode string pointer in a client
//   buffer.  The upper byte of the length field may be an encryption seed
//   and should not be used for error checking.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length & 0x00ff.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE_ENCODED( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = ((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase);     \
        if ( Offset > SubmitBufferSize ||                                  \
             Offset + ((_q)->Length & 0x00ff) > SubmitBufferSize ||         \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length & 0x00ff;                                \
    }


//
//  Following macro is used to initialize UNICODE strings
//

#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }
#define NULL_UNICODE_STRING {0 , 0, NULL }
#define EMPTY_UNICODE_STRING(s) { (s)->Buffer = NULL; (s)->Length = 0; (s)->MaximumLength = 0; }



///VOID
// KerbSetTime(
//     IN OUT PTimeStamp TimeStamp,
//     IN LONGLONG Time
//     )


#ifndef WIN32_CHICAGO
#define KerbSetTime(_d_, _s_) (_d_)->QuadPart = (_s_)
#else  // WIN32_CHICAGO
#define KerbSetTime(_d_, _s_) *(_d_) = (_s_)
#endif // WIN32_CHICAGO

// TimeStamp
// KerbGetTime(
//     IN TimeStamp Time
//     )

#ifndef WIN32_CHICAGO
#define KerbGetTime(_x_) ((_x_).QuadPart)
#else  // WIN32_CHICAGO
#define KerbGetTime(_x_) (_x_)
#endif // WIN32_CHICAGO

// VOID
// KerbSetTimeInMinutes(
//    IN OUT PTimeStamp Time,
//    IN LONG TimeInMinutes
//    )

#ifndef WIN32_CHICAGO
#define KerbSetTimeInMinutes(_x_, _m_) (_x_)->QuadPart = (LONGLONG) 10000000 * 60 * (_m_)
#else  // WIN32_CHICAGO
#define KerbSetTimeInMinutes(_x_, _m_) *(_x_) = (LONGLONG) 10000000 * 60 * (_m_)
#endif // WIN32_CHICAGO

NTSTATUS
KerbSplitFullServiceName(
    IN PUNICODE_STRING FullServiceName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING ServiceName
    );

NTSTATUS
KerbSplitEmailName(
    IN PUNICODE_STRING EmailName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING ServiceName
    );

ULONG
KerbAllocateNonce(
    VOID
    );

#ifndef WIN32_CHICAGO
PSID
KerbMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );
#endif // WIN32_CHICAGO

#ifdef notdef
VOID
KerbFree(
    IN PVOID Buffer
    );
#endif

PVOID
KerbAllocate(
    IN ULONG BufferSize
    );

BOOLEAN
KerbRunningPersonal(
    VOID
    );

#ifndef WIN32_CHICAGO
NTSTATUS
KerbWaitForKdc(
    IN ULONG Timeout
    );

NTSTATUS
KerbWaitForService(
    IN LPWSTR ServiceName,
    IN OPTIONAL LPWSTR ServiceEvent,
    IN ULONG Timeout
    );
#endif // WIN32_CHICAGO

ULONG
KerbMapContextFlags(
    IN ULONG ContextFlags
    );

BOOLEAN
KerbIsIpAddress(
    IN PUNICODE_STRING TargetName
    );

VOID
KerbHidePassword(
    IN OUT PUNICODE_STRING Password
    );

VOID
KerbRevealPassword(
    IN OUT PUNICODE_STRING Password
    );

NTSTATUS
KerbDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    );


#ifdef notdef
// use this if we ever need to map errors in kerb to something else.
NTSTATUS
KerbMapKerbNtStatusToNtStatus(
    IN NTSTATUS Status
    );
#else
#ifndef WIN32_CHICAGO
//#if DBG
//#define KerbMapKerbNtStatusToNtStatus(x) (RtlCheckForOrphanedCriticalSections(NtCurrentThread()),x)
//#else
#define KerbMapKerbNtStatusToNtStatus(x) (x)
//#endif
#else // WIN32_CHICAGO
#define KerbMapKerbNtStatusToNtStatus(x) (x)
#endif
#endif

NTSTATUS
KerbExtractDomainName(
    OUT PUNICODE_STRING DomainName,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN PUNICODE_STRING TicketSourceDomain
    );

VOID
KerbUtcTimeToLocalTime(
    OUT PTimeStamp LocalTime,
    IN PTimeStamp SystemTime
    );

ULONG
KerbConvertKdcOptionsToTicketFlags(
    IN ULONG KdcOptions
    );

NTSTATUS
KerbUnpackErrorMethodData(
   IN PKERB_ERROR  ErrorMessage,
   IN OUT OPTIONAL PKERB_ERROR_METHOD_DATA * ppErrorData
   );

NTSTATUS
KerbBuildHostAddresses(
    IN BOOLEAN IncludeIpAddresses,
    IN BOOLEAN IncludeNetbiosAddresses,
    OUT PKERB_HOST_ADDRESSES * HostAddresses
    );

NTSTATUS
KerbReceiveErrorMessage(
    IN PBYTE ErrorMessage,
    IN ULONG ErrorMessageSize,
    IN PKERB_CONTEXT Context,
    OUT PKERB_ERROR * DecodedErrorMessage,
    OUT PKERB_ERROR_METHOD_DATA * ErrorData
    );

NTSTATUS
KerbBuildGssErrorMessage(
    IN KERBERR Error,
    IN PBYTE ErrorData,
    IN ULONG ErrorDataSize,
    IN PKERB_CONTEXT Context,
    OUT PULONG ErrorMessageSize,
    OUT PBYTE * ErrorMessage
    );


NTSTATUS
KerbGetDnsHostName(
    OUT PUNICODE_STRING DnsHostName
    );

NTSTATUS
KerbSetComputerName(
    VOID
    );

NTSTATUS
KerbSetDomainName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING DnsDomainName,
    IN PSID DomainSid,
    IN GUID DomainGuid
    );


BOOLEAN
KerbIsThisOurDomain(
    IN PUNICODE_STRING DomainName
    );

NTSTATUS
KerbGetOurDomainName(
    OUT PUNICODE_STRING DomainName
    );

KERBEROS_MACHINE_ROLE
KerbGetGlobalRole(
    VOID
    );


#ifndef WIN32_CHICAGO
NTSTATUS
KerbLoadKdc(
    VOID
    );

NTSTATUS
KerbRegisterForDomainChange(
    VOID
    );

VOID
KerbUnregisterForDomainChange(
    VOID
    );

NTSTATUS
KerbUpdateGlobalAddresses(
    IN PSOCKET_ADDRESS NewAddresses,
    IN ULONG NewAddressCount
    );

ULONG
KerbUpdateMachineSidWorker(
    PVOID Parameter
    );


VOID
KerbWaitGetMachineSid(
    VOID
    );

NTSTATUS
KerbCaptureTokenRestrictions(
    IN HANDLE TokenHandle,
    OUT PKERB_AUTHORIZATION_DATA Restrictions
    );

NTSTATUS
KerbBuildEncryptedAuthData(
    OUT PKERB_ENCRYPTED_DATA EncryptedAuthData,
    IN PKERB_TICKET_CACHE_ENTRY Ticket,
    IN PKERB_AUTHORIZATION_DATA PlainAuthData
    );

NTSTATUS
KerbGetRestrictedTgtForCredential(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential
    );

NTSTATUS
KerbAddRestrictionsToCredential(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential
    );

BOOLEAN
KerbRunningServer(
    VOID
    );

#endif // WIN32_CHICAGO

#endif // __KERBUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\kerbtrace.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    kerbtrace.cxx

Abstract:

    Set up event tracing for Kerberos

Author:

    15 June 2000  t-ryanj     (* largely stolen from kdctrace.cxx *)

Revision History:

--*/


#include <kerb.hxx>
#include <wmistr.h>
#define INITGUID
#include "kerbdbg.h"

#define RESOURCE_NAME       __TEXT("MOF_RESOURCE")  // kerberos.mof => kerberos.bmf => MOF_RESOURCE
#define IMAGE_PATH          __TEXT("kerberos.dll")

BOOLEAN          KerbEventTraceFlag = FALSE;
TRACEHANDLE      KerbTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE      KerbTraceLoggerHandle = (TRACEHANDLE) 0;


ULONG
KerbTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

TRACE_GUID_REGISTRATION KerbTraceGuids[] =
{
    { &KerbLogonGuid,      NULL },
    { &KerbInitSCGuid,     NULL },
    { &KerbAcceptSCGuid,   NULL },
    { &KerbSetPassGuid,    NULL },
    { &KerbChangePassGuid, NULL }
};

#define KerbGuidCount (sizeof(KerbTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

ULONG
KerbInitializeTrace(
    VOID
    )
{
    ULONG status;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }

    status = RegisterTraceGuids(
                KerbTraceControlCallback,
                NULL,
                &KerbControlGuid,
                KerbGuidCount,
                KerbTraceGuids,
                (LPCWSTR) FileName,
                (LPCWSTR) RESOURCE_NAME,
                &KerbTraceRegistrationHandle);


    if (status != ERROR_SUCCESS) {
        DebugLog((DEB_ERROR,"Trace registration failed with %x\n",status));
    }
    return status;
}


ULONG
KerbTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            KerbTraceLoggerHandle =
                GetTraceLoggerHandle(Buffer);
            KerbEventTraceFlag = TRUE;
            RetSize = 0;
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            KerbEventTraceFlag = FALSE;
            RetSize = 0;
            KerbTraceLoggerHandle = (TRACEHANDLE) 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\krbtoken.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        token.cxx
//
// Contents:    Routines building access tokens
//
//
// History:     1-May-1996      Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------
#include <kerb.hxx>
#include <kerbp.h>
#include <pac.hxx>

#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

DWORD
KerbCopyDomainRelativeSid(
    OUT PSID TargetSid,
    IN PSID  DomainId,
    IN ULONG RelativeId
    );

//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyAuthData
//
//  Synopsis:   Verifies that we should not be rejecting the auth data
//              Accepted auth data is anything we know about and even values
//              Odd values and unknown auth data is rejected
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbVerifyAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    PKERB_AUTHORIZATION_DATA TempData = AuthData;

    while (TempData != NULL)
    {
        if ((TempData->value.auth_data_type & 1) != 0)
        {

            switch(TempData->value.auth_data_type)
            {
            case KERB_AUTH_OSF_DCE:
            case KERB_AUTH_SESAME:
            case KERB_AUTH_DATA_PAC:
            case -KERB_AUTH_DATA_PAC:           // obsolete pac id
            case KERB_AUTH_PROXY_ANNOTATION:
            case KERB_AUTH_DATA_IF_RELEVANT:
            case KERB_AUTH_DATA_KDC_ISSUED:
#ifdef RESTRICTED_TOKEN
            case KERB_AUTH_DATA_TOKEN_RESTRICTIONS:
#endif
                break;
            default:
                D_DebugLog((DEB_ERROR,"Unknown auth type: %d\n",TempData->value.auth_data_type));
                return(FALSE);

            }
        }
        TempData = TempData->next;
    }
    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbApplyTokenRestrictions
//
//  Synopsis:   Applies restrictions to a fresh token
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbApplyTokenRestrictions(
    IN PKERB_AUTHORIZATION_DATA AuthData,
    IN OUT PHANDLE TokenHandle
    )
{

    PKERB_TOKEN_RESTRICTIONS Restrictions = NULL;
    HANDLE RestrictedToken = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = PAC_DecodeTokenRestrictions(
                AuthData->value.auth_data.value,
                AuthData->value.auth_data.length,
                &Restrictions
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to decode token restrictions: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // If there are any restrictions, apply them here.
    //

    if (Restrictions->Flags != 0)
    {
        Status = NtFilterToken(
                    *TokenHandle,
                    0,                  // no flags,
                    (Restrictions->Flags & KERB_TOKEN_RESTRICTION_DISABLE_GROUPS) != 0 ? (PTOKEN_GROUPS) Restrictions->GroupsToDisable : NULL,
                    (Restrictions->Flags & KERB_TOKEN_RESTRICTION_DELETE_PRIVS) != 0 ? (PTOKEN_PRIVILEGES) Restrictions->PrivilegesToDelete : NULL,
                    (Restrictions->Flags & KERB_TOKEN_RESTRICTION_RESTRICT_SIDS) != 0 ? (PTOKEN_GROUPS) Restrictions->RestrictedSids : NULL,
                    &RestrictedToken
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to filter token: 0x%x\n",Status));
            goto Cleanup;
        }
        NtClose(*TokenHandle);
        *TokenHandle = RestrictedToken;
        RestrictedToken = NULL;

    }

Cleanup:
    if (Restrictions != NULL)
    {
        MIDL_user_free(Restrictions);
    }
    if (RestrictedToken != NULL)
    {
        NtClose(RestrictedToken);
    }
    return(Status);
}
#ifdef RESTRICTED_TOKEN
//+-------------------------------------------------------------------------
//
//  Function:   KerbApplyAuthDataRestrictions
//
//  Synopsis:   Applies any restrictions from the auth data to the to token
//              and logon session.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbApplyAuthDataRestrictions(
    IN OUT PHANDLE TokenHandle,
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA TempData = AuthData;

    while (TempData != NULL)
    {
        if ((TempData->value.auth_data_type & 1) != 0)
        {

            switch(TempData->value.auth_data_type)
            {
            case KERB_AUTH_DATA_TOKEN_RESTRICTIONS:
                Status = KerbApplyTokenRestrictions(
                            TempData,
                            TokenHandle
                            );
                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR,"Failed to apply token restrictions: 0x%x\n",Status));
                    goto Cleanup;
                    break;
                }
            default:
                break;
            }
        }
        TempData = TempData->next;
    }
Cleanup:
    return(Status);
}
#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyPacSignature
//
//  Synopsis:   Verifies the server signature on a PAC and if necessary
//              calls the KDC to verify the KDC signature.
//
//  Effects:
//
//  Arguments:  Pac - an unmarshalled pac
//              EncryptionKey - Key used to decrypt the ticket & verify the pac
//
//
//  Requires:
//
//  Returns:
//
//  Notes:      No locks should be held while calling this function
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbVerifyPacSignature(
    IN PUNICODE_STRING ServiceDomain,
    IN PPACTYPE Pac,
    IN ULONG PacSize,
    IN PKERB_ENCRYPTION_KEY EncryptionKey,
    IN PKERB_ENCRYPTED_TICKET Ticket,
    IN BOOLEAN CheckKdcSignature,
    OUT PNETLOGON_VALIDATION_SAM_INFO3 * ValidationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus;
    PKERB_VERIFY_PAC_REQUEST VerifyRequest = NULL;
    PMSV1_0_PASSTHROUGH_REQUEST PassthroughRequest = NULL;
    PMSV1_0_PASSTHROUGH_RESPONSE PassthroughResponse = NULL;
    ULONG RequestSize;
    ULONG ResponseSize;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PPAC_SIGNATURE_DATA ServerSignature = NULL;
    PPAC_SIGNATURE_DATA PrivSvrSignature = NULL;
    PPAC_INFO_BUFFER ServerBuffer = NULL;
    PPAC_INFO_BUFFER PrivSvrBuffer = NULL;
    PPAC_INFO_BUFFER LogonInfo = NULL;
    PPAC_INFO_BUFFER ClientBuffer = NULL;
    PPAC_CLIENT_INFO ClientInfo = NULL;
    UCHAR LocalChecksum[20];
    UCHAR LocalServerChecksum[20];
    UCHAR LocalPrivSvrChecksum[20];
    SECPKG_CLIENT_INFO LsaClientInfo;
    ULONG SignatureSize;
    PUCHAR Where;
    UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING(TEXT(MSV1_0_PACKAGE_NAME));
    ULONG NameType;
    UNICODE_STRING ClientName = {0};

    *ValidationInfo = NULL;

    //
    // Get the various pieces we need out of the PAC - the logon information
    // and the two signatures.
    //

    LogonInfo = PAC_Find(
                    Pac,
                    PAC_LOGON_INFO,
                    NULL
                    );
    if (LogonInfo == NULL)
    {
        D_DebugLog((DEB_ERROR,"Failed to find logon info! %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ServerBuffer = PAC_Find(
                        Pac,
                        PAC_SERVER_CHECKSUM,
                        NULL
                        );

    PrivSvrBuffer = PAC_Find(
                        Pac,
                        PAC_PRIVSVR_CHECKSUM,
                        NULL
                        );

    if ((ServerBuffer == NULL) || (PrivSvrBuffer == NULL))
    {

        D_DebugLog((DEB_ERROR,"Pac found with no signature!\n"));
        return(STATUS_LOGON_FAILURE);
    }



    //
    // Now verify the server checksum. First compute the checksum
    // over the logon info.
    //

    ServerSignature = (PPAC_SIGNATURE_DATA) ServerBuffer->Data;
    if ((sizeof(*ServerSignature) > ServerBuffer->cbBufferSize) ||
        (PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize) > sizeof(LocalServerChecksum)))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;
    if ((sizeof(*PrivSvrSignature) > PrivSvrBuffer->cbBufferSize) ||
        (PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize) > sizeof(LocalPrivSvrChecksum)))

    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Copy out the signature so we can zero the signature fields before
    // checksumming
    //

    RtlCopyMemory(
        LocalServerChecksum,
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    RtlZeroMemory(
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    RtlCopyMemory(
        LocalPrivSvrChecksum,
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );
    RtlZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Now remarshal the PAC before checksumming.
    //

    if (!PAC_ReMarshal(Pac,PacSize))
    {
        DsysAssert(!"PAC_Remarhsal failed");
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Locate the checksum of the logon info & compute it.
    //

    Status = CDLocateCheckSum(
                ServerSignature->SignatureType,
                &Check
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (Check->CheckSumSize > sizeof(LocalChecksum)) {
        DsysAssert(Check->CheckSumSize > sizeof(LocalChecksum));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    LocalServerChecksum,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;

    }
    Check->Sum(
        CheckBuffer,
        PacSize,
        (PUCHAR) Pac
        );

    Check->Finalize(
        CheckBuffer,
        LocalChecksum
        );

    Check->Finish(&CheckBuffer);

    //
    // Now compare the local checksum to the supplied checksum.
    //

    if (Check->CheckSumSize != PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize))
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            LocalChecksum,
            LocalServerChecksum,
            Check->CheckSumSize
            ))
    {
        DebugLog((DEB_ERROR,"Checksum on the PAC does not match! %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Now unmarshal the PAC so that the caller will have it back the
    // way they started.
    //

    if (!PAC_UnMarshal(Pac,PacSize))
    {
        DsysAssert(!"PAC_UnMarshal failed");
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Check the client info, if present,
    //

    ClientBuffer = PAC_Find(
                    Pac,
                    PAC_CLIENT_INFO_TYPE,
                    NULL
                    );
    if (ClientBuffer != NULL)
    {
        TimeStamp ClientId;
        UNICODE_STRING PacClientName = {0};

        if (ClientBuffer->cbBufferSize < sizeof(PAC_CLIENT_INFO))
        {
            D_DebugLog((DEB_ERROR,"Clientinfo is too small: %d instead of %d. %ws, line %d\n",
                ClientBuffer->cbBufferSize, sizeof(PAC_CLIENT_INFO), THIS_FILE, __LINE__));
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
        ClientInfo = (PPAC_CLIENT_INFO) ClientBuffer->Data;
        if ((ClientInfo->NameLength - ANYSIZE_ARRAY * sizeof(WCHAR) + sizeof(PPAC_CLIENT_INFO))  > ClientBuffer->cbBufferSize)
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
        KerbConvertGeneralizedTimeToLargeInt(
            &ClientId,
            &Ticket->authtime,
            0                           // no usec
            );
        if (!RtlEqualMemory(
                &ClientId,
                &ClientInfo->ClientId,
                sizeof(TimeStamp)
                ))
        {
            D_DebugLog((DEB_ERROR,"Client IDs don't match. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
        //
        // Check the name now
        //

        PacClientName.Buffer = ClientInfo->Name;
        PacClientName.Length = PacClientName.MaximumLength = ClientInfo->NameLength;

        if (KERB_SUCCESS(KerbConvertPrincipalNameToString(
                            &ClientName,
                            &NameType,
                            &Ticket->client_name
                            )))
        {
            if (!RtlEqualUnicodeString(
                    &ClientName,
                    &PacClientName,
                    TRUE))
            {
                D_DebugLog((DEB_ERROR,"Client names don't match: %wZ vs %wZ. %ws, line %d\n",
                    &PacClientName, &ClientName, THIS_FILE, __LINE__ ));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


    }

    //
    // Unmarshall the logon info. We need to do this to get the logon domain
    // out to use for the pass-through.
    //


    Status = PAC_UnmarshallValidationInfo(
                ValidationInfo,
                LogonInfo->Data,
                LogonInfo->cbBufferSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If we don't need to check the KDC signature, bail now. This is for
    // tokens that can't be used for impersonation
    //

    if (!CheckKdcSignature)
    {
        goto Cleanup;

    }
    //
    // Now check to see if the client has TCB privilege. It it does, we
    // are done. Otherwise we need to call the KDC to verify the PAC.
    //

    Status = LsaFunctions->GetClientInfo(&LsaClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (LsaClientInfo.HasTcbPrivilege)
    {

        goto Cleanup;
    }

    //
    // We have to pass off to the DC so build the request.
    //


    SignatureSize = PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize);
    RequestSize = sizeof(MSV1_0_PASSTHROUGH_REQUEST) +
                    ROUND_UP_COUNT(ServiceDomain->Length, ALIGN_LPTSTR) +
                    ROUND_UP_COUNT(KerbPackageName.Length, ALIGN_LPTSTR) +
                    sizeof(KERB_VERIFY_PAC_REQUEST) - sizeof(UCHAR) * ANYSIZE_ARRAY +
                    Check->CheckSumSize +
                    SignatureSize;

    PassthroughRequest = (PMSV1_0_PASSTHROUGH_REQUEST) KerbAllocate(RequestSize);
    if (PassthroughRequest == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Where = (PUCHAR) (PassthroughRequest + 1);

    PassthroughRequest->MessageType = MsV1_0GenericPassthrough;

    PassthroughRequest->DomainName = *ServiceDomain;
    PassthroughRequest->DomainName.Buffer = (LPWSTR) Where;
    RtlCopyMemory(
        Where,
        ServiceDomain->Buffer,
        ServiceDomain->Length
        );
    Where += ROUND_UP_COUNT(ServiceDomain->Length, ALIGN_LPTSTR);

    PassthroughRequest->PackageName = KerbPackageName;

    PassthroughRequest->PackageName.Buffer = (LPWSTR) Where;
    RtlCopyMemory(
        Where,
        KerbPackageName.Buffer,
        KerbPackageName.Length
        );
    Where += ROUND_UP_COUNT(KerbPackageName.Length, ALIGN_LPTSTR);
    PassthroughRequest->LogonData = Where;
    PassthroughRequest->DataLength = sizeof(KERB_VERIFY_PAC_REQUEST) - sizeof(UCHAR) * ANYSIZE_ARRAY +
                                        Check->CheckSumSize +
                                        SignatureSize;
    VerifyRequest = (PKERB_VERIFY_PAC_REQUEST) PassthroughRequest->LogonData;
    VerifyRequest->MessageType = KerbVerifyPacMessage;

    VerifyRequest->ChecksumLength = Check->CheckSumSize;
    VerifyRequest->SignatureType = PrivSvrSignature->SignatureType;
    VerifyRequest->SignatureLength = SignatureSize;

    RtlCopyMemory(
        VerifyRequest->ChecksumAndSignature,
        LocalChecksum,
        Check->CheckSumSize
        );
    RtlCopyMemory(
        VerifyRequest->ChecksumAndSignature + Check->CheckSumSize,
        LocalPrivSvrChecksum,
        SignatureSize
        );

    //
    // We've build the buffer, now call NTLM to pass it through.
    //

    Status = LsaFunctions->CallPackage(
                &MsvPackageName,
                PassthroughRequest,
                RequestSize,
                (PVOID *) &PassthroughResponse,
                &ResponseSize,
                &SubStatus
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to call MSV package to verify PAC: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        if (Status == STATUS_INVALID_INFO_CLASS)
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    if (!NT_SUCCESS(SubStatus))
    {
        Status = SubStatus;
        DebugLog((DEB_ERROR,"KDC failed to verify PAC signature: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        if ((Status == STATUS_INVALID_INFO_CLASS) ||
            (Status == STATUS_INVALID_SERVER_STATE) ||
            (Status == STATUS_NO_SUCH_USER))
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
        }
        goto Cleanup;
    }


Cleanup:
    KerbFreeString(&ClientName);
    if ( ( CheckBuffer != NULL ) &&
         ( Check != NULL ) )
    {
        Check->Finish(&CheckBuffer);
    }
    if (PassthroughRequest != NULL)
    {
        KerbFree(PassthroughRequest);
    }
    if (PassthroughResponse != NULL)
    {
        LsaFunctions->FreeReturnBuffer(PassthroughResponse);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutClientString
//
//  Synopsis:   Copies a string into a buffer that will be copied to the
//              client's address space
//
//  Effects:
//
//  Arguments:  Where - Location in local buffer to place string.
//              Delta - Difference in addresses of local and client buffers.
//              OutString - Receives 'put' string
//              InString - String to 'put'
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutWOWClientString.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutClientString(
    IN OUT PUCHAR * Where,
    IN LONG_PTR Delta,
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )
{

    if (InString->Length == 0)
    {
        OutString->Buffer = NULL;
        OutString->Length = OutString->MaximumLength = 0;
    }
    else
    {
        RtlCopyMemory(
            *Where,
            InString->Buffer,
            InString->Length
            );

        OutString->Buffer = (LPWSTR) (*Where + Delta);
        OutString->Length = InString->Length;
        *Where += InString->Length;
        *(LPWSTR) (*Where) = L'\0';
        *Where += sizeof(WCHAR);
        OutString->MaximumLength = OutString->Length + sizeof(WCHAR);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateInteractiveProfile
//
//  Synopsis:   This allocates and fills in the clients interactive profile.
//
//  Effects:
//
//  Arguments:
//
//    ProfileBuffer - Is used to return the address of the profile
//        buffer in the client process.  This routine is
//        responsible for allocating and returning the profile buffer
//        within the client process.  However, if the caller subsequently
//        encounters an error which prevents a successful logon, then
//        then it will take care of deallocating the buffer.  This
//        buffer is allocated with the AllocateClientBuffer() service.
//
//     ProfileBufferSize - Receives the Size (in bytes) of the
//        returned profile buffer.
//
//     NlpUser - Contains the validation information which is
//        to be copied in the ProfileBuffer.
//
//     LogonSession - Logon session structure containing certificate
//        context for smart card logons.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:      stolen from private\lsa\msv1_0\nlp.c
//
//              Some of this code is (effectively) duplicated in
//              KerbAllocateInteractiveWOWBuffer.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------


NTSTATUS
KerbAllocateInteractiveProfile (
    OUT PKERB_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET LogonTicket,
    IN OPTIONAL PKERB_INTERACTIVE_LOGON KerbLogonInfo
    )
{
    NTSTATUS Status;
    PKERB_INTERACTIVE_PROFILE LocalProfileBuffer = NULL;
    PKERB_SMART_CARD_PROFILE SmartCardProfile = NULL;
    PKERB_TICKET_PROFILE TicketProfile = NULL;
    PUCHAR ClientBufferBase = NULL;
    PUCHAR Where = NULL;
    LONG_PTR Delta = 0;
    BOOLEAN BuildSmartCardProfile = FALSE;
    BOOLEAN BuildTicketProfile = FALSE;

#if _WIN64

    SECPKG_CALL_INFO  CallInfo;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif  // _WIN64

    //
    // Alocate the profile buffer to return to the client
    //

    KerbReadLockLogonSessions( LogonSession );


    *ProfileBuffer = NULL;

    if ((LogonSession->PrimaryCredentials.PublicKeyCreds != NULL) &&
        (LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext  != NULL))
    {
        BuildSmartCardProfile = TRUE;
    }
    else if (ARGUMENT_PRESENT(KerbLogonInfo) &&
             (KerbLogonInfo->MessageType == KerbTicketLogon) ||
             (KerbLogonInfo->MessageType == KerbTicketUnlockLogon))
    {
        DsysAssert(ARGUMENT_PRESENT(LogonTicket));
        BuildTicketProfile = TRUE;
        KerbReadLockTicketCache();
    }

    //
    // NOTE:  The 64-bit code below is (effectively) duplicated in
    //        the WOW helper routine.  If modifying one, make sure
    //        to apply the change(s) to the other as well.
    //

#if _WIN64

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        Status = KerbAllocateInteractiveWOWBuffer(&LocalProfileBuffer,
                                                  ProfileBufferSize,
                                                  UserInfo,
                                                  LogonSession,
                                                  LogonTicket,
                                                  KerbLogonInfo,
                                                  &ClientBufferBase,
                                                  BuildSmartCardProfile,
                                                  BuildTicketProfile);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else
    {

#endif  // _WIN64

        if (BuildSmartCardProfile)
        {
            *ProfileBufferSize = sizeof(KERB_SMART_CARD_PROFILE) +
                    LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->cbCertEncoded;
        }
        else if (BuildTicketProfile)
        {
            *ProfileBufferSize = sizeof(KERB_TICKET_PROFILE) +
                    LogonTicket->key.keyvalue.length;
        }
        else
        {
            *ProfileBufferSize = sizeof(KERB_INTERACTIVE_PROFILE);
        }

        *ProfileBufferSize +=
            UserInfo->LogonScript.Length + sizeof(WCHAR) +
            UserInfo->HomeDirectory.Length + sizeof(WCHAR) +
            UserInfo->HomeDirectoryDrive.Length + sizeof(WCHAR) +
            UserInfo->FullName.Length + sizeof(WCHAR) +
            UserInfo->ProfilePath.Length + sizeof(WCHAR) +
            UserInfo->LogonServer.Length + sizeof(WCHAR);

        LocalProfileBuffer = (PKERB_INTERACTIVE_PROFILE) KerbAllocate(*ProfileBufferSize);

        if (LocalProfileBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    *ProfileBufferSize,
                    (PVOID *) &ClientBufferBase
                    );

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        Delta = (LONG_PTR) (ClientBufferBase - (PUCHAR) LocalProfileBuffer) ;

        //
        // Don't walk over smart card data
        //

        if (BuildSmartCardProfile)
        {
            Where = (PUCHAR) ((PKERB_SMART_CARD_PROFILE) LocalProfileBuffer + 1);
        }
        else if (BuildTicketProfile)
        {
            Where = (PUCHAR) ((PKERB_TICKET_PROFILE) LocalProfileBuffer + 1);
        }
        else
        {
            Where = (PUCHAR) (LocalProfileBuffer + 1);
        }

        //
        // Copy the scalar fields into the profile buffer.
        //

        LocalProfileBuffer->MessageType = KerbInteractiveProfile;
        LocalProfileBuffer->LogonCount = UserInfo->LogonCount;
        LocalProfileBuffer->BadPasswordCount= UserInfo->BadPasswordCount;
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->LogonTime,
                                  LocalProfileBuffer->LogonTime );
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->LogoffTime,
                                  LocalProfileBuffer->LogoffTime );
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->KickOffTime,
                                  LocalProfileBuffer->KickOffTime );
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordLastSet,
                                  LocalProfileBuffer->PasswordLastSet );
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordCanChange,
                                  LocalProfileBuffer->PasswordCanChange );
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordMustChange,
                                  LocalProfileBuffer->PasswordMustChange );
        LocalProfileBuffer->UserFlags = UserInfo->UserFlags;

        //
        // Copy the Unicode strings into the profile buffer.
        //

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->LogonScript,
                            &UserInfo->LogonScript );

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->HomeDirectory,
                            &UserInfo->HomeDirectory );

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->HomeDirectoryDrive,
                            &UserInfo->HomeDirectoryDrive );

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->FullName,
                            &UserInfo->FullName );

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->ProfilePath,
                            &UserInfo->ProfilePath );

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->LogonServer,
                            &UserInfo->LogonServer );

        if (BuildSmartCardProfile)
        {
            LocalProfileBuffer->MessageType = KerbSmartCardProfile;
            SmartCardProfile = (PKERB_SMART_CARD_PROFILE) LocalProfileBuffer;
            SmartCardProfile->CertificateSize = LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->cbCertEncoded;
            SmartCardProfile->CertificateData = (PUCHAR) Where + Delta;
            RtlCopyMemory(
                Where,
                LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->pbCertEncoded,
                SmartCardProfile->CertificateSize
                );
            Where += SmartCardProfile->CertificateSize;
        }
        else if (BuildTicketProfile)
        {
            LocalProfileBuffer->MessageType = KerbTicketProfile;
            TicketProfile = (PKERB_TICKET_PROFILE) LocalProfileBuffer;

            //
            // If the key is exportable or we are domestic, return the key
            //

            if (KerbGlobalStrongEncryptionPermitted ||
                KerbIsKeyExportable(
                    &LogonTicket->key
                    ))
            {
                TicketProfile->SessionKey.KeyType = LogonTicket->key.keytype;
                TicketProfile->SessionKey.Length = LogonTicket->key.keyvalue.length;
                TicketProfile->SessionKey.Value = (PUCHAR) Where + Delta;
                RtlCopyMemory(
                    Where,
                    LogonTicket->key.keyvalue.value,
                    LogonTicket->key.keyvalue.length
                    );
                Where += TicketProfile->SessionKey.Length;
            }
        }

#if _WIN64

    }

#endif  // _WIN64


    //
    // Flush the buffer to the client's address space.
    //

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                *ProfileBufferSize,
                ClientBufferBase,
                LocalProfileBuffer
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ProfileBuffer = (PKERB_INTERACTIVE_PROFILE) ClientBufferBase;

Cleanup:

    if (BuildTicketProfile)
    {
        KerbUnlockTicketCache();
    }

    KerbUnlockLogonSessions( LogonSession );

    //
    // If the copy wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) )
    {
        LsaFunctions->FreeClientBuffer( NULL, ClientBufferBase );
    }

    if (LocalProfileBuffer != NULL)
    {
        KerbFree(LocalProfileBuffer);
    }

    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeTokenInformationV2
//
//  Synopsis:   This routine makes copies of all the pertinent
//              information from the UserInfo and generates a
//              LSA_TOKEN_INFORMATION_V2 data structure.
//
//  Effects:
//
//  Arguments:
//
//    UserInfo - Contains the validation information which is
//        to be copied into the TokenInformation.
//
//    TokenInformation - Returns a pointer to a properly Version 1 token
//        information structures.  The structure and individual fields are
//        allocated properly as described in ntlsa.h.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - Indicates the service completed successfully.
//
//              STATUS_INSUFFICIENT_RESOURCES -  This error indicates that
//                      the logon could not be completed because the client
//                      does not have sufficient quota to allocate the return
//                      buffer.
//
//  Notes:      stolen from msv1_0\nlp.c:NlpMakeTokenInformationV1
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbMakeTokenInformationV2(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    IN BOOLEAN LocalSystem,
    OUT PLSA_TOKEN_INFORMATION_V2 *TokenInformation
    )
{
    PNETLOGON_VALIDATION_SAM_INFO3 UserInfo = ValidationInfo;
    NTSTATUS Status;
    PLSA_TOKEN_INFORMATION_V2 V2 = NULL;
    ULONG Size, i;
    BYTE SidBuffer[sizeof(SID) + sizeof(ULONG)];
    SID LocalSystemSid = {SID_REVISION,1,SECURITY_NT_AUTHORITY,SECURITY_LOCAL_SYSTEM_RID};
    PSID AdminsSid = SidBuffer;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    DWORD NumGroups = 0;
    PBYTE CurrentSid = NULL;
    ULONG SidLength = 0;


    //
    // For local system, add in administrators & set user id to local system
    //

    if (LocalSystem)
    {
        RtlInitializeSid(
            AdminsSid,
            &NtAuthority,
            2
            );
        *RtlSubAuthoritySid(AdminsSid,0) = SECURITY_BUILTIN_DOMAIN_RID;
        *RtlSubAuthoritySid(AdminsSid,1) = DOMAIN_ALIAS_RID_ADMINS;
    }



    //
    // Allocate the structure itself
    //

    Size = (ULONG)sizeof(LSA_TOKEN_INFORMATION_V2);

    //
    // Allocate an array to hold the groups
    //

    Size += sizeof(TOKEN_GROUPS);


    // Add room for groups passed as RIDS
    NumGroups = UserInfo->GroupCount;
    if(UserInfo->GroupCount)
    {
        Size += UserInfo->GroupCount * (RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
    }

    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {
        ULONG i = 0;
        NumGroups += UserInfo->SidCount;

        // Add room for the sid's themselves
        for(i=0; i < UserInfo->SidCount; i++)
        {
            Size += RtlLengthSid(UserInfo->ExtraSids[i].Sid);
        }
    }

    //
    // If there are resource groups, add space for them
    //
    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {

        NumGroups += UserInfo->ResourceGroupCount;

        if ((UserInfo->ResourceGroupCount != 0) &&
            ((UserInfo->ResourceGroupIds == NULL) ||
             (UserInfo->ResourceGroupDomainSid == NULL)))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        // Allocate space for the sids
        if(UserInfo->ResourceGroupCount)
        {
            Size += UserInfo->ResourceGroupCount * (RtlLengthSid(UserInfo->ResourceGroupDomainSid) + sizeof(ULONG));
        }

    }

    //
    // If this is local system, add space for User & Administrators
    //

    if (!LocalSystem)
    {

        if( UserInfo->UserId )
        {
            Size += 2*(RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
        }
        else
        {
            if ( UserInfo->SidCount <= 0 ) {

                Status = STATUS_INSUFFICIENT_LOGON_INFO;
                goto Cleanup;
            }

            Size += (RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG)) + RtlLengthSid(UserInfo->ExtraSids[0].Sid);

        }
    }
    else
    {
        NumGroups += 2;

        // Allocate sid space for LocalSystem, Administrators
        Size += sizeof(LocalSystemSid) + RtlLengthSid(AdminsSid);

        // Add space for the user sid
        if( UserInfo->UserId )
        {
            Size += (RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
        }
    }

    Size += (NumGroups - ANYSIZE_ARRAY)*sizeof(SID_AND_ATTRIBUTES);



    V2 = (PLSA_TOKEN_INFORMATION_V2) KerbAllocate( Size );
    if ( V2 == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)V2, Size);

    V2->Groups = (PTOKEN_GROUPS)(V2+1);

    V2->Groups->GroupCount = 0;
    CurrentSid = (PBYTE)&V2->Groups->Groups[NumGroups];

    OLD_TO_NEW_LARGE_INTEGER( UserInfo->KickOffTime, V2->ExpirationTime );


    if (!LocalSystem)
    {
        //
        // If the UserId is non-zero, then it contians the users RID.
        //

        if ( UserInfo->UserId ) {
            V2->User.User.Sid = (PSID)CurrentSid;
            CurrentSid += KerbCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->UserId);
        }

        //
        // Make a copy of the primary group (a required field).
        //
        V2->PrimaryGroup.PrimaryGroup = (PSID)CurrentSid;
        CurrentSid += KerbCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->PrimaryGroupId );

    }
    else
    {
        //
        // For local system, the user sid is LocalSystem and the primary
        // group is LocalSystem
        //
        V2->User.User.Sid = (PSID)CurrentSid;
        RtlCopySid(sizeof(LocalSystemSid),  (PSID)CurrentSid, &LocalSystemSid);

        CurrentSid += sizeof(LocalSystemSid);

        //
        // The real system token has LocalSystem for the primary
        // group. However, the LSA will add the primary group to the
        // list of groups if it isn't listed as a group, and since
        // LocalSystem is the user sid, we don't want that.
        //
        V2->PrimaryGroup.PrimaryGroup = (PSID)CurrentSid;
        SidLength = RtlLengthSid(AdminsSid);
        RtlCopySid(SidLength,  (PSID)CurrentSid, AdminsSid);
        CurrentSid += SidLength;


        //
        // If there is a user sid, add it as a group id.
        //

        if ( UserInfo->UserId ) {
            V2->Groups->Groups[V2->Groups->GroupCount].Attributes =
                    SE_GROUP_MANDATORY |
                    SE_GROUP_ENABLED|
                    SE_GROUP_ENABLED_BY_DEFAULT;

            V2->Groups->Groups[V2->Groups->GroupCount].Sid = (PSID)CurrentSid;
            CurrentSid += KerbCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->UserId);

            V2->Groups->GroupCount++;
        }

        //
        // Add builtin administrators. This is not mandatory
        //

        V2->Groups->Groups[V2->Groups->GroupCount].Attributes =
                SE_GROUP_ENABLED|
                SE_GROUP_OWNER|
                SE_GROUP_ENABLED_BY_DEFAULT;

        V2->Groups->Groups[V2->Groups->GroupCount].Sid = V2->PrimaryGroup.PrimaryGroup;
        V2->Groups->GroupCount++;

    }



    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ ) {

        V2->Groups->Groups[V2->Groups->GroupCount].Attributes = UserInfo->GroupIds[i].Attributes;

        V2->Groups->Groups[V2->Groups->GroupCount].Sid = (PSID)CurrentSid;
        CurrentSid += KerbCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->GroupIds[i].RelativeId);

        V2->Groups->GroupCount++;
    }


    //
    // Add in the extra SIDs
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {

        ULONG index = 0;
        //
        // If the user SID wasn't passed as a RID, it is the first
        // SID.
        //

        if ( !V2->User.User.Sid ) {
            V2->User.User.Sid = (PSID)CurrentSid;
            SidLength = RtlLengthSid(UserInfo->ExtraSids[index].Sid);
            RtlCopySid(SidLength, (PSID)CurrentSid, UserInfo->ExtraSids[index].Sid);

            CurrentSid += SidLength;
            index++;
        }

        //
        // Copy over all additional SIDs as groups.
        //

        for ( ; index < UserInfo->SidCount; index++ ) {

            V2->Groups->Groups[V2->Groups->GroupCount].Attributes =
                UserInfo->ExtraSids[index].Attributes;

            V2->Groups->Groups[V2->Groups->GroupCount].Sid= (PSID)CurrentSid;
            SidLength = RtlLengthSid(UserInfo->ExtraSids[index].Sid);
            RtlCopySid(SidLength, (PSID)CurrentSid, UserInfo->ExtraSids[index].Sid);

            CurrentSid += SidLength;

            V2->Groups->GroupCount++;
        }
    }

    //
    // Check to see if any resouce groups exist
    //

    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {


        for ( i=0; i < UserInfo->ResourceGroupCount; i++ ) {

            V2->Groups->Groups[V2->Groups->GroupCount].Attributes = UserInfo->ResourceGroupIds[i].Attributes;

            V2->Groups->Groups[V2->Groups->GroupCount].Sid= (PSID)CurrentSid;
            CurrentSid += KerbCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->ResourceGroupDomainSid, UserInfo->ResourceGroupIds[i].RelativeId);

            V2->Groups->GroupCount++;
        }
    }

    ASSERT( ((PBYTE)V2 + Size) == CurrentSid );

    if (!V2->User.User.Sid) {

        Status = STATUS_INSUFFICIENT_LOGON_INFO;
        goto Cleanup;
    }

    //
    // There are no default privileges supplied.
    // We don't have an explicit owner SID.
    // There is no default DACL.
    //

    V2->Privileges = NULL;
    V2->Owner.Owner = NULL;
    V2->DefaultDacl.DefaultDacl = NULL;

    //
    // Return the Validation Information to the caller.
    //

    *TokenInformation = V2;
    return STATUS_SUCCESS;

    //
    // Deallocate any memory we've allocated
    //

Cleanup:

    KerbFree( V2 );

    return Status;

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateDelegationLogonSession
//
//  Synopsis:   Creates a logon session from the delegation information
//              in the GSS checksum
//
//  Effects:
//
//  Arguments:  LogonId - The logon id for the AP request, which will be used
//                      for the new logon session.
//              Ticket - The ticket used for the AP request, containing the
//                      session key to decrypt the KERB_CRED
//              GssChecksum - Checksum containing the delegation information
//
//  Requires:
//
//  Returns:    NTSTATUS codes
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateDelegationLogonSession(
    IN PLUID LogonId,
    IN PKERB_ENCRYPTED_TICKET Ticket,
    IN PKERB_GSS_CHECKSUM GssChecksum
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CRED KerbCred = NULL;
    PKERB_ENCRYPTED_CRED EncryptedCred = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    KERBERR KerbErr;

    D_DebugLog((DEB_TRACE, "Building delegation logon session\n"));

    if (GssChecksum->Delegation != 1)
    {
        D_DebugLog((DEB_ERROR,"Asked for GSS_C_DELEG_FLAG but Delegation != 1 = 0x%x. %ws, line %d\n",
                    GssChecksum->Delegation, THIS_FILE, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbUnpackKerbCred(
            GssChecksum->DelegationInfo,
            GssChecksum->DelegationLength,
            &KerbCred
            )))
    {
        D_DebugLog((DEB_WARN, "Failed to unpack kerb cred\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    //
    // Now decrypt the encrypted part of the KerbCred.
    //
    KerbErr = KerbDecryptDataEx(
                &KerbCred->encrypted_part,
                &Ticket->key,
                KERB_CRED_SALT,
                (PULONG) &KerbCred->encrypted_part.cipher_text.length,
                KerbCred->encrypted_part.cipher_text.value
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to decrypt KERB_CRED: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        if (KerbErr == KRB_ERR_GENERIC)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;

            //
            // MIT clients don't encrypt the encrypted part, so drop through
            //

        }
    }

    //
    // Now unpack the encrypted part.
    //

    if (!KERB_SUCCESS(KerbUnpackEncryptedCred(
            KerbCred->encrypted_part.cipher_text.value,
            KerbCred->encrypted_part.cipher_text.length,
            &EncryptedCred
            )))
    {
        //
        // Use the old status if it is available.
        //

        if (NT_SUCCESS(Status))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        D_DebugLog((DEB_WARN, "Failed to unpack encrypted cred\n"));
        goto Cleanup;
    }

    //
    // Now build a logon session.
    //

    Status = KerbCreateLogonSessionFromKerbCred(
                LogonId,
                Ticket,
                KerbCred,
                EncryptedCred,
                &LogonSession
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create logon session from kerb cred: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    KerbReadLockLogonSessions(LogonSession);
    LogonSession->LogonSessionFlags |= KERB_LOGON_DELEGATED ;
    KerbUnlockLogonSessions(LogonSession);

    KerbDereferenceLogonSession( LogonSession );


Cleanup:
    if (EncryptedCred != NULL)
    {
        KerbFreeEncryptedCred(EncryptedCred);
    }
    if (KerbCred != NULL)
    {
        KerbFreeKerbCred(KerbCred);
    }
    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateTokenFromTicket
//
//  Synopsis:   Pulls the PAC out of a ticket and
//
//  Effects:    Creates a logon session and a token
//
//  Arguments:  InternalTicket - The ticket off of which to base the
//                      token.
//              Authenticator - Authenticator from the AP request,
//                      which may contain delegation information.
//              NewLogonId - Receives the logon ID of the new logon session
//              UserSid - Receives user's sid.
//              NewTokenHandle - Receives the newly created token handle.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateTokenFromTicket(
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AUTHENTICATOR Authenticator,
    IN ULONG ContextFlags,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN PUNICODE_STRING ServiceDomain,
    IN KERB_ENCRYPTION_KEY* pSessionKey,
    OUT PLUID NewLogonId,
    OUT PSID * UserSid,
    OUT PHANDLE NewTokenHandle,
    OUT PUNICODE_STRING ClientName,
    OUT PUNICODE_STRING ClientDomain
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PPACTYPE Pac = NULL;
    PKERB_AUTHORIZATION_DATA PacAuthData = NULL;
    PKERB_AUTHORIZATION_DATA AuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;
    PPAC_INFO_BUFFER LogonInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    PLSA_TOKEN_INFORMATION_V2 TokenInformation = NULL;
    PLSA_TOKEN_INFORMATION_NULL TokenNull = NULL;
    LSA_TOKEN_INFORMATION_TYPE TokenType = LsaTokenInformationNull;
    PVOID LsaTokenInformation = NULL;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = SecurityImpersonation;
    ULONG NameType;
    BOOLEAN BuildNullToken = FALSE;

    LUID LogonId;
    LUID SystemLogonId = SYSTEM_LUID;
    UNICODE_STRING Workstation = NULL_UNICODE_STRING;
    UNICODE_STRING TempUserName;
    UNICODE_STRING TempDomainName;
    PKERB_GSS_CHECKSUM GssChecksum;
    BOOLEAN IsLocalSystem = FALSE;

    NTSTATUS SubStatus;
    HANDLE TokenHandle = NULL;
    BOOLEAN FreePac = FALSE;

    SECPKG_PRIMARY_CRED PrimaryCredentials;

    RtlZeroMemory(
        &PrimaryCredentials,
        sizeof(SECPKG_PRIMARY_CRED)
        );

    LogonId.HighPart = 0;
    LogonId.LowPart = 0;
    *UserSid = NULL;
    *NewLogonId = LogonId;


    //
    // Check to see if this was NULL session
    //

    if (ARGUMENT_PRESENT(InternalTicket))
    {

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToString(
                            ClientName,
                            &NameType,
                            &InternalTicket->client_name
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                            ClientDomain,
                            &InternalTicket->client_realm
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


        //
        // Convert the principal name into just a user name
        //

        (VOID) KerbSplitFullServiceName(
                ClientName,
                &TempDomainName,
                &TempUserName
                );

        TokenType = LsaTokenInformationV2;

        //
        // Make sure there is some authorization data
        //

        if (((InternalTicket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present) != 0) &&
             (InternalTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL))

        {

            AuthData = InternalTicket->KERB_ENCRYPTED_TICKET_authorization_data;

            //
            // Verify the auth data is valid
            //

            if (!KerbVerifyAuthData(
                InternalTicket->KERB_ENCRYPTED_TICKET_authorization_data
                ))
            {
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            //
            // Get the PAC out of the authorization data
            //

            KerbErr = KerbGetPacFromAuthData(
                            InternalTicket->KERB_ENCRYPTED_TICKET_authorization_data,
                            &IfRelevantData,
                            &PacAuthData
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }

            if (PacAuthData != NULL)
            {
                //
                // Unmarshall the PAC
                //

                Pac = (PPACTYPE) PacAuthData->value.auth_data.value;
                if (PAC_UnMarshal(Pac, PacAuthData->value.auth_data.length) == 0)
                {
                    D_DebugLog((DEB_ERROR,"Failed to unmarshal pac. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // Verify the signature on the pac
                //

                Status = KerbVerifyPacSignature(
                            ServiceDomain,
                            Pac,
                            PacAuthData->value.auth_data.length,
                            TicketKey,
                            InternalTicket,
                            TRUE,
                            &ValidationInfo
                            );
                if (!NT_SUCCESS(Status)) {
                    KerbReportPACError(
                        ClientName,
                        ClientDomain,
                        Status
                        );

                    DebugLog((DEB_WARN,"Pac signature did not verify. Trying to build local pac now. (KerbCreateTokenFromTicket)\n"));
                    Pac = NULL;
                }
            }
        }


        //
        // If we didn't find a PAC, try to build one locally
        //

        if (Pac == NULL)
        {
            PKERB_INTERNAL_NAME ClientKdcName = NULL;
            NTSTATUS TempStatus;


            //
            // Convert the client's name into a usable format
            //

            if (!KERB_SUCCESS(KerbConvertPrincipalNameToKdcName(
                                &ClientKdcName,
                                &InternalTicket->client_name
                                )))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }


            TempStatus = KerbCreatePacForKerbClient(
                            &Pac,
                            ClientKdcName,
                            ClientDomain,
                            NULL
                            );

            KerbFreeKdcName(&ClientKdcName);

            if (!NT_SUCCESS(TempStatus))
            {

                //
                // Reuse the error from above, it is is available.
                //

                if ((TempStatus == STATUS_NO_SUCH_USER) ||
                    (TempStatus == STATUS_PRIVILEGE_NOT_HELD))
                {
                    D_DebugLog((DEB_TRACE,"Failed to create local pac for client : 0x%x\n",TempStatus));
                    BuildNullToken = TRUE;
                    Status = STATUS_SUCCESS;
                }
                else
                {
                    if (NT_SUCCESS(Status))
                    {
                        Status = TempStatus;
                    }
                    DebugLog((DEB_ERROR,"Failed to create local pac for client : 0x%x\n",Status));
                    goto Cleanup;
                }
            }

            //
            // If we have a PAC, build everything else we need now
            //

            if (!BuildNullToken)
            {
                FreePac = TRUE;

                KerbFreeString( ClientDomain );

                KerbGlobalReadLock();

                Status = KerbDuplicateString(
                            ClientDomain,
                            &KerbGlobalMachineName
                            );

                KerbGlobalReleaseLock();

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                //
                // Find the SAM validation info
                //

                LogonInfo = PAC_Find(
                                Pac,
                                PAC_LOGON_INFO,
                                NULL
                                );
                if (LogonInfo == NULL)
                {
                    DebugLog((DEB_ERROR,"Failed to find logon info! %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // Now unmarshall the validation info
                //


                Status = PAC_UnmarshallValidationInfo(
                            &ValidationInfo,
                            LogonInfo->Data,
                            LogonInfo->cbBufferSize
                            );
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"Failed to unmarshall validation info: 0x%x. %ws, line %d\n",
                        Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }
            }
        }

        if (!BuildNullToken)
        {
            //
            // Check to see if the caller is local system on this
            // machine
            //


            if (RtlEqualUnicodeString(
                    ClientName,
                    &KerbGlobalMachineServiceName,
                    TRUE) &&
                KerbIsThisOurDomain(
                    ClientDomain
                    ))
            {
                BOOLEAN bExist = FALSE;

                //
                // check for special case where client is network serice of
                // local computer
                //

                Status = KerbDoesSKeyExist(pSessionKey, &bExist);

                if (NT_SUCCESS(Status))
                {
                    //
                    // bExist is false indicates that it is not network
                    // service of local computer, hence IsLocalSystem is true
                    //

                    IsLocalSystem = !bExist;

                    DebugLog((DEB_TRACE_LOOPBACK, "KerbCreateTokenFromTicket, IsLocalSystem? %s\n", (IsLocalSystem ? "true" : "false")));
                }
                else // !NT_SUCCESS(Status)
                {
                    DebugLog((DEB_ERROR,"Failed to detect local network service: 0x%x. %ws, line %d\n",
                        Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }
            }

            //
            // Now we need to build a LSA_TOKEN_INFORMATION_V2 from the validation
            // information
            //

            Status = KerbMakeTokenInformationV2(
                        ValidationInfo,
                        IsLocalSystem,
                        &TokenInformation
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to make token informatin v2: 0x%x. %ws, line %d\n",
                    Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }

            //
            // Copy out the NT4 user name & domain name to give to the LSA. It
            // requres the names from SAM because it generates the output of
            // GetUserName.
            //

            KerbFreeString( ClientName);
            Status = KerbDuplicateString(
                        ClientName,
                        &ValidationInfo->EffectiveName
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            KerbFreeString( ClientDomain );

            Status = KerbDuplicateString(
                        ClientDomain,
                        &ValidationInfo->LogonDomainName
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }


            //
            // Now create the token.
            //

            LsaTokenInformation = TokenInformation;

            Status = KerbDuplicateSid(
                        UserSid,
                        TokenInformation->User.User.Sid
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

    }
    else
    {
        BuildNullToken = TRUE;
    }

    if (BuildNullToken)
    {
        SID AnonymousSid = {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_ANONYMOUS_LOGON_RID };

        TokenNull = (PLSA_TOKEN_INFORMATION_NULL) KerbAllocate(sizeof(LSA_TOKEN_INFORMATION_NULL));
        if (TokenNull == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        LsaTokenInformation = TokenNull;
        TokenNull->Groups = NULL;
        TokenNull->ExpirationTime = KerbGlobalWillNeverTime;
        TokenType = LsaTokenInformationNull;

        Status = KerbDuplicateSid(
                    UserSid,
                    &AnonymousSid
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }


    //
    // Create a logon session.
    //

    NtAllocateLocallyUniqueId(&LogonId);

    Status = LsaFunctions->CreateLogonSession(&LogonId);
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to create logon session: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Add additional names to the logon session name map.  Ignore failure
    // as that just means GetUserNameEx calls for these name formats later
    // on will be satisfied by hitting the wire.
    //

    if (ValidationInfo && ValidationInfo->FullName.Length)
    {
        I_LsaIAddNameToLogonSession(&LogonId, NameDisplay, &ValidationInfo->FullName);
    }

    /*if (ClientName->Length && ClientName->Buffer)
    {
        I_LsaIAddNameToLogonSession(&LogonId, NameUserPrincipal, ClientName);
    } */

    if (ClientDomain->Length && ClientDomain->Buffer)
    {
        I_LsaIAddNameToLogonSession(&LogonId, NameDnsDomain, ClientDomain);
    }

    //
    // If the caller wanted an identify or delegate level token, duplicate the token
    // now.
    //

    if ((ContextFlags & ISC_RET_IDENTIFY) != 0)
    {
        ImpersonationLevel = SecurityIdentification;
    }
    else if ((ContextFlags & ISC_RET_DELEGATE) != 0)
    {
        ImpersonationLevel = SecurityDelegation;
    }

    if(ClientName->Length && ClientName->Buffer)
    {
        PrimaryCredentials.DownlevelName.Buffer = (PWSTR)LsaFunctions->AllocateLsaHeap(ClientName->Length);
        if (PrimaryCredentials.DownlevelName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        PrimaryCredentials.DownlevelName.Length =
        PrimaryCredentials.DownlevelName.MaximumLength = ClientName->Length;

        RtlCopyMemory(
                PrimaryCredentials.DownlevelName.Buffer,
                ClientName->Buffer,
                ClientName->Length
                );
    }

    if(ClientDomain->Length && ClientDomain->Buffer)
    {
        PrimaryCredentials.DomainName.Buffer = (PWSTR)LsaFunctions->AllocateLsaHeap(ClientDomain->Length);
        if (PrimaryCredentials.DomainName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        PrimaryCredentials.DomainName.Length =
        PrimaryCredentials.DomainName.MaximumLength = ClientDomain->Length;

        RtlCopyMemory(
                PrimaryCredentials.DomainName.Buffer,
                ClientDomain->Buffer,
                ClientDomain->Length
                );
    }

    Status = LsaFunctions->CreateTokenEx(
                &LogonId,
                &KerberosSource,
                Network,
                ImpersonationLevel,
                TokenType,
                LsaTokenInformation,
                NULL,                   // no token groups
                &Workstation,
                (ValidationInfo == NULL ? NULL : &ValidationInfo->ProfilePath),
                &PrimaryCredentials,
                SecSessionPrimaryCred,
                &TokenHandle,
                &SubStatus
                );


    // LsapCreateToken free's the TokenInformation structure for us, so
    // we don't need these pointers anymore.
    TokenInformation = NULL;
    TokenNull = NULL;

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    if (!NT_SUCCESS(SubStatus))
    {
        DebugLog((DEB_ERROR,"Failed to create token, substatus = 0x%x. %ws, line %d\n",SubStatus, THIS_FILE, __LINE__));
        Status = SubStatus;
        goto Cleanup;
    }


    //
    // Check the delegation information to see if we need to create
    // a logon session for this.
    //

    if ((ContextFlags & ISC_RET_DELEGATE) != 0)
    {
        DsysAssert(ARGUMENT_PRESENT(Authenticator));
        GssChecksum = (PKERB_GSS_CHECKSUM) Authenticator->checksum.checksum.value;
        DsysAssert(GssChecksum != 0);
        Status = KerbCreateDelegationLogonSession(
                    &LogonId,
                    InternalTicket,
                    GssChecksum
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to create delgation logon session: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__ ));
            goto Cleanup;
        }


    }

    //
    // Apply any restrictions from the auth data
    // Note: Punted until Blackcomb
    //

#ifdef RESTRICTED_TOKEN
    if (AuthData != NULL)
    {
        Status = KerbApplyAuthDataRestrictions(
                    &TokenHandle,
                    AuthData
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
#endif

    *NewLogonId = LogonId;
    *NewTokenHandle = TokenHandle;

Cleanup:

    if(PrimaryCredentials.DownlevelName.Buffer)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.DownlevelName.Buffer);
    }

    if(PrimaryCredentials.DomainName.Buffer)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.DomainName.Buffer);
    }

    if(PrimaryCredentials.LogonServer.Buffer)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.LogonServer.Buffer);
    }

    if(PrimaryCredentials.UserSid)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.UserSid);
    }

    if(PrimaryCredentials.LogonServer.Buffer)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.LogonServer.Buffer);
    }

    if(PrimaryCredentials.UserSid)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.UserSid);
    }


    if (TokenInformation != NULL)
    {
        KerbFree( TokenInformation );

    }
    if (TokenNull != NULL)
    {
        KerbFree(TokenNull);
    }


    if (!NT_SUCCESS(Status))
    {
        //
        // Note: if we have created a token, we don't want to delete
        // the logon session here because we will end up dereferencing
        // the logon session twice.
        //

        if (TokenHandle != NULL)
        {
            NtClose(TokenHandle);
        }
        else if ((LogonId.LowPart != 0) || (LogonId.HighPart != 0))
        {
            if (!RtlEqualLuid(
                    &LogonId,
                    &SystemLogonId
                    ))
            {
                LsaFunctions->DeleteLogonSession(&LogonId);
            }
        }
        if (*UserSid != NULL)
        {
            KerbFree(*UserSid);
            *UserSid = NULL;
        }
    }
    if (FreePac && (Pac != NULL))
    {
        MIDL_user_free(Pac);
    }

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }

    if (IfRelevantData != NULL)
    {
        KerbFreeData(
            PKERB_IF_RELEVANT_AUTH_DATA_PDU,
            IfRelevantData
            );
    }


    //
    // If the caller didn't have the requisite privilege, just continue
    // without a token.
    //

    if ((Status == STATUS_PRIVILEGE_NOT_HELD) ||
        (Status == STATUS_NO_SUCH_USER))
    {
        Status = STATUS_SUCCESS;
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbExtractCachedCreds
//
//  Synopsis:   Extracts the cached credentials from a logon ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbExtractCachedCreds(
    IN PPACTYPE Pac,
    IN PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PPAC_INFO_BUFFER CredBuffer = NULL;
    PPAC_CREDENTIAL_INFO CredInfo = NULL;
    PBYTE CredData = NULL;
    ULONG CredDataSize = 0;
    PSECPKG_SUPPLEMENTAL_CRED_ARRAY DecodedCreds = NULL;
    KERB_ENCRYPTED_DATA EncryptedData = {0};

    *CachedCredentials = NULL;

    //
    // If we don't have a key to obtain credentials, o.k.
    //

    if (!ARGUMENT_PRESENT(CredentialKey) ||
        (CredentialKey->keyvalue.value == NULL))
    {
        goto Cleanup;
    }

    CredBuffer = PAC_Find(
                    Pac,
                    PAC_CREDENTIAL_TYPE,
                    NULL                        // no previous instance
                    );
    if (CredBuffer == NULL)
    {
        //
        // We have no credentials. O.k.
        //
        goto Cleanup;
    }

    //
    // Build an encrypted data structure so we can decrypt the response
    //

    CredInfo = (PPAC_CREDENTIAL_INFO) CredBuffer->Data;
    if (CredBuffer->cbBufferSize < sizeof(PAC_CREDENTIAL_INFO))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    EncryptedData.version = CredInfo->Version;
    EncryptedData.encryption_type = CredInfo->EncryptionType;
    EncryptedData.cipher_text.value = CredInfo->Data;
    CredDataSize = CredBuffer->cbBufferSize -
                        FIELD_OFFSET(PAC_CREDENTIAL_INFO, Data);
    EncryptedData.cipher_text.length = CredDataSize;

    //
    // Decrypt in place
    //

    CredData =  CredInfo->Data;

    KerbErr = KerbDecryptDataEx(
                &EncryptedData,
                CredentialKey,
                KERB_NON_KERB_SALT,
                &CredDataSize,
                (PBYTE) CredData
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        D_DebugLog((DEB_ERROR,"Failed to decrypt credentials: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now build the return credentials
    //

    //
    // Now unmarshall the credential data
    //

    Status = PAC_UnmarshallCredentials(
                &DecodedCreds,
                CredData,
                CredDataSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *CachedCredentials = DecodedCreds;

    DecodedCreds = NULL;
Cleanup:
    if (DecodedCreds != NULL)
    {
        MIDL_user_free(DecodedCreds);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCacheLogonInformation
//
//  Synopsis:   Calls MSV1_0 to cache logon information. This routine
//              converts the pac into MSV1_0 compatible data and
//              makes a call to MSV1_0 to store it.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCacheLogonInformation(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING Password,
    IN OPTIONAL PUNICODE_STRING DnsDomainName,
    IN OPTIONAL PUNICODE_STRING Upn,
    IN BOOLEAN  MitLogon,
    IN ULONG    Flags,
    IN OPTIONAL PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    IN OPTIONAL PVOID SupplementalCreds,
    IN OPTIONAL ULONG SupplementalCredSize
    )
{
    NETLOGON_VALIDATION_SAM_INFO4 ValidationInfoToUse = {0};
    NETLOGON_INTERACTIVE_INFO MsvLogonInfo = {0};
    MSV1_0_CACHE_LOGON_REQUEST CacheRequest;
    UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING(TEXT(MSV1_0_PACKAGE_NAME));
    PVOID OutputBuffer = NULL;
    ULONG OutputBufferSize;
    NTSTATUS Status,TempStatus, SubStatus;
    ULONG NewGroupCount = 0;
    ULONG Index, Index2;
    UNICODE_STRING LocalMachineName;
    UNICODE_STRING DummyString;
    PBYTE Tmp, Tmp2;
    PVOID SupplementalMitCreds = NULL;
    ULONG SupplementalMitCredSize = 0;

    LocalMachineName.Buffer = NULL;

    //
    // We *used* to ADD a bunch of resource group code here....
    // Removed 5/1/01, as it appears we never add these to the
    // VALIDATION_SAM_INFO3 structure, and the KDC adds in
    // resource groups into ExtraSids....  see rtl/pac.cxx
    //

#if DBG
    if (ARGUMENT_PRESENT(ValidationInfo))
    {
        DsysAssert(ValidationInfo->ResourceGroupCount == 0);
    }
#endif

    MsvLogonInfo.Identity.LogonDomainName = *DomainName;
    MsvLogonInfo.Identity.UserName = *UserName;

    //
    // If this was a logon to an MIT realm that we know about,
    // then add the MIT username (upn?) & realm to the supplemental data
    //
    if (MitLogon)
    {
       D_DebugLog((DEB_TRACE, "Using MIT caching\n"));
       CacheRequest.RequestFlags = MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON;

       //
       // Marshall the MIT info into the supplemental creds.
       //
       SupplementalMitCredSize =
           (2* sizeof(UNICODE_STRING)) +
           ROUND_UP_COUNT(UserName->Length, ALIGN_LONG) +
           ROUND_UP_COUNT(DomainName->Length, ALIGN_LONG);


       SupplementalMitCreds = (PVOID) KerbAllocate(SupplementalMitCredSize);
       if (NULL == SupplementalMitCreds)
       {
           Status = STATUS_INSUFFICIENT_RESOURCES;
           goto Cleanup;
       }

       DummyString.Length = DummyString.MaximumLength = UserName->Length;
       Tmp = (PBYTE) (SupplementalMitCreds) + sizeof(UNICODE_STRING);

       if (DummyString.Length > 0)
       {

           RtlCopyMemory(
               Tmp,
               UserName->Buffer,
               UserName->Length
               );

           DummyString.Buffer = (PWSTR) UlongToPtr(RtlPointerToOffset(SupplementalMitCreds, Tmp));
       }
       else
       {
           DummyString.Buffer = NULL;
       }


       RtlCopyMemory(
           SupplementalMitCreds,
           &DummyString,
           sizeof(UNICODE_STRING)
           );

       Tmp2 = Tmp + ROUND_UP_COUNT(DummyString.Length, ALIGN_LONG);

       Tmp += ROUND_UP_COUNT(DummyString.Length, ALIGN_LONG) + sizeof(UNICODE_STRING);

       DummyString.Length = DummyString.MaximumLength = DomainName->Length;

       if (DummyString.Length > 0)
       {
             RtlCopyMemory(
                 Tmp,
                 DomainName->Buffer,
                 DomainName->Length
                 );

           DummyString.Buffer = (PWSTR) UlongToPtr(RtlPointerToOffset(SupplementalMitCreds, Tmp));
       }
       else
       {
           DummyString.Buffer = NULL;
       }

       RtlCopyMemory(
           Tmp2,
           &DummyString,
           sizeof(UNICODE_STRING)
           );


       CacheRequest.SupplementalCacheData = SupplementalMitCreds;
       CacheRequest.SupplementalCacheDataLength = SupplementalMitCredSize;
    }
    else
    {
       CacheRequest.RequestFlags = Flags;
       CacheRequest.SupplementalCacheData = SupplementalCreds;
       CacheRequest.SupplementalCacheDataLength = SupplementalCredSize;
    }

    //
    // Store the originating package of the logon
    //

    MsvLogonInfo.Identity.ParameterControl = RPC_C_AUTHN_GSS_KERBEROS;

    KerbGlobalReadLock();
    Status = KerbDuplicateString( &LocalMachineName, &KerbGlobalMachineName );
    KerbGlobalReleaseLock();

    if(!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalMachineName\n"));
        goto Cleanup;
    }

    MsvLogonInfo.Identity.Workstation = LocalMachineName;

    if (ARGUMENT_PRESENT(Password))
    {
        Status = RtlCalculateNtOwfPassword(
                    Password,
                    &MsvLogonInfo.NtOwfPassword
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to calculate NT OWF for %wZ. %ws, line %d\n",Password, THIS_FILE, __LINE__));
            goto Cleanup;
        }
    }

    //
    // Build up the NETLOGON_VALIDATION_SAM_INFO4 structure to pass to NTLM
    //
    if (ARGUMENT_PRESENT(ValidationInfo))
    {

        RtlCopyMemory(&ValidationInfoToUse,
                      ValidationInfo,
                      sizeof(NETLOGON_VALIDATION_SAM_INFO2));

        if (ARGUMENT_PRESENT(DnsDomainName))
        {
            ValidationInfoToUse.DnsLogonDomainName = *DnsDomainName;
        }

        /*if (ARGUMENT_PRESENT(Upn))
        {
            ValidationInfoToUse.Upn = *Upn;
        }*/
    }

    CacheRequest.MessageType = MsV1_0CacheLogon;
    CacheRequest.LogonInformation = &MsvLogonInfo;
    CacheRequest.ValidationInformation = &ValidationInfoToUse;

    //
    // tell NTLM it's a INFO4 structure.
    //

    CacheRequest.RequestFlags |= MSV1_0_CACHE_LOGON_REQUEST_INFO4;

    TempStatus = LsaFunctions->CallPackage(
                    &MsvPackageName,
                    &CacheRequest,
                    sizeof(CacheRequest),
                    &OutputBuffer,
                    &OutputBufferSize,
                    &SubStatus
                    );
    if (!NT_SUCCESS(TempStatus) || !NT_SUCCESS(SubStatus))
    {
        D_DebugLog((DEB_ERROR,"Failed to cache credentials: 0x%x, 0x%x. %ws, line %d\n",TempStatus, SubStatus, THIS_FILE, __LINE__));
    }

Cleanup:

    KerbFreeString( &LocalMachineName );

    if (SupplementalMitCreds != NULL)
    {
        KerbFree(SupplementalMitCreds);
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateTokenFromLogonTicket
//
//  Synopsis:   Creates a token from a ticket to the workstation
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateTokenFromLogonTicket(
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY LogonTicket,
    IN PLUID LogonId,
    IN PKERB_INTERACTIVE_LOGON KerbLogonInfo,
    IN BOOLEAN CacheLogon,
    IN BOOLEAN RealmlessWkstaLogon,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    IN OPTIONAL PKERB_MESSAGE_BUFFER ForwardedTgt,
    IN OPTIONAL PUNICODE_STRING MappedName,
    IN OPTIONAL PKERB_INTERNAL_NAME S4UClientName,
    IN OPTIONAL PUNICODE_STRING S4UClientRealm,
    IN PKERB_LOGON_SESSION LogonSession,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *NewTokenInformation,
    OUT PULONG ProfileBufferLength,
    OUT PVOID * ProfileBuffer,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials,
    OUT PNETLOGON_VALIDATION_SAM_INFO4 * ppValidationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION SystemLogonSession = NULL;
    LUID SystemLogonId = SYSTEM_LUID;
    BOOLEAN TicketCacheLocked = FALSE;
    BOOLEAN LogonSessionsLocked = FALSE;
    PKERB_ENCRYPTED_TICKET Ticket = NULL;
    PPACTYPE Pac = NULL;
    PKERB_AUTHORIZATION_DATA PacAuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;
    PPAC_INFO_BUFFER LogonInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo4 = NULL;
    PLSA_TOKEN_INFORMATION_V2 TokenInformation = NULL;
    PKERB_ENCRYPTION_KEY WkstaKey;
    BOOLEAN FreePac = FALSE;
    KERBERR KerbErr;
    UNICODE_STRING LocalDnsDomain = {0};
    LPWSTR lpDnsDomainName;

    *ProfileBuffer = NULL;
    *NewTokenInformation = NULL;
    *ppValidationInfo = NULL;

    //
    // If you're not on a "joined" wksta, you don't need to use the
    // system key.  Otherwise, locate the sytem logon session, which contains the key
    // to decrypt the ticket
    //
    if (!RealmlessWkstaLogon)
    {

        SystemLogonSession = KerbReferenceLogonSession(
            &SystemLogonId,
            FALSE               // don't unlink
            );


        DsysAssert(SystemLogonSession != NULL);
        if (SystemLogonSession == NULL)
        {
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto Cleanup;
        }

        DsysAssert((SystemLogonSession->LogonSessionFlags & KERB_LOGON_NO_PASSWORD) == 0);

        Status = KerbGetOurDomainName(
                        &LocalDnsDomain
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Decrypt the ticket
        //

        KerbReadLockLogonSessions(SystemLogonSession);
        LogonSessionsLocked = TRUE;
        KerbReadLockTicketCache();
        TicketCacheLocked = TRUE;


        //
        // Get the appropriate key
        //

        WkstaKey = KerbGetKeyFromList(
                            SystemLogonSession->PrimaryCredentials.Passwords,
                            LogonTicket->Ticket.encrypted_part.encryption_type
                            );
        if (WkstaKey == NULL)
        {
            D_DebugLog((DEB_ERROR,"Couldn't find correct key type: 0x%x. %ws, line %d\n",
                      LogonTicket->Ticket.encrypted_part.encryption_type, THIS_FILE, __LINE__ ));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        KerbErr = KerbVerifyTicket(
                        &LogonTicket->Ticket,
                        1,
                        &KerbGlobalMachineServiceName,
                        &LocalDnsDomain,
                        WkstaKey,
                        NULL,           // don't check time
                        &Ticket
                        );


        //
        // Check that expired ticket for ticket logon are handled properly.
        // The client may pass a flag to explicitly allow an expired ticket.
        // This ticket makes the logon fail if the ticket is not expired.
        //
        if ((KerbLogonInfo->MessageType == KerbTicketLogon) ||
            (KerbLogonInfo->MessageType == KerbTicketUnlockLogon))
        {
            BOOLEAN AllowExpired = FALSE;
            PKERB_TICKET_LOGON TicketLogon = (PKERB_TICKET_LOGON) KerbLogonInfo;
            if ((TicketLogon->Flags & KERB_LOGON_FLAG_ALLOW_EXPIRED_TICKET) != 0)
            {
                AllowExpired = TRUE;
            }

            if (AllowExpired)
            {
                if (KerbErr == KDC_ERR_NONE)
                {
                    Status = STATUS_INVALID_PARAMETER;
                    D_DebugLog((DEB_ERROR,"Can't allow expired ticket on a non-expired ticket\n"));
                    goto Cleanup;
                }
                else if (KerbErr == KRB_AP_ERR_TKT_EXPIRED)
                {
                    KerbErr = KDC_ERR_NONE;
                }
            }

        }


        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to decrypt workstation ticket: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
            if (KerbErr == KRB_AP_ERR_MODIFIED)
            {
                Status = STATUS_TRUSTED_RELATIONSHIP_FAILURE;
            }
            else
            {
                Status = KerbMapKerbError(KerbErr);
            }
        }


        //
        // If that failed, try again using the old password of the server
        //
        if ((Status == STATUS_TRUSTED_RELATIONSHIP_FAILURE) &&
            (SystemLogonSession->PrimaryCredentials.OldPasswords != NULL))
        {
            DebugLog((DEB_TRACE,"Current system password failed, trying old password\n"));

            //
            // Get the appropriate key
            //

            WkstaKey = KerbGetKeyFromList(
                            SystemLogonSession->PrimaryCredentials.OldPasswords,
                            LogonTicket->Ticket.encrypted_part.encryption_type
                            );
            if (WkstaKey == NULL)
            {
                DebugLog((DEB_ERROR,"Couldn't find correct key type: 0x%x. %ws, line %d\n",
                          LogonTicket->Ticket.encrypted_part.encryption_type, THIS_FILE, __LINE__ ));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            KerbErr = KerbVerifyTicket(
                            &LogonTicket->Ticket,
                            1,
                            &KerbGlobalMachineServiceName,
                            &LocalDnsDomain,
                            WkstaKey,
                            NULL,               // don't check time
                            &Ticket
                            );
            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"Failed to decrypt workstation ticket. %ws, line %d\n", THIS_FILE, __LINE__));
                if (KerbErr == KRB_AP_ERR_MODIFIED)
                    {
                    Status = STATUS_TRUSTED_RELATIONSHIP_FAILURE;
                }
                else
                {
                    Status = KerbMapKerbError(KerbErr);
                }
            }
            else
            {
                Status = STATUS_SUCCESS;
            }
        }

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


    //
    // Make sure there is some authorization data
    //

    if (((Ticket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present) != 0) &&
         (Ticket->KERB_ENCRYPTED_TICKET_authorization_data != NULL))

    {
        KERB_ENCRYPTION_KEY LocalKey = {0};
        UNICODE_STRING DomainName = {0};

        if (!KerbVerifyAuthData(
            Ticket->KERB_ENCRYPTED_TICKET_authorization_data
            ))
        {
            D_DebugLog((DEB_ERROR,"Failed to verify auth data\n"));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        //
        // Verify the auth data is valid
        //

        if (!KerbVerifyAuthData(
            Ticket->KERB_ENCRYPTED_TICKET_authorization_data
            ))
        {
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        //
        // Get the PAC out of the authorization data
        //

        KerbErr = KerbGetPacFromAuthData(
                        Ticket->KERB_ENCRYPTED_TICKET_authorization_data,
                        &IfRelevantData,
                        &PacAuthData
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }


        if (PacAuthData != NULL)
        {

            //
            // Unmarshall the PAC
            //

            Pac = (PPACTYPE) PacAuthData->value.auth_data.value;
            if (PAC_UnMarshal(Pac, PacAuthData->value.auth_data.length) == 0)
            {
                D_DebugLog((DEB_ERROR,"Failed to unmarshal pac. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // Copy state from the system logon session so we don't
            // leave it locked while verifying the PAC.
            //

            Status = KerbDuplicateString(
                        &DomainName,
                        &SystemLogonSession->PrimaryCredentials.DomainName
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            if (!KERB_SUCCESS(KerbDuplicateKey(
                                &LocalKey,
                                WkstaKey)))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }


            if (TicketCacheLocked)
            {
                KerbUnlockTicketCache();
                TicketCacheLocked = FALSE;
            }

            if (LogonSessionsLocked)
            {
                KerbUnlockLogonSessions(SystemLogonSession);
                LogonSessionsLocked = FALSE;
            }

            Status = KerbVerifyPacSignature(
                        &DomainName,
                        Pac,
                        PacAuthData->value.auth_data.length,
                        &LocalKey,
                        Ticket,
                        FALSE,              // don't bother verifying at KDC, because we obtained the ticket
                        &ValidationInfo
                        );

            KerbFreeString( &DomainName );
            KerbFreeKey( &LocalKey );

            if (!NT_SUCCESS(Status))
            {
                NTSTATUS Tmp;
                UNICODE_STRING UserName = {0};

                DebugLog((DEB_WARN,"Pac signature did not verify. Trying to build local pac now. (KerbCreateTokenFromLogonTicket)\n"));

                Tmp = KerbDuplicateString(
                            &UserName,
                            &SystemLogonSession->PrimaryCredentials.UserName
                            );

                if (NT_SUCCESS(Tmp))
                {
                    KerbReportPACError(
                    &UserName,
                    &DomainName,
                    Status
                    );

                    KerbFreeString( &UserName );
                }


                //
                // Null the pac so we can try to build one locally.
                //

                Pac = NULL;
            }

            KerbReadLockLogonSessions(SystemLogonSession);  // nothing can change
            LogonSessionsLocked = TRUE;
        }


    }
    }



    //
    // If we didn't find a PAC, try to build one locally
    //

    if (RealmlessWkstaLogon || Pac == NULL)
    {
        UNICODE_STRING DomainName = NULL_UNICODE_STRING;
        PKERB_INTERNAL_NAME ClientName = NULL;
        NTSTATUS TempStatus;

        DebugLog((DEB_WARN,"No authorization data in ticket - trying local\n"));

        // if we don't have a name, make one, but only if we have a service ticket
        if (ARGUMENT_PRESENT(LogonTicket))
        {

            if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                                    &DomainName,
                                    &Ticket->client_realm
                                    )))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            //
            // Convert the client's name into a usable format
            //

            if (!KERB_SUCCESS(KerbConvertPrincipalNameToKdcName(
                                    &ClientName,
                                    &Ticket->client_name
                                    )))
            {
                KerbFreeString(&DomainName);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
        //
        //  We don't have any information to do the mapping.  Return
        else if (MappedName->Buffer == NULL)
        {
            D_DebugLog((DEB_ERROR, "We don't have any information for creating a token!\n"));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;

        }

        TempStatus = KerbCreatePacForKerbClient(
                        &Pac,
                        ClientName,
                        &DomainName,
                        MappedName
                        );

        KerbFreeKdcName(&ClientName);
        KerbFreeString(&DomainName);

        if (!NT_SUCCESS(TempStatus))
        {
            DebugLog((DEB_ERROR,"Failed to create local pac for client: 0x%x\n",TempStatus));

            //
            // Return the original error if we failed to build a pac
            //

            if (NT_SUCCESS(Status))
            {
                Status = TempStatus;
            }
            goto Cleanup;
        }

        FreePac = TRUE;


        //
        // Find the SAM validation info
        //

        LogonInfo = PAC_Find(
                        Pac,
                        PAC_LOGON_INFO,
                        NULL
                        );
        if (LogonInfo == NULL)
        {
            D_DebugLog((DEB_ERROR,"Failed to find logon info! %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Now unmarshall the validation info
        //


        Status = PAC_UnmarshallValidationInfo(
                    &ValidationInfo,
                    LogonInfo->Data,
                    LogonInfo->cbBufferSize
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to unmarshall validation info: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
    }


    //
    // Check to see if this is a non-user account. If so, don't allow the logon
    //

    if ((ValidationInfo->ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] & USER_MACHINE_ACCOUNT_MASK) != 0)
    {
        DebugLog((DEB_ERROR,"Logons to non-user accounts not allowed. UserAccountControl = 0x%x. %ws, line %d\n",
            ValidationInfo->ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL], THIS_FILE, __LINE__ ));
        Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        goto Cleanup;
    }

    //
    // Now we need to build a LSA_TOKEN_INFORMATION_V2 from the validation
    // information
    //

    Status = KerbMakeTokenInformationV2(
                ValidationInfo,
                FALSE,                  // not local system
                &TokenInformation
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to make token informatin v1: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // Allocate the client profile
    //

    Status = KerbAllocateInteractiveProfile(
                (PKERB_INTERACTIVE_PROFILE *) ProfileBuffer,
                ProfileBufferLength,
                ValidationInfo,
                LogonSession,
                Ticket,
                KerbLogonInfo
                );
    if (!KERB_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Build the primary credential. We let someone else fill in the
    // password.
    //

    PrimaryCredentials->LogonId = *LogonId;
    Status = KerbDuplicateString(
                &PrimaryCredentials->DownlevelName,
                &ValidationInfo->EffectiveName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateString(
                &PrimaryCredentials->DomainName,
                &ValidationInfo->LogonDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateString(
                &PrimaryCredentials->LogonServer,
                &ValidationInfo->LogonServer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateSid(
                &PrimaryCredentials->UserSid,
                TokenInformation->User.User.Sid
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    PrimaryCredentials->Flags = 0;

    //
    // Get supplemental credentials out of the pac
    //

    Status = KerbExtractCachedCreds(
                Pac,
                CredentialKey,
                CachedCredentials
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // We're using the validation_info4 struct to pass appropriate information
    // back to caller for use in Lsa GetUserName().  We don't really use all
    // of this information, however, so only copy over interesting fields
    //
    ValidationInfo4 = (PNETLOGON_VALIDATION_SAM_INFO4) KerbAllocate(sizeof(NETLOGON_VALIDATION_SAM_INFO4));
    if (NULL == ValidationInfo4)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (ValidationInfo->FullName.Length)
    {
        Status = KerbDuplicateString(
                    &ValidationInfo4->FullName,
                    &ValidationInfo->FullName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    KerbReadLockLogonSessions(LogonSession);

    if (LogonSession->PrimaryCredentials.DomainName.Length)
    {

        Status = KerbDuplicateString(
                    &ValidationInfo4->DnsLogonDomainName,
                    &LogonSession->PrimaryCredentials.DomainName
                    );

        if (!NT_SUCCESS(Status))
        {
            KerbUnlockLogonSessions(LogonSession);
            goto Cleanup;
        }

        ValidationInfo4->Upn.Length = LogonSession->PrimaryCredentials.UserName.Length
                    + LogonSession->PrimaryCredentials.DomainName.Length
                    +sizeof(WCHAR);

        ValidationInfo4->Upn.MaximumLength = ValidationInfo4->Upn.Length + sizeof(WCHAR);

        ValidationInfo4->Upn.Buffer = (LPWSTR) KerbAllocate(ValidationInfo4->Upn.MaximumLength);

        if ( ValidationInfo4->Upn.Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            KerbUnlockLogonSessions(LogonSession);
            goto Cleanup;
        }

        RtlCopyMemory(
            ValidationInfo4->Upn.Buffer,
            LogonSession->PrimaryCredentials.UserName.Buffer,
            LogonSession->PrimaryCredentials.UserName.Length
            );

        ValidationInfo4->Upn.Buffer[LogonSession->PrimaryCredentials.UserName.Length/ sizeof(WCHAR)] = L'@';

        lpDnsDomainName =  ValidationInfo4->Upn.Buffer +
            LogonSession->PrimaryCredentials.UserName.Length / sizeof(WCHAR) + 1;

        RtlCopyMemory(
            lpDnsDomainName,
            LogonSession->PrimaryCredentials.DomainName.Buffer,
            LogonSession->PrimaryCredentials.DomainName.Length
            );

        D_DebugLog((DEB_ERROR, "Built UPN %wZ\n", &ValidationInfo4->Upn)); // fester: dumb down

    }

    KerbUnlockLogonSessions(LogonSession);

    //
    // Cache the logon info in MSV
    //
    if (CacheLogon)
    {
        if (KerbLogonInfo->MessageType == KerbInteractiveLogon)
        {

            BOOLEAN MitLogon;


            //
            // Hold no locks when leaving this dll
            //

            if (TicketCacheLocked)
            {
                KerbUnlockTicketCache();
                TicketCacheLocked = FALSE;
            }

            if (LogonSessionsLocked)
            {
                KerbUnlockLogonSessions(SystemLogonSession);
                LogonSessionsLocked = FALSE;
            }


            MitLogon = ((LogonSession->LogonSessionFlags & KERB_LOGON_MIT_REALM) != 0);


            KerbCacheLogonInformation(
                &KerbLogonInfo->UserName,
                &KerbLogonInfo->LogonDomainName,
                &KerbLogonInfo->Password,
                ((ValidationInfo4->DnsLogonDomainName.Length) ? &ValidationInfo4->DnsLogonDomainName : NULL),
                NULL, //((ValidationInfo4->Upn.Length) ? &ValidationInfo4->Upn : NULL),
                MitLogon,
                0,                              // no special flags
                ValidationInfo,
                NULL,                           // no supplemental creds
                0
                );

        }
        else if (KerbLogonInfo->MessageType == KerbSmartCardLogon)
        {
            KerbCacheSmartCardLogon(
                ValidationInfo,
                ((ValidationInfo4->DnsLogonDomainName.Length) ? &ValidationInfo4->DnsLogonDomainName : NULL),
                NULL, //((ValidationInfo4->Upn.Length) ? &ValidationInfo4->Upn : NULL),
                LogonSession,
                *CachedCredentials
                );
        }
        else
        {
            D_DebugLog((DEB_WARN,"CacheLogon requested but logon type not cacheable\n"));
        }

    }

    //
    // If we were supplied a TGT for this logon, stick it in the logon session
    //

    if (ARGUMENT_PRESENT(ForwardedTgt) && (ForwardedTgt->BufferSize != 0))
    {
        Status = KerbExtractForwardedTgt(
                    LogonSession,
                    ForwardedTgt,
                    Ticket
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    *NewTokenInformation = TokenInformation;
    *TokenInformationType = LsaTokenInformationV2;
    *ppValidationInfo = ValidationInfo4;
    ValidationInfo4 = NULL;

Cleanup:

    KerbFreeString(&LocalDnsDomain);
    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(SystemLogonSession);
    }

    if (!NT_SUCCESS(Status))
    {
        if (TokenInformation != NULL)
        {
            KerbFree( TokenInformation );
        }
        if (*ProfileBuffer != NULL)
        {
            LsaFunctions->FreeClientBuffer(NULL, *ProfileBuffer);
            *ProfileBuffer = NULL;
        }
        KerbFreeString(
            &PrimaryCredentials->DownlevelName
            );
        KerbFreeString(
            &PrimaryCredentials->DomainName
            );
        KerbFreeString(
            &PrimaryCredentials->LogonServer
            );
        if (PrimaryCredentials->UserSid != NULL)
        {
            KerbFree(PrimaryCredentials->UserSid);
            PrimaryCredentials->UserSid = NULL;
        }
    }
    if (Ticket != NULL)
    {
        KerbFreeTicket(Ticket);
    }
    if (FreePac && (Pac != NULL))
    {
        MIDL_user_free(Pac);
    }

    if (IfRelevantData != NULL)
    {
        KerbFreeData(
            PKERB_IF_RELEVANT_AUTH_DATA_PDU,
            IfRelevantData
            );
    }

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }

    if (ValidationInfo4)
    {
        KerbFreeString(&ValidationInfo4->DnsLogonDomainName);
        KerbFreeString(&ValidationInfo4->Upn);
        KerbFreeString(&ValidationInfo4->FullName);
        KerbFree(ValidationInfo4);
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCopyDomainRelativeSid
//
//  Synopsis:   Given a domain Id and a relative ID create the corresponding
//              SID at the location indicated by TargetSid
//
//  Effects:
//
//  Arguments:  TargetSid - target memory location
//              DomainId - The template SID to use.
//
//                  RelativeId - The relative Id to append to the DomainId.
//
//  Requires:
//
//  Returns:    Size - Size of the sid copied
//
//  Notes:
//
//
//--------------------------------------------------------------------------

DWORD
KerbCopyDomainRelativeSid(
    OUT PSID TargetSid,
    IN PSID  DomainId,
    IN ULONG RelativeId
    )
{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, TargetSid, DomainId ) ) ) {
        return 0;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( TargetSid ))) ++;
    *RtlSubAuthoritySid( TargetSid, DomainIdSubAuthorityCount ) = RelativeId;


    return Size;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildLocalAccountToken
//
//  Synopsis:   Creates a token from a mapped kerberos principal
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
/*
NTSTATUS
KerbBuildLocalAccountToken(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PLUID LogonId,
    IN PUNICODE_STRING MappedClientName,
    IN PKERB_INTERACTIVE_LOGON KerbLogonInfo,
    OUT PLSA_TOKEN_INFORMATION_TYPE LogonSession,
    OUT PVOID * NewTokenInformation,
    OUT PULONG ProfileBufferLength,
    OUT PVOID * ProfileBuffer,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCreds
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    SECPKG_CLIENT_INFO ClientInfo;
    PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;
    SAMPR_HANDLE SamHandle = NULL;
    SAMPR_HANDLE DomainHandle = NULL;
    SAMPR_HANDLE UserHandle = NULL;
    PSAMPR_GET_GROUPS_BUFFER Groups = NULL;
    SID_AND_ATTRIBUTES_LIST TransitiveGroups = {0};
    PSAMPR_USER_INFO_BUFFER UserInfo = NULL;
    PPACTYPE LocalPac = NULL;
    SAMPR_ULONG_ARRAY RidArray;
    SAMPR_ULONG_ARRAY UseArray;


    *ProfileBuffer = NULL;
    *NewTokenInformation = NULL;

    //
    // Verify that the caller has TCB privilege. Otherwise anyone can forge
    // a ticket to themselves to logon with any name in the list.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    if (!ClientInfo.HasTcbPrivilege)
    {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // Call the LSA to get our domain sid
    //
    Status = LsaIQueryInformationPolicyTrusted(
                PolicyAccountDomainInformation,
                &PolicyInfo
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "LsaIQueryInformationPolicyTrusted failed - %x\n", Status));
        goto Cleanup;
    }

    //
    // Open SAM to get the account information
    //
    Status = SamIConnect(
                NULL,                   // no server name
                &SamHandle,
                0,                      // no desired access
                TRUE                    // trusted caller
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SamIConnectFailed - %x\n", Status));
        goto Cleanup;
    }

    Status = SamrOpenDomain(
                SamHandle,
                0,                      // no desired access
                (PRPC_SID) PolicyInfo->PolicyAccountDomainInfo.DomainSid,
                &DomainHandle
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SamrOpenDomain failed - %x\n", Status));
        goto Cleanup;
    }

    Status = SamrLookupNamesInDomain(
                    DomainHandle,
                    1,
                    (PRPC_UNICODE_STRING) MappedClientName,
                    &RidArray,
                    &UseArray
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SamrOpenDomain failed - %x\n", Status));
        goto Cleanup;
    }

    if ((UseArray.Element[0] != SidTypeUser) &&
        (UseArray.Element[0] != SidTypeComputer))
    {
        Status = STATUS_NONE_MAPPED;
        goto Cleanup;
    }

    Status = SamrOpenUser(
                DomainHandle,
                0,                      // no desired access,
                RidArray.Element[0],
                &UserHandle
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = SamrQueryInformationUser(
        UserHandle,
        UserAllInformation,
        &UserInfo
        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = SamrGetGroupsForUser(
                UserHandle,
                &Groups
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbGlobalReadLock();
    Status = KerbDuplicateString(
                    &LocalMachineName,
                    &KerbGlobalMachineName
                    );

    KerbGlobalReleaseLock();

    if(!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalMachineName\n"));
        goto Cleanup;
    }


    //
    // Set the password must changes time to inifinite because we don't
    // want spurious password must change popups
    //

    UserInfo->All.PasswordMustChange = *(POLD_LARGE_INTEGER) &KerbGlobalWillNeverTime;

    //
    // *Don't build a PAC, that's extra effort in marshalling unmarshalling
    // data we can just convert over from Samuserall to Netlogon_Validation_Info
    //













}   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\krbevent.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       events.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1-03-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include <kerb.hxx>
#include <kerbp.h>
#include "krbevent.h"
#include "kerbevt.h"
#include <limits.h>

#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


HANDLE  KerbEventLogHandle = NULL;
WCHAR   KerbEventSourceName[] = L"Kerberos";


//+-------------------------------------------------------------------------
//
//  Function:   KerbErrorToString
//
//  Synopsis:   returns a string from the data segment pointing to the name
//              of an error
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


LPWSTR
KerbErrorToString(
                 IN KERBERR KerbErr
                 )
{
   LPWSTR String;
   switch (KerbErr)
   {
   case KDC_ERR_NONE                  : String = L"KDC_ERR_NONE"; break;
   case KDC_ERR_NAME_EXP              : String = L"KDC_ERR_NAME_EXP"; break;
   case KDC_ERR_SERVICE_EXP           : String = L"KDC_ERR_SERVICE_EXP"; break;
   case KDC_ERR_BAD_PVNO              : String = L"KDC_ERR_BAD_PVNO"; break;
   case KDC_ERR_C_OLD_MAST_KVNO       : String = L"KDC_ERR_C_OLD_MAST_KVNO"; break;
   case KDC_ERR_S_OLD_MAST_KVNO       : String = L"KDC_ERR_S_OLD_MAST_KVNO"; break;
   case KDC_ERR_C_PRINCIPAL_UNKNOWN   : String = L"KDC_ERR_C_PRINCIPAL_UNKNOWN"; break;
   case KDC_ERR_S_PRINCIPAL_UNKNOWN   : String = L" KDC_ERR_S_PRINCIPAL_UNKNOWN"; break;
   case KDC_ERR_PRINCIPAL_NOT_UNIQUE  : String = L"KDC_ERR_PRINCIPAL_NOT_UNIQUE"; break;
   case KDC_ERR_NULL_KEY              : String = L"KDC_ERR_NULL_KEY"; break;
   case KDC_ERR_CANNOT_POSTDATE       : String = L"KDC_ERR_CANNOT_POSTDATE"; break;
   case KDC_ERR_NEVER_VALID           : String = L"KDC_ERR_NEVER_VALID"; break;
   case KDC_ERR_POLICY                : String = L"KDC_ERR_POLICY"; break;
   case KDC_ERR_BADOPTION             : String = L"KDC_ERR_BADOPTION"; break;
   case KDC_ERR_ETYPE_NOTSUPP         : String = L"KDC_ERR_ETYPE_NOTSUPP"; break;
   case KDC_ERR_SUMTYPE_NOSUPP        : String = L"KDC_ERR_SUMTYPE_NOSUPP"; break;
   case KDC_ERR_PADATA_TYPE_NOSUPP    : String = L"KDC_ERR_PADATA_TYPE_NOSUPP"; break;
   case KDC_ERR_TRTYPE_NO_SUPP        : String = L"KDC_ERR_TRTYPE_NO_SUPP"; break;
   case KDC_ERR_CLIENT_REVOKED        : String = L"KDC_ERR_CLIENT_REVOKED"; break;
   case KDC_ERR_SERVICE_REVOKED       : String = L"KDC_ERR_SERVICE_REVOKED"; break;
   case KDC_ERR_TGT_REVOKED           : String = L"KDC_ERR_TGT_REVOKED"; break;
   case KDC_ERR_CLIENT_NOTYET         : String = L"KDC_ERR_CLIENT_NOTYET"; break;
   case KDC_ERR_SERVICE_NOTYET        : String = L"KDC_ERR_SERVICE_NOTYET"; break;
   case KDC_ERR_KEY_EXPIRED           : String = L"KDC_ERR_KEY_EXPIRED"; break;
   case KDC_ERR_PREAUTH_FAILED        : String = L"KDC_ERR_PREAUTH_FAILED"; break;
   case KDC_ERR_PREAUTH_REQUIRED      : String = L"KDC_ERR_PREAUTH_REQUIRED"; break;
   case KDC_ERR_SERVER_NOMATCH        : String = L"KDC_ERR_SERVER_NOMATCH"; break;
   case KDC_ERR_SVC_UNAVAILABLE       : String = L"KDC_ERR_SVC_UNAVAILABLE"; break;

   case KRB_AP_ERR_BAD_INTEGRITY      : String = L"KRB_AP_ERR_BAD_INTEGRITY"; break;
   case KRB_AP_ERR_TKT_EXPIRED        : String = L"KRB_AP_ERR_TKT_EXPIRED"; break;
   case KRB_AP_ERR_TKT_NYV            : String = L"KRB_AP_ERR_TKT_NYV"; break;
   case KRB_AP_ERR_REPEAT             : String = L"KRB_AP_ERR_REPEAT"; break;
   case KRB_AP_ERR_NOT_US             : String = L"KRB_AP_ERR_NOT_US"; break;
   case KRB_AP_ERR_BADMATCH           : String = L"KRB_AP_ERR_BADMATCH"; break;
   case KRB_AP_ERR_SKEW               : String = L"KRB_AP_ERR_SKEW"; break;
   case KRB_AP_ERR_BADADDR            : String = L"KRB_AP_ERR_BADADDR"; break;
   case KRB_AP_ERR_BADVERSION         : String = L"KRB_AP_ERR_BADVERSION"; break;
   case KRB_AP_ERR_MSG_TYPE           : String = L"KRB_AP_ERR_MSG_TYPE"; break;
   case KRB_AP_ERR_MODIFIED           : String = L"KRB_AP_ERR_MODIFIED"; break;
   case KRB_AP_ERR_BADORDER           : String = L"KRB_AP_ERR_BADORDER"; break;
   case KRB_AP_ERR_BADKEYVER          : String = L"KRB_AP_ERR_BADKEYVER"; break;
   case KRB_AP_ERR_NOKEY              : String = L"KRB_AP_ERR_NOKEY"; break;
   case KRB_AP_ERR_MUT_FAIL           : String = L"KRB_AP_ERR_MUT_FAIL"; break;
   case KRB_AP_ERR_BADDIRECTION       : String = L"KRB_AP_ERR_BADDIRECTION"; break;
   case KRB_AP_ERR_METHOD             : String = L"KRB_AP_ERR_METHOD"; break;
   case KRB_AP_ERR_BADSEQ             : String = L"KRB_AP_ERR_BADSEQ"; break;
   case KRB_AP_ERR_INAPP_CKSUM        : String = L"KRB_AP_ERR_INAPP_CKSUM"; break;
   case KRB_AP_PATH_NOT_ACCEPTED      : String = L"KRB_AP_PATH_NOT_ACCEPTED"; break;
   case KRB_ERR_RESPONSE_TOO_BIG      : String = L"KRB_ERR_RESPONSE_TOO_BIG"; break;

   case KRB_ERR_GENERIC               : String = L"KRB_ERR_GENERIC"; break;
   case KRB_ERR_FIELD_TOOLONG         : String = L"KRB_ERR_FIELD_TOOLONG"; break;


   case KDC_ERR_CLIENT_NOT_TRUSTED    : String = L"KDC_ERR_CLIENT_NOT_TRUSTED"; break;
   case KDC_ERR_KDC_NOT_TRUSTED       : String = L"KDC_ERR_KDC_NOT_TRUSTED"; break;
   case KDC_ERR_INVALID_SIG           : String = L"KDC_ERR_INVALID_SIG"; break;
   case KDC_ERR_KEY_TOO_WEAK          : String = L"KDC_ERR_KEY_TOO_WEAK"; break;
   case KRB_AP_ERR_USER_TO_USER_REQUIRED : String = L"KRB_AP_ERR_USER_TO_USER_REQUIRED"; break;
   case KRB_AP_ERR_NO_TGT             : String = L"KRB_AP_ERR_NO_TGT"; break;
   case KDC_ERR_WRONG_REALM           : String = L"KDC_ERR_WRONG_REALM"; break;
   default                            : String = L"Unknown Error"; break;

   }
   return(String);
}




//+---------------------------------------------------------------------------
//
//  Function:   InitializeEvents
//
//  Synopsis:   Connects to event log service
//
//  Arguments:  (none)
//
//  History:    1-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
KerbInitializeEvents(
    VOID
    )
{
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitEventLogHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbInitEventLogHandle()
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (KerbEventLogHandle == NULL)
    {
        HANDLE EventLogHandle;

        //
        // open an instance of kerb event sources, that discards duplicate
        // events in a one hour window.
        //

        EventLogHandle = NetpEventlogOpen( KerbEventSourceName, 60000*60 );      
        if (EventLogHandle != NULL)
        {
            //
            // atomically store the new handle value.  If there was a race,
            // free the one we just created.
            //
            
            if(InterlockedCompareExchangePointer(
                        &KerbEventLogHandle,
                        EventLogHandle,
                        NULL
                        ) != NULL)
            {
                NetpEventlogClose( EventLogHandle );    
            }
        }

        if (KerbEventLogHandle == NULL)
        {
            D_DebugLog((DEB_ERROR, "Could not open event log, error %d. %ws, line %d - %x\n", GetLastError(), THIS_FILE, __LINE__, Status));
            return STATUS_EVENTLOG_CANT_START;
        }
    }
    
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbReportNtstatus
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
#define MAX_NTSTATUS_STRINGS 10
#define MAX_ULONG_STRING 20
VOID
KerbReportNtstatus(
    IN ULONG ErrorClass,
    IN NTSTATUS Status,
    IN LPWSTR* ErrorStrings,
    IN ULONG NumberOfStrings,
    IN PULONG Data,
    IN ULONG NumberOfUlong
    )
{
    ULONG   StringCount, i, j, allocstart = 0;
    LPWSTR  Strings[MAX_NTSTATUS_STRINGS];
    

    StringCount = NumberOfUlong + NumberOfStrings;

    if (StringCount > MAX_NTSTATUS_STRINGS)
    {
        return;
    }

    //
    // Validate params
    //
    switch (ErrorClass)
    {
    case KERBEVT_INSUFFICIENT_TOKEN_SIZE:
        if ((NumberOfStrings != 0) || (NumberOfUlong > 3))
        {
            DsysAssert(FALSE);
            return;
        }
        break;

    default:
        return;
    }


    if (KerbEventLogHandle == NULL)
    {
        NTSTATUS TmpStatus;
        TmpStatus = KerbInitEventLogHandle();
        if (TmpStatus != STATUS_SUCCESS)
        {
            return;
        }
    }



    ZeroMemory( Strings, (StringCount * sizeof(Strings[0])) );

    for (i = 0; i < NumberOfStrings; i++)
    {
        Strings[i] = ErrorStrings[i];
    }

    allocstart = i; // save for cleanup

    for (j = 0; j < NumberOfUlong; j++)
    {
        UNICODE_STRING DummyString = { MAX_ULONG_STRING, MAX_ULONG_STRING, NULL};

        DummyString.Buffer = (LPWSTR) LsaFunctions->AllocatePrivateHeap(MAX_ULONG_STRING);
        if ( DummyString.Buffer == NULL )
        {
            goto Cleanup;
        }

        //
        // Use this since they don't export
        // RtlIntegerToUnicode(), and we don't want to
        // bring in _itow.
        //
        RtlIntegerToUnicodeString(
                Data[j],
                16,
                &DummyString
                );

        Strings[i] = DummyString.Buffer;

        i++;
    }


    if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                KerbEventLogHandle,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                ErrorClass,
                                (WORD) StringCount,
                                sizeof(NTSTATUS),
                                Strings,
                                &Status
                                ))
    {
        D_DebugLog((DEB_ERROR,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
    }


Cleanup:

    for (i = allocstart ; i < (allocstart+NumberOfUlong) ; i++)
    {
        if (Strings[i] != NULL)
        {
            LsaFunctions->FreePrivateHeap(Strings[i]);
        }
    }

    return;
}









//+-------------------------------------------------------------------------
//
//  Function:   KerbReportKerbError
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReportKerbError(
                   IN OPTIONAL PKERB_INTERNAL_NAME PrincipalName,
                   IN OPTIONAL PUNICODE_STRING PrincipalRealm,
                   IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
                   IN OPTIONAL PKERB_CREDENTIAL Credential,
                   IN ULONG KlinInfo,
                   IN OPTIONAL PKERB_ERROR ErrorMsg,
                   IN ULONG KerbError,
                   IN OPTIONAL PKERB_EXT_ERROR pExtendedError,
                   IN BOOLEAN RequiredEvent
                   )
{
#ifdef WIN32_CHICAGO
   return;
#else
   UNICODE_STRING ClientRealm = {0};
   UNICODE_STRING ClientName = {0};
   UNICODE_STRING ServerRealm = {0};
   UNICODE_STRING ServerName = {0};
   UNICODE_STRING ErrorText = {0};
   UNICODE_STRING LogonSessionName = {0};
   UNICODE_STRING TargetFullName = {0};
   WCHAR ClientTime[50] = {0};
   WCHAR ServerTime[50] = {0};
   WCHAR LineString[12] = {0};
   WCHAR ErrorCode[12] = {0};
   WCHAR ExtendedError[128] = {0};
   KERBERR KerbErr;
   ULONG NameType;
   NTSTATUS Status = STATUS_SUCCESS;
   STRING KerbString = {0};
#define KERB_ERROR_STRING_COUNT 13
   LPWSTR Strings[KERB_ERROR_STRING_COUNT];
   ULONG RawDataSize = 0;
   PVOID RawData = NULL;
   ULONG Index;


    if (!RequiredEvent || KerbGlobalLoggingLevel == 0)
    {
        return;
    }

    if (KerbEventLogHandle == NULL)
    {
        Status = KerbInitEventLogHandle();
        if (Status != STATUS_SUCCESS)
        {
            return;
        }
    }


   //
   // Get the user name from the logon session
   //
   if (ARGUMENT_PRESENT(LogonSession))
   {
      KerbReadLockLogonSessions( LogonSession );
      KerbErr = KerbBuildFullServiceName(
                                        &LogonSession->PrimaryCredentials.DomainName,
                                        &LogonSession->PrimaryCredentials.UserName,
                                        &LogonSessionName
                                        );

      KerbUnlockLogonSessions( LogonSession );

      if (!KERB_SUCCESS(KerbErr))
      {
         goto Cleanup;
      }
   }

   if (ARGUMENT_PRESENT(pExtendedError))
   {
      swprintf(ExtendedError, L"0x%x KLIN(%x)", pExtendedError->status, pExtendedError->klininfo);
   }

   if (ARGUMENT_PRESENT(PrincipalName) && ARGUMENT_PRESENT(PrincipalRealm))
   {
      KerbConvertKdcNameToString(
                                &TargetFullName,
                                PrincipalName,
                                PrincipalRealm
                                );
   }

   swprintf(LineString, L"%x", KlinInfo);

   if (ARGUMENT_PRESENT(ErrorMsg))
   {
      swprintf(ErrorCode, L"0x%x", ErrorMsg->error_code);


   //
   // Get the client and server realms
   //

   if ((ErrorMsg->bit_mask & client_realm_present) != 0)
   {
      KerbErr = KerbConvertRealmToUnicodeString(
                                               &ClientRealm,
                                               &ErrorMsg->client_realm
                                               );
      if (!KERB_SUCCESS(KerbErr))
      {
         goto Cleanup;
      }
   }

   if (ErrorMsg->realm != NULL)
   {
      KerbErr = KerbConvertRealmToUnicodeString(
                                               &ServerRealm,
                                               &ErrorMsg->realm
                                               );
      if (!KERB_SUCCESS(KerbErr))
      {
         goto Cleanup;
      }
   }

   if ((ErrorMsg->bit_mask & KERB_ERROR_client_name_present) != 0)
   {
      KerbErr = KerbConvertPrincipalNameToString(
                                                &ClientName,
                                                &NameType,
                                                &ErrorMsg->KERB_ERROR_client_name
                                                );
      if (!KERB_SUCCESS(KerbErr))
      {
         goto Cleanup;
      }
   }

   KerbErr = KerbConvertPrincipalNameToString(
                                             &ServerName,
                                             &NameType,
                                             &ErrorMsg->server_name
                                             );
   if (!KERB_SUCCESS(KerbErr))
   {
      goto Cleanup;
   }

   if ((ErrorMsg->bit_mask & client_time_present) != 0)
   {
      swprintf(ClientTime,L"%d:%d:%d.%04d %d/%d/%d %ws",
               ErrorMsg->client_time.hour,
               ErrorMsg->client_time.minute,
               ErrorMsg->client_time.second,
               ErrorMsg->client_time.millisecond,
               ErrorMsg->client_time.month,
               ErrorMsg->client_time.day,
               ErrorMsg->client_time.year,
               (ErrorMsg->client_time.universal) ? L"Z" : L""
              );
   }

   swprintf(ServerTime,L"%d:%d:%d.%04d %d/%d/%d %ws",
            ErrorMsg->server_time.hour,
            ErrorMsg->server_time.minute,
            ErrorMsg->server_time.second,
            ErrorMsg->server_time.millisecond,
            ErrorMsg->server_time.month,
            ErrorMsg->server_time.day,
            ErrorMsg->server_time.year,
            (ErrorMsg->server_time.universal) ? L"Z" : L""
           );

      if (((ErrorMsg->bit_mask & error_text_present) != 0) &&
          (ErrorMsg->error_text.length < SHRT_MAX))
      {
         KerbString.Buffer = ErrorMsg->error_text.value;
         KerbString.Length = (USHORT) ErrorMsg->error_text.length;

         KerbErr = KerbStringToUnicodeString(
                                            &ErrorText,
                                            &KerbString
                                            );
         if (!KERB_SUCCESS(KerbErr))
         {
            goto Cleanup;
         }
      }

      if ((ErrorMsg->bit_mask & error_data_present) != 0)
      {
         RawDataSize = ErrorMsg->error_data.length;
         RawData = ErrorMsg->error_data.value;
      }

   }
   else
   {
      swprintf(ErrorCode, L"0x%x", KerbError);
   }

   //
   // Build the array of strings
   //

   Strings[0] = LineString;
   Strings[1] = LogonSessionName.Buffer;
   Strings[2] = ClientTime;
   Strings[3] = ServerTime;
   Strings[4] = ErrorCode;
   Strings[5] = (ARGUMENT_PRESENT(ErrorMsg)
                 ? KerbErrorToString(ErrorMsg->error_code) :
                   KerbErrorToString(KerbError));

   Strings[6] = ExtendedError;
   Strings[7] = ClientRealm.Buffer;
   Strings[8] = ClientName.Buffer;
   Strings[9] = ServerRealm.Buffer;
   Strings[10] = ServerName.Buffer;
   Strings[11] = TargetFullName.Buffer;
   Strings[12] = ErrorText.Buffer;


   //
   // Replace NULLs with an empty string.
   //

   for (Index = 0; Index < KERB_ERROR_STRING_COUNT ; Index++ )
   {
      if (Strings[Index] == NULL)
      {
         Strings[Index] = L"";
      }
   }

   if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                KerbEventLogHandle,
                                EVENTLOG_ERROR_TYPE,
                                0,
                                KERBEVT_KERB_ERROR_MSG,
                                KERB_ERROR_STRING_COUNT,
                                RawDataSize,
                                Strings,
                                RawData
                                ))
   {
      D_DebugLog((DEB_ERROR,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
   }

Cleanup:

   KerbFreeString( &LogonSessionName );
   KerbFreeString( &ClientRealm );
   KerbFreeString( &ClientName );
   KerbFreeString( &ServerRealm );
   KerbFreeString( &ServerName );
   KerbFreeString( &ErrorText );
   KerbFreeString( &TargetFullName );


}



//+-------------------------------------------------------------------------
//
//  Function:   KerbReportApModifiedError
//
//  Synopsis:   Reports error of type KRB_AP_ERR_MODIFIED
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

#define MAX_STRINGS 2
VOID
KerbReportApError(
   PKERB_ERROR ErrorMsg
   )
{


   KERBERR KerbErr;
   LPWSTR  Strings[MAX_STRINGS] = {NULL, NULL};
   DWORD   EventId = 0, dwDataSize = 0;
   WORD StringCount = MAX_STRINGS;
   LPVOID  lpRawData = NULL;
   UNICODE_STRING ServerName = {0};
   UNICODE_STRING ServerRealm = {0};
   ULONG NameType;
   NTSTATUS Status;

    if (KerbEventLogHandle == NULL)
    {
        Status = KerbInitEventLogHandle();
        if (Status != STATUS_SUCCESS)
        {
            return;
        }
    }

   KerbErr = KerbConvertPrincipalNameToString(
                                          &ServerName,
                                          &NameType,
                                          &ErrorMsg->server_name
                                          );
   if (!KERB_SUCCESS(KerbErr))
   {
      goto Cleanup;
   }

   if (ErrorMsg->realm != NULL)
   {
      KerbErr = KerbConvertRealmToUnicodeString(
                                               &ServerRealm,
                                               &ErrorMsg->realm
                                               );
      if (!KERB_SUCCESS(KerbErr))
      {
         goto Cleanup;
      }
   }

   Strings[0] = ServerName.Buffer;
   Strings[1] = ServerRealm.Buffer;

   switch (ErrorMsg->error_code)
   {
   case KRB_AP_ERR_MODIFIED:
      EventId = KERBEVT_KRB_AP_ERR_MODIFIED;
      break;
   case KRB_AP_ERR_TKT_NYV:
      EventId = KERBEVT_KRB_AP_ERR_TKT_NYV;
      break;
   default:
      D_DebugLog((DEB_ERROR, "Unknown error to KerbReportApError  %x\n", ErrorMsg->error_code));
      goto Cleanup;
   }


   if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                KerbEventLogHandle,
                                EVENTLOG_ERROR_TYPE,
                                0,
                                EventId,
                                StringCount,
                                dwDataSize,
                                Strings,
                                lpRawData
                                ))
   {
      D_DebugLog((DEB_ERROR,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
   }

Cleanup:

   KerbFreeString( &ServerRealm );
   KerbFreeString( &ServerName );

}



#endif // WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbShutdownEvents
//
//  Synopsis:   Shutsdown event log reporting
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbShutdownEvents(
    VOID
    )
{
    HANDLE EventLogHandle;
    
    EventLogHandle = InterlockedExchangePointer( &KerbEventLogHandle, NULL );

    if( EventLogHandle )
    {
        NetpEventlogClose( EventLogHandle );
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbReportPACError
//
//  Synopsis:   Reports error of type KERBEVT_KRB_PAC_VERIFICATION_FAILURE
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReportPACError(
    PUNICODE_STRING ClientName,
    PUNICODE_STRING ClientDomain,
    NTSTATUS        FailureStatus
    )
{
   KERBERR KerbErr;
   LPWSTR  Strings[MAX_STRINGS] = {NULL, NULL};
   NTSTATUS Status;
   
   if (KerbEventLogHandle == NULL)
   {
       Status = KerbInitEventLogHandle();
       if (Status != STATUS_SUCCESS)
       {
           return;
       }
   }

   Strings[0] = ClientName->Buffer;    // this is null terminated in this case
   Strings[1] = ClientDomain->Buffer;  // this is null terminated in this case

   if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                KerbEventLogHandle,
                                EVENTLOG_ERROR_TYPE,
                                0,
                                KERBEVT_KRB_PAC_VERIFICATION_FAILURE,
                                2,
                                sizeof(NTSTATUS),
                                Strings,
                                &FailureStatus
                                ))
   {
      D_DebugLog((DEB_ERROR,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
   }

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbReportPkinit
//
//  Synopsis:   Reports errors generated by invalid client certificates
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReportPkinitError(
    IN ULONG PolicyStatus,
    IN OPTIONAL PCCERT_CONTEXT KdcCert
    )
{
   KERBERR KerbErr;
   LPWSTR  Strings[MAX_STRINGS] = {NULL, NULL};
   WCHAR SubjectName[DNS_MAX_NAME_LENGTH + 1];
   DWORD NameMaxLength = DNS_MAX_NAME_LENGTH + 1;
   DWORD SubjectLength;
   NTSTATUS Status;
   ULONG StringCount = 0;
   
   if (KerbEventLogHandle == NULL)
   {
       Status = KerbInitEventLogHandle();
       if (Status != STATUS_SUCCESS)
       {
           return;
       }
   }

   if (ARGUMENT_PRESENT(KdcCert))
   {
       RtlZeroMemory(
            &SubjectName,
            NameMaxLength
            );
       

       SubjectLength = CertNameToStr(
                          X509_ASN_ENCODING,
                          &KdcCert->pCertInfo->Subject,
                          CERT_NAME_DNS_TYPE,
                          SubjectName,
                          NameMaxLength
                          );

       if (SubjectLength != 0)
       {
           Strings[0] = SubjectName;
           StringCount++;
       }                            

   }

   
   if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                KerbEventLogHandle,
                                EVENTLOG_ERROR_TYPE,
                                0,
                                (ARGUMENT_PRESENT(KdcCert) ? 
                                 KERBEVT_BAD_KDC_CERTIFICATE : 
                                 KERBEVT_BAD_CLIENT_CERTIFICATE),
                                StringCount,
                                sizeof(ULONG),
                                Strings,
                                &PolicyStatus
                                ))
   {
      D_DebugLog((DEB_ERROR,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\krbaudit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        krbaudit.h
//
// Contents:    Auditing routines
//
//
// History:     27-April-2001   Created         kumarp
//
//------------------------------------------------------------------------

NTSTATUS
KerbGetLogonGuid(
    IN  PKERB_PRIMARY_CREDENTIAL  pPrimaryCredentials,
    IN  PKERB_ENCRYPTED_KDC_REPLY pKdcReplyBody,
    OUT LPGUID pLogonGuid
    );


NTSTATUS
KerbGenerateAuditForLogonUsingExplicitCreds(
    IN PKERB_LOGON_SESSION CurrentUserLogonSession,
    IN PKERB_PRIMARY_CREDENTIAL NewUserPrimaryCredentials,
    IN LPGUID pNewUserLogonGuid
    );

NTSTATUS
KerbAuditLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PKERB_ENCRYPTED_TICKET pEncryptedTicket,
    IN PSID pUserSid,
    IN PUNICODE_STRING pWorkstationName,
    IN PLUID pLogonId
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\krbevent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       krbevent.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    05-Oct-98       MikeSw          Created
//
//----------------------------------------------------------------------------

#ifndef __KRBEVENT_H__
#define __KRBEVENT_H__

#define KERB_FUNC_INIT_CONTEXT          L"InitializeSecurityContext"
#define KERB_FUNC_ACCEPT_CONTEXT        L"AcceptSecurityContext"
#define KERB_FUNC_LOGON_USER            L"LogonUser"
#define KERB_FUNC_ACQUIRE_CREDS         L"AcquireCredentialsHandle"
#define KERB_FUNC_CHANGE_PASSWORD       L"ChangePassword"
#define KERB_FUNC_BUILD_PREAUTH         L"BuildPreAuthDataForRealm"


#ifndef WIN32_CHICAGO
NTSTATUS
KerbInitializeEvents(void);


VOID
KerbReportPACError(
    PUNICODE_STRING ClientName,
    PUNICODE_STRING ClientDomain,
    NTSTATUS        FailureStatus
    );



VOID
KerbReportPkinitError(
    ULONG PolicyStatus,
    IN OPTIONAL PCCERT_CONTEXT KdcCert
    );



VOID
KerbReportKerbError(
                   IN OPTIONAL PKERB_INTERNAL_NAME PrincipalName,
                   IN OPTIONAL PUNICODE_STRING PrincipalRealm,
                   IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
                   IN OPTIONAL PKERB_CREDENTIAL Credential,
                   IN ULONG KlinInfo,
                   IN OPTIONAL PKERB_ERROR ErrorMsg,
                   IN ULONG KerbError,
                   IN OPTIONAL PKERB_EXT_ERROR pExtendedError,
                   IN BOOLEAN RequiredEvent
                   );


VOID
KerbReportApError(
   PKERB_ERROR ErrorMessage
   );

VOID
KerbReportNtstatus(
    IN ULONG ErrorClass,
    IN NTSTATUS Status,
    IN LPWSTR* ErrorStrings,
    IN ULONG NumberOfStrings,
    IN PULONG Data,
    IN ULONG NumberOfUlong
    );








VOID
KerbShutdownEvents(void);

#else // WIN32_CHICAGO

#define KerbInitializeEvents() (STATUS_SUCCESS)
#define KerbShutdownEvents() (TRUE)
#define KerbReportKerbError(_a_,_b_,_u_,_v_,_w_,_x_,_y_,_z_)
#define KerbReportApError(_a_)
#endif

#endif //  __KRBEVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\krbaudit.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        krbaudit.cxx
//
// Contents:    Auditing routines
//
//
// History:     27-April-2001   Created         kumarp
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <krbaudit.h>


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetLogonGuid
//
//  Synopsis:   Gets a unique ID based on certain fields in the ticket
//
//  Arguments:  pPrimaryCredentials -- primary credentials
//              pKdcReplyBody       -- kdc reply structure
//              pLogonGuid          -- returned GUID
//
//  Returns:    NTSTATUS code
//
//  Notes:      The generated GUID is MD5 hash of 3 fields:
//                -- client name
//                -- client realm
//                -- ticket start time
//                
//              All of these fields are available at client/kdc/server machine.
//              this allows us to generate the same unique ID on these machines
//              without having to introduce a new field in the ticket.
//              This GUID is used in audit events allowing us to correlate
//              events on three different machines.
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetLogonGuid(
    IN  PKERB_PRIMARY_CREDENTIAL  pPrimaryCredentials,
    IN  PKERB_ENCRYPTED_KDC_REPLY pKdcReplyBody,
    OUT LPGUID pLogonGuid
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    // ISSUE-2001/04/28-kumarp : use KERB_ENCRYPTED_KDC_REPLY_starttime_present
    //if ( KdcReplyBody->flags & KERB_ENCRYPTED_KDC_REPLY_starttime_present )
    if ( pKdcReplyBody && pPrimaryCredentials )
    {

        Status = LsaIGetLogonGuid(
                     &pPrimaryCredentials->UserName,
                     &pPrimaryCredentials->DomainName,
                     (PBYTE) &pKdcReplyBody->starttime,
                     sizeof(KERB_TIME),
                     pLogonGuid
                     );

        if (!NT_SUCCESS(Status))
        {
            RtlZeroMemory( pLogonGuid, sizeof(GUID) );
        }
    }
    
    return Status;
}
    


//+-------------------------------------------------------------------------
//
//  Function:   KerbGenerateAuditForLogonUsingExplicitCreds
//
//  Synopsis:   Generate an audit event to indicate that somebody logged on
//              by supplying explicit credentials.
//
//  Arguments:  pCurrentUserLogonSession   -- logon session of the user
//                                            who supplied credentials of
//                                            another user
//              pNewUserPrimaryCredentials -- supplied primary credentials
//              pNewUserLogonGuid          -- logon GUID for the new logon
//
//  Returns:    NTSTATUS code
//
//  Notes:      This event covers credentials obtain from credman
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGenerateAuditForLogonUsingExplicitCreds(
    IN PKERB_LOGON_SESSION pCurrentUserLogonSession,
    IN PKERB_PRIMARY_CREDENTIAL pNewUserPrimaryCredentials,
    IN LPGUID pNewUserLogonGuid
      )
{
    NTSTATUS Status = STATUS_SUCCESS;
    GUID CurrentUserLogonGuid;
    LPGUID pCurrentUserLogonGuid = NULL;
    PKERB_TICKET_CACHE_ENTRY pTicketCacheEntry = NULL;
    UNICODE_STRING OurDomainName = { 0 };
    KERB_TIME CurrentUserStartTime = { 0 };

    //
    // calculate LogonGuid for current logged on user
    // we need the following 3 parameters for this:
    //   -- client name
    //   -- client realm
    //   -- ticket start time
    //
    if ( !(pCurrentUserLogonSession->LogonSessionFlags &
           (KERB_LOGON_LOCAL_ONLY | KERB_LOGON_DEFERRED)) )
    {
        Status = KerbGetOurDomainName( &OurDomainName );

        ASSERT( NT_SUCCESS(Status) && L"KerbGenerateAuditForLogonUsingExplicitCreds: KerbGetOurDomainName failed" );
        
        if (NT_SUCCESS(Status))
        {
            //
            // find the cached ticket for the local machine from
            // the ticket cache of the current logon session.
            //
            pTicketCacheEntry =
                KerbLocateTicketCacheEntry(
                    &pCurrentUserLogonSession->PrimaryCredentials.ServerTicketCache,
                    KerbGlobalMitMachineServiceName,
                    &OurDomainName
                    );

            if ( pTicketCacheEntry )
            {
                //
                // Convert start time to the format we want.
                //
                KerbConvertLargeIntToGeneralizedTime(
                    &CurrentUserStartTime,
                    NULL,
                    &pTicketCacheEntry->StartTime
                    );

                //
                // Generate the logon GUID
                //
                Status = LsaIGetLogonGuid(
                             &pCurrentUserLogonSession->PrimaryCredentials.UserName,
                             &pCurrentUserLogonSession->PrimaryCredentials.DomainName,
                             (PBYTE) &CurrentUserStartTime,
                             sizeof(KERB_TIME),
                             &CurrentUserLogonGuid
                             );
                if (NT_SUCCESS(Status))
                {
                    pCurrentUserLogonGuid = &CurrentUserLogonGuid;
                }
            }
            else
            {
                D_DebugLog((DEB_TRACE, "KerbGenerateAuditForLogonUsingExplicitCreds: could not locate ticket"));
            }                                                                                                   
        }
                                       
        KerbFreeString(&OurDomainName);

    }
#if DBG
    else
    {
        //
        // KERB_LOGON_LOCAL_ONLY indicates a logon using non Kerberos package.
        // Logon GUID is supported only by Kerberos therefore its generation
        // is skipped.
        //
        if (pCurrentUserLogonSession->LogonSessionFlags & KERB_LOGON_LOCAL_ONLY)
        {
            D_DebugLog((DEB_TRACE,"KerbGenerateAuditForLogonUsingExplicitCreds: LogonSession %p has KERB_LOGON_LOCAL_ONLY\n", pCurrentUserLogonSession));
        }

        //
        // KERB_LOGON_DEFERRED indicates that a logon occurred using
        // cached credentials because kdc was not available.  In this case,
        // we will not have a ticket for local machine therefore generation of
        // the logon GUID is skipped.
        //
        if (pCurrentUserLogonSession->LogonSessionFlags & KERB_LOGON_DEFERRED)
        {
            D_DebugLog((DEB_TRACE,"KerbGenerateAuditForLogonUsingExplicitCreds: LogonSession %p has KERB_LOGON_DEFERRED\n", pCurrentUserLogonSession));
        }
    }
#endif

    //
    // now generate the audit
    //
    Status = I_LsaIAuditLogonUsingExplicitCreds(
                 EVENTLOG_AUDIT_SUCCESS,
                 NULL,          // no user sid
                 &pCurrentUserLogonSession->PrimaryCredentials.UserName,
                 &pCurrentUserLogonSession->PrimaryCredentials.DomainName,
                 &pCurrentUserLogonSession->LogonId,
                 pCurrentUserLogonGuid,
                 &pNewUserPrimaryCredentials->UserName,
                 &pNewUserPrimaryCredentials->DomainName,
                 pNewUserLogonGuid
                 );

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAuditLogon
//
//  Synopsis:   Generate a successful logon audit event
//
//  Arguments:  LogonStatus      -- overall logon status
//              LogonSubStatus   -- sub-category within a failed logon status
//              pEncryptedTicket -- ticket used
//              pUserSid         -- user's SID
//              pWorkstationName -- logon workstation
//              pLogonId         -- logon LUID
//
//  Returns:    NTSTATUS code
//
//  Notes:      A new field (logon GUID) was added to this audit event.
//              In order to send this new field to LSA, we had two options:
//              1) add new function (AuditLogonEx) to LSA dispatch table
//              2) define a private (LsaI) function to do the job
//
//             option#2 was chosen because the logon GUID is a Kerberos only
//             feature.
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAuditLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PKERB_ENCRYPTED_TICKET pEncryptedTicket,
    IN PSID pUserSid,
    IN PUNICODE_STRING pWorkstationName,
    IN PLUID pLogonId
    )
{
    GUID LogonGuid = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;
    //PKERB_TIME pStartTime;
    UNICODE_STRING ClientRealm = { 0 };
    UNICODE_STRING ClientName = { 0 };
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG NameType;

    //
    // convert kerb style names to UNICODE_STRINGs
    //
    KerbErr = KerbConvertRealmToUnicodeString(
                  &ClientRealm,
                  &pEncryptedTicket->client_realm );
    if ( KerbErr == KDC_ERR_NONE )
    {
        KerbErr = KerbConvertPrincipalNameToString(
                      &ClientName,
                      &NameType,
                      &pEncryptedTicket->client_name
                      );
    }

    if ( KerbErr != KDC_ERR_NONE )
    {
        Status = KerbMapKerbError( KerbErr );
        goto Cleanup;
    }

    //
    // generate the logon GUID
    //
    Status = I_LsaIGetLogonGuid(
                 &ClientName,
                 &ClientRealm,
                 (PBYTE)&pEncryptedTicket->KERB_ENCRYPTED_TICKET_starttime,
                 sizeof(KERB_TIME),
                 &LogonGuid
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
        
    //
    // generate successful logon audit. use the special 
    // LsaIAuditKerberosLogon function so that we can pass in
    // the generated unique logon guid
    //
    I_LsaIAuditKerberosLogon(
        LogonStatus,
        LogonSubStatus,
        &ClientName,
        &ClientRealm,
        pWorkstationName,
        pUserSid,
        Network,
        &KerberosSource,
        pLogonId,
        &LogonGuid
        );
    
 Cleanup:
    if (ClientRealm.Buffer != NULL)
    {
        KerbFreeString( &ClientRealm );
    }

    if (ClientName.Buffer != NULL)
    {
        KerbFreeString( &ClientName );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        D_DebugLog((DEB_ERROR,"KerbAuditLogon: failed: %x\n", Status ));
    }


    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\krbtoken.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        token.h
//
// Contents:    Prototypes and structures for token creation
//
//
// History:     1-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __TOKEN_H__
#define __TOKEN_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines CREDMGR_ALLOCATE
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef CREDMGR_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN TOKEN_SOURCE KerberosSource;


#ifndef WIN32_CHICAGO
#ifndef notdef
NTSTATUS
KerbCreateTokenFromTicket(
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AUTHENTICATOR InternalAuthenticator,
    IN ULONG ContextFlags,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN PUNICODE_STRING ServiceDomain,
    IN KERB_ENCRYPTION_KEY* pSessionKey,
    OUT PLUID NewLogonId,
    OUT PSID * UserSid,
    OUT PHANDLE NewTokenHandle,
    OUT PUNICODE_STRING ClientName,
    OUT PUNICODE_STRING ClientDomain
    );
#endif

NTSTATUS
KerbCreateTokenFromLogonTicket(
    IN PKERB_TICKET_CACHE_ENTRY LogonTicket,
    IN PLUID LogonId,
    IN PKERB_INTERACTIVE_LOGON LogonInfo,
    IN BOOLEAN CacheLogon,
    IN BOOLEAN RealmlessWksta,
    IN OPTIONAL PKERB_ENCRYPTION_KEY TicketKey,
    IN OPTIONAL PKERB_MESSAGE_BUFFER ForwardedTgt,
    IN OPTIONAL PUNICODE_STRING MappedClientName,
    IN OPTIONAL PKERB_INTERNAL_NAME S4UClientName,
    IN OPTIONAL PUNICODE_STRING S4UClientRealm,
    IN PKERB_LOGON_SESSION LogonSession,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *NewTokenInformation,
    OUT PULONG ProfileBufferLength,
    OUT PVOID * ProfileBuffer,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials,
    OUT PNETLOGON_VALIDATION_SAM_INFO4 * ppValidationInfo
    );

NTSTATUS
KerbMakeTokenInformationV2(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  BOOLEAN IsLocalSystem,
    OUT PLSA_TOKEN_INFORMATION_V2 *TokenInformation
    );

NTSTATUS
KerbAllocateInteractiveProfile (
    OUT PKERB_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET LogonTicket,
    IN OPTIONAL PKERB_INTERACTIVE_LOGON KerbLogonInfo
    );

VOID
KerbCacheLogonInformation(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING Password,
    IN OPTIONAL PUNICODE_STRING DnsDomainName,
    IN OPTIONAL PUNICODE_STRING Upn,
    IN BOOLEAN  MitLogon,
    IN ULONG    Flags,
    IN OPTIONAL PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    IN OPTIONAL PVOID SupplementalCreds,
    IN OPTIONAL ULONG SupplementalCredSize
    );

#endif // WIN32_CHICAGO

#endif // __TOKEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\logonapi.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        logonapi.h
//
// Contents:    Prototypes and structures for Logon support in Kerberos
//
//
// History:     19-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------


#ifndef __LOGONAPI_H__
#define __LOGONAPI_H__


NTSTATUS
KerbGetAuthenticationTicket(
    IN OUT PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING ServerRealm,
    IN PKERB_INTERNAL_NAME ClientFullName,
    IN ULONG TicketFlags,
    IN ULONG CacheFlags,
    OUT OPTIONAL PKERB_TICKET_CACHE_ENTRY * TicketCacheEntry,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PUNICODE_STRING CorrectRealm
    );

#define KERB_GET_TICKET_NO_PAC                  0x00000001
#define KERB_GET_AUTH_TICKET_NO_CANONICALIZE    0x00000002

#define KERB_CLIENT_REFERRAL_MAX 3

NTSTATUS
KerbGetTicketGrantingTicket(
    IN OUT PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    OUT OPTIONAL PKERB_TICKET_CACHE_ENTRY * TicketCacheEntry,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey
    );

BOOLEAN
KerbPurgeServiceTicketAndTgt(
     IN PKERB_CONTEXT Context,
     IN OPTIONAL LSA_SEC_HANDLE CredentialHandle,
     IN OPTIONAL PKERB_CREDMAN_CRED CredManHandle
     );

NTSTATUS
KerbGetClientNameAndRealm(
    IN OPTIONAL LUID *pLogonId,
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCreds,
    IN BOOLEAN UsingSuppliedCreds,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN OUT OPTIONAL BOOLEAN * MitRealmUsed,
    IN BOOLEAN UseWkstaRealm,
    OUT PKERB_INTERNAL_NAME * ClientName,
    OUT PUNICODE_STRING ClientRealm
    );


#endif __LOGONAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\logonapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        logonapi.cxx
//
// Contents:    Code for logon and logoff for the Kerberos package
//
//
// History:     16-April-1996   MikeSw          Created
//              15-June-2000    t-ryanj         Added event tracing support
//
//------------------------------------------------------------------------
#include <kerb.hxx>
#include <kerbp.h>

#include <utils.hxx>

#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

#define FILENO FILENO_LOGONAPI

//+-------------------------------------------------------------------------
//
//  Function:   KerbFindCommonPaEtype
//
//  Synopsis:   Finds an encryption type in common between KDC and client.
//
//  Effects:
//
//  Arguments:  Credentials - Client's credentials, must be locked
//              InputPaData - PA data from an error return from the KDC
//              UseOldPassword - if TRUE, use the old password instead of current password
//              UserKey - receives key for common encryption type
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbFindCommonPaEtype(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_PA_DATA_LIST InputPaData,
    IN BOOLEAN UseOldPassword,
    IN BOOLEAN IgnoreSaltFailures,
    OUT PKERB_ENCRYPTION_KEY * UserKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_PA_DATA InputData = NULL;
    ULONG PasswordTypes[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG PasswordCount;
    ULONG KdcEtypes[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG KdcEtypeCount = 0;
    PKERB_ETYPE_INFO * EtypeInfo = NULL;
    PKERB_ETYPE_INFO EtypeEntry;
    ULONG CommonCryptSystem;
    ULONG Index;
    PKERB_STORED_CREDENTIAL Passwords;
    BOOLEAN UseDES = FALSE;

    *UserKey = NULL;



    //
    // Check to see if the input had any interesting PA data
    //

    if ((InputPaData != NULL) && (!UseOldPassword))
    {
        InputData = KerbFindPreAuthDataEntry(
                        KRB5_PADATA_ETYPE_INFO,
                        InputPaData
                        );
        if (InputData == NULL)
        {
            //
            // If no etype-info was provided, then we are out of luck.
            // Change this to allow for utilizing default DES etype if no
            // etypeinfo specified for Heimdel KDC interop. Bug#87960
            //


            //Status = STATUS_NO_PA_DATA;
            //goto Cleanup;
            UseDES = TRUE;
        }
        else
        {
            //
            // Unpack the etype info
            //

            KerbErr = KerbUnpackData(
                        InputData->preauth_data.value,
                        InputData->preauth_data.length,
                        PKERB_ETYPE_INFO_PDU,
                        (PVOID *) &EtypeInfo
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                D_DebugLog((DEB_ERROR,"Failed to unpack ETYPE INFO: 0x%x. %ws, line%d\n",KerbErr, THIS_FILE, __LINE__));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            //
            // Build a new set of passwords
            //

            Status = KerbChangeCredentialsPassword(
                        Credentials,
                        NULL,                   // no password
                        *EtypeInfo,
                        UnknownAccount,
                        PRIMARY_CRED_CLEAR_PASSWORD
                        );
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog((DEB_ERROR,"Failed to update primary creds with new salt: 0x%x, file %ws %d\n",
                        Status, THIS_FILE, __LINE__ ));

                if (!IgnoreSaltFailures)
                {
                    //
                    // Remap the error, as we want to return a more useful error
                    //

                    if (Status == STATUS_INVALID_PARAMETER)
                    {
                        Status = STATUS_WRONG_PASSWORD;
                    }
                    goto Cleanup;
                }
                else
                {
                    Status = STATUS_SUCCESS;
                }

            }

            //
            // Build a list of crypt types from the etype info
            //

            KdcEtypeCount = 0;
            EtypeEntry = *EtypeInfo;
            while (EtypeEntry != NULL)
            {
                KdcEtypes[KdcEtypeCount++] = EtypeEntry->value.encryption_type;
                EtypeEntry = EtypeEntry->next;
                if (KdcEtypeCount == KERB_MAX_CRYPTO_SYSTEMS)
                {
                    break;
                }
            }
        }

    } else {
        ULONG OldFirstEtype;

        //
        // Include all our crypt types as supported
        //

        Status = CDBuildIntegrityVect(
                    &KdcEtypeCount,
                    KdcEtypes
                    );
        DsysAssert(NT_SUCCESS(Status));
        DsysAssert(KdcEtypeCount >= 1);

        //
        // replace the first etype with the default
        //

        if (KdcEtypes[0] != KerbGlobalDefaultPreauthEtype)
        {
            OldFirstEtype = KdcEtypes[0];
            KdcEtypes[0] = KerbGlobalDefaultPreauthEtype;

            for (Index = 1; Index < KdcEtypeCount ; Index++ )
            {
                if ( KdcEtypes[Index] == KerbGlobalDefaultPreauthEtype)
                {
                    KdcEtypes[Index] = OldFirstEtype;
                    break;
                }
            }
        }

    }

    //  Heimdal KDC compat gives us no supported EType info, so
    //  we've got to rely upon SPEC'd default, DES encryption.
    //  See bug 87960 for more info.  NOTE:  We'll try this
    //  2 times...  Should work to avoid this..
    if (UseDES) {

        ULONG OldFirstEtype;

        //
        // Include all our crypt types as supported
        //

        Status = CDBuildIntegrityVect(
                    &KdcEtypeCount,
                    KdcEtypes
                    );
        DsysAssert(NT_SUCCESS(Status));
        DsysAssert(KdcEtypeCount >= 1);

        //
        // Use **only** DES, as it should be supported by all
        // KDCs, and w/o preauth ETYPEINFO data, we would have
        // to hit every ETYPE.
        // TBD:  When Heimdal supports RC4, or if they fix their
        // padata, then pull this code.
        if (KdcEtypes[0] != KERB_ETYPE_DES_CBC_MD5)
        {
            OldFirstEtype = KdcEtypes[0];
            KdcEtypes[0] = KERB_ETYPE_DES_CBC_MD5;

            for (Index = 1; Index < KdcEtypeCount ; Index++ )
            {
                if ( KdcEtypes[Index] == KERB_ETYPE_DES_CBC_MD5)
                {
                    KdcEtypes[Index] = OldFirstEtype;
                    break;
                }
            }
        }

    }

    //
    // Build the list of passwords
    //

    if (UseOldPassword)
    {
        Passwords = Credentials->OldPasswords;
        if (Passwords == NULL)
        {
            Status = STATUS_WRONG_PASSWORD;
            goto Cleanup;
        }
    }
    else
    {
        Passwords = Credentials->Passwords;
    }



    PasswordCount = Passwords->CredentialCount;
    if (PasswordCount > KERB_MAX_CRYPTO_SYSTEMS)
    {
        DsysAssert(PasswordCount < KERB_MAX_CRYPTO_SYSTEMS);
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    for (Index = 0; Index < PasswordCount ; Index++ )
    {
        PasswordTypes[Index] = (ULONG) Passwords->Credentials[Index].Key.keytype;
    }

    //
    // Now find the common crypt system
    //


    Status = CDFindCommonCSystemWithKey(
                KdcEtypeCount,
                KdcEtypes,
                PasswordCount,
                PasswordTypes,
                &CommonCryptSystem
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Get the key for the common crypt type
    //

    *UserKey = KerbGetKeyFromList(
                Passwords,
                CommonCryptSystem
                );
    DsysAssert(*UserKey != NULL);


    //
    // If we were using etype info, and not an old password, and the
    // etype doesn't use salt, then fail the operation, as we aren't
    // really generating a new key.
    //

    if (!UseOldPassword &&
        (CommonCryptSystem == KerbGlobalDefaultPreauthEtype) &&
        ARGUMENT_PRESENT(InputPaData))
    {
        PCRYPTO_SYSTEM CryptoSystem = NULL;
        Status = CDLocateCSystem(CommonCryptSystem, &CryptoSystem);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x.\n",CommonCryptSystem,Status ));
            goto Cleanup;
        }

        DsysAssert(CryptoSystem != NULL);
        if ((CryptoSystem->Attributes & CSYSTEM_USE_PRINCIPAL_NAME) == 0)
        {
            if (!IgnoreSaltFailures)
            {
                D_DebugLog((DEB_WARN,"Tried to update password with new salt, but keytype 0x%x doesn't use salt.\n",
                          CommonCryptSystem));

                *UserKey = NULL;
                Status = STATUS_WRONG_PASSWORD;
                goto Cleanup;
            }
        }
    }

Cleanup:

    if (EtypeInfo != NULL)
    {
        KerbFreeData(PKERB_ETYPE_INFO_PDU, EtypeInfo);
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildPreAuthData
//
//  Synopsis:   Builds pre-auth data for type the specified pre-auth types
//
//  Effects:
//
//  Arguments:  Credentials - Client's credentials, must be locked
//              RealmName - Name of target realm
//              ServiceName - Name of target server
//              PaTypeCount - count of pre-auth types to build
//              PaTypes - list of pre-auth types to build
//              InputPaData - any PA data returned by a previous (failed)
//                  AS request
//              TimeSkew - Time Skew with KDC
//              UseOldPassword - Use the old password instead of current one
//              PreAuthData - receives list of pre-auth data
//              Done - don't call again on pre-auth failure
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildPreAuthData(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN PUNICODE_STRING RealmName,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN ULONG PaTypeCount,
    IN PULONG PaTypes,
    IN OPTIONAL PKERB_PA_DATA_LIST InputPaData,
    IN PTimeStamp TimeSkew,
    IN BOOLEAN UseOldPassword,
    IN ULONG Nonce,
    IN KERBERR ErrorCode,
    OUT PKERB_PA_DATA_LIST * PreAuthData,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PKERB_CRYPT_LIST * CryptList,
    OUT PBOOLEAN Done
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    PKERB_PA_DATA_LIST OutputList = NULL;
    ULONG Index;
    BOOLEAN FoundPreauth = FALSE;


    //
    // Initialize outputs
    //

    *PreAuthData = NULL;
    *Done = FALSE;

    for (Index = 0 ; Index < PaTypeCount ; Index++ )
    {
        switch(PaTypes[Index]) {
        case KRB5_PADATA_ENC_TIMESTAMP:
            {
                KERB_ENCRYPTED_TIMESTAMP Timestamp = {0};
                TimeStamp CurrentTime;
                PBYTE EncryptedTime = NULL;
                ULONG EncryptedTimeSize = 0;
                KERB_ENCRYPTED_DATA EncryptedData;
                PKERB_ENCRYPTION_KEY UserKey = NULL;

                FoundPreauth = TRUE;
                //
                // Check for encryption hints in the incoming pa-data
                //

                Status = KerbFindCommonPaEtype(
                            Credentials,
                            InputPaData,
                            UseOldPassword,
                            ErrorCode == KDC_ERR_PREAUTH_REQUIRED,      // ignore salt problems on preauth-req errors
                            &UserKey
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                //
                // If there was any input PA data, we don't want to try again.
                //

                if (InputPaData != NULL)
                {
                    *Done = TRUE;
                }
                //
                // Build the output element
                //

                ListElement = (PKERB_PA_DATA_LIST) KerbAllocate(sizeof(KERB_PA_DATA_LIST));
                if (ListElement == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                //
                // Now build the encrypted timestamp
                //

                GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);

                //
                // Adjust for time skew with KDC
                //

                KerbSetTime(&CurrentTime, KerbGetTime(CurrentTime) + KerbGetTime(*TimeSkew));

                KerbConvertLargeIntToGeneralizedTimeWrapper(
                    &Timestamp.timestamp,
                    &Timestamp.KERB_ENCRYPTED_TIMESTAMP_usec,
                    &CurrentTime
                    );

                Timestamp.bit_mask = KERB_ENCRYPTED_TIMESTAMP_usec_present;

                KerbErr = KerbPackEncryptedTime(
                            &Timestamp,
                            &EncryptedTimeSize,
                            &EncryptedTime
                            );
                if (!KERB_SUCCESS(KerbErr))
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                //
                // Now encrypt the time
                //

                KerbErr = KerbAllocateEncryptionBufferWrapper(
                            UserKey->keytype,
                            EncryptedTimeSize,
                            &EncryptedData.cipher_text.length,
                            &EncryptedData.cipher_text.value
                            );

                if (!KERB_SUCCESS(KerbErr))
                {
                    D_DebugLog((DEB_ERROR,"\n\nFailed to get encryption overhead. %ws, line %d\n\n", THIS_FILE, __LINE__));
                    KerbFree(EncryptedTime);
                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }


                KerbErr = KerbEncryptDataEx(
                            &EncryptedData,
                            EncryptedTimeSize,
                            EncryptedTime,
                            UserKey->keytype,
                            KERB_ENC_TIMESTAMP_SALT,
                            UserKey
                            );
                KerbFree(EncryptedTime);

                if (!KERB_SUCCESS(KerbErr))
                {
                    MIDL_user_free(EncryptedData.cipher_text.value);
                    D_DebugLog((DEB_ERROR,"Failed to encrypt PA data. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                //
                // Now pack the encrypted data
                //

                KerbErr = KerbPackEncryptedData(
                            &EncryptedData,
                            (PULONG) &ListElement->value.preauth_data.length,
                            (PUCHAR *) &ListElement->value.preauth_data.value
                            );

                MIDL_user_free(EncryptedData.cipher_text.value);

                if (!KERB_SUCCESS(KerbErr))
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                ListElement->value.preauth_data_type = KRB5_PADATA_ENC_TIMESTAMP;
                ListElement->next = OutputList;
                OutputList = ListElement;
                ListElement = NULL;
                break;
            }
#ifndef WIN32_CHICAGO
        case KRB5_PADATA_PK_AS_REQ:
            FoundPreauth = TRUE;
            Status = KerbBuildPkinitPreauthData(
                        Credentials,
                        InputPaData,
                        TimeSkew,
                        ServiceName,
                        RealmName,
                        Nonce,
                        &OutputList,
                        EncryptionKey,
                        CryptList,
                        Done
                        );

            break;
#endif // WIN32_CHICAGO
        default:
            continue;
        }
    }
    if (!FoundPreauth)
    {
        DebugLog((DEB_ERROR,"NO known pa data type passed to KerbBuildPreAuthData. %ws, line %d\n",
            THIS_FILE, __LINE__ ));
        Status = STATUS_UNSUPPORTED_PREAUTH;
        goto Cleanup;

    }
    *PreAuthData = OutputList;
    OutputList = NULL;

Cleanup:

    if (OutputList != NULL)
    {
        KerbFreePreAuthData(
            OutputList
            );
    }
    if (ListElement != NULL)
    {
        KerbFreePreAuthData(
            ListElement
            );
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetPreAuthDataForRealm
//
//  Synopsis:   Gets the appropriate pre-auth data for the specified realm.
//              Right now it always returns KRB_ENC_TIMESTAMP pre-auth data
//              but at some point it might do different things based on
//              the realm.
//
//  Effects:
//
//  Arguments:  Credentials - Client's credentials
//              TargetRealm - realm from which the client is requesting a ticket
//              OldPreAuthData - any pre-auth data returned from the KDC on
//                      the last AS request.
//              TimeSkew - Time skew with KDC
//              UseOldPassword - if TRUE, use the old password instead of current
//              PreAuthData - Receives the new pre-auth data
//              Done - if TRUE, don't bother trying again on a pre-auth required
//                      failure
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetPreAuthDataForRealm(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN PUNICODE_STRING TargetRealm,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PKERB_PA_DATA_LIST OldPreAuthData,
    IN PTimeStamp TimeSkew,
    IN BOOLEAN UseOldPassword,
    IN ULONG Nonce,
    IN KERBERR ErrorCode,
    OUT PKERB_PA_DATA_LIST * PreAuthData,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PKERB_CRYPT_LIST * CryptList,
    OUT PBOOLEAN Done
    )
{
#define KERB_MAX_PA_DATA_TYPES 10
    NTSTATUS Status;
    ULONG PaTypeCount = 0;
    ULONG PaDataTypes[KERB_MAX_PA_DATA_TYPES];
    PKERB_MIT_REALM MitRealm;
    BOOLEAN UsedAlternateName;
    PKERB_PA_DATA_LIST PreAuthElement = NULL;


    //
    // If an error message was supplied, see if we can pull out the
    // list of supported pre-auth types from it.
    //

    if (ARGUMENT_PRESENT(OldPreAuthData) && (ErrorCode == KDC_ERR_PREAUTH_REQUIRED))
    {

        //
        // Pick the first type from the list as the type
        //

        PreAuthElement = OldPreAuthData;
        while ((PaTypeCount < KERB_MAX_PA_DATA_TYPES) && (PreAuthElement != NULL))
        {
            PaDataTypes[PaTypeCount++] = (ULONG) PreAuthElement->value.preauth_data_type;
            PreAuthElement = PreAuthElement->next;
        }

    }
    else
    {
        //
        // For MIT realms, check the list to see what kind of preauth to do.
        //

        if (KerbLookupMitRealm(
                TargetRealm,
                &MitRealm,
                &UsedAlternateName
                ))
        {
           //
           //  There are some types of preauth returned from the KDC that we
           //  need to log an event for.   PA-PW-SALT (3) and PA-AFS3-SALT (10)
           //  are not implemented in our client, so log an error to help admins,
           //  and retry w/ default for realm.
           //
           while ((PaTypeCount < KERB_MAX_PA_DATA_TYPES) && (PreAuthElement != NULL))
           {
              if (PreAuthElement->value.preauth_data_type == KRB5_PADATA_PW_SALT ||
                  PreAuthElement->value.preauth_data_type == KRB5_PADATA_AFS3_SALT)
              {

                 Status = STATUS_UNSUPPORTED_PREAUTH;
                 DebugLog((
                           DEB_ERROR,
                           "Unsupported Preauth type : %x\n",
                           PreAuthElement->value.preauth_data_type
                           ));

                 goto Cleanup;
              }

              PaTypeCount++;
              PreAuthElement = PreAuthElement->next;
           }

           if (MitRealm->PreAuthType != 0)
           {
              PaDataTypes[0] = MitRealm->PreAuthType;
              PaTypeCount = 1;
           }
           else
           {
              return(STATUS_SUCCESS);
           }
        }

        //
        // Plug in fancier capabilities here.
        //

        //
        // If the caller has public key credentials, use pkinit rather than
        // encrypted timestamp
        //


        else if (Credentials->PublicKeyCreds != NULL)
        {
            PaDataTypes[0] = KRB5_PADATA_PK_AS_REQ;
            PaTypeCount = 1;
        }
        else
        {
            //
            // If we were succeful, ignore this preauth data
            //

            if ((ErrorCode == KDC_ERR_NONE) && (OldPreAuthData != NULL))
            {
                return(STATUS_SUCCESS);
            }
            PaDataTypes[0] = KRB5_PADATA_ENC_TIMESTAMP;
            PaTypeCount = 1;
        }


    }

    Status = KerbBuildPreAuthData(
                Credentials,
                TargetRealm,
                ServiceName,
                PaTypeCount,
                PaDataTypes,
                OldPreAuthData,
                TimeSkew,
                UseOldPassword,
                Nonce,
                ErrorCode,
                PreAuthData,
                EncryptionKey,
                CryptList,
                Done
                );

Cleanup:

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackErrorPreauth
//
//  Synopsis:   Unpacks preauth data from a kerb_error message
//
//  Effects:
//
//  Arguments:  ErrorMessage - ErrorMessage from an AS request that failed
//                      with KDC_ERR_PREAUTH_REQUIRED
//              PreAuthData - returns any preauth data from the error message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbUnpackErrorPreauth(
    IN PKERB_ERROR ErrorMessage,
    OUT PKERB_PA_DATA_LIST ** PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PREAUTH_DATA_LIST * ErrorPreAuth = NULL;

    *PreAuthData = NULL;

    //
    // If there was no data, return now
    //

    if ((ErrorMessage->bit_mask & error_data_present) == 0)
    {
        //
        // If we weren't given any hints, we can't do any better so return
        // an error.
        //

        KerbErr = KDC_ERR_PREAUTH_REQUIRED;
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                ErrorMessage->error_data.value,
                ErrorMessage->error_data.length,
                PKERB_PREAUTH_DATA_LIST_PDU,
                (PVOID *) &ErrorPreAuth
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to unpack pre-auth data from error message. %ws, line %d\n", THIS_FILE, __LINE__));

        //
        // This error code isn't particularly informative but we were unable to get the
        // error information so this is the best we can do.
        //

        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Make sure the two structures are similar
    //

    DsysAssert(FIELD_OFFSET(KERB_PREAUTH_DATA_LIST,next) == FIELD_OFFSET(KERB_PA_DATA_LIST,next));
    DsysAssert(FIELD_OFFSET(KERB_PREAUTH_DATA_LIST,value) == FIELD_OFFSET(KERB_PA_DATA_LIST,value));
    DsysAssert(sizeof(KERB_PREAUTH_DATA_LIST) == sizeof(KERB_PA_DATA_LIST));

    *PreAuthData = (PKERB_PA_DATA_LIST *) ErrorPreAuth;
    ErrorPreAuth = NULL;

Cleanup:

    if (ErrorPreAuth != NULL)
    {
        KerbFreeData(PKERB_PREAUTH_DATA_LIST_PDU,ErrorPreAuth);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAddPacRequestPreAuth
//
//  Synopsis:   Add the pac-request preauth data to either requst a pac
//              or request that no pac be included
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbAddPacRequestPreAuth(
    OUT PKERB_PA_DATA_LIST * PreAuthData,
    IN ULONG TicketFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    PKERB_PA_DATA_LIST LastElement = NULL;
    KERB_PA_PAC_REQUEST PacRequest = {0};

    ListElement = (PKERB_PA_DATA_LIST) KerbAllocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if ((TicketFlags & KERB_GET_TICKET_NO_PAC) != 0 )
    {
        PacRequest.include_pac = FALSE;
    }
    else
    {
        PacRequest.include_pac = TRUE;
    }

    //
    // Marshall the type into the list element.
    //

    if (!KERB_SUCCESS(KerbPackData(
                        &PacRequest,
                        KERB_PA_PAC_REQUEST_PDU,
                        (PULONG) &ListElement->value.preauth_data.length,
                        (PUCHAR *) &ListElement->value.preauth_data.value
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    ListElement->value.preauth_data_type = KRB5_PADATA_PAC_REQUEST;

    //
    // We want this to go at the end, so that it will override any other
    // pa-data that may enable a PAC.
    //

    LastElement = *PreAuthData;
    if (LastElement != NULL)
    {
        while (LastElement->next != NULL)
        {
            LastElement = LastElement->next;
        }
        LastElement->next = ListElement;
    }
    else
    {
        *PreAuthData = ListElement;
    }

    ListElement->next = NULL;
    ListElement = NULL;

Cleanup:
    if (ListElement != NULL)
    {
        KerbFreePreAuthData(
            ListElement
            );
    }

    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbPingWlBalloon
//
//  Synopsis:   Opens and pulses winlogon event, so they can pop up the balloon,
//              informing user of bad pwd, or expired pwd
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session for which to acquire a ticket
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//
//
//

#define KERBEROS_NOTIFICATION_EVENT_NAME             L"WlballoonKerberosNotificationEventName"

BOOLEAN
KerbPingWlBalloon(
    PLUID Luid
    )
{
    HANDLE              EventHandle;
    WCHAR               Event[512];

    wsprintfW(
        Event,
        L"Global\\%08x%08x_%s",
        Luid->HighPart,
        Luid->LowPart,
        KERBEROS_NOTIFICATION_EVENT_NAME
        );

    EventHandle = OpenEventW(EVENT_MODIFY_STATE, FALSE, Event);

    if (EventHandle == NULL)
    {
        DebugLog((DEB_ERROR, "Opening winlogon event %S failed %x\n", Event, GetLastError()));
        return FALSE;
    }

    if (!SetEvent(EventHandle))
    {
        DebugLog((DEB_ERROR, "SETTING winlogon event %S failed %x\n", Event, GetLastError()));
    }


    if (EventHandle != NULL)
    {
        CloseHandle(EventHandle);
    }

    return TRUE;

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetAuthenticationTicket
//
//  Synopsis:   Gets an AS ticket for the specified logon session
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session for which to acquire a ticket
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//
//  Notes:      The retry logic here is complex. The idea is that we
//              shouldn't retry more than once for any particular failure.
//
//
//--------------------------------------------------------------------------

#define KERB_RETRY_ETYPE_FAILURE        0x0001
#define KERB_RETRY_TIME_FAILURE         0x0002
#define KERB_RETRY_PASSWORD_FAILURE     0x0004
#define KERB_RETRY_WRONG_PREAUTH        0x0008
#define KERB_RETRY_USE_TCP              0x0010
#define KERB_RETRY_CALL_PDC             0x0020
#define KERB_RETRY_SALT_FAILURE         0x0040
#define KERB_RETRY_WITH_ACCOUNT         0x0080
#define KERB_RETRY_BAD_REALM            0x0100
#define KERB_RETRY_PKINIT               0x0200
#define KERB_RETRY_BAD_KDC              0x0400



NTSTATUS
KerbGetAuthenticationTicket(
    IN OUT PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING ServerRealm,
    IN PKERB_INTERNAL_NAME ClientFullName,
    IN ULONG TicketFlags,
    IN ULONG CacheFlags,
    OUT OPTIONAL PKERB_TICKET_CACHE_ENTRY * TicketCacheEntry,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PUNICODE_STRING CorrectRealm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS OldStatus = STATUS_SUCCESS;
    NTSTATUS ExtendedStatus = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERBERR LastKerbErr = KDC_ERR_NONE;
    KERB_KDC_REQUEST TicketRequest = {0};
    PKERB_KDC_REQUEST_BODY RequestBody;
    PULONG CryptVector = NULL;
    BOOLEAN LogonSessionsLocked = FALSE;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY ReplyBody = NULL;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    PKERB_TICKET_CACHE_ENTRY NewTGT = NULL;
    TimeStamp TempTime;
    KERB_MESSAGE_BUFFER RequestMessage = {0, NULL};
    KERB_MESSAGE_BUFFER ReplyMessage = {0, NULL};
    UNICODE_STRING ClientName = NULL_UNICODE_STRING;
    PKERB_ENCRYPTION_KEY ClientKey;
    ULONG RetryFlags = 0;
    BOOLEAN CalledPDC = FALSE;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    BOOLEAN PreAuthDone = FALSE;
    PKERB_ERROR ErrorMessage = NULL;
    PKERB_PA_DATA_LIST * OldPreAuthData = NULL;
#ifndef WIN32_CHICAGO
    LARGE_INTEGER TimeSkew = {0,0};
#else // WIN32_CHICAGO
    TimeStamp TimeSkew = 0;
#endif // WIN32_CHICAGO
    ULONG NameType = KRB_NT_MS_PRINCIPAL;
    BOOLEAN UsedAlternateName = FALSE;
    PKERB_MIT_REALM MitRealm = NULL;
    PKERB_INTERNAL_NAME LocalServiceName = NULL;
    PKERB_EXT_ERROR pExtendedError = NULL;
    BOOLEAN UsedCredentials = FALSE;
    KERB_ENCRYPTION_KEY EncryptionKey = {0};
    PKERB_HOST_ADDRESSES HostAddresses = NULL;
    PKERB_CRYPT_LIST CryptList = NULL;
    UNICODE_STRING ClientRealm = {0};
    ULONG KdcOptions;
    ULONG KdcFlagOptions, AdditionalFlags = 0;
    BOOLEAN DoLogonRetry = FALSE;
    BOOLEAN DoTcpRetry = FALSE;
    BOOLEAN DoPreauthRetry = FALSE;
    BOOLEAN DoAccountLookup = FALSE;
    BOOLEAN IncludeIpAddresses = FALSE;
    BOOLEAN IncludeNetbiosAddresses = TRUE;

    D_DebugLog((DEB_TRACE,"Getting authentication ticket for client "));
    D_KerbPrintKdcName(DEB_TRACE, ClientFullName );
    D_DebugLog((DEB_TRACE," for service in realm %wZ : ", ServerRealm));
    D_KerbPrintKdcName(DEB_TRACE, ServiceName);

    //
    // Initialize variables to NULL
    //

    RequestBody = &TicketRequest.request_body;
    RtlInitUnicodeString(
        CorrectRealm,
        NULL
        );

    if ((ClientFullName->NameCount == 0) || (ClientFullName->Names[0].Length == 0))
    {
        D_DebugLog((DEB_WARN,"KerbGetServiceTicket: not requesting ticket for blank server name\n"));
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }

    //
    // Build the request
    //

    KdcOptions = KERB_DEFAULT_TICKET_FLAGS;

    //
    // The domain name may be null - if so, use our domain for now.
    //

    //
    // Check to see if the domain is an MIT realm
    //

    if (KerbLookupMitRealm(
            ServerRealm,
            &MitRealm,
            &UsedAlternateName
            ) ||
        ((TicketFlags & KERB_GET_AUTH_TICKET_NO_CANONICALIZE) != 0))
    {
        DsysAssert(((TicketFlags & KERB_GET_AUTH_TICKET_NO_CANONICALIZE) != 0) ||
                   (MitRealm != NULL));

        //
        // So the user is getting a ticket from an MIT realm. This means
        // we don't ask for name canonicalization.
        //

        KdcOptions &= ~KERB_KDC_OPTIONS_name_canonicalize;

        if (MitRealm != NULL)
        {
            LogonSession->LogonSessionFlags |= KERB_LOGON_MIT_REALM;
        }
    }

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KdcOptions);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions ;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;

    RequestBody->nonce = KerbAllocateNonce();

    TempTime = KerbGlobalWillNeverTime;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;

    //
    // Lock down the logon session while we build the request.
    //

    KerbReadLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;

    //
    // If credentials were supplied, use the primary creds from there
    //

    if (ARGUMENT_PRESENT(Credential) && (Credential->SuppliedCredentials != NULL))
    {
        UsedCredentials = TRUE;

        PrimaryCredentials = Credential->SuppliedCredentials;
        D_DebugLog((DEB_TRACE_CRED,"GetAuthTicket: Using supplied credentials %wZ\\%wZ to \n",
            &PrimaryCredentials->DomainName,
            &PrimaryCredentials->UserName
            ));
        D_KerbPrintKdcName( DEB_TRACE_CRED, ServiceName );

    }
    else if (ARGUMENT_PRESENT(CredManCredentials))
    {
        UsedCredentials = TRUE;

        PrimaryCredentials = CredManCredentials->SuppliedCredentials;
        D_DebugLog((DEB_TRACE_CRED,"GetAuthTicket: Using cred manager credentials %wZ\\%wZ to \n",
            &PrimaryCredentials->DomainName,
            &PrimaryCredentials->UserName
            ));
        D_KerbPrintKdcName( DEB_TRACE_CRED, ServiceName );
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
        D_DebugLog((DEB_TRACE_CRED,"GetAuthTicket: Using default credentials %wZ\\%wZ to ",
            &PrimaryCredentials->DomainName,
            &PrimaryCredentials->UserName
            ));

        D_KerbPrintKdcName(DEB_TRACE_CRED, ServiceName);

    }

    if ((PrimaryCredentials->Passwords == NULL) &&
        (PrimaryCredentials->PublicKeyCreds == NULL))
    {
        D_DebugLog((DEB_ERROR,"Can't get AS ticket with no password. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    //
    // Copy all the names into the request message
    //

    //
    // Build the client name from the client domain & user name.
    //


    KerbErr = KerbConvertKdcNameToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                ClientFullName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;


    //
    // If we are talking to an NT Domain, or are using an MIT compatible
    // name type, convert the service name as is is
    //

    KerbErr = KerbConvertKdcNameToPrincipalName(
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                    ServiceName
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;

    //
    // Build the list of host addresses. We don't do this for all
    // MIT realms
    //

    if ( KerbGlobalUseClientIpAddresses ) {

        IncludeIpAddresses = TRUE;

    }

    //
    // MIT realms never care to see the NetBIOS addresses
    //

    if ( MitRealm != NULL ) {

        IncludeNetbiosAddresses = FALSE;

        if (( MitRealm->Flags & KERB_MIT_REALM_SEND_ADDRESS ) != 0 ) {

            IncludeIpAddresses = TRUE;
        }
    }

    //
    // We always put the NetBIOS name of the client into the request,
    // as this is how the workstations restriction is enforced.
    // It is understood that the mechanism is bogus, as the client can spoof
    // the netbios address, but that's okay -- we're only doing this for
    // feature preservation, this is no worse than W2K.
    //
    // The IP address is only put in based on a registry setting or for MIT
    // realms that explicity request it, as having them in the request would
    // break us when going through NATs.
    //

    Status = KerbBuildHostAddresses(
                 IncludeIpAddresses,
                 IncludeNetbiosAddresses,
                 &HostAddresses
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if ( HostAddresses )
    {
        RequestBody->addresses = HostAddresses;
        RequestBody->bit_mask |= addresses_present;
    }

    TicketRequest.version = KERBEROS_VERSION;
    TicketRequest.message_type = KRB_AS_REQ;

PreauthRestart:
    //
    // Lock down the logon session while we build the request.
    // This is done so that when we try the second time around, the logon
    // session list is locked
    //

    if (!LogonSessionsLocked)
    {
        KerbReadLockLogonSessions(LogonSession);
        LogonSessionsLocked = TRUE;
    }

    DoPreauthRetry = FALSE;
    if (RequestMessage.Buffer != NULL)
    {
        MIDL_user_free(RequestMessage.Buffer);
        RequestMessage.Buffer = NULL;
    }

    // Free this in case we are doing a retry

    KerbFreeRealm(
        &RequestBody->realm
        );

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                ServerRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Stick the PA data in the request
    //

    DsysAssert(TicketRequest.KERB_KDC_REQUEST_preauth_data == NULL);

    Status = KerbGetPreAuthDataForRealm(
                PrimaryCredentials,
                ServerRealm,
                ServiceName,
                (OldPreAuthData != NULL) ? *OldPreAuthData : NULL,
                &TimeSkew,
                (RetryFlags & KERB_RETRY_PASSWORD_FAILURE) != 0,
                RequestBody->nonce,
                LastKerbErr,
                &TicketRequest.KERB_KDC_REQUEST_preauth_data,
                &EncryptionKey,
                &CryptList,
                &PreAuthDone
                );

    if (!NT_SUCCESS(Status))
    {
        //
        // If we couldn't build the preauth, try again
        //

        if (Status == STATUS_WRONG_PASSWORD)
        {
            if ((RetryFlags & KERB_RETRY_PASSWORD_FAILURE) == 0)
            {
                RetryFlags |= KERB_RETRY_PASSWORD_FAILURE;
                goto PreauthRestart;
            }
            else if ((RetryFlags & KERB_RETRY_SALT_FAILURE) == 0)
            {
                RetryFlags |= KERB_RETRY_SALT_FAILURE;
                RetryFlags &= ~KERB_RETRY_PASSWORD_FAILURE;
                goto PreauthRestart;
            }
        } else if (Status == STATUS_UNSUPPORTED_PREAUTH)
        {

              // Log this, every time, as this is impossible to triage otherwise

             KerbReportKerbError(
                ServiceName,
                ServerRealm,
                NULL,
                Credential,
                KLIN(FILENO,__LINE__),
                NULL,
                KDC_ERR_PADATA_TYPE_NOSUPP,
                NULL,
                TRUE
                );

        }

        DebugLog((DEB_ERROR,"GetAuthenticationTicket: Failed to build pre-auth data: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Build crypt list
    //

    KerbFreeCryptList(
        RequestBody->encryption_type
        );

    RequestBody->encryption_type = NULL;

    if (PrimaryCredentials->Passwords != NULL) {

        if (!KERB_SUCCESS(KerbConvertKeysToCryptList(
                            &RequestBody->encryption_type,
                            PrimaryCredentials->Passwords
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

    } else {
        ULONG CryptTypes[KERB_MAX_CRYPTO_SYSTEMS];
        ULONG CryptTypeCount = KERB_MAX_CRYPTO_SYSTEMS;

        //
        // Include all our crypt types as supported
        //

        Status = CDBuildIntegrityVect(
                    &CryptTypeCount,
                    CryptTypes
                    );
        DsysAssert(NT_SUCCESS(Status));

        if (!KERB_SUCCESS(KerbConvertArrayToCryptList(
                            &RequestBody->encryption_type,
                            CryptTypes,
                            CryptTypeCount)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

    }

    //
    // Add in preauth generated encryption types
    //

    if (CryptList != NULL)
    {
        PKERB_CRYPT_LIST Next;
        Next = CryptList;
        while (Next != NULL)
        {
            if (Next->next == NULL)
            {
                Next->next = RequestBody->encryption_type;
                RequestBody->encryption_type = CryptList;
                CryptList = NULL;
                break;
            }
            Next = Next->next;
        }
    }

    //
    // If the we need to either request the presence or absence of a PAC, do
    // it here
    //

    if (MitRealm == NULL)
    {
        Status = KerbAddPacRequestPreAuth(
                    &TicketRequest.KERB_KDC_REQUEST_preauth_data,
                    TicketFlags
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if (TicketRequest.KERB_KDC_REQUEST_preauth_data != NULL)
    {
        TicketRequest.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;
    }


    //
    // Pack the request
    //


    KerbErr = KerbPackAsRequest(
                &TicketRequest,
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


RetryLogon:
    DoLogonRetry = FALSE;


    //
    // Unlock the logon sessions and credential so we don't cause problems
    // waiting for a network request to complete.
    //


    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
        LogonSessionsLocked = FALSE;
    }

    D_DebugLog((DEB_TRACE_KDC,"KerbGetAuthenticationTicket: Calling KDC\n"));

RetryWithTcp:

    if (ReplyMessage.Buffer != NULL)
    {
        MIDL_user_free(ReplyMessage.Buffer);
        ReplyMessage.Buffer = NULL;
    }

    DoTcpRetry = FALSE;

    Status = KerbMakeKdcCall(
                ServerRealm,
                (DoAccountLookup && ClientFullName->NameType == KRB_NT_PRINCIPAL) ? &ClientFullName->Names[0] : NULL,        // send the client name, if available
                (RetryFlags & KERB_RETRY_CALL_PDC) != 0,
                (RetryFlags & KERB_RETRY_USE_TCP) != 0,
                &RequestMessage,
                &ReplyMessage,
                AdditionalFlags,
                &CalledPDC
                // FESTER:  TBD:  Tell us we made MIT call for AS, so we can update
                // logonsession w/ MIT flag....
                );

    D_DebugLog((DEB_TRACE_KDC,"KerbGetAuthenticationTicket: Returned from KDC status 0x%x\n",
        Status ));

    if (!NT_SUCCESS(Status))
    {
#if DBG
        if (Status != STATUS_NO_LOGON_SERVERS)
        {
            DebugLog((DEB_ERROR,"Failed KerbMakeKdcCall for AS request: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        }
#endif

        //
        // If this is the second time around (on the PDC) and this fails,
        // use the original error
        //

        if (OldStatus != STATUS_SUCCESS)
        {
            Status = OldStatus;
        }
        goto Cleanup;
    }

    //
    // Free the preauth data now, as it is not necessary any more
    //

    KerbFreePreAuthData( TicketRequest.KERB_KDC_REQUEST_preauth_data );
    TicketRequest.KERB_KDC_REQUEST_preauth_data = NULL;

    KerbErr = KerbUnpackAsReply(
                ReplyMessage.Buffer,
                ReplyMessage.BufferSize,
                &KdcReply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN,"Failed to unpack KDC reply as AS: 0x%x\n", KerbErr ));

        //
        // Try to unpack it as  kerb_error
        //

        if (ErrorMessage != NULL)
        {
            KerbFreeKerbError(ErrorMessage);
            ErrorMessage = NULL;
        }

        KerbErr =  KerbUnpackKerbError(
                        ReplyMessage.Buffer,
                        ReplyMessage.BufferSize,
                        &ErrorMessage
                        );
        if (KERB_SUCCESS(KerbErr))
        {
           //
           // Let's see if there's any extended error here
           //
           if (ErrorMessage->bit_mask & error_data_present)
           {
              if (NULL != pExtendedError) // might be a re-auth failure. Don't leak!
              {
                 KerbFree(pExtendedError);
                 pExtendedError = NULL;
              }

              KerbErr = KerbUnpackErrorData(
                              ErrorMessage,
                              &pExtendedError
                              );

              if (KERB_SUCCESS(KerbErr) && (EXT_CLIENT_INFO_PRESENT(pExtendedError)))
              {
                 ExtendedStatus = pExtendedError->status;
              }
           }

           KerbErr = (KERBERR) ErrorMessage->error_code;
           LastKerbErr = KerbErr;
           DebugLog((DEB_ERROR,"KerbCallKdc failed: error 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));

           Status = KerbMapKerbError(KerbErr);

           KerbReportKerbError(
                ServiceName,
                ServerRealm,
                LogonSession,
                Credential,
                KLIN(FILENO,__LINE__),
                ErrorMessage,
                KerbErr,
                pExtendedError,
                FALSE
                );

            if (KerbErr == KRB_ERR_RESPONSE_TOO_BIG)
            {
                if ((RetryFlags & KERB_RETRY_USE_TCP) != 0)
                {
                    D_DebugLog((DEB_ERROR,"Got response too big twice. %ws, %d\n",
                            THIS_FILE, __LINE__ ));
                    Status = STATUS_BUFFER_OVERFLOW;
                    goto Cleanup;
                }
                RetryFlags |= KERB_RETRY_USE_TCP;
                DoTcpRetry = TRUE;

            }

            //
            // If we didn't try the PDC, try it now.
            //

            else if (KerbErr == KDC_ERR_KEY_EXPIRED)
            {
                if (CalledPDC ||
                    ((RetryFlags & KERB_RETRY_CALL_PDC) != 0) ||
                    (!KerbGlobalRetryPdc))
                {
                   // If we've already tried the PDC, then we should
                   // have some extended info w.r.t. what's up w/
                   // this password.
                   if (EXT_CLIENT_INFO_PRESENT(pExtendedError))
                   {
                      Status = ExtendedStatus;
                   }
                   else
                   {
                      Status = KerbMapKerbError(KerbErr);
                   }
                   goto Cleanup;
                }
                RetryFlags |= KERB_RETRY_CALL_PDC;
                DoLogonRetry = TRUE;
            }

            //
            // Check for time skew. If so, calculate the skew and retry
            //

            else if (KerbErr == KRB_AP_ERR_SKEW)
            {
                TimeStamp CurrentTime;
                TimeStamp KdcTime;

                if ((RetryFlags & KERB_RETRY_TIME_FAILURE) != 0)
                {
                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }

                RetryFlags |= KERB_RETRY_TIME_FAILURE;
                DoPreauthRetry = TRUE;

                GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);


                KerbConvertGeneralizedTimeToLargeInt(
                    &KdcTime,
                    &ErrorMessage->server_time,
                    ErrorMessage->server_usec
                    );

                KerbSetTime(&TimeSkew, KerbGetTime(KdcTime) - KerbGetTime(CurrentTime));
                KerbUpdateSkewTime(TRUE);
            }


            //
            // Check for pre-authenication required
            //

            else if ((KerbErr == KDC_ERR_PREAUTH_FAILED) ||
                     (KerbErr == KRB_AP_ERR_BAD_INTEGRITY))
            {
                //
                // This is a bad password failure.
                //


                if ((RetryFlags & KERB_RETRY_PASSWORD_FAILURE) == 0)
                {
                    RetryFlags |= KERB_RETRY_PASSWORD_FAILURE;
                }
                else if ((RetryFlags & KERB_RETRY_SALT_FAILURE) != 0)
                {
                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }
                else
                {
                    RetryFlags |= KERB_RETRY_SALT_FAILURE;
                    RetryFlags &= ~KERB_RETRY_PASSWORD_FAILURE;
                }

                //
                // In this case, there may be data in the error data
                //

                KerbFreeData(
                    PKERB_PREAUTH_DATA_LIST_PDU,
                    OldPreAuthData
                    );

                OldPreAuthData = NULL;

                (VOID) KerbUnpackErrorPreauth(
                                ErrorMessage,
                                &OldPreAuthData
                                );

                DoPreauthRetry = TRUE;
            }
            else if ((KerbErr == KDC_ERR_ETYPE_NOTSUPP) ||
                     (KerbErr == KDC_ERR_PREAUTH_REQUIRED))
            {
                NTSTATUS TempStatus;

                if (KerbErr == KDC_ERR_ETYPE_NOTSUPP)
                {
                    if ((RetryFlags & KERB_RETRY_ETYPE_FAILURE) != 0)
                    {
                        Status = KerbMapKerbError(KerbErr);
                        goto Cleanup;
                    }
                    RetryFlags |= KERB_RETRY_ETYPE_FAILURE;
                }
                else
                {
                    if ((RetryFlags & KERB_RETRY_WRONG_PREAUTH) != 0)
                    {
                        Status = KerbMapKerbError(KerbErr);
                        goto Cleanup;
                    }
                    RetryFlags |= KERB_RETRY_WRONG_PREAUTH;

                }

                //
                // In this case, there should be data in the error data
                //

                KerbFreeData(
                    PKERB_PREAUTH_DATA_LIST_PDU,
                    OldPreAuthData
                    );

                OldPreAuthData = NULL;

                TempStatus = KerbUnpackErrorPreauth(
                                ErrorMessage,
                                &OldPreAuthData
                                );
                if (!NT_SUCCESS(TempStatus))
                {
                    D_DebugLog((DEB_ERROR,"GetAuthTicket: Failed to unpack error for preauth : 0x%x. %ws, line %d\n", TempStatus, THIS_FILE, __LINE__));
                    D_DebugLog((DEB_ERROR,"client was "));
                    D_KerbPrintKdcName(DEB_ERROR, ClientFullName );
                    D_DebugLog((DEB_ERROR," for service in realm %wZ : ", ServerRealm));
                    D_KerbPrintKdcName(DEB_ERROR, ServiceName);
                    DsysAssert(!NT_SUCCESS(Status));
                    goto Cleanup;
                }
                DoPreauthRetry = TRUE;
            }
            //
            // There's something wrong w/ the client's account.  In all cases
            // this error should be accompanied by an extended error packet.
            // and no retry should be attempted (see restrict.cxx)
            //
            else if ((KerbErr == KDC_ERR_CLIENT_REVOKED ||
                      KerbErr == KDC_ERR_POLICY ) &&
                     EXT_CLIENT_INFO_PRESENT(pExtendedError))
            {
               Status = pExtendedError->status;
               goto Cleanup;
            }
            //
            // For PKINIT, the client not trusted error indicates that SCLogon failed
            // as the client certificate was bogus.  Log an error here.
            // NOTE:  The extended status is a wincrypt error, so just return the
            // normal status (
            else if (KerbErr == KDC_ERR_CLIENT_NOT_TRUSTED)
            {

                ULONG PolicyStatus = ERROR_NOT_SUPPORTED; // w2k DCs won't likely have this data.

                //
                // WE may have trust status on the client certificate
                // use this to create an event log.  NOte:  this is only
                // going to happen if logon was against Whistler DC
                //
                // W2K Dcs returning errors will get mapped to generic
                // error.
                //
                if (EXT_CLIENT_INFO_PRESENT(pExtendedError))
                {
                    PolicyStatus = pExtendedError->status;
                }

                KerbReportPkinitError(PolicyStatus, NULL);
                Status = KerbMapClientCertChainError(PolicyStatus);
                DebugLog((DEB_ERROR, "Client certificate didn't validate on KDC - %x\n", PolicyStatus));

            }
            else if ((KerbErr == KDC_ERR_PADATA_TYPE_NOSUPP) &&
                     (EXT_CLIENT_INFO_PRESENT(pExtendedError)))
            {
                if ((RetryFlags & KERB_RETRY_PKINIT) != 0)
                {
                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }

                //
                // no KDC certificate error in edata, do a retry against
                // another DC
                //
                if (pExtendedError->status == STATUS_PKINIT_FAILURE)
                {
                    RetryFlags |= KERB_RETRY_PKINIT;
                    AdditionalFlags = DS_FORCE_REDISCOVERY;
                    DoLogonRetry = TRUE;
                }
            }
            //
            // Check if the server didn't know the client principal
            //

            else if (KerbErr == KDC_ERR_C_PRINCIPAL_UNKNOWN )
            {

               // fester
               //D_DebugLog((DEB_ERROR, "Client principal unknown (realm %wZ) : ", ServerRealm));
               //D_KerbPrintKdcName(DEB_ERROR, ClientFullName);

               if ((RetryFlags & KERB_RETRY_WITH_ACCOUNT) != 0)
               {
                  Status = KerbMapKerbError(KerbErr);
                  goto Cleanup;
               }

               RetryFlags |= KERB_RETRY_WITH_ACCOUNT;

               DoAccountLookup = TRUE;

               if ((ErrorMessage->bit_mask & client_realm_present) != 0)
               {
                  UNICODE_STRING TempRealm;

                  if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                     &TempRealm,
                     &ErrorMessage->client_realm
                     )))
                  {
                     Status = STATUS_INSUFFICIENT_RESOURCES;
                     goto Cleanup;
                  }

                  if (!RtlEqualUnicodeString(
                     ServerRealm,
                     &TempRealm,
                     TRUE            // case insensitive
                     ))
                  {
                     D_DebugLog((DEB_TRACE,"Received UPN referral to another domain: %wZ\n",
                                 &TempRealm ));
                     //
                     // Return the correct realm so the caller will retry
                     //

                     *CorrectRealm = TempRealm;
                     TempRealm.Buffer = NULL;
                     DoAccountLookup = FALSE;
                  }

                   KerbFreeString( &TempRealm );
               }

               if (DoAccountLookup)
               {
                  DoLogonRetry = TRUE;
               }
            }
            //
            // Something's wrong w/ the KDC...  Try another one, but 1 time only
            //
            else if (KerbErr == KDC_ERR_SVC_UNAVAILABLE)
            {

                if ((RetryFlags & KERB_RETRY_BAD_KDC) != 0)
                {
                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }

                D_DebugLog((DEB_ERROR, "Retrying new KDC\n"));

                AdditionalFlags = DS_FORCE_REDISCOVERY;
                DoLogonRetry = TRUE;
                RetryFlags |= KERB_RETRY_BAD_KDC;
            }
            else if (KerbErr == KDC_ERR_WRONG_REALM)
            {
               if ((RetryFlags & KERB_RETRY_BAD_REALM) != 0)
               {
                  Status = KerbMapKerbError(KerbErr);
                  goto Cleanup;
               }

               RetryFlags |= KERB_RETRY_BAD_REALM;

               AdditionalFlags = DS_FORCE_REDISCOVERY; // possibly bad cached DC
               DoLogonRetry = TRUE;

               if ((ErrorMessage->bit_mask & client_realm_present) != 0)
               {
                  UNICODE_STRING TempRealm;
                  if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                     &TempRealm,
                     &ErrorMessage->client_realm
                     )))
                  {
                     Status = STATUS_INSUFFICIENT_RESOURCES;
                     goto Cleanup;
                  }

                  if (!RtlEqualUnicodeString(
                     ServerRealm,
                     &TempRealm,
                     TRUE            // case insensitive
                     ))
                  {
                     D_DebugLog((DEB_TRACE,"Received UPN referral to another domain: %wZ\n",
                                 &TempRealm ));
                    //
                    // Return the correct realm so the caller will retry
                    //

                     *CorrectRealm = TempRealm;
                     TempRealm.Buffer = NULL;
                     DoLogonRetry = FALSE;  // this is a referral, not a bad cache entry
                  }

                  KerbFreeString( &TempRealm );
               }
            }

            //
            // Retry if need be
            //

            if (DoPreauthRetry)
            {
                goto PreauthRestart;
            }
            else if (DoLogonRetry)
            {
                goto RetryLogon;
            }
            else if (DoTcpRetry)
            {
                goto RetryWithTcp;
            }
        }
        else
        {
           D_DebugLog((DEB_WARN,"Failed to unpack KDC reply as AS or Error: 0x%x\n", KerbErr ));

           Status = STATUS_INTERNAL_ERROR;
        }

        goto Cleanup;
    }


    //
    // Update the skew counter if necessary
    //

    if ((RetryFlags & KERB_RETRY_TIME_FAILURE) == 0)
    {
        KerbUpdateSkewTime(FALSE);
    }

    //
    // Now unpack the reply body:
    //

    KerbWriteLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;

    //
    // if there was any pre auth data, process it now
    //

    if ((KdcReply->bit_mask & KERB_KDC_REPLY_preauth_data_present) != 0)
    {
        Status = KerbGetPreAuthDataForRealm(
                    PrimaryCredentials,
                    ServerRealm,
                    ServiceName,
                    (PKERB_PA_DATA_LIST) KdcReply->KERB_KDC_REPLY_preauth_data,
                    &TimeSkew,
                    (RetryFlags & KERB_RETRY_PASSWORD_FAILURE) != 0,
                    RequestBody->nonce,
                    KDC_ERR_NONE,
                    &TicketRequest.KERB_KDC_REQUEST_preauth_data,
                    &EncryptionKey,
                    &CryptList,
                    &PreAuthDone
                    );
        if (!NT_SUCCESS(Status))
        {
           if (Status == STATUS_UNSUPPORTED_PREAUTH )
           {
               // Log this, every time, as this is impossible to triage otherwise
               KerbReportKerbError(
                   ServiceName,
                   ServerRealm,
                   NULL,
                   Credential,
                   KLIN(FILENO,__LINE__),
                   NULL,
                   KDC_ERR_PADATA_TYPE_NOSUPP,
                   NULL,
                   TRUE
                   );
           }

           D_DebugLog((DEB_ERROR,"Failed to post process pre-auth data: 0x%x. %ws, %d\n",Status, THIS_FILE, __LINE__));
           goto Cleanup;
        }

        KerbFreeCryptList(CryptList);
        CryptList = NULL;
    }

    //
    // If there is any preauth in the response, handle it
    //

    if (EncryptionKey.keyvalue.value == NULL)
    {

        ClientKey = KerbGetKeyFromList(
                        PrimaryCredentials->Passwords,
                        KdcReply->encrypted_part.encryption_type
                        );

        DsysAssert(ClientKey != NULL);

        if (ClientKey == NULL)
        {
            D_DebugLog((DEB_ERROR,"Kdc returned reply with encryption type we don't support: %d. %ws, line %d\n",
                KdcReply->encrypted_part.encryption_type, THIS_FILE, __LINE__));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
    }
    else
    {
        //
        // Use the encryption key we have from the pre-auth data
        //

        ClientKey = &EncryptionKey;
    }


    KerbErr = KerbUnpackKdcReplyBody(
                &KdcReply->encrypted_part,
                ClientKey,
                KERB_ENCRYPTED_AS_REPLY_PDU,
                &ReplyBody
                );


    //
    // if we couldn't decrypt it and we have an old password around,
    // give it a try too before heading to the PDC.
    //

    if ((KerbErr == KRB_AP_ERR_MODIFIED) &&
        (PrimaryCredentials->OldPasswords != NULL) &&
        (EncryptionKey.keyvalue.value == NULL))
    {
        ClientKey = KerbGetKeyFromList(
                        PrimaryCredentials->OldPasswords,
                        KdcReply->encrypted_part.encryption_type
                        );
        if (ClientKey != NULL)
        {
            KerbErr = KerbUnpackKdcReplyBody(
                        &KdcReply->encrypted_part,
                        ClientKey,
                        KERB_ENCRYPTED_AS_REPLY_PDU,
                        &ReplyBody
                        );

        }
    }
    if (!KERB_SUCCESS(KerbErr))
    {

        D_DebugLog((DEB_ERROR,"Failed to decrypt KDC reply body: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));

        //
        // If we didn't try the PDC, try it now.
        //

        if (((RetryFlags & KERB_RETRY_CALL_PDC) == 0) &&
             (KerbErr == KRB_AP_ERR_MODIFIED) &&
             (KerbGlobalRetryPdc))
        {
            RetryFlags |= KERB_RETRY_CALL_PDC;


            KerbFreeAsReply(KdcReply);
            KdcReply = NULL;

            ReplyMessage.Buffer = NULL;

            D_DebugLog((DEB_TRACE_CRED,"KerbGetAuthenticationTicket: Password wrong, trying PDC\n"));
            goto RetryLogon;
        }

        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }


    //
    // Verify the nonce is correct:
    //

    if (RequestBody->nonce != ReplyBody->nonce)
    {
        D_DebugLog((DEB_ERROR,"AS Nonces don't match: 0x%x vs 0x%x. %ws, line %d\n",RequestBody->nonce, ReplyBody->nonce, THIS_FILE, __LINE__));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Update the logon session with the information if we didn't use
    // supplied credentials.
    //

    {
        UNICODE_STRING TempName;
        UNICODE_STRING TempRealm;


        //
        // Get the new client realm & user name - if they are different
        // we will update the logon session. This is in case the user
        // logged on with a nickname (e.g. email name)
        //


        if (!KERB_SUCCESS(KerbConvertPrincipalNameToString(
                &ClientName,
                &NameType,
                &KdcReply->client_name
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // The KDC may hand back names with domains, so split the name
        // now.
        //

        Status = KerbSplitFullServiceName(
                    &ClientName,
                    &TempRealm,
                    &TempName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                &ClientRealm,
                &KdcReply->client_realm
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (!RtlEqualUnicodeString(
                &PrimaryCredentials->UserName,
                &TempName,
                TRUE                // case insensitive
                )) {

            D_DebugLog((DEB_TRACE_LSESS,"UserName different in logon session & AS ticket: %wZ vs %wZ\n",
                &PrimaryCredentials->UserName,
                &TempName
                ));


            KerbFreeString(
                &PrimaryCredentials->UserName
                );

            Status = KerbDuplicateString(
                        &PrimaryCredentials->UserName,
                        &TempName
                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }


        if (!RtlEqualUnicodeString(
                &PrimaryCredentials->DomainName,
                &ClientRealm,
                FALSE // case sensitive, specially for ext chars.
                )) {

            D_DebugLog((DEB_TRACE_LSESS, "Domain name is different in logon session & as ticket: %wZ vs %wZ\n",
                &PrimaryCredentials->DomainName,
                &ClientRealm
                ));

            KerbFreeString(
                &PrimaryCredentials->DomainName
                );
            PrimaryCredentials->DomainName = ClientRealm;
            ClientRealm.Buffer = NULL;
        }
    }


    //
    // Cache the ticket
    //

    DsysAssert(LogonSessionsLocked);


    //
    // Free the cleartext password as we now have a ticket acquired with them.
    //

    if (PrimaryCredentials->ClearPassword.Buffer != NULL)
    {
        RtlZeroMemory(
            PrimaryCredentials->ClearPassword.Buffer,
            PrimaryCredentials->ClearPassword.Length
            );
        KerbFreeString(&PrimaryCredentials->ClearPassword);
    }


    Status = KerbCacheTicket(
                &PrimaryCredentials->AuthenticationTicketCache,
                KdcReply,
                ReplyBody,
                ServiceName,
                ServerRealm,
                CacheFlags,
                TRUE,
                &CacheEntry
                );

    if (!NT_SUCCESS(Status))
    {
       if (Status == STATUS_TIME_DIFFERENCE_AT_DC &&
           ((RetryFlags & KERB_RETRY_TIME_FAILURE) == 0))
       {
          RetryFlags |= KERB_RETRY_TIME_FAILURE;
          KerbUpdateSkewTime(TRUE);
          D_DebugLog((DEB_WARN, "Retrying AS after trying to cache time invalid ticket\n"));
          goto PreauthRestart;
       }

       goto Cleanup;
    }

    if (ARGUMENT_PRESENT(TicketCacheEntry))
    {
        *TicketCacheEntry = CacheEntry;
        CacheEntry = NULL;
    }

    if (ARGUMENT_PRESENT(CredentialKey))
    {
        *CredentialKey = EncryptionKey;
        EncryptionKey.keyvalue.value = NULL;
    }

Cleanup:
    if (HostAddresses != NULL)
    {
        KerbFreeHostAddresses(HostAddresses);
    }
    if (ErrorMessage != NULL)
    {
        KerbFreeKerbError(ErrorMessage);
    }

    if (pExtendedError)
    {
        KerbFreeData(KERB_EXT_ERROR_PDU, pExtendedError);
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    if (CryptVector != NULL)
    {
        KerbFree(CryptVector);
    }

    if (OldPreAuthData != NULL)
    {
        KerbFreeData(
            PKERB_PREAUTH_DATA_LIST_PDU,
            OldPreAuthData
            );
    }
    KerbFreePreAuthData( TicketRequest.KERB_KDC_REQUEST_preauth_data );

    KerbFreeCryptList(
        RequestBody->encryption_type
        );

    KerbFreeCryptList(
        CryptList
        );



    KerbFreeString(
        &ClientName
        );


    KerbFreeKdcName(
        &LocalServiceName
        );


    KerbFreeString(
        &ClientRealm
        );

    KerbFreePrincipalName(
        &RequestBody->KERB_KDC_REQUEST_BODY_client_name
        );

    KerbFreePrincipalName(
        &RequestBody->KERB_KDC_REQUEST_BODY_server_name
        );

    KerbFreeRealm(
        &RequestBody->realm
        );

    KerbFreeKdcReplyBody( ReplyBody );

    KerbFreeAsReply( KdcReply );

    if (CacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }

    if (NewTGT != NULL)
    {
        KerbDereferenceTicketCacheEntry(NewTGT);
    }

    if (ReplyMessage.Buffer != NULL)
    {
        MIDL_user_free(ReplyMessage.Buffer);
    }

    if (RequestMessage.Buffer != NULL)
    {
        MIDL_user_free(RequestMessage.Buffer);
    }


    KerbFreeKey(&EncryptionKey);
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetClientNameAndRealm
//
//  Synopsis:   Proceses the name & realm supplied by a client to determine
//              a name & realm to be sent to the KDC
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS
KerbGetClientNameAndRealm(
    IN OPTIONAL LUID *pLogonId,
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCreds,
    IN BOOLEAN SuppliedCreds,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN OUT OPTIONAL BOOLEAN * MitRealmUsed,
    IN BOOLEAN UseWkstaRealm,
    OUT PKERB_INTERNAL_NAME * ClientName,
    OUT PUNICODE_STRING ClientRealm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ParseFlags = 0;
    ULONG ProcessFlags = 0;
    PUNICODE_STRING UserName = NULL;

    UNICODE_STRING LocalMachineServiceName;
    LUID SystemLogonId = SYSTEM_LUID;


    LocalMachineServiceName.Buffer = NULL;

    //
    // if the computer name has changed, we lie about the machineservicename,
    // since existing creds contain the wrong username
    //

    if (( KerbGlobalMachineNameChanged ) &&
        ( !SuppliedCreds ) &&
        ( pLogonId != NULL ) &&
        ( RtlEqualLuid(pLogonId, &SystemLogonId)))
    {
        D_DebugLog((DEB_WARN,"Netbios machine name change caused credential over-ride.\n"));

        KerbGlobalReadLock();
        Status = KerbDuplicateString( &LocalMachineServiceName, &KerbGlobalMachineServiceName );
        KerbGlobalReleaseLock();

        if(!NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }

        UserName = &LocalMachineServiceName;
    } else {
        UserName = &PrimaryCreds->UserName;
    }


    //
    // Compute the parse flags
    //

    if (PrimaryCreds->DomainName.Length != 0)
    {
        ParseFlags |= KERB_CRACK_NAME_REALM_SUPPLIED;
    }
    else if (UseWkstaRealm)
    {
        ParseFlags |= KERB_CRACK_NAME_USE_WKSTA_REALM;
    }


    Status = KerbProcessTargetNames(
                UserName,
                NULL,
                ParseFlags,
                &ProcessFlags,
                ClientName,
                ClientRealm,
                NULL
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If we were not supplied a realm, use the one from the name
    //

    if (SuppRealm && (SuppRealm->Length != 0))
    {
        KerbFreeString(ClientRealm);
        Status = KerbDuplicateString(
                    ClientRealm,
                    SuppRealm
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else if (PrimaryCreds->DomainName.Length != 0)
    {
        KerbFreeString(ClientRealm);
        Status = KerbDuplicateString(
                    ClientRealm,
                    &PrimaryCreds->DomainName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
Cleanup:
#ifdef notdef
    if (CacheEntry != NULL)
    {
        KerbDereferenceSidCacheEntry(
            CacheEntry
            );
        CacheEntry = NULL;
    }
#endif


    if (ARGUMENT_PRESENT(MitRealmUsed))
    {
        *MitRealmUsed = ((ProcessFlags & KERB_MIT_REALM_USED) != 0);
    }


    KerbFreeString( &LocalMachineServiceName );

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTicketGrantingTicket
//
//  Synopsis:   Gets a TGT for a set of credentials
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetTicketGrantingTicket(
    IN OUT PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    OUT OPTIONAL PKERB_TICKET_CACHE_ENTRY * TicketCacheEntry,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS, LookupStatus = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_INTERNAL_NAME KdcServiceKdcName = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING UClientName = {0};
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING CorrectRealm = {0};
    ULONG RetryCount = KERB_CLIENT_REFERRAL_MAX;
    PKERB_PRIMARY_CREDENTIAL PrimaryCreds;
    PKERB_MIT_REALM MitRealm = NULL;
    ULONG RequestFlags = 0;
    BOOLEAN UsingSuppliedCreds = FALSE;
    BOOLEAN UseWkstaRealm = TRUE;
    BOOLEAN MitRealmLogon = FALSE;
    BOOLEAN UsedPrimaryLogonCreds = FALSE;


    LUID LogonId;


    //
    // Get the proper realm name
    //


    if (ARGUMENT_PRESENT(Credential) && (Credential->SuppliedCredentials != NULL))
    {
        PrimaryCreds = Credential->SuppliedCredentials;
        if ((Credential->CredentialFlags & KERB_CRED_NO_PAC) != 0)
        {
            RequestFlags |= KERB_GET_TICKET_NO_PAC;
        }
        LogonId = Credential->LogonId;
        UsingSuppliedCreds = TRUE;
    }
    else if (ARGUMENT_PRESENT(CredManCredentials))
    {
        PrimaryCreds = CredManCredentials->SuppliedCredentials;
        LogonId = LogonSession->LogonId;
    }
    else
    {
        KerbWriteLockLogonSessions(LogonSession);
        PrimaryCreds = &LogonSession->PrimaryCredentials;
        LogonId = LogonSession->LogonId;

        Status = KerbDuplicateString(
                    &UClientName,
                    &LogonSession->PrimaryCredentials.UserName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        UsedPrimaryLogonCreds = TRUE;
    }

    //
    // Parse the name
    //

    Status = KerbGetClientNameAndRealm(
                &LogonId,
                PrimaryCreds,
                UsingSuppliedCreds,
                SuppRealm,
                &MitRealmLogon,
                UseWkstaRealm,
                &ClientName,
                &ClientRealm
                );
    //
    //   If we're doing a MIT logon, add the MIT logon flag
    //
    if (MitRealmLogon && UsedPrimaryLogonCreds)
    {
       LogonSession->LogonSessionFlags |= KERB_LOGON_MIT_REALM;
    }

    // only needed lock if we're tinkering w/ primary creds
    // in case updates the credentials for that logon id.
    if (UsedPrimaryLogonCreds)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to get client name & realm: 0x%x, %ws line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }



GetTicketRestart:

    KerbErr = KerbBuildFullServiceKdcName(
                &ClientRealm,
                &KerbGlobalKdcServiceName,
                KRB_NT_SRV_INST,
                &KdcServiceKdcName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }



    Status = KerbGetAuthenticationTicket(
                LogonSession,
                Credential,
                CredManCredentials,
                KdcServiceKdcName,
                &ClientRealm,
                ClientName,
                RequestFlags,
                KERB_TICKET_CACHE_PRIMARY_TGT,
                TicketCacheEntry,
                CredentialKey,
                &CorrectRealm
                );
    //
    // If it failed but gave us another realm to try, go there
    //

    if (!NT_SUCCESS(Status) && (CorrectRealm.Length != 0))
    {
       if (--RetryCount != 0)
       {
          KerbFreeKdcName(&KdcServiceKdcName);
          KerbFreeString(&ClientRealm);
          ClientRealm = CorrectRealm;
          CorrectRealm.Buffer = NULL;

          //
          // Might be an MIT realm, in which case we'll need to adjust
          // the client name.  This will also populate the realm list
          // with appropriate entries, so the KerbGetKdcBinding will not
          // hit DNS again.
          //
          if (KerbLookupMitRealmWithSrvLookup(
                           &ClientRealm,
                           &MitRealm,
                           FALSE,
                           FALSE
                           ))
          {
             D_DebugLog((DEB_TRACE,"Reacquiring client name & realm after referral\n"));
             UseWkstaRealm = FALSE;
             KerbFreeKdcName(&ClientName);

             Status = KerbGetClientNameAndRealm(
                        &LogonId,
                        PrimaryCreds,
                        UsingSuppliedCreds,
                        NULL,
                        NULL,
                        UseWkstaRealm,
                        &ClientName,
                        &ClientRealm
                        );

             if (!NT_SUCCESS(Status))
             {
                 goto Cleanup;
             }
          }

          goto GetTicketRestart;

       }
       else
       {
          // Tbd:  Log error here?  Max referrals reached..
          goto Cleanup;
       }

    }
    else if ((Status == STATUS_NO_SUCH_USER) && UsingSuppliedCreds && UseWkstaRealm)
    {
        //
        // We tried using the realm of the workstation and the account couldn't
        // be found - try the realm from the UPN now.
        //

        if (KerbIsThisOurDomain(&ClientRealm))
        {
            UseWkstaRealm = FALSE;

            KerbFreeKdcName(&ClientName);
            KerbFreeString(&ClientRealm);

            //
            // Only do this if the caller did not supply a
            // domain name
            //

            KerbReadLockLogonSessions(LogonSession);
            if (PrimaryCreds->DomainName.Length == 0)
            {

                Status = KerbGetClientNameAndRealm(
                            &LogonId,
                            PrimaryCreds,
                            UsingSuppliedCreds,
                            NULL,
                            NULL,
                            UseWkstaRealm,
                            &ClientName,
                            &ClientRealm
                            );
            }

            KerbUnlockLogonSessions(LogonSession);

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            goto GetTicketRestart;
        }

    }

Cleanup:


    if (Status == STATUS_ACCOUNT_DISABLED && UsedPrimaryLogonCreds)
    {
        D_DebugLog((DEB_ERROR, "Purging NLP Cache entry due to disabled acct.\n"));

        KerbCacheLogonInformation(
            &UClientName,
            &ClientRealm,
            NULL,
            NULL,
            NULL,
            ((LogonSession->LogonSessionFlags & KERB_LOGON_MIT_REALM) != 0),
            MSV1_0_CACHE_LOGON_DELETE_ENTRY,
            NULL,
            NULL,                          // no supplemental creds
            0
            );

    }


    if (UsedPrimaryLogonCreds &&
        ((Status == STATUS_WRONG_PASSWORD) ||
         (Status == STATUS_SMARTCARD_NO_CARD) ||
         (Status == STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED) ))
    {
        KerbPingWlBalloon(&LogonSession->LogonId);
    }


    KerbFreeString(&ClientRealm);
    KerbFreeString(&CorrectRealm);
    KerbFreeString(&UClientName);

    KerbFreeKdcName(&KdcServiceKdcName);
    KerbFreeKdcName(&ClientName);

    return(Status);


}





//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeServiceTicketAndTgt
//
//  Synopsis:   Whacks the service ticket, and its associated TGT, usually as a
//              result of some sort of error condition.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbPurgeServiceTicketAndTgt(
     IN PKERB_CONTEXT Context,
     IN LSA_SEC_HANDLE CredentialHandle,
     IN OPTIONAL PKERB_CREDMAN_CRED CredManHandle
     )
{

   PKERB_PRIMARY_CREDENTIAL   PrimaryCredentials = NULL;
   PKERB_LOGON_SESSION        LogonSession = NULL;
   UNICODE_STRING             RealmName[3];
   PUNICODE_STRING            pTmp = RealmName;
   PKERB_TICKET_CACHE_ENTRY   TicketCacheEntry = NULL;
   PKERB_CREDENTIAL           Credential = NULL;
   BOOLEAN                    CacheLocked = FALSE, fRet = FALSE;
   NTSTATUS                   Status;

   // Validate in params
   // If any of these fires, contact Todds
   DsysAssert(NULL != CredentialHandle);
   DsysAssert(NULL != Context->TicketCacheEntry );
   DsysAssert(NULL != Context->TicketCacheEntry->TargetDomainName.Buffer);

   Status = KerbReferenceCredential(
                  CredentialHandle,
                  0,
                  FALSE,
                  &Credential
                  );

   if (!NT_SUCCESS(Status) || Credential == NULL)
   {
      D_DebugLog((DEB_ERROR,"KerbPurgeServiceTicket supplied w/ bogus cred handle\n"));
      goto Cleanup;
   }

   LogonSession = KerbReferenceLogonSession(&Credential->LogonId, FALSE);
   if (NULL == LogonSession)
   {
      D_DebugLog((DEB_ERROR, "Couldn't find LUID %x\n", Credential->LogonId));
      goto Cleanup;
   }

   KerbReadLockLogonSessions(&KerbLogonSessionList);
   if (NULL != Credential && Credential->SuppliedCredentials != NULL)
   {
      PrimaryCredentials = Credential->SuppliedCredentials;
      D_DebugLog((DEB_TRACE, "Purging tgt associated with SUPPLIED creds (%S\\%S)\n",
                PrimaryCredentials->DomainName.Buffer,PrimaryCredentials->UserName.Buffer));

   }
   else if ARGUMENT_PRESENT(CredManHandle)
   {

      PrimaryCredentials = CredManHandle->SuppliedCredentials;
      D_DebugLog((DEB_TRACE, "Purging tgt associated with CREDMAN creds (%S\\%S)\n",
                PrimaryCredentials->DomainName.Buffer,PrimaryCredentials->UserName.Buffer));

   }
   else
   {
      PrimaryCredentials = &LogonSession->PrimaryCredentials;
      D_DebugLog((DEB_TRACE, "Purging tgt associated with PRIMARY creds (%S\\%S)\n",
                PrimaryCredentials->DomainName.Buffer,PrimaryCredentials->UserName.Buffer));
   }

   KerbWriteLockContexts();
   TicketCacheEntry = Context->TicketCacheEntry;
   Context->TicketCacheEntry = NULL;
   KerbUnlockContexts();

   KerbReadLockTicketCache();
   CacheLocked = TRUE;

   // Do some mem copy rather than block over ticket cache searches
   RtlCopyMemory(RealmName, &TicketCacheEntry->TargetDomainName, sizeof(UNICODE_STRING));
   RealmName[0].Buffer = (PWSTR) KerbAllocate(RealmName[0].MaximumLength);
   if (NULL == RealmName[0].Buffer)
   {
      goto Cleanup;
   }

   RtlCopyUnicodeString(
      &RealmName[0],
      &TicketCacheEntry->TargetDomainName
      );

   RtlCopyMemory(&RealmName[1],&TicketCacheEntry->AltTargetDomainName, sizeof(UNICODE_STRING));
   if (RealmName[1].Buffer != NULL && RealmName[1].MaximumLength != 0)
   {
      RealmName[1].Buffer = (PWSTR) KerbAllocate(RealmName[1].MaximumLength);
      if (NULL == RealmName[1].Buffer)
      {
         goto Cleanup;
      }

      RtlCopyUnicodeString(
         &RealmName[1],
         &TicketCacheEntry->TargetDomainName
         );
   }
   KerbUnlockTicketCache();
   CacheLocked = FALSE;

   RtlInitUnicodeString(
      &RealmName[2],
      NULL
      );

   // Kill the service ticket
   KerbRemoveTicketCacheEntry(TicketCacheEntry);

   do
   {
      PKERB_TICKET_CACHE_ENTRY   DummyEntry = NULL;

      DummyEntry = KerbLocateTicketCacheEntryByRealm(
                        &PrimaryCredentials->AuthenticationTicketCache,
                        pTmp,
                        KERB_TICKET_CACHE_PRIMARY_TGT
                        );

      if (NULL == DummyEntry)
      {
         D_DebugLog((DEB_TRACE, "Didn't find primary TGT for %S \n", pTmp->Buffer));
      }
      else
      {
         KerbRemoveTicketCacheEntry(DummyEntry);
         KerbDereferenceTicketCacheEntry(DummyEntry);
      }

      DummyEntry = KerbLocateTicketCacheEntryByRealm(
                        &PrimaryCredentials->AuthenticationTicketCache,
                        pTmp,
                        KERB_TICKET_CACHE_DELEGATION_TGT
                        );

      if (NULL == DummyEntry)
      {
         D_DebugLog((DEB_TRACE, "Didn't find delegation TGT for %S\n", pTmp->Buffer));
      }
      else
      {
         KerbRemoveTicketCacheEntry(DummyEntry);
         KerbDereferenceTicketCacheEntry(DummyEntry);
      }

      pTmp++;

   } while (pTmp->Buffer != NULL);

   fRet = TRUE;

Cleanup:

   if (CacheLocked)
   {
      KerbUnlockTicketCache();
   }

   if (NULL != Credential)
   {
      KerbDereferenceCredential(Credential);
   }

   KerbUnlockLogonSessions(&KerbLogonSessionList);

   if (NULL != LogonSession)
   {
      KerbDereferenceLogonSession(LogonSession);
   }

   if (RealmName[0].Buffer != NULL)
   {
      KerbFree(RealmName[0].Buffer);
   }

   if (RealmName[1].Buffer != NULL)
   {
      KerbFree(RealmName[1].Buffer);
   }

   return fRet;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCopyTicketCache
//
//  Synopsis:   Copies the authentication ticket cache from one
//              logon session to another.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbUpdateOldLogonSession(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PLUID OldLogonId,
    IN PKERB_TICKET_CACHE_ENTRY NewWorkstationTicket
    )
{
    PKERB_LOGON_SESSION     OldLogonSession;

    OldLogonSession = KerbReferenceLogonSession(
                        OldLogonId,
                        FALSE                           // don't unlink
                        );
    if (OldLogonSession == NULL)
    {
        goto Cleanup;
    }

    KerbWriteLockLogonSessions(OldLogonSession);
    KerbWriteLockLogonSessions(LogonSession);
    KerbWriteLockTicketCache();

    //
    // Make sure the two accounts are the same before copying tickets
    // around.
    //

    if ((RtlEqualUnicodeString(
            &LogonSession->PrimaryCredentials.UserName,
            &OldLogonSession->PrimaryCredentials.UserName,
            TRUE                                        // case insensitive
            )) &&
        (RtlEqualUnicodeString(
            &LogonSession->PrimaryCredentials.DomainName,
            &OldLogonSession->PrimaryCredentials.DomainName,
            TRUE                                        // case insensitive
            )))
    {

        PKERB_TICKET_CACHE_ENTRY ASTicket = NULL;


        //
        // Search for the new TGT so we can put it in the old
        // cache.
        //


        ASTicket = KerbLocateTicketCacheEntryByRealm(
                        &LogonSession->PrimaryCredentials.AuthenticationTicketCache,
                        NULL,               // get initial ticket
                        KERB_TICKET_CACHE_PRIMARY_TGT
                        );

        if (ASTicket != NULL)
        {
            OldLogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;
            KerbRemoveTicketCacheEntry(ASTicket);
        }
        else
        {
            //
            // Hold on to our old TGT if we didn't get one this time around..
            //

            D_DebugLog((DEB_ERROR, "Failed to find primary TGT on unlock logon session\n"));

            ASTicket = KerbLocateTicketCacheEntryByRealm(
                                &OldLogonSession->PrimaryCredentials.AuthenticationTicketCache,
                                NULL,
                                KERB_TICKET_CACHE_PRIMARY_TGT
                                );

            if (ASTicket != NULL)
            {
                //
                // Copy into new logon session cache for later reuse.
                //
                KerbRemoveTicketCacheEntry(ASTicket);
                OldLogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;
            }
            else
            {
                //
                // No TGT in either new or old logonsession -- we're deferred...
                //
                D_DebugLog((DEB_ERROR, "Failed to find primary TGT on *OLD* logon session\n"));
                OldLogonSession->LogonSessionFlags |= KERB_LOGON_DEFERRED;
            }
        }

        if ((LogonSession->LogonSessionFlags & KERB_LOGON_SMARTCARD) != 0)
        {
            OldLogonSession->LogonSessionFlags |= KERB_LOGON_SMARTCARD;
        }

        //
        // swap the primary creds
        //
        KerbFreePrimaryCredentials(&OldLogonSession->PrimaryCredentials, FALSE);

        if ( NewWorkstationTicket != NULL )
        {
            KerbRemoveTicketCacheEntry(NewWorkstationTicket);
        }

        KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.AuthenticationTicketCache);
        KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.S4UTicketCache);
        KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.ServerTicketCache);

        RtlCopyMemory(
            &OldLogonSession->PrimaryCredentials,
            &LogonSession->PrimaryCredentials,
            sizeof(KERB_PRIMARY_CREDENTIAL)
            );

        RtlZeroMemory(
            &LogonSession->PrimaryCredentials,
            sizeof(KERB_PRIMARY_CREDENTIAL)
            );


        // Fix up list entry pointers.
        KerbInitTicketCache(&OldLogonSession->PrimaryCredentials.AuthenticationTicketCache);
        KerbInitTicketCache(&OldLogonSession->PrimaryCredentials.S4UTicketCache);
        KerbInitTicketCache(&OldLogonSession->PrimaryCredentials.ServerTicketCache);

        KerbInitTicketCache(&LogonSession->PrimaryCredentials.AuthenticationTicketCache);
        KerbInitTicketCache(&LogonSession->PrimaryCredentials.S4UTicketCache);
        KerbInitTicketCache(&LogonSession->PrimaryCredentials.ServerTicketCache);

        // insert new tickets into old logon session
        if (ASTicket != NULL)
        {
            KerbInsertTicketCacheEntry(&OldLogonSession->PrimaryCredentials.AuthenticationTicketCache, ASTicket);
            KerbDereferenceTicketCacheEntry(ASTicket); // for locate call above
        }

        if (NewWorkstationTicket != NULL)
        {
            KerbInsertTicketCacheEntry(&OldLogonSession->PrimaryCredentials.ServerTicketCache, NewWorkstationTicket);
        }


    }
    KerbUnlockTicketCache();
    KerbUnlockLogonSessions(LogonSession);
    KerbUnlockLogonSessions(OldLogonSession);
    KerbDereferenceLogonSession(OldLogonSession);

Cleanup:



    return;
}

#ifndef WIN32_CHICAGO // later

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckDomainlessLogonPolicy
//
//  Synopsis:   If a machine is not a member of a domain or MIT realm,
//              we've got to verify that the kerberos principal is mapped
//              to a local account.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
KerbCheckRealmlessLogonPolicy(
    IN PKERB_TICKET_CACHE_ENTRY AsTicket,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;


    //
    //  Sanity check to prevent identity spoofing for
    //  gaining access to a machine
    //
    //  tbd:  Credman support?  Seems like we should be using credman
    //  credentials, if present, but for logon???
    //
    if (!KerbEqualKdcNames(
                    ClientName,
                    AsTicket->ClientName) ||
        !RtlEqualUnicodeString(
                    &AsTicket->ClientDomainName,
                    ClientRealm,
                    TRUE
                    ))
    {
        D_DebugLog((DEB_ERROR, "Logon session and AS ticket identities don't match\n"));
        // tbd:  Log names?
        Status = STATUS_NO_SUCH_USER;
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   LsaApLogonUserEx2
//
//  Synopsis:   Handles service, batch, and interactive logons
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsaApLogonUserEx2(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID NewLogonId,
    OUT PNTSTATUS ApiSubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_INTERACTIVE_LOGON LogonInfo = NULL;
    UCHAR Seed;
    UNICODE_STRING TempName = NULL_UNICODE_STRING;
    UNICODE_STRING TempAuthority = NULL_UNICODE_STRING;
    UNICODE_STRING NullAuthority = NULL_UNICODE_STRING;
    UNICODE_STRING MappedClientName = NULL_UNICODE_STRING;
    LUID LogonId;
    LUID OldLogonId;
    BOOLEAN DoingUnlock = FALSE, WkstaAccount = FALSE;
    PKERB_TICKET_CACHE_ENTRY WorkstationTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY AsTicket = NULL;
    KERB_MESSAGE_BUFFER ForwardedTgt = {0};
    KERBEROS_MACHINE_ROLE Role;
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN LocalLogon = FALSE, RealmlessWkstaLogon = FALSE;
    BOOLEAN UsedAlternateName = FALSE;
    BOOLEAN MitRealmLogon = FALSE;
    KERB_ENCRYPTION_KEY CredentialKey = {0};
    UNICODE_STRING DomainName = {0};
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING ClientRealm = {0};
    PKERB_INTERNAL_NAME MachineServiceName = {0};
    PKERB_INTERNAL_NAME S4UClientName = {0};
    UNICODE_STRING S4UClientRealm = {0};
    UNICODE_STRING CorrectRealm = {0};
    PLSAPR_CR_CIPHER_VALUE SecretCurrent = NULL;
    SECPKG_CLIENT_INFO            ClientInfo;
    UNICODE_STRING Prefix, SavedPassword = {0};
    BOOLEAN ServiceSecretLogon = FALSE;
    ULONG ProcessFlags = 0;
    PCERT_CONTEXT CertContext = NULL;
    BOOLEAN fSuppliedCertCred = FALSE;
    PVOID pTempSubmitBuffer = ProtocolSubmitBuffer;
    PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO4 SCValidationInfo = NULL;
    GUID LogonGuid = { 0 };

    //
    // Credential manager stored credentials.
    //

    UNICODE_STRING CredmanUserName;
    UNICODE_STRING CredmanDomainName;
    UNICODE_STRING CredmanPassword;

#if _WIN64

    BOOL  fAllocatedSubmitBuffer = FALSE;

#endif  // _WIN64

    KERB_LOGON_INFO LogonTraceInfo;

    if (LogonType == CachedInteractive) {

        //
        // We don't support cached logons.
        //

        return STATUS_INVALID_LOGON_TYPE;
    }

    if( KerbEventTraceFlag ) // Event Trace:  KerbLogonUserStart {No Data}
    {
        // Set trace parameters
        LogonTraceInfo.EventTrace.Guid       = KerbLogonGuid;
        LogonTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        LogonTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
        LogonTraceInfo.EventTrace.Size       = sizeof(EVENT_TRACE_HEADER);

        TraceEvent(
            KerbTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&LogonTraceInfo);
    }

    //
    // First initialize all the output parameters to NULL.
    //

    *ProfileBuffer = NULL;
    *ApiSubStatus = STATUS_SUCCESS;
    *TokenInformation = NULL;
    *AccountName = NULL;
    *AuthenticatingAuthority = NULL;
    *MachineName = NULL;
    *CachedCredentials = NULL;

    CredmanUserName.Buffer      = NULL;
    CredmanDomainName.Buffer    = NULL;
    CredmanPassword.Buffer      = NULL;

    RtlZeroMemory(
        PrimaryCredentials,
        sizeof(SECPKG_PRIMARY_CRED)
        );

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    //
    // Make sure we have at least tcp as a xport, unless we are doing
    // cached sc logon, in which case we'll let them get through.
    //

    KerbGlobalReadLock();
    if (KerbGlobalNoTcpUdp)
    {
        Status = STATUS_NETWORK_UNREACHABLE;
    }
    KerbGlobalReleaseLock();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Role = KerbGetGlobalRole();

    *AccountName = (PUNICODE_STRING) KerbAllocate(sizeof(UNICODE_STRING));
    if (*AccountName == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    (*AccountName)->Buffer = NULL;

    *AuthenticatingAuthority = (PUNICODE_STRING) KerbAllocate(sizeof(UNICODE_STRING));
    if (*AuthenticatingAuthority == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    (*AuthenticatingAuthority)->Buffer = NULL;


    //
    // Initialize local pointers to NULL
    //

    LogonId.LowPart = 0;
    LogonId.HighPart = 0;
    *NewLogonId = LogonId;


    //
    // Check the logon type
    //

    switch (LogonType) {

    case Service:
    case Interactive:
    case Batch:
    case Network:
    case NetworkCleartext:
    case RemoteInteractive:


        PSECURITY_SEED_AND_LENGTH SeedAndLength;

        LogonInfo = (PKERB_INTERACTIVE_LOGON) pTempSubmitBuffer;

        if (SubmitBufferSize < sizeof(KERB_LOGON_SUBMIT_TYPE))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

#if _WIN64

        SECPKG_CALL_INFO  CallInfo;

        //
        // Expand the ProtocolSubmitBuffer to 64-bit pointers if this
        // call came from a WOW client.
        //

        if(!LsaFunctions->GetCallInfo(&CallInfo))
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
        {
            Status = KerbConvertWOWLogonBuffer(ProtocolSubmitBuffer,
                                               ClientBufferBase,
                                               &SubmitBufferSize,
                                               LogonInfo->MessageType,
                                               &pTempSubmitBuffer);

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            fAllocatedSubmitBuffer = TRUE;

            //
            // Some macros below expand out to use ProtocolSubmitBuffer directly.
            // We've secretly replaced their usual ProtocolSubmitBuffer with
            // pTempSubmitBuffer -- let's see if they can tell the difference.
            //

            ProtocolSubmitBuffer = pTempSubmitBuffer;
            LogonInfo = (PKERB_INTERACTIVE_LOGON) pTempSubmitBuffer;
        }


#endif  // _WIN64


        if ((LogonInfo->MessageType == KerbInteractiveLogon) ||
            (LogonInfo->MessageType == KerbWorkstationUnlockLogon))
        {
            //
            // Pull the interesting information out of the submit buffer
            //

            if (LogonInfo->MessageType == KerbInteractiveLogon)
            {
                if (SubmitBufferSize < sizeof(KERB_INTERACTIVE_LOGON))
                {
                    D_DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
            else
            {
                if (SubmitBufferSize < sizeof(KERB_INTERACTIVE_UNLOCK_LOGON))
                {
                    D_DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }
                PKERB_INTERACTIVE_UNLOCK_LOGON UnlockInfo = (PKERB_INTERACTIVE_UNLOCK_LOGON) LogonInfo;

                OldLogonId = UnlockInfo->LogonId;
                DoingUnlock = TRUE;
            }

            //
            // If the password length is greater than 255 (i.e., the
            // upper byte of the length is non-zero) then the password
            // has been run-encoded for privacy reasons.  Get the
            // run-encode seed out of the upper-byte of the length
            // for later use.
            //

            SeedAndLength = (PSECURITY_SEED_AND_LENGTH)
                            &LogonInfo->Password.Length;
            Seed = SeedAndLength->Seed;
            SeedAndLength->Seed = 0;

            //
            // Enforce length restrictions on username and password.
            //

            if ( LogonInfo->UserName.Length > (UNLEN * sizeof(WCHAR)) ||
                LogonInfo->Password.Length > (PWLEN * sizeof(WCHAR)) ) {
                D_DebugLog((DEB_ERROR,"LsaApLogonUserEx2: Name or password too long. %ws, line%d\n", THIS_FILE, __LINE__));
                Status = STATUS_NAME_TOO_LONG;
                goto Cleanup;
            }


            //
            // Relocate any pointers to be relative to 'LogonInfo'
            //


            RELOCATE_ONE(&LogonInfo->UserName);
            NULL_RELOCATE_ONE(&LogonInfo->LogonDomainName);
            NULL_RELOCATE_ONE(&LogonInfo->Password);

            if( (LogonInfo->LogonDomainName.Length <= sizeof(WCHAR)) &&
                (LogonInfo->Password.Length <= sizeof(WCHAR))
                )
            {
                if(KerbProcessUserNameCredential(
                                &LogonInfo->UserName,
                                &CredmanUserName,
                                &CredmanDomainName,
                                &CredmanPassword
                                ) == STATUS_SUCCESS)
                {
                    LogonInfo->UserName = CredmanUserName;
                    LogonInfo->LogonDomainName = CredmanDomainName;
                    LogonInfo->Password = CredmanPassword;
                    Seed = 0;
                }
            }


            if ( LogonType == Service )
            {
                SECPKG_CALL_INFO   CallInfo;

                //
                // If we have a service logon, the password we got is likely the name of the
                // secret that is holding the account password.  Make sure to read that secret
                // here
                //

                RtlInitUnicodeString( &Prefix, L"_SC_" );
                if ( (RtlPrefixUnicodeString( &Prefix, &LogonInfo->Password, TRUE )) &&
                     (LsaFunctions->GetCallInfo(&CallInfo)) &&
                     (CallInfo.Attributes & SECPKG_CALL_IS_TCB)
                    )
                {
                    LSAPR_HANDLE SecretHandle = NULL;

                    Status = LsarOpenSecret( KerbGlobalPolicyHandle,
                                             ( PLSAPR_UNICODE_STRING )&LogonInfo->Password,
                                             SECRET_QUERY_VALUE,
                                             &SecretHandle );

                    if ( NT_SUCCESS( Status ) ) {

                        Status = LsarQuerySecret( SecretHandle,
                                                  &SecretCurrent,
                                                  NULL,
                                                  NULL,
                                                  NULL );

                        if ( NT_SUCCESS( Status ) && (SecretCurrent != NULL) ) {

                            RtlCopyMemory( &SavedPassword,
                                           &LogonInfo->Password,
                                           sizeof( UNICODE_STRING ) );
                            LogonInfo->Password.Length = ( USHORT )SecretCurrent->Length;
                            LogonInfo->Password.MaximumLength =
                                                       ( USHORT )SecretCurrent->MaximumLength;
                            LogonInfo->Password.Buffer = ( USHORT * )SecretCurrent->Buffer;
                            ServiceSecretLogon = TRUE;
                        }

                        LsarClose( &SecretHandle );
                    }
                }


                if ( !NT_SUCCESS( Status ) ) {

                    goto Cleanup;
                }

            }

            D_DebugLog((DEB_TRACE,"Logging on user %wZ, domain %wZ\n",
                &LogonInfo->UserName,
                &LogonInfo->LogonDomainName
                ));

            KerbGlobalReadLock();

            WkstaAccount = RtlEqualUnicodeString(
                                &KerbGlobalMachineName,
                                &LogonInfo->LogonDomainName,
                                TRUE
                                );

            KerbGlobalReleaseLock();


            // In the case where we're doing a realmless wksta
            // logon, then run see if there's a client mapping,
            // but only for interactive logons
            if ((!WkstaAccount) &&
                (Role == KerbRoleRealmlessWksta) &&
                (LogonType == Interactive ))
            {
                Status = KerbProcessTargetNames(
                                &LogonInfo->UserName,
                                NULL,
                                0,
                                &ProcessFlags,
                                &ClientName,
                                &ClientRealm,
                                NULL
                                );

                if (NT_SUCCESS(Status))
                {
                    Status = KerbMapClientName(
                                &MappedClientName,
                                ClientName,
                                &ClientRealm
                                );
                }

                if (NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_WARN, "Mapping user to MIT principal\n"));
                    RealmlessWkstaLogon = TRUE;
                }
            }

            if (WkstaAccount  ||
                 (KerbGlobalDomainIsPreNT5 && !RealmlessWkstaLogon) ||
                 (KerbGlobalSafeModeBootOptionPresent))
            {

                D_DebugLog(( DEB_TRACE, "Local Logon, bailing out now\n" ));
                Status = STATUS_NO_LOGON_SERVERS;
                goto Cleanup ;
            }


            //
            // Now decode the password, if necessary
            //

            if (Seed != 0 ) {
                __try {
                    RtlRunDecodeUnicodeString( Seed, &LogonInfo->Password);
                } __except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = STATUS_ILL_FORMED_PASSWORD;
                    goto Cleanup;
                }
            }

            //
            // Check if the user name holds a cert context thumbprint
            //

            Status = KerbCheckUserNameForCert(
                            NULL,
                            TRUE,
                            &LogonInfo->UserName,
                            &CertContext
                            );
            if (NT_SUCCESS(Status))
            {
                if (NULL != CertContext)
                {
                    fSuppliedCertCred = TRUE;
                }
                else
                {
                    //
                    // Copy out the user name and Authenticating Authority so we can audit them.
                    //

                    Status = KerbDuplicateString(
                                &TempName,
                                &LogonInfo->UserName
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }
                }
            }
            else
            {
                goto Cleanup;
            }

            if ( LogonInfo->LogonDomainName.Buffer != NULL ) {

                Status = KerbDuplicateString(
                            &TempAuthority,
                            &LogonInfo->LogonDomainName
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }
            }


            //
            // Allocate a locally unique ID for this logon session. We will
            // create it in the LSA just before returning.
            //

            Status = NtAllocateLocallyUniqueId( &LogonId );
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }


            if (fSuppliedCertCred)
            {
                //
                // Build a logon session to hold all this information
                // for a smart card logon
                //

                Status = KerbCreateSmartCardLogonSessionFromCertContext(
                            &CertContext,
                            &LogonId,
                            &NullAuthority,
                            &LogonInfo->Password,
                            NULL,        // no CSP data
                            0,           // no CSP data
                            &LogonSession,
                            &TempName
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }
            }
            else
            {
                //
                // Build a logon session to hold all this information
                //

                Status = KerbCreateLogonSession(
                            &LogonId,
                            &TempName,
                            &TempAuthority,
                            &LogonInfo->Password,
                            NULL,                       // no old password
                            PRIMARY_CRED_CLEAR_PASSWORD,
                            LogonType,
                            &LogonSession
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }
            }
        }
        else if ((LogonInfo->MessageType == KerbSmartCardLogon) ||
                 (LogonInfo->MessageType == KerbSmartCardUnlockLogon))
        {

            if (LogonInfo->MessageType == KerbSmartCardUnlockLogon)
            {
                if (SubmitBufferSize < sizeof(KERB_SMART_CARD_UNLOCK_LOGON))
                {
                    D_DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }
                PKERB_SMART_CARD_UNLOCK_LOGON UnlockInfo = (PKERB_SMART_CARD_UNLOCK_LOGON) LogonInfo;

                OldLogonId = UnlockInfo->LogonId;
                DoingUnlock = TRUE;
            }

            Status = KerbCreateSmartCardLogonSession(
                        pTempSubmitBuffer,
                        ClientBufferBase,
                        SubmitBufferSize,
                        LogonType,
                        &LogonSession,
                        &LogonId,
                        &TempName,
                        &TempAuthority
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else if ((LogonInfo->MessageType == KerbTicketLogon) ||
                 (LogonInfo->MessageType == KerbTicketUnlockLogon))
        {
            if (LogonInfo->MessageType == KerbTicketUnlockLogon)
            {
                if (SubmitBufferSize < sizeof(KERB_TICKET_UNLOCK_LOGON))
                {
                    D_DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }
                PKERB_TICKET_UNLOCK_LOGON UnlockInfo = (PKERB_TICKET_UNLOCK_LOGON) LogonInfo;

                OldLogonId = UnlockInfo->LogonId;
                DoingUnlock = TRUE;
            }

            //
            // Ticket logons *must* have TCB.  This prevents arbitrary users from
            // gathering service tickets for given hosts, and presenting them in order
            // to spoof the client of those tickets.
            //
            Status = LsaFunctions->GetClientInfo( &ClientInfo );
            if ( !NT_SUCCESS( Status ))
            {
                goto Cleanup;
            }

            if ( !ClientInfo.HasTcbPrivilege )
            {
                DebugLog((DEB_ERROR, "Calling ticket logon / unlock without TCB\n"));
                Status = STATUS_PRIVILEGE_NOT_HELD;
                goto Cleanup;
            }

            Status = KerbCreateTicketLogonSession(
                        pTempSubmitBuffer,
                        ClientBufferBase,
                        SubmitBufferSize,
                        LogonType,
                        &LogonSession,
                        &LogonId,
                        &WorkstationTicket,
                        &ForwardedTgt
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        //
        // The S4UToSelf Logon really is quite different
        // than any other form of logon.  As such, we're
        // going to branch out into the S4UToSelf protocol
        // code.
        //
        else if (LogonInfo->MessageType == KerbS4ULogon)
        {
            if (SubmitBufferSize < sizeof(KERB_S4U_LOGON))
            {
                D_DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            if ( LogonType != Network )
            {
                D_DebugLog((DEB_ERROR, "LogonType must be network for S4ULogon\n"));
                Status = STATUS_INVALID_LOGON_TYPE;
                goto Cleanup;
            }

            Status = KerbS4UToSelfLogon(
                        pTempSubmitBuffer,
                        ClientBufferBase,
                        SubmitBufferSize,
                        &LogonSession,
                        &LogonId,
                        &WorkstationTicket,
                        &S4UClientName,
                        &S4UClientRealm
                        );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "KerbS4UToSelfLogon failed - %x\n", Status));
                goto Cleanup;
            }
        }

        else
        {
            D_DebugLog((DEB_ERROR,"Invalid info class to logon: %d. %ws, line %d\n",
                LogonInfo->MessageType, THIS_FILE, __LINE__));
            Status = STATUS_INVALID_INFO_CLASS;
            goto Cleanup;
        }

        break;

    default:
        //
        // No other logon types are supported.
        //

        Status = STATUS_INVALID_LOGON_TYPE;
        D_DebugLog((DEB_ERROR, "Invalid logon type passed to LsaApLogonUserEx2: %d. %ws, line %d\n",LogonType, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE,"LogonUser: Attempting to logon user %wZ\\%wZ\n",
        &TempAuthority,
        &TempName
        ));

    //
    // If the KDC is not yet started, start it now.
    //

#ifndef WIN32_CHICAGO
    if ((KerbGlobalRole == KerbRoleDomainController) && !KerbKdcStarted)
    {
        D_DebugLog((DEB_TRACE_LOGON,"Waiting for KDC to start\n"));
        Status = KerbWaitForKdc( KerbGlobalKdcWaitTime );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_TRACE_LOGON,"Failed to wait for KDC to start\n"));
            goto Cleanup;
        }

    }
#endif // WIN32_CHICAGO


    //
    // If we don't have a workstation ticket already, attempt to get one now.
    //

    // Per bug 94726, if we're not part of an NT domain, then we should not require
    // the workstation ticket to perform the logon successfully.

    if (WorkstationTicket == NULL)
    {


        //
        // Get the initial TGT for the user. This routine figures out the real
        // principal names & realm names
        //

        Status = KerbGetTicketGrantingTicket(
                    LogonSession,
                    NULL,
                    NULL,
                    NULL,           // no credential
                    (Role == KerbRoleRealmlessWksta ? &AsTicket : NULL),
                    &CredentialKey
                    );

        if ( Status == STATUS_NO_TRUST_SAM_ACCOUNT )
        {
            Status = STATUS_NO_LOGON_SERVERS ;
        }


        if (NT_SUCCESS(Status))
        {
            if (Role != KerbRoleRealmlessWksta) // joined machine
            {
                KerbWriteLockLogonSessions(LogonSession);
                LogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;
                KerbUnlockLogonSessions(LogonSession);

                //
                // Check to see if the client is from an MIT realm
                //

                KerbGlobalReadLock();

                (VOID) KerbLookupMitRealm(
                            &KerbGlobalDnsDomainName,
                            &MitRealm,
                            &UsedAlternateName
                            );

                Status = KerbDuplicateKdcName(
                            &MachineServiceName,
                            KerbGlobalMitMachineServiceName
                            );

                KerbGlobalReleaseLock();
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                Status = KerbGetOurDomainName(
                            &DomainName
                            );

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                //
                // Now that we have a TGT, we need to build a token.  The PAC is currently
                // hidden inside the TGT, so we need to get a ticket to this workstation
                //

                D_DebugLog((DEB_TRACE_LOGON,"Getting outbound ticket to "));
                D_KerbPrintKdcName(DEB_TRACE_LOGON, MachineServiceName );

                Status = KerbGetServiceTicket(
                            LogonSession,
                            NULL,               // no credential
                            NULL,
                            MachineServiceName,
                            &DomainName,
			    NULL,
                            ProcessFlags,
                            0,                  // no options
                            0,                  // no enc type
                            NULL,               // no error message
                            NULL,               // no authorization data
                            NULL,               // no TGT reply
                            &WorkstationTicket,
                            &LogonGuid
                            );

                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"LogonUser: Failed to get workstation ticket for %wZ\\%wZ: 0x%x. %ws, line %d\n",
                              &TempAuthority, &TempName, Status, THIS_FILE, __LINE__ ));
                    goto Cleanup;
                }
            }
            else
            {
                D_DebugLog((DEB_ERROR, "Nonjoined workstation\n"));
                DsysAssert(AsTicket != NULL);
                DsysAssert(MappedClientName.Buffer != NULL);

                Status = KerbCheckRealmlessLogonPolicy(
                                    AsTicket,
                                    ClientName,
                                    &ClientRealm
                                    );

                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR, "LogonUser:  Failed check for domainless logon\n"));
                    goto Cleanup;
                }

            }
        }
        else
        {
            DebugLog((DEB_WARN, "LogonUser: Failed to get TGT for %wZ\\%wZ : 0x%x\n",
                      &TempAuthority,
                      &TempName,
                      Status ));

            //
            // If this was a smart card logon, try logging on locally for
            // non-definitive errors:
            //

            if ( ( (LogonInfo->MessageType == KerbSmartCardLogon ) ||
                   (LogonInfo->MessageType == KerbSmartCardUnlockLogon ) ) &&
                 ( ( Status == STATUS_NO_LOGON_SERVERS ) ||
                   ( Status == STATUS_NETWORK_UNREACHABLE ) ||// From DsGetdcName
                   ( Status == STATUS_NETLOGON_NOT_STARTED ) ) )
                {

                Status = KerbDoLocalSmartCardLogon(
                                LogonSession,
                                TokenInformationType,
                                TokenInformation,
                                ProfileBufferLength,
                                ProfileBuffer,
                                PrimaryCredentials,
                                CachedCredentials,
                                &SCValidationInfo
                                );

                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"Failed smart card local logon: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }

                LocalLogon = TRUE;

            }
            else
            {
                //
                // Not smart card
                //

                goto Cleanup;
            }

        }
    }



    //
    // If we didn't already build a ticket, do so now
    //

    if (!LocalLogon)
    {
        Status = KerbCreateTokenFromLogonTicket(
                    WorkstationTicket,
                    &LogonId,
                    LogonInfo,
                    (LogonType == Interactive || LogonType == Service || LogonType == Batch || LogonType == RemoteInteractive ) ? TRUE : FALSE,      // cache interactive logons only
                    RealmlessWkstaLogon,
                    &CredentialKey,
                    &ForwardedTgt,
                    &MappedClientName,
                    S4UClientName,
                    &S4UClientRealm,
                    LogonSession,
                    TokenInformationType,
                    TokenInformation,
                    ProfileBufferLength,
                    ProfileBuffer,
                    PrimaryCredentials,
                    CachedCredentials,
                    &ValidationInfo
                    );


        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"LogonUser: Failed to create token from ticket: 0x%x\n",Status));
            goto Cleanup;
        }

        //
        // Cache the sid, if we are caching - meaning this is an
        // interactive logon to an NT domain and we have a sid
        //

        if (( (LogonType == Interactive) || (LogonType == RemoteInteractive )) &&
            (PrimaryCredentials != NULL) &&
            (PrimaryCredentials->UserSid != NULL) &&
            (MitRealm == NULL) && !RealmlessWkstaLogon
            )
        {
            //
            // Store the pertinent info in the cache.
            //

            KerbReadLockLogonSessions(LogonSession);
            KerbCacheLogonSid(
                &TempName,
                &TempAuthority,
                &LogonSession->PrimaryCredentials.DomainName,
                PrimaryCredentials->UserSid
                );
            KerbUnlockLogonSessions(LogonSession);

        }
        //
        // Add the password to the primary credentials.
        //

        if (LogonInfo->MessageType == KerbInteractiveLogon)
        {
            Status = KerbDuplicateString(
                        &PrimaryCredentials->Password,
                        &LogonInfo->Password
                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            PrimaryCredentials->Flags |= PRIMARY_CRED_CLEAR_PASSWORD;
        }
    }

    //
    // Get the final doamin name and user name out of the logon session,
    // if it is different than the one used for logon.
    //

    KerbReadLockLogonSessions(LogonSession);
    if (!RtlEqualUnicodeString(
            &TempName,
            &PrimaryCredentials->DownlevelName,
            TRUE))
    {
        KerbFreeString(&TempName);
        Status = KerbDuplicateString(
                    &TempName,
                    &PrimaryCredentials->DownlevelName
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbUnlockLogonSessions(LogonSession);
            goto Cleanup;
        }
    }

    if (!RtlEqualDomainName(
            &TempAuthority,
            &PrimaryCredentials->DomainName
            ))
    {
        KerbFreeString(&TempAuthority);
        Status = KerbDuplicateString(
                    &TempAuthority,
                    &PrimaryCredentials->DomainName
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbUnlockLogonSessions(LogonSession);
            goto Cleanup;
        }
    }

    KerbUnlockLogonSessions(LogonSession);

    //
    // Finally create the logon session in the LSA
    //

    Status = LsaFunctions->CreateLogonSession( &LogonId );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to create logon session: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Add additional names to the logon session name map.  Ignore failure
    // as that just means GetUserNameEx calls for these name formats later
    // on will be satisfied by hitting the wire.
    //

    if (ValidationInfo || SCValidationInfo)
    {
        PNETLOGON_VALIDATION_SAM_INFO4 Tmp = (ValidationInfo ? ValidationInfo : SCValidationInfo);

        if (Tmp->FullName.Length)
        {
            I_LsaIAddNameToLogonSession(&LogonId, NameDisplay, &Tmp->FullName);
        }

        //
        // Smart cards use a "special" UPN for the logon cache, so don't
        // use it here, as the cached logon will provide us w/ bogus data...
        //
        /*if (ValidationInfo && ValidationInfo->Upn.Length)
        {
            I_LsaIAddNameToLogonSession(&LogonId, NameUserPrincipal, &ValidationInfo->Upn);
        }*/

        if (Tmp->DnsLogonDomainName.Length)
        {
            I_LsaIAddNameToLogonSession(&LogonId, NameDnsDomain, &Tmp->DnsLogonDomainName);
        }
    }

    I_LsaISetLogonGuidInLogonSession(&LogonId, &LogonGuid);


    //
    // If this was an unlock operation, copy the authentication ticket
    // cache into the original logon session.
    //

    if (DoingUnlock)
    {
        KerbUpdateOldLogonSession(
            LogonSession,
            &OldLogonId,
            WorkstationTicket
            );
    }
    *NewLogonId = LogonId;

Cleanup:




    //
    // This is a "fake" Info4 struct... Free UPN and dnsdomain
    // name manually -- normally a giant struct alloc'd by RPC
    //
    if (ValidationInfo)
    {
        KerbFreeString(&ValidationInfo->DnsLogonDomainName);
        KerbFreeString(&ValidationInfo->Upn);
        KerbFreeString(&ValidationInfo->FullName);
        KerbFree(ValidationInfo);
    }

    if (SCValidationInfo)
    {
        LocalFree(ValidationInfo); // this was alloc'd by cache lookup.
    }


    KerbFreeString( &CredmanUserName );
    KerbFreeString( &CredmanDomainName );
    KerbFreeString( &CredmanPassword );

    if (CertContext != NULL)
    {
        CertFreeCertificateContext(CertContext);
    }

    //
    // Restore the saved password
    //
    if ( ServiceSecretLogon ) {

        RtlCopyMemory( &LogonInfo->Password,
                       &SavedPassword,
                       sizeof( UNICODE_STRING ) );

        //
        // Free the secret value we read...
        //
        LsaIFree_LSAPR_CR_CIPHER_VALUE( SecretCurrent );
    }


    KerbFreeString( &CorrectRealm );
    KerbFreeKey(&CredentialKey);
    if (*AccountName != NULL)
    {
        **AccountName = TempName;
        TempName.Buffer = NULL;
    }

    if (*AuthenticatingAuthority != NULL)
    {
        **AuthenticatingAuthority = TempAuthority;
        TempAuthority.Buffer = NULL;
    }

    if (!NT_SUCCESS(Status))
    {
        //
        // Unlink the new logon session
        //

        if (LogonSession != NULL)
        {
            KerbReferenceLogonSessionByPointer(LogonSession, TRUE);
            KerbDereferenceLogonSession(LogonSession);
        }
        if (*ProfileBuffer != NULL)
        {
            LsaFunctions->FreeClientBuffer(NULL, *ProfileBuffer);
            *ProfileBuffer = NULL;
        }
        if (*CachedCredentials != NULL)
        {
            KerbFree(*CachedCredentials);
            *CachedCredentials = NULL;
        }

        //
        // Map status codes to prevent specific information from being
        // released about this user.
        //
        switch (Status) {
        case STATUS_WRONG_PASSWORD:
        case STATUS_NO_SUCH_USER:
        case STATUS_PKINIT_FAILURE:
        case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
        case STATUS_SMARTCARD_WRONG_PIN:
        case STATUS_SMARTCARD_CARD_BLOCKED:
        case STATUS_SMARTCARD_NO_CARD:
        case STATUS_SMARTCARD_NO_KEY_CONTAINER:
        case STATUS_SMARTCARD_NO_CERTIFICATE:
        case STATUS_SMARTCARD_NO_KEYSET:
        case STATUS_SMARTCARD_IO_ERROR:
        case STATUS_SMARTCARD_CERT_REVOKED:
        case STATUS_SMARTCARD_CERT_EXPIRED:
        case STATUS_REVOCATION_OFFLINE_C:
        case STATUS_PKINIT_CLIENT_FAILURE:


            //
            // sleep 3 seconds to "discourage" dictionary attacks.
            // Don't worry about interactive logon dictionary attacks.
            // They will be slow anyway.
            //
            // per bug 171041, SField, RichardW, CliffV all decided this
            // delay has almost zero value for Win2000.  Offline attacks at
            // sniffed wire traffic are more efficient and viable.  Further,
            // opimizations in logon code path make failed interactive logons.
            // very fast.
            //
            //
//            if (LogonType != Interactive) {
//                Sleep( 3000 );
//            }

            //
            // This is for auditing.  Make sure to clear it out before
            // passing it out of LSA to the caller.
            //

            *ApiSubStatus = Status;
            Status = STATUS_LOGON_FAILURE;
            break;

        case STATUS_INVALID_LOGON_HOURS:
        case STATUS_INVALID_WORKSTATION:
        case STATUS_PASSWORD_EXPIRED:
        case STATUS_ACCOUNT_DISABLED:
        case STATUS_SMARTCARD_LOGON_REQUIRED:
            *ApiSubStatus = Status;
            Status = STATUS_ACCOUNT_RESTRICTION;
            break;

        //
        // This shouldn't happen, but guard against it anyway.
        //
        case STATUS_ACCOUNT_RESTRICTION:
            *ApiSubStatus = STATUS_ACCOUNT_RESTRICTION;
            break;

        case STATUS_ACCOUNT_EXPIRED: // fix 122291
            *ApiSubStatus = STATUS_ACCOUNT_EXPIRED;
            break;

        default:
            break;

        }


        if (*TokenInformation != NULL)
        {
            KerbFree( *TokenInformation );
            *TokenInformation = NULL;
        }
        KerbFreeString(
            &PrimaryCredentials->DownlevelName
            );
        KerbFreeString(
            &PrimaryCredentials->DomainName
            );
        KerbFreeString(
            &PrimaryCredentials->LogonServer
            );
        KerbFreeString(
            &PrimaryCredentials->Password
            );
        if (PrimaryCredentials->UserSid != NULL)
        {
            KerbFree(PrimaryCredentials->UserSid);
            PrimaryCredentials->UserSid = NULL;
        }
        RtlZeroMemory(
            PrimaryCredentials,
            sizeof(SECPKG_PRIMARY_CRED)
            );
    }


    if (WorkstationTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry( WorkstationTicket );
    }

    if (AsTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry( AsTicket );
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    KerbFreeKdcName(&ClientName);

    KerbFreeString(&ClientRealm);

    KerbFreeString(
        &DomainName
        );

    KerbFreeString(
        &MappedClientName
        );

    KerbFreeString(
        &TempName
        );
    KerbFreeString(
        &TempAuthority
        );

    KerbFreeKdcName(
        &MachineServiceName
        );

    KerbFreeString(
        &S4UClientRealm
        );


    // Allocate the machine name here. Lsa will free it after auditing is
    // done

    *MachineName = (PUNICODE_STRING) KerbAllocate( sizeof( UNICODE_STRING ) );

    if ( *MachineName != NULL )
    {
        NTSTATUS TempStatus;

        KerbGlobalReadLock();
        TempStatus = KerbDuplicateString (*MachineName, &KerbGlobalMachineName);
        KerbGlobalReleaseLock();

        if(!NT_SUCCESS(TempStatus))
        {
            D_DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalMachineName\n"));
            ZeroMemory( *MachineName, sizeof(UNICODE_STRING) );
        }
    }

    if( KerbEventTraceFlag ) // Event Trace: KerbLogonUserEnd {Status, (LogonType), (Username), (Domain)}
    {
        INSERT_ULONG_INTO_MOF( *ApiSubStatus, LogonTraceInfo.MofData, 0 );
        LogonTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER) + sizeof(MOF_FIELD);

        if( LogonInfo != NULL )
        {
            UNICODE_STRING KerbLogonTypeString;

            PCWSTR KerbLogonTypeTable[] = // see enum _KERB_LOGON_SUBMIT_TYPE
            {   L"",L"",
                L"KerbInteractiveLogon",  // = 2
                L"",L"",L"",
                L"KerbSmartCardLogon",    // = 6
                L"KerbWorkstationUnlockLogon",
                L"KerbSmartCardUnlockLogon",
                L"KerbProxyLogon",
                L"KerbTicketLogon",
                L"KerbTicketUnlockLogon"
            };

            RtlInitUnicodeString( &KerbLogonTypeString, KerbLogonTypeTable[LogonInfo->MessageType] );

            INSERT_UNICODE_STRING_INTO_MOF( KerbLogonTypeString,        LogonTraceInfo.MofData, 1 );
            INSERT_UNICODE_STRING_INTO_MOF( LogonInfo->UserName,        LogonTraceInfo.MofData, 3 );
            INSERT_UNICODE_STRING_INTO_MOF( LogonInfo->LogonDomainName, LogonTraceInfo.MofData, 5 );
            LogonTraceInfo.EventTrace.Size += 6*sizeof(MOF_FIELD);
        }

        // Set trace parameters
        LogonTraceInfo.EventTrace.Guid       = KerbLogonGuid;
        LogonTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        LogonTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

        TraceEvent(
            KerbTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&LogonTraceInfo
            );
    }

#if _WIN64

    if (fAllocatedSubmitBuffer)
    {
        KerbFree(pTempSubmitBuffer);
    }

#endif  // _WIN64

    return(Status);
}

#endif // WIN32_CHICAGO // later


//+-------------------------------------------------------------------------
//
//  Function:   LsaApLogonTerminated
//
//  Synopsis:   This routine is called whenever a logon session terminates
//              (the last token for it is closed). It dereferences the
//              logon session (if it exists), which may cause any
//              associated credentials or contexts to be run down.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsaApLogonTerminated(
    IN PLUID LogonId
    )
{
    PKERB_LOGON_SESSION LogonSession;

    D_DebugLog((DEB_TRACE_API, "LsaApLogonTerminated called: 0x%x:0x%x\n",
        LogonId->HighPart, LogonId->LowPart ));
    LogonSession = KerbReferenceLogonSession(
                        LogonId,
                        TRUE            // unlink logon session
                        );
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    return;
}

#ifdef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbSspiLogonUser
//
//  Synopsis:   Handles service, batch, and interactive logons
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
KerbSspiLogonUser(
    IN LPTSTR PackageName,
    IN LPTSTR UserName,
    IN LPTSTR DomainName,
    IN LPTSTR Password
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LogonSession = NULL;
    UNICODE_STRING TempName = NULL_UNICODE_STRING;
    UNICODE_STRING TempAuthority = NULL_UNICODE_STRING;
    UNICODE_STRING TempPassword = NULL_UNICODE_STRING;
    UNICODE_STRING KdcServiceName = NULL_UNICODE_STRING;
    PKERB_INTERNAL_NAME KdcServiceKdcName = NULL;
    LUID LogonId;
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN UsedAlternateName = NULL;

    //
    // First initialize all the output parameters to NULL.
    //

    Status = STATUS_SUCCESS;
    KdcServiceName.Buffer = NULL;

    //
    // Initialize local pointers to NULL
    //

    LogonId.LowPart = 0;
    LogonId.HighPart = 0;

    //
    // Copy out the user name and Authenticating Authority so we can audit them.
    //

    // NOTE - Do we need to enforce username & password restrictions here
    // or will the redir do the job when we setuid to it?

    if ( UserName != NULL ) {

        Status = RtlCreateUnicodeStringFromAsciiz(
                        &TempName,
                        UserName);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if ( DomainName != NULL ) {

        Status = RtlCreateUnicodeStringFromAsciiz(
                        &TempAuthority,
                        DomainName);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if ( Password != NULL ) {

        Status = RtlCreateUnicodeStringFromAsciiz(
                        &TempPassword,
                        Password);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Allocate a locally unique ID for this logon session. We will
    // create it in the LSA just before returning.
    //

    Status = NtAllocateLocallyUniqueId( &LogonId );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Check to see if the client is from an MIT realm
    //

    (VOID) KerbLookupMitRealm(
                    &TempAuthority,
                    &MitRealm,
                    &UsedAlternateName
                    );

    if ((MitRealm != NULL) && UsedAlternateName)
    {
        KerbFreeString(&TempAuthority);
        Status = KerbDuplicateString(
                        &TempAuthority,
                        &MitRealm->RealmName
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    // For win95, if there is a logon session in our list, remove it.
    // This is generated from the logon session dumped in the registry.
    // But, we are about to do a new logon. Get rid of the old logon.
    // If the new one does not succeed, too bad. But, that's by design.

    LsaApLogonTerminated(&LogonId);

    //
    // Build a logon session to hold all this information
    //

    Status = KerbCreateLogonSession(
                    &LogonId,
                    &TempName,
                    &TempAuthority,
                    &TempPassword,
                    NULL,                       // no old password
                    PRIMARY_CRED_CLEAR_PASSWORD,
                    Network,
                    &LogonSession
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE,"LogonUser: Attempting to logon user %wZ\\%wZ\n",
        &TempAuthority,
        &TempName
        ));

    //
    // Now the real work of logon begins - getting a TGT and then a ticket
    // to this machine.
    //

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                    &TempAuthority,
                    &KerbGlobalKdcServiceName,
                    KRB_NT_MS_PRINCIPAL,
                    &KdcServiceKdcName
                    )))

    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = KerbGetTicketGrantingTicket(
                LogonSession,
                NULL,
                NULL,
                NULL,           // no credential
                NULL,           // don't return ticket cache entry
                NULL            // don't return credential key
                );



    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "LogonUser: Failed to get authentication ticket for %wZ\\%wZ to %wZ: 0x%x\n",
            &TempAuthority,
            &TempName,
            &KdcServiceName,
            Status ));
        goto Cleanup;

    }

    KerbWriteLockLogonSessions(LogonSession);
    LogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;
    KerbUnlockLogonSessions(LogonSession);

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        //
        // Unlink the new logon session
        //

        if (LogonSession != NULL)
        {
            KerbReferenceLogonSessionByPointer(LogonSession, TRUE);
            KerbDereferenceLogonSession(LogonSession);
        }

        //
        // Map status codes to prevent specific information from being
        // released about this user.
        //
        switch (Status) {
        case STATUS_WRONG_PASSWORD:
        case STATUS_NO_SUCH_USER:

            //
            // This is for auditing.  Make sure to clear it out before
            // passing it out of LSA to the caller.
            //

            Status = STATUS_LOGON_FAILURE;
            break;

        case STATUS_INVALID_LOGON_HOURS:
        case STATUS_INVALID_WORKSTATION:
        case STATUS_PASSWORD_EXPIRED:
        case STATUS_ACCOUNT_DISABLED:
        case STATUS_ACCOUNT_EXPIRED:
            Status = STATUS_ACCOUNT_RESTRICTION;
            break;

        //
        // This shouldn't happen, but guard against it anyway.
        //
        case STATUS_ACCOUNT_RESTRICTION:
            Status = STATUS_ACCOUNT_RESTRICTION;
            break;

        default:
            break;

        }

    }


    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    KerbFreeString(
        &TempName
        );
    KerbFreeString(
        &TempAuthority
        );
    KerbFreeString(
        &KdcServiceName
        );

    KerbFreeKdcName( &KdcServiceKdcName );
    D_DebugLog((DEB_TRACE, "SspiLogonUser: returns 0x%x\n", Status));
    return(Status);
}


#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\mitutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        mitutil.h
//
// Contents:    Prototypes & structures for MIT KDC support
//
//
// History:     4-March-1997    Created         MikeSw
//
//------------------------------------------------------------------------


#ifndef __MITUTIL_H__
#define __MITUTIL_H__

typedef struct _KERB_MIT_SERVER_LIST {
    LONG ServerCount;
    LONG LastServerUsed;
    PUNICODE_STRING ServerNames;
} KERB_MIT_SERVER_LIST, *PKERB_MIT_SERVER_LIST;

typedef struct _KERB_MIT_REALM {
    KERBEROS_LIST_ENTRY Next;
    ULONG Flags;
    ULONG ApReqChecksumType;
    ULONG PreAuthType;
    ULONG RealmNameCount;
    UNICODE_STRING RealmName;
    PUNICODE_STRING AlternateRealmNames;
    KERB_MIT_SERVER_LIST KdcNames;
    KERB_MIT_SERVER_LIST KpasswdNames;
    TimeStamp LastLookup;
} KERB_MIT_REALM, *PKERB_MIT_REALM;

#define KERB_MIT_REALM_SEND_ADDRESS 0x0001
#define KERB_MIT_REALM_TCP_SUPPORTED 0x0002
#define KERB_MIT_REALM_TRUSTED_FOR_DELEGATION 0x0004
#define KERB_MIT_REALM_DOES_CANONICALIZE 0x0008

// DNS lookup flags
#define KERB_MIT_REALM_KDC_LOOKUP             0x00010000
#define KERB_MIT_REALM_KPWD_LOOKUP            0x00020000

#define DNS_LOOKUP_TIMEOUT               120
#define DNS_TCP         "_tcp."
#define DNS_UDP         "_udp."
#define DNS_KERBEROS    "_kerberos."
#define DNS_KPASSWD     "_kpasswd."
#define DNS_MSKDC       "_kerberos._tcp.dc._msdcs."
#define DNS_MAX_PREFIX  128 // udp + kerberos char count
#define MAX_SRV_RECORDS 50  // maximum server records


#define KERB_DOMAINS_KEY TEXT("System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Domains")
#define KERB_DOMAIN_KDC_NAMES_VALUE TEXT("KdcNames")
#define KERB_DOMAIN_KPASSWD_NAMES_VALUE TEXT("KpasswdNames")
#define KERB_DOMAIN_ALT_NAMES_VALUE TEXT("AlternateDomainNames")
#define KERB_DOMAIN_FLAGS_VALUE TEXT("RealmFlags")
#define KERB_DOMAIN_AP_REQ_CSUM_VALUE TEXT("ApReqChecksumType")
#define KERB_DOMAIN_PREAUTH_VALUE TEXT("PreAuthType")



BOOLEAN
KerbLookupMitRealm(
    IN PUNICODE_STRING RealmName,
    OUT PKERB_MIT_REALM * MitRealm,
    OUT PBOOLEAN UsedAlternateName
    );

NTSTATUS
KerbInitializeMitRealmList(
    VOID
    );

VOID
KerbUninitializeMitRealmList(
    VOID
    );

VOID
KerbFreeServerNames(
   PKERB_MIT_SERVER_LIST ServerList
   );


BOOLEAN
KerbLookupMitRealmWithSrvLookup(
   PUNICODE_STRING RealmName,
   PKERB_MIT_REALM * MitRealm,
   BOOLEAN   Kpasswd,
   BOOLEAN   UseTcp
   );


#endif // __MITUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\logonses.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        logonses.h
//
// Contents:    prototypes and structures for the logon session list
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __LOGONSES_H__
#define __LOGONSES_H__


//
// All global variables declared as EXTERN will be allocated in the file
// that defines LOGONSES_ALLOCATE
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef LOGONSES_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN KERBEROS_LIST KerbLogonSessionList;
EXTERN BOOLEAN KerberosLogonSessionsInitialized;

//
// Keep track a list of session keys for network service in ISC. These keys are
// used in ASC to detect whether a kerb logon session is from ISC called by the
// local network serivce (the client)
//

EXTERN LIST_ENTRY KerbNetworkServiceSKeyList;
EXTERN RTL_RESOURCE KerbNetworkServiceSKeyLock;

//
// the number of entries is only used in debugger spew of checked builds
//

#if DBG

EXTERN volatile LONG KerbcSKeyEntries;

#endif

//
// timer used to clean up the session key list above
//

EXTERN HANDLE KerbhSKeyTimerQueue;

//
// NOTICE: The logon session resource, credential resource, and context
// resource must all be acquired carefully to prevent deadlock. They
// can only be acquired in this order:
//
// 1. Logon Sessions
// 2. Credentials
// 3. Contexts
//

#if DBG
#ifdef WIN32_CHICAGO
#define KerbWriteLockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Write locking LogonSessions\n")); \
    DsysAssert(KerbGlobalContextsLocked != GetCurrentThreadId()); \
    EnterCriticalSection(&(_X_)->Lock); \
}
#define KerbReadLockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Read locking LogonSessions\n")); \
    DsysAssert(KerbGlobalContextsLocked != GetCurrentThreadId()); \
    EnterCriticalSection(&(_X_)->Lock); \
}
#define KerbUnlockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Unlocking LogonSessions\n")); \
    LeaveCriticalSection(&(_X_)->Lock); \
}
#else  // WIN32_CHICAGO
#define KerbWriteLockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Write locking LogonSession %p\n",(_X_))); \
    DsysAssert(KerbGlobalContextsLocked != GetCurrentThreadId()); \
    RtlEnterCriticalSection(&(_X_)->Lock); \
}
#define KerbReadLockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Read locking LogonSession %p\n",(_X_))); \
    DsysAssert(KerbGlobalContextsLocked != GetCurrentThreadId()); \
    RtlEnterCriticalSection(&(_X_)->Lock); \
}
#define KerbUnlockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Unlocking LogonSessions\n")); \
    RtlLeaveCriticalSection(&(_X_)->Lock); \
}
#endif // WIN32_CHICAGO
#else
#ifdef WIN32_CHICAGO
#define KerbWriteLockLogonSessions(_X_) \
    EnterCriticalSection(&(_X_)->Lock)
#define KerbReadLockLogonSessions(_X_) \
    EnterCriticalSection(&(_X_)->Lock)
#define KerbUnlockLogonSessions(_X_) \
    LeaveCriticalSection(&(_X_)->Lock)
#else  // WIN32_CHICAGO
#define KerbWriteLockLogonSessions(_X_) \
    RtlEnterCriticalSection(&(_X_)->Lock);
#define KerbReadLockLogonSessions(_X_) \
    RtlEnterCriticalSection(&(_X_)->Lock);
#define KerbUnlockLogonSessions(_X_) \
    RtlLeaveCriticalSection(&(_X_)->Lock);
#endif // WIN32_CHICAGO
#endif

//
// Helper routines for Logon Sessions
//

NTSTATUS
KerbInitLogonSessionList(
    VOID
    );

NTSTATUS
KerbInitNetworkServiceLoopbackDetection(
    VOID
    );

VOID
KerbFreeNetworkServiceSKeyListAndLock(
    VOID
    );

VOID
KerbFreeLogonSessionList(
    VOID
    );

NTSTATUS
KerbAllocateLogonSession(
    PKERB_LOGON_SESSION * NewLogonSession
    );

NTSTATUS
KerbInsertLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    );

PKERB_LOGON_SESSION
KerbReferenceLogonSession(
    IN PLUID LogonId,
    IN BOOLEAN RemoveFromList
    );

VOID
KerbReferenceLogonSessionByPointer(
    IN PKERB_LOGON_SESSION LogonSession,
    IN BOOLEAN RemoveFromList
    );


VOID
KerbDereferenceLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    );

NTSTATUS
KerbCreateLogonSession(
    IN PLUID LogonId,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING Password,
    IN OPTIONAL PUNICODE_STRING OldPassword,
    IN ULONG PasswordFlags,
    IN SECURITY_LOGON_TYPE LogonType,
    OUT PKERB_LOGON_SESSION * NewLogonSession
    );

VOID
KerbFreeLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    );

NTSTATUS
KerbCreateLogonSessionFromKerbCred(
    IN OPTIONAL PLUID LogonId,
    IN PKERB_ENCRYPTED_TICKET Ticket,
    IN PKERB_CRED KerbCred,
    IN PKERB_ENCRYPTED_CRED EncryptedCred,
    IN OUT PKERB_LOGON_SESSION *OldLogonSession
    );

NTSTATUS
KerbBuildPasswordList(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PKERB_ETYPE_INFO SuppliedSalt,
    IN PKERB_STORED_CREDENTIAL OldPasswords,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN KERB_ACCOUNT_TYPE AccountType,
    IN ULONG PasswordFlags,
    OUT PKERB_STORED_CREDENTIAL * PasswordList
    );

VOID
KerbFreeStoredCred(
    IN PKERB_STORED_CREDENTIAL StoredCred
    );


NTSTATUS
KerbChangeCredentialsPassword(
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCredentials,
    IN OPTIONAL PUNICODE_STRING NewPassword,
    IN OPTIONAL PKERB_ETYPE_INFO EtypeInfo,
    IN KERB_ACCOUNT_TYPE AccountType,
    IN ULONG PasswordFlags
    );

//
// Flags for logon sessions
//

#define KERB_LOGON_DEFERRED             0x1
#define KERB_LOGON_NO_PASSWORD          0x2
#define KERB_LOGON_LOCAL_ONLY           0x4
#define KERB_LOGON_DELEGATED            0x8
#define KERB_LOGON_SMARTCARD            0x10
#define KERB_LOGON_MIT_REALM            0x20
#define KERB_LOGON_S4U_SESSION          0x4000 // make sure we don't collide w/ other flags
#define KERB_LOGON_CREDMAN_INITIALIZED  0x80000000

#endif // __LOGONSES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\kerberos\client2\mitutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        mitutil.cxx
//
// Contents:    Routines for talking to MIT KDCs
//
//
// History:     4-March-1997    Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

static HKEY     KerbMITRealmRootKey = NULL;
static HANDLE   hKerbMITRealmWaitEvent = NULL;
static HANDLE   hKerbMITRealmWaitObject = NULL;

KERBEROS_LIST KerbMitRealmList;

#define MAX_DOMAIN_NAME_LEN     128   // number of characters



//+-------------------------------------------------------------------------
//
//  Function:   KerbReadMitRealmList
//
//  Synopsis:   Loads the list of MIT realms from the registry
//
//  Effects:    Initialize and links domains to KerbMitRealmList
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbReadMitRealmList(
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG WinError;
    HKEY DomainKey = NULL;
    LPWSTR KdcNames = NULL;
    LPWSTR KpasswdNames = NULL;
    LPWSTR AlternateRealmNames = NULL;
    TCHAR DomainName[MAX_DOMAIN_NAME_LEN];    // max domain name length
    PKERB_MIT_REALM MitRealm = NULL;
    ULONG Index,Index2;
    ULONG Type;
    ULONG NameSize;
    ULONG KdcNameSize = 0;
    ULONG AltRealmSize = 0;
    ULONG KpasswdNameSize = 0;
    LPWSTR Where;
    ULONG NameCount, tmp;
    UNICODE_STRING TempString;
    ULONG Flags = 0;
    ULONG FlagSize = sizeof(ULONG);
    ULONG ApReqChecksumType = 0;
    ULONG PreAuthType = 0;
    BOOLEAN fListLocked = FALSE;

    //
    // If it is there, we now want to enumerate all the child keys.
    //
    KerbLockList(&KerbMitRealmList);
    fListLocked = TRUE;

    for (Index = 0; TRUE ; Index++ )
    {
        //
        // Enumerate through all the keys
        //
        NameSize = MAX_DOMAIN_NAME_LEN;
        WinError = RegEnumKeyEx(
                    KerbMITRealmRootKey,
                    Index,
                    DomainName,
                    &NameSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

        if (WinError != ERROR_SUCCESS)
        {
            //
            // nothing more to do.
            //

            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        //
        // Open the domain key to read the values under it
        //
        if( DomainKey != NULL )
        {
            RegCloseKey( DomainKey );
            DomainKey = NULL;
        }

        WinError = RegOpenKey(
                    KerbMITRealmRootKey,
                    DomainName,
                    &DomainKey
                    );
        if (WinError != ERROR_SUCCESS)
        {
            D_DebugLog((DEB_ERROR,"Failed to open key %ws \\ %ws: %d. %ws, line %d\n",
                KERB_DOMAINS_KEY, DomainName, WinError, THIS_FILE, __LINE__ ));

            //
            // keep going.
            //

            continue;
        }

        //
        // Now read the values from the domain
        //

        KdcNameSize = 0;
        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_KDC_NAMES_VALUE,
                    NULL,
                    &Type,
                    NULL,
                    &KdcNameSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            KdcNames = (LPWSTR) KerbAllocate(KdcNameSize);
            if (KdcNames == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            WinError = RegQueryValueEx(
                        DomainKey,
                        KERB_DOMAIN_KDC_NAMES_VALUE,
                        NULL,
                        &Type,
                        (PUCHAR) KdcNames,
                        &KdcNameSize
                        );
            if (WinError != ERROR_SUCCESS)
            {
                D_DebugLog((DEB_ERROR,"Failed to query value %ws\\%ws: %d. %ws, line %d\n",
                    DomainName, KERB_DOMAIN_KDC_NAMES_VALUE, WinError, THIS_FILE, __LINE__ ));
                Status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }
        }

        //
        // Now read the Kpasswd values from the domain
        //

        KpasswdNameSize = 0;
        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_KPASSWD_NAMES_VALUE,
                    NULL,
                    &Type,
                    NULL,
                    &KpasswdNameSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            KpasswdNames = (LPWSTR) KerbAllocate(KpasswdNameSize);
            if (KpasswdNames == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            WinError = RegQueryValueEx(
                        DomainKey,
                        KERB_DOMAIN_KPASSWD_NAMES_VALUE,
                        NULL,
                        &Type,
                        (PUCHAR) KpasswdNames,
                        &KpasswdNameSize
                        );
            if (WinError != ERROR_SUCCESS)
            {
                D_DebugLog((DEB_ERROR,"Failed to query value %ws\\%ws: %d. %ws, line %d\n",
                    DomainName, KERB_DOMAIN_KPASSWD_NAMES_VALUE, WinError, THIS_FILE, __LINE__ ));
                Status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }
        }

        //
        // Get any alternate domain names
        //

        AltRealmSize = 0;
        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_ALT_NAMES_VALUE,
                    NULL,
                    &Type,
                    NULL,
                    &AltRealmSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            AlternateRealmNames = (LPWSTR) KerbAllocate(AltRealmSize);
            if (AlternateRealmNames == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            WinError = RegQueryValueEx(
                        DomainKey,
                        KERB_DOMAIN_ALT_NAMES_VALUE,
                        NULL,
                        &Type,
                        (PUCHAR) AlternateRealmNames,
                        &AltRealmSize
                        );

            if (WinError != ERROR_SUCCESS)
            {
                D_DebugLog((DEB_ERROR,"Failed to query value %ws\\%ws: %d. %ws, line %d\n",
                    DomainName, KERB_DOMAIN_KDC_NAMES_VALUE, WinError, THIS_FILE, __LINE__ ));
                Status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }

        }

        //
        // Read the flags
        //

        FlagSize = sizeof(ULONG);
        Flags = 0;

        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_FLAGS_VALUE,
                    NULL,
                    &Type,
                    (PUCHAR) &Flags,
                    &FlagSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            if (Type != REG_DWORD)
            {
                Flags = 0;
            }
        }

        //
        // Read the ApReq checksum type
        //

        FlagSize = sizeof(ULONG);
        ApReqChecksumType = KERB_DEFAULT_AP_REQ_CSUM;

        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_AP_REQ_CSUM_VALUE,
                    NULL,
                    &Type,
                    (PUCHAR) &ApReqChecksumType,
                    &FlagSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            if (Type != REG_DWORD)
            {
                ApReqChecksumType = KERB_DEFAULT_AP_REQ_CSUM;
            }
        }

        //
        // Read the ApReq checksum type
        //

        FlagSize = sizeof(ULONG);
        PreAuthType = KERB_DEFAULT_PREAUTH_TYPE;;

        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_PREAUTH_VALUE,
                    NULL,
                    &Type,
                    (PUCHAR) &PreAuthType,
                    &FlagSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            if (Type != REG_DWORD)
            {
                PreAuthType = KERB_DEFAULT_PREAUTH_TYPE;
            }
        }


        //
        // Now build the domain structure
        //

        MitRealm = (PKERB_MIT_REALM) KerbAllocate(sizeof(KERB_MIT_REALM));
        if (MitRealm == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        MitRealm->Flags = Flags;
        MitRealm->ApReqChecksumType = ApReqChecksumType;
        MitRealm->PreAuthType = PreAuthType;
#ifdef WIN32_CHICAGO
        RtlCreateUnicodeStringFromAsciiz(
            &TempString,
            DomainName
            );
#else // WIN32_CHICAGO
        RtlInitUnicodeString(
            &TempString,
            DomainName
            );
#endif // WIN32_CHICAGO

        Status = KerbDuplicateString(
                    &MitRealm->RealmName,
                    &TempString
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


        //
        // Fill in the KDC names etc.
        //

        NameCount = 0;
        if ((AlternateRealmNames != NULL ) && (AltRealmSize != 0))
        {
            Where = AlternateRealmNames;
            NameCount ++;
            while (Where + wcslen(Where) + 1 < (AlternateRealmNames + AltRealmSize /sizeof(WCHAR)))
            {  
               NameCount++;
               Where += wcslen(Where)+1;
            }
            MitRealm->AlternateRealmNames = (PUNICODE_STRING) KerbAllocate(NameCount * sizeof(UNICODE_STRING));
            if (MitRealm->AlternateRealmNames == NULL)
            {
               Status = STATUS_INSUFFICIENT_RESOURCES;
               goto Cleanup;
            }

            MitRealm->RealmNameCount = NameCount;
            Where = AlternateRealmNames;
            for (Index2 = 0;Index2 < NameCount; Index2++)
            {
                RtlInitUnicodeString(
                    &MitRealm->AlternateRealmNames[Index2],
                    Where
                    );
                Where += MitRealm->AlternateRealmNames[Index2].Length / sizeof(WCHAR) + 1;
            }

            AlternateRealmNames = NULL;
        }

        NameCount = 0;
        if ((KdcNames != NULL ) && (KdcNameSize != 0))
        {
            Where = KdcNames;
            while (Where + wcslen(Where) + 1 < (KdcNames + KdcNameSize /sizeof(WCHAR)))
            {
               // There's a bug in ksetup which adds a couple of "" strings to this, so...
               tmp = wcslen(Where) + 1;
            
               if (tmp > 1)
               {
                  NameCount++;
               }
               Where += tmp;
            }
            MitRealm->KdcNames.ServerNames = (PUNICODE_STRING) KerbAllocate(NameCount * sizeof(UNICODE_STRING));
            if (MitRealm->KdcNames.ServerNames == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            
            MitRealm->KdcNames.ServerCount = NameCount;
            
            Where = KdcNames;
            for (Index2 = 0;Index2 < NameCount; Index2++)
            {
                RtlInitUnicodeString(
                    &MitRealm->KdcNames.ServerNames[Index2],
                    Where
                    );

                // ugh.  Didn't want to have to allocate, but keep it simple.
                MitRealm->KdcNames.ServerNames[Index2].Buffer = (LPWSTR)KerbAllocate(sizeof(WCHAR)*(wcslen(Where)+2));
                if (NULL == MitRealm->KdcNames.ServerNames[Index2].Buffer)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                wcscpy(MitRealm->KdcNames.ServerNames[Index2].Buffer, Where);
                Where += MitRealm->KdcNames.ServerNames[Index2].Length / sizeof(WCHAR) + 1;
            }
    
            KerbFree(KdcNames);
            KdcNames = NULL;
        }


        if (NameCount == 0)
        {
            MitRealm->Flags |= KERB_MIT_REALM_KDC_LOOKUP;
        }


        NameCount = 0;
        if ((KpasswdNames != NULL ) && (KpasswdNameSize != 0))
        {
            Where = KpasswdNames;
            NameCount ++;
            while (Where + wcslen(Where) + 1 - (KpasswdNames + KpasswdNameSize /sizeof(WCHAR)) > 0)
            {
                NameCount++;
                Where += wcslen(Where)+1;
            }
            MitRealm->KpasswdNames.ServerNames = (PUNICODE_STRING) KerbAllocate(NameCount * sizeof(UNICODE_STRING));
            if (MitRealm->KpasswdNames.ServerNames == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            
            MitRealm->KpasswdNames.ServerCount = NameCount;
            
            Where = KpasswdNames;
            for (Index2 = 0;Index2 < NameCount; Index2++)
            {
                RtlInitUnicodeString(
                    &MitRealm->KpasswdNames.ServerNames[Index2],
                    Where
                    );

                // ugh.  Didn't want to have to allocate, but keep it simple.
                MitRealm->KpasswdNames.ServerNames[Index2].Buffer = (LPWSTR) KerbAllocate(sizeof(WCHAR)*(wcslen(Where)+2));
                if (NULL == MitRealm->KpasswdNames.ServerNames[Index2].Buffer)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                wcscpy(MitRealm->KpasswdNames.ServerNames[Index2].Buffer, Where);
                Where += MitRealm->KpasswdNames.ServerNames[Index2].Length / sizeof(WCHAR) + 1;
            }

            KerbFree(KpasswdNames);
            KpasswdNames = NULL;
        }

 