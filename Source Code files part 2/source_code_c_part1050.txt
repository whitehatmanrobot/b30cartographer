       "0wB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 1
                SearchAttributes,   //  w         _USHORT( SearchAttributes );
                SMB_WCT_CHECK(1)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                &RenameName         //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
            );

    MRxSmbDumpStufferState (700,"SMB w/ Delete 4RENAME after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
SmbPseExchangeStart_Rename(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for rename and downlevel delete.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    ULONG SmbLength;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Rename\n", 0 ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);
    ASSERT(!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

    //first we have to close the fid....if it's a directory, we close the search handle as well

    MRxSmbSetInitialSMB( StufferState STUFFERTRACE(Dbg,'FC') );
    ASSERT (StufferState->CurrentCommand == SMB_COM_NO_ANDX_COMMAND);

    if( (TypeOfOpen==RDBSS_NTC_STORAGE_TYPE_DIRECTORY)
            &&  FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN)  ){
        // we have a search handle open.....close it
        NTSTATUS Status2 = MRxSmbBuildFindClose(StufferState);

        if (Status2 == STATUS_SUCCESS) {
            Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            SMBPSE_OETYPE_FINDCLOSE
                                            );
        }

        ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
        ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST);

        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            RxFreePool(smbFobx->Enumeration.ResumeInfo);
            smbFobx->Enumeration.ResumeInfo = NULL;
        }
    }

    if (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
        COVERED_CALL(MRxSmbBuildClose(StufferState));
    
        SetFlag(SrvOpen->Flags,SRVOPEN_FLAG_FILE_RENAMED);
        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_CLOSE
                                        );
    }

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    //
    // the fid is now closed and we are almost ready to do the rename. first, tho, we have
    // to check for ReplaceIfExists. our implementation here is the same as rdr1....we pop out
    // a smb_com_delete, which only works for a file. be like mike!! remember to ignore any errors....

    if (0) {
        DbgPrint("RxContext->Info.ReplaceIfExists %08lx %02lx\n",
                      &RxContext->Info.ReplaceIfExists,
                      RxContext->Info.ReplaceIfExists);
        if (0) {
            DbgBreakPoint();
        }
    }

    if (RxContext->Info.ReplaceIfExists) {
        NTSTATUS DeleteStatus;
        PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;
        UNICODE_STRING RenameName;
        BOOLEAN CaseInsensitive;

        CaseInsensitive= BooleanFlagOn(capFcb->pNetRoot->pSrvCall->Flags,SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES);
        RenameName.Buffer = &RenameInformation->FileName[0];
        RenameName.Length = (USHORT)RenameInformation->FileNameLength;

        // We cannot delete the file that is renamed as its own.
        if (RtlCompareUnicodeString(RemainingName,
                                    &RenameName,
                                    CaseInsensitive)) {
            DeleteStatus = MRxSmbBuildDeleteForRename(StufferState);
            if (DeleteStatus==STATUS_SUCCESS) {

                DeleteStatus = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                      SMBPSE_OETYPE_DELETE_FOR_RENAME);
            }
        } else {
            if ( !CaseInsensitive || (CaseInsensitive &&
                 !RtlCompareUnicodeString(RemainingName,&RenameName,FALSE)) ) {
                    Status = STATUS_SUCCESS;
                    goto FINALLY;
            }
        }
    }

    //
    // now do the rename..........

    Status = MRxSmbBuildRename(StufferState);
    SmbLength = (ULONG)(StufferState->CurrentPosition - StufferState->BufferBase);
    if ( (Status == STATUS_BUFFER_OVERFLOW)
                 || (SmbLength>pServer->MaximumBufferSize) ){
        RxDbgTrace(0, Dbg, ("MRxSmbRename - name too long\n", 0 ));
        Status = STATUS_OBJECT_NAME_INVALID;
    }

    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_RENAME
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Rename exit w %08lx\n", Status ));
    return Status;
}


extern UNICODE_STRING MRxSmbAll8dot3Files;

NTSTATUS
MRxSmbBuildCheckEmptyDirectory (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a FindFirst SMB.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;

    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
    ULONG ResumeKeyLength = 0;

    UNICODE_STRING FindFirstPattern;

    // SearchAttributes is hardcoded to the magic number 0x16
    ULONG SearchAttributes =
            (SMB_FILE_ATTRIBUTE_DIRECTORY
                | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbBuildCheckEmptyDirectory \n"));

    if (OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey == NULL) {
        PUNICODE_STRING DirectoryName = RemainingName;
        PUNICODE_STRING Template = &MRxSmbAll8dot3Files;
        ULONG DirectoryNameLength,TemplateLength,AllocationLength;
        PBYTE SmbFileName;

        //the stuffer cannot handle the intricate logic here so we
        //will have to preallocate for the name

        DirectoryNameLength = DirectoryName->Length;
        TemplateLength = Template->Length;
        AllocationLength = sizeof(WCHAR)  // backslash separator
                            +DirectoryNameLength
                            +TemplateLength;
        RxDbgTrace(0, Dbg, ("  --> d/t/dl/tl/al <%wZ><%wZ>%08lx/%08lx/%08lx!\n",
                      DirectoryName,Template,
                      DirectoryNameLength,TemplateLength,AllocationLength));

        FindFirstPattern.Buffer = (PWCHAR)RxAllocatePoolWithTag( PagedPool,AllocationLength,'0SxR');
        if (FindFirstPattern.Buffer==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the findfind pattern buffer!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DbgBreakPoint();
            goto FINALLY;
        }

        SmbFileName = (PBYTE)FindFirstPattern.Buffer;
        RtlCopyMemory(SmbFileName,DirectoryName->Buffer,DirectoryNameLength);
        SmbFileName += DirectoryNameLength;
        if (*((PWCHAR)(SmbFileName-sizeof(WCHAR))) != L'\\') {
            *((PWCHAR)SmbFileName) = L'\\'; SmbFileName+= sizeof(WCHAR);
        }
        RtlCopyMemory(SmbFileName,Template->Buffer,TemplateLength);
        SmbFileName += TemplateLength;
        if ((TemplateLength == sizeof(WCHAR)) && (Template->Buffer[0]==DOS_STAR)) {
            *((PWCHAR)SmbFileName) = L'.'; SmbFileName+= sizeof(WCHAR);
            *((PWCHAR)SmbFileName) = L'*'; SmbFileName+= sizeof(WCHAR);
        }
        FindFirstPattern.Length = (USHORT)(SmbFileName - (PBYTE)FindFirstPattern.Buffer);
        RxDbgTrace(0, Dbg, ("  --> find1stpattern <%wZ>!\n",&FindFirstPattern));
    } else {
        ResumeKeyLength = sizeof(SMB_RESUME_KEY);
        FindFirstPattern.Buffer = NULL;
        FindFirstPattern.Length = 0;
    }


    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_Never, SMB_COM_SEARCH,
                                SMB_REQUEST_SIZE(SEARCH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ core search before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwB4ywc!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               3,                   //  w         _USHORT( MaxCount );                // Number of dir. entries to return
               SearchAttributes,    //  w         _USHORT( SearchAttributes );
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &FindFirstPattern,   //  4        //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               ResumeKeyLength,     //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //  c
               ResumeKeyLength,OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey
             );


    MRxSmbDumpStufferState (700,"SMB w/ core search for checkempty after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");


FINALLY:
    if (FindFirstPattern.Buffer != NULL) {
        RxFreePool(FindFirstPattern.Buffer);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbBuildCheckEmptyDirectory exiting.......st=%08lx\n",Status));
    return(Status);
}

NTSTATUS
SmbPseExchangeStart_SetDeleteDisposition(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for SetDeleteDisposition and downlevel delete. This only thing that happens here
    is that we check for an empty directory. On core, this is harder than you think. what we do is to try to get three
    entries. if the directory is empty, we will get only two . and ..; since we do not know whether the server just terminated
    early or whether those are the only two, we go again. we do this until either we get a name that is not . or .. or until
    NO_MORE_FILES is returned. sigh..................

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    ULONG SmbLength;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_SetDeleteDisposition\n", 0 ));

    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);

    ASSERT(!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
    ASSERT (OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey == NULL);

    for (;;) {
        MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

        Status = MRxSmbBuildCheckEmptyDirectory(StufferState);
        SmbLength = (ULONG)(StufferState->CurrentPosition - StufferState->BufferBase);
        if ( (Status == STATUS_BUFFER_OVERFLOW)
                     || (SmbLength>pServer->MaximumBufferSize) ){
            RxDbgTrace(-1, Dbg, ("MRxSmbSetDeleteDisposition - name too long\n", 0 ));
            return(STATUS_OBJECT_NAME_INVALID);
        } else if ( Status != STATUS_SUCCESS ){
            goto FINALLY;
        }

        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY
                                        );
        //
        // if success is returned with a resume key then we have to go again

        if ( (Status == STATUS_SUCCESS) && (OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey != NULL) ) continue;
        break;
    }

    //
    // this is pretty strange. if it succeeds, then fail the empty check. similarly, if the search
    // fails with the right status...succeeed the check. otherwise fail

FINALLY:
    if (Status == STATUS_SUCCESS) {
        Status = STATUS_DIRECTORY_NOT_EMPTY;
    } else if (Status == STATUS_NO_MORE_FILES) {
        Status = STATUS_SUCCESS;
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_SetDeleteDisposition exit w %08lx\n", Status ));
    return Status;
}


MRxSmbSetDeleteDisposition(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a delete for downlevel.

   It is impossible to provide exact NTish semantics on a core server. So, all we do here is to ensure that
   a directory is empty. The actual delete happens when on the last close.


Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();


    RxDbgTrace(+1, Dbg, ("MRxSmbSetDeleteDisposition\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    if (NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY ) {
        RxDbgTrace(-1, Dbg, ("MRxSmbSetDeleteDisposition not a directory!\n"));
        return(STATUS_SUCCESS);
    }

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                                    capFobx->pSrvOpen->pVNetRoot,
                                                    SMBPSE_OE_FROM_FAKESETDELETEDISPOSITION,
                                                    SmbPseExchangeStart_SetDeleteDisposition,
                                                    &OrdinaryExchange
                                                    );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(Status);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != STATUS_PENDING);

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

    RxDbgTrace(-1, Dbg, ("MRxSmbSetDeleteDisposition  exit with status=%08lx\n", Status ));
    return(Status);

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbce.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    smbce.h

Abstract:

    This module defines all functions, along with implementations for inline functions
    related to accessing the SMB connection engine

--*/

#ifndef _SMBCE_H_
#define _SMBCE_H_

//
// The SMB protocol has a number of dialects. These reflect the extensions made
// to the core protocol over a period of time to cater to increasingly sophisticated
// file systems. The connection engine must be capable of dealing with different
// dialects implemented by server. The underlying Transport mechanism is used to
// uniquely identify the file server and the SMB protocol furnishes the remaining
// identification information to uniquely map an SMB onto a particular file opened by
// a particular client. The three important pieces of information are the SMB_TREE_ID,
// SMB_FILE_ID and SMB_USER_ID. These identify the particular connection made by a
// client machine, the particular file opened on that connection, and the user on
// behalf of whom the file has been opened. Note that there could be multiple
// connections from a client machine to a server machine. Therefore the unique id. is
// really connection based rather than machine based. The SMB connection engine
// data structures are built around these concepts.

//
// The known SMB dialects are as follows.
//

typedef enum _SMB_DIALECT_ {
    PCNET1_DIALECT,
    //XENIXCORE_DIALECT,
    //MSNET103_DIALECT,
    LANMAN10_DIALECT,
    WFW10_DIALECT,
    LANMAN12_DIALECT,
    LANMAN21_DIALECT,
    NTLANMAN_DIALECT
} SMB_DIALECT, *PSMB_DIALECT;

#define   NET_ROOT_FILESYSTEM_UNKOWN  ((UCHAR)0)
#define   NET_ROOT_FILESYSTEM_FAT     ((UCHAR)1)
#define   NET_ROOT_FILESYSTEM_NTFS    ((UCHAR)2)
typedef UCHAR NET_ROOT_FILESYSTEM, *PNET_ROOT_FILESYSTEM;

//
// The SMBCE_NET_ROOT encapsulates the information pertaining to a share on a server.
//

//we restrict to the first 7 characters (HPFS386)
#define SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL 7

#define MaximumNumberOfVNetRootContextsForScavenging 10

typedef struct _SMBCE_NET_ROOT_ {
    BOOLEAN       DfsAware;

    NET_ROOT_TYPE NetRootType;
    NET_ROOT_FILESYSTEM NetRootFileSystem;

    SMB_USER_ID   UserId;

    ULONG         MaximumReadBufferSize;
    ULONG         MaximumWriteBufferSize;

    LIST_ENTRY    ClusterSizeSerializationQueue;

    ULONG         FileSystemAttributes;

    LONG          MaximumComponentNameLength;


    UCHAR   ClusterShift;

    BOOLEAN  Disconnected;

    LIST_ENTRY DirNotifyList;       // head of a list of notify Irps.

    PNOTIFY_SYNC pNotifySync;       // used to synchronize the dir notify list.

    LIST_ENTRY  NotifyeeFobxList;     // list of fobx's given to the fsrtl structure
    FAST_MUTEX  NotifyeeFobxListMutex;

    union {
        struct {
            USHORT FileSystemNameLength;
            WCHAR FileSystemName[SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL];
        };
        struct {
            USHORT Pad2;
            UCHAR FileSystemNameALength;
            UCHAR FileSystemNameA[SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL];
            UCHAR Pad;  //this field is used for a null in a dbgprint; don't move it
        };
    };

    //ULONG         ClusterSize;
} SMBCE_NET_ROOT, *PSMBCE_NET_ROOT;

//
// There are two levels of security in the SMB protocol. User level security and Share level
// security. Corresponding to each user in the user level security mode there is a session.
//
// Typically the password, user name and domain name strings associated with the session entry
// revert to the default values, i.e., they are zero. In the event that they are not zero the
// SessionString represents a concatenated version of the password,user name and domain name in
// that order. This representation in a concatenated way yields us a savings of atleast 3
// USHORT's over other representations.
//

typedef enum _SECURITY_MODE_ {
    SECURITY_MODE_SHARE_LEVEL = 0,
    SECURITY_MODE_USER_LEVEL = 1
} SECURITY_MODE, *PSECURITY_MODE;

#define SMBCE_SHARE_LEVEL_SERVER_USERID 0xffffffff

typedef enum _SESSION_TYPE_ {
    UNINITIALIZED_SESSION,
    LANMAN_SESSION
} SESSION_TYPE, *PSESSION_TYPE;

#define SMBCE_SESSION_FLAGS_LANMAN_SESSION_KEY_USED (0x2)
#define SMBCE_SESSION_FLAGS_NULL_CREDENTIALS        (0x4)
#define SMBCE_SESSION_FLAGS_GUEST_SESSION           (0x10)
#define SMBCE_SESSION_FLAGS_LOGGED_OFF              (0x20)
#define SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION     (0x40)

typedef struct _SMBCE_SESSION_ {
    SESSION_TYPE    Type;
    SMB_USER_ID     UserId;

    // Flags associated with the session.
    ULONG           Flags;

    LUID            LogonId;
    PUNICODE_STRING pUserName;
    PUNICODE_STRING pPassword;
    PUNICODE_STRING pUserDomainName;

    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];

    // The credential and context handles.
    CtxtHandle      SecurityContextHandle;
    CredHandle      CredentialHandle;
    ULONG           SessionId;
    ULONG           SessionKeyLength;

    ULONG           NumberOfActiveVNetRoot;
} SMBCE_SESSION, *PSMBCE_SESSION;

extern VOID
UninitializeSecurityContextsForSession(PSMBCE_SESSION pSession);

//
// SMBCE_*_SERVER -- This data structure encapsulates all the information related to a server.
// Since there are multiple dialects of the SMB protocol, the capabilities as well as the
// actions that need to be taken at the client machine are very different.
//
// Owing to the number of dialects of the SMB protocol we have two design possibilities.
// Either we define an all encompassing data structure and have a code path that
// uses the dialect and the capabilities of the connection to determine the action
// required, or we use a subclassing mechanism associated with a dispatch vector.
// The advantage of the second mechanism is that it can be developed incrementally and
// it is very easily extensible. The disadvantage of this mechanism is that it can
// lead to a very large footprint, if sufficient care is not exercised during
// factorization and we could have lots and lots of procedure calls which has an
// adverse effect on the code generated.
//
// We will adopt the second approach ( Thereby implicitly defining the metrics by
// which the code should be evaluated !! ).
//
// The types of SMBCE_SERVER's can be classified in the following hierarchy
//
//    SMBCE_SERVER
//
//        SMBCE_USER_LEVEL_SERVER
//
//            SMBCE_NT_SERVER
//
//        SMBCE_SHARE_LEVEL_SERVER
//
// The dispatch vector which defines the set of methods supported by all the connections
// (virtual functions in C++ terminology) are as follows
//

#define RAW_READ_CAPABILITY         0x0001
#define RAW_WRITE_CAPABILITY        0x0002

#define ECHO_PROBE_IDLE              0x1
#define ECHO_PROBE_AWAITING_RESPONSE 0x2

#define CRYPT_TEXT_LEN MSV1_0_CHALLENGE_LENGTH

typedef struct _NTLANMAN_SERVER_ {
    ULONG    NtCapabilities;
} NTLANMAN_SERVER, *PNTLANMAN_SERVER;

typedef struct _SMBCE_SERVER_ {
    // the server version count
    ULONG           Version;

    // the dispatch vector
    struct _SMBCE_SERVER_DISPATCH_VECTOR_  *pDispatch;

    // the SMB dialect
    SMB_DIALECT     Dialect;

    // More Server Capabilities
    ULONG           DialectFlags;

    // the session key
    ULONG           SessionKey;

    // the server Ip address
    ULONG           IpAddress;

    // Security mode supported on the server
    SECURITY_MODE   SecurityMode;

    // Time zone bias for conversion.
    LARGE_INTEGER   TimeZoneBias;

    // Echo Expiry Time
    LARGE_INTEGER   EchoExpiryTime;

    LONG            SmbsReceivedSinceLastStrobe;

    LONG            EchoProbeState;
    LONG            NumberOfEchoProbesSent;

    // Maximum negotiated buffer size.
    ULONG           MaximumBufferSize;

    // maximum buffer size for read/write operations
    ULONG           MaximumDiskFileReadBufferSize;
    ULONG           MaximumNonDiskFileReadBufferSize;
    ULONG           MaximumDiskFileWriteBufferSize;
    ULONG           MaximumNonDiskFileWriteBufferSize;

    // This is used to detect the number of server opens. If it is larger than 0,
    // we shouldn't tear down the current transport in case the user provides the transport.
    LONG            NumberOfSrvOpens;

    LONG            NumberOfActiveSessions;

    LONG            NumberOfVNetRootContextsForScavenging;

    LONG            MidCounter;

    // Maximum number of multiplexed requests
    USHORT          MaximumRequests;

    // Maximum number of VC's
    USHORT          MaximumVCs;

    // Server Capabilities
    USHORT          Capabilities;

    // encrypt passwords
    BOOLEAN         EncryptPasswords;

    // distinguishes a loopback connections
    BOOLEAN         IsLoopBack;

    // There are certain servers that return DF_NT_SMBS in the negotiate
    // but do not support change notifies. This allows us to suppress
    // change notify requests to those servers.

    BOOLEAN         ChangeNotifyNotSupported;

    // avoid multiple event logs posted for security context failures
    BOOLEAN         EventLogPosted;

    USHORT          EncryptionKeyLength;
    UCHAR           EncryptionKey[CRYPT_TEXT_LEN];

    // Dialect specific information
    union {
        NTLANMAN_SERVER   NtServer;
    };

} SMBCE_SERVER, *PSMBCE_SERVER;

typedef
NTSTATUS
(*PBUILD_SESSION_SETUP_SMB)(
    IN OUT struct _SMB_EXCHANGE *pExchange,
    IN OUT PGENERIC_ANDX  pSmb,
    IN OUT PULONG          pBufferSize
    );

typedef
NTSTATUS
(*PBUILD_TREE_CONNECT_SMB)(
    IN OUT struct _SMB_EXCHANGE *pExchange,
    IN OUT PGENERIC_ANDX   pSmb,
    IN OUT PULONG          pBufferSize
    );

typedef struct _SMBCE_SERVER_DISPATCH_VECTOR_ {
    PBUILD_SESSION_SETUP_SMB  BuildSessionSetup;
    PBUILD_TREE_CONNECT_SMB   BuildTreeConnect;
} SMBCE_SERVER_DISPATCH_VECTOR, *PSMBCE_SERVER_DISPATCH_VECTOR;

#define SMBCE_SERVER_DIALECT_DISPATCH(pServer,Routine,Arguments)        \
      (*((pServer)->pDispatch->Routine))##Arguments

// The SMBCE engine process all requests in an asychronous fashion. Therefore for synchronous
// requests an additional mechanism is required for synchronization. The following data structure
// provides an easy way for implementing this synchronization.
//
// NOTE: For asynchronous resumption contexts the resumption routine can be invoked
// at DPC level.

#define SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS (0x1)

typedef struct SMBCE_RESUMPTION_CONTEXT {
    ULONG    Flags;
    NTSTATUS Status;              // the status
    PVOID    pContext;            // a void pointer for clients to add additional context information
    union {
        PRX_WORKERTHREAD_ROUTINE pRoutine; // asynchronous contexts
        KEVENT                   Event;    // the event for synchronization
    };
} SMBCE_RESUMPTION_CONTEXT, *PSMBCE_RESUMPTION_CONTEXT;

#define SmbCeIsResumptionContextAsynchronous(pResumptionContext)   \
         ((pResumptionContext)->Flags & SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS)

INLINE VOID
SmbCeInitializeResumptionContext(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext)
{
    KeInitializeEvent(&(pResumptionContext)->Event,NotificationEvent,FALSE);
    pResumptionContext->Status   = STATUS_SUCCESS;
    pResumptionContext->Flags    = 0;
    pResumptionContext->pContext = NULL;
}

INLINE VOID
SmbCeInitializeAsynchronousResumptionContext(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext,
    PRX_WORKERTHREAD_ROUTINE  pResumptionRoutine,
    PVOID                     pResumptionRoutineParam)
{
    pResumptionContext->Status   = STATUS_SUCCESS;
    pResumptionContext->Flags    = SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS;
    pResumptionContext->pContext = pResumptionRoutineParam;
    pResumptionContext->pRoutine = pResumptionRoutine;
}

INLINE VOID
SmbCeSuspend(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext)
{
    ASSERT(!(pResumptionContext->Flags & SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS));
    KeWaitForSingleObject(
        &pResumptionContext->Event,
        Executive,
        KernelMode,
        FALSE,
        NULL);
}

INLINE VOID
SmbCeResume(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext)
{
    if (!(pResumptionContext->Flags & SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS)) {
        KeSetEvent(&(pResumptionContext)->Event,0,FALSE);
    } else {
        if (RxShouldPostCompletion()) {
            RxDispatchToWorkerThread(
                MRxSmbDeviceObject,
                CriticalWorkQueue,
                pResumptionContext->pRoutine,
                pResumptionContext->pContext);
        } else {
            (pResumptionContext->pRoutine)(pResumptionContext->pContext);
        }
    }
}

//
// The SMBCE_REQUEST struct encapsulates the continuation context associated. Typically
// the act of sending a SMB along an exchange results in a SMBCE_REQUEST structure being
// created with sufficient context information to resume the exchange upon reciept of
// response from the serve. The SMBCE_REQUEST conatins ebough information to identify
// the SMB for which the response is being obtained followed by enough context information
// to resume the exchange.
//

typedef enum _SMBCE_OPERATION_ {
    SMBCE_TRANCEIVE,
    SMBCE_RECEIVE,
    SMBCE_SEND,
    SMBCE_ASYNCHRONOUS_SEND,
    SMBCE_ACQUIRE_MID
} SMBCE_OPERATION, *PSMBCE_OPERATION;

typedef enum _SMBCE_REQUEST_TYPE_ {
    ORDINARY_REQUEST,
    COPY_DATA_REQUEST,
    RECONNECT_REQUEST,
    ACQUIRE_MID_REQUEST
} SMBCE_REQUEST_TYPE, *PSMBCE_REQUEST_TYPE;

typedef struct _SMBCE_GENERIC_REQUEST_ {
    SMBCE_REQUEST_TYPE      Type;

    // the exchange instance that originated this SMB
    struct _SMB_EXCHANGE *  pExchange;
} SMBCE_GENERIC_REQUEST, *PSMBCE_GENERIC_REQUEST;

typedef struct _SMBCE_REQUEST_ {
    SMBCE_GENERIC_REQUEST;

    // the type of request
    SMBCE_OPERATION Operation;

    // the virtual circuit along which this request was sent.
    PRXCE_VC        pVc;

    // MPX Id of outgoing request.
    SMB_MPX_ID      Mid;

    // the pedigree of the request
    SMB_TREE_ID     TreeId;      // The Tree Id.
    SMB_FILE_ID     FileId;      // The file id.
    SMB_USER_ID     UserId;      // User Id. for cancel.
    SMB_PROCESS_ID  ProcessId;   // Process Id. for cancel.

    PMDL            pSendBuffer;
    ULONG           BytesSent;
} SMBCE_REQUEST, *PSMBCE_REQUEST;


typedef struct _SMBCE_COPY_DATA_REQUEST_ {
    SMBCE_GENERIC_REQUEST;

    // the virtual circuit along which this request was sent.
    PRXCE_VC    pVc;

    // the buffer into whihc data is being copied.
    PVOID          pBuffer;

    // the actual number of bytes copied
    ULONG          BytesCopied;
} SMBCE_COPY_DATA_REQUEST, *PSMBCE_COPY_DATA_REQUEST;


typedef struct _SMBCE_RECONNECT_REQUEST_ {
    SMBCE_GENERIC_REQUEST;
} SMBCE_RECONNECT_REQUEST, *PSMBCE_RECONNECT_REQUEST;

typedef struct _SMBCE_MID_REQUEST_ {
    SMBCE_GENERIC_REQUEST;
    PSMBCE_RESUMPTION_CONTEXT   pResumptionContext;
} SMBCE_MID_REQUEST, *PSMBCE_MID_REQUEST;


//
// extern function declarations
//

extern NTSTATUS
BuildSessionSetupSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX  pAndXSmb,
    PULONG         pAndXSmbBufferSize);

extern NTSTATUS
CoreBuildTreeConnectSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX        pAndXSmb,
    PULONG               pAndXSmbBufferSize);

extern NTSTATUS
LmBuildTreeConnectSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX        pAndXSmb,
    PULONG               pAndXSmbBufferSize);

extern NTSTATUS
NtBuildTreeConnectSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX        pAndXSmb,
    PULONG               pAndXSmbBufferSize);

extern NTSTATUS
BuildNegotiateSmb(
    PVOID    *pSmbBufferPointer,
    PULONG   pSmbBufferLength);

extern NTSTATUS
ParseNegotiateResponse(
    IN OUT struct _SMB_ADMIN_EXCHANGE_ *pExchange,
    IN     ULONG               BytesIndicated,
    IN     ULONG               BytesAvailable,
       OUT PULONG              pBytesTaken,
    IN     PSMB_HEADER         pSmbHeader,
       OUT PMDL                *pDataBufferPointer,
       OUT PULONG              pDataSize);


extern struct _MINIRDR_DISPATCH MRxSmbDispatch;

#endif // _SMBCE_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbcaps.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    SmbCaps.h

Abstract:

    This module defines the types and functions related to the determining the capabilities supported
    by any particular server according to both the dialect it negotiates and the capabilties it returns.

Revision History:

--*/

#ifndef _SMBCAPS_H_
#define _SMBCAPS_H_


//
//      Dialect flags
//
//      These flags describe the various and sundry capabilities that
//      a server can provide. I essentially just lifted this list from rdr1 so that I
//      could also use the level2,3 of getconnectinfo which was also just lifted from rdr1.
//      Many of these guys you can get directly from the CAPS field of the negotiate response but others
//      you cannot. These is a table in the negotiate code that fills in the stuff that is just inferred
//      from the dialect negotiated (also, just lifted from rdr1....a veritable fount of just info.)
//
//      Another set of capabilities is defined in smbce.h....perhaps these should go there or vice versa.
//      The advantage to having them here is that this file has to be included by the aforementioned getconfiginfo code
//      up in the wrapper.
//

#define DF_CORE                0x00000001      // Server is a core server
#define DF_MIXEDCASEPW         0x00000002      // Server supports mixed case password
#define DF_OLDRAWIO            0x00000004      // Server supports MSNET 1.03 RAW I/O
#define DF_NEWRAWIO            0x00000008      // Server supports LANMAN Raw I/O
#define DF_LANMAN10            0x00000010      // Server supports LANMAN 1.0 protocol
#define DF_LANMAN20            0x00000020      // Server supports LANMAN 2.0 protocol
#define DF_MIXEDCASE           0x00000040      // Server supports mixed case files
#define DF_LONGNAME            0x00000080      // Server supports long named files
#define DF_EXTENDNEGOT         0x00000100      // Server returns extended negotiate
#define DF_LOCKREAD            0x00000200      // Server supports LockReadWriteUnlock
#define DF_SECURITY            0x00000400      // Server supports enhanced security
#define DF_NTPROTOCOL          0x00000800      // Server supports NT semantics
#define DF_SUPPORTEA           0x00001000      // Server supports extended attribs
#define DF_LANMAN21            0x00002000      // Server supports LANMAN 2.1 protocol
#define DF_CANCEL              0x00004000      // Server supports NT style cancel
#define DF_UNICODE             0x00008000      // Server supports unicode names.
#define DF_NTNEGOTIATE         0x00010000      // Server supports NT style negotiate.
#define DF_LARGE_FILES         0x00020000      // Server supports large files.
#define DF_NT_SMBS             0x00040000      // Server supports NT SMBs
#define DF_RPC_REMOTE          0x00080000      // Server is administrated via RPC
#define DF_NT_STATUS           0x00100000      // Server returns NT style statuses
#define DF_OPLOCK_LVL2         0x00200000      // Server supports level 2 oplocks.
#define DF_TIME_IS_UTC         0x00400000      // Server time is in UTC.
#define DF_WFW                 0x00800000      // Server is Windows for workgroups.
#define DF_TRANS2_FSCTL        0x02000000      // Server accepts remoted fsctls in tran2s
#define DF_DFS_TRANS2          0x04000000      // Server accepts Dfs related trans2
                                               // functions. Can this be merged with
                                               // DF_TRANS2_FSCTL?
#define DF_NT_FIND             0x08000000      // Server supports NT infolevels
#define DF_W95                 0x10000000      // this is a win95 server.....sigh
#define DF_NT_INFO_PASSTHROUGH 0x20000000      // This server supports setting and getting
                                               // NT infolevels by offsetting the requested
                                               // infolevel by SMB_INFO_PASSTHROUGH
#define DF_LARGE_WRITEX        0x40000000      // This server supports large writes
#define DF_OPLOCK              0x80000000      // This server supports opportunistic lock

#endif // _SMBCAPS_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbcedb.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    smbcedb.c

Abstract:

    This module implements all functions related to accessing the SMB connection engine
    database

Notes:

    The construction of server, net root and session entries involve a certain
    amount of network traffic. Therefore, all these entities are constructed
    using a two phase protocol

    This continuation context is that of the RDBSS during construction of
    srv call and net root entries. For the session entries it is an SMB exchange
    that needs to be resumed.

    Two of the three primary data structures in the SMB mini redirector, i.e.,
    SMBCEDB_SERVER_ENTRY, SMBCEDB_SESSION_ENTRY and SMBCEDB_NET_ROOT_ENTRY  have
    directcounterparts in the RDBSS (MRX_SRV_CALL, MRX_V_NET_ROOT and MRX_NET_ROOT)
    constitute the core of the SMB mini redirector connection engine. There exists
    a one to one mapping between the SERVER_ENTRY and the MRX_SRV_CALL, as well
    as NET_ROOT_ENTRY and MRX_NET_ROOT.

    The SMBCEDB_SESSION_ENTRY does not have a direct mapping to a wrapper data
    structue, It is a part of SMBCE_V_NET_ROOT_CONTEXT which is the data
    structure associated with a MRX_V_NET_ROOT instance.

    More than one tree connect to a server can use the same session on a USER level
    security share. Consequently mapping rules need to be established to manage this
    relationship. The SMB mini redirector implements the following rules ...

         1) The first session with explicitly specified credentials will be
         treated as the default session for all subsequent requests to any given
         server unless credentials are explicitly specified for the new session.

         2) If no session with explicitly specified credentials exist then a
         session with the same logon id. is choosen.

         3) If no session with the same logon id. exists a new session is created.

    These rules are liable to change as we experiment with rules for establishing
    sessions with differing credentials to a given server. The problem is not with
    creating/manipulating these sessions but providing an adequate set of
    fallback rules for emulating the behaviour of the old redirector.

    These rules are implemented in SmbCeFindOrConstructSessionEntry.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeUpdateSrvCall)
#pragma alloc_text(PAGE, SmbCeTearDownServerEntry)
#pragma alloc_text(PAGE, SmbCeCompleteSessionEntryInitialization)
#pragma alloc_text(PAGE, SmbCeGetUserNameAndDomainName)
#pragma alloc_text(PAGE, SmbCeTearDownSessionEntry)
#pragma alloc_text(PAGE, SmbCeTearDownNetRootEntry)
#pragma alloc_text(PAGE, SmbCeUpdateNetRoot)
#pragma alloc_text(PAGE, SmbCeDbInit)
#endif

RXDT_DefineCategory(SMBCEDB);
#define Dbg        (DEBUG_TRACE_SMBCEDB)

// The flag mask to control reference count tracing.

ULONG MRxSmbReferenceTracingValue = 0;

PSMBCEDB_SERVER_ENTRY
SmbCeFindServerEntry(
    PUNICODE_STRING     pServerName,
    SMBCEDB_SERVER_TYPE ServerType)
/*++

Routine Description:

    This routine searches the list of server entries and locates a matching
    entry

Arguments:

    pServerName - the name of the server

    ServerType  - the server type

Notes:

    The SmbCeResource must be held on entry and its ownership state will remain
    unchanged on exit

--*/
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    ASSERT(SmbCeIsResourceOwned());

    pServerEntry = SmbCeGetFirstServerEntry();
    while (pServerEntry != NULL) {
        if ((RtlCompareUnicodeString(
                    pServerName,
                    &pServerEntry->Name,
                    TRUE) == 0)) {
            SmbCeReferenceServerEntry(pServerEntry);
            break;
        } else {
            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }
    }

    return pServerEntry;
}


NTSTATUS
SmbCeFindOrConstructServerEntry(
    PUNICODE_STRING       pServerName,
    SMBCEDB_SERVER_TYPE   ServerType,
    PSMBCEDB_SERVER_ENTRY *pServerEntryPtr,
    PBOOLEAN              pNewServerEntry)
/*++

Routine Description:

    This routine searches the list of server entries and locates a matching
    entry or constructs a new one with the given name

Arguments:

    pServerName - the name of the server

    ServerType  - the type of server

    pServerEntryPtr - placeholder for the server entry

    pNewServerEntry - set to TRUE if it is a newly created server entry

Notes:

    The SmbCeResource must be held on entry and its ownership state will remain
    unchanged on exit

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN               fNewServerEntry = FALSE;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    ASSERT(SmbCeIsResourceOwned());

    pServerEntry = SmbCeFindServerEntry(
                       pServerName,
                       ServerType);

    if (pServerEntry == NULL) {
        // Create a server instance, initialize its state, add it to the list

        pServerEntry = (PSMBCEDB_SERVER_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_SERVER);

        if (pServerEntry != NULL) {
            pServerEntry->Name.Buffer = RxAllocatePoolWithTag(
                                             NonPagedPool,
                                             pServerName->Length,
                                             MRXSMB_SERVER_POOLTAG);

            if (pServerEntry->Name.Buffer == NULL) {
                SmbMmFreeObject(pServerEntry);
                pServerEntry = NULL;
            }
        }

        if (pServerEntry != NULL) {
            fNewServerEntry = TRUE;

            pServerEntry->Name.Length = pServerName->Length;
            pServerEntry->Name.MaximumLength = pServerEntry->Name.Length;
            RtlCopyMemory(
                pServerEntry->Name.Buffer,
                pServerName->Buffer,
                pServerEntry->Name.Length);

            SmbCeUpdateServerEntryState(
                pServerEntry,
                SMBCEDB_CONSTRUCTION_IN_PROGRESS);

            SmbCeSetServerType(
                pServerEntry,
                ServerType);

            pServerEntry->PreferredTransport = NULL;

            SmbCeReferenceServerEntry(pServerEntry);
            SmbCeAddServerEntry(pServerEntry);

            SmbCeLog(("NewSrvEntry %lx %wZ\n",pServerEntry,&pServerEntry->Name));
        } else {
            RxDbgTrace(0, Dbg, ("SmbCeOpenServer : Server Entry Allocation failed\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        if (pServerEntry->PreferredTransport != NULL) {
            // reset the preferred transport created by previous owner
            SmbCeDereferenceTransport(pServerEntry->PreferredTransport);
            pServerEntry->PreferredTransport = NULL;
        }

        SmbCeLog(("CachedSrvEntry %lx %wZ\n",pServerEntry,&pServerEntry->Name));
    }

    *pServerEntryPtr = pServerEntry;
    *pNewServerEntry = fNewServerEntry;

    return Status;
}

VOID
SmbCeCompleteSrvCallConstruction(
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

    This routine comlpletes the srvcall construtcion routine by invoking
    the callback routine to the wrapper.

Arguments:

    pCallbackContext   - the RDBSS context

Notes:

--*/
{
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure;
    PMRX_SRV_CALL              pSrvCall;
    PSMBCEDB_SERVER_ENTRY      pServerEntry;
    BOOLEAN                    MustSucceed = FALSE;
    NTSTATUS                   Status;

    PAGED_CODE();

    SrvCalldownStructure =
        (PMRX_SRVCALLDOWN_STRUCTURE)(pCallbackContext->SrvCalldownStructure);

    pSrvCall = SrvCalldownStructure->SrvCall;
    pServerEntry = (PSMBCEDB_SERVER_ENTRY)pCallbackContext->RecommunicateContext;

    if (pServerEntry != NULL) {
        if (!NT_SUCCESS(pCallbackContext->Status)) {
            if (pCallbackContext->Status == STATUS_RETRY) {
                MustSucceed = TRUE;
            }

            SmbCeDereferenceServerEntry(pServerEntry);
        }
    } else {
        pCallbackContext->Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (MustSucceed) {
        //DbgPrint("Build ServerEntry %X try again.\n",pCallbackContext->Status);

        // Transport is not ready and the cache is not filled, we need to create the
        // server entry again until it succeeds.
        Status = RxDispatchToWorkerThread(
                     MRxSmbDeviceObject,
                     CriticalWorkQueue,
                     SmbCeCreateSrvCall,
                     pCallbackContext);
    } else {
        SrvCalldownStructure->CallBack(pCallbackContext);
    }
}

NTSTATUS
SmbCeInitializeServerEntry(
    PMRX_SRV_CALL                 pSrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext,
    BOOLEAN                       fDeferNetworkInitialization)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pSrvCall           - the SrvCall instance

    pCallbackContext   - the RDBSS context

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
    PSMBCE_TRANSPORT      PreferredTransport = NULL;
    BOOLEAN               fNewServerEntry = FALSE;
    SMBCEDB_SERVER_TYPE   ServerType = SMBCEDB_FILE_SERVER;
    UNICODE_STRING        TransportName;

//   RxProfile(SmbCe,SmbCeOpenServer);

    ASSERT(pSrvCall->Context == NULL);
    TransportName = pCallbackContext->SrvCalldownStructure->RxContext->Create.TransportName;

    if (TransportName.Length > 0) {
        if ((PreferredTransport=SmbCeFindTransport(&TransportName)) == NULL) {
            ASSERT(pCallbackContext->RecommunicateContext == NULL);
            Status = STATUS_NETWORK_UNREACHABLE;
            goto FINALLY;
        }
    }

    SmbCeAcquireResource();

    Status = SmbCeFindOrConstructServerEntry(
                 pSrvCall->pSrvCallName,
                 ServerType,
                 &pServerEntry,
                 &fNewServerEntry);

    SmbCeReleaseResource();

    pCallbackContext->RecommunicateContext = pServerEntry;

    if (Status == STATUS_SUCCESS) {

        ASSERT(pServerEntry != NULL);

        InterlockedExchangePointer(
            &pServerEntry->pRdbssSrvCall,
            pSrvCall);

        Status = SmbCeUpdateSrvCall(pServerEntry);

        if (Status == STATUS_SUCCESS) {
            if (PreferredTransport != NULL) {
                // Transfer the ownership of the preferred transport to the
                // server entry.
                pServerEntry->PreferredTransport = PreferredTransport;
                PreferredTransport = NULL;
            } else {
                pServerEntry->PreferredTransport = NULL;
            }

            if (fNewServerEntry) {
                pServerEntry->Header.State = SMBCEDB_INVALID;
                pServerEntry->Server.Dialect = LANMAN21_DIALECT;
                pServerEntry->Server.MaximumBufferSize = 0xffff;

            }

            if (!fDeferNetworkInitialization) {
                Status = SmbCeInitializeServerTransport(
                             pServerEntry,
                             SmbCeCompleteSrvCallConstruction,
                             pCallbackContext);
            }
        }
    }

FINALLY:
    if (Status != STATUS_PENDING) {
        pCallbackContext->Status = Status;
        SmbCeCompleteSrvCallConstruction(pCallbackContext);
    }

    if (PreferredTransport != NULL) {
        SmbCeDereferenceTransport(PreferredTransport);
    }

    return STATUS_PENDING;
}


NTSTATUS
SmbCeUpdateSrvCall(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine initializes the wrapper data structure corresponding to a
    given server entry.

Arguments:

    pServerEntry  - the server entry

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMRX_SRV_CALL pSrvCall = pServerEntry->pRdbssSrvCall;

    PAGED_CODE();

    if (pSrvCall != NULL) {
        // Copy the domain name into the server entry
        Status = RxSetSrvCallDomainName(
                     pSrvCall,
                     &pServerEntry->DomainName);

        // Initialize the SrvCall flags based upon the capabilities of the remote
        // server. The only flag that the SMB mini redirector updates is the
        // SRVCALL_FLAG_DFS_AWARE

        if (pServerEntry->Server.Capabilities & CAP_DFS) {
            SetFlag(
                pSrvCall->Flags,
                SRVCALL_FLAG_DFS_AWARE_SERVER);
        }
    }

    return Status;
}


VOID
SmbCeCompleteServerEntryInitialization(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    NTSTATUS              Status)
/*++

Routine Description:

    This routine is invoked in the context of a worker thread to finalize the
    construction of a server entry

Arguments:

    pServerEntry  - the server entry to be finalized

    ServerState   - the final state of the server

--*/
{
    NTSTATUS                ServerStatus;

    SMBCEDB_OBJECT_STATE    PreviousState;
    SMBCEDB_REQUESTS        ReconnectRequests;
    PSMBCEDB_REQUEST_ENTRY  pRequestEntry;

    KIRQL                   SavedIrql;

    RxDbgTrace( 0, Dbg, ("Server Entry Finalization\n"));
    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    InitializeListHead(&ReconnectRequests.ListHead);

    // Acquire the SMBCE resource
    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    // The server status could have changed because of the transport disconnects
    // from the time the admin exchange was completed to the time the server
    // entry initialization complete routine is called. Update the state
    // accordingly.

    PreviousState = pServerEntry->Header.State;

    if (PreviousState == SMBCEDB_CONSTRUCTION_IN_PROGRESS) {
        pServerEntry->ServerStatus = Status;

        if (Status == STATUS_SUCCESS) {
            pServerEntry->Header.State = SMBCEDB_ACTIVE;
        } else {
            pServerEntry->Header.State = SMBCEDB_INVALID;
        }
    }

    ServerStatus = pServerEntry->ServerStatus;

    pServerEntry->NegotiateInProgress = FALSE;

    // Weed out all the reconnect requests so that they can be resumed
    pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
    while (pRequestEntry != NULL) {
        if (pRequestEntry->GenericRequest.Type == RECONNECT_REQUEST) {
            PSMBCEDB_REQUEST_ENTRY pTempRequestEntry;

            pTempRequestEntry = pRequestEntry;
            pRequestEntry = SmbCeGetNextRequestEntry(
                                &pServerEntry->OutstandingRequests,
                                pRequestEntry);

            SmbCeRemoveRequestEntryLite(
                &pServerEntry->OutstandingRequests,
                pTempRequestEntry);

            SmbCeAddRequestEntryLite(
                &ReconnectRequests,
                pTempRequestEntry);
        } else {
            pRequestEntry = SmbCeGetNextRequestEntry(
                                &pServerEntry->OutstandingRequests,
                                pRequestEntry);
        }
    }

    pServerEntry->Server.NumberOfVNetRootContextsForScavenging = 0;

    SmbCeReleaseSpinLock();

    if ((Status == STATUS_SUCCESS) &&
        (ServerStatus == STATUS_SUCCESS) &&
        (PreviousState == SMBCEDB_CONSTRUCTION_IN_PROGRESS)) {
        PSMBCEDB_SESSION_ENTRY pSessionEntry;
        SESSION_TYPE           SessionType;

        InterlockedIncrement(&pServerEntry->Server.Version);
        pServerEntry->Server.NumberOfSrvOpens = 0;

        ASSERT(pServerEntry->pMidAtlas == NULL);

        // Initialize the MID Atlas
        pServerEntry->pMidAtlas = FsRtlCreateMidAtlas(
                                       pServerEntry->Server.MaximumRequests,
                                       pServerEntry->Server.MaximumRequests);

        if (pServerEntry->pMidAtlas == NULL) {
            pServerEntry->ServerStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        // The sessions that have been created but whose initialization has been
        // deferred will have the session types set incorrectly. This is because
        // there is no previous knowledge of the session type required for deferred
        // servers.

        SessionType = LANMAN_SESSION;

        pSessionEntry =  SmbCeGetFirstSessionEntry(pServerEntry);
        while (pSessionEntry != NULL) {
            pSessionEntry->Session.Type = SessionType;
            pSessionEntry = SmbCeGetNextSessionEntry(
                                pServerEntry,
                                pSessionEntry);
        }
    }

    // Release the resource for the server entry
    SmbCeReleaseResource();

    // Resume all the outstanding reconnect requests that were held up because an earlier
    // reconnect request was under way.
    // Iterate over the list of pending requests and resume all of them
    SmbCeResumeOutstandingRequests(&ReconnectRequests,ServerStatus);
}


VOID
SmbCepDereferenceServerEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine dereferences a server entry instance

Arguments:

    pServerEntry - the server entry to be dereferenced

--*/
{
    if (pServerEntry != NULL) {
        BOOLEAN fTearDownEntry = FALSE;
        LONG    FinalRefCount;

        ASSERT((pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER) &&
               (pServerEntry->Header.SwizzleCount > 0));

        MRXSMB_PRINT_REF_COUNT(SERVER_ENTRY,pServerEntry->Header.SwizzleCount);

        SmbCeAcquireResource();
        SmbCeAcquireSpinLock();

        FinalRefCount = InterlockedDecrement(&pServerEntry->Header.SwizzleCount);

        fTearDownEntry = (FinalRefCount == 0);

        if (fTearDownEntry) {
            // This is to ensure that the routines for traversing the server
            // entry list, i.e., probing servers do not colide with the teardown.

            if (pServerEntry->Header.SwizzleCount == 0) {
                pServerEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                SmbCeRemoveServerEntryLite(pServerEntry);

                if (SmbCeGetFirstServerEntry() == NULL &&
                    SmbCeStartStopContext.pServerEntryTearDownEvent != NULL) {
                    KeSetEvent(SmbCeStartStopContext.pServerEntryTearDownEvent,0,FALSE);
                }
            } else {
                fTearDownEntry = FALSE;
            }

        }

        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();

        if (fTearDownEntry) {
            SmbCeTearDownServerEntry(pServerEntry);
        }
    }
}

VOID
SmbCeTearDownServerEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine tears down a server entry instance

Arguments:

    pServerEntry - the server entry to be dereferenced

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAGED_CODE();

    ASSERT(pServerEntry->Header.State == SMBCEDB_MARKED_FOR_DELETION);
    SmbCeLog(("TearSrvEntry %lx %wZ\n",pServerEntry,&pServerEntry->Name));

    if (pServerEntry->pMidAtlas != NULL) {
        FsRtlDestroyMidAtlas(pServerEntry->pMidAtlas,NULL);
        pServerEntry->pMidAtlas = NULL;
    }

    if (pServerEntry->pTransport != NULL) {
        Status = SmbCeUninitializeServerTransport(pServerEntry,NULL,NULL);
    }

    if (pServerEntry->Name.Buffer != NULL) {
        RxFreePool(pServerEntry->Name.Buffer);
    }

    if (pServerEntry->DomainName.Buffer != NULL) {
        RxFreePool(pServerEntry->DomainName.Buffer);
    }

    if (pServerEntry->DfsRootName.Buffer != NULL) {
        RxFreePool(pServerEntry->DfsRootName.Buffer);
    }

    if (pServerEntry->PreferredTransport != NULL) {
        SmbCeDereferenceTransport(pServerEntry->PreferredTransport);
    }

    if (Status == STATUS_SUCCESS) {
        SmbMmFreeObject(pServerEntry);
    } else {
        ASSERT(FALSE);
    }

}

NTSTATUS
SmbCeFindOrConstructSessionEntry(
    PMRX_V_NET_ROOT         pVNetRoot,
    PSMBCEDB_SESSION_ENTRY *pSessionEntryPtr)
/*++

Routine Description:

    This routine opens/creates a session for a given user in the connection engine database

Arguments:

    pVNetRoot - the RDBSS Virtual net root instance

Return Value:

    STATUS_SUCCESS - if successful

    Other Status codes correspond to error situations.

Notes:

    This routine assumes that the necesary concurreny control mechanism has already
    been taken.

    On Entry the connection engine resource must have been acquired exclusive and
    ownership remains invariant on exit.

    In case of UPN, we should pass a NULL string instead of NULL as domain name.

--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY   pServerEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry = NULL;
    BOOLEAN                 fSessionEntryFound = FALSE;
    PUNICODE_STRING         UserName;
    PUNICODE_STRING         Password;
    PUNICODE_STRING         UserDomainName;
    DWORD                   SessionType;
    LUID                    AnonymousLogonID = ANONYMOUS_LOGON_LUID;

#define SessionTypeDefault      1
#define SessionTypeUser         2
#define SessionTypeNull         3

    ASSERT(SmbCeIsResourceOwned());

    UserName = pVNetRoot->pUserName;
    Password = pVNetRoot->pPassword;
    UserDomainName = pVNetRoot->pUserDomainName;

    SessionType = SessionTypeDefault;


        if ((UserName != NULL)       &&
            (UserName->Length == 0)  &&
            (Password != NULL)       &&
            (Password->Length == 0)  &&
            (UserDomainName != NULL) &&
            (UserDomainName->Length == 0)) {
            SessionType = SessionTypeNull;
        } else if ((UserName != NULL) ||
                   ((Password != NULL) &&
                    (Password->Length > 0))) {
            SessionType = SessionTypeUser;
        }

    *pSessionEntryPtr = NULL;

    // Reference the server handle
    pServerEntry = SmbCeReferenceAssociatedServerEntry(pVNetRoot->pNetRoot->pSrvCall);
    if (pServerEntry != NULL) {
        if (SessionType != SessionTypeUser) {

            SmbCeAcquireSpinLock();
            // Rule No. 1
            // 1) The first session with explicitly specified credentials will be treated as the
            // default session for all subsequent requests to any given server.
            if (SessionType == SessionTypeDefault) {
                pSessionEntry = SmbCeGetDefaultSessionEntry(
                                    pServerEntry,
                                    pVNetRoot->SessionId,
                                    &pVNetRoot->LogonId);

                while (pSessionEntry != NULL &&
                       FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION)) {

                    SmbCeRemoveDefaultSessionEntry(pSessionEntry);

                    pSessionEntry = SmbCeGetDefaultSessionEntry(
                                        pServerEntry,
                                        pVNetRoot->SessionId,
                                        &pVNetRoot->LogonId);
                }
            }

            if (pSessionEntry == NULL) {
                // Enumerate the sessions to detect if a session satisfying rule 2 exists

                pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
                while (pSessionEntry != NULL) {
                    if (!FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION)) {
                        if (SessionType == SessionTypeDefault) {
                            //
                            // Rule No. 2
                            // 2) If no session with explicitly specified credentials exist then a
                            // session with the same logon id. is choosen.
                            //

                            if (RtlEqualLuid(
                                    &pSessionEntry->Session.LogonId,
                                    &pVNetRoot->LogonId)) {
                                break;
                            }
                        } else if (SessionType == SessionTypeNull) {
                            if (FlagOn(
                                    pSessionEntry->Session.Flags,
                                    SMBCE_SESSION_FLAGS_NULL_CREDENTIALS)) {
                                break;
                            }
                        }
                    }

                    pSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry);
                }
            }

            if (pSessionEntry != NULL) {
                SmbCeReferenceSessionEntry(pSessionEntry);
            }

            SmbCeReleaseSpinLock();
        } else {
            BOOLEAN SessionEntryFound = FALSE;
            
            SmbCeAcquireSpinLock();
            pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
            if (pSessionEntry != NULL) {
                SmbCeReferenceSessionEntry(pSessionEntry);
            }
            SmbCeReleaseSpinLock();

            while ((pSessionEntry != NULL) && !SessionEntryFound) {
                if (!FlagOn(pSessionEntry->Session.Flags,
                        SMBCE_SESSION_FLAGS_NULL_CREDENTIALS |
                        SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION)) {
                    PSecurityUserData pSecurityData = NULL;

                    for (;;) {
                        PSMBCE_SESSION  pSession = &pSessionEntry->Session;
                        PUNICODE_STRING TempUserName,TempUserDomainName;

                        // For each existing session check to determine if the credentials
                        // supplied match the credentials used to construct the session.
                        if( pSession->SessionId != pVNetRoot->SessionId ) {
                            break;
                        }

                        if (!RtlEqualLuid(
                                &pSessionEntry->Session.LogonId,
                                &pVNetRoot->LogonId)) {
                            break;
                        }
                         
                        TempUserName       = pSession->pUserName;
                        TempUserDomainName = pSession->pUserDomainName;

                        if (TempUserName == NULL ||
                            TempUserDomainName == NULL) {
                            Status = GetSecurityUserInfo(
                                         &pVNetRoot->LogonId,
                                         UNDERSTANDS_LONG_NAMES,
                                         &pSecurityData);
                            
                            if (NT_SUCCESS(Status)) {
                                if (TempUserName == NULL) {
                                    TempUserName = &(pSecurityData->UserName);
                                }
                
                                if (TempUserDomainName == NULL) {
                                    TempUserDomainName = &(pSecurityData->LogonDomainName);
                                }
                            } else {
                                break;
                            }
                        }

                        if (UserName != NULL && 
                            !RtlEqualUnicodeString(UserName,TempUserName,TRUE)) {
                            Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                            break;
                        }
                    
                        if (UserDomainName != NULL &&
                            !RtlEqualUnicodeString(UserDomainName,TempUserDomainName,TRUE)) {
                            Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                            break;
                        }
                        
                        if ((Password != NULL) &&
                            (pSession->pPassword != NULL)) {
                            if (!RtlEqualUnicodeString(
                                    Password,
                                    pSession->pPassword,
                                    FALSE)) {
                                Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                                break;
                            }
                        }
                         
                        // We use existing session if either the stored or new password is NULL.
                        // Later, a new security API will be created for verify the password 
                        // based on the logon ID.

                        // An entry that matches the credentials supplied has been found. use it.
                        SessionEntryFound = TRUE;
                        break;
                    }

                    //ASSERT(Status != STATUS_NETWORK_CREDENTIAL_CONFLICT);

                    if (pSecurityData != NULL) {
                        LsaFreeReturnBuffer(pSecurityData);
                    }
                }

                if (pServerEntry->Server.SecurityMode == SECURITY_MODE_SHARE_LEVEL &&
                    (Status == STATUS_NETWORK_CREDENTIAL_CONFLICT ||
                     Status == STATUS_LOGON_FAILURE)) {
                    Status = STATUS_SUCCESS;
                }

                if (!SessionEntryFound) {
                    if (Status == STATUS_SUCCESS) {
                        PSMBCEDB_SESSION_ENTRY pNextSessionEntry;

                        SmbCeAcquireSpinLock();
                        pNextSessionEntry = SmbCeGetNextSessionEntry(
                                                pServerEntry,
                                                pSessionEntry);
                        if (pNextSessionEntry != NULL) {
                            SmbCeReferenceSessionEntry(pNextSessionEntry);
                        }
                        SmbCeReleaseSpinLock();

                        SmbCeDereferenceSessionEntry(pSessionEntry);
                        pSessionEntry = pNextSessionEntry;
                    } else {
                        // An error situation was encountered. Terminate the iteration.
                        // Typically a set of conflicting credentials have been presented
                        SmbCeDereferenceSessionEntry(pSessionEntry);
                        pSessionEntry = NULL;
                    }
                } else {
                    if (RtlEqualLuid(&pSessionEntry->Session.LogonId,&AnonymousLogonID) &&
                        (Password != NULL || UserName != NULL || UserDomainName != NULL)) {
                        Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                    }
                }
            }
        }

        if ((pSessionEntry == NULL) && (Status == STATUS_SUCCESS)) {
            // Rule No. 3
            // 3) If no session with the same logon id. exists a new session is created.
            //
            // Allocate a new session entry

            // This is the point at which a many to mapping between session entries and
            // V_NET_ROOT's in the RDBSS is being established. From this point it is
            // true that the session entry can outlive the associated V_NET_ROOT entry.
            // Therefore copies of the parameters used in the session setup need be made.

            PSMBCE_SESSION  pSession = &pSessionEntry->Session;
            PUNICODE_STRING pPassword,pUserName,pUserDomainName;


            if (Password != NULL) {
                pPassword = (PUNICODE_STRING)
                            RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(UNICODE_STRING) + Password->Length,
                                MRXSMB_SESSION_POOLTAG);
                if (pPassword != NULL) {
                    pPassword->Buffer = (PWCHAR)((PCHAR)pPassword + sizeof(UNICODE_STRING));
                    pPassword->Length = Password->Length;
                    pPassword->MaximumLength = pPassword->Length;
                    RtlCopyMemory(
                        pPassword->Buffer,
                        Password->Buffer,
                        pPassword->Length);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                pPassword = NULL;
            }

            if ((UserName != NULL) &&
                (Status == STATUS_SUCCESS)) {
                pUserName = (PUNICODE_STRING)
                            RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(UNICODE_STRING) + UserName->Length,
                                MRXSMB_SESSION_POOLTAG);
                if (pUserName != NULL) {
                    pUserName->Buffer = (PWCHAR)((PCHAR)pUserName + sizeof(UNICODE_STRING));
                    pUserName->Length = UserName->Length;
                    pUserName->MaximumLength = pUserName->Length;
                    RtlCopyMemory(
                        pUserName->Buffer,
                        UserName->Buffer,
                        pUserName->Length);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                pUserName = NULL;
            }

            if ((UserDomainName != NULL) &&
                (Status == STATUS_SUCCESS)) {
                pUserDomainName = (PUNICODE_STRING)
                                  RxAllocatePoolWithTag(
                                      NonPagedPool,
                                      sizeof(UNICODE_STRING) + UserDomainName->Length + sizeof(WCHAR),
                                      MRXSMB_SESSION_POOLTAG);

                if (pUserDomainName != NULL) {
                    pUserDomainName->Buffer = (PWCHAR)((PCHAR)pUserDomainName + sizeof(UNICODE_STRING));
                    pUserDomainName->Length = UserDomainName->Length;
                    pUserDomainName->MaximumLength = pUserDomainName->Length;

                    // in case of UPN name, domain name will be a NULL string
                    *pUserDomainName->Buffer = 0;

                    if (UserDomainName->Length > 0) {
                        RtlCopyMemory(
                            pUserDomainName->Buffer,
                            UserDomainName->Buffer,
                            pUserDomainName->Length);
                    }
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                pUserDomainName = NULL;
            }

            if (Status == STATUS_SUCCESS) {
                pSessionEntry = SmbMmAllocateSessionEntry(pServerEntry);
                if (pSessionEntry != NULL) {
                    PSMBCE_SESSION pSession = & pSessionEntry->Session;

                    SmbCeLog(("NewSessEntry %lx\n",pSessionEntry));

                    pSessionEntry->Header.State    = SMBCEDB_INVALID;
                    pSessionEntry->pServerEntry    = pServerEntry;

                    if (pServerEntry->Server.SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
                        pSessionEntry->Session.UserId = (SMB_USER_ID)SMBCE_SHARE_LEVEL_SERVER_USERID;
                    }

                    pSession->Flags           = 0;

                    if ( SessionType == SessionTypeNull ) {
                        pSession->Flags |= SMBCE_SESSION_FLAGS_NULL_CREDENTIALS;
                    }

                    pSession->LogonId         = pVNetRoot->LogonId;
                    pSession->pUserName       = pUserName;
                    pSession->pPassword       = pPassword;
                    pSession->pUserDomainName = pUserDomainName;
                    pSession->SessionId       = pVNetRoot->SessionId;

                    SmbCeReferenceSessionEntry(pSessionEntry);
                    SmbCeAddSessionEntry(pServerEntry,pSessionEntry);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            if (Status != STATUS_SUCCESS) {
                if (pUserName != NULL) {
                    RxFreePool(pUserName);
                }

                if (pPassword != NULL) {
                    RxFreePool(pPassword);
                }

                if (pUserDomainName != NULL) {
                    RxFreePool(pUserDomainName);
                }
            }
        } else {
            if (Status == STATUS_SUCCESS) {
                SmbCeLog(("CachedSessEntry %lx\n",pSessionEntry));
            }
        }

        if (Status == STATUS_SUCCESS) {
            *pSessionEntryPtr = pSessionEntry;
        }

        SmbCeDereferenceServerEntry(pServerEntry);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

VOID
SmbCeCompleteSessionEntryInitialization(
    PVOID    pContext,
    NTSTATUS Status)
/*++

Routine Description:

    This routine is invoked in the context of a worker thread to finalize the
    construction of a session entry

Arguments:

    pContext  - the session entry to be activated

Notes:

    PRE_CONDITION: The session entry must have been referenced to ensure that
    even it has been finalized it will not be deleted.

--*/
{
    PSMBCEDB_SESSION_ENTRY pSessionEntry = (PSMBCEDB_SESSION_ENTRY)pContext;
    PSMBCE_SESSION         pSession = &pSessionEntry->Session;
    PSMBCEDB_SERVER_ENTRY  pServerEntry = pSessionEntry->pServerEntry;
    PSMBCEDB_REQUEST_ENTRY pRequestEntry;
    SMBCEDB_REQUESTS       Requests;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("Session Entry Finalization\n"));
    ASSERT(pSessionEntry->Header.ObjectType == SMBCEDB_OT_SESSION);

    // Acquire the SMBCE resource
    SmbCeAcquireResource();

    // reset the constructor exchange field since the construction is complete
    pSessionEntry->pExchange = NULL;

    // Create a temporary copy of the list that can be traversed after releasing the
    // resource.
    SmbCeTransferRequests(&Requests,&pSessionEntry->Requests);

    if (Status == STATUS_SUCCESS) {
        SmbCeUpdateSessionEntryState(
            pSessionEntry,
            SMBCEDB_ACTIVE);

        if ((pSession->pPassword != NULL || pSession->pUserName != NULL) &&
            !BooleanFlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_NULL_CREDENTIALS)) {
            if (pSessionEntry->DefaultSessionLink.Flink == NULL ) {
                ASSERT( pSessionEntry->DefaultSessionLink.Blink == NULL );
                InsertHeadList(&pServerEntry->Sessions.DefaultSessionList,
                               &pSessionEntry->DefaultSessionLink );
            }
        }
    } else {
        Status = STATUS_BAD_LOGON_SESSION_STATE;
        SmbCeUpdateSessionEntryState(
            pSessionEntry,
            SMBCEDB_INVALID);
    }

    // Release the resource for the session entry
    SmbCeReleaseResource();

    if (!IsListEmpty(&Requests.ListHead)) {
        // Iterate over the list of pending requests and resume all of them
        SmbCeResumeOutstandingRequests(&Requests,Status);
    }

    SmbCeDereferenceSessionEntry(pSessionEntry);
}

NTSTATUS
SmbCeGetUserNameAndDomainName(
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PUNICODE_STRING         pUserName,
    PUNICODE_STRING         pUserDomainName)
/*++

Routine Description:

    This routine returns the user name and domain name associated with a session
    in a caller allocated buffer.

Arguments:

    pSessionEntry - the session entry to be dereferenced

    pUserName     - the User name

    pUserDomainName - the user domain name

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status;

    PSMBCE_SESSION  pSession;
    PUNICODE_STRING pSessionUserName,pSessionDomainName;

    PSecurityUserData   pSecurityData;

    PAGED_CODE();

    ASSERT(pSessionEntry != NULL);
    pSession = &pSessionEntry->Session;

    if ((pUserName == NULL) ||
        (pUserDomainName == NULL) ||
        (pUserName->MaximumLength < (UNLEN * sizeof(WCHAR))) ||
        (pUserDomainName->MaximumLength < (DNLEN * sizeof(WCHAR)))) {
        return STATUS_INVALID_PARAMETER;
    }

    Status          = STATUS_SUCCESS;
    pSecurityData   = NULL;

    pSessionUserName   = pSession->pUserName;
    pSessionDomainName = pSession->pUserDomainName;

    try {
        if (pSessionUserName == NULL || 
            pSessionDomainName == NULL) {
            Status = GetSecurityUserInfo(
                         &pSession->LogonId,
                         UNDERSTANDS_LONG_NAMES,
                         &pSecurityData);
            
            if (NT_SUCCESS(Status)) {
                if (pSessionUserName == NULL) {
                    pSessionUserName   = &(pSecurityData->UserName);
                }

                if (pSessionDomainName == NULL) {
                    pSessionDomainName = &(pSecurityData->LogonDomainName);
                }
            }
        }

        if (NT_SUCCESS(Status)) {
            ASSERT(pSessionUserName->Length <= pUserName->MaximumLength);

            ASSERT(pSessionDomainName->Length <= pUserDomainName->MaximumLength);

            pUserName->Length = pSessionUserName->Length;
            RtlCopyMemory(
                pUserName->Buffer,
                pSessionUserName->Buffer,
                pUserName->Length);

            pUserDomainName->Length = pSessionDomainName->Length;
            if (pUserDomainName->Length > 0) {
                RtlCopyMemory(
                    pUserDomainName->Buffer,
                    pSessionDomainName->Buffer,
                    pUserDomainName->Length);
            }
        }
    } finally {
        if (pSecurityData != NULL) {
            LsaFreeReturnBuffer(pSecurityData);
        }
    }

    return Status;
}

VOID
SmbCepDereferenceSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
/*++

Routine Description:

    This routine dereferences a session entry instance

Arguments:

    pSessionEntry - the session entry to be dereferenced

--*/
{
    if (pSessionEntry != NULL) {
        BOOLEAN fTearDownEntry;
        BOOLEAN fLogOffRequired;

        LONG    FinalRefCount;

        PSMBCEDB_SERVER_ENTRY pServerEntry;

        ASSERT((pSessionEntry->Header.ObjectType == SMBCEDB_OT_SESSION) &&
               (pSessionEntry->Header.SwizzleCount > 0));

        MRXSMB_PRINT_REF_COUNT(SESSION_ENTRY,pSessionEntry->Header.SwizzleCount);

        pServerEntry = pSessionEntry->pServerEntry;

        SmbCeAcquireResource();

        FinalRefCount = InterlockedDecrement(&pSessionEntry->Header.SwizzleCount);

        fTearDownEntry = (FinalRefCount == 0);

        if (fTearDownEntry) {
            // A logoff smb needs to be sent if the user id associated with
            // the session is not zero. Note that we cannot rely on the state
            // of the session to indicate this.

            SmbCeReferenceServerEntry(pServerEntry);

            if (pSessionEntry->Header.SwizzleCount == 0) {
                if (!FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {
                    SmbCeRemoveSessionEntry(pServerEntry,pSessionEntry);
                    
                    InterlockedDecrement(
                        &pServerEntry->Server.NumberOfActiveSessions);
                }

                SmbCeRemoveDefaultSessionEntry(pSessionEntry);

                if ((pSessionEntry->Session.UserId != (SMB_USER_ID)(SMBCE_SHARE_LEVEL_SERVER_USERID)) &&
                    (pSessionEntry->Session.UserId != 0) &&
                    !FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {
                    SmbCeReferenceServerEntry(pServerEntry);
                    SmbCeReferenceSessionEntry(pSessionEntry);
                    
                    fLogOffRequired = TRUE;
                } else {
                    fLogOffRequired = FALSE;
                    pSessionEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                }

                pSessionEntry->Session.Flags |= SMBCE_SESSION_FLAGS_LOGGED_OFF;
                fTearDownEntry = TRUE;
            } else {
                fTearDownEntry = FALSE;
            }

            SmbCeDereferenceServerEntry(pServerEntry);
        }

        SmbCeReleaseResource();

        if (fTearDownEntry) {
            if (fLogOffRequired) {
                SmbCeLogOff(pServerEntry,pSessionEntry);

                SmbCeDereferenceServerEntry(pServerEntry);
            } else {
                SmbCeTearDownSessionEntry(pSessionEntry);
            }
        }
    }
}


VOID
SmbCeTearDownSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
/*++

Routine Description:

    This routine tears down a session entry instance

Arguments:

    pSessionEntry - the session entry to be dereferenced

--*/
{
    PAGED_CODE();

    ASSERT((pSessionEntry->Header.SwizzleCount == 0) &&
           (pSessionEntry->Header.State == SMBCEDB_MARKED_FOR_DELETION));

    ASSERT(IsListEmpty(&pSessionEntry->SerializationList));

    SmbCeLog(("TearSessEntry %lx\n",pSessionEntry));

    if (pSessionEntry->Session.pUserName != NULL) {
        RxFreePool(pSessionEntry->Session.pUserName);
    }

    if (pSessionEntry->Session.pPassword != NULL) {
        RxFreePool(pSessionEntry->Session.pPassword);
    }

    if (pSessionEntry->Session.pUserDomainName != NULL) {
        RxFreePool(pSessionEntry->Session.pUserDomainName);
    }

    UninitializeSecurityContextsForSession(&pSessionEntry->Session);

    SmbMmFreeSessionEntry(pSessionEntry);
}

PSMBCEDB_NET_ROOT_ENTRY
SmbCeFindNetRootEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PUNICODE_STRING pServerShare
    )
{
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;

   ASSERT(SmbCeIsResourceOwned());

   pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);

    while (pNetRootEntry != NULL) {
        if (RtlCompareUnicodeString(
                pServerShare,
                &pNetRootEntry->Name,
                TRUE) == 0) {
            break;
        }

        pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);

    }
    
    return pNetRootEntry;
}

NTSTATUS
SmbCeFindOrConstructNetRootEntry(
    IN  PMRX_NET_ROOT pNetRoot,
    OUT PSMBCEDB_NET_ROOT_ENTRY *pNetRootEntryPtr)
/*++

Routine Description:

    This routine opens/creates a net root entry in the connection engine database

Arguments:

    pNetRoot -- the RDBSS net root instance

    pNetRootEntryPtr -- Initialized to the SMBCEDB_NET_ROOT_ENTRY instance if
                        successful

Return Value:

    STATUS_SUCCESS - the construction of the net root instance has been finalized

    Other Status codes correspond to error situations.

Notes:

    This routine assumes that the necesary concurreny control mechanism has already
    been taken.

    On Entry the connection engine resource must have been acquired exclusive and
    ownership remains invariant on exit.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY   pServerEntry   = NULL;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry  = NULL;

    SMB_USER_ID UserId = 0;

    ASSERT(SmbCeIsResourceOwned());

    *pNetRootEntryPtr = NULL;

    pServerEntry = SmbCeReferenceAssociatedServerEntry(pNetRoot->pSrvCall);

    if (pServerEntry != NULL) {
        // Check if any of the SMBCEDB_NET_ROOT_ENTRY associated with the server
        // can be used. An existing entry is reusable if the names match

        pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
        while (pNetRootEntry != NULL) {
            if (RtlCompareUnicodeString(
                    pNetRoot->pNetRootName,
                    &pNetRootEntry->Name,
                    TRUE) == 0) {
                SmbCeLog(("CachedNREntry %lx\n",pNetRootEntry));
                break;
            }

            pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
        }

        if (pNetRootEntry != NULL) {
            SmbCeReferenceNetRootEntry(pNetRootEntry);
        } else {
            pNetRootEntry = (PSMBCEDB_NET_ROOT_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_NETROOT);
            if (pNetRootEntry != NULL) {
                pNetRootEntry->Name.Buffer = RxAllocatePoolWithTag(
                                                 PagedPool,
                                                 pNetRoot->pNetRootName->Length,
                                                 MRXSMB_NETROOT_POOLTAG);

                if (pNetRootEntry->Name.Buffer != NULL) {
                    SmbCeLog(("NewNetREntry %lx\n",pNetRootEntry));

                    pNetRootEntry->Name.Length = pNetRoot->pNetRootName->Length;
                    pNetRootEntry->Name.MaximumLength = pNetRootEntry->Name.Length;
                    RtlCopyMemory(
                        pNetRootEntry->Name.Buffer,
                        pNetRoot->pNetRootName->Buffer,
                        pNetRootEntry->Name.Length);

                    pNetRootEntry->pServerEntry = pServerEntry;
                    pNetRootEntry->NetRoot.UserId = UserId;
                    pNetRootEntry->NetRoot.NetRootType   = pNetRoot->Type;
                    InitializeListHead(&pNetRootEntry->NetRoot.ClusterSizeSerializationQueue);

                    pNetRootEntry->Header.State = SMBCEDB_ACTIVE;

                    SmbCeReferenceNetRootEntry(pNetRootEntry);
                    SmbCeAddNetRootEntry(pServerEntry,pNetRootEntry);

                } else {
                    SmbMmFreeObject(pNetRootEntry);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (Status == STATUS_SUCCESS) {
            ASSERT(pNetRootEntry != NULL);
            *pNetRootEntryPtr = pNetRootEntry;
        }
        SmbCeDereferenceServerEntry(pServerEntry);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

VOID
SmbCepDereferenceNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    PVOID                   FileName,
    ULONG                   FileLine)
/*++

Routine Description:

    This routine dereferences a net root entry instance

Arguments:

    pNetRootEntry - the NEt Root entry to be dereferenced

--*/
{
    if (pNetRootEntry != NULL) {
        LONG    FinalRefCount;
        BOOLEAN fTearDownEntry;
        BOOLEAN fDisconnectRequired;

        ASSERT((pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT) &&
               (pNetRootEntry->Header.SwizzleCount > 0));

        MRXSMB_PRINT_REF_COUNT(NETROOT_ENTRY,pNetRootEntry->Header.SwizzleCount);

        SmbCeAcquireResource();

        FinalRefCount = InterlockedDecrement(&pNetRootEntry->Header.SwizzleCount);

        fTearDownEntry = (FinalRefCount == 0);

        if (fTearDownEntry) {

            if (pNetRootEntry->Header.SwizzleCount == 0) {
                PSMBCEDB_SERVER_ENTRY   pServerEntry  = pNetRootEntry->pServerEntry;
                PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;
                
                SmbCeRemoveNetRootEntryLite(pNetRootEntry->pServerEntry,pNetRootEntry);
                pNetRootEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                fTearDownEntry = TRUE;

                pVNetRootContext = SmbCeGetFirstVNetRootContext(&pServerEntry->VNetRootContexts);
                while (pVNetRootContext != NULL) {
                    ASSERT(pVNetRootContext->pNetRootEntry != pNetRootEntry);

                    pVNetRootContext = SmbCeGetNextVNetRootContext(
                                           &pServerEntry->VNetRootContexts,
                                           pVNetRootContext);
                }
            } else {
                fTearDownEntry = FALSE;
            }

        }

        SmbReferenceRecord(&pNetRootEntry->ReferenceRecord[0],FileName,FileLine);
        
        SmbCeReleaseResource();

        if (fTearDownEntry) {
            SmbCeTearDownNetRootEntry(pNetRootEntry);
        }
    }
}

VOID
SmbCeTearDownNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry)
/*++

Routine Description:

    This routine tears down a net root entry instance

Arguments:

    pNetRootEntry - the NEt Root entry to be dereferenced

--*/
{
    PAGED_CODE();

    ASSERT((pNetRootEntry->Header.SwizzleCount == 0) &&
           (pNetRootEntry->Header.State == SMBCEDB_MARKED_FOR_DELETION));

    SmbCeLog(("TearNetREntry %lx\n",pNetRootEntry));

    if (pNetRootEntry->Name.Buffer != NULL) {
        RxFreePool(pNetRootEntry->Name.Buffer);
        pNetRootEntry->Name.Buffer = NULL;
    }

    SmbMmFreeObject(pNetRootEntry);
}


NTSTATUS
SmbCeUpdateNetRoot(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    PMRX_NET_ROOT           pNetRoot)
/*++

Routine Description:

    This routine initializes the wrapper data structure corresponding to a
    given net root entry.

Arguments:

    pNetRootEntry - the server entry

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    PAGED_CODE();

    pNetRoot->Type = pNetRootEntry->NetRoot.NetRootType;

    switch (pNetRoot->Type) {
    case NET_ROOT_DISK:
        {
            pNetRoot->DeviceType = RxDeviceType(DISK);

            RxInitializeNetRootThrottlingParameters(
                &pNetRoot->DiskParameters.LockThrottlingParameters,
                MRxSmbConfiguration.LockIncrement,
                MRxSmbConfiguration.MaximumLock);
        }
        break;

    case NET_ROOT_PIPE:
        pNetRoot->DeviceType = RxDeviceType(NAMED_PIPE);
        break;
    case NET_ROOT_COMM:
        pNetRoot->DeviceType = RxDeviceType(SERIAL_PORT);
        break;
    case NET_ROOT_PRINT:
        pNetRoot->DeviceType = RxDeviceType(PRINTER);
        break;
    case NET_ROOT_MAILSLOT:
        pNetRoot->DeviceType = RxDeviceType(MAILSLOT);
        break;
    case NET_ROOT_WILD:
        break;
    default:
        ASSERT(!"Valid Net Root Type");
    }

    if (pNetRootEntry->NetRoot.DfsAware) {
        SetFlag(pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT);
    } else {
        ClearFlag(pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SmbCeProbeServers(
    PVOID    pContext)
/*++

Routine Description:

    This routine probes all the remote servers on which no activity has been
    detected in the recent past.

Notes:

    The current implementation of walking through the list of all servers to
    initiate echo processing will not scale very well for gateway servers. A
    different mechanism needs to be implemented.


--*/
{
    LIST_ENTRY              DiscardedServersList;
    PSMBCEDB_SERVER_ENTRY   pServerEntry;

    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext;
    PSMBCEDB_SERVER_ENTRY pPreviousServerEntry = NULL;

    pEchoProbeContext = (PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT)pContext;

    InitializeListHead(&DiscardedServersList);

    SmbCeAcquireSpinLock();
    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {
        BOOLEAN               TearDownTransport = FALSE;

        if ((SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER) &&
            ((pServerEntry->Header.State == SMBCEDB_ACTIVE) ||
             (pServerEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS))) {

            // The additional reference is required to keep this server entry
            // as a place marker in the list of server entries.
            // This will be released on resumption of the processinf further
            // down in this routine
            InterlockedIncrement(&pServerEntry->Header.SwizzleCount);
            SmbCeReleaseSpinLock();

            if (pPreviousServerEntry != NULL) {
                SmbCeDereferenceServerEntry(pPreviousServerEntry);
            }

            // For loop back servers we forego the expired exchange detection
            // mechanism. Since the I/O is directed to the same machine this
            // indicates a problem with the local system.

            if (!pServerEntry->Server.IsLoopBack) {
                TearDownTransport = SmbCeDetectExpiredExchanges(pServerEntry);
            }

            if (!TearDownTransport) {
                if ((pServerEntry->Server.SmbsReceivedSinceLastStrobe == 0) &&
                    (pServerEntry->pMidAtlas != NULL) &&
                    (pServerEntry->pMidAtlas->NumberOfMidsInUse > 0)) {
                    if (pServerEntry->Server.EchoProbeState == ECHO_PROBE_IDLE) {
                        NTSTATUS      Status;
                        LARGE_INTEGER CurrentTime,ExpiryTimeInTicks;

                        KeQueryTickCount( &CurrentTime );

                        ExpiryTimeInTicks.QuadPart = (1000 * 1000 * 10) / KeQueryTimeIncrement();

                        ExpiryTimeInTicks.QuadPart = MRxSmbConfiguration.SessionTimeoutInterval * ExpiryTimeInTicks.QuadPart;

                        pServerEntry->Server.EchoExpiryTime.QuadPart = CurrentTime.QuadPart +
                                                                ExpiryTimeInTicks.QuadPart;


                        InterlockedExchange(
                            &pServerEntry->Server.EchoProbeState,
                            ECHO_PROBE_AWAITING_RESPONSE);

                        Status = SmbCeSendEchoProbe(
                                     pServerEntry,
                                     pEchoProbeContext);

                        RxDbgTrace(0,Dbg,("Sending ECHO SMB %lx Status %lx\n",pServerEntry,Status));

                        TearDownTransport = ((Status != STATUS_SUCCESS) &&
                                             (Status != STATUS_PENDING));
                    } else if (pServerEntry->Server.EchoProbeState == ECHO_PROBE_AWAITING_RESPONSE) {
                        // Compare the current time with the time at which the echo probe
                        // was sent. If the interval is greater than the response time then
                        // it can be deemed that the echo response is not forthcoming and
                        // the tear down can be initiated.
                        LARGE_INTEGER CurrentTime;

                        KeQueryTickCount( &CurrentTime );

                        if ((pServerEntry->Server.EchoExpiryTime.QuadPart != 0) &&
                            (pServerEntry->Server.EchoExpiryTime.QuadPart < CurrentTime.QuadPart)) {

                            TearDownTransport = TRUE;
                        }
                    }

                    if (TearDownTransport) {
                        RxLog(("Echo Problem for srvr%lx \n",pServerEntry));
                    }
                } else {
                    InterlockedExchange(&pServerEntry->Server.SmbsReceivedSinceLastStrobe,0);
                }
            }

            if (TearDownTransport) {
                InterlockedIncrement(&MRxSmbStatistics.HungSessions);
                SmbCeTransportDisconnectIndicated(pServerEntry);
            }

            // reacquire the spin lock to traverse the list.
            SmbCeAcquireSpinLock();

            pPreviousServerEntry = pServerEntry;
            pServerEntry = SmbCeGetNextServerEntry(pPreviousServerEntry);
        } else {
            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }
    }

    SmbCeReleaseSpinLock();

    if (pPreviousServerEntry != NULL) {
        SmbCeDereferenceServerEntry(pPreviousServerEntry);
    }

    return STATUS_SUCCESS;
}

VOID
SmbCeTransportDisconnectIndicated(
    PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine invalidates a server entry on notification from the underlying transport

Arguments:

    pServerEntry - the server entry to be dereferenced

Notes:

    The server entry and the associated net roots and sessions are marked as invalid. A
    reconnect is facilitated on other requests as and when required. In addition all
    pending requests are resumed with the appropriate error indication.

--*/
{
    NTSTATUS Status;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    RxDbgTrace(0,
              Dbg,
              ("SmbCeDbTransportDisconnectIndicated for %lx -- Entry\n",pServerEntry));

    // Acquire the database resource (DPC Level)
    SmbCeAcquireSpinLock();

    // Increment the associated version count so as to invalidate all existing Fids
    InterlockedIncrement(&pServerEntry->Server.Version);

    pServerEntry->ServerStatus = STATUS_CONNECTION_DISCONNECTED;
    pServerEntry->Header.State = SMBCEDB_DESTRUCTION_IN_PROGRESS;

    // Mark all the associated sessions as being invalid.
    pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
    while (pSessionEntry != NULL) {
        if (pSessionEntry->Header.State == SMBCEDB_ACTIVE) {
            pSessionEntry->Header.State = SMBCEDB_INVALID;
        }

        pSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry);
    }

    // Mark all the associated net roots as being invalid
    pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
    while (pNetRootEntry != NULL) {
        if (pNetRootEntry->Header.State == SMBCEDB_ACTIVE) {
            pNetRootEntry->Header.State = SMBCEDB_INVALID;
        }

        pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
    }

    pVNetRootContext = SmbCeGetFirstVNetRootContext(&pServerEntry->VNetRootContexts);
    while (pVNetRootContext != NULL) {
        pVNetRootContext->Header.State = SMBCEDB_INVALID;
        ClearFlag(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

        pVNetRootContext->TreeId = 0;

        pVNetRootContext = SmbCeGetNextVNetRootContext(
                               &pServerEntry->VNetRootContexts,
                               pVNetRootContext);
    }

    SmbCeReferenceServerEntry(pServerEntry);

    // release the database resource (DPC Level)
    SmbCeReleaseSpinLock();

    Status = RxDispatchToWorkerThread(
                 MRxSmbDeviceObject,
                 CriticalWorkQueue,
                 SmbCeResumeAllOutstandingRequestsOnError,
                 pServerEntry);

    if (Status != STATUS_SUCCESS) {
        RxLog(("SmbCe Xport Disc.Error %lx\n", pServerEntry));
    }

    RxDbgTrace(0,
              Dbg,
              ("SmbCeTransportDisconnectIndicated -- Exit\n"));
}

VOID
SmbCeHandleTransportInvalidation(
    IN PSMBCE_TRANSPORT  pTransport)
/*++

Routine Description:

    This routine invalidates all servers using a particular transport. This is different from
    a disconnect indication in which one server is invalidated. In this case a transport is being
    removed/invalidated locally and all servers using that transport must be invalidated

Arguments:

    pTransport  - the transport being invalidated

--*/
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    SmbCeAcquireSpinLock();

    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {

        if ((pServerEntry->pTransport != NULL) &&
            (pServerEntry->pTransport->pTransport == pTransport)) {
            pServerEntry->Header.State = SMBCEDB_DESTRUCTION_IN_PROGRESS;

            // The invalidation needs to hold onto an extra reference to avoid
            // race conditions which could lead to premature destruction of
            // this server entry.
            SmbCeReferenceServerEntry(pServerEntry);
        }

        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
    }

    SmbCeReleaseSpinLock();

    SmbCeAcquireResource();

    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {
        PSMBCEDB_SERVER_ENTRY pPrevServerEntry;
        BOOLEAN               fDereferencePrevServerEntry = FALSE;

        if ((pServerEntry->pTransport != NULL) &&
            (pServerEntry->pTransport->pTransport == pTransport)) {
            SmbCeReleaseResource();

            SmbCeTransportDisconnectIndicated(pServerEntry);

            SmbCeReferenceServerEntry(pServerEntry);

            // the reference count of Server Entry will be taken away while the transport
            // is torn down, which prevents the server tranports being torn down again at
            // time the server entry being freed.
            SmbCeUninitializeServerTransport(pServerEntry,
                                             SmbCeCompleteUninitializeServerTransport,
                                             pServerEntry);

            SmbCeAcquireResource();

            if (pServerEntry->PreferredTransport != NULL) {
                SmbCeDereferenceTransport(pServerEntry->PreferredTransport);
                pServerEntry->PreferredTransport = NULL;
            }

            fDereferencePrevServerEntry = TRUE;
        }

        pPrevServerEntry = pServerEntry;
        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);

        if (fDereferencePrevServerEntry) {
            SmbCeDereferenceServerEntry(pPrevServerEntry);
        }
    }

    SmbCeReleaseResource();
}

VOID
SmbCeResumeOutstandingRequests(
    PSMBCEDB_REQUESTS pRequests,
    NTSTATUS          RequestStatus)
/*++

Routine Description:

    This routine resumes the outstanding requests with the appropriate status

Arguments:

    pRequests - the list of requests

    RequestStatus - the resumption status ..

Notes:

    As a side effect the list of requests is torn down.

--*/
{
    NTSTATUS               Status;
    PSMBCEDB_REQUEST_ENTRY pRequestEntry;

    // Resume all the outstanding reconnect requests that were held up because an earlier
    // reconnect request was under way.
    // Iterate over the list of pending requests and resume all of them

    pRequestEntry = SmbCeGetFirstRequestEntry(pRequests);
    while (pRequestEntry != NULL) {
        PSMB_EXCHANGE pExchange = pRequestEntry->ReconnectRequest.pExchange;

        RxDbgTrace(0, Dbg, ("Resuming outstanding reconnect request exchange %lx \n",pExchange));

        pExchange->Status = RequestStatus;

        SmbCeDecrementPendingLocalOperations(pExchange);

        // Resume the exchange.
        if (pRequestEntry->Request.pExchange->pSmbCeSynchronizationEvent == NULL) {
            if (RequestStatus == STATUS_SUCCESS) {
                Status = SmbCeResumeExchange(pExchange);
            } else {
                // Invoke the error handler
                RxDbgTrace( 0, Dbg, ("Resuming exchange%lx with error\n",pRequestEntry->Request.pExchange));
                SmbCeFinalizeExchange(pExchange);
            }
        } else {
            KeSetEvent(
                pRequestEntry->Request.pExchange->pSmbCeSynchronizationEvent,
                0,
                FALSE);
        }

        // Delete the request entry
        SmbCeRemoveRequestEntryLite(pRequests,pRequestEntry);

        // Tear down the continuation entry
        SmbCeTearDownRequestEntry(pRequestEntry);

        // Skip to the next one.
        pRequestEntry = SmbCeGetFirstRequestEntry(pRequests);
    }
}

VOID
SmbCeResumeAllOutstandingRequestsOnError(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine handles the resumption of all outstanding requests on an error

Arguments:

    pServerEntry  - the Server entry which is being classified as disconnected
Notes:

    This routine requires the caller to have obtained a reference on the corresponding
    server entry. This is required because invocation of this routine can be posted
    which implies that a reference is required to avoid premature destruction of
    the associated server entry.

--*/
{
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    SMBCEDB_REQUESTS       Requests;
    SMBCEDB_REQUESTS       MidRequests;

    PSMBCEDB_REQUEST_ENTRY pRequestEntry;
    PMID_ATLAS             pMidAtlas;
    PSMB_EXCHANGE          pNegotiateExchange = NULL;
    LIST_ENTRY             ExpiredExchanges;

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Invoked \n");
    InitializeListHead(&ExpiredExchanges);
    InitializeListHead(&Requests.ListHead);

    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    if (pServerEntry->Header.State != SMBCEDB_DESTRUCTION_IN_PROGRESS) {
        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();

        SmbCeDereferenceServerEntry(pServerEntry);

        return;
    }

    if (pServerEntry->pNegotiateExchange != NULL) {
        if (pServerEntry->pNegotiateExchange->ReceivePendingOperations > 0) {
            pNegotiateExchange = SmbResetServerEntryNegotiateExchange(pServerEntry);
        }
    }

    // Create a temporary copy of the list that can be traversed after releasing the
    // resource.

    // Copy all the MID assignment requests pending.
    SmbCeTransferRequests(&MidRequests,&pServerEntry->MidAssignmentRequests);

    // Weed out all the reconnect requests so that they can be resumed
    pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
    while (pRequestEntry != NULL) {
        if (pRequestEntry->GenericRequest.Type == RECONNECT_REQUEST) {
            PSMBCEDB_REQUEST_ENTRY pTempRequestEntry;

            pTempRequestEntry = pRequestEntry;
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);

            SmbCeRemoveRequestEntryLite(&pServerEntry->OutstandingRequests,pTempRequestEntry);
            SmbCeAddRequestEntryLite(&Requests,pTempRequestEntry);
        } else {
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
        }
    }

    // The exchanges that have valid MID's assigned to them fall into two categories
    // Those that have a ReceivePendingOperation count of > 0 and those that have
    // a ReceievePendingOperation count of zero. For all the exchanges that belong
    // to the first category the finalize ( quiescent state ) routine must be invoked
    // since no receives will be forthcoming. For those exchanges that are in the
    // second category it is sufficient to mark the MID as being invalid. The
    // finalization( quiescent state ) routine is going to be called on completion
    // of other opertaions in this case.

    pMidAtlas = pServerEntry->pMidAtlas;
    if (pMidAtlas != NULL) {
        PVOID  pContext;
        USHORT MidsProcessed = 0;
        USHORT NumberOfMidsInUse;
        USHORT MaximumNumberOfMids;
        USHORT NextMid = 0;

        MaximumNumberOfMids = FsRtlGetMaximumNumberOfMids(pMidAtlas);
        NumberOfMidsInUse = FsRtlGetNumberOfMidsInUse(pMidAtlas);

        while ((NumberOfMidsInUse > MidsProcessed) &&
               (NextMid < MaximumNumberOfMids)) {
            pContext = FsRtlMapMidToContext(pMidAtlas,NextMid);

            if (pContext != NULL) {
                PSMB_EXCHANGE pExchange = (PSMB_EXCHANGE)pContext;

                pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_MID_VALID;

                pExchange->Status      = STATUS_CONNECTION_DISCONNECTED;
                pExchange->SmbStatus   = STATUS_CONNECTION_DISCONNECTED;

                if ((pExchange->ReceivePendingOperations > 0) &&
                    ((pExchange->LocalPendingOperations > 0) ||
                    (pExchange->CopyDataPendingOperations > 0) ||
                    (pExchange->SendCompletePendingOperations > 0))) {
                    // There are other pending operations. By merely setting the
                    // pending receive operations to zero, the finalization of
                    // the exchange is ensured.
                    pExchange->ReceivePendingOperations = 0;
                }

                if (pExchange->ReceivePendingOperations ==  0) {
                    FsRtlMapAndDissociateMidFromContext(pMidAtlas,NextMid,&pContext);
                }

                MidsProcessed++;
            }

            NextMid++;
        }
    }

    // Transfer all the active exchanges to expired exchanges. This will prevent these
    // exchanges from being considered for time outs again.
    if (!IsListEmpty(&pServerEntry->ActiveExchanges)) {
        pServerEntry->ExpiredExchanges.Blink->Flink = pServerEntry->ActiveExchanges.Flink;
        pServerEntry->ActiveExchanges.Flink->Blink = pServerEntry->ExpiredExchanges.Blink;

        pServerEntry->ExpiredExchanges.Blink = pServerEntry->ActiveExchanges.Blink;
        pServerEntry->ActiveExchanges.Blink->Flink = &pServerEntry->ExpiredExchanges;

        InitializeListHead(&pServerEntry->ActiveExchanges);
    }

    // Splice together all the requests that are awaiting the completion of the
    // session/netroot construction.

    pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
    while (pSessionEntry != NULL) {
        if (pSessionEntry->Header.State == SMBCEDB_ACTIVE) {
            pSessionEntry->Header.State = SMBCEDB_INVALID;
        }

        if (!IsListEmpty(&pSessionEntry->Requests.ListHead)) {
            Requests.ListHead.Blink->Flink = pSessionEntry->Requests.ListHead.Flink;
            pSessionEntry->Requests.ListHead.Flink->Blink = Requests.ListHead.Blink;

            Requests.ListHead.Blink = pSessionEntry->Requests.ListHead.Blink;
            pSessionEntry->Requests.ListHead.Blink->Flink = &Requests.ListHead;

            SmbCeInitializeRequests(&pSessionEntry->Requests);
        }

        pSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry);
    }

    pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
    while (pNetRootEntry != NULL) {
        if (pNetRootEntry->Header.State == SMBCEDB_ACTIVE) {
            pNetRootEntry->Header.State = SMBCEDB_INVALID;
        }

        if (!IsListEmpty(&pNetRootEntry->Requests.ListHead)) {
            Requests.ListHead.Blink->Flink = pNetRootEntry->Requests.ListHead.Flink;
            pNetRootEntry->Requests.ListHead.Flink->Blink = Requests.ListHead.Blink;

            Requests.ListHead.Blink = pNetRootEntry->Requests.ListHead.Blink;
            pNetRootEntry->Requests.ListHead.Blink->Flink = &Requests.ListHead;

            SmbCeInitializeRequests(&pNetRootEntry->Requests);
        }

        pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
    }

    pVNetRootContext = SmbCeGetFirstVNetRootContext(&pServerEntry->VNetRootContexts);
    while (pVNetRootContext != NULL) {
        pVNetRootContext->Header.State = SMBCEDB_INVALID;
        ClearFlag(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

        pVNetRootContext->TreeId = 0;

        if (!IsListEmpty(&pVNetRootContext->Requests.ListHead)) {
            Requests.ListHead.Blink->Flink = pVNetRootContext->Requests.ListHead.Flink;
            pVNetRootContext->Requests.ListHead.Flink->Blink = Requests.ListHead.Blink;

            Requests.ListHead.Blink = pVNetRootContext->Requests.ListHead.Blink;
            pVNetRootContext->Requests.ListHead.Blink->Flink = &Requests.ListHead;

            SmbCeInitializeRequests(&pVNetRootContext->Requests);
        }

        pVNetRootContext = SmbCeGetNextVNetRootContext(
                               &pServerEntry->VNetRootContexts,
                               pVNetRootContext);
    }

    pVNetRootContext = SmbCeGetFirstVNetRootContext(&MRxSmbScavengerServiceContext.VNetRootContexts);
    while (pVNetRootContext != NULL &&
           pVNetRootContext->pServerEntry == pServerEntry) {
        // prevent the VNetRootContexts on the scavenger list from being reused
        pVNetRootContext->Header.State = SMBCEDB_INVALID;
        ClearFlag(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

        pVNetRootContext->TreeId = 0;

        pVNetRootContext = SmbCeGetNextVNetRootContext(
                               &MRxSmbScavengerServiceContext.VNetRootContexts,
                               pVNetRootContext);
    }

    pServerEntry->pMidAtlas          = NULL;

    if (pServerEntry->NegotiateInProgress) {
        pServerEntry->Header.State = SMBCEDB_CONSTRUCTION_IN_PROGRESS;
    } else {
        pServerEntry->Header.State = SMBCEDB_INVALID;
    }

    SmbCeReleaseSpinLock();

    if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
        SmbCeInitiateDisconnect(pServerEntry);
    }

    SmbCeReleaseResource();

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Processing outsanding request \n");
    SmbCeResumeOutstandingRequests(&Requests,STATUS_CONNECTION_DISCONNECTED);

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Processing MID request \n");
    SmbCeResumeDiscardedMidAssignmentRequests(
        &MidRequests,
        STATUS_CONNECTION_DISCONNECTED);

    // Resume all the outstanding requests with the error indication
    // The FsRtlDestroyMidAtlas destroys the Mid atlas and at the same
    // time invokes the specified routine on each valid context.
    if (pMidAtlas != NULL) {
        FsRtlDestroyMidAtlas(pMidAtlas,SmbCeFinalizeExchangeOnDisconnect);
    }

    if (pNegotiateExchange != NULL) {
        pNegotiateExchange->Status    = STATUS_CONNECTION_DISCONNECTED;
        pNegotiateExchange->SmbStatus = STATUS_CONNECTION_DISCONNECTED;
        pNegotiateExchange->ReceivePendingOperations = 0;

        SmbCeDecrementPendingLocalOperationsAndFinalize(pNegotiateExchange);
    }

    // The remaining ECHO exchanges on the expired exchanges list in the server entry
    // needs to be finalized as well.

    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    if (!IsListEmpty(&pServerEntry->ExpiredExchanges)) {
        PLIST_ENTRY pListEntry;
        PSMB_EXCHANGE pExchange;

        pListEntry = pServerEntry->ExpiredExchanges.Flink;

        while (pListEntry != &pServerEntry->ExpiredExchanges) {
            PLIST_ENTRY pNextListEntry = pListEntry->Flink;

            pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);
            if ((pExchange->Mid == SMBCE_ECHO_PROBE_MID) &&
                !FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED) &&
                ((pExchange->ReceivePendingOperations > 0) ||
                 (pExchange->LocalPendingOperations > 0) ||
                 (pExchange->CopyDataPendingOperations > 0) ||
                 (pExchange->SendCompletePendingOperations > 0))) {
                RemoveEntryList(&pExchange->ExchangeList);
                InsertTailList(&ExpiredExchanges,&pExchange->ExchangeList);
                InterlockedIncrement(&pExchange->LocalPendingOperations);
            }

            pListEntry = pNextListEntry;
        }
    }

    SmbCeReleaseSpinLock();
    SmbCeReleaseResource();

    while (!IsListEmpty(&ExpiredExchanges)) {
        PLIST_ENTRY   pListEntry;
        PSMB_EXCHANGE pExchange;

        pListEntry = ExpiredExchanges.Flink;
        RemoveHeadList(&ExpiredExchanges);

        pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);
        InitializeListHead(&pExchange->ExchangeList);

        RxLog(("Finalizing scavenged exchange %lx Type %ld\n",pExchange,pExchange->Type));
        pExchange->Status      = STATUS_CONNECTION_DISCONNECTED;
        pExchange->SmbStatus   = STATUS_CONNECTION_DISCONNECTED;
        pExchange->ReceivePendingOperations = 0;

        SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);
    }

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Exit \n");
    SmbCeDereferenceServerEntry(pServerEntry);
}

VOID
SmbCeFinalizeAllExchangesForNetRoot(
    PMRX_NET_ROOT pNetRoot)
/*++

Routine Description:

    This routine handles the resumption of all outstanding requests on a forced
    finalization of a connection

Arguments:

    pNetRoot - the NetRoot which is being fianlized forcibly

Notes:

--*/
{
    PMRX_SRV_CALL         pSrvCall;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    SMBCEDB_REQUESTS       Requests;
    LIST_ENTRY             ExpiredExchanges;

    PSMB_EXCHANGE pExchange;
    PSMBCEDB_REQUEST_ENTRY pRequestEntry;
    PLIST_ENTRY            pListEntry;

    pSrvCall = pNetRoot->pSrvCall;

    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    InitializeListHead(&Requests.ListHead);
    InitializeListHead(&ExpiredExchanges);

    SmbCeAcquireSpinLock();

    // Walk through the list of active exchanges, and the pending requests to
    // weed out the exchanges for the given VNET_ROOT.

    pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
    while (pRequestEntry != NULL) {
        pExchange = pRequestEntry->GenericRequest.pExchange;

        if ((pRequestEntry->GenericRequest.Type == RECONNECT_REQUEST) &&
            (pExchange->SmbCeContext.pVNetRoot != NULL) &&
            (pExchange->SmbCeContext.pVNetRoot->pNetRoot == pNetRoot)) {
            PSMBCEDB_REQUEST_ENTRY pTempRequestEntry;

            pTempRequestEntry = pRequestEntry;
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);

            SmbCeRemoveRequestEntryLite(&pServerEntry->OutstandingRequests,pTempRequestEntry);
            SmbCeAddRequestEntryLite(&Requests,pTempRequestEntry);
        } else {
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
        }
    }

    pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->MidAssignmentRequests);
    while (pRequestEntry != NULL) {
        pExchange = pRequestEntry->GenericRequest.pExchange;

        ASSERT(pRequestEntry->GenericRequest.Type == ACQUIRE_MID_REQUEST);

        if ((pRequestEntry->GenericRequest.Type == ACQUIRE_MID_REQUEST) &&
            (pExchange->SmbCeContext.pVNetRoot != NULL) &&
            (pExchange->SmbCeContext.pVNetRoot->pNetRoot == pNetRoot)) {

            PSMBCEDB_REQUEST_ENTRY pTempRequestEntry;

            pTempRequestEntry = pRequestEntry;
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->MidAssignmentRequests,pRequestEntry);

            SmbCeRemoveRequestEntryLite(&pServerEntry->MidAssignmentRequests,pTempRequestEntry);

            // Signal the waiter for resumption
            pTempRequestEntry->MidRequest.pResumptionContext->Status = STATUS_CONNECTION_DISCONNECTED;
            SmbCeResume(pTempRequestEntry->MidRequest.pResumptionContext);

            SmbCeTearDownRequestEntry(pTempRequestEntry);
        } else {
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->MidAssignmentRequests,pRequestEntry);
        }
    }

    pListEntry = pServerEntry->ActiveExchanges.Flink;

    while (pListEntry != &pServerEntry->ActiveExchanges) {
        PLIST_ENTRY pNextListEntry = pListEntry->Flink;

        pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);

        if ((pExchange->SmbCeContext.pVNetRoot != NULL) &&
            (pExchange->SmbCeContext.pVNetRoot->pNetRoot == pNetRoot)) {


            if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED)) {
                if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
                    NTSTATUS LocalStatus;

                    LocalStatus = SmbCepDiscardMidAssociatedWithExchange(
                                      pExchange);

                    ASSERT(LocalStatus == STATUS_SUCCESS);
                }

                if ((pExchange->ReceivePendingOperations > 0) ||
                    (pExchange->LocalPendingOperations > 0) ||
                    (pExchange->CopyDataPendingOperations > 0) ||
                    (pExchange->SendCompletePendingOperations > 0)) {

                    RemoveEntryList(&pExchange->ExchangeList);
                    InsertTailList(&ExpiredExchanges,&pExchange->ExchangeList);
                    InterlockedIncrement(&pExchange->LocalPendingOperations);
                }
            }
        }

        pListEntry = pNextListEntry;
    }

    SmbCeReleaseSpinLock();

    while (!IsListEmpty(&ExpiredExchanges)) {
        PLIST_ENTRY   pListEntry;
        PSMB_EXCHANGE pExchange;

        pListEntry = ExpiredExchanges.Flink;
        RemoveHeadList(&ExpiredExchanges);

        pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);
        InitializeListHead(&pExchange->ExchangeList);

        RxLog(("Finalizing scavenged exchange %lx Type %ld\n",pExchange,pExchange->Type));

        pExchange->Status      = STATUS_CONNECTION_DISCONNECTED;
        pExchange->SmbStatus   = STATUS_CONNECTION_DISCONNECTED;
        pExchange->ReceivePendingOperations = 0;
        SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);
    }

    SmbCeResumeOutstandingRequests(&Requests,STATUS_CONNECTION_DISCONNECTED);
}

VOID
SmbCeTearDownRequestEntry(
    PSMBCEDB_REQUEST_ENTRY  pRequestEntry)
/*++

Routine Description:

    This routine tears down a request entry

Arguments:

    pRequestEntry - the request entry to be torn down

Notes:

--*/
{
    SmbMmFreeObject(pRequestEntry);
}

//
// The connection engine database initializtion/tear down routines
//

extern NTSTATUS
SmbMmInit();

extern VOID
SmbMmTearDown();

KIRQL           s_SmbCeDbSpinLockSavedIrql;
KSPIN_LOCK      s_SmbCeDbSpinLock;
ERESOURCE       s_SmbCeDbResource;
SMBCEDB_SERVERS s_DbServers;
BOOLEAN         s_SmbCeDbSpinLockAcquired;

NTSTATUS
SmbCeDbInit()
/*++

Routine Description:

    This routine initializes the SMBCe database

Notes:

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    // Initialize the lists associated with various database entities
    InitializeListHead(&s_DbServers.ListHead);

    // Initialize the resource associated with the database.
    KeInitializeSpinLock(&s_SmbCeDbSpinLock );
    //ExInitializeResource(&s_SmbCeDbResource);
    s_SmbCeDbSpinLockAcquired = FALSE;

    MRxSmbInitializeSmbCe();

    // Initialize the memory management data structures.
    Status = SmbMmInit();

    return Status;
}

VOID
SmbCeDbTearDown()
/*++

Routine Description:

    This routine tears down the SMB connection engine database

Notes:

--*/
{
    // Walk through the list of servers and tear them down.
    PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
    KEVENT ServerEntryTearDownEvent;
    BOOLEAN NeedToWait = FALSE;
    
    KeInitializeEvent(
        &ServerEntryTearDownEvent,
        NotificationEvent,
        FALSE);

    SmbCeStartStopContext.pServerEntryTearDownEvent = &ServerEntryTearDownEvent;
    
    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    pServerEntry = SmbCeGetFirstServerEntry();

    if (pServerEntry != NULL) {
        SmbCeReferenceServerEntry(pServerEntry);
        NeedToWait = TRUE;
    }

    while (pServerEntry != NULL) {
        PSMBCEDB_SERVER_ENTRY pTempServerEntry;
        
        pTempServerEntry = pServerEntry;
        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        
        if (pServerEntry != NULL) {
            SmbCeReferenceServerEntry(pServerEntry);
        }

        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();

        pTempServerEntry->Header.State = SMBCEDB_DESTRUCTION_IN_PROGRESS;
        pTempServerEntry->ServerStatus = STATUS_REDIRECTOR_PAUSED;
        SmbCeResumeAllOutstandingRequestsOnError(pTempServerEntry);

        SmbCeAcquireResource();
        SmbCeAcquireSpinLock();
    }

    SmbCeReleaseSpinLock();
    SmbCeReleaseResource();

    MRxSmbTearDownSmbCe();
    
    if (NeedToWait) {
        KeWaitForSingleObject(
            &ServerEntryTearDownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    }

    // Tear down the connection engine memory management data structures.
    SmbMmTearDown();
}

NTSTATUS
FindServerEntryFromCompleteUNCPath(
    USHORT  *lpuServerShareName,
    PSMBCEDB_SERVER_ENTRY *ppServerEntry
)
/*++

Routine Description:

    Given a UNC path of the form \\server\share, this routine looks up the redir
    in-memory data structures to locate such s SMBCEDB_SERVER_ENTRY for the server

Arguments:

    lpuServerShareName  \\server\share

    ppServerEntry      Contains the server entry if successful

Notes:

    The server entry is refcounted, hence the caller must dereference it after use by
    calling SmbCeDereferenceServerEntry

--*/
{

    UNICODE_STRING unistrServerName;
    USHORT  *lpuT = lpuServerShareName;
    DWORD   dwlenServerShare, dwlenServer=0;

    if ((*lpuT++ != (USHORT)'\\') || (*lpuT++ != (USHORT)'\\'))
    {
        return STATUS_INVALID_PARAMETER;
    }


    for (dwlenServerShare = 1; *lpuT; lpuT++, dwlenServerShare++)
    {
        if (*lpuT == (USHORT)'\\')
        {
            if (dwlenServer)
            {
                break;
            }
            else
            {
                dwlenServer = dwlenServerShare; // length of the \server part
            }
        }
    }

    unistrServerName.Length = unistrServerName.MaximumLength = (USHORT)(dwlenServer * sizeof(USHORT));
    unistrServerName.Buffer = lpuServerShareName+1;

    SmbCeAcquireResource();

    *ppServerEntry = SmbCeFindServerEntry(&unistrServerName, SMBCEDB_FILE_SERVER);

    SmbCeReleaseResource();

    if (*ppServerEntry)
    {
        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
FindNetRootEntryFromCompleteUNCPath(
    USHORT  *lpuServerShareName,
    PSMBCEDB_NET_ROOT_ENTRY *ppNetRootEntry
)
/*++

Routine Description:

    Given a UNC path of the form \\server\share, this routine looks up the redir
    in-memory data structures to locate such a NETROOT

Arguments:

    lpuServerShareName  \\server\share

    ppNetRootEntry      Contains the netroot entry if successful.

Notes:

    The netroot entry is refcounted, hence the caller must dereference it after use by
    calling SmbCeDereferenceNetRootEntry

--*/
{

    PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;
    UNICODE_STRING unistrServerName, unistrServerShare;
    USHORT  *lpuT = lpuServerShareName, *lpuDfsShare=NULL, *lpuSav;
    DWORD   dwlenServerShare, dwlenServer=0;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    if ((*lpuT++ != (USHORT)'\\') || (*lpuT++ != (USHORT)'\\'))
    {
        return STATUS_INVALID_PARAMETER;
    }

    for (dwlenServerShare = 1; *lpuT; lpuT++, dwlenServerShare++)
    {
        if (*lpuT == (USHORT)'\\')
        {
            if (dwlenServer)
            {
                break;
            }
            else
            {
                dwlenServer = dwlenServerShare; // length of the \server part
            }
        }
    }

    ASSERT((dwlenServerShare>dwlenServer));

    unistrServerName.Length = unistrServerName.MaximumLength = (USHORT)(dwlenServer * sizeof(USHORT));
    unistrServerName.Buffer = lpuServerShareName+1;

    unistrServerShare.Length = unistrServerShare.MaximumLength =  (USHORT)(dwlenServerShare * sizeof(USHORT));
    unistrServerShare.Buffer = lpuServerShareName+1;

    SmbCeAcquireResource();

    // lookup in standard places

    pServerEntry = SmbCeFindServerEntry(&unistrServerName, SMBCEDB_FILE_SERVER);
    if (pServerEntry)
    {
        pNetRootEntry = SmbCeFindNetRootEntry(pServerEntry, &unistrServerShare);
        SmbCeDereferenceServerEntry(pServerEntry);

        if (pNetRootEntry)
        {
            goto bailout;            
        }
    }

    // now look to see if a DFS alternate has this share

    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {

        DWORD   dwAllocationSize = 0;

        if ((RtlCompareUnicodeString(
                    &unistrServerName,
                    &pServerEntry->DfsRootName,
                    TRUE) == 0)) {

            dwAllocationSize =  pServerEntry->Name.MaximumLength+
                                (dwlenServerShare-dwlenServer+2) * sizeof(USHORT);
                               
            lpuDfsShare =  RxAllocatePoolWithTag(
                                NonPagedPool,
                                dwAllocationSize,
                                MRXSMB_SESSION_POOLTAG);
            if (!lpuDfsShare)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto bailout;
            }

            ASSERT(dwAllocationSize > pServerEntry->Name.MaximumLength);

            unistrServerShare.Length = (USHORT)(pServerEntry->Name.Length + (dwlenServerShare-dwlenServer) * sizeof(USHORT));
            unistrServerShare.MaximumLength = (USHORT)(pServerEntry->Name.MaximumLength+
                                                      (dwlenServerShare-dwlenServer+2) * sizeof(USHORT));

            memcpy(lpuDfsShare, pServerEntry->Name.Buffer, pServerEntry->Name.Length);
            memcpy(&lpuDfsShare[pServerEntry->Name.Length/sizeof(USHORT)], 
                   &(unistrServerShare.Buffer[dwlenServer]),
                    (dwlenServerShare-dwlenServer) * sizeof(USHORT));

            lpuSav = unistrServerShare.Buffer;
            unistrServerShare.Buffer = lpuDfsShare;

            pNetRootEntry = SmbCeFindNetRootEntry(pServerEntry, &unistrServerShare);

            unistrServerShare.Buffer = lpuSav;

            RxFreePool(lpuDfsShare);

            // stop if we found it
            if (pNetRootEntry)
            {
                break;                
            }
        } 
        
        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
    }



bailout:
    if (pNetRootEntry)
    {
        SmbCeReferenceNetRootEntry(pNetRootEntry);
        *ppNetRootEntry = pNetRootEntry;
        Status = STATUS_SUCCESS;
    }

    SmbCeReleaseResource();

    return Status;
}


PSMBCEDB_SESSION_ENTRY
SmbCeGetDefaultSessionEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    ULONG SessionId,
    PLUID pLogonId
    )
/*++

Routine Description:

    This routine returns the session entry from the default sessions list.

Arguments:

    pServerEntry - Server entry

    SessionId    - Hydra session Id.

    pLogonId     - the logon id.

Notes:

    This is called with the SmbCe spinlock held.

--*/
{
    PLIST_ENTRY pListEntry;
    PSMBCEDB_SESSION_ENTRY pSession;
    PSMBCEDB_SESSION_ENTRY pReturnSession = NULL;

    ASSERT( pServerEntry != NULL );

    pListEntry = pServerEntry->Sessions.DefaultSessionList.Flink;

    while( pListEntry != &pServerEntry->Sessions.DefaultSessionList ) {

        pSession = CONTAINING_RECORD( pListEntry, SMBCEDB_SESSION_ENTRY, DefaultSessionLink );

        if( pSession->Session.SessionId == SessionId ) {
            if (!RtlEqualLuid(
                    &pSession->Session.LogonId,
                    pLogonId)) {
                pReturnSession = pSession;
                break;
            }
        }

        pListEntry = pListEntry->Flink;
    }

    return( pReturnSession );
}

VOID
SmbCeRemoveDefaultSessionEntry(
    PSMBCEDB_SESSION_ENTRY pDefaultSessionEntry
    )
/*++

Routine Description:

    This routine removes the session entry from the default sessions list.

Arguments:

    pServerEntry - Server entry

    SessionId    - Hydra session Id.

    pLogonId     - the logon id.

Notes:

    This is called with the SmbCe spinlock held.

--*/
{
    if( pDefaultSessionEntry &&
        pDefaultSessionEntry->DefaultSessionLink.Flink ) {

        RemoveEntryList( &pDefaultSessionEntry->DefaultSessionLink );

        pDefaultSessionEntry->DefaultSessionLink.Flink = NULL;
        pDefaultSessionEntry->DefaultSessionLink.Blink = NULL;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbcedb.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    smbcedb.h

Abstract:

    This module defines all functions, along with implementations for inline functions
    related to accessing the SMB connection engine

Notes:

    The various data structures created by the mini rdr (Server Entries, Session Entries
    and Net Root Entries) are used in asynchronous operations. Hence a reference count
    mechanism is used to keep track of the creation/use/destruction of these data structures.

    The usage patterns for these data structures falls into one of two cases

      1) A prior reference exists and access is required

      2) A new reference need be created.

    These two scenarios are dealt with by two sets of access routines
      SmbCeGetAssociatedServerEntry,
      SmbCeGetAssociatedNetRootEntry
    and
      SmbCeReferenceAssociatedServerEntry,
      SmbCeReferenceAssociatedNetRootEntry.

    The first set of routines include the necessary asserts in a debug build to ensure that a
    reference does exist.

    The dereferencing mechanism is provided by the following routines
      SmbCeDereferenceServerEntry,
      SmbCeDereferenceSessionEntry,
      SmbCeDereferenceNetRootEntry.

    The dereferencing routines also ensure that the data structures are deleted if the reference
    count is zero.

    The construction of the various SMB mini redirector structures ( Server,Session and Net root entries )
    follow a two phase protocol since network traffic is involved. The first set of routines
    initiate the construction while the second set of routines complete the construction.

    These routines are
      SmbCeInitializeServerEntry,
      SmbCeCompleteServerEntryInitialization,
      SmbCeInitializeSessionEntry,
      SmbCeCompleteSessionEntryInitialization,
      SmbCeInitializeNetRootEntry,
    and SmbCeCompleteNetRootEntryInitialization.

    Each of the SMB mini redirector data structures  embodies a state diagram that consist of
    the following states

      SMBCEDB_ACTIVE,                    // the instance is in use
      SMBCEDB_INVALID,                   // the instance has been invalidated/disconnected.
      SMBCEDB_MARKED_FOR_DELETION,       // the instance has been marked for deletion.
      SMBCEDB_RECYCLE,                   // the instance is available for recycling
      SMBCEDB_START_CONSTRUCTION,        // Initiate construction.
      SMBCEDB_CONSTRUCTION_IN_PROGRESS,  // the instance construction is in progress
      SMBCEDB_DESTRUCTION_IN_PROGRESS    // the instance destruction is in progress

    A SMB MRX data structure instance begins its life in SMBCEDB_START_CONSTRUCTION state.
    When the construction is initiated the state transitions to SMBCEDB_CONSTRUCTION_IN_PROGRESS.

    On completion of the construction the state is either transitioned to SMBCEDB_ACTIVE if the
    construction was successful. If the construction was not successful the state transitions to
    SMBCEDB_MARKED_FOR_DELETION if scavenging is to be done or SMBCEDB_DESTRUCTION_IN_PROGRESS
    if the tear down has been initiated.

    An instance in the SMBCEDB_ACTIVE state transitions to SMBCEDB_INVALID when the transport/remote server
    information associated with it has been invalidated due to disconnects etc. This state is a
    cue for a reconnect attempt to be initiated.

    The SMBCEDB_RECYCLE state is not in use currently.

    All the state transitions are accomplished by the following set of routines which ensure that
    the appropriate concurrency control action is taken.

         SmbCeUpdateServerEntryState,
         SmbCeUpdateSessionEntryState,
    and  SmbCeUpdateNetRootEntryState.

    Since the Server,Session and NetRoot entries are often referenced together the following
    two routines provide a batching mechanism to minimize the concurrency control overhead.

      SmbCeReferenceAssociatedEntries,
      SmbCeDereferenceEntries

    In addition this file also contains helper functions to access certain fields of
    MRX_SRV_CALL,MRX_NET_ROOT and MRX_V_NET_ROOT which are intrepreted differently by the SMB
    mini redirector.

--*/

#ifndef _SMBCEDB_H_
#define _SMBCEDB_H_
#include <smbcedbp.h>    // To accomodate inline routines.

//
// All the routines below return the referenced object if successful. It is the caller's
// responsibility to dereference them subsequently.
//

PSMBCEDB_SERVER_ENTRY
SmbCeFindServerEntry(
    PUNICODE_STRING pServerName,
    SMBCEDB_SERVER_TYPE ServerType);

extern NTSTATUS
SmbCeFindOrConstructServerEntry(
    PUNICODE_STRING       pServerName,
    SMBCEDB_SERVER_TYPE   ServerType,
    PSMBCEDB_SERVER_ENTRY *pServerEntryPtr,
    PBOOLEAN              pNewServerEntry);

extern NTSTATUS
SmbCeInitializeServerEntry(
    IN     PMRX_SRV_CALL                 pSrvCall,
    IN OUT PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext,
    IN     BOOLEAN                       DeferNetworkInitialization);

extern NTSTATUS
SmbCeFindOrConstructSessionEntry(
    IN PMRX_V_NET_ROOT pVirtualNetRoot,
    OUT PSMBCEDB_SESSION_ENTRY *pSessionEntryPtr);

extern NTSTATUS
SmbCeFindOrConstructNetRootEntry(
    IN PMRX_NET_ROOT  pNetRoot,
    OUT PSMBCEDB_NET_ROOT_ENTRY *pNetRootEntryPtr);

extern NTSTATUS
SmbCeFindOrConstructVNetRootContext(
    IN OUT PMRX_V_NET_ROOT pVNetRoot,
    IN     BOOLEAN         fDeferNetworkInitialization);

//
// The finalization routines are invoked in the context of a worker thread to finalize
// the construction of an entry as well as resume other entries waiting for it.
//

extern VOID
SmbCeCompleteServerEntryInitialization(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    NTSTATUS              Status);

extern VOID
SmbCeCompleteSessionEntryInitialization(
    PVOID    pSessionEntry,
    NTSTATUS Status);

extern VOID
SmbCeCompleteVNetRootContextInitialization(
    PVOID  pVNetRootContextEntry);

extern VOID
SmbReferenceRecord(
    PREFERENCE_RECORD pReferenceRecord,
    PVOID FileName,
    ULONG FileLine);

//
// Routines for referencing/dereferencing SMB Mini redirector information associated with
// the wrapper data structures.
//

INLINE PSMBCEDB_SERVER_ENTRY
SmbCeGetAssociatedServerEntry(
    PMRX_SRV_CALL pSrvCall)
{
   ASSERT(pSrvCall->Context != NULL);
   return (PSMBCEDB_SERVER_ENTRY)(pSrvCall->Context);
}

INLINE PSMBCE_V_NET_ROOT_CONTEXT
SmbCeGetAssociatedVNetRootContext(
    PMRX_V_NET_ROOT pVNetRoot)
{
   ASSERT(pVNetRoot != NULL);
   return (PSMBCE_V_NET_ROOT_CONTEXT)(pVNetRoot->Context);
}

INLINE PSMBCEDB_NET_ROOT_ENTRY
SmbCeGetAssociatedNetRootEntry(
    PMRX_NET_ROOT pNetRoot)
{
   ASSERT(pNetRoot->Context != NULL);
   return (PSMBCEDB_NET_ROOT_ENTRY)(pNetRoot->Context);
}

//
// All the macros for referencing and dereferencing begin with a prefix SmbCep...
// The p stands for a private version which is used for implementing reference tracking.
// By selectively turning on the desired flag it is possible to track every instance
// of a given type as the reference count is modified.
//

#define MRXSMB_REF_TRACE_SERVER_ENTRY     (0x00000001)
#define MRXSMB_REF_TRACE_NETROOT_ENTRY    (0x00000002)
#define MRXSMB_REF_TRACE_SESSION_ENTRY    (0x00000004)
#define MRXSMB_REF_TRACE_VNETROOT_CONTEXT (0x00000008)

extern ULONG MRxSmbReferenceTracingValue;

#define MRXSMB_REF_TRACING_ON(TraceMask)  (TraceMask & MRxSmbReferenceTracingValue)
#define MRXSMB_PRINT_REF_COUNT(TYPE,Count)                                \
        if (MRXSMB_REF_TRACING_ON( MRXSMB_REF_TRACE_ ## TYPE )) {              \
           DbgPrint("%ld\n",Count);                                \
        }

INLINE VOID
SmbCepReferenceServerEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
{
   ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);
   InterlockedIncrement(&pServerEntry->Header.SwizzleCount);
   MRXSMB_PRINT_REF_COUNT(SERVER_ENTRY,pServerEntry->Header.SwizzleCount)
}

INLINE VOID
SmbCepReferenceSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
{
   ASSERT(pSessionEntry->Header.ObjectType == SMBCEDB_OT_SESSION);
   InterlockedIncrement(&(pSessionEntry->Header.SwizzleCount));
   MRXSMB_PRINT_REF_COUNT(SESSION_ENTRY,pSessionEntry->Header.SwizzleCount)
}

INLINE VOID
SmbCepReferenceNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    PVOID                   FileName,
    ULONG                   FileLine)
{
   ASSERT(pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT);
   InterlockedIncrement(&(pNetRootEntry->Header.SwizzleCount));
   MRXSMB_PRINT_REF_COUNT(NETROOT_ENTRY,pNetRootEntry->Header.SwizzleCount);
   SmbReferenceRecord(&pNetRootEntry->ReferenceRecord[0],FileName,FileLine);
} 

INLINE VOID
SmbCepReferenceVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext)
{
   ASSERT(pVNetRootContext->Header.ObjectType == SMBCEDB_OT_VNETROOTCONTEXT);
   InterlockedIncrement(&(pVNetRootContext->Header.SwizzleCount));
   MRXSMB_PRINT_REF_COUNT(VNETROOT_CONTEXT,pVNetRootContext->Header.SwizzleCount)
}

INLINE PSMBCEDB_SERVER_ENTRY
SmbCeReferenceAssociatedServerEntry(
    PMRX_SRV_CALL pSrvCall)
{
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SERVER_ENTRY)) {
      DbgPrint("Reference SrvCall's(%lx) Server Entry %lx %s %ld ",
      pSrvCall,pSrvCall->Context,__FILE__,__LINE__);                                                          \
   }

   if ((pServerEntry = pSrvCall->Context) != NULL) {
      ASSERT(pServerEntry->Header.SwizzleCount > 0);
      SmbCepReferenceServerEntry(pServerEntry);
   }

   return pServerEntry;
}


INLINE PSMBCEDB_NET_ROOT_ENTRY
SmbCeReferenceAssociatedNetRootEntry(
    PMRX_NET_ROOT pNetRoot)
{
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_NETROOT_ENTRY)) {
      DbgPrint("Reference NetRoot's(%lx) Net Root Entry %lx %s %ld ",
      pNetRoot,pNetRoot->Context,__FILE__,__LINE__);                                                      \
   }

   if ((pNetRootEntry = pNetRoot->Context) != NULL) {
      ASSERT(pNetRootEntry->Header.SwizzleCount > 0);
      SmbCepReferenceNetRootEntry(pNetRootEntry,__FILE__,__LINE__);
   }

   return pNetRootEntry;
}

extern VOID
SmbCepDereferenceServerEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCepDereferenceSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern VOID
SmbCepDereferenceNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    PVOID                   FileName,
    ULONG                   FileLine);

extern VOID
SmbCepDereferenceVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext);

#define SmbCeReferenceServerEntry(pServerEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SERVER_ENTRY)) {                      \
      DbgPrint("Reference Server Entry(%lx) %s %ld ",pServerEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepReferenceServerEntry(pServerEntry)

#define SmbCeReferenceNetRootEntry(pNetRootEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_NETROOT_ENTRY)) {                      \
      DbgPrint("Reference NetRoot Entry(%lx) %s %ld ",pNetRootEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepReferenceNetRootEntry(pNetRootEntry,__FILE__,__LINE__)

#define SmbCeReferenceVNetRootContext(pVNetRootContext)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_VNETROOT_CONTEXT)) {                      \
      DbgPrint("Reference VNetRootContext(%lx) %s %ld ",pVNetRootContext,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepReferenceVNetRootContext(pVNetRootContext)


#define SmbCeReferenceSessionEntry(pSessionEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SESSION_ENTRY)) {                      \
      DbgPrint("Reference Session Entry(%lx) %s %ld ",pSessionEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepReferenceSessionEntry(pSessionEntry)

#define SmbCeDereferenceServerEntry(pServerEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SERVER_ENTRY)) {                      \
      DbgPrint("Dereference Server Entry(%lx) %s %ld ",pServerEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepDereferenceServerEntry(pServerEntry)

#define SmbCeDereferenceNetRootEntry(pNetRootEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_NETROOT_ENTRY)) {                      \
      DbgPrint("Dereference NetRoot Entry(%lx) %s %ld ",pNetRootEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepDereferenceNetRootEntry(pNetRootEntry,__FILE__,__LINE__)

#define SmbCeDereferenceSessionEntry(pSessionEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SESSION_ENTRY)) {                      \
      DbgPrint("Dereference Session Entry(%lx) %s %ld ",pSessionEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepDereferenceSessionEntry(pSessionEntry)

#define SmbCeDereferenceVNetRootContext(pVNetRootContext)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_VNETROOT_CONTEXT)) {                      \
      DbgPrint("Dereference VNetRootContext Entry(%lx) %s %ld ",pVNetRootContext,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepDereferenceVNetRootContext(pVNetRootContext)

INLINE VOID
SmbCeDereferenceEntries(
   PSMBCEDB_SERVER_ENTRY   pServerEntry,
   PSMBCEDB_SESSION_ENTRY  pSessionEntry,
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry)
{
   SmbCeDereferenceNetRootEntry(pNetRootEntry);
   SmbCeDereferenceSessionEntry(pSessionEntry);
   SmbCeDereferenceServerEntry(pServerEntry);
}

//
// Routines for updating the state of SMB MRX data structures
//

#define SmbCeUpdateServerEntryState(pServerEntry,NEWSTATE)   \
        InterlockedExchange(&pServerEntry->Header.State,(NEWSTATE))


#define SmbCeUpdateSessionEntryState(pSessionEntry,NEWSTATE)  \
        InterlockedExchange(&pSessionEntry->Header.State,(NEWSTATE))

#define SmbCeUpdateNetRootEntryState(pNetRootEntry,NEWSTATE)   \
        InterlockedExchange(&pNetRootEntry->Header.State,(NEWSTATE))

#define SmbCeUpdateVNetRootContextState(pVNetRootContext,NEWSTATE)   \
        InterlockedExchange(&pVNetRootContext->Header.State,(NEWSTATE))

//
// The RDBSS wrapper stores all the server names with a backslash prepended to
// them. This helps synthesize UNC names easily. In order to manipulate the
// Server name in the SMB protocol the \ needs to be stripped off.

INLINE VOID
SmbCeGetServerName(
    PMRX_SRV_CALL pSrvCall,
    PUNICODE_STRING pServerName)
{
   ASSERT(pSrvCall->pSrvCallName != NULL);
   pServerName->Buffer        = pSrvCall->pSrvCallName->Buffer + 1;
   pServerName->Length        = pSrvCall->pSrvCallName->Length - sizeof(WCHAR);
   pServerName->MaximumLength = pSrvCall->pSrvCallName->MaximumLength - sizeof(WCHAR);
}

INLINE VOID
SmbCeGetNetRootName(
    PMRX_NET_ROOT pNetRoot,
    PUNICODE_STRING pNetRootName)
{
   ASSERT(pNetRoot->pNetRootName != NULL);
   *pNetRootName  = *pNetRoot->pNetRootName;
}

extern NTSTATUS
SmbCeDestroyAssociatedVNetRootContext(
    PMRX_V_NET_ROOT pVNetRoot);

extern VOID
SmbCeTearDownVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext);

extern NTSTATUS
SmbCeGetUserNameAndDomainName(
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PUNICODE_STRING         pUserName,
    PUNICODE_STRING         pUserDomainName);

extern NTSTATUS
SmbCeUpdateSrvCall(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry);

extern NTSTATUS
SmbCeUpdateNetRoot(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    PMRX_NET_ROOT           pNetRoot);

extern NTSTATUS
SmbCeScavengeRelatedContexts(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCeResumeOutstandingRequests(
    IN OUT PSMBCEDB_REQUESTS pRequests,
    IN     NTSTATUS          Status);


// given \\server\share, this routine returns a refcounted serverentry
NTSTATUS
FindServerEntryFromCompleteUNCPath(
    USHORT  *lpuServerShareName,
    PSMBCEDB_SERVER_ENTRY *ppServerEntry);

// given \\server\share, this routine returns a refcounted netroot entry
NTSTATUS
FindNetRootEntryFromCompleteUNCPath(
    USHORT  *lpuServerShareName,
    PSMBCEDB_NET_ROOT_ENTRY *ppNetRootEntry);

#endif // _SMBCEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbea.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    smbea.h

Abstract:

    This module defines the prototypes for various functions which aid in the conversion
    from NT's EA format to the OS21.2 style and vice versa.

--*/

#ifndef _SMBEA_H_
#define _SMBEA_H_

VOID
MRxSmbNtGeaListToOs2 (
    IN PFILE_GET_EA_INFORMATION NtGetEaList,
    IN ULONG GeaListLength,
    IN PGEALIST GeaList
    );

PGEA
MRxSmbNtGetEaToOs2 (
    OUT PGEA Gea,
    IN PFILE_GET_EA_INFORMATION NtGetEa
    );

ULONG
MRxSmbNtFullEaSizeToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

VOID
MRxSmbNtFullListToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtEaList,
    IN PFEALIST FeaList
    );

PVOID
MRxSmbNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

#endif // _SMBEA_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbcemid.c ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    smbcemid.c

Abstract:

    This module defines the routines for manipulating MIDs associated with SMB's

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#endif

RXDT_DefineCategory(SMBCEMID);

#define Dbg        (DEBUG_TRACE_SMBCEMID)

INLINE
BOOLEAN
SmbCeVerifyMid(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PSMB_EXCHANGE         pExchange,
    SMB_MPX_ID            Mid)
{
    BOOLEAN MidIsValid = TRUE;
    USHORT  ServerVersion;

    ASSERT(pServerEntry != NULL);
    ASSERT(pServerEntry->pMidAtlas != NULL);

    if (pServerEntry->pMidAtlas->MaximumMidFieldWidth < 16) {
        USHORT MidMask;

        MidMask = 0x1 << pServerEntry->pMidAtlas->MaximumMidFieldWidth;
        MidMask = MidMask -1;

        MidIsValid = ((Mid & ~MidMask) == pExchange->MidCookie);
    }


    return MidIsValid;
}

INLINE
SMB_MPX_ID
SmbCeEncodeMid(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PSMB_EXCHANGE         pExchange,
    SMB_MPX_ID            Mid)
{
    USHORT VersionNumber;
    SMB_MPX_ID EncodedMid;

    EncodedMid = Mid;
    if (pServerEntry->pMidAtlas->MaximumMidFieldWidth < 16) {
        LONG MidCookie = InterlockedIncrement(&pServerEntry->Server.MidCounter);

        pExchange->MidCookie= ((USHORT)MidCookie <<
                               pServerEntry->pMidAtlas->MaximumMidFieldWidth);

        EncodedMid |= pExchange->MidCookie;
    }

    return EncodedMid;
}

INLINE
SMB_MPX_ID
SmbCeExtractMid(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    SMB_MPX_ID            EncodedMid)
{
    SMB_MPX_ID Mid = EncodedMid;

    if (pServerEntry->pMidAtlas->MaximumMidFieldWidth < 16) {
        USHORT MidMask;

        MidMask = 0x1 << pServerEntry->pMidAtlas->MaximumMidFieldWidth;
        MidMask = MidMask -1;

        Mid &= MidMask;
    }

    return Mid;
}

NTSTATUS
SmbCeAssociateExchangeWithMid(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange)
/*++

Routine Description:

   This routine associates an exchange with a MID

Arguments:

    pServerEntry - the servere entry

    pExchange    - the Exchange instance.

Return Value:

    STATUS_SUCCESS if successful, otherwise one of the following errors

Notes:

   If an asynchronous mechanism to acquire MID's is to be introduced this routine
   needs to be modified. Currently this routine does not return control till a
   MID is acquired or the exchange is aborted/terminated.

--*/
{
    NTSTATUS                 Status = STATUS_SUCCESS;
    PSMBCEDB_REQUEST_ENTRY   pRequestEntry;
    SMBCE_RESUMPTION_CONTEXT ResumptionContext;
    SMBCEDB_SERVER_TYPE      ServerType;
    BOOLEAN                  ResetServerEntry = FALSE;

    ServerType = SmbCeGetServerType(pServerEntry);

    // Acquire the resource
    SmbCeAcquireSpinLock();

    // Attempt to allocate a MID only for FILE Servers.

    if (pServerEntry->pMidAtlas != NULL) {
        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_INDEFINITE_DELAY_IN_RESPONSE) {
            // This exchange response can be arbitrarily delayed. Ensure that
            // all the available MIDS are not tied up in such exchanges.

            if ((pServerEntry->pMidAtlas->NumberOfMidsInUse + 1) >=
                pServerEntry->pMidAtlas->MaximumNumberOfMids) {
                Status = STATUS_TOO_MANY_COMMANDS;
            }
        }

        if (Status == STATUS_SUCCESS) {
            if (pServerEntry->pMidAtlas->NumberOfMidsDiscarded ==
                pServerEntry->pMidAtlas->MaximumNumberOfMids) {
                Status = STATUS_TOO_MANY_COMMANDS;
                ResetServerEntry = TRUE;
            }
        }

        if (Status == STATUS_SUCCESS) {
            SMB_MPX_ID Mid;

            Status = FsRtlAssociateContextWithMid(
                          pServerEntry->pMidAtlas,
                          pExchange,
                          &Mid);

            if (Status == STATUS_SUCCESS) {
                pExchange->Mid = SmbCeEncodeMid(pServerEntry,pExchange,Mid);
            }
        }
    } else {
        if (pServerEntry->Header.State == SMBCEDB_ACTIVE) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
    }

    if (Status == STATUS_UNSUCCESSFUL) {
        // Allocate a new entry and add it to the list.
        pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_REQUEST);
        if (pRequestEntry != NULL) {
            // Enqueue the request entry.

            SmbCeInitializeResumptionContext(&ResumptionContext);

            pRequestEntry->MidRequest.Type               = ACQUIRE_MID_REQUEST;
            pRequestEntry->MidRequest.pExchange          = pExchange;
            pRequestEntry->MidRequest.pResumptionContext = &ResumptionContext;
            SmbCeAddRequestEntryLite(&pServerEntry->MidAssignmentRequests,pRequestEntry);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else if (Status == STATUS_SUCCESS) {
        pExchange->SmbCeFlags |= SMBCE_EXCHANGE_MID_VALID;
    }

    // Release the resource
    SmbCeReleaseSpinLock();

    if (Status == STATUS_UNSUCCESSFUL) {
        //DbgPrint("***** Thread %lx Waiting for MID Resumption Context %lx*****\n",PsGetCurrentThread(),&ResumptionContext);
        SmbCeSuspend(&ResumptionContext);
        Status = ResumptionContext.Status;
        //DbgPrint("***** Thread %lx MID Wait Satisfied %lx *****\n",PsGetCurrentThread(),&ResumptionContext);
    }

    if (ResetServerEntry) {
        // If all the mids have been discarded we rest the transport connection
        // to start afresh.
        SmbCeTransportDisconnectIndicated(pServerEntry);
    }

    return Status;
}

struct _SMB_EXCHANGE *
SmbCeMapMidToExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   SMB_MPX_ID            Mid)
/*++

Routine Description:

   This routine maps a given MID to the exchange associated with it

Arguments:

    pServerEntry - the servere entry

    Mid          - the mid to be mapped to an Exchange.

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

--*/
{
    PSMB_EXCHANGE pExchange;

    // Acquire the resource
    SmbCeAcquireSpinLock();

    if (pServerEntry->pMidAtlas != NULL) {
        pExchange = FsRtlMapMidToContext(
                        pServerEntry->pMidAtlas,
                        Mid);

        if (pExchange != NULL) {
            if (!SmbCeVerifyMid(pServerEntry,pExchange,Mid)) {
                pExchange = NULL;
            }
        }
    } else {
        pExchange = NULL;
    }

    // Release the resource
    SmbCeReleaseSpinLock();

    return pExchange;
}

NTSTATUS
SmbCeDissociateMidFromExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange)
/*++

Routine Description:

   This routine disassociates an exchange from the MID

Arguments:

    pServerEntry - the servere entry

    pExchange    - the exchange instance.

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

Notes:

   If an asynchronous mechanism to acquire MID's is to be introduced this routine
   needs to be modified. This modification will also include posting requests
   for resumption of exchanges when invoked at DPC level.

--*/
{
    NTSTATUS               Status = STATUS_SUCCESS;
    SMBCEDB_SERVER_TYPE    ServerType;

    ServerType = SmbCeGetServerType(pServerEntry);

    if (pExchange->Mid != SMBCE_OPLOCK_RESPONSE_MID) {
        PVOID                  pContext;
        PSMBCEDB_REQUEST_ENTRY pRequestEntry = NULL;

        // Acquire the resource
        SmbCeAcquireSpinLock();

        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
            // Check if there are any pending MID assignment requests and transfer the MID
            // if one exists.
            pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->MidAssignmentRequests);

            if (pRequestEntry != NULL) {
                SmbCeRemoveRequestEntryLite(&pServerEntry->MidAssignmentRequests,pRequestEntry);
            }

            if (pServerEntry->pMidAtlas != NULL) {
                SMB_MPX_ID Mid;

                Mid = SmbCeExtractMid(pServerEntry,pExchange->Mid);

                if (pRequestEntry != NULL) {
                    Status = FsRtlReassociateMid(
                                 pServerEntry->pMidAtlas,
                                 Mid,
                                 pRequestEntry->MidRequest.pExchange);

                    ASSERT(Status == STATUS_SUCCESS);

                    pRequestEntry->MidRequest.pExchange->SmbCeFlags |= SMBCE_EXCHANGE_MID_VALID;
                    pRequestEntry->MidRequest.pExchange->Mid = SmbCeEncodeMid(
                                                                   pServerEntry,
                                                                   pRequestEntry->MidRequest.pExchange,
                                                                   Mid);
                    pRequestEntry->MidRequest.pResumptionContext->Status = STATUS_SUCCESS;
                } else {
                    Status = FsRtlMapAndDissociateMidFromContext(
                                 pServerEntry->pMidAtlas,
                                 Mid,
                                 &pContext);

                    ASSERT(pContext == pExchange);
                }
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
        }

        // Release the resource
        SmbCeReleaseSpinLock();

        if (pRequestEntry != NULL) {
             // Signal the waiter for resumption
            SmbCeResume(pRequestEntry->MidRequest.pResumptionContext);

            SmbCeTearDownRequestEntry(pRequestEntry);
        }
    }

    pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_MID_VALID;

    return Status;
}

VOID
SmbCeDiscardMidAssignmentRequests(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

   This routine discards all mid assignment requests for a given server entry

Arguments:

    pServerEntry - the servere entry

Notes:

    This typically happens when the mids in use are being cancelled against a
    down level server. In such cases there is no cancel command that can be
    sent to the server. Typically we throw away the MID and not use it any
    further. this will lead to a graceful degradation in performance when
    the connection is reestablished

--*/
{
    SMBCEDB_REQUESTS MidRequests;

    InitializeListHead(&MidRequests.ListHead);

    SmbCeAcquireSpinLock();

    if (pServerEntry->pMidAtlas != NULL) {
        if (pServerEntry->pMidAtlas->NumberOfMidsDiscarded ==
            pServerEntry->pMidAtlas->MaximumNumberOfMids) {
            SmbCeTransferRequests(
                &MidRequests,
                &pServerEntry->MidAssignmentRequests);
        }
    }

    SmbCeReleaseSpinLock();

    SmbCeResumeDiscardedMidAssignmentRequests(
        &MidRequests,
        STATUS_TOO_MANY_COMMANDS);

    SmbCeDereferenceServerEntry(pServerEntry);
}

NTSTATUS
SmbCepDiscardMidAssociatedWithExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine discards the mid associated with an exchange

Arguments:

    pExchange - the exchange

Notes:

    We use the hypercritical thread to ensure that this request does not block
    behind other requests.

    This routine also assumes that it is invoked with the SmbCeSpinLock held

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ((pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) &&
        (pExchange->Mid != SMBCE_OPLOCK_RESPONSE_MID) &&
        (pExchange->Mid != SMBCE_ECHO_PROBE_MID)) {
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

        if ((pServerEntry != NULL) &&
            (pServerEntry->pMidAtlas != NULL)) {
            SMB_MPX_ID Mid;

            Mid = SmbCeExtractMid(pServerEntry,pExchange->Mid);

            Status = FsRtlReassociateMid(
                         pServerEntry->pMidAtlas,
                         Mid,
                         NULL);

            if (Status == STATUS_SUCCESS) {
                pServerEntry->pMidAtlas->NumberOfMidsDiscarded++;

                if (pServerEntry->pMidAtlas->NumberOfMidsDiscarded ==
                    pServerEntry->pMidAtlas->MaximumNumberOfMids) {
                    // All the mids have been discarded. Any pending
                    // mid assignment requests needs to be completed
                    // with the appropriate error code.

                    SmbCeReferenceServerEntry(pServerEntry);

                    Status = RxDispatchToWorkerThread(
                                 MRxSmbDeviceObject,
                                 HyperCriticalWorkQueue,
                                 SmbCeDiscardMidAssignmentRequests,
                                 pServerEntry);
                }
            }

            pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_MID_VALID;
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}

VOID
SmbCeResumeDiscardedMidAssignmentRequests(
    PSMBCEDB_REQUESTS pMidRequests,
    NTSTATUS          ResumptionStatus)
/*++

Routine Description:

   This routine resumes discarded mid assignment requests with the appropriate error

Arguments:

    pMidRequests - the discarded requests

    ResumptionStatus - the resumption status

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

Notes:

   This routine and the routines that follow enable a pipelined reuse of MID's
   If a large buffer is to be copied then this can be done without hodling onto
   a MID. This improves the throughput between the client and the server. At the
   very least this mechanism ensures that the connection engine will not be the
   constraining factor in MID reuse.

--*/
{
    PSMBCEDB_REQUEST_ENTRY pRequestEntry;

    pRequestEntry = SmbCeGetFirstRequestEntry(pMidRequests);
    while (pRequestEntry != NULL) {
        // Remove the request entry from the list
        SmbCeRemoveRequestEntryLite(pMidRequests,pRequestEntry);

        ASSERT(pRequestEntry->GenericRequest.Type == ACQUIRE_MID_REQUEST);

        // Signal the waiter for resumption
        pRequestEntry->MidRequest.pResumptionContext->Status = ResumptionStatus;
        SmbCeResume(pRequestEntry->MidRequest.pResumptionContext);

        SmbCeTearDownRequestEntry(pRequestEntry);
        pRequestEntry = SmbCeGetFirstRequestEntry(pMidRequests);
    }
}

struct _SMB_EXCHANGE *
SmbCeGetExchangeAssociatedWithBuffer(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   PVOID                 pBuffer)
/*++

Routine Description:

   This routine gets the exchange associated with a buffer

Arguments:

    pServerEntry - the servere entry

    pBuffer      - the buffer instance.

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

Notes:

   This routine and the routines that follow enable a pipelined reuse of MID's
   If a large buffer is to be copied then this can be done without hodling onto
   a MID. This improves the throughput between the client and the server. At the
   very least this mechanism ensures that the connection engine will not be the
   constraining factor in MID reuse.

--*/
{
   PSMBCEDB_REQUEST_ENTRY pRequestEntry;
   PSMB_EXCHANGE          pExchange = NULL;

   // Acquire the resource
   SmbCeAcquireSpinLock();

   // Walk through the list of requests maintained on this and remove the one
   // matching the cached buffer ptr with the ptr indicated
   pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
   while (pRequestEntry != NULL) {
      if ((pRequestEntry->GenericRequest.Type == COPY_DATA_REQUEST) &&
          (pRequestEntry->CopyDataRequest.pBuffer == pBuffer)) {
         pExchange = pRequestEntry->CopyDataRequest.pExchange;
         pRequestEntry->CopyDataRequest.pBuffer = NULL;
         break;
      }

      pRequestEntry = SmbCeGetNextRequestEntry(
                              &pServerEntry->OutstandingRequests,
                              pRequestEntry);
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   return pExchange;
}

NTSTATUS
SmbCeAssociateBufferWithExchange(
   PSMBCEDB_SERVER_ENTRY  pServerEntry,
   struct _SMB_EXCHANGE * pExchange,
   PVOID                  pBuffer)
/*++

Routine Description:

   This routine establishes an association between an exchange and a copy data request
   buffer

Arguments:

    pServerEntry - the servere entry

    pBuffer      - the buffer instance.

Return Value:

    STATUS_SUCCESS if succesful

--*/
{
   NTSTATUS               Status = STATUS_SUCCESS;
   PSMBCEDB_REQUEST_ENTRY pRequestEntry;

   // Acquire the resource
   SmbCeAcquireSpinLock();

   Status = pServerEntry->ServerStatus;
   if (Status == STATUS_SUCCESS) {
      // Walk through the list of requests maintained on this and remove the one
      // matching the cached buffer ptr with the ptr indicated
      pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
      while (pRequestEntry != NULL) {
         if ((pRequestEntry->GenericRequest.Type == COPY_DATA_REQUEST) &&
             (pRequestEntry->CopyDataRequest.pBuffer == NULL)) {
            pRequestEntry->CopyDataRequest.pExchange = pExchange;
            pRequestEntry->CopyDataRequest.pBuffer = pBuffer;
            break;
         }
         pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
      }
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   if ((Status == STATUS_SUCCESS) &&
       (pRequestEntry == NULL)) {
      // Allocate a new entry and add it to the list.
      pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_REQUEST);
      if (pRequestEntry != NULL) {
         // Enqueue the request entry.
         pRequestEntry->CopyDataRequest.Type      = COPY_DATA_REQUEST;
         pRequestEntry->CopyDataRequest.pExchange = pExchange;
         pRequestEntry->CopyDataRequest.pBuffer   = pBuffer;

         // Acquire the resource
         SmbCeAcquireSpinLock();

         if ((Status = pServerEntry->ServerStatus) == STATUS_SUCCESS) {
            SmbCeAddRequestEntryLite(&pServerEntry->OutstandingRequests,pRequestEntry);
         }

         // Release the resource
         SmbCeReleaseSpinLock();

         if (Status != STATUS_SUCCESS) {
            SmbCeTearDownRequestEntry(pRequestEntry);
         }
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   }

   return Status;
}

VOID
SmbCePurgeBuffersAssociatedWithExchange(
   PSMBCEDB_SERVER_ENTRY  pServerEntry,
   struct _SMB_EXCHANGE * pExchange)
/*++

Routine Description:

   This routine purges all the copy data requests associated with an exchange.

Arguments:

    pServerEntry - the servere entry

    pExchange    - the exchange instance.

Notes:

   This mechanism of delaying the purging of requests associated with an exchange
   till it is discared is intended to solve the problem of repeated allocation/freeing
   of request entries. This rests on the assumption that there will not be too many
   copy data requests outstanding for any exchange. If evidence to the contrary is
   noticed this technique has to be modified.

--*/
{
   SMBCEDB_REQUESTS       ExchangeRequests;
   PSMBCEDB_REQUEST_ENTRY pRequestEntry;
   PSMBCEDB_REQUEST_ENTRY pNextRequestEntry;

   SmbCeInitializeRequests(&ExchangeRequests);

   // Acquire the resource
   SmbCeAcquireSpinLock();

   // Walk through the list of requests maintained on this and remove the one
   // matching the given exchange
   pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
   while (pRequestEntry != NULL) {
      pNextRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
      if (pRequestEntry->GenericRequest.pExchange == pExchange) {
         SmbCeRemoveRequestEntryLite(&pServerEntry->OutStandingRequests,pRequestEntry);
         SmbCeAddRequestEntryLite(&ExchangeRequests,pRequestEntry);
      }
      pRequestEntry = pNextRequestEntry;
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   pRequestEntry = SmbCeGetFirstRequestEntry(&ExchangeRequests);
   while (pRequestEntry != NULL) {
      SmbCeRemoveRequestEntryLite(&ExchangeRequests,pRequestEntry);
      SmbCeTearDownRequestEntry(pRequestEntry);
      pRequestEntry = SmbCeGetFirstRequestEntry(&ExchangeRequests);
   }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbmrx.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    smbmrx.h

Abstract:

    This module includes all SMB smaple mini redirector definitions shared
    between the control utility, network provider DLL and the mini redirector

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _SMBMRX_H_
#define _SMBMRX_H_

// This file contains all the definitions that are shared across the multiple
// components that constitute the mini rdr -- the mini redirector driver,
// the net provider dll and the utility.


// The sample net provider id. This needs to be unique and
// should not be the same as any other network provider id.
#ifndef WNNC_NET_RDR2_SAMPLE
#define WNNC_NET_RDR2_SAMPLE 0x00250000
#endif



#define SMBMRX_DEVICE_NAME_U L"SmbSampleMiniRedirector"
#define SMBMRX_DEVICE_NAME_A "SmbSampleMiniRedirector"

#ifdef UNICODE
#define SMBMRX_DEVICE_NAME SMBMRX_DEVICE_NAME_U
#else
#define SMBMRX_DEVICE_NAME SMBMRX_DEVICE_NAME_A
#endif

// The following constant defines the length of the above name.

#define SMBMRX_DEVICE_NAME_A_LENGTH (24)

#define SMBMRX_PROVIDER_NAME_U L"SMB Sample Redirector Network"
#define SMBMRX_PROVIDER_NAME_A "SMB Sample Redirector Network"

#ifdef UNICODE
#define SMBMRX_PROVIDER_NAME SMBMRX_PROVIDER_NAME_U
#else
#define SMBMRX_PROVIDER_NAME SMBMRX_PROVIDER_NAME_A
#endif

// The following constant defines the length of the above name.

#define DD_SMBMRX_FS_DEVICE_NAME_U L"\\Device\\SmbSampleMiniRedirector"
#define DD_SMBMRX_FS_DEVICE_NAME_A "\\Device\\SmbSampleMiniRedirector"

#ifdef UNICODE
#define DD_SMBMRX_FS_DEVICE_NAME    DD_SMBMRX_FS_DEVICE_NAME_U
#else
#define DD_SMBMRX_FS_DEVICE_NAME    DD_SMBMRX_FS_DEVICE_NAME_A
#endif


#define SMBMRX_MINIRDR_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\SmbMRx\\Parameters"
//
//  The Devicename string required to access the mini-redirector device from
//  User Mode
//
//  WARNING The next two strings must be kept in sync. Change one and you must change the
//  other. These strings have been chosen such that they are unlikely to
//  coincide with names of other drivers.
//
#define DD_SMBMRX_USERMODE_SHADOW_DEV_NAME_U    L"\\??\\SmbMiniRdrDCN"

#define DD_SMBMRX_USERMODE_DEV_NAME_U   L"\\\\.\\SmbMiniRdrDCN"
#define DD_SMBMRX_USERMODE_DEV_NAME_A   "\\\\.\\SmbMiniRdrDCN"

#ifdef UNICODE
#define DD_SMBMRX_USERMODE_DEV_NAME     DD_SMBMRX_USERMODE_DEV_NAME_U
#else
#define DD_SMBMRX_USERMODE_DEV_NAME     DD_SMBMRX_USERMODE_DEV_NAME_A
#endif

// UM code use devioclt.h

// BEGIN WARNING WARNING WARNING WARNING
//  The following are from the ddk include files and cannot be changed

//#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014 // from ddk\inc\ntddk.h

//#define METHOD_BUFFERED 0

//#define FILE_ANY_ACCESS 0

// END WARNING WARNING WARNING WARNING

#define IOCTL_RDR_BASE FILE_DEVICE_NETWORK_FILE_SYSTEM

#define _RDR_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_RDR_BASE, request, method, access)

#define IOCTL_SMBMRX_START      _RDR_CONTROL_CODE(100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_SMBMRX_STOP       _RDR_CONTROL_CODE(101, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_SMBMRX_GETSTATE   _RDR_CONTROL_CODE(102, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_SMBMRX_ADDCONN    _RDR_CONTROL_CODE(125, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SMBMRX_DELCONN    _RDR_CONTROL_CODE(126, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define SMBMRXNP_MAX_DEVICES (26)

typedef struct _SMBMRX_CONNECTINFO_
{
    DWORD   ConnectionNameOffset;
    DWORD   ConnectionNameLength;
    DWORD   EaDataOffset;
    DWORD   EaDataLength;
    BYTE    InfoArea[1];

} SMBMRX_CONNECTINFO, *PSMBMRX_CONNECTINFO;

// The NP Dll updates a shared memory data structure to reflect the various
// drive mappings established from the various process. This shared memory
// is used in maintaining the data structures required for enumeration as
// well.

typedef struct _SMBMRXNP_NETRESOURCE_
{
    BOOL     InUse;
    USHORT   LocalNameLength;
    USHORT   RemoteNameLength;
    USHORT   ConnectionNameLength;
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    WCHAR    LocalName[MAX_PATH];
    WCHAR    RemoteName[MAX_PATH];
    WCHAR    ConnectionName[MAX_PATH];
    WCHAR    UserName[MAX_PATH];
    WCHAR    Password[MAX_PATH];

} SMBMRXNP_NETRESOURCE, *PSMBMRXNP_NETRESOURCE;

typedef struct _SMBMRXNP_SHARED_MEMORY_
{
    INT                     HighestIndexInUse;
    INT                     NumberOfResourcesInUse;
    SMBMRXNP_NETRESOURCE    NetResources[SMBMRXNP_MAX_DEVICES];

} SMBMRXNP_SHARED_MEMORY, *PSMBMRXNP_SHARED_MEMORY;

#define SMBMRXNP_SHARED_MEMORY_NAME L"SMBMRXNPMEMORY"

#define SMBMRXNP_MUTEX_NAME         L"SMBMRXNPMUTEX"


#define RDR_NULL_STATE  0
#define RDR_UNLOADED    1
#define RDR_UNLOADING   2
#define RDR_LOADING     3
#define RDR_LOADED      4
#define RDR_STOPPED     5
#define RDR_STOPPING    6
#define RDR_STARTING    7
#define RDR_STARTED     8

#ifndef min
#define min(a, b)        ((a) > (b) ? (b) : (a))
#endif


#endif // _SMBMRX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbcedbp.h ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    smbcedbp.h

Abstract:

    This is the include file that defines all constants and types for
    implementing the SMB mini redirector connection engine.

    This module contains all the implementation details of the connection engine
    data structures and should be included only by the implementation modules.

Notes:

--*/

#ifndef _SMBCEDBP_H_
#define _SMBCEDBP_H_

//
// There is reliance on the fact that SMBCEDB_OT_SENTINEL is the last entry in the
// enumerated type and the types have a range of values from 0. Please ensure that
// this is always true.
//
typedef struct _REFERENCE_RECORD_ {
    PVOID   FileName;
    ULONG   FileLine;
} REFERENCE_RECORD,*PREFERENCE_RECORD;

#define REFERENCE_RECORD_SIZE 20

typedef enum _SMBCEDB_OBJECT_TYPE {
   SMBCEDB_OT_SERVER,
   SMBCEDB_OT_NETROOT,
   SMBCEDB_OT_SESSION,
   SMBCEDB_OT_REQUEST,
   SMBCEDB_OT_VNETROOTCONTEXT,
   SMBCEDB_OT_SENTINEL,
   SMBCEDB_OT_TRANSPORT
} SMBCEDB_OBJECT_TYPE, *PSMBCEDB_OBJECT_TYPE;

typedef enum _SMBCEDB_OBJECT_STATE_ {
   SMBCEDB_ACTIVE,                    // the instance is in use
   SMBCEDB_INVALID,                   // the instance has been invalidated/disconnected.
   SMBCEDB_MARKED_FOR_DELETION,       // the instance has been marked for deletion.
   SMBCEDB_RECYCLE,                   // the instance is available for recycling
   SMBCEDB_START_CONSTRUCTION,        // Initiate construction.
   SMBCEDB_CONSTRUCTION_IN_PROGRESS,  // the instance construction is in progress
   SMBCEDB_DESTRUCTION_IN_PROGRESS    // the instance destruction is in progress
} SMBCEDB_OBJECT_STATE, *PSMBCEDB_OBJECT_STATE;

typedef struct _SMBCE_OBJECT_HEADER_ {
    union {
        struct {
            UCHAR   ObjectType;      // type of the object
            UCHAR   ObjectCategory;  // Node type for debugging
        };
        USHORT NodeType;
    };
    UCHAR   Flags;           // flags associated with the object, This is implementation dependent
    UCHAR   Reserved;        // padding
    LONG    SwizzleCount;    // Number of swizzled references to this object
    LONG    State;           // State of the object
} SMBCE_OBJECT_HEADER, *PSMBCE_OBJECT_HEADER;

typedef struct _SMBCE_SERVERS_LIST_ {
    LIST_ENTRY ListHead;
} SMBCEDB_SERVERS, *PSMBCEDB_SERVERS;

typedef struct _SMBCEDB_SESSIONS_ {
   LIST_ENTRY                     ListHead;
   LIST_ENTRY                     DefaultSessionList;
} SMBCEDB_SESSIONS, *PSMBCEDB_SESSIONS;

typedef struct _SMBCEDB_NET_ROOTS_ {
   LIST_ENTRY  ListHead;
} SMBCEDB_NET_ROOTS, *PSMBCEDB_NET_ROOTS;

typedef struct _MRX_SMB_V_NET_ROOT_CONTEXTS {
    LIST_ENTRY ListHead;
} SMBCE_V_NET_ROOT_CONTEXTS, *PSMBCE_V_NET_ROOT_CONTEXTS;

typedef struct _SMBCEDB_REQUESTS_ {
    LIST_ENTRY  ListHead;
    SMB_MPX_ID  NextRequestId;
} SMBCEDB_REQUESTS, *PSMBCEDB_REQUESTS;

typedef enum _SMBCEDB_SERVER_TYPE_ {
   SMBCEDB_MAILSLOT_SERVER = 1,
   SMBCEDB_FILE_SERVER     = 2
} SMBCEDB_SERVER_TYPE, *PSMBCEDB_SERVER_TYPE;

//
// The SMBCEDB_SERVER_ENTRY is the data structure which encapsulates all the information
// w.r.t a remote server for the connection engine. This information includes the dialect
// details as well as the operational data structures required to communicate with the server.
//
// All the dialect related details are further encapsulated in SMBCE_SERVER while the operational
// data structures constitute the remaining parts of the server entry. A pointer to a
// SMBCEDB_SERVER_ENTRY instance is associated with every SRV_CALL that has been hooked
// onto this mini redirector by the wrapper. It is stored in the Context field of MRX_SRV_CALL.
//
// The operational information associated with a server entry includes the Transport related
// information, a collection of requests and a mechanism for associating MID's ( See SMB
// protocol spec.) and a mechanism for posting to threads ( WORK_QUEUE_ITEM ).
//

typedef struct _SMBCEDB_SERVER_ENTRY {
    SMBCE_OBJECT_HEADER           Header;           // struct header.
    LIST_ENTRY                    ServersList;      // list of server instances.
    PMRX_SRV_CALL                 pRdbssSrvCall;
    UNICODE_STRING                Name;             // the server name.
    UNICODE_STRING                DomainName;       // the server domain name.
    SMBCEDB_SESSIONS              Sessions;         // the sessions associated with the server
    SMBCEDB_NET_ROOTS             NetRoots;         // the net roots associated with the server.
    SMBCE_V_NET_ROOT_CONTEXTS     VNetRootContexts; // the V_NET_ROOT contexts
    LIST_ENTRY                    ActiveExchanges;  // list of exchanges active for this server
    LIST_ENTRY                    ExpiredExchanges; // exchanges that have been timed out
    RX_WORK_QUEUE_ITEM            WorkQueueItem;    // work queue item for posting
    NTSTATUS                      ServerStatus;     // the status of the server as determined by negotiate response
    struct _SMBCE_TRANSPORT_      *PreferredTransport;
    LONG                          TransportSpecifiedByUser; // ture if the connection is established on the tranport
                                                            // with the name specified
    struct SMBCE_SERVER_TRANSPORT *pTransport;

    SMBCEDB_REQUESTS              MidAssignmentRequests;
    SMBCEDB_REQUESTS              OutstandingRequests;
    PMID_ATLAS                    pMidAtlas;
    struct _SMB_EXCHANGE          *pNegotiateExchange;
    SMBCE_SERVER                  Server;           // the server data structure.
    UNICODE_STRING                DfsRootName;
    PVOID                         ConstructionContext;       // debug only
    KEVENT                        TransportRundownEvent;
    BOOLEAN                       IsTransportDereferenced;   // prevent transport from being dereferenced more than once
    BOOLEAN                       NegotiateInProgress;       // a negotiate is in progress for this server
} SMBCEDB_SERVER_ENTRY, *PSMBCEDB_SERVER_ENTRY;

// The SMBCEDB_NET_ROOT_ENTRY encapsulates all the information associated with a particular
// TREE_CONNECT ( Net use ) made on a server. As with the server entry this data structure
// encapsulates the dialect oriented details as well as the opertaional information
// associated with handling the requests on a net root.
//
// The dialect specific information is encapsulated in the SMBCE_NET_ROOT data structure. A
// pointer to an instance of this data structure is associated with every MRX_NET_ROOT call
// associated with a MRX_SRV_CALL hooked to this mini redirector.

typedef struct _SMBCEDB_NET_ROOT_ENTRY {
    SMBCE_OBJECT_HEADER      Header;              // the struct header
    LIST_ENTRY               NetRootsList;        // the list of net roots asssociated with a server
    PMRX_NET_ROOT            pRdbssNetRoot;       // the associated net root ( purely as a debug aid )
    PSMBCEDB_SERVER_ENTRY    pServerEntry;        // the associated server entry
    struct _SMB_EXCHANGE    *pExchange;          // the exchange which is responsible for construction
    SMBCEDB_REQUESTS         Requests;            // the pending requests for this net root
    UNICODE_STRING           Name;
    ACCESS_MASK              MaximalAccessRights;
    ACCESS_MASK              GuestMaximalAccessRights;
    SMBCE_NET_ROOT           NetRoot;             // the net root data structure.
    NAME_CACHE_CONTROL       NameCacheCtlGFABasic;    // The get file attributes name cache control.
    NAME_CACHE_CONTROL       NameCacheCtlGFAStandard; // The get file attributes name cache control.
    NAME_CACHE_CONTROL       NameCacheCtlFNF;     // The File not found name cache control.
    REFERENCE_RECORD         ReferenceRecord[REFERENCE_RECORD_SIZE]; // debug only
} SMBCEDB_NET_ROOT_ENTRY, *PSMBCEDB_NET_ROOT_ENTRY;

// The SMBCEDB_SESSION_ENTRY encapsulates all the information associated with a session
// established to a remote machine. The session encapsulates all the security information.
// The dialect specific details are encapsulated in teh SMBCE_SESSION data structure. The
// SMBCE_SESSION data structure is available in many flavours depending on the security
// package used. Currently there is support for handling LSA sessions.
//
// A pointer to an instance of this data structure is associated with every MRX_V_NET_ROOT
// data structure hooked to this mini redirector by the wrapper.

typedef struct _SMBCEDB_SESSION_ENTRY {
    SMBCE_OBJECT_HEADER        Header;           // the struct header
    LIST_ENTRY                 SessionsList;     // the list of sessions associated with the server
    LIST_ENTRY                 DefaultSessionLink; // the list of explicit credentials for this server
    PSMBCEDB_SERVER_ENTRY      pServerEntry;     // the associated server entry
    struct _SMB_EXCHANGE       *pExchange;       // the exchange which is responsible for construction
    SMBCEDB_REQUESTS           Requests;         // pending requests
    LIST_ENTRY                 SerializationList; // session construction serialization
    PKEVENT                    pSerializationEvent;
    ULONG                      SessionVCNumber;  // the VC number to be packaged with session setup
    SMBCE_SESSION              Session;          // the Session
} SMBCEDB_SESSION_ENTRY, *PSMBCEDB_SESSION_ENTRY;

//
// The wrapper exposes three data structures for manipulating and describing
// name spaces set up on remote servers, Viz., MRX_SRV_CALL, MRX_NET_ROOT and
// MRX_V_NET_ROOT. The SRV_CALL corresponds to a remote server, the MRX_NET_ROOT
// corresponds to a share on that machine and V_NET_ROOT encapsulates
// the notion of a view of a MRX_NET_ROOT ( share in SMB terminology)
//
// The mapping between the wrapper level data structures and the SMB notion
// of SMBCEDB_SERVER_ENTRY, SMBCEDB_SESSION_ENTRY and SMBCEDB_NET_ROOT_ENTRY
// is not one to one in all cases.
//
// It is one to one between MRX_SRV_CALL and SMBCEDB_SERVER_ENTRY. It is for this
// reason that a pointer to SMBCEDB_SERVER_ENTRY is stored in the context field
// of the MRX_SRV_CALL instance.
//
// SMBCEDB_SESSION_ENTRY has a one to one mapping with the set of credentials
// supplied to establish a connection to a server. Having established a session
// one can have access to all the shares available on the server.
//
// SMBCEDB_NET_ROOT_ENTRY has a one to one mapping with a share on a given
// server. Since this closely corresponds to the wrappers interpretation of
// MRX_NET_ROOT a pointer to SMBCEDB_NET_ROOT_ENTRY is stored as part of the
// MRX_NET_ROOT instance.
//
// The context associated with every MRX_V_NET_ROOT instance is a pointer to
// an instance of SMBCE_V_NET_ROOT_CONTEXT. This encapsulates the associated session
// entry, the net root entry and the relevant book keeping information.
//
// The bookkeeping information is the UID/TID used in the SMB protocol, a
// reference count and a LIST_ENTRY to thread the instance into the appropriate
// list.
//

#define SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID    (0x1)

typedef struct _SMBCE_V_NET_ROOT_CONTEXT {
    SMBCE_OBJECT_HEADER     Header;

    PMRX_V_NET_ROOT         pRdbssVNetRoot;   // the associated VNetRoot ( purely as a debug aid)
    struct _SMB_EXCHANGE    *pExchange;           // the exchange which is responsible for construction
    SMBCEDB_REQUESTS        Requests;

    LIST_ENTRY              ListEntry;
    LARGE_INTEGER           ExpireTime;

    struct _SMBCEDB_SERVER_ENTRY   *pServerEntry;
    struct _SMBCEDB_SESSION_ENTRY  *pSessionEntry;
    struct _SMBCEDB_NET_ROOT_ENTRY *pNetRootEntry;

    USHORT          Flags;
    SMB_TREE_ID     TreeId;

    BOOLEAN         NumberOfActiveVNetRootIncremented;
} SMBCE_V_NET_ROOT_CONTEXT, *PSMBCE_V_NET_ROOT_CONTEXT;

//
// An SMBCEDB_REQUEST_ENTRY encapsulates an action being processed by the SMBCE connection
// engine. The requests come in vairous flavours and each of these flavours is associated
// with the appropriate context required for resumption. In order to provide better memory
// management mechanisms the REQUEST_ENTRY encapsulates a union of the requests of various
// flavours. Each SERVER_ENTRY in the connection engine is associated with a list or
// request entries. In order to hide the abstraction of a list which does not scale well to
// the case of GATEWAY redirectors a set of routines are provided to manipulate the
// collection of requests. They provide a mechanism for intializing the collection of requests,
// adding a request, deleting a request and enumeratiung requests in a collection.
//
// Special mechanisms are built in to handle batching of operations. Each operation on the
// collection of requests come in two flavours, a vanila version and a lite version. In the
// lite version it is assumed that the appropriate concurrency control action has been taken
//
// One common scenario that is often encountered in processing the requests is invocation
// of a specific function on the requests in the collection. As an example if a disconnect
// request is received on a server entry then all the outstanding requests must be resumed
// with the appropriate error. Since these indications can potentially occur at DPC levels in
// NT it is not desirable to manipulate the collection while holding onto a spinlock, nor is
// it desirable to repeatedly release and accquire the spin lock. A special operation is
// provided for transferring the requests enmasse from one collection to another and resetting
// the original. With the help of this operation it is sufficient to hold the spinlock only
// for the duration of the transfer. The remainder of the processing can be done on the newly
// created collection.
//
//
// NT Specific Implementation Note:
//
// On NT the transport indications are at DPC level, therefore it is required to protect
// the manipulation of the requests data structure with a spinlock.
//
//

typedef struct _SMBCEDB_REQUEST_ENTRY_ {
    SMBCE_OBJECT_HEADER           Header;        // the struct header
    LIST_ENTRY                      RequestsList;  // the next request for the VC.
    union {
       SMBCE_GENERIC_REQUEST    GenericRequest;
       SMBCE_REQUEST            Request;           // the next request.
       SMBCE_COPY_DATA_REQUEST  CopyDataRequest;
       SMBCE_RECONNECT_REQUEST  ReconnectRequest;
       SMBCE_MID_REQUEST        MidRequest;
    };
} SMBCEDB_REQUEST_ENTRY, *PSMBCEDB_REQUEST_ENTRY;

#define SmbCeInitializeRequests(pRequests)  \
         InitializeListHead(&(pRequests)->ListHead); \
         (pRequests)->NextRequestId = 0

#define SmbCeAddRequestEntry(pRequestList,pRequestEntry)                             \
           SmbCeAcquireSpinLock();                                                   \
           InsertTailList(&(pRequestList)->ListHead,&(pRequestEntry)->RequestsList); \
           SmbCeReleaseSpinLock()

#define SmbCeAddRequestEntryLite(pRequestList,pRequestEntry)   \
           InsertTailList(&(pRequestList)->ListHead,&(pRequestEntry)->RequestsList);

#define SmbCeRemoveRequestEntry(pRequests,pEntry)     \
           SmbCeAcquireSpinLock();                    \
           RemoveEntryList(&(pEntry)->RequestsList);  \
           SmbCeReleaseSpinLock()

#define SmbCeRemoveRequestEntryLite(pRequests,pEntry)         \
               RemoveEntryList(&(pEntry)->RequestsList);

#define SmbCeGetFirstRequestEntry(pRequestList)                    \
            (IsListEmpty(&(pRequestList)->ListHead)                \
             ? NULL                                                \
             : (PSMBCEDB_REQUEST_ENTRY)                            \
               (CONTAINING_RECORD((pRequestList)->ListHead.Flink,  \
                                  SMBCEDB_REQUEST_ENTRY,           \
                                  RequestsList)))

#define SmbCeGetNextRequestEntry(pRequestList,pRequestEntry)                     \
            (((pRequestEntry)->RequestsList.Flink == &(pRequestList)->ListHead)  \
             ? NULL                                                              \
             : (PSMBCEDB_REQUEST_ENTRY)                                          \
               (CONTAINING_RECORD((pRequestEntry)->RequestsList.Flink,           \
                                  SMBCEDB_REQUEST_ENTRY,                         \
                                  RequestsList)))

#define SmbCeTransferRequests(pDestination,pSource)                               \
         if (IsListEmpty(&(pSource)->ListHead)) {                                 \
            SmbCeInitializeRequests((pDestination));                              \
         } else {                                                                 \
            *(pDestination) = *(pSource);                                         \
            (pDestination)->ListHead.Flink->Blink = &(pDestination)->ListHead;    \
            (pDestination)->ListHead.Blink->Flink = &(pDestination)->ListHead;    \
            SmbCeInitializeRequests((pSource));                                   \
         }


// Much along the lines of a collection of request a collection of all server entries is
// maintained as part of the connection engine. The following operations are supported on
// the colection of server entries
//    1) adding a server entry to the collection
//    2) removing a server entry from the colection
//    3) enumerating the entries in the collection
//
// As in the case of the collection of requests all these operations come in two flavours
// the vanila version in which concurrency control is enforced and the lite version in
// which the concurrency control is left to the user's discretion.

#define SmbCeAddServerEntry(pServerEntry)                                      \
            SmbCeAcquireSpinLock();                                            \
            InsertTailList(&s_DbServers.ListHead,&pServerEntry->ServersList);  \
            SmbCeReleaseSpinLock()

#define SmbCeAddServerEntryLite(pServerEntry)                                   \
            InsertTailList(&s_DbServers.ListHead,&pServerEntry->ServersList);

#define SmbCeRemoveServerEntry(pServerEntry)                \
            SmbCeAcquireSpinLock();                         \
            RemoveEntryList(&(pServerEntry)->ServersList);  \
            SmbCeReleaseSpinLock()

#define SmbCeRemoveServerEntryLite(pServerEntry)   \
            RemoveEntryList(&(pServerEntry)->ServersList);

#define SmbCeGetFirstServerEntry()                                   \
               (IsListEmpty(&s_DbServers.ListHead)                   \
                ? NULL                                               \
                : (PSMBCEDB_SERVER_ENTRY)                            \
                  (CONTAINING_RECORD(s_DbServers.ListHead.Flink,     \
                                     SMBCEDB_SERVER_ENTRY,           \
                                     ServersList)))

#define SmbCeGetNextServerEntry(pServerEntry)                               \
           (((pServerEntry)->ServersList.Flink == &s_DbServers.ListHead)    \
            ? NULL                                                          \
            : (PSMBCEDB_SERVER_ENTRY)                                       \
              (CONTAINING_RECORD((pServerEntry)->ServersList.Flink,         \
                                 SMBCEDB_SERVER_ENTRY,                      \
                                 ServersList)))


// Since the mapping between V_NET_ROOT's in the RDBSS and the session entries in the mini
// redirector is a many to one mapping a collection of session entries is maintained as part
// of each server entry. The following operations are supported on the collection of session
// entries
//    1) adding a session entry to the collection
//    2) removing a session entry from the colection
//    3) enumerating the entries in the collection
//
// As in the case of the collection of requests all these operations come in two flavours
// the vanila version in which concurrency control is enforced and the lite version in
// which the concurrency control is left to the user's discretion.
//
// In addition two more methods are specified for retrieving the default session entry and
// setting the default session entry for any given server.

#define SmbCeAddSessionEntry(pServerEntry,pSessionEntry)   \
            SmbCeAcquireSpinLock();                                              \
            InsertTailList(&(pServerEntry)->Sessions.ListHead,&(pSessionEntry)->SessionsList); \
            SmbCeReleaseSpinLock()


#define SmbCeAddSessionEntryLite(pServerEntry,pSessionEntry)   \
            InsertTailList(&(pServerEntry)->Sessions.ListHead,&(pSessionEntry)->SessionsList);

#define SmbCeRemoveSessionEntry(pServerEntry,pSessionEntry)                          \
               SmbCeAcquireSpinLock();                                               \
               if ((pSessionEntry)->DefaultSessionLink.Flink != NULL) {              \
                   RemoveEntryList(&(pSessionEntry)->DefaultSessionLink);            \
                   pSessionEntry->DefaultSessionLink.Flink = NULL;                   \
                   pSessionEntry->DefaultSessionLink.Blink = NULL;                   \
               };                                                                    \
               RemoveEntryList(&(pSessionEntry)->SessionsList);                      \
               SmbCeReleaseSpinLock()

#define SmbCeRemoveSessionEntryLite(pServerEntry,pSessionEntry)                      \
               ASSERT( SmbCeSpinLockAcquired(); );                                   \
               if ((pSessionEntry)->DefaultSessionLink.Flink != NULL) {              \
                   RemoveEntryList(&(pSessionEntry)->DefaultSessionLink);            \
                   pSessionEntry->DefaultSessionLink.Flink = NULL;                   \
                   pSessionEntry->DefaultSessionLink.Blink = NULL;                   \
               };                                                                    \
               RemoveEntryList(&(pSessionEntry)->SessionsList);


#define SmbCeGetFirstSessionEntry(pServerEntry)                                \
            (IsListEmpty(&(pServerEntry)->Sessions.ListHead)                   \
             ? NULL                                                            \
             : (PSMBCEDB_SESSION_ENTRY)                                        \
               (CONTAINING_RECORD((pServerEntry)->Sessions.ListHead.Flink,     \
                                  SMBCEDB_SESSION_ENTRY,                       \
                                  SessionsList)))

#define SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry)                  \
            (((pSessionEntry)->SessionsList.Flink ==                          \
                              &(pServerEntry)->Sessions.ListHead)             \
             ? NULL                                                           \
             : (PSMBCEDB_SESSION_ENTRY)                                       \
               (CONTAINING_RECORD((pSessionEntry)->SessionsList.Flink,        \
                                  SMBCEDB_SESSION_ENTRY,                      \
                                  SessionsList)))

#define SmbCeSetDefaultSessionEntry(pServerEntry,pSessionEntry)               \
               SmbCeAcquireSpinLock();                                        \
               if ((pSessionEntry)->DefaultSessionLink.Flink == NULL) {       \
                   ASSERT( pSessionEntry->DefaultSessionLink.Blink == NULL ); \
               InsertHeadList(&(pServerEntry)->Sessions.DefaultSessionList,&(pSessionEntry)->DefaultSessionLink); \
               };                                                             \
           SmbCeReleaseSpinLock()

extern PSMBCEDB_SESSION_ENTRY
SmbCeGetDefaultSessionEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    ULONG SessionId,
    PLUID pLogonId
    );

VOID
SmbCeRemoveDefaultSessionEntry(
    PSMBCEDB_SESSION_ENTRY pDefaultSessionEntry
    );

// In order to encapsulate the notion of reconnects and to provide for hot reconnects,
// i.e., reconnection attempts in which the saved state in the server/client prior to
// a transport level disconnect can be reused it is required to mark each net root
// entry associated with a server as invalid on receipt of a transport level disconnect.
//
// Therefore an abstraction of a collection of net root entries is provided and is associated
// with each server entry.
//
// The following operations are supported on the collection of net root entries
//    1) adding a net root entry to the collection
//    2) removing a net root entry from the colection
//    3) enumerating the entries in the collection
//
// As in the case of the collection of requests all these operations come in two flavours
// the vanila version in which concurrency control is enforced and the lite version in
// which the concurrency control is left to the user's discretion.
//


#define SmbCeAddNetRootEntry(pServerEntry,pNetRootEntry)   \
            SmbCeAcquireSpinLock();                                              \
            InsertTailList(&(pServerEntry)->NetRoots.ListHead,&(pNetRootEntry)->NetRootsList); \
            SmbCeReleaseSpinLock()


#define SmbCeAddNetRootEntryLite(pServerEntry,pNetRootEntry)   \
            InsertTailList(&(pServerEntry)->NetRoots.ListHead,&(pNetRootEntry)->NetRootsList);

#define SmbCeRemoveNetRootEntry(pServerEntry,pNetRootEntry)                          \
               SmbCeAcquireSpinLock();                                               \
               RemoveEntryList(&(pNetRootEntry)->NetRootsList);                      \
               SmbCeReleaseSpinLock()

#define SmbCeRemoveNetRootEntryLite(pServerEntry,pNetRootEntry)                      \
               RemoveEntryList(&(pNetRootEntry)->NetRootsList);


#define SmbCeGetFirstNetRootEntry(pServerEntry)                                \
            (IsListEmpty(&(pServerEntry)->NetRoots.ListHead)                   \
             ? NULL                                                            \
             : (PSMBCEDB_NET_ROOT_ENTRY)                                       \
               (CONTAINING_RECORD((pServerEntry)->NetRoots.ListHead.Flink,     \
                                  SMBCEDB_NET_ROOT_ENTRY,                      \
                                  NetRootsList)))

#define SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry)                  \
            (((pNetRootEntry)->NetRootsList.Flink ==                          \
                              &(pServerEntry)->NetRoots.ListHead)             \
             ? NULL                                                           \
             : (PSMBCEDB_NET_ROOT_ENTRY)                                      \
               (CONTAINING_RECORD((pNetRootEntry)->NetRootsList.Flink,        \
                                  SMBCEDB_NET_ROOT_ENTRY,                     \
                                  NetRootsList)))


// Macros to manipulate the collection of SMBCE_V_NET_ROOT_CONTEXT instances.

#define SmbCeAddVNetRootContext(pVNetRootContexts,pVNetRootContext)   \
            SmbCeAcquireSpinLock();                                              \
            InsertTailList(&(pVNetRootContexts)->ListHead,&(pVNetRootContext)->ListEntry); \
            SmbCeReleaseSpinLock()


#define SmbCeAddVNetRootContextLite(pVNetRootContexts,pVNetRootContext)   \
            InsertTailList(&(pVNetRootContexts)->ListHead,&(pVNetRootContext)->ListEntry);

#define SmbCeRemoveVNetRootContext(pVNetRootContexts,pVNetRootContext)               \
               SmbCeAcquireSpinLock();                                               \
               RemoveEntryList(&(pVNetRootContext)->ListEntry);                      \
               SmbCeReleaseSpinLock()

#define SmbCeRemoveVNetRootContextLite(pVNetRootContexts,pVNetRootContext)              \
               RemoveEntryList(&(pVNetRootContext)->ListEntry);


#define SmbCeGetFirstVNetRootContext(pVNetRootContexts)                        \
            (IsListEmpty(&((pVNetRootContexts)->ListHead))                       \
             ? NULL                                                            \
             : (PSMBCE_V_NET_ROOT_CONTEXT)                                     \
               (CONTAINING_RECORD((pVNetRootContexts)->ListHead.Flink,         \
                                  SMBCE_V_NET_ROOT_CONTEXT,                    \
                                  ListEntry)))

#define SmbCeGetNextVNetRootContext(pVNetRootContexts,pVNetRootContext)          \
            (((pVNetRootContext)->ListEntry.Flink ==                          \
                              &(pVNetRootContexts)->ListHead)                 \
             ? NULL                                                           \
             : (PSMBCE_V_NET_ROOT_CONTEXT)                                    \
               (CONTAINING_RECORD((pVNetRootContext)->ListEntry.Flink,        \
                                  SMBCE_V_NET_ROOT_CONTEXT,                   \
                                  ListEntry)))


//
// SmbCe database initialization
//

extern NTSTATUS
SmbCeDbInit();

extern VOID
SmbCeDbTearDown();

//
// Object allocation and deallocation
//

extern PSMBCE_OBJECT_HEADER
SmbCeDbAllocateObject(
      SMBCEDB_OBJECT_TYPE ObjectType);

extern VOID
SmbCeDbFreeObject(
      PVOID pObject);

//
// Object destruction
//

extern VOID
SmbCeTearDownServerEntry(PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCeTearDownNetRootEntry(PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry);

extern VOID
SmbCeTearDownSessionEntry(PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern VOID
SmbCeTearDownRequestEntry(PSMBCEDB_REQUEST_ENTRY pRequestEntry);

//
// The routines for mapping a MID with an exchange and for associating an exchange with
// a MID
//

extern NTSTATUS
SmbCeAssociateExchangeWithMid(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange);

extern struct _SMB_EXCHANGE *
SmbCeMapMidToExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   SMB_MPX_ID            Mid);

extern NTSTATUS
SmbCeDissociateMidFromExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange);

extern struct _SMB_EXCHANGE *
SmbCeGetExchangeAssociatedWithBuffer(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   PVOID                 pBuffer);

extern NTSTATUS
SmbCeAssociateBufferWithExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE * pExchange,
   PVOID                 pBuffer);

extern VOID
SmbCePurgeBuffersAssociatedWithExchange(
   PSMBCEDB_SERVER_ENTRY  pServerEntry,
   struct _SMB_EXCHANGE * pExchange);

extern NTSTATUS
SmbCepDiscardMidAssociatedWithExchange(
    struct _SMB_EXCHANGE * pExchange);

extern VOID
SmbCeResumeDiscardedMidAssignmentRequests(
    PSMBCEDB_REQUESTS pMidRequests,
    NTSTATUS          ResumptionStatus);

//
// Routines for handling transport disconnects/invalidation.
//

extern VOID
SmbCeTransportDisconnectIndicated(
      PSMBCEDB_SERVER_ENTRY pServerEntry);


extern VOID
SmbCeResumeAllOutstandingRequestsOnError(
   PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCeHandleTransportInvalidation(
   struct _SMBCE_TRANSPORT_ *pTransport);

extern VOID
SmbCeFinalizeAllExchangesForNetRoot(
    PMRX_NET_ROOT pNetRoot);

//
// Resource acquistion/release
//

PVOID SmbCeDbResourceAcquireFile;
ULONG SmbCeDbResourceAcquireLine;

#define SmbCeAcquireResource() \
        ExAcquireResourceExclusive(&s_SmbCeDbResource,TRUE);\
        SmbCeDbResourceAcquireFile = __FILE__;\
        SmbCeDbResourceAcquireLine = __LINE__

#define SmbCeReleaseResource() \
        SmbCeDbResourceAcquireFile = NULL;\
        SmbCeDbResourceAcquireLine = 0;\
        ExReleaseResource(&s_SmbCeDbResource)

#define SmbCeIsResourceOwned() ExIsResourceAcquiredExclusive(&s_SmbCeDbResource)

#define SmbCeAcquireSpinLock() \
                KeAcquireSpinLock(&s_SmbCeDbSpinLock,&s_SmbCeDbSpinLockSavedIrql);   \
                s_SmbCeDbSpinLockAcquired = TRUE

#define SmbCeReleaseSpinLock()   \
                s_SmbCeDbSpinLockAcquired = FALSE;                                  \
                KeReleaseSpinLock(&s_SmbCeDbSpinLock,s_SmbCeDbSpinLockSavedIrql)

#define SmbCeSpinLockAcquired()   \
                (s_SmbCeDbSpinLockAcquired == TRUE)

//INLINE BOOLEAN SmbCeDbIsEntryInUse(PSMBCE_OBJECT_HEADER pHeader)
/*++

Routine Description:

    This routine determines if a SmbCe database entry is in use.

Arguments:

    pHeader - the entry header

Return Value:

    TRUE if the entry is in use otherwise FALSE

--*/

#define SmbCeIsEntryInUse(pHeader)                                                   \
                  (((PSMBCE_OBJECT_HEADER)(pHeader))->State == SMBCEDB_ACTIVE  ||    \
                   ((PSMBCE_OBJECT_HEADER)(pHeader))->State == SMBCEDB_INVALID ||    \
                   ((PSMBCE_OBJECT_HEADER)(pHeader))->State == SMBCEDB_CONSTRUCTION_IN_PROGRESS)


#define SmbCeSetServerType(pServerEntry,ServerType) \
           (pServerEntry)->Header.Flags = (UCHAR)(ServerType)

#define SmbCeGetServerType(pServerEntry)   \
           ((SMBCEDB_SERVER_TYPE)(pServerEntry)->Header.Flags)


//
// Static variable declarations that constitute the SmbCe database.
//

extern SMBCEDB_SERVERS     s_DbServers;

//
// Currently there is only one resource for synchronizing the access to all the
// entities in the connection engine database. It is possible to customize it
// subsequently since the acquistion/release methods take the type of the object
// as a parameter.
//

extern ERESOURCE  s_SmbCeDbResource;
extern RX_SPIN_LOCK s_SmbCeDbSpinLock;
extern KIRQL      s_SmbCeDbSpinLockSavedIrql;
extern BOOLEAN    s_SmbCeDbSpinLockAcquired;

#endif  // _SMBCEDBP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbpoolt.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    smbpoolt.h

Abstract:

    The pool tag definitions for SMB mini redirector

Notes:

   This file contains all the pool tag definitions related to the SMB mini redirector.
   The mechanism is intended to balance the number of pool tags to be used with the
   total number of tags available in the system.

   By specifying special flags the total number of tags consumed by the mini redirector
   can be controlled. For most builds the tags should be aliased such that about
   6 tags are consumed by the mini redirector. In special builds the aliasing of tags
   will be suppressed, thereby consuming more tags to track down memory leaks easily.

   The following are the major tags ....

      1) SmCe -- the Smb Mini Redirector connection engine.

      2) SmOe -- the Smb Mini redirector ordinary exchange related allocation.

      3) SmAd -- the Smb Mini redirector ADMIN exchange/session setup/tree connect etc.

      4) SmRw -- the Smb mini redirector read/write paths

      5) SmTr -- the Transact exchange related allocations

      6) SmMs -- the miscellanous category.

--*/

#ifndef _SMBPOOLT_H_
#define _SMBPOOLT_H_

#define MRXSMB_CE_POOLTAG        ('eCmS')
#define MRXSMB_MM_POOLTAG        ('mMmS')
#define MRXSMB_ADMIN_POOLTAG     ('dAmS')
#define MRXSMB_RW_POOLTAG        ('wRmS')
#define MRXSMB_XACT_POOLTAG      ('rTmS')
#define MRXSMB_MISC_POOLTAG      ('sMmS')
#define MRXSMB_TRANSPORT_POOLTAG ('pTmS')

extern ULONG MRxSmbExplodePoolTags;

#define MRXSMB_DEFINE_POOLTAG(ExplodedPoolTag,DefaultPoolTag)  \
        ((MRxSmbExplodePoolTags == 0) ? (DefaultPoolTag) : (ExplodedPoolTag))

#define MRXSMB_FSCTL_POOLTAG     MRXSMB_DEFINE_POOLTAG('cFmS',MRXSMB_MISC_POOLTAG)
#define MRXSMB_DIRCTL_POOLTAG    MRXSMB_DEFINE_POOLTAG('cDmS',MRXSMB_MISC_POOLTAG)
#define MRXSMB_DEFROPEN_POOLTAG  MRXSMB_DEFINE_POOLTAG('ODmS',MRXSMB_MISC_POOLTAG)
#define MRXSMB_QPINFO_POOLTAG    MRXSMB_DEFINE_POOLTAG('PQmS',MRXSMB_MISC_POOLTAG)
#define MRXSMB_RXCONTEXT_POOLTAG MRXSMB_DEFINE_POOLTAG('xRmS',MRXSMB_MISC_POOLTAG)

#define MRXSMB_VNETROOT_POOLTAG  MRXSMB_DEFINE_POOLTAG('rVmS',MRXSMB_CE_POOLTAG)
#define MRXSMB_SERVER_POOLTAG    MRXSMB_DEFINE_POOLTAG('rSmS',MRXSMB_CE_POOLTAG)
#define MRXSMB_SESSION_POOLTAG   MRXSMB_DEFINE_POOLTAG('eSmS',MRXSMB_CE_POOLTAG)
#define MRXSMB_NETROOT_POOLTAG   MRXSMB_DEFINE_POOLTAG('rNmS',MRXSMB_CE_POOLTAG)

#define MRXSMB_MIDATLAS_POOLTAG  MRXSMB_DEFINE_POOLTAG('aMmS', MRXSMB_CE_POOLTAG)

#define MRXSMB_VC_POOLTAG        MRXSMB_DEFINE_POOLTAG('cVmS',MRXSMB_CE_POOLTAG)

#define MRXSMB_ECHO_POOLTAG      MRXSMB_DEFINE_POOLTAG('cEmS',MRXSMB_ADMIN_POOLTAG)

// NodeType Codes

#define SMB_EXCHANGE_CATEGORY             (0xed)
#define SMB_CONNECTION_ENGINE_DB_CATEGORY (0xea)
#define SMB_SERVER_TRANSPORT_CATEGORY     (0xeb)

#define SMB_EXCHANGE_NTC(x) \
        ((SMB_EXCHANGE_CATEGORY << 8) | (x))

#define SMB_CONNECTION_ENGINE_NTC(x)    \
        ((SMB_CONNECTION_ENGINE_DB_CATEGORY << 8) | (x))

#define SMB_NTC_STUFFERSTATE  0xed80

#endif _SMBPOOLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbprocs.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    smbprocs.h

Abstract:

    Prototypes for routines that cross protocol-selection boundaries

--*/

#ifndef _SMBPROCS_H_
#define _SMBPROCS_H_

#include "tdikrnl.h"

//cross-referenced internal routines

//from rename.c
MRxSmbRename(
      IN PRX_CONTEXT            RxContext
      );

//from openclos.c
NTSTATUS
MRxSmbBuildClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbBuildFindClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

PSMBCE_TRANSPORT
SmbCeFindTransport(
    PUNICODE_STRING pTransportName);

//paged internal routines


NTSTATUS
MRxSmbGetStatistics(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbSetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbQueryQuotaInformation (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbSetQuotaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbLoadEaList(
    IN PRX_CONTEXT RxContext,
    IN PUCHAR  UserEaList,
    IN ULONG   UserEaListLength,
    OUT PFEALIST *ServerEaList
    );

VOID
MRxSmbNtGeaListToOs2 (
    IN PFILE_GET_EA_INFORMATION NtGetEaList,
    IN ULONG GeaListLength,
    IN PGEALIST GeaList
    );

PGEA
MRxSmbNtGetEaToOs2 (
    OUT PGEA Gea,
    IN PFILE_GET_EA_INFORMATION NtGetEa
    );

NTSTATUS
MRxSmbQueryEasFromServer(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList,
    IN PVOID Buffer,
    IN OUT PULONG BufferLengthRemaining,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN UserEaListSupplied
    );

ULONG
MRxSmbNtFullEaSizeToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

VOID
MRxSmbNtFullListToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtEaList,
    IN PFEALIST FeaList
    );

PVOID
MRxSmbNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

NTSTATUS
MRxSmbSetEaList(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList
    );

NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    RX_FILE_TYPE StorageType,
    SMB_FILE_ID Fid,
    ULONG ServerVersion,
    UCHAR OplockLevel,
    ULONG CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    );

NTSTATUS
SmbConstructNetRootExchangeFinalize(
         PSMB_EXCHANGE pExchange,
         BOOLEAN       *pPostFinalize);

VOID
__MRxSmbAllocateSideBuffer(
    IN OUT PRX_CONTEXT     RxContext,
    IN OUT PMRX_SMB_FOBX   smbFobx,
    IN     USHORT          Setup
#if DBG
    ,IN     PUNICODE_STRING smbtemplate
#endif
    );

VOID
MRxSmbDeallocateSideBuffer(
    IN OUT PRX_CONTEXT    RxContext,
    IN OUT PMRX_SMB_FOBX  smbFobx,
    IN     PSZ            where
    );

VOID
MRxSmbTranslateLanManFindBuffer(
    PRX_CONTEXT RxContext,
    PULONG PreviousReturnedEntry,
    PBYTE ThisEntryInBuffer
    );

NTSTATUS
MrxSmbUnalignedDirEntryCopyTail(
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID                  pBuffer,
    IN OUT PULONG                 pLengthRemaining,
    IN OUT PMRX_SMB_FOBX          smbFobx
    );

NTSTATUS
MRxSmbQueryDirectory(
    IN OUT PRX_CONTEXT            RxContext
    );

NTSTATUS
MRxSmbQueryVolumeInformation(
      IN OUT PRX_CONTEXT          RxContext
      );

NTSTATUS
MRxSmbQueryVolumeInformationWithFullBuffer(
      IN OUT PRX_CONTEXT          RxContext
      );

NTSTATUS
MRxSmbSetVolumeInformation(
      IN OUT PRX_CONTEXT              pRxContext
      );

    NTSTATUS
MRxSmbSetFileInformation (
      IN PRX_CONTEXT  RxContext
      );

NTSTATUS
MRxSmbSetFileInformationAtCleanup(
      IN PRX_CONTEXT            RxContext
      );

NTSTATUS
MRxSmbIsValidDirectory(
    IN OUT PRX_CONTEXT    RxContext,
    IN PUNICODE_STRING    DirectoryName
    );

NTSTATUS
MRxSmbFabricateAttributesOnNetRoot(
    IN OUT PSMBCE_NET_ROOT  psmbNetRoot,
    IN     PSMBCE_SERVER    pServer 
    );

NTSTATUS
MRxSmbCoreInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN     ULONG                InformationClass,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength,
      IN     SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint
      );

NTSTATUS
MRxSmbLoadCoreFileSearchBuffer(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

VOID MRxSmbCoreFileSeach_AssertFields(void);

NTSTATUS
MRxSmbCoreFileSearch(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MrxSmbOemVolumeInfoToUnicode(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG *VolumeLabelLengthReturned
    );

MrxSmbCoreQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MrxSmbQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MrxSmbCoreQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MrxSmbQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

 NTSTATUS
SmbPseExchangeStart_CoreInfo(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbFinishSearch (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_SEARCH                Response
      );

NTSTATUS
MRxSmbFinishQueryDiskInfo (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PRESP_QUERY_INFORMATION_DISK Response
      );

NTSTATUS
MRxSmbExtendForCache(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

NTSTATUS
MRxSmbExtendForNonCache(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

NTSTATUS
MRxSmbGetNtAllocationInfo (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
__MRxSmbSimpleSyncTransact2(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType,
    IN ULONG TransactSetupCode,
    IN PVOID Params,
    IN ULONG ParamsLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN PSMB_PSE_OE_T2_FIXUP_ROUTINE FixupRoutine
    );

NTSTATUS
MRxSmbFinishTransaction2 (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_TRANSACTION           Response
      );

NTSTATUS
MRxSmbFsCtl(
      IN OUT PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbIoCtl(
      IN OUT PRX_CONTEXT RxContext);

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MRxSmbInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN enum _MRXSMB_INIT_STATES MRxSmbInitState
    );

VOID
MRxSmbUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
MRxSmbStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
MRxSmbStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
MRxSmbInitializeSecurity (VOID);

NTSTATUS
MRxSmbUninitializeSecurity(VOID);

NTSTATUS
SmbCeGetConfigurationInformation();

NTSTATUS
MRxSmbFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MRxSmbDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
MRxSmbDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    );

NTSTATUS
MRxSmbGetUlongRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    BOOLEAN LogFailure
    );

NTSTATUS
MRxSmbInitializeTables(void);

NTSTATUS
MRxSmbLocks(
      IN PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbBuildLocksAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState);

NTSTATUS
MRxSmbBuildLockAssert (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
SmbPseExchangeStart_Locks(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbFinishLocks (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_LOCKING_ANDX             Response
      );

NTSTATUS
MRxSmbUnlockRoutine (
    IN PRX_CONTEXT RxContext,
    IN PFILE_LOCK_INFO LockInfo
    );

NTSTATUS
MRxSmbCompleteBufferingStateChangeRequest(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    );

NTSTATUS
MRxSmbBuildFlush (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbFlush(
      IN PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbIsLockRealizable (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    );

NTSTATUS
MRxSmbFinishFlush (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_FLUSH             Response
      );


VOID
_InitializeMidMapFreeList(struct _MID_MAP_ *pMidMap);

PMID_ATLAS
FsRtlCreateMidAtlas(
   USHORT MaximumNumberOfMids,
   USHORT MidsAllocatedAtStart);

VOID
_UninitializeMidMap(
         struct _MID_MAP_    *pMidMap,
         PCONTEXT_DESTRUCTOR pContextDestructor);

VOID
FsRtlDestroyMidAtlas(
   PMID_ATLAS          pMidAtlas,
   PCONTEXT_DESTRUCTOR pContextDestructor);

NTSTATUS
BuildSessionSetupSecurityInformation(
    PSMB_EXCHANGE   pExchange,
    PBYTE           pSmbBuffer,
    PULONG          pSmbBufferSize);

NTSTATUS
BuildTreeConnectSecurityInformation(
    PSMB_EXCHANGE  pExchange,
    PBYTE          pBuffer,
    PBYTE          pPasswordLength,
    PULONG         pSmbBufferSize);

VOID
MRxSmbMungeBufferingIfWriteOnlyHandles (
    ULONG WriteOnlySrvOpenCount,
    PMRX_SRV_OPEN SrvOpen
    );

BOOLEAN
IsReconnectRequired(
      PMRX_SRV_CALL SrvCall);

BOOLEAN
MRxSmbIsCreateWithEasSidsOrLongName(
      IN OUT PRX_CONTEXT RxContext,
      OUT    PULONG      DialectFlags
      );

NTSTATUS
MRxSmbShouldTryToCollapseThisOpen (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbCreate (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbDeferredCreate (
      IN OUT PRX_CONTEXT RxContext
      );

NTSTATUS
MRxSmbCollapseOpen(
      IN OUT PRX_CONTEXT RxContext
      );

NTSTATUS
MRxSmbComputeNewBufferingState(
   IN OUT PMRX_SRV_OPEN   pMRxSrvOpen,
   IN     PVOID           pMRxContext,
      OUT PULONG          pNewBufferingState);

NTSTATUS
MRxSmbConstructDeferredOpenContext (
    IN OUT PRX_CONTEXT RxContext
      );

VOID
MRxSmbAdjustCreateParameters (
    PRX_CONTEXT RxContext,
    PMRXSMB_CREATE_PARAMETERS smbcp
    );

VOID
MRxSmbAdjustReturnedCreateAction(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbBuildNtCreateAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PMRXSMB_CREATE_PARAMETERS smbcp
    );

NTSTATUS
MRxSmbBuildOpenAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PMRXSMB_CREATE_PARAMETERS smbcp
    );

NTSTATUS
SmbPseExchangeStart_Create(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

VOID
MRxSmbSetSrvOpenFlags (
    PRX_CONTEXT  RxContext,
    RX_FILE_TYPE StorageType,
    PMRX_SRV_OPEN SrvOpen,
    PMRX_SMB_SRV_OPEN smbSrvOpen
    );

NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    RX_FILE_TYPE StorageType,
    SMB_FILE_ID Fid,
    ULONG ServerVersion,
    UCHAR OplockLevel,
    ULONG CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    );

NTSTATUS
MRxSmbFinishNTCreateAndX (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_NT_CREATE_ANDX        Response
      );

NTSTATUS
MRxSmbFinishOpenAndX (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_OPEN_ANDX        Response
      );

NTSTATUS
MRxSmbFinishT2OpenFile (
    IN OUT PRX_CONTEXT            RxContext,
    IN     PRESP_OPEN2            Response,
    IN OUT PBOOLEAN               MustRegainExclusiveResource,
    IN     ULONG                  ServerVersion
    );

NTSTATUS
MRxSmbT2OpenFile(
      IN OUT PRX_CONTEXT RxContext
      );

NTSTATUS
MRxSmbFinishLongNameCreateFile (
    IN OUT PRX_CONTEXT                RxContext,
    IN     PRESP_CREATE_WITH_SD_OR_EA Response,
    IN     PBOOLEAN                   MustRegainExclusiveResource,
    IN     ULONG                      ServerVersion
    );

NTSTATUS
MRxSmbCreateWithEasSidsOrLongName(
      IN OUT PRX_CONTEXT RxContext
      );

NTSTATUS
MRxSmbZeroExtend(
      IN PRX_CONTEXT pRxContext);

NTSTATUS
MRxSmbTruncate(
      IN PRX_CONTEXT pRxContext);

NTSTATUS
MRxSmbCleanupFobx(
      IN PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbForcedClose(
      IN PMRX_SRV_OPEN pSrvOpen);

NTSTATUS
MRxSmbCloseSrvOpen(
      IN     PRX_CONTEXT   RxContext
      );

NTSTATUS
MRxSmbBuildClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbBuildFindClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
SmbPseExchangeStart_Close(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbFinishClose (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CLOSE                 Response
      );

NTSTATUS
MRxSmbGetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCoreDeleteForSupercedeOrClose(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    BOOLEAN DeleteDirectory
    );

NTSTATUS
MRxSmbCoreCheckPath(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCoreOpen(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    OpenShareMode,
    ULONG    Attribute
    );

NTSTATUS
MRxSmbSetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG SmbAttributes
    );

NTSTATUS
MRxSmbCoreCreateDirectory(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    Attribute,
    BOOLEAN CreateNew
    );

NTSTATUS
MRxSmbCloseAfterCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCoreTruncate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG Fid,
    ULONG FileTruncationPoint
    );

NTSTATUS
MRxSmbDownlevelCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbFinishCoreCreate (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CREATE                Response
      );

VOID
MRxSmbPopulateFileInfoInOE(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    USHORT FileAttributes,
    ULONG LastWriteTimeInSeconds,
    ULONG FileSize
    );

NTSTATUS
MRxSmbFinishCoreOpen (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_OPEN                  Response
      );

NTSTATUS
MRxSmbPseudoOpenTailFromCoreCreateDirectory (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      USHORT Attributes
      );

NTSTATUS
MRxSmbPseudoOpenTailFromFakeGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      RX_FILE_TYPE StorageType
      );

NTSTATUS
MRxSmbPseudoOpenTailFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      );

LARGE_INTEGER
MRxSmbConvertSmbTimeToTime (
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    IN SMB_TIME Time,
    IN SMB_DATE Date
    );

BOOLEAN
MRxSmbConvertTimeToSmbTime (
    IN PLARGE_INTEGER InputTime,
    IN PSMB_EXCHANGE Exchange OPTIONAL,
    OUT PSMB_TIME Time,
    OUT PSMB_DATE Date
    );

BOOLEAN
MRxSmbTimeToSecondsSince1970 (
    IN PLARGE_INTEGER CurrentTime,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PULONG SecondsSince1970
    );

VOID
MRxSmbSecondsSince1970ToTime (
    IN ULONG SecondsSince1970,
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server,
    OUT PLARGE_INTEGER CurrentTime
    );

ULONG
MRxSmbMapSmbAttributes (
    IN USHORT SmbAttribs
    );

USHORT
MRxSmbMapDisposition (
    IN ULONG Disposition
    );

ULONG
MRxSmbUnmapDisposition (
    IN USHORT SmbDisposition,
    ULONG     Disposition
    );

USHORT
MRxSmbMapDesiredAccess (
    IN ULONG DesiredAccess
    );

USHORT
MRxSmbMapShareAccess (
    IN USHORT ShareAccess
    );

USHORT
MRxSmbMapFileAttributes (
    IN ULONG FileAttributes
    );

NTSTATUS
MRxSmbRead(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbBuildReadAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PLARGE_INTEGER ByteOffsetAsLI,
    ULONG ByteCount,
    ULONG RemainingBytes
    );

NTSTATUS
MRxSmbBuildCoreRead (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PLARGE_INTEGER ByteOffsetAsLI,
    ULONG ByteCount,
    ULONG RemainingBytes
    );

NTSTATUS
MRxSmbBuildSmallRead (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PLARGE_INTEGER ByteOffsetAsLI,
    ULONG ByteCount,
    ULONG RemainingBytes
    );

NTSTATUS
SmbPseExchangeStart_Read(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbFinishNoCopyRead (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      );

MRxSmbRename(
      IN PRX_CONTEXT            RxContext
      );

NTSTATUS
MRxSmbBuildRename (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbBuildDeleteForRename (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
SmbPseExchangeStart_Rename(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbFinishRename (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_RENAME                 Response
      );

NTSTATUS
MRxSmbBuildCheckEmptyDirectory (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
SmbPseExchangeStart_SetDeleteDisposition(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

MRxSmbSetDeleteDisposition(
      IN PRX_CONTEXT            RxContext
      );

VOID
MRxSmbInitializeRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext,
    PRECURRENT_SERVICE_ROUTINE pServiceRoutine,
    PVOID                      pServiceRoutineParameter,
    PLARGE_INTEGER             pTimeInterval);

VOID
MRxSmbCancelRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext);

VOID
MRxSmbRecurrentServiceDispatcher(
    PVOID   pContext);

NTSTATUS
MRxSmbActivateRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext);

NTSTATUS
MRxSmbInitializeRecurrentServices();

VOID
MRxSmbTearDownRecurrentServices();

NTSTATUS
MRxSmbInitializeScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext);

VOID
MRxSmbTearDownScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext);

NTSTATUS
SmbCeNegotiate(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PMRX_SRV_CALL         pSrvCall);

NTSTATUS
SmbCeSendEchoProbe(
    PSMBCEDB_SERVER_ENTRY              pServerEntry,
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext);

NTSTATUS
SmbCeDisconnect(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext);

NTSTATUS
SmbCeLogOff(
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry);

NTSTATUS
SmbCeInitializeAdminExchange(
    PSMB_ADMIN_EXCHANGE     pSmbAdminExchange,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    UCHAR                   SmbCommand);

VOID
SmbCeDiscardAdminExchange(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange);

NTSTATUS
SmbCeCompleteAdminExchange(
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange);

NTSTATUS
SmbAdminExchangeStart(
    PSMB_EXCHANGE  pExchange);

VOID
SmbCeCreateSrvCall(
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext);

NTSTATUS
MRxSmbCreateSrvCall(
    PMRX_SRV_CALL                  pSrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext);

NTSTATUS
MRxSmbFinalizeSrvCall(
    PMRX_SRV_CALL pSrvCall,
    BOOLEAN       Force);

NTSTATUS
MRxSmbSrvCallWinnerNotify(
    IN PMRX_SRV_CALL  pSrvCall,
    IN BOOLEAN        ThisMinirdrIsTheWinner,
    IN OUT PVOID      pSrvCallContext);

NTSTATUS
MRxSmbInitializeEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext);

VOID
MRxSmbTearDownEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext);

NTSTATUS
BuildNegotiateSmb(
    PVOID    *pSmbBufferPointer,
    PULONG   pSmbBufferLength);

LARGE_INTEGER
ConvertSmbTimeToTime (
    IN SMB_TIME Time,
    IN SMB_DATE Date
    );

VOID
__SmbPseDbgCheckOEMdls(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line
    );

NTSTATUS
SmbPseContinueOrdinaryExchange(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
SmbPseOrdinaryExchange(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN     SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType
    );

NTSTATUS
__SmbPseCreateOrdinaryExchange (
    IN PRX_CONTEXT RxContext,
    IN PMRX_V_NET_ROOT VNetRoot,
    IN SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint,
    IN PSMB_PSE_OE_START_ROUTINE StartRoutine,
    OUT PSMB_PSE_ORDINARY_EXCHANGE *OrdinaryExchangePtr
    );

VOID
SmbPseFinalizeOETrace(PSZ text,ULONG finalstate);

BOOLEAN
SmbPseFinalizeOrdinaryExchange (
    IN OUT PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    );

NTSTATUS
SmbPseExchangeAssociatedExchangeCompletionHandler_default(
    IN OUT PSMB_EXCHANGE  pExchange,
    OUT    BOOLEAN        *pPostFinalize
    );

NTSTATUS
SmbPseExchangeStart_default(
    IN PSMB_EXCHANGE    pExchange
    );

NTSTATUS
SmbPseExchangeCopyDataHandler_Read(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pCopyDataBuffer,
    IN ULONG            CopyDataSize
    );

VOID
__SmbPseRMTableEntry(
    UCHAR SmbCommand,
    UCHAR Flags,
    SMBPSE_RECEIVE_HANDLER_TOKEN ReceiveHandlerToken,
    PSMBPSE_RECEIVE_HANDLER ReceiveHandler
#if DBG
    ,
    PBYTE IndicationString,
    SMB_PSE_ORDINARY_EXCHANGE_TYPE LowType,
    SMB_PSE_ORDINARY_EXCHANGE_TYPE HighType
#endif
    );

VOID
SmbPseInitializeTables(
    void
    );

NTSTATUS
SmbMrxFinalizeStufferFacilities(
    void
    );

NTSTATUS
MRxSmbSetInitialSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    STUFFERTRACE_CONTROLPOINT_ARGS
    );

NTSTATUS
MRxSmbStartSMBCommand (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     INITIAL_SMBBUG_DISPOSITION InitialSMBDisposition,
    IN UCHAR Command,
    IN ULONG MaximumBufferUsed,
    IN ULONG MaximumSize,
    IN ULONG InitialAlignment,
    IN ULONG MaximumResponseHeader,
    IN UCHAR Flags,
    IN UCHAR FlagsMask,
    IN USHORT Flags2,
    IN USHORT Flags2Mask
    STUFFERTRACE_CONTROLPOINT_ARGS
    );

BOOLEAN
MrxSMBWillThisFit(
    IN PSMBSTUFFER_BUFFER_STATE StufferState,
    IN ULONG AlignmentUnit,
    IN ULONG DataSize
    );

NTSTATUS
MRxSmbStuffSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    ...
    );

VOID
MRxSmbStuffAppendRawData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    );

VOID
MRxSmbStuffAppendSmbData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    );

VOID
MRxSmbStuffSetByteCount(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbWrite (
      IN PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbBuildWriteRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    BOOLEAN                    IsPagingIo,
    UCHAR                      WriteCommand,
    ULONG                      ByteCount,
    PLARGE_INTEGER             ByteOffsetAsLI,
    PBYTE                      Buffer,
    PMDL                       BufferAsMdl);

NTSTATUS
SmbPseExchangeStart_Write (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
BuildCanonicalNetRootInformation(
            PUNICODE_STRING     pServerName,
            PUNICODE_STRING     pNetRootName,
            NET_ROOT_TYPE       NetRootType,
            BOOLEAN             fUnicode,
            BOOLEAN             fPostPendServiceString,
            PBYTE               *pBufferPointer,
            PULONG              pBufferSize);

NTSTATUS
CoreBuildTreeConnectSmb(
            PSMB_EXCHANGE     pExchange,
            PGENERIC_ANDX     pAndXSmb,
            PULONG            pAndXSmbBufferSize);

NTSTATUS
LmBuildTreeConnectSmb(
            PSMB_EXCHANGE     pExchange,
            PGENERIC_ANDX     pAndXSmb,
            PULONG            pAndXSmbBufferSize);

NTSTATUS
NtBuildTreeConnectSmb(
            PSMB_EXCHANGE     pExchange,
            PGENERIC_ANDX     pAndXSmb,
            PULONG            pAndXSmbBufferSize);

NTSTATUS
MRxSmbUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot);

ULONG
MRxSmbGetDialectFlagsFromSrvCall(
    PMRX_SRV_CALL SrvCall
    );

NTSTATUS
MRxSmbCreateVNetRoot(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

NTSTATUS
MRxSmbFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN        ForceDisconnect);

NTSTATUS
MRxSmbFinalizeNetRoot(
    IN PMRX_NET_ROOT   pNetRoot,
    IN PBOOLEAN        ForceDisconnect);

NTSTATUS
SmbCeReconnect(
    IN PMRX_V_NET_ROOT            pVNetRoot);

NTSTATUS
SmbCeEstablishConnection(
    IN OUT PMRX_V_NET_ROOT        pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext,
    IN BOOLEAN                    fInitializeNetRoot
    );

NTSTATUS
SmbConstructNetRootExchangeStart(
      PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbConstructNetRootExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL       pCopyDataBuffer,
    IN ULONG            DataSize);

NTSTATUS
SmbConstructNetRootExchangeFinalize(
         PSMB_EXCHANGE pExchange,
         BOOLEAN       *pPostFinalize);

VOID
MRxSmbExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

NTSTATUS
MRxSmbInitializeSmbCe();

NTSTATUS
SmbCeReferenceServer(
    PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbCeReferenceSession(
    PSMB_EXCHANGE   pExchange);

NTSTATUS
SmbCeReferenceNetRoot(
    PSMB_EXCHANGE   pExchange);

NTSTATUS
SmbCeInitiateExchange(
    PSMB_EXCHANGE pExchange);

NTSTATUS
SmbCeInitiateAssociatedExchange(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       EnableCompletionHandlerInMasterExchange);

NTSTATUS
SmbCeExchangeAbort(
    PSMB_EXCHANGE pExchange);

NTSTATUS
SmbCeBuildSmbHeader(
    IN OUT PSMB_EXCHANGE     pExchange,
    IN OUT PVOID             pBuffer,
    IN     ULONG             BufferLength,
    OUT    PULONG            pBufferConsumed,
    OUT    PUCHAR            pLastCommandInHeader,
    OUT    PUCHAR            *pNextCommandPtr);

NTSTATUS
SmbCeResumeExchange(
    PSMB_EXCHANGE pExchange);

NTSTATUS
SmbCepInitializeExchange(
    PSMB_EXCHANGE                 *pExchangePointer,
    PRX_CONTEXT                   pRxContext,
    PSMBCEDB_SERVER_ENTRY         pServerEntry,
    PMRX_V_NET_ROOT               pVNetRoot,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

NTSTATUS
SmbCeInitializeAssociatedExchange(
    PSMB_EXCHANGE                 *pAssociatedExchangePointer,
    PSMB_EXCHANGE                 pMasterExchange,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

NTSTATUS
SmbCeTransformExchange(
    PSMB_EXCHANGE                 pExchange,
    SMB_EXCHANGE_TYPE             NewType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

NTSTATUS
SmbCePrepareExchangeForReuse(
    PSMB_EXCHANGE                 pExchange);

VOID
SmbCeDiscardExchange(PVOID pExchange);

VOID
SmbCeDiscardExchangeWorkerThreadRoutine(PVOID pExchange);

NTSTATUS
SmbCeCancelExchange(
    PRX_CONTEXT pRxContext);

VOID
SmbCeFinalizeExchangeWorkerThreadRoutine(
    PSMB_EXCHANGE  pExchange);

VOID
SmbCepFinalizeExchange(
    PSMB_EXCHANGE pExchange);

BOOLEAN
SmbCeCanExchangeBeFinalized(
    PSMB_EXCHANGE pExchange,
    PSMBCE_EXCHANGE_STATUS pExchangeStatus);

VOID
SmbCeFinalizeExchangeOnDisconnect(
    PSMB_EXCHANGE pExchange);

VOID
SmbCeSetExpiryTime(
    PSMB_EXCHANGE pExchange);

BOOLEAN
SmbCeDetectExpiredExchanges(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

NTSTATUS
DefaultSmbExchangeIndError(
    IN PSMB_EXCHANGE pExchange);

NTSTATUS
DefaultSmbExchangeIndReceive(
    IN PSMB_EXCHANGE    pExchange);

NTSTATUS
DefaultSmbExchangeIndSendCallback(
    IN PSMB_EXCHANGE    pExchange);

VOID
MRxSmbBindTransportCallback(
    IN PUNICODE_STRING pTransportName
);

VOID
MRxSmbUnbindTransportCallback(
    IN PUNICODE_STRING pTransportName
);

NTSTATUS
MRxSmbRegisterForPnpNotifications();

VOID
MRxSmbpBindTransportCallback(
    IN struct _TRANSPORT_BIND_CONTEXT_ *pTransportContext);

VOID
MRxSmbpBindTransportWorkerThreadRoutine(
    IN struct _TRANSPORT_BIND_CONTEXT_ *pTransportContext);

VOID
MRxSmbpUnbindTransportCallback(
    PSMBCE_TRANSPORT pTransport);

NTSTATUS
MRxSmbDeregisterForPnpNotifications();

NTSTATUS
SmbCeDereferenceTransportArray(
    PSMBCE_TRANSPORT_ARRAY pTransportArray);

NTSTATUS
SmbCeInitializeTransactionParameters(
   PVOID  pSetup,
   USHORT SetupLength,
   PVOID  pParam,
   ULONG  ParamLength,
   PVOID  pData,
   ULONG  DataLength,
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters
);

VOID
SmbCeUninitializeTransactionParameters(
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters
);

VOID
SmbCeDiscardTransactExchange(PSMB_TRANSACT_EXCHANGE pTransactExchange);

NTSTATUS
SmbCeSubmitTransactionRequest(
    PRX_CONTEXT                           RxContext,
    PSMB_TRANSACTION_OPTIONS              pOptions,
    PSMB_TRANSACTION_PARAMETERS           pSendParameters,
    PSMB_TRANSACTION_PARAMETERS           pReceiveParameters,
    PSMB_TRANSACTION_RESUMPTION_CONTEXT   pResumptionContext );

NTSTATUS
_SmbCeTransact(
   PRX_CONTEXT                         RxContext,
   PSMB_TRANSACTION_OPTIONS            pOptions,
   PVOID                               pInputSetupBuffer,
   ULONG                               InputSetupBufferLength,
   PVOID                               pOutputSetupBuffer,
   ULONG                               OutputSetupBufferLength,
   PVOID                               pInputParamBuffer,
   ULONG                               InputParamBufferLength,
   PVOID                               pOutputParamBuffer,
   ULONG                               OutputParamBufferLength,
   PVOID                               pInputDataBuffer,
   ULONG                               InputDataBufferLength,
   PVOID                               pOutputDataBuffer,
   ULONG                               OutputDataBufferLength,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext);

NTSTATUS
SmbTransactBuildHeader(
    PSMB_TRANSACT_EXCHANGE  pTransactExchange,
    UCHAR                   SmbCommand,
    PSMB_HEADER             pHeader);

NTSTATUS
SmbTransactExchangeStart(
      PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbTransactExchangeAbort(
      PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbTransactExchangeErrorHandler(
    IN PSMB_EXCHANGE pExchange);

NTSTATUS
SmbTransactExchangeSendCallbackHandler(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus);

NTSTATUS
SmbTransactExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pDataBuffer,
    IN ULONG            DataSize);

NTSTATUS
SmbCeInitializeTransactExchange(
    PSMB_TRANSACT_EXCHANGE              pTransactExchange,
    PRX_CONTEXT                         RxContext,
    PSMB_TRANSACTION_OPTIONS            pOptions,
    PSMB_TRANSACTION_SEND_PARAMETERS    pSendParameters,
    PSMB_TRANSACTION_RECEIVE_PARAMETERS pReceiveParameters,
    PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext);

NTSTATUS
SmbTransactExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize);

NTSTATUS
SendSecondaryRequests(PVOID pContext);

NTSTATUS SmbMmInit();

VOID SmbMmTearDown();

VOID
SmbCeCompleteVNetRootContextInitialization(
    PVOID  pContext);

VOID
SmbCepDereferenceVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext);

NTSTATUS
SmbCeDestroyAssociatedVNetRootContext(
    PMRX_V_NET_ROOT pVNetRoot);

VOID
SmbCeTearDownVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext);

VOID
SmbCeDecrementNumberOfActiveVNetRootOnSession(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext
    );

NTSTATUS
SmbCeScavenger(
    PVOID pContext);

NTSTATUS
SmbCeScavengeRelatedContexts(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

BOOLEAN
SmbCeIsReconnectionRequired(
    PSMB_EXCHANGE  pExchange,
    PRX_CONTEXT    pRxContext);

VOID
MRxSmbCreateFileInfoCache(
    PRX_CONTEXT             RxContext,
    PSMBPSE_FILEINFO_BUNDLE FileInfo,
    NTSTATUS                Status);

VOID
MRxSmbCreateBasicFileInfoCache(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                Status);

VOID
MRxSmbCreateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status);

VOID
MRxSmbUpdateFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status);

VOID
MRxSmbUpdateBasicFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status);

VOID
MRxSmbUpdateStandardFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status);

VOID
MRxSmbInvalidateFileInfoCache(
    PRX_CONTEXT     RxContext);

VOID
MRxSmbInvalidateBasicFileInfoCache(
    PRX_CONTEXT     RxContext);

VOID
MRxSmbInvalidateStandardFileInfoCache(
    PRX_CONTEXT     RxContext);

VOID
MRxSmbUpdateFileInfoCacheFileSize(
    PRX_CONTEXT     RxContext,
    PLARGE_INTEGER  FileSize);

VOID
MRxSmbUpdateBasicFileInfoCache(
    PRX_CONTEXT     RxContext,
    ULONG           FileAttributes,
    PLARGE_INTEGER  pLastWriteTime);

VOID
MRxSmbUpdateBasicFileInfoCacheAll(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic);

VOID
MRxSmbUpdateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    BOOLEAN                    IsDirectory);

BOOLEAN
MRxSmbIsFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PSMBPSE_FILEINFO_BUNDLE FileInfo,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName);

BOOLEAN
MRxSmbIsBasicFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName);

BOOLEAN
MRxSmbIsStandardFileInfoCacheFound(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   *Status,
    PUNICODE_STRING            OriginalFileName);

NTSTATUS
MRxSmbGetFileInfoCacheStatus(
    PRX_CONTEXT RxContext);

BOOLEAN
MRxSmbIsFileNotFoundCached(
    PRX_CONTEXT RxContext);

VOID
MRxSmbCacheFileNotFound(
    PRX_CONTEXT RxContext);

VOID
MRxSmbInvalidateFileNotFoundCache(
    PRX_CONTEXT     RxContext);

BOOLEAN
MRxSmbIsStreamFile(
    PUNICODE_STRING FileName,
    PUNICODE_STRING AdjustFileName);

VOID
MRxSmbUpdateFileInfoCacheFromDelete(
    PRX_CONTEXT     RxContext);

NTSTATUS
MRxSmbQueryFileInformationFromPseudoOpen(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE);

BOOLEAN
MRxSmbIsLongFileName(
    PRX_CONTEXT     RxContext);

PVOID
SmbMmAllocateObject(SMBCEDB_OBJECT_TYPE ObjectType);

VOID
SmbMmFreeObject(PVOID pObject);

PSMBCEDB_SESSION_ENTRY
SmbMmAllocateSessionEntry(PSMBCEDB_SERVER_ENTRY pServerEntry );

VOID
SmbMmFreeSessionEntry(PSMBCEDB_SESSION_ENTRY pSessionEntry);

PVOID
SmbMmAllocateExchange(
    SMB_EXCHANGE_TYPE ExchangeType,
    PVOID             pv);

VOID
SmbMmFreeExchange(PVOID pExchange);

PVOID
SmbMmAllocateServerTransport(SMBCE_SERVER_TRANSPORT_TYPE ServerTransportType);

VOID
SmbMmFreeServerTransport(PSMBCE_SERVER_TRANSPORT);

NTSTATUS
BuildSessionSetupSecurityInformation(
            PSMB_EXCHANGE pExchange,
            PBYTE           pSmbBuffer,
            PULONG          pSmbBufferSize);

NTSTATUS
BuildNtLanmanResponsePrologue(
   PSMB_EXCHANGE              pExchange,
   PUNICODE_STRING            pUserName,
   PUNICODE_STRING            pDomainName,
   PSTRING                    pCaseSensitiveResponse,
   PSTRING                    pCaseInsensitiveResponse,
   PSECURITY_RESPONSE_CONTEXT pResponseContext);

NTSTATUS
BuildNtLanmanResponseEpilogue(
   PSMB_EXCHANGE              pExchange,
   PSECURITY_RESPONSE_CONTEXT pResponseContext);

#define SmbMmInitializeHeader(pHeader)                        \
         RtlZeroMemory((pHeader),sizeof(SMBCE_OBJECT_HEADER))

#endif   // _SMBPROCS_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbpse.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    SmbPse.h

Abstract:

    This module defines the types and functions related to the SMB protocol
    selection engine: the component that translates minirdr calldowns into
    SMBs.

--*/

#ifndef _SMBPSE_H_
#define _SMBPSE_H_

IMPORTANT_STRUCTURE(SMB_PSE_ORDINARY_EXCHANGE);

#define StorageType(co) ((co) & FILE_STORAGE_TYPE_MASK)
#define StorageFlag(co) ((co) & FILE_STORAGE_TYPE_SPECIFIED)
#define IsStorageTypeSpecified(co)  (StorageFlag(co) == FILE_STORAGE_TYPE_SPECIFIED)

#define MustBeDirectory(co) ((co) & FILE_DIRECTORY_FILE)
#define MustBeFile(co)      ((co) & FILE_NON_DIRECTORY_FILE)

#define CLUSTER_SIZE 0x1000

#define SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE \
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange, \
    PRX_CONTEXT RxContext

#define SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS \
    OrdinaryExchange,RxContext

#if DBG
#define OECHKLINKAGE_FLAG_NO_REQPCKT_CHECK 0x00000001

VOID
__SmbPseOEAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSMBSTUFFER_BUFFER_STATE StufferState,
    ULONG Flags
    );
#define SmbPseOEAssertConsistentLinkage(a) {\
   __SmbPseOEAssertConsistentLinkage(a,__FILE__,__LINE__,RxContext,OrdinaryExchange,StufferState,0);\
   }
#define SmbPseOEAssertConsistentLinkageFromOE(a) {\
    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);                        \
   __SmbPseOEAssertConsistentLinkage(a,__FILE__,__LINE__,              \
                                     OrdinaryExchange->RxContext,      \
                                     OrdinaryExchange,                 \
                                     &OrdinaryExchange->AssociatedStufferState,0);  \
   }
#define SmbPseOEAssertConsistentLinkageFromOEwithFlags(a,FLAGS) {\
    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);                        \
   __SmbPseOEAssertConsistentLinkage(a,__FILE__,__LINE__,              \
                                     OrdinaryExchange->RxContext,      \
                                     OrdinaryExchange,                 \
                                     &OrdinaryExchange->AssociatedStufferState,FLAGS);  \
   }
#else
#define SmbPseOEAssertConsistentLinkage(a) {NOTHING;}
#define SmbPseOEAssertConsistentLinkageFromOE(a) {NOTHING;}
#define SmbPseOEAssertConsistentLinkageFromOEwithFlags(a,b) {NOTHING;}
#endif

typedef
NTSTATUS
(*PSMB_PSE_OE_START_ROUTINE) (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

typedef
NTSTATUS
(*PSMB_PSE_CONTINUATION_ROUTINE) (
    PSMB_PSE_ORDINARY_EXCHANGE
    );

#define SMBPSE_OE_HISTORY_SIZE 32
typedef struct _SMBPSE_HISTORY {
    ULONG Next;
    ULONG Submits; //could be shortened....
    struct {
        ULONG Longs[2];
    } Markers[SMBPSE_OE_HISTORY_SIZE];
} SMBPSE_HISTORY;

#if DBG
VOID SmbPseUpdateOEHistory(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    ULONG Tag1,
    ULONG Tag2
    );
#define UPDATE_OE_HISTORY_LONG(a) {SmbPseUpdateOEHistory(OrdinaryExchange,a,0);}
#define UPDATE_OE_HISTORY_2SHORTS(a,b) {SmbPseUpdateOEHistory(OrdinaryExchange,a,b);}
#else
#define UPDATE_OE_HISTORY_LONG(a)
#define UPDATE_OE_HISTORY_2SHORTS(a,b)
#endif //if DBG


typedef enum _SMB_PSE_ORDINARY_EXCHANGE_TYPE {
    SMBPSE_OETYPE_LATENT_HEADEROPS,
    SMBPSE_OETYPE_CREATE,
    SMBPSE_OETYPE_COREOPEN,
//    SMBPSE_OETYPE_CLEANUP,
    SMBPSE_OETYPE_FINDCLOSE,
    SMBPSE_OETYPE_READ,
    SMBPSE_OETYPE_WRITE, SMBPSE_OETYPE_EXTEND_WRITE, SMBPSE_OETYPE_CORETRUNCATE,
    SMBPSE_OETYPE_LOCKS, SMBPSE_OETYPE_ASSERTBUFFEREDLOCKS,
    SMBPSE_OETYPE_FLUSH,
    SMBPSE_OETYPE_CLOSE, SMBPSE_OETYPE_CLOSEAFTERCORECREATE,
    //SMBPSE_OETYPE_SEARCH,
    SMBPSE_OETYPE_RENAME,
    SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,  //MUST BE FIRST T2
    SMBPSE_OETYPE_T2_FOR_NT_DISKATTRIBUTES_INFO,
    SMBPSE_OETYPE_T2_FOR_ONE_FILE_DIRCTRL,
    SMBPSE_OETYPE_T2_FOR_LANMAN_DISKATTRIBUTES_INFO,
    SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,  //MUST BE LAST T2
    SMBPSE_OETYPE_GFA,
//    SMBPSE_OETYPE_GFA2,
    SMBPSE_OETYPE_COREINFO,
    SMBPSE_OETYPE_CORECREATE,
    SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE, SMBPSE_OETYPE_DELETE_FOR_RENAME,
    SMBPSE_OETYPE_CORECREATEDIRECTORY,
    SMBPSE_OETYPE_CORECHECKDIRECTORY,
    SMBPSE_OETYPE_SFA,
    SMBPSE_OETYPE_SFA2,
    SMBPSE_OETYPE_COREQUERYLABEL, SMBPSE_OETYPE_CORESEARCH, SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY,
    SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES,
    SMBPSE_OETYPE_CREATEPRINTFILE,
    SMBPSE_OETYPE_IOCTL,
    SMBPSE_OETYPE_MAXIMUM
} SMB_PSE_ORDINARY_EXCHANGE_TYPE;

typedef enum _SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS {
    SMBPSE_OE_FROM_QUERYDIRECTORY,
    SMBPSE_OE_FROM_QUERYFILEINFO,
    SMBPSE_OE_FROM_SETFILEINFO,
    SMBPSE_OE_FROM_QUERYVOLUMEINFO,
    SMBPSE_OE_FROM_EXTENDFILEFORCACHEING,
    SMBPSE_OE_FROM_LOCKS,
    SMBPSE_OE_FROM_FLUSH,
    SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS,
    SMBPSE_OE_FROM_CLEANUPFOBX,
    SMBPSE_OE_FROM_CLOSESRVCALL,
    SMBPSE_OE_FROM_CREATE,
    SMBPSE_OE_FROM_RENAME,
    SMBPSE_OE_FROM_READ,
    SMBPSE_OE_FROM_WRITE,
    SMBPSE_OE_FROM_FAKESETDELETEDISPOSITION,
    SMBPSE_OE_FROM_MAXIMUM
} SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS;

#define SMBPSE_DEFINE_OE_FLAG(a,c) RX_DEFINE_FLAG(SMBPSE_OE_FLAG_##a,c,0xffff)

typedef enum {
    SMBPSE_DEFINE_OE_FLAG(HEADER_ALREADY_PARSED, 0)
    SMBPSE_DEFINE_OE_FLAG(OE_ALREADY_RESUMED, 1)
    SMBPSE_DEFINE_OE_FLAG(VALIDATE_FID, 2)
    SMBPSE_DEFINE_OE_FLAG(OE_HDR_PARTIAL_INITIALIZED, 3)
    SMBPSE_DEFINE_OE_FLAG(OE_ALLOCATED_DATA_PARTIAL, 4)
    SMBPSE_DEFINE_OE_FLAG(OE_HDR_LOCKED, 5)
    //SMBPSE_DEFINE_OE_FLAG(SMBBUF_IS_A_MDL, 6)
    SMBPSE_DEFINE_OE_FLAG(NO_RESPONSE_EXPECTED, 7)
    SMBPSE_DEFINE_OE_FLAG(MUST_SUCCEED_ALLOCATED_OE, 8)
    SMBPSE_DEFINE_OE_FLAG(MUST_SUCCEED_ALLOCATED_SMBBUF, 9)
    SMBPSE_DEFINE_OE_FLAG(OE_AWAITING_DISPATCH, 10)
    SMBPSE_DEFINE_OE_FLAG(TURNON_DFS_FLAG, 11)
    //SMBPSE_DEFINE_OE_FLAG(NETROOT_GOOD, 15)
} SMBPSE_OE_FLAGS;

typedef enum _SMB_PSE_OE_INNERIO_STATE {
    SmbPseOEInnerIoStates_Initial = 0,
    SmbPseOEInnerIoStates_ReadyToSend,
    SmbPseOEInnerIoStates_OperationOutstanding,
    SmbPseOEInnerIoStates_OperationCompleted
} SMB_PSE_OE_INNERIO_STATE;

#define MAX_PAGES_SPANNED_BY_PARTIAL_DATA_MDL (20)
#define MAX_PAGES_SPANNED_BY_PARTIAL_EXCHANGE_MDL (2)

#define MAX_PARTIAL_DATA_MDL_BUFFER_SIZE    \
    (MAX_PAGES_SPANNED_BY_PARTIAL_DATA_MDL * PAGE_SIZE)

#define MAX_PARTIAL_EXCHANGE_MDL_BUFFER_SIZE \
    (MAX_PAGES_SPANNED_BY_PARTIAL_EXCHANGE_MDL * PAGE_SIZE)

typedef struct _SMB_PSE_OE_READWRITE {
    union {
        PBYTE UserBufferBase;
        PLOWIO_LOCK_LIST LockList;
    };

    ULONG         RemainingByteCount;
    ULONG         ThisBytesRequested;
    ULONG         ThisByteCount;
    ULONG         ThisBufferOffset;
    LARGE_INTEGER ByteOffsetAsLI;
    ULONG         BytesReturned;

    BOOLEAN PartialExchangeMdlInUse;
    BOOLEAN PartialDataMdlInUse;

    ULONG   UserBufferPortionLength;
    ULONG   ExchangeBufferPortionLength;

    union {
        MDL     PartialDataMdl;
        BYTE    ByteBuffer1[
                    sizeof(MDL) +
                    sizeof(ULONG) * MAX_PAGES_SPANNED_BY_PARTIAL_DATA_MDL];
    };

    union {
        MDL     PartialExchangeMdl;
        BYTE    PartialExchangeMdlBuffer[
                    sizeof(MDL) +
                    sizeof(ULONG) * MAX_PAGES_SPANNED_BY_PARTIAL_EXCHANGE_MDL];
    };
} SMB_PSE_OE_READWRITE, *PSMB_PSE_OE_READWRITE;

#define OE_RW_FLAG_SUCCESS_IN_COPYHANDLER (0x01)
#define OE_RW_FLAG_REDUCE_RETURNCOUNT     (0x20) //used in pipewrites to track rawmode
#define OE_RW_FLAG_SUBSEQUENT_OPERATION   (0x40) //used in pipewrites to distinguish the first
#define OE_RW_FLAG_MSGMODE_PIPE_OPERATION (0x80) //MAX VALUE, it's just a byte.....


#define SMB_PSE_OE_HDR_MDL_PAGES (2 + (COMPUTE_PAGES_SPANNED( (ULONG) 0, MAXIMUM_SMB_BUFFER_SIZE )))

typedef struct _SMB_PSE_ORDINARY_EXCHANGE{
   union {
       SMB_EXCHANGE  Exchange;
       SMB_EXCHANGE;
   };
   SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType;
   SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint;
   ULONG SmbBufSize;
   ULONG StartEntryCount;
   PMDL  DataPartialMdl;
   USHORT Flags;
   UCHAR  OpSpecificFlags;
   UCHAR  OpSpecificState;
   ULONG  SendOptions;
   GENERIC_ANDX ParseResumeState;
   UCHAR LastSmbCommand;
   NTSTATUS NoCopyFinalStatus;
   ULONG MessageLength;

   PSMB_PSE_OE_START_ROUTINE        AsyncResumptionRoutine;
   PSMB_PSE_OE_START_ROUTINE        StartRoutine;
   PSMB_PSE_CONTINUATION_ROUTINE    ContinuationRoutine;

   union {
       struct {
           SMBPSE_FILEINFO_BUNDLE FileInfo;
           PMRX_SMB_SRV_OPEN smbSrvOpen;
           RX_FILE_TYPE StorageTypeFromGFA;
           ///DO NOT CHANGE ABOVE HERE UNLESS YOU CHANGE THE INFO ARM AS WELL
           MRXSMB_CREATE_PARAMETERS SmbCp;
           BOOLEAN MustRegainExclusiveResource;
           BOOLEAN CreateWithEasSidsOrLongName;
           ULONG FidReturnedFromCreate;
           ULONG FidReturnedFromOpen;
           ULONG FileSizeReturnedFromOpen;
           BOOLEAN FileWasCreated;
           BOOLEAN FileWasTruncated;
           //UNICODE_STRING PathNameForCoreOperation;
       } Create;
       SMB_PSE_OE_READWRITE ReadWrite;    //also used for locks
       struct {
           SMBPSE_FILEINFO_BUNDLE FileInfo;
           PMRX_SMB_SRV_OPEN smbSrvOpen;
           RX_FILE_TYPE StorageTypeFromGFA;
           ///DO NOT CHANGE ABOVE HERE UNLESS YOU CHANGE THE CREATE ARM AS WELL
           PVOID Buffer;
           PULONG pBufferLength;
           ULONG InfoClass;
           union {
               struct {
                   UCHAR CoreLabel[13];    //right from smb.h
               } QFSVolInfo;
               struct {
                   ULONG CountRemaining;
                   ULONG CountRemainingInSmbbuf;
                   PSMB_DIRECTORY_INFORMATION NextDirInfo;
                   //there should be a union here
                   PSMB_RESUME_KEY EmptyCheckResumeKey;
                   SMB_RESUME_KEY EmptyCheckResumeKeyBuffer;
               } CoreSearch;
           };
       } Info;
       struct {
           LARGE_INTEGER AllocationSize;
       } Transact2;
       struct {
           PUCHAR PtrToLockType;   //this must be here because the beginning of the
                                   //lockstart code sets the locklist to zero which will be this
           PMRX_SRV_OPEN SrvOpen;
           PRX_LOCK_ENUMERATOR LockEnumerator;
           PVOID ContinuationHandle;
           ULONG NumberOfLocksPlaced;
           LARGE_INTEGER NextLockOffset;
           LARGE_INTEGER NextLockRange;
           BOOLEAN NextLockIsExclusive;
           BOOLEAN LockAreaNonEmpty;
           BOOLEAN EndOfListReached;
       } AssertLocks;
   } ;
   PUNICODE_STRING   pPathArgument1;  // Unicode path
   union {
       PUNICODE_STRING   pPathArgument2;  // secondary unicode path
       PVOID             Find32WithinSmbbuf;
   };
   PSMBSTUFFER_BUFFER_STATE StufferStateDbgPtr; //this is just for the debugger....get rid of it
   SMBSTUFFER_BUFFER_STATE AssociatedStufferState;
   struct {
       union {
           MDL;
           MDL Mdl;
       };
       ULONG Pages2[SMB_PSE_OE_HDR_MDL_PAGES];
   } HeaderMdl;
   struct {
       union {
           MDL;
           MDL Mdl;
       };
       ULONG Pages2[SMB_PSE_OE_HDR_MDL_PAGES];
   } HeaderPartialMdl;
//#if DBG
   ULONG SerialNumber;
   SMBPSE_HISTORY History;
   PIRP RxContextCapturedRequestPacket;
   PMDL  SaveDataMdlForDebug;
   ULONG SaveLengthForDebug;
   PMDL  SaveIrpMdlForDebug;
//#endif
   ULONG BytesAvailableCopy;
   ULONG BytesIndicatedCopy;
} SMB_PSE_ORDINARY_EXCHANGE, *PSMB_PSE_ORDINARY_EXCHANGE;

#define SmbPseDiscardProtocol(__STATUS__) { \
    *pBytesTaken = BytesAvailable; \
    pExchange->Status = (__STATUS__); \
}

NTSTATUS
SmbPseOrdinaryExchange(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType
    );

NTSTATUS
SmbPseResumeOrdinaryExchange(
    IN OUT PRX_CONTEXT RxContext
    );

#define ASSERT_ORDINARY_EXCHANGE(__p) ASSERT(NodeType(__p)==SMB_EXCHANGE_NTC(ORDINARY_EXCHANGE))


NTSTATUS
__SmbPseCreateOrdinaryExchange (
    IN PRX_CONTEXT RxContext,
    IN PMRX_V_NET_ROOT VNetRoot,
    IN SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint,
    IN PSMB_PSE_OE_START_ROUTINE StartRoutine,
    OUT PSMB_PSE_ORDINARY_EXCHANGE *OrdinaryExchangePtr
    );
#define SmbPseCreateOrdinaryExchange(__rxcontext,__vnetroot,__entrypoint,__start,__ordinaryexchangeptr) \
      __SmbPseCreateOrdinaryExchange(__rxcontext,__vnetroot,__entrypoint,__start,__ordinaryexchangeptr)

BOOLEAN
SmbPseFinalizeOrdinaryExchange (
    IN OUT PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    );

#define SmbPseInitiateOrdinaryExchange(OrdinaryExchange) (SmbCeInitiateExchange(&OrdinaryExchange->Exchange))

// this macro is used to do the async completion for read/write/locks. Note that the call to lowiocompletion
// will try to complete the irp thereby freeing the user's mdl. so, we better get rid of the partial first.
// we use this macro so that there will be only one version of this code. when we combine start routines,
// this will be un macroed
#define SmbPseAsyncCompletionIfNecessary(OE,RXCONTEXT) {                           \
    if (StartEntryCount>1) {                                                       \
        BOOLEAN FinalizationComplete;                                              \
        if (FALSE) {DbgBreakPoint(); }                                             \
        if ( (OE)->DataPartialMdl ) {                                              \
            if (FlagOn((OE)->Flags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF)){\
                MmPrepareMdlForReuse((OE)->DataPartialMdl);                        \
            } else {                                                               \
                IoFreeMdl((OE)->DataPartialMdl);                                   \
                (OE)->DataPartialMdl = NULL;                                       \
                ClearFlag((OE)->Flags,SMBPSE_OE_FLAG_OE_ALLOCATED_DATA_PARTIAL);   \
            }                                                                      \
        }                                                                          \
        (RXCONTEXT)->StoredStatus = Status;                                        \
                                                                                   \
        RxLowIoCompletion((RXCONTEXT));                                            \
        FinalizationComplete = SmbPseFinalizeOrdinaryExchange((OE));               \
        ASSERT(!FinalizationComplete);                                             \
        Status = STATUS_PENDING;                                                   \
    }}


/* ------------------------------------------
   ------------------------------------------
   Receive Handler Stuff
   ------------------------------------------
   ------------------------------------------
*/

VOID
SmbPseInitializeTables(
    void
    );

typedef
NTSTATUS
(*PSMBPSE_RECEIVE_HANDLER) (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PBYTE                        Response
    );


//boy, talk about a load of arguments
typedef
UCHAR
(*PSMBPSE_NOCOPY_RECEIVE_HANDLER) (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
#if DBG
    IN  UCHAR       ThisIsAReenter,
#endif
    IN  PBYTE       Response
    );
#define SMBPSE_NOCOPYACTION_NORMALFINISH  0x00
#define SMBPSE_NOCOPYACTION_MDLFINISH     0x01
#define SMBPSE_NOCOPYACTION_DISCARD 0x02
#define SMBPSE_NOCOPYACTION_COPY_FOR_RESUME 0x03


#define SMBPSE_RMP_MODELED        (0x00000001)
#define SMBPSE_RMP_THIS_IS_ANDX   (0x00000002)
#define SMBPSE_RMP_WARNINGS_OK    (0x00000004)
#define SMBPSE_RMP_NOCOPY_HANDLER (0x00000008)

typedef enum _SMBPSE_RECEIVE_HANDLER_TOKEN {
    SMBPSE_RECEIVE_HANDLER_TOKEN_READ_ANDX_HANDLER = 0,
    SMBPSE_RECEIVE_HANDLER_TOKEN_READ_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_LOCKING_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_PRINTFILE_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_PRINTFILE_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_CLOSE_HANDLER,  //also close_print_file
    SMBPSE_RECEIVE_HANDLER_TOKEN_NTCREATE_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_CREATE_HANDLER,  //also create_new
    SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_TRANS2_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_GFA_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_SEARCH_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_QUERYDISKINFO_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_IOCTL_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM
} SMBPSE_RECEIVE_HANDLER_TOKEN;

PSMBPSE_RECEIVE_HANDLER SmbPseReceiveHandlers[SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM];
typedef struct _SMBPSE_RECEIVE_MODEL_PARAMETERS {
    UCHAR Flags;
    UCHAR ReceiveHandlerToken;
#if DBG
    USHORT Dummy;
    PSMBPSE_RECEIVE_HANDLER ReceiveHandler;
    PBYTE IndicationString;
    SMB_PSE_ORDINARY_EXCHANGE_TYPE LowType,HighType;
#endif
} SMBPSE_RECEIVE_MODEL_PARAMETERS, *PSMBPSE_RECEIVE_MODEL_PARAMETERS;

SMBPSE_RECEIVE_MODEL_PARAMETERS SmbPseReceiveModelParameters[256]; //there are 256 possible smbs


typedef struct _SMBPSE_VESTIGIAL_SMBBUF {
    NT_SMB_HEADER Header;
    union {
        REQ_WRITE Write;
        REQ_NT_WRITE_ANDX WriteAndX;
        REQ_FLUSH Flush;
        struct {
            REQ_LOCKING_ANDX LockingAndX;
            NTLOCKING_ANDX_RANGE Locks[20];
        };
        REQ_FIND_CLOSE2 FindClose;
        REQ_CLOSE Close;
    };
    ULONG Pad;
} SMBPSE_VESTIGIAL_SMBBUF;


// Finishing routines - these are all cast into the correct procedure type
//                      so that the response will already have the correct SMB format
//                      on entry to the routine


NTSTATUS
MRxSmbFinishNTCreateAndX (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_NT_CREATE_ANDX        Response
      );
#define MRxSmbReceiveHandler_NTCreateAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishNTCreateAndX)

NTSTATUS
MRxSmbFinishOpenAndX (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_OPEN_ANDX             Response
      );
#define MRxSmbReceiveHandler_OpenAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishOpenAndX)

NTSTATUS
MRxSmbFinishClose (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_CLOSE                 Response
      );

#define MRxSmbReceiveHandler_Close ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishClose)

NTSTATUS
MRxSmbFinishGFA (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PVOID                       Response
      );
#define MRxSmbReceiveHandler_GetFileAttributes ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishGFA)

NTSTATUS
MRxSmbFinishTransaction2 (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_TRANSACTION           Response
      );
#define MRxSmbReceiveHandler_Transact2 ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishTransaction2)

NTSTATUS
MRxSmbFinishCoreOpen (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_OPEN                  Response
      );
#define MRxSmbReceiveHandler_CoreOpen ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreOpen)

NTSTATUS
MRxSmbFinishCoreCreate (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_CREATE                Response
      );
#define MRxSmbReceiveHandler_CoreCreate ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreCreate)

//NTSTATUS
//MRxSmbFinishRead (
//      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
//      IN     PRESP_READ_ANDX             Response
//      );
//#define MRxSmbReceiveHandler_ReadAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishRead)

//NTSTATUS
//MRxSmbFinishCoreRead (
//      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
//      IN     PRESP_READ                  Response
//      );
//#define MRxSmbReceiveHandler_CoreRead ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreRead)

UCHAR
MRxSmbReadHandler_NoCopy (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
#if DBG
    IN  UCHAR       ThisIsAReenter,
#endif
    IN  PRESP_READ_ANDX       Response
    );
#define MRxSmbReceiveHandler_Read_NoCopy ((PSMBPSE_RECEIVE_HANDLER)MRxSmbReadHandler_NoCopy)

NTSTATUS
MRxSmbFinishWrite (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PBYTE                       Response
      );

#define MRxSmbReceiveHandler_WritePrintFile ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishWrite)
#define MRxSmbReceiveHandler_WriteAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishWrite)
#define MRxSmbReceiveHandler_CoreWrite ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishWrite)

NTSTATUS
MRxSmbFinishLocks (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_LOCKING_ANDX          Response
      );
#define MRxSmbReceiveHandler_LockingAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishLocks)

NTSTATUS
MRxSmbFinishSearch (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_SEARCH                Response
      );
#define MRxSmbReceiveHandler_Search ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishSearch)
NTSTATUS
MRxSmbFinishQueryDiskInfo (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PRESP_QUERY_INFORMATION_DISK Response
      );
#define MRxSmbReceiveHandler_QueryDiskInfo ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishQueryDiskInfo)


typedef
NTSTATUS
(*PSMB_PSE_OE_T2_FIXUP_ROUTINE) (
    PSMB_PSE_ORDINARY_EXCHANGE
    );

NTSTATUS
__MRxSmbSimpleSyncTransact2(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType,
    IN ULONG TransactSetupCode,
    IN PVOID Params,
    IN ULONG ParamsLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN PSMB_PSE_OE_T2_FIXUP_ROUTINE FixupRoutine
    );
#define MRxSmbSimpleSyncTransact2(a,b,c,d,e,f,g) \
    __MRxSmbSimpleSyncTransact2(a,b,c,d,e,f,g,NULL);

NTSTATUS
MRxSmbDeferredCreate (
      IN OUT PRX_CONTEXT RxContext
      );
NTSTATUS
MRxSmbConstructDeferredOpenContext (
      IN OUT PRX_CONTEXT RxContext
      );

//downlevel stuff....
NTSTATUS
MRxSmbPseudoOpenTailFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      );

NTSTATUS
MRxSmbPseudoOpenTailFromFakeGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      RX_FILE_TYPE StorageType
      );

NTSTATUS
MRxSmbCoreTruncate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG Fid,
    ULONG FileTruncationPoint
    );

NTSTATUS
MRxSmbCoreInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN     ULONG                InformationClass,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength,
      IN     SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint
      );

ULONG
MRxSmbMapSmbAttributes (
    IN USHORT SmbAttribs
    );

USHORT
MRxSmbMapDisposition (
    IN ULONG Disposition
    );

USHORT
MRxSmbMapShareAccess (
    IN USHORT ShareAccess
    );

USHORT
MRxSmbMapDesiredAccess (
    IN ULONG DesiredAccess
    );

USHORT
MRxSmbMapFileAttributes (
    IN ULONG FileAttributes
    );

ULONG
MRxSmbUnmapDisposition (
    IN USHORT SmbDisposition,
    IN ULONG Disposition
    );

LARGE_INTEGER
MRxSmbConvertSmbTimeToTime (
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    IN SMB_TIME Time,
    IN SMB_DATE Date
    );


BOOLEAN
MRxSmbConvertTimeToSmbTime (
    IN PLARGE_INTEGER InputTime,
    IN PSMB_EXCHANGE Exchange OPTIONAL,
    OUT PSMB_TIME Time,
    OUT PSMB_DATE Date
    );


BOOLEAN
MRxSmbTimeToSecondsSince1970 (
    IN PLARGE_INTEGER CurrentTime,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PULONG SecondsSince1970
    );

VOID
MRxSmbSecondsSince1970ToTime (
    IN ULONG SecondsSince1970,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PLARGE_INTEGER CurrentTime
    );


VOID
MRxSmbResumeAsyncReadWriteRequests(
    PRX_CONTEXT RxContext);

#endif // _SMBPSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbutils.c ===
/*++
Copyright (c) 1987 - 1999  Microsoft Corporation

Module Name:

    smbutils.c

Abstract:

    This module implements the routines that aid in the assembly/disassembly of SMB's

--*/

#include "precomp.h"
#pragma hdrstop

#define BASE_DOS_ERROR  ((NTSTATUS )0xC0010000L)

#include "lmerr.h"
#include "nb30.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbPutString)
#pragma alloc_text(PAGE, SmbPutUnicodeString)
#pragma alloc_text(PAGE, SmbPutUnicodeStringAndUpcase)
#pragma alloc_text(PAGE, SmbPutUnicodeStringAsOemString)
#pragma alloc_text(PAGE, SmbPutUnicodeStringAsOemStringAndUpcase)
#endif


NTSTATUS
SmbPutString(
    PBYTE   *pBufferPointer,
    PSTRING pString,
    PULONG  pSize)
{
    NTSTATUS Status;
    PBYTE    pBuffer = *pBufferPointer;

    PAGED_CODE();

    if (*pSize > pString->Length) {
        RtlCopyMemory(
            pBuffer,
            pString->Buffer,
            pString->Length);

        *pSize -= pString->Length;
        *pBufferPointer = pBuffer + pString->Length;
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }

    return Status;
}

NTSTATUS
SmbPutUnicodeString(
    PBYTE           *pBufferPointer,
    PUNICODE_STRING pUnicodeString,
    PULONG          pSize)
{
    NTSTATUS Status;
    PBYTE    pBuffer = *pBufferPointer;

    PAGED_CODE();

    if (*pSize >= (pUnicodeString->Length + sizeof(WCHAR))) {
        WCHAR NullChar = L'\0';

        RtlCopyMemory(
            pBuffer,
            pUnicodeString->Buffer,
            pUnicodeString->Length);

        RtlCopyMemory(
            (pBuffer + pUnicodeString->Length),
            &NullChar,
            sizeof(WCHAR));

        *pSize -= (pUnicodeString->Length + sizeof(WCHAR));
        *pBufferPointer = pBuffer + (pUnicodeString->Length + sizeof(WCHAR));
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }

    return Status;
}

NTSTATUS
SmbPutUnicodeStringAndUpcase(
    PBYTE           *pBufferPointer,
    PUNICODE_STRING pUnicodeString,
    PULONG          pSize)
{
    NTSTATUS Status;
    PBYTE    pBuffer = *pBufferPointer;

    PAGED_CODE();

    if (*pSize >= (pUnicodeString->Length + sizeof(WCHAR))) {
        UNICODE_STRING BufferAsUnicode;
        WCHAR          NullChar = L'\0';

        BufferAsUnicode.Buffer = (PWCHAR)pBuffer;
        BufferAsUnicode.Length = pUnicodeString->Length;
        BufferAsUnicode.MaximumLength = BufferAsUnicode.Length;

        RtlUpcaseUnicodeString(
            &BufferAsUnicode,
            pUnicodeString,
            FALSE);

        RtlCopyMemory(
            (pBuffer + pUnicodeString->Length),
            &NullChar,
            sizeof(WCHAR));

        *pSize -= (pUnicodeString->Length + sizeof(WCHAR));
        *pBufferPointer = pBuffer + (pUnicodeString->Length + sizeof(WCHAR));
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }

    return Status;
}

NTSTATUS
SmbPutUnicodeStringAsOemString(
    PBYTE           *pBufferPointer,
    PUNICODE_STRING pUnicodeString,
    PULONG          pSize)
{
    NTSTATUS   Status;
    OEM_STRING OemString;
    PBYTE      pBuffer = *pBufferPointer;

    PAGED_CODE();

    OemString.MaximumLength = (USHORT)*pSize;
    OemString.Buffer        = pBuffer;

    // The Rtl routine pads the converted string with a NULL.
    Status = RtlUnicodeStringToOemString(
                 &OemString,             // destination string
                 pUnicodeString,         // source string
                 FALSE);                 // No memory allocation for destination

    if (NT_SUCCESS(Status)) {
        if (OemString.Length < *pSize) {
            // put the null
            pBuffer += (OemString.Length + 1);
            *pBufferPointer = pBuffer;
            *pSize -= (OemString.Length + 1); // the NULL is not included in the length by the RTL routine.
        } else {
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }

    return Status;
}

NTSTATUS
SmbPutUnicodeStringAsOemStringAndUpcase(
    PBYTE           *pBufferPointer,
    PUNICODE_STRING pUnicodeString,
    PULONG          pSize)
{
    NTSTATUS   Status;
    OEM_STRING OemString;
    PBYTE      pBuffer = *pBufferPointer;

    PAGED_CODE();

    OemString.MaximumLength = (USHORT)*pSize;
    OemString.Buffer        = pBuffer;

    // The Rtl routine pads the converted string with a NULL.
    Status = RtlUpcaseUnicodeStringToOemString(
                 &OemString,             // destination string
                 pUnicodeString,         // source string
                 FALSE);                 // No memory allocation for destination

    if (NT_SUCCESS(Status)) {
        if (OemString.Length < *pSize) {
            // put the null
            pBuffer += (OemString.Length + 1);
            *pBufferPointer = pBuffer;
            *pSize -= (OemString.Length + 1); // the NULL is not included in the length by the RTL routine.
        } else {
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }

    return Status;
}

//
// The maps for mapping various error codes into NTSTATUSs
//

typedef struct _STATUS_MAP {
    USHORT ErrorCode;
    NTSTATUS ResultingStatus;
} STATUS_MAP, *PSTATUS_MAP;

STATUS_MAP
SmbErrorMap[] = {
    { SMB_ERR_BAD_PASSWORD, STATUS_WRONG_PASSWORD },
    { SMB_ERR_ACCESS, STATUS_NETWORK_ACCESS_DENIED },
    { SMB_ERR_BAD_TID, STATUS_NETWORK_NAME_DELETED },
    { SMB_ERR_BAD_NET_NAME, STATUS_BAD_NETWORK_NAME }, // Invalid network name
    { SMB_ERR_BAD_DEVICE, STATUS_BAD_DEVICE_TYPE }, // Invalid device request
    { SMB_ERR_QUEUE_FULL, STATUS_PRINT_QUEUE_FULL }, // Print queue full
    { SMB_ERR_QUEUE_TOO_BIG, STATUS_NO_SPOOL_SPACE }, // No space on print dev
    { SMB_ERR_BAD_PRINT_FID, STATUS_PRINT_CANCELLED }, // Invalid printfile FID
    { SMB_ERR_SERVER_PAUSED, STATUS_SHARING_PAUSED }, // Server is paused
    { SMB_ERR_MESSAGE_OFF, STATUS_REQUEST_NOT_ACCEPTED }, // Server not receiving msgs
    { SMB_ERR_BAD_TYPE, STATUS_BAD_DEVICE_TYPE },           // Reserved
    { SMB_ERR_BAD_SMB_COMMAND, STATUS_NOT_IMPLEMENTED }, // SMB command not recognized
    { SMB_ERR_BAD_PERMITS, STATUS_NETWORK_ACCESS_DENIED }, // Access permissions invalid
    { SMB_ERR_NO_ROOM, STATUS_DISK_FULL }, // No room for buffer message
    { SMB_ERR_NO_RESOURCE, STATUS_REQUEST_NOT_ACCEPTED }, // No resources available for request
    { SMB_ERR_TOO_MANY_UIDS, STATUS_TOO_MANY_SESSIONS }, // Too many UIDs active in session
    { SMB_ERR_BAD_UID, STATUS_USER_SESSION_DELETED }, // UID not known as a valid UID
    { SMB_ERR_USE_MPX, STATUS_SMB_USE_MPX }, // Can't support Raw; use MPX
    { SMB_ERR_USE_STANDARD, STATUS_SMB_USE_STANDARD }, // Can't support Raw, use standard r/w
    { SMB_ERR_INVALID_NAME, STATUS_OBJECT_NAME_INVALID },
    { SMB_ERR_INVALID_NAME_RANGE, STATUS_OBJECT_NAME_INVALID },
    { SMB_ERR_NO_SUPPORT,STATUS_NOT_SUPPORTED }, // Function not supported
    { NERR_PasswordExpired, STATUS_PASSWORD_EXPIRED },
    { NERR_AccountExpired, STATUS_ACCOUNT_DISABLED },
    { NERR_InvalidLogonHours, STATUS_INVALID_LOGON_HOURS },
    { NERR_InvalidWorkstation, STATUS_INVALID_WORKSTATION },
    { NERR_DuplicateShare, STATUS_LOGON_FAILURE }

//    { SMB_ERR_QUEUE_EOF, STATUS_UNEXPECTED_NETWORK_ERROR },// EOF on print queue dump
//    { SMB_ERR_SERVER_ERROR, STATUS_UNEXPECTED_NETWORK_ERROR}, // Internal server error
//    { SMB_ERR_FILE_SPECS, STATUS_UNEXPECTED_NETWORK_ERROR },    // FID and pathname were incompatible
//    { SMB_ERR_BAD_ATTRIBUTE_MODE, STATUS_UNEXPECTED_NETWORK_ERROR }, // Invalid attribute mode specified
//    { SMB_ERR_NO_SUPPORT_INTERNAL,STATUS_UNEXPECTED_NETWORK_ERROR }, // Internal code for NO_SUPPORT--
//                                                // allows codes to be stored in a byte
//    { SMB_ERR_ERROR, STATUS_UNEXPECTED_NETWORK_ERROR },
//    { SMB_ERR_CONTINUE_MPX, STATUS_UNEXPECTED_NETWORK_ERROR }, // Reserved
//    { SMB_ERR_TOO_MANY_NAMES, STATUS_UNEXPECTED_NETWORK_ERROR }, // Too many remote user names
//    { SMB_ERR_TIMEOUT, STATUS_UNEXPECTED_NETWORK_ERROR }, // Operation was timed out
//    { SMB_ERR_RESERVED2, STATUS_UNEXPECTED_NETWORK_ERROR },
//    { SMB_ERR_RESERVED3, STATUS_UNEXPECTED_NETWORK_ERROR },
//    { SMB_ERR_RESERVED4, STATUS_UNEXPECTED_NETWORK_ERROR },
//    { SMB_ERR_RESERVED5, STATUS_UNEXPECTED_NETWORK_ERROR },

};

ULONG
SmbErrorMapLength = sizeof(SmbErrorMap) / sizeof(SmbErrorMap[0]);

STATUS_MAP
Os2ErrorMap[] = {
    { ERROR_INVALID_FUNCTION,   STATUS_NOT_IMPLEMENTED },
    { ERROR_FILE_NOT_FOUND,     STATUS_NO_SUCH_FILE },
    { ERROR_PATH_NOT_FOUND,     STATUS_OBJECT_PATH_NOT_FOUND },
    { ERROR_TOO_MANY_OPEN_FILES,STATUS_TOO_MANY_OPENED_FILES },
    { ERROR_ACCESS_DENIED,      STATUS_ACCESS_DENIED },
    { ERROR_INVALID_HANDLE,     STATUS_INVALID_HANDLE },
    { ERROR_NOT_ENOUGH_MEMORY,  STATUS_INSUFFICIENT_RESOURCES },
    { ERROR_INVALID_ACCESS,     STATUS_ACCESS_DENIED },
    { ERROR_INVALID_DATA,       STATUS_DATA_ERROR },

    { ERROR_CURRENT_DIRECTORY,  STATUS_DIRECTORY_NOT_EMPTY },
    { ERROR_NOT_SAME_DEVICE,    STATUS_NOT_SAME_DEVICE },
    { ERROR_NO_MORE_FILES,      STATUS_NO_MORE_FILES },
    { ERROR_WRITE_PROTECT,      STATUS_MEDIA_WRITE_PROTECTED},
    { ERROR_NOT_READY,          STATUS_DEVICE_NOT_READY },
    { ERROR_CRC,                STATUS_CRC_ERROR },
    { ERROR_BAD_LENGTH,         STATUS_DATA_ERROR },
    { ERROR_NOT_DOS_DISK,       STATUS_DISK_CORRUPT_ERROR }, //***
    { ERROR_SECTOR_NOT_FOUND,   STATUS_NONEXISTENT_SECTOR },
    { ERROR_OUT_OF_PAPER,       STATUS_DEVICE_PAPER_EMPTY},
    { ERROR_SHARING_VIOLATION,  STATUS_SHARING_VIOLATION },
    { ERROR_LOCK_VIOLATION,     STATUS_FILE_LOCK_CONFLICT },
    { ERROR_WRONG_DISK,         STATUS_WRONG_VOLUME },
    { ERROR_NOT_SUPPORTED,      STATUS_NOT_SUPPORTED },
    { ERROR_REM_NOT_LIST,       STATUS_REMOTE_NOT_LISTENING },
    { ERROR_DUP_NAME,           STATUS_DUPLICATE_NAME },
    { ERROR_BAD_NETPATH,        STATUS_BAD_NETWORK_PATH },
    { ERROR_NETWORK_BUSY,       STATUS_NETWORK_BUSY },
    { ERROR_DEV_NOT_EXIST,      STATUS_DEVICE_DOES_NOT_EXIST },
    { ERROR_TOO_MANY_CMDS,      STATUS_TOO_MANY_COMMANDS },
    { ERROR_ADAP_HDW_ERR,       STATUS_ADAPTER_HARDWARE_ERROR },
    { ERROR_BAD_NET_RESP,       STATUS_INVALID_NETWORK_RESPONSE },
    { ERROR_UNEXP_NET_ERR,      STATUS_UNEXPECTED_NETWORK_ERROR },
    { ERROR_BAD_REM_ADAP,       STATUS_BAD_REMOTE_ADAPTER },
    { ERROR_PRINTQ_FULL,        STATUS_PRINT_QUEUE_FULL },
    { ERROR_NO_SPOOL_SPACE,     STATUS_NO_SPOOL_SPACE },
    { ERROR_PRINT_CANCELLED,    STATUS_PRINT_CANCELLED },
    { ERROR_NETNAME_DELETED,    STATUS_NETWORK_NAME_DELETED },
    { ERROR_NETWORK_ACCESS_DENIED, STATUS_NETWORK_ACCESS_DENIED },
    { ERROR_BAD_DEV_TYPE,       STATUS_BAD_DEVICE_TYPE },
    { ERROR_BAD_NET_NAME,       STATUS_BAD_NETWORK_NAME },
    { ERROR_TOO_MANY_NAMES,     STATUS_TOO_MANY_NAMES },
    { ERROR_TOO_MANY_SESS,      STATUS_TOO_MANY_SESSIONS },
    { ERROR_SHARING_PAUSED,     STATUS_SHARING_PAUSED },
    { ERROR_REQ_NOT_ACCEP,      STATUS_REQUEST_NOT_ACCEPTED },
    { ERROR_REDIR_PAUSED,       STATUS_REDIRECTOR_PAUSED },

    { ERROR_FILE_EXISTS,        STATUS_OBJECT_NAME_COLLISION },
    { ERROR_INVALID_PASSWORD,   STATUS_WRONG_PASSWORD },
    { ERROR_INVALID_PARAMETER,  STATUS_INVALID_PARAMETER },
    { ERROR_NET_WRITE_FAULT,    STATUS_NET_WRITE_FAULT },

    { ERROR_BROKEN_PIPE,        STATUS_PIPE_BROKEN },

    { ERROR_OPEN_FAILED,        STATUS_OPEN_FAILED },
    { ERROR_BUFFER_OVERFLOW,    STATUS_BUFFER_OVERFLOW },
    { ERROR_DISK_FULL,          STATUS_DISK_FULL },
    { ERROR_SEM_TIMEOUT,        STATUS_IO_TIMEOUT },
    { ERROR_INSUFFICIENT_BUFFER,STATUS_BUFFER_TOO_SMALL },
    { ERROR_INVALID_NAME,       STATUS_OBJECT_NAME_INVALID },
    { ERROR_INVALID_LEVEL,      STATUS_INVALID_LEVEL },
    { ERROR_BAD_PATHNAME,       STATUS_OBJECT_PATH_INVALID },   //*
    { ERROR_BAD_PIPE,           STATUS_INVALID_PARAMETER },
    { ERROR_PIPE_BUSY,          STATUS_PIPE_NOT_AVAILABLE },
    { ERROR_NO_DATA,            STATUS_PIPE_EMPTY },
    { ERROR_PIPE_NOT_CONNECTED, STATUS_PIPE_DISCONNECTED },
    { ERROR_MORE_DATA,          STATUS_BUFFER_OVERFLOW },
    { ERROR_VC_DISCONNECTED,    STATUS_VIRTUAL_CIRCUIT_CLOSED },
    { ERROR_INVALID_EA_NAME,    STATUS_INVALID_EA_NAME },
    { ERROR_EA_LIST_INCONSISTENT,STATUS_EA_LIST_INCONSISTENT },
//    { ERROR_EA_LIST_TOO_LONG, STATUS_EA_LIST_TO_LONG },
    { ERROR_EAS_DIDNT_FIT,      STATUS_EA_TOO_LARGE },
    { ERROR_EA_FILE_CORRUPT,    STATUS_EA_CORRUPT_ERROR },
    { ERROR_EA_TABLE_FULL,      STATUS_EA_CORRUPT_ERROR },
    { ERROR_INVALID_EA_HANDLE,  STATUS_EA_CORRUPT_ERROR }
//    { ERROR_BAD_UNIT,           STATUS_UNSUCCESSFUL}, // ***
//    { ERROR_BAD_COMMAND,        STATUS_UNSUCCESSFUL}, // ***
//    { ERROR_SEEK,               STATUS_UNSUCCESSFUL },// ***
//    { ERROR_WRITE_FAULT,        STATUS_UNSUCCESSFUL}, // ***
//    { ERROR_READ_FAULT,         STATUS_UNSUCCESSFUL}, // ***
//    { ERROR_GEN_FAILURE,        STATUS_UNSUCCESSFUL }, // ***

};

ULONG
Os2ErrorMapLength = sizeof(Os2ErrorMap) / sizeof(Os2ErrorMap[0]);


NTSTATUS
GetSmbResponseNtStatus(
    PSMB_HEADER     pSmbHeader,
    PSMB_EXCHANGE   pExchange
    )
{
    NTSTATUS Status;
    USHORT Error;
    USHORT i;

    ASSERT( pSmbHeader != NULL );

    //  If this SMB contains an NT status for the operation, return
    //  that, otherwise map the resulting error.
    if (SmbGetUshort(&pSmbHeader->Flags2) & SMB_FLAGS2_NT_STATUS) {

        Status = SmbGetUlong( & ((PNT_SMB_HEADER)pSmbHeader)->Status.NtStatus );

        if ((Status == STATUS_SUCCESS) || NT_ERROR(Status) || NT_WARNING(Status)) {
            return Status;
        }
        // else fall through and treat it as an SMB error ..
        // This needs to be done because in certain cases NT servers return SMB
        // specific error codes eventhough the NTSTATUS flag is set
    }

    if (pSmbHeader->ErrorClass == SMB_ERR_SUCCESS) {
        return STATUS_SUCCESS;
    }

    Error = SmbGetUshort(&pSmbHeader->Error);
    if (Error == SMB_ERR_SUCCESS) {
        // Umm, non success ErrorClass but success Error code.
        Status = STATUS_UNEXPECTED_NETWORK_ERROR;
    } else {
        // Map the error code depending on Error Class
        switch (pSmbHeader->ErrorClass) {
        case SMB_ERR_CLASS_DOS:
        case SMB_ERR_CLASS_HARDWARE:
            Status = BASE_DOS_ERROR + Error;
            for (i = 0; i < Os2ErrorMapLength; i++) {
                if (Os2ErrorMap[i].ErrorCode == Error) {
                    Status = Os2ErrorMap[i].ResultingStatus;
                    break;
                }
            }
            break;

        case SMB_ERR_CLASS_SERVER:
            Status = STATUS_UNEXPECTED_NETWORK_ERROR;
            for (i = 0; i < SmbErrorMapLength; i++) {
                if (SmbErrorMap[i].ErrorCode == Error) {
                    //The error of STATUS_NETWORK_ACCESS_DENIED should be mapped as STATUS_NO_SUCH_FILE for
                    //the non-NT servers in case it tries to access the PIPE.
                    if (SmbErrorMap[i].ResultingStatus == STATUS_NETWORK_ACCESS_DENIED) {
                        SMBCE_SERVER Server = pExchange->SmbCeContext.pServerEntry->Server;
                        NET_ROOT_TYPE NetRootType = pExchange->SmbCeContext.pVNetRoot->pNetRoot->Type;

                        if (NetRootType == NET_ROOT_PIPE) {
                            if ( (Server.Dialect != NTLANMAN_DIALECT) ||
                                 !FlagOn(Server.DialectFlags,DF_NT_STATUS) ) {
                                Status = STATUS_NO_SUCH_FILE;
                                break;
                            }
                        }
                    }
                    Status = SmbErrorMap[i].ResultingStatus;
                    break;
                }
            }
            break;

        default:
            Status = STATUS_UNEXPECTED_NETWORK_ERROR;
            break;
        }
    }

    return Status;
}

BOOLEAN
IsValidShortFileName(
    PUNICODE_STRING Name
    )
{
    BOOLEAN IsValidName = TRUE;
    int NumberOfChars;
    int CurrentNameStart = 0;
    int CurrentNameEnd = 0;
    int CurrentDot = 0;
    int i;

    if (Name == NULL) {
        return TRUE;
    }

    NumberOfChars = Name->Length/sizeof(UNICODE_NULL);

    while(IsValidName && CurrentNameStart < NumberOfChars) {
        CurrentNameEnd = NumberOfChars;

        for (i=CurrentNameStart+1;i<NumberOfChars;i++) {
            if (Name->Buffer[i] == L'\\') {
                CurrentNameEnd = i;
                break;
            }
        }

        if (CurrentNameEnd - CurrentNameStart > 13) {
            IsValidName = FALSE;
        }

        if (IsValidName) {
            CurrentDot = CurrentNameEnd;

            for (i=CurrentNameStart;i<CurrentNameEnd;i++) {
                if (Name->Buffer[i] == L'.') {
                    if (CurrentDot == CurrentNameEnd) {
                        CurrentDot = i;
                    } else {
                        IsValidName = FALSE;
                    }
                }
            }

            if (IsValidName) {
                if (CurrentDot - CurrentNameStart > 9 ||
                    CurrentNameEnd - CurrentDot > 4) {
                    IsValidName = FALSE;
                }
            }
        }

        CurrentNameStart = CurrentNameEnd;
    }

    return IsValidName;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbpse.c ===
/*++

Copyright (c) 1987 - 1999  Microsoft Corporation

Module Name:

    SmbPse.c

Abstract:

    This module defines the types and functions related to the SMB protocol
    selection engine: the component that translates minirdr calldowns into
    SMBs.

Notes:

    The Ordinary exchange bridges the mismatch between the connection engine exchange
    which is oriented towards sending a single SMB request to the server and processing
    the response from the server and the requests recieved from RDBSS.

    The requests from RDBSS come in one of two flavours -- synchronous and asynchronous.
    There are requests which often translate into multiple SMB's being sent to the
    server and the associated response processing. There is no one to one mapping
    between the requests and the SMBs that need to be sent. In some cases a reconnection
    attempt needs to be made and in others a delayed open needs to be sent before the
    associated request can be processed. There are instances of requests which are
    inherently multi SMB, e.g., large read and write requests.

    The ordinary exchange provides the framework for dealing with all these variations.
    The ORDINARY_EXCHANGE wraps a connection engine exchange and extends it with
    different hooks for customization. The custromization of ORDINARY_EXCHANGE is
    possible both from the data and control viewpoint. The data portion is provided
    by a union at the tail end of the ORDINARY_EXCHANGE which provides for the
    appropriate state to be captured.

    The code customization consists of three routines that can be specified as
    part of the ORDIANRY_EXCHANGE. These are the Asynchronous Resumption routine
    (AsyncResumptionRoutine), the continuation routine (ContinuationRoutine) and
    the start routine (StartRoutine).

    The SmbPseCreateOrdinaryExchange, SmbPseSubmitOrdinaryExchange and
    SmbPseFinalizeOrdinaryExchange provide the necessay mechanism for creating an
    ordinary exchange, triggering the action and finalizing it upon completion.

    The ordinary exchange implementation tailors the dispatch vector associated
    with the underlying connection engine exchange using extensive tables. All
    the routines suffixed with _default are the default routines for the
    underlying connection engine exchange.

    The typical course of exchange in response to a request from the RDBSS is to

        1) create an ordinary exchange (SmbPseCreateOrdinaryExchange)

        2) submit it for processing (SmbPseSubmitOrdinaryExchange)

            2.1) The Ordinary exchange completes the initialization w.r.t the state
                associated with it and initiates the processing in the connection
                engine (SmbCeInitiateExchange)

            2.2) The connection engine completes the initialization associated
            with the connection engine and invokes the Start routine provided in
            the dispatch vector.

            2.3) This results in the Start routine provided to the Ordinary exchange
            being invoked. The request specific initialization is carried out followed
            by a call to SmbCeTranceive or SmbCeSend.

            2.4) The resulting exchange is suspended while the underlying connection
            engine interfaces with the transport to ship the packet over and receive
            the response.

            2.5) Once the connection engine quiesces the SMbPseContinueOrdinaryExchange
            is called. This routine either invokes the continuation routine to resume
            processing or wrap up the ordianry exchange processing and return to
            the caller. this involves either setting the event for synchronous
            requests or invoking the AsyncResumption routine for asynchronous requests.

    The request for read/write which involve multiple packets use the continuation
    routine to spin up further requests. These can be network exchanges which are wired
    to the original exchange and are referred to as associated exchanges. On completion
    of all associated exchanges the connection engine invokes the
    AssociatedExchangeCompletionHandler which results in the resumption of
    ORDINARY_EXCHANGE processing in 2.5.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, __SmbPseDbgCheckOEMdls)
#pragma alloc_text(PAGE, SmbPseContinueOrdinaryExchange)
#pragma alloc_text(PAGE, SmbPseOrdinaryExchange)
#pragma alloc_text(PAGE, __SmbPseCreateOrdinaryExchange)
#pragma alloc_text(PAGE, SmbPseFinalizeOrdinaryExchange)
#pragma alloc_text(PAGE, SmbPseExchangeStart_default)
#pragma alloc_text(PAGE, SmbPseExchangeCopyDataHandler_Read)
#pragma alloc_text(PAGE, __SmbPseRMTableEntry)
#pragma alloc_text(PAGE, SmbPseInitializeTables)
#endif

RXDT_DefineCategory(SMBPSE);
#define Dbg                              (DEBUG_TRACE_SMBPSE)

#define MINIMUM_SEND_SIZE 512

PVOID LastOE;

#define MIN(x,y) ((x) < (y) ? (x) : (y))

#define IM_THE_LAST_GUY (*Response==0)

//
// Generic AndX request
//

GENERIC_ANDX NullGenericAndX = {
            //    typedef struct _GENERIC_ANDX {
      0,    //        UCHAR WordCount;                    // Count of parameter words
            //        UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
      SMB_COM_NO_ANDX_COMMAND,
      0,    //        UCHAR AndXReserved;                 // Reserved
      0     //        _USHORT( AndXOffset );              // Offset (from SMB header start)
            //    } GENERIC_ANDX;
    };

NTSTATUS
SmbPseExchangeStart_default(
    IN OUT PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbPseExchangeSendCallbackHandler_default(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus);

NTSTATUS
SmbPseExchangeCopyDataHandler_default(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pDataBuffer,
    IN ULONG            DataSize);

NTSTATUS
SmbPseExchangeCopyDataHandler_Read(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pDataBuffer,
    IN ULONG            DataSize);

NTSTATUS
SmbPseExchangeReceive_default(
    IN struct _SMB_EXCHANGE *pExchange,
    IN ULONG  BytesIndicated,
    IN ULONG  BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL *pDataBufferPointer,
    OUT PULONG  pDataSize,
    IN ULONG    ReceiveFlags);

NTSTATUS
SmbPseExchangeFinalize_default(
   IN OUT struct _SMB_EXCHANGE *pExchange,
   OUT    BOOLEAN              *pPostFinalize);

SMB_EXCHANGE_DISPATCH_VECTOR
SmbPseOEDispatch = {
    SmbPseExchangeStart_default,
    SmbPseExchangeReceive_default,
    SmbPseExchangeCopyDataHandler_default,
    SmbPseExchangeSendCallbackHandler_default,
    SmbPseExchangeFinalize_default,
    NULL
    };

#if DBG
#define P__ASSERT(exp) {             \
    if (!(exp)) {                    \
        DbgPrint("NOT %s\n",#exp);   \
        errors++;                    \
    }}

VOID
__SmbPseOEAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSMBSTUFFER_BUFFER_STATE StufferState,
    ULONG Flags
    )
/*++

Routine Description:

   This routine performs a variety of checks to ensure that the linkage between the rxcontext, the OE, and
   the stufferstate is correct and that various fields have correct values. if anything is bad....print stuff out and brkpoint;

Arguments:

     MsgPrefix          an identifying msg
     RxContext           duh
     OrdinaryExchange    .
     StufferState        .

Return Value:

    none

Notes:

--*/
{
    ULONG errors = 0;

    PMRXSMB_RX_CONTEXT pMRxSmbContext;
    PSMB_EXCHANGE Exchange = &OrdinaryExchange->Exchange;

    pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    if (Exchange->CancellationStatus != SMBCE_EXCHANGE_CANCELLED) {
        P__ASSERT( OrdinaryExchange->SerialNumber == RxContext->SerialNumber );
        P__ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );
        P__ASSERT( pMRxSmbContext->pExchange == Exchange );
        P__ASSERT( pMRxSmbContext->pStufferState == StufferState );
    }

    P__ASSERT( NodeType(OrdinaryExchange)==SMB_EXCHANGE_NTC(ORDINARY_EXCHANGE) );
    P__ASSERT( OrdinaryExchange->RxContext == RxContext );
    P__ASSERT( NodeType(StufferState) == SMB_NTC_STUFFERSTATE );
    P__ASSERT( Exchange == StufferState->Exchange);
    P__ASSERT( StufferState->RxContext == RxContext );

    if(StufferState->HeaderMdl!=NULL){
        P__ASSERT( !RxMdlIsPartial(StufferState->HeaderMdl) );
    }

    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED)) {
        P__ASSERT( RxMdlIsPartial(StufferState->HeaderPartialMdl) );
    }

    if (errors==0) {
        return;
    }

    DbgPrint("%s INCONSISTENT OE STATE: %d errors at %s line %d\n",
                 MsgPrefix,errors,File,Line);
    DbgBreakPoint();

    return;
}

VOID
__SmbPseDbgRunMdlChain(
    PMDL MdlChain,
    ULONG CountToCompare,
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line
    )
{
    ULONG i,total;

    RxDbgTrace(0,Dbg,("__SmbPseRunMdlChain: -------------%08lx\n",MdlChain));
    for (total=i=0;MdlChain!=NULL;i++,MdlChain=MdlChain->Next) {
        total+=MdlChain->ByteCount;
        RxDbgTrace(0,Dbg,("--->%02d %08lx %08lx %08lx %6d %6d\n",i,MdlChain,MdlChain->MdlFlags,
               MmGetMdlVirtualAddress(MdlChain),MdlChain->ByteCount,total));
    }

    if (total == CountToCompare) return;

    DbgPrint("%s: MdlChain.Count!=CountToCompart c1,c2,xch.st=%08lx %08lx %08lx\n",
                             MsgPrefix,
                             total,CountToCompare,OrdinaryExchange->Status,

                             File,Line);
    DbgBreakPoint();
}

#define SmbPseDbgRunMdlChain(a,b,c,d) {\
   __SmbPseDbgRunMdlChain(a,b,c,d,__FILE__,__LINE__);\
   }

VOID
__SmbPseDbgCheckOEMdls(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line
    )
{
    ULONG errors = 0;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PMDL SubmitMdl = StufferState->HeaderPartialMdl;

    PAGED_CODE();

    P__ASSERT (OrdinaryExchange->SaveDataMdlForDebug == SubmitMdl->Next);
    P__ASSERT (OrdinaryExchange->SaveDataMdlForDebug == StufferState->DataMdl);
    P__ASSERT (SubmitMdl != NULL);

    if (errors==0) {
        return;
    }

    DbgPrint("%s CheckOEMdls failed: %d errors at %s line %d: OE=%08lx\n",
                 MsgPrefix,errors,File,Line,OrdinaryExchange);
    DbgBreakPoint();

    return;
}

#define SmbPseDbgCheckOEMdls(a,b) {\
   __SmbPseDbgCheckOEMdls(a,b,__FILE__,__LINE__);\
   }

ULONG SmbPseShortStatus(ULONG Status)
{
    ULONG ShortStatus;

    ShortStatus = Status & 0xc0003fff;
    ShortStatus = ShortStatus | (ShortStatus >>16);
    return(ShortStatus);
}

VOID SmbPseUpdateOEHistory(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    ULONG Tag1,
    ULONG Tag2
    )
{
    ULONG MyIndex,Long0,Long1;

    MyIndex = InterlockedIncrement(&OrdinaryExchange->History.Next);
    MyIndex = (MyIndex-1) & (SMBPSE_OE_HISTORY_SIZE-1);
    Long0 = (Tag1<<16) | (Tag2 & 0xffff);
    Long1 = (SmbPseShortStatus(OrdinaryExchange->SmbStatus)<<16) | OrdinaryExchange->Flags;
    OrdinaryExchange->History.Markers[MyIndex].Longs[0] = Long0;
    OrdinaryExchange->History.Markers[MyIndex].Longs[1] = Long1;
}

VOID SmbPseVerifyDataPartialAllocationPerFlags(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    )
{
    BOOLEAN FlagsSayPartialAllocated,TheresADataPartial;
    ULONG t = OrdinaryExchange->Flags & (SMBPSE_OE_FLAG_OE_ALLOCATED_DATA_PARTIAL|SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF);

    FlagsSayPartialAllocated = (t!=0)?TRUE:FALSE;   //the compiler is getting confused
    TheresADataPartial = (OrdinaryExchange->DataPartialMdl != NULL)?TRUE:FALSE;  //the compiler is getting confused
    if ( FlagsSayPartialAllocated != TheresADataPartial){
        DbgPrint("Flags %08lx datapartial %08lx t %08lx fspa %08lx tadp %08lx\n",
                     OrdinaryExchange->Flags, OrdinaryExchange->DataPartialMdl,
                     t, FlagsSayPartialAllocated, TheresADataPartial);
        ASSERT ( FlagsSayPartialAllocated == TheresADataPartial);
    }
}

#else

#define SmbPseDbgRunMdlChain(a,b,c,d) {NOTHING;}
#define SmbPseDbgCheckOEMdls(a,b) {NOTHING;}
#define SmbPseVerifyDataPartialAllocationPerFlags(a) {NOTHING;}

#endif

#define UPDATE_OE_HISTORY_WITH_STATUS(a) \
            UPDATE_OE_HISTORY_2SHORTS(a,SmbPseShortStatus(OrdinaryExchange->Status))




VOID
MRxSmbResumeAsyncReadWriteRequests(
    PRX_CONTEXT RxContext)
/*++

Routine Description:

    Asynchronous read write requests can be deferred because of SMB FCB resource
    acquistion. In all such cases this routine resumes the request. We
    cannot directly reume execution with MRxSmbRead/MRxSmbWrite routine because
    we need to invoke LowIoCompletion in certain failure cases. We have two choices
    to do so .... either we can include this logic in the MRxSmbRead/MRxSmbWrite
    routine or consolidate it in pne place. This routine implements the later
    approach.

Arguments:

    RxContext - the RDBSS context

Notes:

--*/
{
    NTSTATUS Status;

    PMRX_CALLDOWN ResumptionRoutine;

    switch (RxContext->MajorFunction) {
    case IRP_MJ_READ:
        ResumptionRoutine = MRxSmbRead;
        break;
    case IRP_MJ_WRITE:
        ResumptionRoutine = MRxSmbWrite;
        break;
    default:
        ASSERT(!"Valid IRP Major Function code for ResumeReadWrite");
        return;
    }

    Status = (ResumptionRoutine)(RxContext);

    if (Status != STATUS_PENDING) {
        if (Status != STATUS_SUCCESS) {
            DbgPrint("RxContext Async Status %lx\n",Status);
            RxContext->StoredStatus = Status;
            RxContext->InformationToReturn = 0;
        }
        // Invoke the Low Io Resumption routine
        RxLowIoCompletion(RxContext);
    }
}

NTSTATUS
SmbPseContinueOrdinaryExchange(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine resumes processing on an exchange. This is called when work is
   required to finish processing a request that cannot be completed at DPC
   level.  This happens either because the parse routine needs access to
   structures that are not locks OR because the operation if asynchronous and
   there maybe more work to be done.

   The two cases are regularized by delaying the parse if we know that we're
   going to post: this is indicated by the presense of a resume routine.

Arguments:

    RxContext  - the context of the operation. .

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;

    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                        (PSMB_PSE_ORDINARY_EXCHANGE)(pMRxSmbContext->pExchange);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PMDL SubmitMdl, HeaderFullMdl;

    BOOLEAN InvokeContinuationRoutine = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("SmbPseContinueOrdinaryExchange entering........OE=%08lx\n",OrdinaryExchange));

    Status = Exchange->Status;

    if (OrdinaryExchange->OpSpecificState !=
            SmbPseOEInnerIoStates_OperationCompleted) {

        ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_AWAITING_DISPATCH);

        SmbPseOEAssertConsistentLinkageFromOE("SmbPseContinueOrdinaryExchange:");

        UPDATE_OE_HISTORY_WITH_STATUS('0c');

        SubmitMdl = StufferState->HeaderPartialMdl;
        HeaderFullMdl = StufferState->HeaderMdl;

        ASSERT(FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED));

        SmbPseOEAssertConsistentLinkage("Top of OE continue: ");

        RxUnprotectMdlFromFree(SubmitMdl);
        RxUnprotectMdlFromFree(HeaderFullMdl);

        SmbPseDbgCheckOEMdls(
            OrdinaryExchange,"SmbPseContinueOrdinaryExchange(top)");

        SmbPseDbgRunMdlChain(
            SubmitMdl,
            OrdinaryExchange->SaveLengthForDebug,
            OrdinaryExchange,
            "SmbPseContinueOrdinaryExchange(top)");

        MmPrepareMdlForReuse(SubmitMdl);

        ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED);

        SmbPseVerifyDataPartialAllocationPerFlags(OrdinaryExchange);

        if ( OrdinaryExchange->DataPartialMdl ) {
            MmPrepareMdlForReuse( OrdinaryExchange->DataPartialMdl );
        }

        RxDbgTrace( 0, Dbg, ("  --> P4Reuse %08lx, full %08lx is no longer unlocked here\n"
                             ,SubmitMdl,HeaderFullMdl));
    }

    if (OrdinaryExchange->ContinuationRoutine == NULL) {
        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            ULONG BytesTaken;
            ULONG DataSize = 0;
            ULONG MessageLength = OrdinaryExchange->MessageLength;
            PMDL  DataBufferPointer = NULL;
            PSMB_HEADER SmbHeader = (PSMB_HEADER)StufferState->BufferBase;

            Status = SMB_EXCHANGE_DISPATCH(
                         Exchange,
                         Receive,
                         (
                            Exchange,           // IN struct SMB_EXCHANGE *pExchange,
                            MessageLength,      // IN ULONG  BytesIndicated,
                            MessageLength,      // IN ULONG  BytesAvailable,
                            &BytesTaken,        // OUT ULONG *pBytesTaken,
                            SmbHeader,          // IN  PSMB_HEADER pSmbHeader,
                            &DataBufferPointer, // OUT PMDL *pDataBufferPointer,
                            &DataSize,          // OUT PULONG  pDataSize)
                            TDI_RECEIVE_ENTIRE_MESSAGE
                         ));

            if (Status == STATUS_SUCCESS) {
                Status = Exchange->Status;
                UPDATE_OE_HISTORY_WITH_STATUS('2c');
            } else {
                UPDATE_OE_HISTORY_WITH_STATUS('dd');
            }

            if (DataSize != 0 ||
                DataBufferPointer != NULL ||
                BytesTaken != MessageLength ||
                Status == STATUS_MORE_PROCESSING_REQUIRED) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            InvokeContinuationRoutine = TRUE;
        }
    } else {
        InvokeContinuationRoutine = TRUE;
    }


    if (InvokeContinuationRoutine) {
        if ( OrdinaryExchange->ContinuationRoutine != NULL ) {
            if ( Status == STATUS_MORE_PROCESSING_REQUIRED){
                Exchange->Status = STATUS_SUCCESS;
            }

            Status = OrdinaryExchange->ContinuationRoutine( OrdinaryExchange );

            UPDATE_OE_HISTORY_WITH_STATUS('1c');

            if (Status != STATUS_PENDING) {
                Exchange->Status = Status;
                OrdinaryExchange->ContinuationRoutine = NULL;
            }
        }
    }

    if (Status != STATUS_PENDING) {
        if (Status != STATUS_SUCCESS) {
            OrdinaryExchange->Status = OrdinaryExchange->SmbStatus = Status;
        }

        if (OrdinaryExchange->AsyncResumptionRoutine ) {

            //call the continuation is it's async
            Status = OrdinaryExchange->AsyncResumptionRoutine(
                         OrdinaryExchange,
                         RxContext );

            UPDATE_OE_HISTORY_WITH_STATUS('3c');
        }

        //remove my references, if i'm the last guy then do the putaway...
        UPDATE_OE_HISTORY_WITH_STATUS('4c');
        SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    }

    RxDbgTrace(-1, Dbg, ("SmbPseContinueOrdinaryExchange returning %08lx.\n", Status));
    return(Status);
} // SmbPseContinueOrdinaryExchange


NTSTATUS
SmbPseOrdinaryExchange(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN     SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType
    )
/*++

Routine Description:

   This routine implements an ordinary exchange as viewed by the protocol
   selection routines.

Arguments:

    OrdinaryExchange  - the exchange to be conducted.
    OEType            - Ordinary Exchange Type

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;
    RxCaptureFobx;

    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;
    PSMB_PSE_OE_START_ROUTINE Continuation;
    ULONG   SmbLength;
    PMDL    SubmitMdl,HeaderFullMdl;
    ULONG   SendOptions;
    DEBUG_ONLY_DECL( ULONG LengthP; ULONG LengthF; )

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("SmbPseOrdinaryExchange entering.......OE=%08lx\n",OrdinaryExchange));

    SmbPseOEAssertConsistentLinkageFromOE("SmbPseOrdinaryExchange:");

    OrdinaryExchange->OEType = OEType;
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    KeInitializeEvent(
        &RxContext->SyncEvent,
        NotificationEvent,
        FALSE );

    HeaderFullMdl = StufferState->HeaderMdl;
    ASSERT( HeaderFullMdl != NULL );
    SmbLength = (ULONG)(StufferState->CurrentPosition - StufferState->BufferBase);

    SubmitMdl = StufferState->HeaderPartialMdl;

    ASSERT(RxMdlIsOwned(SubmitMdl));

    RxBuildPartialHeaderMdl(
        StufferState->HeaderMdl,
        SubmitMdl,
        StufferState->BufferBase,
        SmbLength );

    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED);

    //
    // If there is a data MDL associated with this request, then
    // we'll have to chain it.
    //

    SubmitMdl->Next = StufferState->DataMdl;

    if (StufferState->DataMdl) {
        SmbLength += StufferState->DataSize;
    }

    DbgDoit(
        SmbPseDbgRunMdlChain(
            SubmitMdl,
            SmbLength,
            OrdinaryExchange,
            "SmbPseOrdinaryExchange(before)");

        OrdinaryExchange->SaveDataMdlForDebug = SubmitMdl->Next;
        OrdinaryExchange->SaveLengthForDebug = SmbLength;

        if (OrdinaryExchange->RxContextCapturedRequestPacket != NULL) {
            OrdinaryExchange->SaveIrpMdlForDebug =
                OrdinaryExchange->RxContextCapturedRequestPacket->MdlAddress;
        }
    )

    RxDbgTrace(
        0,
        Dbg,
        ("  --> mdllength/smblength %08lx/%08lx headermdl %08lx\n",
         MmGetMdlByteCount(SubmitMdl), SmbLength, StufferState->HeaderMdl) );

    ClearFlag(
        OrdinaryExchange->Flags,
        (SMBPSE_OE_FLAG_HEADER_ALREADY_PARSED |
         SMBPSE_OE_FLAG_OE_ALREADY_RESUMED) );

    SendOptions = OrdinaryExchange->SendOptions;

    SmbCeReferenceExchange( Exchange );  //this one is taken away in ContinueOE
    SmbCeReferenceExchange( Exchange );  //this one is taken away below...
                                                       //i must NOT finalize before SmbCe returns
    SmbCeResetExchange(Exchange);

    Continuation = OrdinaryExchange->AsyncResumptionRoutine;
    if (((OrdinaryExchange->OEType == SMBPSE_OETYPE_WRITE) ||
         (OrdinaryExchange->OEType == SMBPSE_OETYPE_READ)  ||
         (OrdinaryExchange->OEType == SMBPSE_OETYPE_LOCKS)) &&
        BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)
       ) {
        ASSERT(Continuation!=NULL);
    }

    DbgDoit((LengthP = MmGetMdlByteCount(SubmitMdl),LengthF = MmGetMdlByteCount(HeaderFullMdl)));

    RxProtectMdlFromFree(SubmitMdl);
    RxProtectMdlFromFree(HeaderFullMdl);

    SmbPseOEAssertConsistentLinkage("just before transceive: ");

    UPDATE_OE_HISTORY_2SHORTS('eo',(Continuation!=NULL)?'!!':0);

    DbgDoit( InterlockedIncrement(&OrdinaryExchange->History.Submits); )

    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID)) {
       PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
       PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
       PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(OrdinaryExchange);

       if (smbSrvOpen->Version == pServerEntry->Server.Version) {
          Status = STATUS_SUCCESS;
       } else {
          Exchange->Status = Exchange->SmbStatus = Status = STATUS_CONNECTION_DISCONNECTED;
       }

       IF_DEBUG {
           PSMB_HEADER pSmbHeader = (PSMB_HEADER)MmGetSystemAddressForMdlSafe(SubmitMdl,LowPagePriority);
           USHORT Flags2 = 0;

           if (pSmbHeader) {
               Flags2 = SmbGetUshort(&pSmbHeader->Flags2);
           }

           RxDbgTrace(0, Dbg, ("Flags2 Value for Exchange %lx is %lx\n",Exchange,Flags2));
       }
    } else {
       Status = STATUS_SUCCESS;
    }

    if (Status == STATUS_SUCCESS) {
        if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_NO_RESPONSE_EXPECTED)) {
            Status = SmbCeSend(
                         Exchange,
                         SendOptions,
                         SubmitMdl,
                         SmbLength);
        } else {
            PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(OrdinaryExchange);

            Status = SmbCeTranceive(
                         Exchange,
                         SendOptions,
                         SubmitMdl,
                         SmbLength);
        }
    }

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);  //okay to finalize now that we're back

    if ( Status == STATUS_PENDING) {
        if ( Continuation != NULL ) {
            goto FINALLY;
        }

        UPDATE_OE_HISTORY_WITH_STATUS('1o');
        RxWaitSync( RxContext );

        ASSERT(RxMdlIsOwned(SubmitMdl));

        DbgDoit (
            //variables in the assert are only declared for DBG
            //asserts can be enabled separately
            ASSERT(
                LengthP == MmGetMdlByteCount(SubmitMdl) &&
                LengthF == MmGetMdlByteCount(HeaderFullMdl) );
        )
    } else {
        RxDbgTrace (0, Dbg, ("  -->Status after transceive %08lx\n",Status));
        DbgDoit (
            //variables in the assert are only declared for DBG
            //asserts can be enabled separately
            ASSERT(
                LengthP == MmGetMdlByteCount(SubmitMdl) &&
                LengthF == MmGetMdlByteCount(HeaderFullMdl) );
        )

        RxUnprotectMdlFromFree(SubmitMdl);
        RxUnprotectMdlFromFree(HeaderFullMdl);
        SmbPseOEAssertConsistentLinkage("nonpending return from transceive: ");

        // if it's an error, remove the references that i placed and get out
        if (NT_ERROR(Status)) {
            SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            goto FINALLY;
        }
    }

    //at last, call the continuation........

    SmbPseOEAssertConsistentLinkage("just before continueOE: ");
    UPDATE_OE_HISTORY_WITH_STATUS('9b');

    Status = SmbPseContinueOrdinaryExchange( RxContext );

    UPDATE_OE_HISTORY_WITH_STATUS('9o');

FINALLY:
    RxDbgTrace(-1, Dbg, ("SmbPseOrdinaryExchange returning %08lx.\n", Status));

    return(Status);

} // SmbPseOrdinaryExchange

NTSTATUS
__SmbPseCreateOrdinaryExchange (
    IN PRX_CONTEXT RxContext,
    IN PMRX_V_NET_ROOT VNetRoot,
    IN SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint,
    IN PSMB_PSE_OE_START_ROUTINE StartRoutine,
    OUT PSMB_PSE_ORDINARY_EXCHANGE *OrdinaryExchangePtr
    )
/*++

Routine Description:

   This routine allocates and initializes an SMB header buffer. Currently,
   we just allocate them from pool except when must_succeed is specified.

Arguments:

    RxContext       - the RDBSS context
    VNetRoot        -
    DispatchVector  -

Return Value:

    A buffer ready to go, OR NULL.

Notes:

--*/
{
    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);
    PSMBSTUFFER_BUFFER_STATE StufferState = NULL;
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = NULL;
    PCHAR SmbBuffer = NULL;
    PMDL HeaderFullMdl = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFobx;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("SmbPseCreateOrdinaryExchange\n") );

    OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)SmbMmAllocateExchange(ORDINARY_EXCHANGE,NULL);

    //we rely on the fact that SmbMmAllocate Zeros the exchange.............
    if ( OrdinaryExchange == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto UNWIND;
    }

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    StufferState->NodeTypeCode = SMB_NTC_STUFFERSTATE;
    StufferState->NodeByteSize = sizeof(SMBSTUFFER_BUFFER_STATE);
    StufferState->Exchange = &OrdinaryExchange->Exchange;

    DbgDoit(OrdinaryExchange->SerialNumber = RxContext->SerialNumber);

    //
    // Initialize the exchange packet
    //

    Status = SmbCeInitializeExchange(
                &StufferState->Exchange,
                RxContext,
                (PMRX_V_NET_ROOT)VNetRoot,
                ORDINARY_EXCHANGE,
                &SmbPseOEDispatch);

    if (StufferState->Exchange != NULL) {
        SmbCeReferenceExchange(StufferState->Exchange);

        RxDbgTrace(0, Dbg, ("  exchng=%08lx,type=%08lx\n",&StufferState->Exchange,StufferState->Exchange->Type));
    }

    StufferState->RxContext = RxContext;

    //place a reference on the rxcontext until we are finished
    InterlockedIncrement( &RxContext->ReferenceCount );

    OrdinaryExchange->StufferStateDbgPtr = StufferState;
    OrdinaryExchange->RxContext = RxContext;
    OrdinaryExchange->EntryPoint = EntryPoint;
    OrdinaryExchange->StartRoutine = StartRoutine;
    OrdinaryExchange->SmbBufSize = MAXIMUM_SMB_BUFFER_SIZE;

    DbgDoit(OrdinaryExchange->RxContextCapturedRequestPacket = RxContext->CurrentIrp;);

    //note: create path must turn this flag on.
    OrdinaryExchange->SmbCeFlags &= ~(SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

    ASSERT( (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_OE))
                       ||  (OrdinaryExchange->Flags == 0) );
    ASSERT( OrdinaryExchange->SendOptions == 0 );
    ASSERT( OrdinaryExchange->DataPartialMdl == NULL );

    pMRxSmbContext->pExchange     = &OrdinaryExchange->Exchange;
    pMRxSmbContext->pStufferState = StufferState;

    if (capFobx != NULL) {
        if (BooleanFlagOn(capFobx->Flags,FOBX_FLAG_DFS_OPEN)) {
            SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_TURNON_DFS_FLAG);
        }
    } else if (BooleanFlagOn(VNetRoot->pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT) &&
               (RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT))) {
        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_TURNON_DFS_FLAG);
    }

    if (Status != STATUS_SUCCESS) {
        goto UNWIND;
    }

    //
    // Allocate the SmbBuffer
    //

    if (SmbBuffer == NULL) {
        SmbBuffer = (PCHAR)RxAllocatePoolWithTag(
                               PagedPool,
                               OrdinaryExchange->SmbBufSize +
                               TRANSPORT_HEADER_SIZE,
                               'BMSx' );
    }

    if ( SmbBuffer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto UNWIND;
    }

    RxDbgTrace(0, Dbg, ("  smbbuf=%08lx,stfstate=%08lx\n",SmbBuffer,StufferState));

    StufferState->ActualBufferBase =  SmbBuffer;

    (PBYTE) SmbBuffer += TRANSPORT_HEADER_SIZE;

    StufferState->BufferBase       =  SmbBuffer;
    StufferState->BufferLimit      =  SmbBuffer + OrdinaryExchange->SmbBufSize;

    //
    // Init the HeaderMdl
    //

    HeaderFullMdl = StufferState->HeaderMdl = &OrdinaryExchange->HeaderMdl.Mdl;
    RxInitializeHeaderMdl(HeaderFullMdl,SmbBuffer, OrdinaryExchange->SmbBufSize);

    RxDbgTrace(
        0,
        Dbg,
        ("  --> smbbufsize %08lx, mdllength %08lx\n",
         OrdinaryExchange->SmbBufSize,
         MmGetMdlByteCount(HeaderFullMdl)));

    //finally, lock down the smbbuf taking different paths according to whether
    // we are must-succeed or not

    ASSERT( !RxMdlIsLocked(HeaderFullMdl) );
    ASSERT( HeaderFullMdl->Next == NULL );

    RxDbgTrace( 0, Dbg, ("  --> LOCKING %08lx\n",HeaderFullMdl));

    RxProbeAndLockHeaderPages(
        HeaderFullMdl,
        KernelMode,
        IoModifyAccess,
        Status );

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace( 0, Dbg, ("  --> LOCKING FAILED\n"));
        goto UNWIND;
    }

    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_LOCKED);

    if (MmGetSystemAddressForMdlSafe(HeaderFullMdl,LowPagePriority) == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto UNWIND;
    }

    //
    // No initialization is required for the partial...just set the pointer

    StufferState->HeaderPartialMdl = &OrdinaryExchange->HeaderPartialMdl.Mdl;

    RxDbgTrace( -1, Dbg, ("  --> exiting w!\n") );

    *OrdinaryExchangePtr = OrdinaryExchange;
    return Status;


UNWIND:
    RxDbgTrace( -1, Dbg, ("  --> exiting w/o!\n") );

    if (OrdinaryExchange != NULL ) {
        SmbPseFinalizeOrdinaryExchange( OrdinaryExchange );
    }

    *OrdinaryExchangePtr = NULL;
    return Status;

} // SmbPseCreateOrdinaryExchange



#if DBG
ULONG MRxSmbFinalizeStfStateTraceLevel = 1200;
#define FINALIZESS_LEVEL MRxSmbFinalizeStfStateTraceLevel
#define FINALIZE_TRACKING_SETUP() \
    struct {                    \
        ULONG marker1;          \
        ULONG finalstate;       \
        ULONG marker2;          \
    } Tracking = {'ereh',0,'ereh'};
#define FINALIZE_TRACKING(x) {\
    Tracking.finalstate |= x; \
    }

#define FINALIZE_TRACE(x) SmbPseFinalizeOETrace(x,Tracking.finalstate)
VOID
SmbPseFinalizeOETrace(PSZ text,ULONG finalstate)
{
    PAGED_CODE();

    RxDbgTraceLV(0, Dbg, FINALIZESS_LEVEL,
                   ("MRxSmbFinalizeSmbStufferState  --> %s(%08lx)\n",text,finalstate));
}
#else
#define FINALIZE_TRACKING_SETUP()
#define FINALIZE_TRACKING(x)
#define FINALIZE_TRACE(x)
#endif

BOOLEAN
SmbPseFinalizeOrdinaryExchange (
    IN OUT PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    )
/*++

Routine Description:

    This finalizes an OE.

Arguments:

    OrdinaryExchange - pointer to the OE to be dismantled.

Return Value:

    TRUE if finalization occurs otherwise FALSE.

Notes:

--*/
{
    PMRXSMB_RX_CONTEXT pMRxSmbContext;
    PSMBSTUFFER_BUFFER_STATE StufferState;
    LONG result;
    ULONG OrdinaryExchangeFlags = OrdinaryExchange->Flags;

    FINALIZE_TRACKING_SETUP()

    PAGED_CODE();

    SmbPseOEAssertConsistentLinkageFromOEwithFlags(
        "SmbPseFinalizeOrdinaryExchange:",
        OECHKLINKAGE_FLAG_NO_REQPCKT_CHECK);

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    pMRxSmbContext = MRxSmbGetMinirdrContext(StufferState->RxContext);

    RxDbgTraceLV(+1, Dbg, 1000, ("MRxSmbFinalizeSmbStufferState\n"));

    result =  SmbCeDereferenceExchange(&OrdinaryExchange->Exchange);

    if ( result != 0 ) {
        RxDbgTraceLV(
            -1,
            Dbg,
            1000,
            ("MRxSmbFinalizeSmbStufferState -- returning w/o finalizing (%d)\n",
             result));

        return FALSE;
    }

    // if we're holding the smbfcb, get rid of it

    FINALIZE_TRACKING( 0x10000000 );
    FINALIZE_TRACE("ready to freedatapartial");

    SmbPseVerifyDataPartialAllocationPerFlags(OrdinaryExchange);

    if ( OrdinaryExchange->DataPartialMdl ) {
        if (!FlagOn(OrdinaryExchangeFlags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF)) {
            IoFreeMdl( OrdinaryExchange->DataPartialMdl );
            FINALIZE_TRACKING( 0x8000000 );
        }
    }

    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_LOCKED)) {
        RxUnlockHeaderPages(StufferState->HeaderMdl);
        ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_LOCKED);
        MmPrepareMdlForReuse( StufferState->HeaderMdl );
        FINALIZE_TRACKING( 0x4000000 );
    }

    FINALIZE_TRACE("ready to uninit hdr partial");

    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED)) {
        MmPrepareMdlForReuse( StufferState->HeaderPartialMdl ); //no harm in calling this multiple times
        FINALIZE_TRACKING( 0x300000 );
    } else {
        FINALIZE_TRACKING( 0xf00000 );
    }

    if (!FlagOn(OrdinaryExchangeFlags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF)) {
        FINALIZE_TRACE("ready to freepool actualbuffer");
        if ( StufferState->ActualBufferBase != NULL ) {

            RxFreePool( StufferState->ActualBufferBase );

            FINALIZE_TRACKING( 0x5000 );
        } else {
            FINALIZE_TRACKING( 0xf000 );
        }
    }

    if ( StufferState->RxContext != NULL ) {
        ASSERT( pMRxSmbContext->pExchange == &OrdinaryExchange->Exchange );
        ASSERT( pMRxSmbContext->pStufferState == StufferState );

        //get rid of the reference on the RxContext....if i'm the last guy this will finalize
        RxDereferenceAndDeleteRxContext( StufferState->RxContext );
        FINALIZE_TRACKING( 0x600 );
    } else {
        FINALIZE_TRACKING( 0xf00 );
    }

    FINALIZE_TRACE("ready to discard exchange");
    SmbCeDiscardExchange(OrdinaryExchange);
    FINALIZE_TRACKING( 0x2000000 );

    FINALIZE_TRACKING( 0x8 );
    RxDbgTraceLV(-1, Dbg, 1000, ("MRxSmbFinalizeSmbStufferState  --> exit finalstate=%x\n",Tracking.finalstate));
    return(TRUE);

} // MRxSmbFinalizeSmbStufferState

NTSTATUS
SmbPseExchangeFinalize_default(
    IN OUT PSMB_EXCHANGE  pExchange,
    OUT    BOOLEAN        *pPostFinalize
    )
/*++

Routine Description:


Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                        (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    UPDATE_OE_HISTORY_WITH_STATUS('ff');
    SmbPseOEAssertConsistentLinkageFromOE("SmbPseExchangeFinalize_default: ");

    if (OrdinaryExchange->SmbStatus != STATUS_SUCCESS) {
        OrdinaryExchange->Status = OrdinaryExchange->SmbStatus;
    }

    if (OrdinaryExchange->AsyncResumptionRoutine != NULL) {
        NTSTATUS PostStatus;
        RxDbgTraceLV(0, Dbg, 1000, ("Resume with post-to-async\n"));
        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_AWAITING_DISPATCH);

        IF_DEBUG {
            //fill the workqueue structure with deadbeef....all the better to diagnose
            //a failed post
            ULONG i;
            for (i=0;i+sizeof(ULONG)-1<sizeof(OrdinaryExchange->WorkQueueItem);i+=sizeof(ULONG)) {
                //*((PULONG)(((PBYTE)&OrdinaryExchange->WorkQueueItem)+i)) = 0xdeadbeef;
                PBYTE BytePtr = ((PBYTE)&OrdinaryExchange->WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }

        PostStatus = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         CriticalWorkQueue,
                         &OrdinaryExchange->WorkQueueItem,
                         SmbPseContinueOrdinaryExchange,
                         RxContext);

        ASSERT(PostStatus == STATUS_SUCCESS);
    } else {
        RxDbgTraceLV(0, Dbg, 1000, ("sync resume\n"));
        RxSignalSynchronousWaiter(RxContext);
    }

    *pPostFinalize = FALSE;
    return STATUS_SUCCESS;
}

NTSTATUS
SmbPseExchangeSendCallbackHandler_default(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL       pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus
    )
/*++

Routine Description:

    This is the send call back indication handling routine for ordinary
    exchanges.

Arguments:

    pExchange            - the exchange instance
    pXmitBuffer          - pointer to the transmit buffer MDL
    BytesSent            - number of bytes transmitted
    SendCompletionStatus - status for the send

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;

    SmbPseOEAssertConsistentLinkageFromOE("SmbPseExchangeSendCallbackHandler_default: ");
    UPDATE_OE_HISTORY_WITH_STATUS('cs');

    if (!NT_SUCCESS(SendCompletionStatus)) {
        //sometimes we use exchange-status, sometimes exchange->smbstatus
        //set them both
        pExchange->Status = SendCompletionStatus;
        pExchange->SmbStatus = SendCompletionStatus;
    }

    SmbPseDbgRunMdlChain(
        OrdinaryExchange->AssociatedStufferState.HeaderPartialMdl,
        OrdinaryExchange->SaveLengthForDebug,
        OrdinaryExchange,
        "SmbPseExchangeSendCallbackHandler_default");

    return STATUS_SUCCESS;

} // SmbPseExchangeSendCallbackHandler_default

NTSTATUS
SmbPseExchangeStart_default(
    IN PSMB_EXCHANGE    pExchange
    )
/*++

Routine Description:

    This is the start routine for ordinary exchanges. irght now this is just a simple wrapper.

Arguments:

    pExchange - the exchange instance NOT an Ordinary Exchange

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;

    PAGED_CODE();

    return OrdinaryExchange->StartRoutine(
               (PSMB_PSE_ORDINARY_EXCHANGE)pExchange,
               pExchange->RxContext);

} // SmbPseExchangeStart_default


NTSTATUS
SmbPseExchangeCopyDataHandler_default(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pCopyDataBuffer,
    IN ULONG            CopyDataSize
    )
/*++

Routine Description:

    This is the copy data handling routine for ordinary exchanges.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;

    SmbPseOEAssertConsistentLinkageFromOE("SmbPseExchangeCopyDataHandler_default: ");
    UPDATE_OE_HISTORY_WITH_STATUS('dd');

    OrdinaryExchange->MessageLength = CopyDataSize;
    pExchange->Status = STATUS_MORE_PROCESSING_REQUIRED;

    return STATUS_SUCCESS;
} // SmbPseExchangeCopyDataHandler_default

NTSTATUS
SmbPseExchangeReceive_default(
    IN  struct _SMB_EXCHANGE *pExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
    IN ULONG        ReceiveFlags)
/*++

Routine Description:

    This is the receive indication handling routine for ordinary exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - pointer to the data buffer

    pDataBufferPointer - pointer to the buffer Mdl into which the remaining
                         data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level directly from the tdi receive event
    handler. BUT, it is also called at task time from SmbPseContinueOrdinaryExchange.
    Often, we cannot complete processing from DPClevel because fileobjects, fcbs,
    srvopens, and fobx are pageable and not locked.

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    NTSTATUS SmbStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    PGENERIC_ANDX CommandState;
    UCHAR Command;
    ULONG CopyBufferLength;
    BOOLEAN ThisIsAReenter = BooleanFlagOn(OrdinaryExchange->Flags,
                                        SMBPSE_OE_FLAG_HEADER_ALREADY_PARSED);
    PLOWIO_CONTEXT LowIoContext;
    ULONG ByteCount;
    ULONG Remain;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PCHAR startVa;

    SmbPseOEAssertConsistentLinkage("SmbPseExchangeReceive_default: ");
    UPDATE_OE_HISTORY_WITH_STATUS(ThisIsAReenter?'00':'01');

    RxDbgTrace (0, Dbg, ("SmbPseExchangeReceive_default av/ind=%08lx/%08lx\n",
                           BytesAvailable,BytesIndicated)
                );
    RxDbgTrace (0, Dbg, ("  -->headermdl %08lx\n",StufferState->HeaderMdl));
    ASSERT_ORDINARY_EXCHANGE( OrdinaryExchange );

    CommandState = &OrdinaryExchange->ParseResumeState;

    if ( !ThisIsAReenter ) {

        OrdinaryExchange->BytesIndicatedCopy = BytesIndicated;
        OrdinaryExchange->BytesAvailableCopy = BytesAvailable;

        pExchange->Status = SmbCeParseSmbHeader(
                                pExchange,
                                pSmbHeader,
                                CommandState,
                                &OrdinaryExchange->SmbStatus,
                                BytesAvailable,
                                BytesIndicated,
                                pBytesTaken);

        UPDATE_OE_HISTORY_WITH_STATUS('22');

        if ( pExchange->Status == STATUS_MORE_PROCESSING_REQUIRED) {
            goto COPY_FOR_RESUME;
        }

        if ( (pExchange->Status != STATUS_SUCCESS) ||
             ((Command = OrdinaryExchange->ParseResumeState.AndXCommand) == SMB_COM_NO_ANDX_COMMAND) ) {
            goto FINALLY;
        }

        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_HEADER_ALREADY_PARSED);
    } else {

        OrdinaryExchange->Status = OrdinaryExchange->SmbStatus;

        RxDbgTrace (0, Dbg, ("  -->this is a reenter\n"));

        Command = CommandState->AndXCommand;
    }

    SmbStatus = OrdinaryExchange->SmbStatus;

    if (SmbStatus!=STATUS_SUCCESS) {
        RxDbgTrace (0, Dbg, ("  STATUS NOT SUCCESS = %08lx\n", SmbStatus));
    }

    for ( ; Command != SMB_COM_NO_ANDX_COMMAND ; ) {
        PSMBPSE_RECEIVE_MODEL_PARAMETERS ReceiveModelParams = &SmbPseReceiveModelParameters[Command];
        ULONG ReceiveModelParamsFlags;
        UCHAR mappedCommand = Command;
        PCHAR Response = (PCHAR)pSmbHeader + SmbGetUshort(&CommandState->AndXOffset);

        OrdinaryExchange->LastSmbCommand = Command; //this is used to multiplex in finish routines
        UPDATE_OE_HISTORY_WITH_STATUS('88');

        //
        // Case on the Smb Command Type
        //

        ReceiveModelParamsFlags = ReceiveModelParams->Flags;
        if (ReceiveModelParamsFlags!=0) {

            //map this onto read_andx....which is the arm of the switch that implements the model
            mappedCommand = SMB_COM_READ_ANDX;

        } else {

            //
            // If there's a continuation, then copy&post. it used to always do this.
            // now, we're going to do it unless the command is modeled.
            // the modeling code will take care of correctly deciding to post/nopost.
            //

            if ( (OrdinaryExchange->AsyncResumptionRoutine != NULL) &&
                 !ThisIsAReenter) {
                goto COPY_FOR_RESUME;
            }

        }

        switch (mappedCommand) {
        case SMB_COM_READ_ANDX:
            {
                NTSTATUS FinishStatus = STATUS_SUCCESS;
                NTSTATUS FinalStatus = STATUS_SUCCESS;
                BOOLEAN ThisIsAnAndX = BooleanFlagOn(ReceiveModelParamsFlags,SMBPSE_RMP_THIS_IS_ANDX);
                BOOLEAN ThisWouldBeMyError = (IM_THE_LAST_GUY || !ThisIsAnAndX);

                RxDbgTrace( 0, Dbg, ("  *(ind) %s, smbstatus=%08lx\n",ReceiveModelParams->IndicationString,SmbStatus) );

                IF_DEBUG {
                    BOOLEAN BadType = FALSE;
                    DbgDoit(BadType = (OrdinaryExchange->OEType < ReceiveModelParams->LowType)
                                    ||  (OrdinaryExchange->OEType > ReceiveModelParams->HighType) );
                    if (BadType) {
                        DbgPrint("Bad OEType....%u,Cmd=%02lx,Exch=%08lx\n",OrdinaryExchange->OEType,Command,OrdinaryExchange);
                        ASSERT(!"proceed???");
                    }
                }

                // If this is an error and it's an error for this guy of the AndX
                // chain then finishup If it's a warning tho, continue according
                // to the Flags

                if ( NT_ERROR(SmbStatus) && ThisWouldBeMyError ) {

                    SmbPseDiscardProtocol( SmbStatus );
                    RxDbgTrace( 0, Dbg, ("--->discard1\n"));
                    goto FINALLY;

                } else if ( (SmbStatus != STATUS_SUCCESS) && ThisWouldBeMyError ) {

                    if (!FlagOn(ReceiveModelParamsFlags,SMBPSE_RMP_WARNINGS_OK)) {
                        SmbPseDiscardProtocol(SmbStatus);
                        RxDbgTrace( 0, Dbg, ("--->discard1\n"));
                        goto FINALLY;
                    } else {
                        FinalStatus = SmbStatus;
                    }

                }

                // if there's no nocopy handler then do things the old way

                if (!FlagOn(ReceiveModelParamsFlags,SMBPSE_RMP_NOCOPY_HANDLER)) {
                    // If there's a continuation, then copy&post. it used to always do this. now, we're
                    // going to do it unless the command is modeled. the modeling code will take care of
                    // correctly deciding to post/nopost.
                    //

                    if ((OrdinaryExchange->AsyncResumptionRoutine != NULL) &&
                        !ThisIsAReenter ) {
                        goto COPY_FOR_RESUME;
                    }


                    //eventually, we'll finish from here but for now copy
                    if (RxShouldPostCompletion()) {
                        goto COPY_FOR_RESUME;
                    }

                    if (ReceiveModelParams->ReceiveHandlerToken < SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM){
                        PSMBPSE_RECEIVE_HANDLER ReceiveHandler = SmbPseReceiveHandlers[ReceiveModelParams->ReceiveHandlerToken];
                        FinishStatus = ReceiveHandler( OrdinaryExchange, Response);
                    }
                } else {
                    PSMBPSE_NOCOPY_RECEIVE_HANDLER NoCopyReceiveHandler =
                          (PSMBPSE_NOCOPY_RECEIVE_HANDLER)(SmbPseReceiveHandlers[ReceiveModelParams->ReceiveHandlerToken]);
                    UCHAR Action;

                    OrdinaryExchange->NoCopyFinalStatus = FinalStatus;
                    Action = NoCopyReceiveHandler(
                                 OrdinaryExchange,
                                 BytesIndicated,
                                 BytesAvailable,
                                 pBytesTaken,
                                 pSmbHeader,
                                 pDataBufferPointer,
                                 pDataSize,
#if DBG
                                 ThisIsAReenter,
#endif
                                 Response );

                    switch(Action) {
                    case SMBPSE_NOCOPYACTION_NORMALFINISH:
                        NOTHING;
                        break;

                    case SMBPSE_NOCOPYACTION_MDLFINISH:
                        Status = STATUS_MORE_PROCESSING_REQUIRED;
                        //note that whatever does this must be the last command in the
                        // packet unless we make continueOE more complicated
                        goto FINALLY;

                    case SMBPSE_NOCOPYACTION_COPY_FOR_RESUME:
                        goto COPY_FOR_RESUME;

                    case SMBPSE_NOCOPYACTION_DISCARD:
                        *pBytesTaken = BytesAvailable;
                        RxDbgTrace( 0, Dbg, ("--->discardX\n"));
                        goto FINALLY;
                    }
                }

                pExchange->Status =  (FinishStatus==STATUS_SUCCESS)
                                     ? FinalStatus : FinishStatus;

                if (!ThisIsAnAndX) {
                    Response = (PCHAR)&NullGenericAndX;
                }

            }//this corresponds to the top level of the switch
            break;

        default:
        {
            PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

            RxDbgTrace( 0, Dbg, ("  *(ind) Unimplemented cmd=%02lx,wct=%02lx\n",
                                              Command,*Response) );


            SmbCeTransportDisconnectIndicated(pServerEntry);
            *pBytesTaken = BytesAvailable;
            *pDataBufferPointer = NULL;
            *pDataSize = 0;

            Status = STATUS_SUCCESS;
            pExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
            goto FINALLY;
        }
        }

        CommandState = (PGENERIC_ANDX)Response;
        Command = CommandState->AndXCommand;
    }

    //
    // If we get here then we're done.
    // Make everyone happy by taking all the bytes.
    //

    *pBytesTaken = BytesAvailable;
    goto FINALLY;


COPY_FOR_RESUME:

    CopyBufferLength = MmGetMdlByteCount(StufferState->HeaderMdl);

    ASSERT( BytesAvailable <= CopyBufferLength );

    if (!FlagOn(ReceiveFlags,TDI_RECEIVE_ENTIRE_MESSAGE) ||
        (BytesAvailable > BytesIndicated) || 
        (BytesAvailable > 127)) {

        RxDbgTrace( 0, Dbg, ("Taking data through MDL\n") );
        // Pass an MDL back in for copying the data
        *pDataBufferPointer = StufferState->HeaderMdl;
        *pDataSize    = CopyBufferLength;
        *pBytesTaken  = 0;
        Status = STATUS_MORE_PROCESSING_REQUIRED;

    } else {

        // Copy the data and resume the exchange
        ASSERT( BytesAvailable == BytesIndicated );
        RxDbgTrace( 0, Dbg, ("Taking data through copying\n") );
        *pBytesTaken = OrdinaryExchange->MessageLength = BytesAvailable;
        
        RtlCopyMemory(StufferState->BufferBase,
                      pSmbHeader,BytesIndicated);

        ASSERT(SmbGetUlong((PULONG)pSmbHeader->Protocol) == (ULONG)SMB_HEADER_PROTOCOL);

        pExchange->Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (ThisIsAReenter) {
        pExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

FINALLY:
    OrdinaryExchange->ParseResumeState = *CommandState;
    UPDATE_OE_HISTORY_WITH_STATUS('99');
    return Status;

} // SmbPseExchangeReceive_default


#define SmbPseRIStringsBufferSize 500
CHAR SmbPseReceiveIndicationStringsBuffer[SmbPseRIStringsBufferSize];
ULONG SmbPseRIStringsBufferUsed = 0;

VOID
__SmbPseRMTableEntry(
    UCHAR SmbCommand,
    UCHAR Flags,
    SMBPSE_RECEIVE_HANDLER_TOKEN ReceiveHandlerToken,
    PSMBPSE_RECEIVE_HANDLER ReceiveHandler
#if DBG
    ,
    PBYTE IndicationString,
    SMB_PSE_ORDINARY_EXCHANGE_TYPE LowType,
    SMB_PSE_ORDINARY_EXCHANGE_TYPE HighType
#endif
    )
{
    PSMBPSE_RECEIVE_MODEL_PARAMETERS r = &SmbPseReceiveModelParameters[SmbCommand];
#if DBG
    ULONG ISlength = strlen(IndicationString)+1;
#endif

    PAGED_CODE();

    r->Flags = SMBPSE_RMP_MODELED | Flags;
    r->ReceiveHandlerToken = (UCHAR)ReceiveHandlerToken;
    if (ReceiveHandlerToken < SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM){
        ASSERT((SmbPseReceiveHandlers[ReceiveHandlerToken] == ReceiveHandler)
                   || (SmbPseReceiveHandlers[ReceiveHandlerToken] == NULL));
        SmbPseReceiveHandlers[ReceiveHandlerToken] = ReceiveHandler;
    }

#if DBG
    r->ReceiveHandler = ReceiveHandler;
    r->LowType = LowType;
    r->HighType = HighType;
    if (SmbPseRIStringsBufferUsed+ISlength<=SmbPseRIStringsBufferSize) {
        r->IndicationString = &SmbPseReceiveIndicationStringsBuffer[SmbPseRIStringsBufferUsed];
        RtlCopyMemory(r->IndicationString,IndicationString,ISlength);
    } else {
        if (SmbPseRIStringsBufferUsed<SmbPseRIStringsBufferSize) {
            DbgPrint("Overflowing the indicationstringarray...%s\n",IndicationString);
            ASSERT(!"fix it please");
        }
        r->IndicationString = &SmbPseReceiveIndicationStringsBuffer[SmbPseRIStringsBufferUsed];
    }
    SmbPseRIStringsBufferUsed += ISlength;
#endif
}
#if DBG
#define SmbPseRMTableEntry(__smbcommand,b,c,token,__rcv,flags) \
       __SmbPseRMTableEntry(SMB_COM_##__smbcommand,flags,token,__rcv \
                           ,#__smbcommand,b,c)
#else
#define SmbPseRMTableEntry(__smbcommand,b,c,token,__rcv,flags) \
       __SmbPseRMTableEntry(SMB_COM_##__smbcommand,flags,token,__rcv \
                           )
#endif


VOID
SmbPseInitializeTables(
    void
    )
/*++

Routine Description:

    This routine initializes tables that are used at various points by the
    smbpse mechanisms. The must succeed structure(s) is(are) also initialized.

Arguments:

    none

Return Value:

    none

--*/
{
    ULONG i;

    PAGED_CODE();

    for (i=0;i<256;i++) {
        SmbPseReceiveModelParameters[i].Flags = 0;
        SmbPseReceiveModelParameters[i].ReceiveHandlerToken =
            SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM;
    }

    for (i=0;i<SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM;i++) {
        SmbPseReceiveHandlers[i] = NULL;
    }

    SmbPseRMTableEntry(
        READ_ANDX,
        SMBPSE_OETYPE_READ,
        SMBPSE_OETYPE_READ,
        SMBPSE_RECEIVE_HANDLER_TOKEN_READ_ANDX_HANDLER,
        MRxSmbReceiveHandler_Read_NoCopy,
        SMBPSE_RMP_THIS_IS_ANDX|SMBPSE_RMP_WARNINGS_OK|SMBPSE_RMP_NOCOPY_HANDLER);

    SmbPseRMTableEntry(
        READ,
        SMBPSE_OETYPE_READ,
        SMBPSE_OETYPE_READ,
        SMBPSE_RECEIVE_HANDLER_TOKEN_READ_ANDX_HANDLER,
        MRxSmbReceiveHandler_Read_NoCopy,
        SMBPSE_RMP_WARNINGS_OK|SMBPSE_RMP_NOCOPY_HANDLER);

    SmbPseRMTableEntry(
        WRITE_ANDX,
        SMBPSE_OETYPE_WRITE,
        SMBPSE_OETYPE_EXTEND_WRITE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_ANDX_HANDLER,
        MRxSmbReceiveHandler_WriteAndX,
        SMBPSE_RMP_THIS_IS_ANDX);

    SmbPseRMTableEntry(
        WRITE,
        SMBPSE_OETYPE_WRITE,
        SMBPSE_OETYPE_CORETRUNCATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_HANDLER,
        MRxSmbReceiveHandler_CoreWrite,
        0);

    SmbPseRMTableEntry(
        LOCKING_ANDX,
        SMBPSE_OETYPE_LOCKS,
        SMBPSE_OETYPE_ASSERTBUFFEREDLOCKS,
        SMBPSE_RECEIVE_HANDLER_TOKEN_LOCKING_ANDX_HANDLER,
        MRxSmbReceiveHandler_LockingAndX,
        SMBPSE_RMP_THIS_IS_ANDX);

    SmbPseRMTableEntry(
        UNLOCK_BYTE_RANGE,
        SMBPSE_OETYPE_LOCKS,
        SMBPSE_OETYPE_LOCKS,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        LOCK_BYTE_RANGE,
        SMBPSE_OETYPE_LOCKS,
        SMBPSE_OETYPE_LOCKS,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        QUERY_INFORMATION2,
        SMBPSE_OETYPE_GFA,
        SMBPSE_OETYPE_GFA,
        SMBPSE_RECEIVE_HANDLER_TOKEN_GFA_HANDLER,
        MRxSmbReceiveHandler_GetFileAttributes,
        0);

    SmbPseRMTableEntry(
        CLOSE_PRINT_FILE,
        SMBPSE_OETYPE_CLOSE,
        SMBPSE_OETYPE_CLOSE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_CLOSE_HANDLER,
        MRxSmbReceiveHandler_Close,
        0);

    SmbPseRMTableEntry(
        NT_CREATE_ANDX,
        SMBPSE_OETYPE_LATENT_HEADEROPS,
        SMBPSE_OETYPE_CREATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_NTCREATE_ANDX_HANDLER,
        MRxSmbReceiveHandler_NTCreateAndX,
        SMBPSE_RMP_THIS_IS_ANDX);

    SmbPseRMTableEntry(
        OPEN_ANDX,
        SMBPSE_OETYPE_LATENT_HEADEROPS,
        SMBPSE_OETYPE_CREATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_ANDX_HANDLER,
        MRxSmbReceiveHandler_OpenAndX,
        SMBPSE_RMP_THIS_IS_ANDX);

    SmbPseRMTableEntry(
        OPEN,
        SMBPSE_OETYPE_COREOPEN,
        SMBPSE_OETYPE_COREOPEN,
        SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_HANDLER,
        MRxSmbReceiveHandler_CoreOpen,
        0);

    SmbPseRMTableEntry(
        CREATE,
        SMBPSE_OETYPE_CORECREATE,
        SMBPSE_OETYPE_CORECREATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_CREATE_HANDLER,
        MRxSmbReceiveHandler_CoreCreate,
        0);

    SmbPseRMTableEntry(
        CREATE_NEW,
        SMBPSE_OETYPE_CORECREATE,
        SMBPSE_OETYPE_CORECREATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_CREATE_HANDLER,
        MRxSmbReceiveHandler_CoreCreate,
        0);

    SmbPseRMTableEntry(
        CLOSE,
        SMBPSE_OETYPE_CLOSE,
        SMBPSE_OETYPE_CLOSEAFTERCORECREATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_CLOSE_HANDLER,
        MRxSmbReceiveHandler_Close,
        0);

    SmbPseRMTableEntry(
        QUERY_INFORMATION,
        0,
        SMBPSE_OETYPE_MAXIMUM,
        SMBPSE_RECEIVE_HANDLER_TOKEN_GFA_HANDLER,
        MRxSmbReceiveHandler_GetFileAttributes,
        0);

    SmbPseRMTableEntry(
        TRANSACTION2,
        SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,
        SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,
        SMBPSE_RECEIVE_HANDLER_TOKEN_TRANS2_ANDX_HANDLER,
        MRxSmbReceiveHandler_Transact2,
        0);

    SmbPseRMTableEntry(
        TRANSACTION2_SECONDARY,
        SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,
        SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,
        SMBPSE_RECEIVE_HANDLER_TOKEN_TRANS2_ANDX_HANDLER,
        MRxSmbReceiveHandler_Transact2,
        0);

    SmbPseRMTableEntry(
        SEARCH,
        SMBPSE_OETYPE_COREQUERYLABEL,
        SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY,
        SMBPSE_RECEIVE_HANDLER_TOKEN_SEARCH_HANDLER,
        MRxSmbReceiveHandler_Search,
        0);

    SmbPseRMTableEntry(
        QUERY_INFORMATION_DISK,
        SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES,
        SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES,
        SMBPSE_RECEIVE_HANDLER_TOKEN_QUERYDISKINFO_HANDLER,
        MRxSmbReceiveHandler_QueryDiskInfo,
        0);

    SmbPseRMTableEntry(
        DELETE,
        SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,
        SMBPSE_OETYPE_DELETE_FOR_RENAME,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        DELETE_DIRECTORY,
        SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,
        SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        CHECK_DIRECTORY,
        SMBPSE_OETYPE_CORECHECKDIRECTORY,
        SMBPSE_OETYPE_CORECHECKDIRECTORY,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        SET_INFORMATION,
        SMBPSE_OETYPE_SFA,
        SMBPSE_OETYPE_SFA,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        SET_INFORMATION2,
        SMBPSE_OETYPE_SFA2,
        SMBPSE_OETYPE_SFA2,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        CREATE_DIRECTORY,
        SMBPSE_OETYPE_CORECREATEDIRECTORY,
        SMBPSE_OETYPE_CORECREATEDIRECTORY,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        FLUSH,
        SMBPSE_OETYPE_FLUSH,
        SMBPSE_OETYPE_FLUSH,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        FIND_CLOSE2,
        SMBPSE_OETYPE_FINDCLOSE,
        SMBPSE_OETYPE_FINDCLOSE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        RENAME,
        SMBPSE_OETYPE_RENAME,
        SMBPSE_OETYPE_RENAME,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        NT_RENAME,
        SMBPSE_OETYPE_RENAME,
        SMBPSE_OETYPE_RENAME,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);
}



#ifndef RX_NO_DBGFIELD_HLPRS

#define DECLARE_FIELD_HLPR(x) ULONG SmbPseOeField_##x = FIELD_OFFSET(SMB_PSE_ORDINARY_EXCHANGE,x);
#define DECLARE_FIELD_HLPR2(x,y) ULONG SmbPseOeField_##x##y = FIELD_OFFSET(SMB_PSE_ORDINARY_EXCHANGE,x.y);

DECLARE_FIELD_HLPR(RxContext);
DECLARE_FIELD_HLPR(ReferenceCount);
DECLARE_FIELD_HLPR(AssociatedStufferState);
DECLARE_FIELD_HLPR(Flags);
DECLARE_FIELD_HLPR(ReadWrite);
DECLARE_FIELD_HLPR(Transact2);
DECLARE_FIELD_HLPR2(Create,FileInfo);
DECLARE_FIELD_HLPR2(Create,smbSrvOpen);
DECLARE_FIELD_HLPR2(ReadWrite,RemainingByteCount);
DECLARE_FIELD_HLPR2(Info,FileInfo);
DECLARE_FIELD_HLPR2(Info,Buffer);
#endif





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbutils.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    smbutils.h

Abstract:

    This module defines the prototypes for various functions which aid in the assembly and
    disassembly of SMB's.

--*/

#ifndef _SMBUTILS_H_
#define _SMBUTILS_H_

extern
NTSTATUS
SmbPutString(
         PBYTE   *pBufferPointer,
         PSTRING pString,
         PULONG  pSize);

extern
NTSTATUS
SmbPutUnicodeString(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);

extern
NTSTATUS
SmbPutUnicodeStringAsOemString(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);


extern
NTSTATUS
SmbPutUnicodeStringAndUpcase(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);

extern
NTSTATUS
SmbPutUnicodeStringAsOemStringAndUpcase(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);

BOOLEAN
IsValidShortFileName(
    PUNICODE_STRING FileName
    );

#endif // _SMBUTILS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\sources.inc ===
!IF 0

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


TARGETNAME=smbmrx
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

SYNCHRONIZE_DRAIN=1

MONOLITHIC_MINIRDR=1

INCLUDES=$(INCLUDES); \
    	 $(IFSKIT_INC_PATH);

# @@BEGIN_DDKSPLIT
!IF 0
# @@END_DDKSPLIT

TARGETLIBS=$(DDK_LIB_PATH)\rdbsslib.lib	\
           $(DDK_LIB_PATH)\ksecdd.lib

# @@BEGIN_DDKSPLIT
!ENDIF

RDR2=$(PROJECT_ROOT)\fs\rdr2

INCLUDES=$(INCLUDES); \
    	 $(RDR2)\inc;

TARGETLIBS=$(RDR2)\rdbss\monolithic\obj\*\rdbsslib.lib	\
           $(DDK_LIB_PATH)\ksecdd.lib

# @@END_DDKSPLIT

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES= $(C_DEFINES) -DEXPLODE_POOLTAGS
!IF $(MONOLITHIC_MINIRDR)
C_DEFINES=$(C_DEFINES) -DMONOLITHIC_MINIRDR
!ENDIF


MOST_SOURCES=  \
    3connect.c \
    ea.c       \
    devfcb.c   \
    downlvli.c \
    downlvlo.c \
    fileinfo.c \
    fsctl.c    \
    init.c     \
    locks.c    \
    midatlas.c \
    mm.c       \
    netroot.c  \
    openclos.c \
    read.c     \
    recursvc.c \
    rename.c   \
    sessetup.c \
    smbadmin.c \
    smbcedb.c  \
    smbcemid.c \
    smbpse.c   \
    smbutils.c \
    smbxchng.c \
    sndrcv.c   \
    srvcall.c  \
    stuffer.c  \
    transact.c \
    transprt.c \
    vcsndrcv.c \
    write.c    \
    vnrcntxt.c \
    wmlkm.c

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

DLLDEF=$(_OBJ_DIR)\*\smbmrx.def



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbxchng.h ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    smbcxchng.h

Abstract:

    This is the include file that defines all constants and types for
    SMB exchange implementation.

Notes:

    An exchange is the core abstarction on which the SMB connection engine and
    the mini RDR are implemented. It encapsulates the notion of sending an SMB to
    the server and receiving the associated response, i.e, exchanging an SMB and
    hence the name.

    The exchange of an SMB with the server involves the following steps ....

         1) Submitting the formatted SMB buffer for transmission.
         2) Processing a send complete indication which ensures that at the
            transport level the SMB has been sent to the server.
         3) Processing the receive indication which contains all/part of the
            response sent by the server.
         4) Copying additional data not indicated by the transport

    There are a number of variations on this theme. For example there are certain
    SMB's for which no response is expected, e.g., certain SMB's which are
    inherently multi part in nature, TRANSACT smb's.

    In addition the steps outlined above will not always happen in that order. The
    precise sequence of events is dictated by the underlying transport chosen and
    the network conditions. It is this dependency that makes the implementation
    of exchanges challenging.

    The two primary goals that the current implementation was designed for are (1)
    performance and (2) encapsulation of transport dependencies. Goal(1) is
    important because this constitutes an integral part of the code path for
    exchanging any packet with the server. Goal (2) is important to ensure
    customization of the Rdr for different transports. This encapsulation provides
    a convenient vehicle for isolating SMB protocol level decisions from transport
    level decisons as much as possible.

    In addition the following goals were used to guide the implementation process ...

         1) The exchange implementation must be able to handle asynchronous
         operations and synchronous operations well. The trade offs were made in
         favour of asynchronous operations as and when required.

         2) Sufficient infrastructure support must be provided so as to ease the
         implementation of different flavours of exchanges.

    The SMB_EXCHANGE consists of a dispatch vector with the following functions

         1) Start                 -- to initiate the exchange
         2) Receive               -- to handle response indications from the server
         3) CopyDataHandler       -- to handle portions of the response not indicated
         4) SendCompletionHandler -- to handle send complete indications from the transport.
         5) QuiescentStateHandler -- to handle transitions to a quiescent state, i.e., no
                                     SMB connection engine operations are outstanding.

         Most kinds of exchange use the QuiescentStateHandler to finalize the
         operation and discard the exchange. However, certain kinds of exchanges
         which implement the notion of a macro exchange, i.e., exchange multiple
         SMB's use this to delineate different phases of the multiple exchange,
         e.g., ORDINARY_EXCHANGE which implements most file io operations.

    In addition to the dispatch vector the vanilla exchange consists of state
    information to record the current state of the exchange, sufficient context
    for resumption and context for handling SMB protocol related operations. The
    SMB protocol requires that each SMB sent to the server be stamped with a MID
    ( multiplex id. ) in order to distinguish between concurrent SMB exchanges.
    The connection engine provides this service.

    The exchange also encapsulates a SMBCE_EXCHANGE_CONTEXT instance which
    encapsulates all the information required for building a SMB_HEADER.

--*/

#ifndef _SMBXCHNG_H_
#define _SMBXCHNG_H_

typedef enum _SMBCE_STATE_ {
    SMBCE_START_IN_PROGRESS,
    SMBCE_STARTED,
    SMBCE_STOP_IN_PROGRESS,
    SMBCE_STOPPED
} SMBCE_STATE, *PSMBCE_STATE;

typedef struct _SMBCE_STARTSTOP_CONTEXT_ {
    SMBCE_STATE  State;
    LONG         ActiveExchanges;
    KEVENT       StopEvent;
    PKEVENT      pServerEntryTearDownEvent;
    LIST_ENTRY   SessionSetupRequests;
} SMBCE_STARTSTOP_CONTEXT, *PSMBCE_STARTSTOP_CONTEXT;

extern SMBCE_STARTSTOP_CONTEXT SmbCeStartStopContext;

//
// SMB_PROTOCOL_EXCHANGE dispatch vector function prototypes ..
//

// the initiator or the start routine
typedef
NTSTATUS
(*PSMB_EXCHANGE_START)(
    IN struct _SMB_EXCHANGE *pExchange);

// The SMB receive handler
typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_RECEIVE)(
    IN struct       _SMB_EXCHANGE *pExchange, // The exchange instance
    IN ULONG        BytesIndicated,
    IN ULONG        BytesAvailable,
    OUT ULONG       *BytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,      // buffer to copy unindicated data
    OUT PULONG      pDataSize,                // buffer size
    IN ULONG        ReceiveFlags
    );

// the SMB xmit callback
typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_SEND_CALLBACK)(
    IN struct _SMB_EXCHANGE     *pExchange,    // The exchange instance
    IN PMDL                   pDataBuffer,
    IN NTSTATUS               SendCompletionStatus
    );

// the copy data callback for fetching large data
typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_COPY_DATA_CALLBACK)(
    IN struct _SMB_EXCHANGE     *pExchange,      // the exchange instance
    IN PMDL                    pCopyDataBuffer, // the buffer
    IN ULONG                   CopyDataSize     // amount of data copied
    );

// the finalization routine
// This particular routine has a signature that is NT specific the IRQL
// parameter that is passed in and the notion of posting. This helps consolidate
// the NT transport driver model of indications at DPC level in SmbCeFinalizeExchange.
// On WIN95 the lease restrictive value of IRQL can be passed in.

typedef
NTSTATUS
(*PSMB_EXCHANGE_FINALIZE)(
   IN OUT struct _SMB_EXCHANGE *pExchange,
   OUT    BOOLEAN              *pPostRequest);

typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_ASSOCIATED_EXCHANGES_COMPLETION)(
    IN OUT struct _SMB_EXCHANGE *pExchange,
    OUT    BOOLEAN              *pPostRequest);

// The Exchange dispatch vector definition

typedef struct _SMB_EXCHANGE_DISPATCH_VECTOR_ {
    PSMB_EXCHANGE_START                                 Start;
    PSMB_EXCHANGE_IND_RECEIVE                           Receive;
    PSMB_EXCHANGE_IND_COPY_DATA_CALLBACK                CopyDataHandler;
    PSMB_EXCHANGE_IND_SEND_CALLBACK                     SendCompletionHandler;
    PSMB_EXCHANGE_FINALIZE                              Finalize;
    PSMB_EXCHANGE_IND_ASSOCIATED_EXCHANGES_COMPLETION   AssociatedExchangesCompletionHandler;
} SMB_EXCHANGE_DISPATCH_VECTOR, *PSMB_EXCHANGE_DISPATCH_VECTOR;

// An enumerated type listing the type of exchanges

typedef enum _SMB_EXCHANGE_TYPE_ {
    CONSTRUCT_NETROOT_EXCHANGE,
    ORDINARY_EXCHANGE,
    TRANSACT_EXCHANGE,
    ADMIN_EXCHANGE,
    SENTINEL_EXCHANGE
} SMB_EXCHANGE_TYPE, *PSMB_EXCHANGE_TYPE;

// known exchange type dispatch vectors

extern SMB_EXCHANGE_DISPATCH_VECTOR ConstructNetRootExchangeDispatch;
extern SMB_EXCHANGE_DISPATCH_VECTOR OrdinaryExchangeDispatch;
extern SMB_EXCHANGE_DISPATCH_VECTOR TransactExchangeDispatch;

// The various states of the exchange. Each exchange transitions from
// the SMBCE_EXCHANGE_INITIALIZATION_START to SMBCE_EXCHANGE_INITIATED  or
// SMBCE_EXCHANGE_ABORTED state.

typedef enum _SMBCE_EXCHANGE_STATE_ {
    SMBCE_EXCHANGE_INITIALIZATION_START,
    SMBCE_EXCHANGE_SERVER_INITIALIZED,
    SMBCE_EXCHANGE_SESSION_INITIALIZED,
    SMBCE_EXCHANGE_NETROOT_INITIALIZED,
    SMBCE_EXCHANGE_INITIATED,
    SMBCE_EXCHANGE_ABORTED
} SMBCE_EXCHANGE_STATE, *PSMBCE_EXCHANGE_STATE;

// The exchange encapsulates the transport information from the clients. The
// Exchange engine is sandwiched between the protocol selection engine in the
// mini redirector on one side and the various transports on the other side.
// The transport information encapsulates the various categories of transport
// the exchange engine understands.

typedef struct SMBCE_EXCHANGE_TRANSPORT_INFORMATION {
    union {
        struct {
            struct _SMBCE_VC *pVc;
        } Vcs;
        struct {
             ULONG Dummy;
        } Datagrams;
        struct {
             ULONG Dummy;
        } Hybrid;
     };
} SMBCE_EXCHANGE_TRANSPORT_CONTEXT,
  *PSMBCE_EXCHANGE_TRANSPORT_CONTEXT;

typedef struct _SMBCE_EXCHANGE_CONTEXT_ {
    PMRX_V_NET_ROOT                      pVNetRoot;
    PSMBCEDB_SERVER_ENTRY                pServerEntry;
    PSMBCE_V_NET_ROOT_CONTEXT            pVNetRootContext;
    SMBCE_EXCHANGE_TRANSPORT_CONTEXT     TransportContext;
} SMBCE_EXCHANGE_CONTEXT,*PSMBCE_EXCHANGE_CONTEXT;

//
// Similar to the subclassing of SMB net roots the SMB_EXCHANGE will be subclassed
// further to deal with various types of SMB exchanges. SMB exchanges can be roughly
// classified into the following types based on the interactions involved ...
//
// The SMB's that need to be exchanged need to be augmented with some admin SMB's which
// are required for the maintenance of SMB's in the connection engine.

#define SMBCE_EXCHANGE_MID_VALID                   (0x1)
#define SMBCE_EXCHANGE_REUSE_MID                   (0x2)
#define SMBCE_EXCHANGE_RETAIN_MID                  (SMBCE_EXCHANGE_REUSE_MID)
#define SMBCE_EXCHANGE_MULTIPLE_SENDS_POSSIBLE     (0x4)
#define SMBCE_EXCHANGE_FINALIZED                   (0x8)

#define SMBCE_EXCHANGE_ATTEMPT_RECONNECTS           (0x10)
#define SMBCE_EXCHANGE_INDEFINITE_DELAY_IN_RESPONSE (0x20)

#define SMBCE_EXCHANGE_MAILSLOT_OPERATION           (0x40)

#define SMBCE_EXCHANGE_SESSION_CONSTRUCTOR         (0x100)
#define SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR         (0x200)

#define SMBCE_EXCHANGE_NOT_FROM_POOL               (0x800)

#define SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION     (0x1000)
#define SMBCE_EXCHANGE_TIMEDOUT                    (0x2000)

#define SMBCE_EXCHANGE_FULL_PROCESSID_SPECIFIED    (0x4000)

#define SMBCE_EXCHANGE_SMBCE_STOPPED               (0x8000)

#define SMBCE_ASSOCIATED_EXCHANGE                  (0x80000000)
#define SMBCE_ASSOCIATED_EXCHANGES_COMPLETION_HANDLER_ACTIVATED (0x40000000)

#define SMBCE_EXCHANGE_FLAGS_TO_PRESERVE           (SMBCE_EXCHANGE_NOT_FROM_POOL)

#define SMBCE_OPLOCK_RESPONSE_MID    (0xffff)
#define SMBCE_MAILSLOT_OPERATION_MID (0xffff)
#define SMBCE_ECHO_PROBE_MID         (0xfffe)

//
// The cancellation status is defined as a PVOID instead of a BOOLEAN to allow
// us the use of Interlocked manipulation instructions
// There are only two states SMBCE_EXCHANGE_CANCELLED, SMBCE_EXCHANGE_ACTIVE
//

#define SMBCE_EXCHANGE_CANCELLED     (0xcccccccc)
#define SMBCE_EXCHANGE_NOT_CANCELLED (0xaaaaaaaa)

// The Exchange definition

typedef struct _SMB_EXCHANGE {
    union {
        UCHAR                     Type;
        struct {
            NODE_TYPE_CODE        NodeTypeCode;     // node type.
            NODE_BYTE_SIZE        NodeByteSize;     // node size.
            LONG                  ReferenceCount;
        };
    };

    LIST_ENTRY                    SmbMmInUseListEntry;

    PRX_CONTEXT                   RxContext;            //use of these two fields is advisory
    PVOID                         LastExecutingThread;  //OE and Xact will use them

    union {
        NTSTATUS                  SmbStatus;
        PMRX_SMB_SRV_OPEN         SmbSrvOpen;
    };
    NTSTATUS                      Status;

    ULONG                         ServerVersion;
    SMB_EXCHANGE_ID               Id;

    USHORT                        SmbCeState;

    USHORT                        MidCookie;
    SMB_MPX_ID                    Mid;

    LONG                          CancellationStatus;

    ULONG                         SmbCeFlags;
    SMBCE_EXCHANGE_CONTEXT        SmbCeContext;

    LONG                          SendCompletePendingOperations;
    LONG                          CopyDataPendingOperations;
    LONG                          ReceivePendingOperations;
    LONG                          LocalPendingOperations;

    PKEVENT                       pSmbCeSynchronizationEvent;

    LIST_ENTRY                    ExchangeList;
    LARGE_INTEGER                 ExpiryTime;

    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector;

    union {
        struct {
            struct _SMB_EXCHANGE  *pMasterExchange;
            SINGLE_LIST_ENTRY     NextAssociatedExchange;
        } Associated;
        struct {
            SINGLE_LIST_ENTRY     AssociatedExchangesToBeFinalized;
            LONG                  PendingAssociatedExchanges;
        } Master;
    };

    RX_WORK_QUEUE_ITEM            WorkQueueItem;

    ULONG                         ExchangeTransportInitialized;
    NTSTATUS                      SessionSetupStatus;
} SMB_EXCHANGE, *PSMB_EXCHANGE;


INLINE PSMBCEDB_SERVER_ENTRY
SmbCeGetExchangeServerEntry(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    ASSERT(pSmbExchange->SmbCeContext.pServerEntry != NULL);

    return pSmbExchange->SmbCeContext.pServerEntry;
}

INLINE PSMBCE_SERVER
SmbCeGetExchangeServer(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    return &(pSmbExchange->SmbCeContext.pServerEntry->Server);
}

INLINE PSMBCEDB_SESSION_ENTRY
SmbCeGetExchangeSessionEntry(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    if (pSmbExchange->SmbCeContext.pVNetRootContext != NULL) {
        return pSmbExchange->SmbCeContext.pVNetRootContext->pSessionEntry;
    } else {
        return NULL;
    }
}

INLINE PSMBCE_SESSION
SmbCeGetExchangeSession(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    if (pSmbExchange->SmbCeContext.pVNetRootContext != NULL) {
        return &(pSmbExchange->SmbCeContext.pVNetRootContext->pSessionEntry->Session);
    } else {
        return NULL;
    }
}

INLINE PSMBCEDB_NET_ROOT_ENTRY
SmbCeGetExchangeNetRootEntry(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    if (pSmbExchange->SmbCeContext.pVNetRootContext != NULL) {
        return pSmbExchange->SmbCeContext.pVNetRootContext->pNetRootEntry;
    } else {
        return NULL;
    }
}

INLINE PSMBCE_NET_ROOT
SmbCeGetExchangeNetRoot(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    if (pSmbExchange->SmbCeContext.pVNetRootContext != NULL) {
        return &(pSmbExchange->SmbCeContext.pVNetRootContext->pNetRootEntry->NetRoot);
    } else {
        return NULL;
    }
}

INLINE  PMRX_V_NET_ROOT
SmbCeGetExchangeVNetRoot(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    return pSmbExchange->SmbCeContext.pVNetRoot;
}

INLINE PSMBCE_V_NET_ROOT_CONTEXT
SmbCeGetExchangeVNetRootContext(PVOID pExchange)
{
    PSMB_EXCHANGE pSmbExchange = (PSMB_EXCHANGE)pExchange;

    return pSmbExchange->SmbCeContext.pVNetRootContext;
}

extern ULONG SmbCeTraceExchangeReferenceCount;

// The following functions ( inline, macros and otherwise ) are defined
// to manipulate the exchanges

// The reset exchange macro provides a mechanism for forcing the exchange
// instance to a well known start state. This is used by the protocol
// selection engine to transceive different SMB's. A note of caution --
// ensure that the conditions are O.K for initialization. There is no well
// known mechanism in the exchange engine to prevent overwriting an
// exchange instance while in use.

#define SmbCeResetExchange(pExchange)                                   \
        (pExchange)->SmbCeFlags &= ~SMBCE_EXCHANGE_FINALIZED;           \
        (pExchange)->ReceivePendingOperations = 0;                      \
        (pExchange)->CopyDataPendingOperations = 0;                     \
        (pExchange)->SendCompletePendingOperations = 0;                 \
        (pExchange)->LocalPendingOperations = 0;                        \
        (pExchange)->Status = STATUS_SUCCESS;                           \
        (pExchange)->SmbStatus = STATUS_SUCCESS

// The following macros provide a mechanism for referencing and dereferencing
// the exchange. The reference count provides a mechanism for detecting
// when an exchange instance can be safely discarded. The reference count
// differs from the pending operations count maintained in the exchange
// which are used to detect when a quiescent state is reached.

#define SmbCeReferenceExchange(pExchange)                               \
        InterlockedIncrement(&(pExchange)->ReferenceCount);             \
        if (SmbCeTraceExchangeReferenceCount) {                         \
           DbgPrint("Reference Exchange %lx Type(%ld) %s %ld %ld\n",    \
                     (pExchange),                                       \
                     (pExchange)->Type,                                 \
                      __FILE__,                                         \
                      __LINE__,                                         \
                      (pExchange)->ReferenceCount);                     \
        }

#define SmbCeDereferenceExchange(pExchange)                             \
        InterlockedDecrement(&(pExchange)->ReferenceCount);             \
        if (SmbCeTraceExchangeReferenceCount) {                         \
           DbgPrint("Dereference Exchange %lx Type(%ld) %s %ld %ld\n",  \
                     (pExchange),                                       \
                     (pExchange)->Type,                                 \
                     __FILE__,                                          \
                     __LINE__,                                          \
                     (pExchange)->ReferenceCount);                      \
        }


#define SmbCeDereferenceAndDiscardExchange(pExchange)                    \
        if (InterlockedDecrement(&(pExchange)->ReferenceCount) == 0) {   \
            SmbCeDiscardExchange(pExchange);                             \
        }                                                                \
        if (SmbCeTraceExchangeReferenceCount) {                          \
            DbgPrint("Dereference Exchange %lx Type(%ld) %s %ld %ld\n",  \
                 (pExchange),                                            \
                 (pExchange)->Type,                                      \
                 __FILE__,                                               \
                 __LINE__,                                               \
                 (pExchange)->ReferenceCount);                           \
        }

// Macros to hide the syntactic details of dereferencing and calling a
// routine in a dispatch vector. These macros are purely intended for
// use in the connection engine only and is not meant for use by
// other modules.

#define SMB_EXCHANGE_DISPATCH(pExchange,Routine,Arguments)        \
      (*((pExchange)->pDispatchVector->Routine))##Arguments

#define SMB_EXCHANGE_POST(pExchange,Routine)                          \
         RxPostToWorkerThread(&(pExchange)->WorkItem.WorkQueueItem,   \
                              (pExchange)->pDispatchVector->Routine,  \
                              (pExchange))

// The following enum type defines the result of invoking the finalization routine
// on an exchange instance.

typedef enum _SMBCE_EXCHANGE_STATUS_ {
    SmbCeExchangeAlreadyFinalized,
    SmbCeExchangeFinalized,
    SmbCeExchangeNotFinalized
} SMBCE_EXCHANGE_STATUS, *PSMBCE_EXCHANGE_STATUS;

// The pending operations associated with an exchange are classified into four kinds
// Receive operations, Copy Data Operations, Send Complete and Local operations.
// These need to be incremented under the protection of a spinlock. However they
// are decremented in the absence of a spinlock ( with the respective assert ).


#define SMBCE_LOCAL_OPERATION         0x1
#define SMBCE_SEND_COMPLETE_OPERATION 0x2
#define SMBCE_COPY_DATA_OPERATION     0x4
#define SMBCE_RECEIVE_OPERATION       0x8

extern NTSTATUS
SmbCeIncrementPendingOperations(
    PSMB_EXCHANGE  pExchange,
    ULONG          PendingOperationsMask,
    PVOID          FileName,
    ULONG          FileLine);

extern NTSTATUS
SmbCeDecrementPendingOperations(
    PSMB_EXCHANGE  pExchange,
    ULONG          PendingOperationsMask,
    PVOID          FileName,
    ULONG          FileLine);

extern SMBCE_EXCHANGE_STATUS
SmbCeDecrementPendingOperationsAndFinalize(
    PSMB_EXCHANGE  pExchange,
    ULONG          PendingOperationsMask,
    PVOID          FileName,
    ULONG          FileLine);

// the pending operations increment routines

#define SmbCeIncrementPendingReceiveOperations(pExchange)           \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_RECEIVE_OPERATION),__FILE__,__LINE__)

#define SmbCeIncrementPendingSendCompleteOperations(pExchange)      \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_SEND_COMPLETE_OPERATION),__FILE__,__LINE__)

#define SmbCeIncrementPendingCopyDataOperations(pExchange)         \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_COPY_DATA_OPERATION),__FILE__,__LINE__)

#define SmbCeIncrementPendingLocalOperations(pExchange)                \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_LOCAL_OPERATION),__FILE__,__LINE__)

// The pending operations decrement routines
// Note the special casing of ReceivePendingOperations since it is the only one
// that can be forced by a disconnect indication. There are two variations in
// the decrement macros. The first flavour is to be used when it can be
// guaranteed that the decrement operation will not lead to the finalization
// of the exchange and the second is to be used when we cannot ensure the criterion
// for the first. The difference between the two is that it eliminates
// acquisition/release of a spinlock.

#define SmbCeDecrementPendingReceiveOperations(pExchange)                  \
        SmbCeDecrementPendingOperations(pExchange,(SMBCE_RECEIVE_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingSendCompleteOperations(pExchange)              \
        SmbCeDecrementPendingOperations(pExchange,(SMBCE_SEND_COMPLETE_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingCopyDataOperations(pExchange)              \
        SmbCeDecrementPendingOperations(pExchange,(SMBCE_COPY_DATA_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingLocalOperations(pExchange)                  \
        SmbCeDecrementPendingOperations(pExchange,(SMBCE_LOCAL_OPERATION),__FILE__,__LINE__)

// The pending operations decrement routines

#define SmbCeDecrementPendingReceiveOperationsAndFinalize(pExchange)          \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_RECEIVE_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingSendCompleteOperationsAndFinalize(pExchange)     \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_SEND_COMPLETE_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingCopyDataOperationsAndFinalize(pExchange)         \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_COPY_DATA_OPERATION),__FILE__,__LINE__)

#define SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange)            \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_LOCAL_OPERATION),__FILE__,__LINE__)

//
// This is the pid that will be used by the rdr; rdr1 used 0xcafe.
// only this pid is ever sent except for nt<-->nt creates. in these cases,
// we have to send the full 32bit process id for RPC.
//

#define MRXSMB_PROCESS_ID (0xfeff)

INLINE VOID
SmbCeSetFullProcessIdInHeader(
    PSMB_EXCHANGE  pExchange,
    ULONG          ProcessId,
    PNT_SMB_HEADER pNtSmbHeader)
{
    pExchange->SmbCeFlags |= SMBCE_EXCHANGE_FULL_PROCESSID_SPECIFIED;
    SmbPutUshort(&pNtSmbHeader->Pid, (USHORT)((ProcessId) & 0xFFFF));
    SmbPutUshort(&pNtSmbHeader->PidHigh, (USHORT)((ProcessId) >> 16));
}

// The exchange engine API, for creation and manipulation of exchange instances

// Initialization/Creation of an exchange instance

extern NTSTATUS
SmbCepInitializeExchange(
    PSMB_EXCHANGE                 *pExchangePointer,
    PRX_CONTEXT                   pRxContext,
    PSMBCEDB_SERVER_ENTRY         pServerEntry,
    PMRX_V_NET_ROOT               pVNetRoot,
    SMB_EXCHANGE_TYPE             ExchangeType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);


INLINE NTSTATUS
SmbCeInitializeExchange(
    PSMB_EXCHANGE                   *pExchangePointer,
    PRX_CONTEXT                     pRxContext,
    PMRX_V_NET_ROOT                 pVNetRoot,
    SMB_EXCHANGE_TYPE               ExchangeType,
    PSMB_EXCHANGE_DISPATCH_VECTOR   pDispatchVector)
{
    return SmbCepInitializeExchange(
               pExchangePointer,
               pRxContext,
               NULL,
               pVNetRoot,
               ExchangeType,
               pDispatchVector);
}

INLINE NTSTATUS
SmbCeInitializeExchange2(
    PSMB_EXCHANGE                   *pExchangePointer,
    PRX_CONTEXT                     pRxContext,
    PSMBCEDB_SERVER_ENTRY           pServerEntry,
    SMB_EXCHANGE_TYPE               ExchangeType,
    PSMB_EXCHANGE_DISPATCH_VECTOR   pDispatchVector)
{
    return SmbCepInitializeExchange(
               pExchangePointer,
               pRxContext,
               pServerEntry,
               NULL,
               ExchangeType,
               pDispatchVector);
}


extern NTSTATUS
SmbCeInitializeAssociatedExchange(
    PSMB_EXCHANGE                 *pAssociatedExchangePointer,
    PSMB_EXCHANGE                 pMasterExchange,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

// converting one type of exchange to another

extern NTSTATUS
SmbCeTransformExchange(
    PSMB_EXCHANGE                 pExchange,
    SMB_EXCHANGE_TYPE             NewType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

// Initiating an exchange

extern NTSTATUS
SmbCeInitiateExchange(PSMB_EXCHANGE pExchange);

extern NTSTATUS
SmbCeInitiateAssociatedExchange(
    PSMB_EXCHANGE   pAssociatedExchange,
    BOOLEAN         EnableCompletionHandlerInMasterExchange);

// Resuming an exchange

extern NTSTATUS
SmbCeResumeExchange(PSMB_EXCHANGE pExchange);

// aborting an initiated exchange

extern NTSTATUS
SmbCeAbortExchange(PSMB_EXCHANGE pExchange);

// discarding an exchnge instance

extern VOID
SmbCeDiscardExchange(PVOID pExchange);

// In addition to providing a flexible mechanism for exchanging packets with
// the server the exchange engine also provides a mechanism for building and
// parsing SMB_HEADER's. This functionality is built into the connection
// engine because the meta data in the headers is used to update the connection
// engine database.

// building SMB headers

extern NTSTATUS
SmbCeBuildSmbHeader(
    IN OUT PSMB_EXCHANGE    pExchange,
    IN OUT PVOID            pBuffer,
    IN     ULONG            BufferLength,
    OUT    PULONG           pRemainingBuffer,
    OUT    PUCHAR           pLastCommandInHeader,
    OUT    PUCHAR           *pNextCommand);

// parsing SMB headers.

extern NTSTATUS
SmbCeParseSmbHeader(
    PSMB_EXCHANGE     pExchange,
    PSMB_HEADER       pSmbHeader,
    PGENERIC_ANDX     pCommandToProcess,
    NTSTATUS          *pSmbResponseStatus,
    ULONG             BytesAvailable,
    ULONG             BytesIndicated,
    PULONG            pBytesConsumed);


// The following routines are intended for use in the connection engine only.

extern NTSTATUS
MRxSmbInitializeSmbCe();

extern NTSTATUS
MRxSmbTearDownSmbCe();

extern NTSTATUS
SmbCePrepareExchangeForReuse(PSMB_EXCHANGE pExchange);

extern PVOID
SmbCeMapSendBufferToCompletionContext(
    PSMB_EXCHANGE                 pExchange,
    PVOID                         pBuffer);

extern PVOID
SmbCeMapSendCompletionContextToBuffer(
    PSMB_EXCHANGE                 pExchange,
    PVOID                         pContext);


extern SMBCE_EXCHANGE_STATUS
SmbCeFinalizeExchange(PSMB_EXCHANGE pExchange);

extern VOID
SmbCeFinalizeExchangeOnDisconnect(
    PSMB_EXCHANGE pExchange);

extern NTSTATUS
SmbCeReferenceServer(
    PSMB_EXCHANGE  pExchange);


extern NTSTATUS
SmbCeIncrementActiveExchangeCount();

extern VOID
SmbCeDecrementActiveExchangeCount();

extern VOID
SmbCeSetExpiryTime(
    PSMB_EXCHANGE pExchange);

extern BOOLEAN
SmbCeDetectExpiredExchanges(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCepFinalizeAssociatedExchange(
    PSMB_EXCHANGE pExchange);

extern NTSTATUS
SmbCeCancelExchange(
    PRX_CONTEXT pRxContext);

typedef struct _SMB_CONSTRUCT_NETROOT_EXCHANGE_ {
    union {
        SMB_EXCHANGE;
        SMB_EXCHANGE Exchange;
    };
    SMB_TREE_ID                 TreeId;
    SMB_USER_ID                 UserId;
    BOOLEAN                     fUpdateDefaultSessionEntry;
    BOOLEAN                     fInitializeNetRoot;
    PMRX_NETROOT_CALLBACK       NetRootCallback;
    PMDL                        pSmbRequestMdl;
    PMDL                        pSmbResponseMdl;
    PVOID                       pSmbActualBuffer;              // Originally allocated buffer
    PVOID                       pSmbBuffer;                    // Start of header
    PMRX_CREATENETROOT_CONTEXT  pCreateNetRootContext;
} SMB_CONSTRUCT_NETROOT_EXCHANGE, *PSMB_CONSTRUCT_NETROOT_EXCHANGE;

extern
NTSTATUS
GetSmbResponseNtStatus(
    IN PSMB_HEADER      pSmbHeader,
    IN PSMB_EXCHANGE    pExchange
    );

#endif // _SMBXCHNG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbxchng.c ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    smbcxchng.c

Abstract:

    This is the include file that implements the SMB_*_EXCHANGE creation, deletion and
    dispatch routines.

Notes:

    The exchange engine supports two kinds of changes, timed and untimed exhanges.
    The timed exchanges are distinguished by the SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION.

    In addition all exchanges are finalized if the transport is not able to push out
    the data within a specific period of time. This enables us to throttle back
    traffic to a overloaded server. Currently this is a global constant for all exchanges
    and is set to 300 seconds.

    This time limit only comes into play only when a send complete operation is outstanding

    The exchanges are put on a timed exchange list ( one for each type of exchange)
    when it is initiated. When a network operation, i.e., tranceive/send/copydata is
    initiated the corresponding expiry time in the exchange is updated by invoking the
    routine SmbCeSetExpiryTime.

    The echo probes are initiated is invoked through the context of a recurrent service
    (recursvc.c/recursvc.h). Every time this service is invoked (SmbCeProbeServers) it
    in turn invokes SmbCeDetectAndResumeExpiredExchanges. This routine detects those
    exchanges for which the wait for a response has exceeded the time limit and marks
    them for finalization.

    The finalization is done by SmbCeScavengeTimedOutExchanges in the context of a worker
    thread. Notice that due to the granularity mismatch we treat timeout intervals as
    soft deadlines.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbInitializeSmbCe)
#pragma alloc_text(PAGE, SmbCeInitiateExchange)
#pragma alloc_text(PAGE, SmbCeInitiateAssociatedExchange)
#pragma alloc_text(PAGE, SmbCeExchangeAbort)
#pragma alloc_text(PAGE, SmbCeBuildSmbHeader)
#pragma alloc_text(PAGE, SmbCeResumeExchange)
#pragma alloc_text(PAGE, SmbCepInitializeExchange)
#pragma alloc_text(PAGE, SmbCeInitializeAssociatedExchange)
#pragma alloc_text(PAGE, SmbCeTransformExchange)
#pragma alloc_text(PAGE, SmbCePrepareExchangeForReuse)
#pragma alloc_text(PAGE, SmbCeDiscardExchange)
#pragma alloc_text(PAGE, SmbCeFinalizeExchangeWorkerThreadRoutine)
#pragma alloc_text(PAGE, SmbCeFinalizeExchangeOnDisconnect)
#pragma alloc_text(PAGE, SmbCeDetectExpiredExchanges)
#pragma alloc_text(PAGE, DefaultSmbExchangeIndError)
#pragma alloc_text(PAGE, DefaultSmbExchangeIndReceive)
#pragma alloc_text(PAGE, DefaultSmbExchangeIndSendCallback)
#endif

ULONG SmbCeTraceExchangeReferenceCount = 0;

RXDT_DefineCategory(SMBXCHNG);
#define Dbg        (DEBUG_TRACE_SMBXCHNG)

// The exchange engine in the mini redirector requires to maintain enough state
// to ensure that all the active exchanges are completed correctly when a shut down
// occurs. Since the exchanges can be finalized by different threads, including
// posted completions the exchange engine on startup initializes an event upon startup
// which is subsequently used to signal the terminating condition.
//
// The count of active changes has to be tracked continously and the signalling
// of the event depends upon the number of active exchanges reaching the count of
// zero and the exchange engine being in a stopped state.

SMBCE_STARTSTOP_CONTEXT SmbCeStartStopContext;

NTSTATUS
MRxSmbInitializeSmbCe()
/*++

Routine Description:

   This routine initializes the connection engine

Return Value:

    NXSTATUS - The return status for the operation

Notes:

--*/
{
    LONG i;

    PAGED_CODE();

    KeInitializeEvent(
        &SmbCeStartStopContext.StopEvent,
        NotificationEvent,
        FALSE);

    SmbCeStartStopContext.ActiveExchanges = 0;
    SmbCeStartStopContext.State = SMBCE_STARTED;
    SmbCeStartStopContext.pServerEntryTearDownEvent = NULL;

    InitializeListHead(
        &SmbCeStartStopContext.SessionSetupRequests);

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbTearDownSmbCe()
/*++

Routine Description:

   This routine tears down the connection engine

Return Value:

    NXSTATUS - The return status for the operation

Notes:

--*/
{
    BOOLEAN fWait;

    if (SmbCeStartStopContext.State == SMBCE_STARTED) {
        SmbCeAcquireSpinLock();
        SmbCeStartStopContext.State = SMBCE_STOPPED;
        fWait = (SmbCeStartStopContext.ActiveExchanges > 0);
        SmbCeReleaseSpinLock();

        if (fWait) {
            KeWaitForSingleObject(
                &SmbCeStartStopContext.StopEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SmbCeIncrementActiveExchangeCount()
/*++

Routine Description:

   This routine increments the active exchange count

Return Value:

    NXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    SmbCeAcquireSpinLock();
    if (SmbCeStartStopContext.State != SMBCE_STARTED) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        InterlockedIncrement(&SmbCeStartStopContext.ActiveExchanges);
    }
    SmbCeReleaseSpinLock();

    return Status;
}

VOID
SmbCeDecrementActiveExchangeCount()
/*++

Routine Description:

   This routine decrements the active exchange count

Return Value:

    NXSTATUS - The return status for the operation

Notes:

--*/
{
    LONG FinalRefCount;

    ASSERT(SmbCeStartStopContext.ActiveExchanges > 0);
    if (InterlockedDecrement(&SmbCeStartStopContext.ActiveExchanges) == 0) {
        SmbCeAcquireSpinLock();
        if (SmbCeStartStopContext.State == SMBCE_STOPPED) {
            KeSetEvent(&SmbCeStartStopContext.StopEvent,0,FALSE);
        }
        SmbCeReleaseSpinLock();
    }
}


NTSTATUS
SmbCeReferenceServer(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

   This routine initializes the server associated with an exchange.

Arguments:

    pExchange  - the exchange to be initialized.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

    The session and net roots are aliased entities, i.e., there is more then one reference
    to it. It is conceivable that the construction is in progress when a reference is made.
    In such cases the exchange is suspended and resumed when the construction is complete.

    On some transports a reconnect is possible without having to tear down an existing
    connection, i.e. attempting to send a packet reestablishes the connection at the
    lower level. Since this is not supported by all the transports ( with the exception
    of TCP/IP) the reference server entry initiates this process by tearing down the
    existing transport and reinitialising it.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    ASSERT(SmbCeIsResourceOwned());
    ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_INITIALIZATION_START);

    if (pServerEntry->Header.State != SMBCEDB_ACTIVE) {
        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) {
            switch (pServerEntry->Header.State) {
            case SMBCEDB_INVALID:
                {
                    SMBCEDB_OBJECT_STATE State;

                    ASSERT(!pServerEntry->NegotiateInProgress);
                    pServerEntry->NegotiateInProgress = TRUE;

                    SmbCeUpdateServerEntryState(
                        pServerEntry,
                        SMBCEDB_CONSTRUCTION_IN_PROGRESS);

                    SmbCeReleaseResource();

                    // Initialize the transport associated with the server
                    Status = SmbCeInitializeServerTransport(pServerEntry,NULL,NULL);

                    if (Status == STATUS_SUCCESS) {

                        PSMBCEDB_SESSION_ENTRY pSessionEntry =
                            SmbCeGetExchangeSessionEntry(pExchange);

                        Status = SmbCeNegotiate(
                                     pServerEntry,
                                     pServerEntry->pRdbssSrvCall
                                     );
                    }

                    SmbCeCompleteServerEntryInitialization(pServerEntry,Status);

                    if (Status != STATUS_SUCCESS) {
                        // Either the transport initialization failed or the NEGOTIATE
                        // SMB could not be sent ....

                        InterlockedIncrement(&MRxSmbStatistics.Reconnects);
                    }

                    SmbCeAcquireResource();
                }
                break;

            case SMBCEDB_CONSTRUCTION_IN_PROGRESS :
                {
                    PSMBCEDB_REQUEST_ENTRY pRequestEntry;

                    pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)
                                    SmbMmAllocateObject(SMBCEDB_OT_REQUEST);
                    if (pRequestEntry != NULL) {
                        // Enqueue the request entry.
                        pRequestEntry->ReconnectRequest.Type      = RECONNECT_REQUEST;
                        pRequestEntry->ReconnectRequest.pExchange = pExchange;

                        SmbCeIncrementPendingLocalOperations(pExchange);
                        SmbCeAddRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);

                        Status = STATUS_PENDING;
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                break;

            default :
                Status = STATUS_CONNECTION_DISCONNECTED;
                break;
            }
        } else {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
    }

    if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
        pExchange->SmbCeState = SMBCE_EXCHANGE_SERVER_INITIALIZED;
    }

    ASSERT(SmbCeIsResourceOwned());

    return Status;
}


NTSTATUS
SmbCeReferenceSession(
    PSMB_EXCHANGE   pExchange)
/*++

Routine Description:

    This routine initializes the session associated with an exchange.

Arguments:

    pExchange  - the exchange to be initialized.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

    The session and net roots are aliased entities, i.e., there is more then one reference
    to it. It is conceivable that the construction is in progress when a reference is made.
    In such cases the exchange is suspended and resumed when the construction is complete.
--*/
{
    NTSTATUS Status;
    BOOLEAN  fReestablishSession;
    BOOLEAN  UnInitializeSecurityContext = FALSE;

    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    PSMBCEDB_SESSION_ENTRY pSessionEntry;

    fReestablishSession = BooleanFlagOn(
                              pExchange->SmbCeFlags,
                              SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

    for (;;) {

        pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
        pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);

        ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);
        ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_SERVER_INITIALIZED);
        ASSERT(SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER);
        ASSERT(SmbCeIsResourceOwned());

        Status = STATUS_USER_SESSION_DELETED;

        if (pSessionEntry == NULL) {
            break;
        }

        switch (pSessionEntry->Header.State) {
        case SMBCEDB_ACTIVE:
            Status = STATUS_SUCCESS;
            break;

        case SMBCEDB_INVALID:
            if (!fReestablishSession) {
                break;
            }

            RxDbgTrace( 0, Dbg, ("SmbCeReferenceSession: Reestablishing session\n"));
            // fall thru ...

        case SMBCEDB_START_CONSTRUCTION:
            {
                RxDbgTrace( 0, Dbg, ("SmbCeReferenceSession: Reestablishing session\n"));
                pSessionEntry->Session.UserId = 0;

                ASSERT(SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER);
                pExchange->SmbCeFlags |= SMBCE_EXCHANGE_SESSION_CONSTRUCTOR;
                pSessionEntry->pExchange = pExchange;
                pSessionEntry->Header.State = SMBCEDB_CONSTRUCTION_IN_PROGRESS;
                Status = STATUS_SUCCESS;

            }
            break;

        case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
            if (fReestablishSession) {
                // The construction of the session is already in progress ....
                // Queue up the request to resume this exchange when the session
                // construction is complete.

                PSMBCEDB_REQUEST_ENTRY pRequestEntry;

                ASSERT(SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER);

                pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)
                                 SmbMmAllocateObject(SMBCEDB_OT_REQUEST);

                if (pRequestEntry != NULL) {
                    pRequestEntry->Request.pExchange = pExchange;

                    SmbCeIncrementPendingLocalOperations(pExchange);
                    SmbCeAddRequestEntry(&pSessionEntry->Requests,pRequestEntry);

                    Status = STATUS_PENDING;
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                fReestablishSession = FALSE;
            }
            break;

        case SMBCEDB_MARKED_FOR_DELETION:
            Status = STATUS_USER_SESSION_DELETED;
            break;

        default:
            ASSERT(!"Valid Session State, SmbCe database corrupt");
            Status = STATUS_USER_SESSION_DELETED;
        }

        {
            if (UnInitializeSecurityContext) {
                SmbCeReleaseResource();
                UninitializeSecurityContextsForSession(&pSessionEntry->Session);
                SmbCeAcquireResource();
            }

            break;
        }
    }

    if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
        pExchange->SmbCeState = SMBCE_EXCHANGE_SESSION_INITIALIZED;
    }

    ASSERT(SmbCeIsResourceOwned());

    return Status;
}

NTSTATUS
SmbCeReferenceNetRoot(
    PSMB_EXCHANGE   pExchange)
/*++

Routine Description:

    This routine initializes the net root associated with an exchange.

Arguments:

    pExchange  - the exchange to be initialized.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

    The session and net roots are aliased entities, i.e., there is more then one reference
    to it. It is conceivable that the construction is in progress when a reference is made.
    In such cases the exchange is suspended and resumed when the construction is complete.
--*/
{
    NTSTATUS Status;
    BOOLEAN  fReconnectNetRoot;

    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pExchange->SmbCeContext.pVNetRoot);

    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    pNetRootEntry = SmbCeGetExchangeNetRootEntry(pExchange);

    ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_SESSION_INITIALIZED);
    ASSERT(SmbCeIsResourceOwned());

    Status            = STATUS_CONNECTION_DISCONNECTED;
    fReconnectNetRoot = BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

    switch (pVNetRootContext->Header.State) {
    case SMBCEDB_ACTIVE:
        ASSERT(pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT);
        ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);
        Status = STATUS_SUCCESS;
        break;

    case SMBCEDB_INVALID:
        RxDbgTrace( 0, Dbg, ("SmbCeReferenceNetRoot: Reestablishing net root\n"));
        if (!fReconnectNetRoot) {
            break;
        }
        ClearFlag(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

        pVNetRootContext->TreeId = 0;
        // fall thru

    case SMBCEDB_START_CONSTRUCTION:
        pExchange->SmbCeFlags |= SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR;
        pVNetRootContext->pExchange = pExchange;
        pVNetRootContext->Header.State = SMBCEDB_CONSTRUCTION_IN_PROGRESS;
        Status = STATUS_SUCCESS;
        break;

    case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
        if (fReconnectNetRoot) {
            // The construction of the net root is already in progress ....
            // Queue up the request to resume this exchange when the session
            // construction is complete.
            PSMBCEDB_REQUEST_ENTRY pRequestEntry;

            pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)
                             SmbMmAllocateObject(SMBCEDB_OT_REQUEST);

            if (pRequestEntry != NULL) {
                pRequestEntry->Request.pExchange = pExchange;

                SmbCeIncrementPendingLocalOperations(pExchange);
                SmbCeAddRequestEntry(&pVNetRootContext->Requests,pRequestEntry);

                Status = STATUS_PENDING;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;

    case SMBCEDB_MARKED_FOR_DELETION:
        break;

    default:
        ASSERT(!"Valid NetRoot State, SmbCe database corrupt");
        break;
    }

    if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
        pExchange->SmbCeState = SMBCE_EXCHANGE_NETROOT_INITIALIZED;
    }

    ASSERT(SmbCeIsResourceOwned());

    return Status;
}

NTSTATUS
SmbCeInitiateExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine inititaes a exchange.

Arguments:

    pExchange  - the exchange to be initiated.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    PKEVENT                 pSmbCeSynchronizationEvent;

    PAGED_CODE();

    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);
    pNetRootEntry = SmbCeGetExchangeNetRootEntry(pExchange);

    ASSERT(pServerEntry != NULL);
    ASSERT(!FlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE));

    switch (SmbCeGetServerType(pServerEntry)) {
    case SMBCEDB_FILE_SERVER:
        // Admin exchanges do not have these fields filled in. All the three
        // entries must be valid for all other exchanges.
        if ((pExchange->NodeTypeCode != SMB_EXCHANGE_NTC(ADMIN_EXCHANGE)) &&
            ((pNetRootEntry == NULL) ||
             (pSessionEntry == NULL))) {
            Status = STATUS_REQUEST_ABORTED;
            break;
        }
        break;

    default:
        // Prepare for aborting the request if either the server type is invalid
        // or if the netroot entry or the session entry is invalid.
        Status = STATUS_REQUEST_ABORTED;
    }

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx Status %lx\n",pExchange,Status));
        return Status;
    }

    pSmbCeSynchronizationEvent = pExchange->pSmbCeSynchronizationEvent;
    if (pSmbCeSynchronizationEvent != NULL) {
        KeInitializeEvent(
            pSmbCeSynchronizationEvent,
            SynchronizationEvent,
            FALSE);
    }

    for (;;) {
        SmbCeAcquireResource();

        switch (pExchange->SmbCeState) {
        case SMBCE_EXCHANGE_INITIALIZATION_START:
            {
                RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));
                Status = SmbCeReferenceServer(pExchange);
                if (Status != STATUS_SUCCESS) {
                    // this covers the case when the SERVER_ENTRY is under construction
                    // and RxStatus(PENDING) is returned.
                    RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SmbCeReferenceServer returned %lx\n",Status));
                    break;
                }
            }
            // fall through

        case SMBCE_EXCHANGE_SERVER_INITIALIZED:
            if (Status == STATUS_SUCCESS) {
                RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));
                Status = SmbCeReferenceSession(pExchange);
                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SmbCeReferenceSession returned %lx\n",Status));
                    break;
                } if ((Status == STATUS_PENDING) &&
                      !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR)) {
                    break;
                }
            } else {
                break;
            }
            // fall through

        case SMBCE_EXCHANGE_SESSION_INITIALIZED:
            RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));
            Status = SmbCeReferenceNetRoot(pExchange);
            if (!NT_SUCCESS(Status)) {
                RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SmbCeReferenceNetRoot returned %lx\n",Status));
                break;
            } else if ((Status == STATUS_PENDING) &&
                       !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR)) {
                break;
            }
            // else fall through

        case SMBCE_EXCHANGE_NETROOT_INITIALIZED:
            {
                PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

	            RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));
                pNetRootEntry = SmbCeGetExchangeNetRootEntry(pExchange);

                if ((pNetRootEntry != NULL) &&
                    !BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_INDEFINITE_DELAY_IN_RESPONSE)) {
                    pExchange->SmbCeFlags |= SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION;
                }

                pExchange->SmbCeState = SMBCE_EXCHANGE_INITIATED;
                Status                = STATUS_SUCCESS;
            }
            break;

        default:
            ASSERT(!"Valid State for a SMB exchange, exchange Initiation aborted");
            break;
        }

        SmbCeReleaseResource();

        if ((pSmbCeSynchronizationEvent != NULL)     &&
            (pExchange->SmbCeState != SMBCE_EXCHANGE_INITIATED) &&
            (Status == STATUS_PENDING)) {

            KeWaitForSingleObject(
                pSmbCeSynchronizationEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL );

            ASSERT(pExchange->Status != STATUS_PENDING);
            Status = pExchange->Status;
            if (Status != STATUS_SUCCESS) {
                break;
            }
        } else {
            break;
        }
    }

    ASSERT((Status != STATUS_PENDING) ||
           (pSmbCeSynchronizationEvent == NULL));

    RxDbgTrace(0,Dbg,("Exchange (%lx) Type (%lx) State(%lx) Status %lx \n",pExchange,pExchange->Type,pExchange->SmbCeState,Status));
    RxDbgTrace(0,Dbg,
        ("ServerEntry(%lx) SessionEntry(%lx) NetRootEntry(%lx) \n",
        pServerEntry,
        pSessionEntry,
        pNetRootEntry));

    // Note: Once the exchange has been initiated no further reference of the exchange
    // can be done since the state of the exchange is non-deterministic, i.e., depends upon
    // the scheduler.
    if (Status == STATUS_SUCCESS) {
        BOOLEAN ResourceReleased = FALSE;

        // Start the exchange
        ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_INITIATED);

        SmbCeAcquireResource();

        if ((pServerEntry->Header.State == SMBCEDB_ACTIVE) ||
            (pExchange->NodeTypeCode == SMB_EXCHANGE_NTC(ADMIN_EXCHANGE))) {
            Status = SmbCeInitializeExchangeTransport(pExchange);
        } else {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }

        if (Status == STATUS_SUCCESS) {
            if (pExchange->RxContext != NULL) {
                PMRXSMB_RX_CONTEXT pMRxSmbContext;

                // Set up the cancellation routine ..

                pMRxSmbContext = MRxSmbGetMinirdrContext(pExchange->RxContext);
                pMRxSmbContext->pCancelContext = pExchange;

                Status = RxSetMinirdrCancelRoutine(
                             pExchange->RxContext,
                             SmbCeCancelExchange);
            }

            if (Status == STATUS_SUCCESS) {
                if (!IsListEmpty(&pExchange->ExchangeList)) {
                    RemoveEntryList(&pExchange->ExchangeList);
                }

                InsertTailList(
                    &pServerEntry->ActiveExchanges,
                    &pExchange->ExchangeList);

                SmbCeReleaseResource();
                ResourceReleased = TRUE;

                pExchange->SmbStatus = STATUS_SUCCESS;
                pExchange->ServerVersion = pServerEntry->Server.Version;
                Status = SMB_EXCHANGE_DISPATCH(pExchange,Start,((PSMB_EXCHANGE)pExchange));
            }

            RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SMB_EXCHANGE_DISPATCH(Start) returned %lx\n",Status));
        }

        if (!ResourceReleased) {
            SmbCeReleaseResource();
        }
    } else if (Status != STATUS_PENDING) {
        RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange(%lx) Initiation failed %lx \n",pExchange,Status));
    }

    return Status;
}

NTSTATUS
SmbCeInitiateAssociatedExchange(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       EnableCompletionHandlerInMasterExchange)
/*++

Routine Description:

   This routine inititaes an associated exchange.

Arguments:

    pExchange  - the exchange to be initiated.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PSMB_EXCHANGE           pMasterExchange;
    PSMBCEDB_SERVER_ENTRY   pServerEntry;

    PAGED_CODE();

    ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_INITIATED);
    ASSERT(FlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE));

    pMasterExchange = pExchange->Associated.pMasterExchange;
    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    ASSERT(pServerEntry != NULL);

    // Note: Once the exchange has been initiated no further reference of the exchange
    // can be done since the state of the exchange is non-deterministic, i.e., depends upon
    // the scheduler.

    Status = SmbCeInitializeExchangeTransport(pExchange);

    SmbCeAcquireResource();

    if (!IsListEmpty(&pExchange->ExchangeList)) {
        RemoveEntryList(&pExchange->ExchangeList);
    }

    InsertTailList(
        &pServerEntry->ActiveExchanges,
        &pExchange->ExchangeList);

    if (EnableCompletionHandlerInMasterExchange) {
        ASSERT(!FlagOn(
                    pMasterExchange->SmbCeFlags,
                    SMBCE_ASSOCIATED_EXCHANGES_COMPLETION_HANDLER_ACTIVATED));
        SetFlag(
            pMasterExchange->SmbCeFlags,
            SMBCE_ASSOCIATED_EXCHANGES_COMPLETION_HANDLER_ACTIVATED);
    }

    pExchange->SmbStatus = STATUS_SUCCESS;
    pExchange->ServerVersion = pServerEntry->Server.Version;

    SmbCeReleaseResource();

    if (Status == STATUS_SUCCESS) {
        Status = SMB_EXCHANGE_DISPATCH(pExchange,Start,((PSMB_EXCHANGE)pExchange));
        RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SMB_EXCHANGE_DISPATCH(Start) returned %lx\n",Status));
    } else {
        SmbCeFinalizeExchange(pExchange);
        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
SmbCeExchangeAbort(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine aborts an exchange.

Arguments:

    pExchange  - the exchange to be aborted.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("SmbCeExchangeAbort: Exchange %lx aborted\n",pExchange));
    SmbCeDiscardExchange(pExchange);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbCeBuildSmbHeader(
    IN OUT PSMB_EXCHANGE     pExchange,
    IN OUT PVOID             pBuffer,
    IN     ULONG             BufferLength,
    OUT    PULONG            pBufferConsumed,
    OUT    PUCHAR            pLastCommandInHeader,
    OUT    PUCHAR            *pNextCommandPtr)
/*++

Routine Description:

   This routine constructs the SMB header associated with any SMB sent as part of
   an exchange.

Arguments:

    pExchange  - the exchange for which the SMB is to be constructed.

    pBuffer    - the buffer in whihc the SMB header is to be constructed

    BufferLength - length of the buffer

    pBufferConsumed - the buffer consumed

    pLastCommandInHeader - the last command in header, SMB_COM_NO_ANDX_COMMAND if none

    pNextCommandPtr - the ptr to the place in the buffer where the next command
                      code should be copied.


Return Value:

    STATUS_SUCCESS  - if the header construction was successful

Notes:

    This routine is called to build the SMB header. This centralization allows us to
    compound the SMB operation with other SMB's required for the maintenance of the
    SMB connection engine data structures. It also provides us with a centralized facility
    for profiling SMB's as well as a one place mechanism for filling in all the header
    fields associated with a SMB.

--*/
{
    NTSTATUS      Status = STATUS_SUCCESS;
    PSMB_HEADER   pSmbHeader = (PSMB_HEADER)pBuffer;
    PGENERIC_ANDX pSmbBuffer;
    ULONG         SmbBufferUnconsumed = BufferLength;
    PUCHAR        pSmbCommand;

    UCHAR         LastCommandInHeader = SMB_COM_NO_ANDX_COMMAND;
    UCHAR         Flags = SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS;
    USHORT        Flags2 = 0;

    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    PSMBCEDB_SESSION_ENTRY pSessionEntry;

    PSMBCE_SERVER         pServer;

    PAGED_CODE();

    if (BufferLength < sizeof(SMB_HEADER)) {
        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: BufferLength too small %d\n",BufferLength));
        ASSERT(!"Buffer too small");
        return STATUS_BUFFER_TOO_SMALL;
    }

    SmbBufferUnconsumed = BufferLength - sizeof(SMB_HEADER);

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);

    pServer = SmbCeGetExchangeServer(pExchange);

    if (pServer->Dialect == NTLANMAN_DIALECT) {

        if (FlagOn(pServer->DialectFlags,DF_NT_SMBS)) {
            Flags2 |= (SMB_FLAGS2_KNOWS_EAS );

            if (FlagOn(pServer->DialectFlags,DF_UNICODE)) {
                    Flags2 |= SMB_FLAGS2_UNICODE;
            }
        }

        if (FlagOn(pServer->DialectFlags,DF_NT_STATUS)) {
            Flags2 |= SMB_FLAGS2_NT_STATUS;
        }
    }

    if (FlagOn(pServer->DialectFlags,DF_LONGNAME)) {
        Flags2 |= SMB_FLAGS2_KNOWS_LONG_NAMES;
    }

    if (FlagOn(pServer->DialectFlags,DF_SUPPORTEA)) {
        Flags2 |= SMB_FLAGS2_KNOWS_EAS;
    }

    RtlZeroMemory(pSmbHeader,sizeof(SMB_HEADER));

    *((PULONG)&pSmbHeader->Protocol) = SMB_HEADER_PROTOCOL;
    pSmbHeader->Flags      = Flags;
    pSmbHeader->Flags2     = Flags2;
    pSmbHeader->Pid        = MRXSMB_PROCESS_ID;
    pSmbHeader->Uid        = 0;
    pSmbHeader->Tid        = 0;
    pSmbHeader->ErrorClass = 0;
    pSmbHeader->Reserved   = 0;
    pSmbCommand            = &pSmbHeader->Command;
    SmbPutUshort(&pSmbHeader->Error,0);

    switch (SmbCeGetServerType(pServerEntry)) {
    case SMBCEDB_FILE_SERVER:
        {
            BOOLEAN fValidTid;

            if (pSessionEntry != NULL) {
                pSmbHeader->Uid = pSessionEntry->Session.UserId;
            }

            if (pExchange->SmbCeContext.pVNetRoot != NULL) {
                PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

                pVNetRootContext = SmbCeGetAssociatedVNetRootContext(
                                       pExchange->SmbCeContext.pVNetRoot);

                fValidTid = BooleanFlagOn(
                                pVNetRootContext->Flags,
                                SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

                pSmbHeader->Tid = pVNetRootContext->TreeId;
            } else {
                fValidTid = TRUE;
            }

            pSmbBuffer = (PGENERIC_ANDX)(pSmbHeader + 1);

            if ((pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) ||
                (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR)) {
                // There is an oppurtunity to compound some SessionSetup/TreeConnect SMB with the
                // given SMB command.
                if ((pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) &&
                    (pSessionEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS)) {
                    if (( pServer->DialectFlags & DF_EXTENDNEGOT) ||
                        ( pServer->DialectFlags & DF_NTNEGOTIATE)) {
                        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Building Session setup And X\n"));

                        *pSmbCommand = SMB_COM_SESSION_SETUP_ANDX;
                        LastCommandInHeader = *pSmbCommand;
                        pSmbCommand = &pSmbBuffer->AndXCommand;
                        pSmbHeader->Tid = 0;

                        Status = SMBCE_SERVER_DIALECT_DISPATCH(
                                     pServer,
                                     BuildSessionSetup,
                                     (pExchange,
                                      pSmbBuffer,
                                      &SmbBufferUnconsumed));
                        if (NT_SUCCESS(Status)) {
                            // Update the buffer for the construction of the following SMB.
                            SmbPutUshort(
                                &pSmbBuffer->AndXOffset,
                                (USHORT)(BufferLength - SmbBufferUnconsumed));
                            pSmbBuffer = (PGENERIC_ANDX)((PBYTE)pBuffer + BufferLength - SmbBufferUnconsumed);
                        }
                    }
                } else {
                    NOTHING; //no sess for share level AT LEAST NOT FOR CORE!!!
                }

                if (NT_SUCCESS(Status) &&
                    (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR) &&
                    !fValidTid) {
                    BOOLEAN BuildingTreeConnectAndX = BooleanFlagOn(pServer->DialectFlags,DF_LANMAN10);
                    if (BuildingTreeConnectAndX) {
                        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Building Tree Connect And X\n"));
                        *pSmbCommand = SMB_COM_TREE_CONNECT_ANDX;
                        LastCommandInHeader = *pSmbCommand;
                    } else {
                        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Building Tree Connect No X\n"));
                        *pSmbCommand = SMB_COM_TREE_CONNECT;
                        LastCommandInHeader = *pSmbCommand;
                    }

                    Status = SMBCE_SERVER_DIALECT_DISPATCH(
                                 pServer,
                                 BuildTreeConnect,
                                 (pExchange,
                                  pSmbBuffer,
                                  &SmbBufferUnconsumed));

                    if (NT_SUCCESS(Status)) {
                        // Update the buffer for the construction of the following SMB.
                        if (BuildingTreeConnectAndX) {
                            pSmbCommand = &pSmbBuffer->AndXCommand;
                            SmbPutUshort(&pSmbBuffer->AndXOffset,(USHORT)(BufferLength - SmbBufferUnconsumed));
                        } else {
                            pSmbCommand = NULL;
                        }
                    }
                }
            }
        }
        break;

    default:
        {
            ASSERT(!"Valid Server Type");
            Status = STATUS_INVALID_HANDLE;
        }
        break;
    }

    *pNextCommandPtr      = pSmbCommand;
    *pBufferConsumed      = BufferLength - SmbBufferUnconsumed;
    *pLastCommandInHeader = LastCommandInHeader;

    RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Buffer Consumed %lx\n",*pBufferConsumed));

    if (Status != STATUS_SUCCESS) {
        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) {
            pExchange->SessionSetupStatus = Status;
        }

        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR) {
            PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

            pVNetRootContext = SmbCeGetExchangeVNetRootContext(pExchange);

            SmbCeUpdateVNetRootContextState(
                pVNetRootContext,
                SMBCEDB_INVALID);
        }
    }

    return Status;
}

typedef struct __Service_Name_Entry {
    NET_ROOT_TYPE NetRootType;
    USHORT NameLength;
    PBYTE  Name;
};
struct __Service_Name_Entry ServiceNameTable[] = {
    {NET_ROOT_DISK,sizeof(SHARE_TYPE_NAME_DISK),SHARE_TYPE_NAME_DISK},
    {NET_ROOT_PIPE,sizeof(SHARE_TYPE_NAME_PIPE),SHARE_TYPE_NAME_PIPE},
    {NET_ROOT_PRINT,sizeof(SHARE_TYPE_NAME_PRINT),SHARE_TYPE_NAME_PRINT},
    {NET_ROOT_COMM,sizeof(SHARE_TYPE_NAME_COMM),SHARE_TYPE_NAME_COMM}  //COMM must be last
    };

UNICODE_STRING FileSystem_NTFS_UNICODE = {8,8,L"NTFS"};
UNICODE_STRING FileSystem_FAT_UNICODE = {6,6,L"FAT"};
CHAR FileSystem_NTFS[] = "NTFS";
CHAR FileSystem_FAT[] = "FAT";

NTSTATUS
SmbCeParseSmbHeader(
    PSMB_EXCHANGE     pExchange,
    PSMB_HEADER       pSmbHeader,
    PGENERIC_ANDX     pCommandToProcess,
    NTSTATUS          *pSmbResponseStatus,
    ULONG             BytesAvailable,
    ULONG             BytesIndicated,
    PULONG            pBytesConsumed)
/*++

Routine Description:

   This routine validates the SMB header associated with any SMB received as part of
   an exchange.

Arguments:

    pExchange  - the exchange for which the SMB is to be constructed.

    pSmbHeader - the header of the SMB received

    pCommandToProcess - the SMB command to be processed after the header ( Can be NULL )

    pSmbResponseStatus - the status in the SMB response header (Can be NULL)

    BytesAvailable - the bytes available for processing but not necesarily indicated.

    BytesIndicated - the length of the SMB buffer avcailable for perusal

    pBytesConsumed - the buffer consumed

Return Value:

    RXSTATUS - The return status for the operation
          STATUS_MORE_PROCESSING_REQUIRED -- if a copy of the data needs to be done before
          processing can be completed. This occurs because sufficient data was not
          indicated to process the header.
          STATUS_SUCCESS -- the header was processed succesfully. In such cases the GENERIC_ANDX
          if not NULL will contain the offset from the start of the buffer and the command
          to be processed.
          STATUS_* -- They indicate an error which would normally lead to the abortion of the
          exchange.

Notes:

    This routine is called to parse the SMB header. This centralization allows us to
    implement a one stop mechanism for updateing/validating the header fields as well as
    resuming the exchanges waiting for the construction of session/net root entry
    associated with this exchange

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SmbResponseStatus;

    PBYTE    pSmbBuffer = (PBYTE)pSmbHeader;
    UCHAR    SmbCommand;

    BOOLEAN  fUpdateVNetRootContext  = FALSE;

    SMBCEDB_OBJECT_STATE SessionState;
    SMBCEDB_OBJECT_STATE NetRootState;

    PMRX_V_NET_ROOT           pVNetRoot;
    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    pVNetRoot     = SmbCeGetExchangeVNetRoot(pExchange);
    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);
    pNetRootEntry = SmbCeGetExchangeNetRootEntry(pExchange);

    pVNetRootContext = SmbCeGetExchangeVNetRootContext(pExchange);

    // Return Immediately if bytes indicated is less then the size of a SMB header.
    if (BytesIndicated < sizeof(SMB_HEADER)) {
        *pBytesConsumed = BytesIndicated;
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    SmbResponseStatus = GetSmbResponseNtStatus(pSmbHeader,pExchange);
    if (!NT_SUCCESS(SmbResponseStatus)) {
        RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::SMB Response Error %lx\n",SmbResponseStatus));
    }

    SmbCommand      = pSmbHeader->Command;
    *pBytesConsumed = sizeof(SMB_HEADER);
    pSmbBuffer     += *pBytesConsumed;

    // There are certain SMB's that effect the connection engine data structures as
    // well as the exchange that has been suspended. These are the SMB's used for tree
    // connect and session setup.
    // In all the other cases no special action is required for the maintenance of the
    // connection engine data structures. The Exchange that was suspended needs to be
    // resumed.
    if (SmbCommand == SMB_COM_SESSION_SETUP_ANDX) {
        if (SmbResponseStatus != STATUS_SUCCESS) {
            if ((FIELD_OFFSET(GENERIC_ANDX,AndXReserved) + *pBytesConsumed) <= BytesIndicated) {
                PGENERIC_ANDX pGenericAndX = (PGENERIC_ANDX)pSmbBuffer;

                if (pGenericAndX->WordCount == 0) {
                    Status = SmbResponseStatus;
                }

                pExchange->SessionSetupStatus = SmbResponseStatus;
            }

            // Note that the case wherein sufficient bytes are not indicated for the
            // GENERIC_ANDX response is handled by the if statement below which
            // imposes a more stringent test.
        }

        if ((Status == STATUS_SUCCESS) &&
            (FIELD_OFFSET(RESP_SESSION_SETUP_ANDX,Buffer) + *pBytesConsumed) > BytesIndicated) {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        }

        if (Status == STATUS_SUCCESS) {
            PRESP_SESSION_SETUP_ANDX pSessionSetupResponse;
            ULONG                    SessionSetupResponseLength,ByteCount;

            RxDbgTrace( 0, Dbg, ("Processing Session Setup ANd X\n"));
            pSessionSetupResponse = (PRESP_SESSION_SETUP_ANDX)(pSmbBuffer);

            ByteCount = SmbGetUshort(&pSessionSetupResponse->ByteCount);
            if (pSessionSetupResponse->WordCount == 3) {
                SmbCommand = pSessionSetupResponse->AndXCommand;
                if (SmbCommand == SMB_COM_NO_ANDX_COMMAND) {
                    SessionSetupResponseLength =
                        FIELD_OFFSET(RESP_SESSION_SETUP_ANDX,Buffer) + ByteCount;
                    Status = SmbResponseStatus;
                } else {
                    SessionSetupResponseLength =
                        SmbGetUshort(&pSessionSetupResponse->AndXOffset) - *pBytesConsumed;
                }

                //if (ByteCount == 0) {
                //    //bytecount==0 and NTDIALECT means that this is really w95...change the flags
                //    PSMBCE_SERVER pServer   = &pExchange->SmbCeContext.pServerEntry->Server;
                //    if (FlagOn(pServer->DialectFlags,DF_NTPROTOCOL)) {
                //        pServer->DialectFlags &= ~(DF_MIXEDCASEPW);
                //        pServer->DialectFlags |= DF_W95;
                //    }
                //}
            } else {
                Status = SmbResponseStatus;
            }

            if (NT_SUCCESS(Status)) {
                if (SessionSetupResponseLength + *pBytesConsumed <= BytesIndicated) {
                    *pBytesConsumed += SessionSetupResponseLength;
                    pSmbBuffer += SessionSetupResponseLength;
                    pSessionEntry->Session.UserId = pSmbHeader->Uid;

                    if (FlagOn(SmbGetUshort(&pSessionSetupResponse->Action), SMB_SETUP_USE_LANMAN_KEY)) {
                        pSessionEntry->Session.Flags |=
                            SMBCE_SESSION_FLAGS_LANMAN_SESSION_KEY_USED;
                    }

                    if (FlagOn(SmbGetUshort(&pSessionSetupResponse->Action), SMB_SETUP_GUEST)) {
                        pSessionEntry->Session.Flags |=
                            SMBCE_SESSION_FLAGS_GUEST_SESSION;
                    }

                    pExchange->SessionSetupStatus = STATUS_SUCCESS;
                    InterlockedIncrement(&MRxSmbStatistics.Sessions);
                } else {
                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                }
            } else {
                RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::Session setup and X Response %lx\n",Status));
                pExchange->SessionSetupStatus = Status;

                InterlockedIncrement(&MRxSmbStatistics.FailedSessions);

                if ((SmbCommand == SMB_COM_TREE_CONNECT_ANDX) ||
                    (SmbCommand == SMB_COM_TREE_CONNECT)) {
                    RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader:: Tearing down a tree connection\n"));
                    fUpdateVNetRootContext = TRUE;
                    NetRootState = SMBCEDB_INVALID;
                }
            }
        }
    }

    if ((SmbCommand == SMB_COM_TREE_CONNECT_ANDX) &&
        NT_SUCCESS(Status)) {
        if (SmbResponseStatus != STATUS_SUCCESS) {
            if ((FIELD_OFFSET(GENERIC_ANDX,AndXReserved) + *pBytesConsumed) <= BytesIndicated) {
                PGENERIC_ANDX pGenericAndX = (PGENERIC_ANDX)pSmbBuffer;

                if (pGenericAndX->WordCount == 0) {
                    Status = SmbResponseStatus;
                }

                fUpdateVNetRootContext  = TRUE;
                NetRootState          = SMBCEDB_INVALID;
            }

            // Note that the case wherein sufficient bytes are not indicated for the
            // GENERIC_ANDX response is handled by the if statement below which
            // imposes a more stringent test.
        }

        if ((Status == STATUS_SUCCESS) &&
            (FIELD_OFFSET(RESP_21_TREE_CONNECT_ANDX,Buffer) + *pBytesConsumed) > BytesIndicated) {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        }

        if (Status == STATUS_SUCCESS) {
            USHORT ResponseWordCount;
            ULONG TreeConnectResponseLength,TreeConnectByteCount,ServiceStringLength;
            PUCHAR pShareTypeResponseString = NULL;
            PRESP_21_TREE_CONNECT_ANDX p21TreeConnectAndXResponse;
            PUCHAR NativeFileSystem = NULL;

            p21TreeConnectAndXResponse = (PRESP_21_TREE_CONNECT_ANDX)(pSmbBuffer);
            SmbCommand = p21TreeConnectAndXResponse->AndXCommand;
            TreeConnectByteCount = 0;

            RxDbgTrace( 0, Dbg, ("Processing Tree Connect and X\n"));

            // case out based on the actual response length. Lanman 21 clients or NT clients
            // have a longer response.....win95 negotiates NT dialect but uses a <lm21 response format
            ResponseWordCount = p21TreeConnectAndXResponse->WordCount;

            switch (ResponseWordCount) {
            case 0:
                Status = SmbResponseStatus;
                break;

            case 3:
                {
                    pNetRootEntry->MaximalAccessRights = FILE_ALL_ACCESS;
                    pNetRootEntry->GuestMaximalAccessRights = 0;

                    pShareTypeResponseString = (PUCHAR)&p21TreeConnectAndXResponse->Buffer;

                    TreeConnectByteCount  = SmbGetUshort(&p21TreeConnectAndXResponse->ByteCount);

                    TreeConnectResponseLength =
                        FIELD_OFFSET(RESP_21_TREE_CONNECT_ANDX,Buffer) + TreeConnectByteCount;

                    NativeFileSystem = &p21TreeConnectAndXResponse->Buffer[3];

                    // Parse and update the optional support bits returned by
                    // the server

                    if (pServerEntry->Server.Dialect >= NTLANMAN_DIALECT ) {
                        USHORT OptionalSupport;

                        OptionalSupport = SmbGetUshort(
                                             &p21TreeConnectAndXResponse->OptionalSupport);

                        if (FlagOn(OptionalSupport,SMB_SHARE_IS_IN_DFS)) {
                            PMRX_NET_ROOT pNetRoot = pVNetRoot->pNetRoot;

                            pNetRootEntry->NetRoot.DfsAware = TRUE;
                            SetFlag(pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT);
                        }
                    }

                    if (SmbCommand == SMB_COM_NO_ANDX_COMMAND) {
                        Status = SmbResponseStatus;
                    } else {
                        TreeConnectResponseLength =
                            SmbGetUshort(&p21TreeConnectAndXResponse->AndXOffset) -
                            *pBytesConsumed;
                    }
                }
                break;

            case 2:
                {
                    PRESP_TREE_CONNECT_ANDX pTreeConnectAndXResponse;

                    pTreeConnectAndXResponse = (PRESP_TREE_CONNECT_ANDX)(pSmbBuffer);

                    ASSERT(FIELD_OFFSET(RESP_TREE_CONNECT_ANDX,AndXCommand)
                           ==FIELD_OFFSET(RESP_21_TREE_CONNECT_ANDX,AndXCommand));

                    pShareTypeResponseString = (PUCHAR)&pTreeConnectAndXResponse->Buffer;
                    TreeConnectByteCount  = SmbGetUshort(&pTreeConnectAndXResponse->ByteCount);
                    TreeConnectResponseLength =
                        FIELD_OFFSET(RESP_TREE_CONNECT_ANDX,Buffer) + TreeConnectByteCount;

                    if (SmbCommand == SMB_COM_NO_ANDX_COMMAND) {
                        Status = SmbResponseStatus;
                    } else {
                        TreeConnectResponseLength =
                            SmbGetUshort(&pTreeConnectAndXResponse->AndXOffset) -
                            *pBytesConsumed;
                    }

                    // win9x server, returns wordcount of 2 yet has the dialect of NTLANMAN
                    // which is a bug, but we will work around it.
                    if (pServerEntry->Server.Dialect >= NTLANMAN_DIALECT ) {
                        pNetRootEntry->MaximalAccessRights = FILE_ALL_ACCESS;
                        pNetRootEntry->GuestMaximalAccessRights = 0;
                    }

                }
                break;

            default :
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::Tree connect and X Response %lx\n",Status));
            if (NT_SUCCESS(Status)) {
                PSMBCE_NET_ROOT psmbNetRoot = &(pNetRootEntry->NetRoot);
                PSMBCE_SERVER psmbServer = &(pServerEntry->Server);

                if (TreeConnectResponseLength + *pBytesConsumed <= BytesIndicated) {
                    *pBytesConsumed += TreeConnectResponseLength;

                    // Update the NetRoot fields based on the response.
                    SetFlag(
                        pVNetRootContext->Flags,
                        SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

                    RtlCopyMemory(
                        &pVNetRootContext->TreeId,
                        &pSmbHeader->Tid,
                        sizeof(pSmbHeader->Tid));

                    {   struct __Service_Name_Entry *i;
                        for (i=ServiceNameTable;;i++) {
                            ServiceStringLength = i->NameLength;
                            if (TreeConnectByteCount >= ServiceStringLength) {
                                if (RtlCompareMemory(
                                        pShareTypeResponseString,
                                        i->Name,
                                        ServiceStringLength)
                                    == ServiceStringLength) {
                                    psmbNetRoot->NetRootType = i->NetRootType;
                                    if (FALSE) DbgPrint("FoundServiceStrng %s len %d type %d\n",i->Name,i->NameLength,i->NetRootType);
                                    break;
                                }
                            }

                            if (i->NetRootType==NET_ROOT_COMM) {
                                ASSERT(!"Valid Share Type returned in TREE COnnect And X response");
                                psmbNetRoot->NetRootType = NET_ROOT_DISK;
                                ServiceStringLength = TreeConnectByteCount;
                                break;
                            }
                        }
                    }

                    if (psmbNetRoot->NetRootType == NET_ROOT_DISK) {
                        if (NativeFileSystem != NULL) {
                            if (BooleanFlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE)) {
                                if (RtlCompareMemory(
                                        NativeFileSystem,
                                        FileSystem_NTFS_UNICODE.Buffer,
                                        FileSystem_NTFS_UNICODE.Length)
                                    == FileSystem_NTFS_UNICODE.Length) {
                                    psmbNetRoot->NetRootFileSystem = NET_ROOT_FILESYSTEM_NTFS;
                                } else if (RtlCompareMemory(
                                        NativeFileSystem,
                                        FileSystem_FAT_UNICODE.Buffer,
                                        FileSystem_FAT_UNICODE.Length)
                                    == FileSystem_FAT_UNICODE.Length) {
                                    psmbNetRoot->NetRootFileSystem = NET_ROOT_FILESYSTEM_FAT;
                                }
                            } else {
                                if (RtlCompareMemory(
                                        NativeFileSystem,
                                        FileSystem_NTFS,
                                        4*sizeof(CHAR))
                                    == 4*sizeof(CHAR)) {
                                    psmbNetRoot->NetRootFileSystem = NET_ROOT_FILESYSTEM_NTFS;
                                } else if (RtlCompareMemory(
                                        NativeFileSystem,
                                        FileSystem_FAT,
                                        3*sizeof(CHAR))
                                    == 3*sizeof(CHAR)) {
                                    psmbNetRoot->NetRootFileSystem = NET_ROOT_FILESYSTEM_FAT;
                                }
                            }
                        }

                        psmbNetRoot->MaximumReadBufferSize = psmbServer->MaximumDiskFileReadBufferSize;
                        psmbNetRoot->MaximumWriteBufferSize = psmbServer->MaximumDiskFileWriteBufferSize;
                    } else {
                        psmbNetRoot->MaximumWriteBufferSize = psmbServer->MaximumNonDiskFileWriteBufferSize;
                        psmbNetRoot->MaximumReadBufferSize = psmbServer->MaximumNonDiskFileReadBufferSize;
                    }

                    //if !(NT was negotiated) and bytecount>servicelength, we may have a NativeFs name
                    if (!FlagOn(psmbServer->DialectFlags,DF_NTNEGOTIATE)
                        && (TreeConnectByteCount>ServiceStringLength)) {
                        PBYTE NativeFs = pShareTypeResponseString+ServiceStringLength;
                        if (*NativeFs != 0) {
                            ULONG i;
                            ULONG maxlenpersmb = TreeConnectByteCount-ServiceStringLength;
                            ULONG maxlenperarraysize = SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL;
                            PCHAR p = (PCHAR)(&psmbNetRoot->FileSystemNameA[0]);  //dont write into the 0th char
                            //DbgPrint("we may have one...\n");
                            for (i=1;;i++){
                                if (i==maxlenpersmb) {
                                    break;
                                }
                                if (i==maxlenperarraysize) {
                                    break;
                                }
                                if (NativeFs[i]==0) {
                                    break;
                                }
                            }
                            //save away the name for processing later

                            RtlCopyMemory(p,NativeFs,i);
                            p[i] = 0;
                            //DbgPrint("NativeFs = %s (%d)\n",p,i);
                            psmbNetRoot->FileSystemNameALength = (UCHAR)i;
                        }
                    }

                    pSmbBuffer += TreeConnectResponseLength;
                    fUpdateVNetRootContext = TRUE;
                    NetRootState         = SMBCEDB_ACTIVE;
                } else {
                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                }
            } else {
                fUpdateVNetRootContext  = TRUE;
                NetRootState          = SMBCEDB_INVALID;
            }
        }
    }

    if ((SmbCommand == SMB_COM_TREE_CONNECT) &&
        NT_SUCCESS(Status)) {
        PRESP_TREE_CONNECT   pTreeConnectResponse;
        ULONG                TreeConnectResponseLength;

        RxDbgTrace( 0, Dbg, ("Processing Tree Connect\n"));
        pTreeConnectResponse      = (PRESP_TREE_CONNECT)pSmbBuffer;
        TreeConnectResponseLength = FIELD_OFFSET(RESP_TREE_CONNECT,Buffer);

        SmbCommand = SMB_COM_NO_ANDX_COMMAND;

        if (NT_SUCCESS(SmbResponseStatus)) {
            PSMBCE_NET_ROOT psmbNetRoot = &(pNetRootEntry->NetRoot);
            PSMBCE_SERVER psmbServer = &(pServerEntry->Server);

            if (TreeConnectResponseLength + *pBytesConsumed <= BytesIndicated) {
                // Update the NetRoot fields based on the response.
                SetFlag(
                    pVNetRootContext->Flags,
                    SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

                RtlCopyMemory(
                    &pVNetRootContext->TreeId,
                    &pTreeConnectResponse->Tid,
                    sizeof(pTreeConnectResponse->Tid));

                if (psmbServer->Dialect == PCNET1_DIALECT) {
                    psmbNetRoot->NetRootType = NET_ROOT_DISK;
                }
                else {
                    psmbNetRoot->NetRootType = NET_ROOT_WILD;
                }

                if (psmbServer->MaximumBufferSize == 0){
                    ULONG MaxBuf = SmbGetUshort(&pTreeConnectResponse->MaxBufferSize);
                    RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader:: setting srvmaxbufsize %ld\n", MaxBuf));
                    psmbServer->MaximumBufferSize = MaxBuf;
                    //psmbServer->MaximumDiskFileReadBufferSize =
                    psmbNetRoot->MaximumWriteBufferSize =
                    psmbNetRoot->MaximumReadBufferSize =
                                MaxBuf -
                                QuadAlign(
                                    sizeof(SMB_HEADER) +
                                    FIELD_OFFSET(
                                        RESP_READ,
                                        Buffer[0]));
                }

                *pBytesConsumed += TreeConnectResponseLength;

                pSmbBuffer += *pBytesConsumed;

                fUpdateVNetRootContext = TRUE;
                NetRootState         = SMBCEDB_ACTIVE;

                //for CORE, this counts as a successful session setup as well!
                pSessionEntry->Session.UserId = pSmbHeader->Uid;
                pExchange->SessionSetupStatus = STATUS_SUCCESS;
            } else {
                Status = STATUS_MORE_PROCESSING_REQUIRED;
            }
        } else {
            Status = SmbResponseStatus;
            fUpdateVNetRootContext  = TRUE;
            NetRootState          = SMBCEDB_MARKED_FOR_DELETION;
        }

        RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::Tree connect Response %lx\n",Status));
    }

    if ((SmbResponseStatus == STATUS_USER_SESSION_DELETED) ||
        (SmbResponseStatus == STATUS_NETWORK_NAME_DELETED)) {
        ClearFlag(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

        InterlockedCompareExchange(
            &(pVNetRootContext->Header.State),
            SMBCEDB_INVALID,
            SMBCEDB_ACTIVE);

        InterlockedCompareExchange(
            &(pSessionEntry->Header.State),
            SMBCEDB_INVALID,
            SMBCEDB_ACTIVE);

        fUpdateVNetRootContext  = TRUE;
        NetRootState            = SMBCEDB_INVALID;
    }

    // Initiate further action if the status of the exchange/conenction engine can be
    // updated based on the data available.

    if (fUpdateVNetRootContext) {
        PMRX_NET_ROOT pNetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;

        SmbCeUpdateVNetRootContextState(
            pVNetRootContext,
            NetRootState);

        switch (NetRootState) {
        case SMBCEDB_ACTIVE:
             pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;
             break;
        case SMBCEDB_INVALID:
             pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_DISCONNECTED;
             break;
        case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
             pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_RECONN;
             break;
        default:
             pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
             break;
        }

        RxDbgTrace( 0, Dbg, ("Dispatching Net root Entry Finalization\n"));
    }

    IF_DEBUG {
        if (!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) &&
            !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR)) {
            if ((pSmbHeader->Uid != pSessionEntry->Session.UserId) ||
                (pSmbHeader->Tid != pVNetRootContext->TreeId)) {
                RxLog(("Srvr %lx Xchg %lx RUid %ld RTid %ld\n SUid %ld STid %ld\n",
                       pServerEntry,pExchange,
                       pSmbHeader->Uid,pSmbHeader->Tid,
                       pSessionEntry->Session.UserId,pVNetRootContext->TreeId));
            }
        }
    }

    pExchange->SmbStatus = SmbResponseStatus;     //N.B. no spinlock!
    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        *pBytesConsumed = 0;
    } else if (!NT_SUCCESS(Status)) {
        *pBytesConsumed = BytesAvailable;
    } else {
        if (pSmbResponseStatus != NULL) {
            *pSmbResponseStatus = SmbResponseStatus;
        }

        if (pCommandToProcess != NULL) {
            PGENERIC_ANDX pGenericAndX = (PGENERIC_ANDX)((PBYTE)pSmbHeader + *pBytesConsumed);

            pCommandToProcess->AndXCommand = SmbCommand;
            SmbPutUshort(&pCommandToProcess->AndXOffset, (USHORT)*pBytesConsumed);

            if ((sizeof(GENERIC_ANDX) + *pBytesConsumed) <= BytesAvailable) {
                pCommandToProcess->WordCount   = pGenericAndX->WordCount;
            } else {
                pCommandToProcess->WordCount = 0;
            }
        }
    }

    return Status;
}

NTSTATUS
SmbCeResumeExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine resumes an exchange that was suspended in the connection
   engine

Arguments:

    pExchange - the exchange Instance

Return Value:

    The return status for the operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    SmbCeIncrementPendingLocalOperations(pExchange);

    // Initiate the exchange
    Status = SmbCeInitiateExchange(pExchange);

    SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

    return Status;
}

NTSTATUS
SmbCepInitializeExchange(
    PSMB_EXCHANGE                 *pExchangePointer,
    PRX_CONTEXT                   pRxContext,
    PSMBCEDB_SERVER_ENTRY         pServerEntry,
    PMRX_V_NET_ROOT               pVNetRoot,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector)
/*++

Routine Description:

   This routine initializes the given exchange instanece

Arguments:

    pExchangePointer  - the placeholder for the exchange instance. If it is NULL a new one
    is allocated.

    pRxContext        - the associated RxContext

    pServerEntry      - the associated server entry

    pVirtualNetRoot   - the virtual net root

    Type              - the type of the exchange

    pDispatchVector   - the dispatch vector asscoiated with this instance.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS      Status = STATUS_SUCCESS;
    PSMB_EXCHANGE pExchange = NULL;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("SmbCeInitializeExchange: Invoked\n"));

    if (*pExchangePointer == NULL) {
        // Allocate a new exchange instance.
        pExchange = SmbMmAllocateExchange(Type,NULL);
        if (pExchange == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        *pExchangePointer = pExchange;
    }

    if ((Status = SmbCeIncrementActiveExchangeCount()) == STATUS_SUCCESS) {
        PSMB_EXCHANGE             LocalExchangePointer = *pExchangePointer;
        PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

        LocalExchangePointer->CancellationStatus = SMBCE_EXCHANGE_NOT_CANCELLED;
        LocalExchangePointer->RxContext = pRxContext;

        if (Status == STATUS_SUCCESS) {
            if (pVNetRoot != NULL) {
                pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot);

                LocalExchangePointer->SmbCeContext.pVNetRoot = pVNetRoot;
                pServerEntry = SmbCeGetAssociatedServerEntry(pVNetRoot->pNetRoot->pSrvCall);
            } else {
                ASSERT(pServerEntry != NULL);
                pVNetRootContext = NULL;
            }

            if (pVNetRootContext != NULL) {
                SmbCeReferenceVNetRootContext(pVNetRootContext);

                LocalExchangePointer->SmbCeContext.pVNetRootContext =
                    pVNetRootContext;
                LocalExchangePointer->SmbCeContext.pServerEntry =
                    pVNetRootContext->pServerEntry;
            } else {
                SmbCeReferenceServerEntry(pServerEntry);

                LocalExchangePointer->SmbCeContext.pServerEntry  =
                    pServerEntry;

                LocalExchangePointer->SmbCeContext.pVNetRootContext = NULL;
            }

            LocalExchangePointer->SmbCeState = SMBCE_EXCHANGE_INITIALIZATION_START;
            LocalExchangePointer->pDispatchVector = pDispatchVector;
            LocalExchangePointer->SmbCeFlags &= (SMBCE_EXCHANGE_FLAGS_TO_PRESERVE);
            LocalExchangePointer->SmbCeFlags |= (SMBCE_EXCHANGE_REUSE_MID | SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);
        }

        if (Status != STATUS_SUCCESS) {
            SmbCeDecrementActiveExchangeCount();
        }
    } else {
        (*pExchangePointer)->SmbCeFlags |= SMBCE_EXCHANGE_SMBCE_STOPPED;
    }

    if (!NT_SUCCESS(Status)) {
        if (pExchange != NULL) {
            SmbMmFreeExchange(pExchange);
            *pExchangePointer = NULL;
        }
    }

    return Status;
}

NTSTATUS
SmbCeInitializeAssociatedExchange(
    PSMB_EXCHANGE                 *pAssociatedExchangePointer,
    PSMB_EXCHANGE                 pMasterExchange,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector)
/*++

Routine Description:

   This routine initializes the given exchange instanece

Arguments:

    pAssociatedExchangePointer  - the placeholder for the exchange instance. If it is NULL a new one
    is allocated.

    pMasterExchange      - the master exchange

    Type              - the type of the exchange

    pDispatchVector   - the dispatch vector asscoiated with this instance.

Return Value:

    NTSTATUS - The return status for the operation

Notes:



--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if ((pMasterExchange->SmbCeState == SMBCE_EXCHANGE_INITIATED) &&
        !FlagOn(pMasterExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE)) {
        Status = SmbCeInitializeExchange(
                     pAssociatedExchangePointer,
                     NULL,
                     pMasterExchange->SmbCeContext.pVNetRoot,
                     Type,
                     pDispatchVector);

        if (Status == STATUS_SUCCESS) {
            PSMB_EXCHANGE pAssociatedExchange;

            pAssociatedExchange = *pAssociatedExchangePointer;

            pAssociatedExchange->SmbCeState = SMBCE_EXCHANGE_INITIATED;
            pAssociatedExchange->SmbCeFlags |= SMBCE_ASSOCIATED_EXCHANGE;

            SmbCeIncrementPendingLocalOperations(pMasterExchange);
            InterlockedIncrement(&pMasterExchange->Master.PendingAssociatedExchanges);
            pAssociatedExchange->Associated.pMasterExchange = pMasterExchange;

            InitializeListHead(&pAssociatedExchange->WorkQueueItem.List);
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
SmbCeTransformExchange(
    PSMB_EXCHANGE                 pExchange,
    SMB_EXCHANGE_TYPE             NewType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector)
/*++

Routine Description:

   This routine transforms an exchange instance of one kind to an exchange instance
   of another kind ( A sophisticated form of casting )

Arguments:

    pExchange         - the exchange instance.

    Type              - the new type of the exchange

    pDispatchVector   - the dispatch vector asscoiated with this instance.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    As it is currently implemented no restrictions are imposed. Once the number of exchanges
    have been established further restrictions will be imposed barring certain kinds of
    transformations. The transformation merely switches the dispatch vector associated
    with the exchange but the context is left intact.

--*/
{
    PAGED_CODE();

    pExchange->Type = (UCHAR)NewType;
    pExchange->pDispatchVector = pDispatchVector;
    return STATUS_SUCCESS;
}

NTSTATUS
SmbCePrepareExchangeForReuse(
    PSMB_EXCHANGE                 pExchange)
/*++

Routine Description:

   This routine transforms an exchange instance of one kind to an exchange instance
   of another kind ( A sophisticated form of casting )

Arguments:

    pExchange  - the exchange instance.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMBCEDB_SERVER_ENTRY     pServerEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry = NULL;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry = NULL;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("SmbCePrepareExchangeForReuse: Invoked\n"));

    if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_SMBCE_STOPPED)) {
        pNetRootEntry    = SmbCeGetExchangeNetRootEntry(pExchange);
        pSessionEntry    = SmbCeGetExchangeSessionEntry(pExchange);
        pServerEntry     = SmbCeGetExchangeServerEntry(pExchange);
        pVNetRootContext = SmbCeGetExchangeVNetRootContext(pExchange);

        if (pServerEntry != NULL) {
            // Disassociate the MID associated with the exchange
            if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
                SmbCeDissociateMidFromExchange(pServerEntry,pExchange);
            }

            // Tear down all the copy data requests associated with this exchange
            SmbCePurgeBuffersAssociatedWithExchange(pServerEntry,pExchange);

            // Uninitialize the transport associated with the exchange
            SmbCeUninitializeExchangeTransport(pExchange);
        }

        // If this exchange has been marked as a constructor for either a
        // session or netroot finalize the appropriate entries. ( mark
        // them for deletion so that other exchanges can be resumed )

        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) {
            ASSERT(pSessionEntry != NULL);
            RxDbgTrace( 0, Dbg, ("Dispatching Session Entry Finalization\n"));

            SmbCeReferenceSessionEntry(pSessionEntry);
            
            ASSERT(pExchange->SessionSetupStatus != STATUS_SUCCESS ||
                   pSessionEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS);
            
            SmbCeCompleteSessionEntryInitialization(pSessionEntry,pExchange->SessionSetupStatus);
            pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_SESSION_CONSTRUCTOR;
        }

        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR) {
            ASSERT(pVNetRootContext != NULL);
            RxDbgTrace( 0, Dbg, ("Dispatching Net root Entry Finalization\n"));

            SmbCeReferenceVNetRootContext(pVNetRootContext);
            SmbCeCompleteVNetRootContextInitialization(pVNetRootContext);
            pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR;
        }

        if (pVNetRootContext != NULL) {
            SmbCeDereferenceVNetRootContext(pVNetRootContext);
         } else {
            if (pServerEntry != NULL) {
                SmbCeDereferenceServerEntry(pServerEntry);
            }
        }
    }

    if (FlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE)) {
        PSMB_EXCHANGE pMasterExchange;
        LONG AssociatedExchangeCount;

        pMasterExchange = pExchange->Associated.pMasterExchange;

        AssociatedExchangeCount = InterlockedDecrement(
                                      &pMasterExchange->Master.PendingAssociatedExchanges);

        if (FlagOn(
                pMasterExchange->SmbCeFlags,
                SMBCE_ASSOCIATED_EXCHANGES_COMPLETION_HANDLER_ACTIVATED) &&
            (AssociatedExchangeCount == 0)){
            NTSTATUS Status;
            BOOLEAN  PostRequest;

            ClearFlag(
                pMasterExchange->SmbCeFlags,
                SMBCE_ASSOCIATED_EXCHANGES_COMPLETION_HANDLER_ACTIVATED);

            Status = SMB_EXCHANGE_DISPATCH(
                         pMasterExchange,
                         AssociatedExchangesCompletionHandler,
                         (pMasterExchange,&PostRequest));

            RxDbgTrace(0,Dbg,("Master Exchange %lx Assoc. Completion Status %lx\n",pMasterExchange,Status));
        }

        SmbCeDecrementPendingLocalOperationsAndFinalize(pMasterExchange);
    }

    return STATUS_SUCCESS;
}

VOID
SmbCeDiscardExchangeWorkerThreadRoutine(PVOID pExchange)
/*++

Routine Description:

   This routine discards an exchange.

Arguments:

    pExchange  - the exchange to be discarded.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Even though this is simple, it cannot be inlined since the destruction of an
    exchange instance can be posted to a waorker thread.

--*/
{
    PSMB_EXCHANGE pSmbExchange = pExchange;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("SmbCeDiscardExchange: Invoked\n"));

    //RxLog((">>>Discard %lx",pSmbExchange));

    // Destory the context
    if (pSmbExchange->ReferenceCount == 0) {
        SmbCeAcquireResource();

        RemoveEntryList(&pSmbExchange->ExchangeList);

        SmbCeReleaseResource();

        SmbCePrepareExchangeForReuse(pSmbExchange);

        SmbCeDecrementActiveExchangeCount();

        // Discard the memory associated with the exchange
        SmbMmFreeExchange(pSmbExchange);
    } else {
        RxDbgTrace(
            0,
            Dbg,
            ("SmbCeDiscardExchange: Exchange %lx not discarded %ld\n",
              pSmbExchange,pSmbExchange->ReferenceCount)
            );
    }
}

VOID
SmbCeDiscardExchange(PVOID pExchange)
/*++

Routine Description:

   This routine discards an exchange.

Arguments:

    pExchange  - the exchange to be discarded.

Notes:

    The destruction of an exchange instance is posted to a worker thread in order to
    avoid deadlock in transport.

--*/
{
    PSMB_EXCHANGE pSmbExchange = pExchange;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pSmbExchange);

    // Disassociate the MID associated with the exchange
    if (pSmbExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
        SmbCeDissociateMidFromExchange(pServerEntry,pSmbExchange);
    }
    
    RxPostToWorkerThread(
        MRxSmbDeviceObject,
        CriticalWorkQueue,
        &((PSMB_EXCHANGE)pExchange)->WorkQueueItem,
        SmbCeDiscardExchangeWorkerThreadRoutine,
        (PSMB_EXCHANGE)pExchange);
}

NTSTATUS
SmbCeCancelExchange(
    PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine initiates the cancellation of an exchange.

Arguments:

    pRxContext  - the RX_CONTEXT instance for which cancellation needs to be
    initiated.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    The cancellation policy that has been implemented is a "best effort" policy.
    Since the server has already committed resources to an operation at its end
    the best that we can do within the scope of the SMB protocol is to initiate
    a cancellation operation by sending the appropriate SMB_COM_NT_CANCEL command

    Not all dialects of SMB support this command. For the downlevel dialects the
    best that we can do is to ensure that the MID is not reused during the lifetime
    of the connection. This will result in a gradual degradation of performance.

    The difficulty in detecting the end of operations is that there are MIDS

--*/
{
    NTSTATUS      Status = STATUS_SUCCESS;
    PSMB_EXCHANGE pExchange;

    PMRXSMB_RX_CONTEXT pMRxSmbContext;

    SmbCeLog(("SmbCe Cancel %lx\n",pRxContext));

    SmbCeAcquireSpinLock();

    pMRxSmbContext = MRxSmbGetMinirdrContext(pRxContext);
    pExchange = (PSMB_EXCHANGE)pMRxSmbContext->pCancelContext;

    if (pExchange != NULL) {
        if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED)) {
            if (pExchange->ReceivePendingOperations > 0) {
                PSMBCEDB_SERVER_ENTRY pServerEntry;

                // This exchange is awaiting a response from the server. In all
                // these cases a CANCEL command needs to be sent to the server
                // This command can only be sent to NT servers. For non NT
                // servers this exchange can be terminated with the detrimental
                // side effect of reducing the maximum number of commands by 1.

                InterlockedIncrement(&pExchange->LocalPendingOperations);

                Status = STATUS_MORE_PROCESSING_REQUIRED;

                pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

                if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
                    if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
                        NTSTATUS LocalStatus;

                        LocalStatus = SmbCepDiscardMidAssociatedWithExchange(
                                          pExchange);

                        ASSERT(LocalStatus == STATUS_SUCCESS);
                    }
                }
            } else {
                InterlockedCompareExchange(
                    &pExchange->CancellationStatus,
                    SMBCE_EXCHANGE_CANCELLED,
                    SMBCE_EXCHANGE_NOT_CANCELLED);
            }
        }
    }

    SmbCeReleaseSpinLock();

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        PSMBCE_SERVER pServer;
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        SmbCeLog(("SmbCeCancel Initiate %lx\n",pExchange));

        pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
        pServer = SmbCeGetExchangeServer(pExchange);

        if (FlagOn(pServer->DialectFlags,DF_NT_SMBS)) {
            UCHAR  LastCommandInHeader;
            PUCHAR pCommand;
            PSMB_HEADER pSmbHeader;
            PNT_SMB_HEADER pNtSmbHeader;

#define CANCEL_BUFFER_SIZE (sizeof(SMB_HEADER) + sizeof(REQ_NT_CANCEL))

            BYTE  SmbBuffer[TRANSPORT_HEADER_SIZE + CANCEL_BUFFER_SIZE];
            PBYTE  CancelRequestBuffer = SmbBuffer + TRANSPORT_HEADER_SIZE;
            ULONG CancelRequestBufferSize = CANCEL_BUFFER_SIZE;

            pSmbHeader = (PSMB_HEADER)CancelRequestBuffer;
            pNtSmbHeader = (PNT_SMB_HEADER)pSmbHeader;

            // Before issuing the cancel request ensure that if this exchange
            // is set as a timed receive operation. This will ensure that if
            // the cancel is delayed at the server we will initiate a tear down
            // of the connection.

            if (!FlagOn(
                    pExchange->SmbCeFlags,
                    SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION)) {

                SmbCeAcquireResource();

                SmbCeSetExpiryTime(pExchange);

                pExchange->SmbCeFlags |= SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION;

                SmbCeReleaseResource();
            }

            // Build the Cancel request and send it across to the server.
            Status = SmbCeBuildSmbHeader(
                         pExchange,
                         CancelRequestBuffer,
                         CancelRequestBufferSize,
                         &CancelRequestBufferSize,
                         &LastCommandInHeader,
                         &pCommand);

            ASSERT(LastCommandInHeader == SMB_COM_NO_ANDX_COMMAND);

            if (Status == STATUS_SUCCESS) {
                PREQ_NT_CANCEL pCancelRequest = (PREQ_NT_CANCEL)(&CancelRequestBuffer[sizeof(SMB_HEADER)]);
                PMDL     pCancelSmbMdl;

                *pCommand = SMB_COM_NT_CANCEL;

                SmbPutUshort(&pSmbHeader->Mid,pExchange->Mid);

                if (BooleanFlagOn(
                        pExchange->SmbCeFlags,
                        SMBCE_EXCHANGE_FULL_PROCESSID_SPECIFIED)) {

                    ULONG ProcessId;

                    ProcessId = RxGetRequestorProcessId(pRxContext);

                    SmbPutUshort(&pNtSmbHeader->Pid, (USHORT)((ProcessId) & 0xFFFF));
                    SmbPutUshort(&pNtSmbHeader->PidHigh, (USHORT)((ProcessId) >> 16));
                }

                SmbPutUshort(&pCancelRequest->WordCount,0);
                pCancelRequest->ByteCount = 0;
                CancelRequestBufferSize   = CANCEL_BUFFER_SIZE;

                RxAllocateHeaderMdl(
                    CancelRequestBuffer,
                    CancelRequestBufferSize,
                    pCancelSmbMdl
                    );

                if (pCancelSmbMdl != NULL) {
                    RxProbeAndLockHeaderPages(
                        pCancelSmbMdl,
                        KernelMode,
                        IoModifyAccess,
                        Status);

                    if (Status == STATUS_SUCCESS) {
                        Status = SmbCeSendToServer(
                                     pServerEntry,
                                     RXCE_SEND_SYNCHRONOUS,
                                     pCancelSmbMdl,
                                     CancelRequestBufferSize);

                        RxUnlockHeaderPages(pCancelSmbMdl);
                    }

                    IoFreeMdl(pCancelSmbMdl);
                }
            }
        } else {
            SmbCeFinalizeExchangeOnDisconnect(pExchange);
        }


        InterlockedCompareExchange(
            &pExchange->CancellationStatus,
            SMBCE_EXCHANGE_CANCELLED,
            SMBCE_EXCHANGE_NOT_CANCELLED);

        SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);
    }

    return Status;
}

NTSTATUS
SmbCeIncrementPendingOperations(
   PSMB_EXCHANGE pExchange,
   ULONG         PendingOperationMask,
   PVOID         FileName,
   ULONG         FileLine)
/*++

Routine Description:

   This routine increments the appropriate pending operation count

Arguments:

    pExchange  - the exchange to be finalized.

    PendingOperationsMask -- the pending operations to be incremented

Return Value:

    RxStatus(SUCCESS) if successful

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    SmbCeAcquireSpinLock();

    if (!BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED)) {
        if ((pServerEntry != NULL) &&
            ((pServerEntry->ServerStatus == STATUS_SUCCESS) ||
             (pExchange->NodeTypeCode == SMB_EXCHANGE_NTC(ADMIN_EXCHANGE)))) {

            if (PendingOperationMask & SMBCE_LOCAL_OPERATION) {
                pExchange->LocalPendingOperations++;
            }

            if (PendingOperationMask & SMBCE_SEND_COMPLETE_OPERATION) {
                pExchange->SendCompletePendingOperations++;
            }

            if (PendingOperationMask & SMBCE_COPY_DATA_OPERATION) {
                pExchange->CopyDataPendingOperations++;
            }

            if (PendingOperationMask & SMBCE_RECEIVE_OPERATION) {
                pExchange->ReceivePendingOperations++;
            }

            Status = STATUS_SUCCESS;
        } else {
            if ((PendingOperationMask & SMBCE_LOCAL_OPERATION) &&
                (PendingOperationMask & ~SMBCE_LOCAL_OPERATION) == 0) {

                pExchange->LocalPendingOperations++;
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_CONNECTION_DISCONNECTED;
            }
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    SmbCeReleaseSpinLock();

    return Status;
}

VOID
SmbCeFinalizeExchangeWorkerThreadRoutine(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

   This is the worker thread exchange finalization routine.

Arguments:

    pExchange  - the exchange to be finalized.

--*/
{
    BOOLEAN  fPostFinalize;
    NTSTATUS Status;

    PAGED_CODE();

    Status = SMB_EXCHANGE_DISPATCH(
                 pExchange,
                 Finalize,
                 (pExchange,&fPostFinalize));

    ASSERT(!fPostFinalize && (Status == STATUS_SUCCESS));
}

VOID
SmbCepFinalizeExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This is the common finalization routine used by both the routines below

Arguments:

    pExchange  - the exchange to be finalized.

--*/
{
    BOOLEAN fAssociatedExchange;

    ASSERT(FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED));
    fAssociatedExchange = BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE);

    if (fAssociatedExchange) {
        PSMB_EXCHANGE pMasterExchange;

        // The local operation will be decremented on resumption of
        // the finalization routine
        pMasterExchange = pExchange->Associated.pMasterExchange;
        SmbCeIncrementPendingLocalOperations(pMasterExchange);

        RxPostToWorkerThread(
            MRxSmbDeviceObject,
            CriticalWorkQueue,
            &pExchange->WorkQueueItem,
            SmbCepFinalizeAssociatedExchange,
            pExchange);
    } else {
        NTSTATUS Status;
        BOOLEAN fPostFinalize = FALSE;

        PSMBCEDB_SERVER_ENTRY pServerEntry;

        pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

        pExchange->ExpiryTime.QuadPart = 0;

        if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_RETAIN_MID)) {
            SmbCeDissociateMidFromExchange(
                pServerEntry,
                pExchange);
        }

        Status = SMB_EXCHANGE_DISPATCH(
                     pExchange,
                     Finalize,
                     (pExchange,&fPostFinalize));

        if ((Status == STATUS_SUCCESS) &&
            fPostFinalize)  {
            // Post the request to a worker thread so that the finalization can be completed
            // at a lower IRQL.
            RxPostToWorkerThread(
                MRxSmbDeviceObject,
                CriticalWorkQueue,
                &pExchange->WorkQueueItem,
                SmbCeFinalizeExchangeWorkerThreadRoutine,
                pExchange);
        }
    }
}

#define SENTINEL_ENTRY ((PSINGLE_LIST_ENTRY)IntToPtr(0xffffffff))

VOID
SmbCepFinalizeAssociatedExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This is the common finalization routine used by both the routines below

Arguments:

    pExchange  - the exchange to be finalized.

--*/
{
    PSMB_EXCHANGE       pMasterExchange;
    PSMB_EXCHANGE       pAssociatedExchange;
    SINGLE_LIST_ENTRY   AssociatedExchangeList;

    ASSERT(FlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE));

    pMasterExchange = pExchange->Associated.pMasterExchange;

    ASSERT(pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next != NULL);

    for (;;) {
        BOOLEAN fAllAssociatedExchangesFinalized = FALSE;

        SmbCeAcquireSpinLock();

        if (pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next == SENTINEL_ENTRY) {
            pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next = NULL;
            fAllAssociatedExchangesFinalized = TRUE;
        } else if (pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next == NULL) {
            fAllAssociatedExchangesFinalized = TRUE;
        } else {
            AssociatedExchangeList.Next =
                pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next;

            pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next =
                SENTINEL_ENTRY;
        }

        SmbCeReleaseSpinLock();

        if (!fAllAssociatedExchangesFinalized) {
            for (;;) {
                PSINGLE_LIST_ENTRY pAssociatedExchangeEntry;

                pAssociatedExchangeEntry = AssociatedExchangeList.Next;

                if ((pAssociatedExchangeEntry != NULL) &&
                    (pAssociatedExchangeEntry != SENTINEL_ENTRY)) {
                    NTSTATUS Status;
                    BOOLEAN  fPostFinalize = FALSE;

                    AssociatedExchangeList.Next = pAssociatedExchangeEntry->Next;

                    pAssociatedExchange = (PSMB_EXCHANGE)
                                          CONTAINING_RECORD(
                                              pAssociatedExchangeEntry,
                                              SMB_EXCHANGE,
                                              Associated.NextAssociatedExchange);

                    ASSERT(IsListEmpty(&pAssociatedExchange->WorkQueueItem.List));

                    Status = SMB_EXCHANGE_DISPATCH(
                                 pAssociatedExchange,
                                 Finalize,
                                 (pAssociatedExchange,&fPostFinalize));
                } else {
                    break;
                }
            };
        } else {
            break;
        }
    }

    SmbCeDecrementPendingLocalOperationsAndFinalize(pMasterExchange);
}

BOOLEAN
SmbCeCanExchangeBeFinalized(
    PSMB_EXCHANGE pExchange,
    PSMBCE_EXCHANGE_STATUS pExchangeStatus)
/*++

Routine Description:

   This routine determines if the exchange instance can be finalized.

Arguments:

    pExchange  - the exchange to be finalized.

    pExchangeStatus - the finalization status

Return Value:

    TRUE if the exchange can be finalized

Notes:

    As a side effect it also sets the SMBCE_EXCHANGE_FINALIZED flag

    The SmbCe spin lock must have been acquire on entry

--*/
{
    BOOLEAN fFinalizeExchange = FALSE;
    BOOLEAN fAssociatedExchange;

    fAssociatedExchange = BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE);

    if (!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_FINALIZED)) {
        if ((pExchange->ReceivePendingOperations == 0) &&
            (pExchange->CopyDataPendingOperations == 0) &&
            (pExchange->SendCompletePendingOperations == 0) &&
            (pExchange->LocalPendingOperations == 0)) {

            fFinalizeExchange = TRUE;
            *pExchangeStatus = SmbCeExchangeFinalized;
            pExchange->SmbCeFlags |= SMBCE_EXCHANGE_FINALIZED;

            if (fAssociatedExchange) {
                PSMB_EXCHANGE pMasterExchange = pExchange->Associated.pMasterExchange;

                if (pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next != NULL) {
                    fFinalizeExchange = FALSE;
                }

                pExchange->Associated.NextAssociatedExchange.Next =
                    pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next;
                pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next =
                    &pExchange->Associated.NextAssociatedExchange;
            }
        } else {
            *pExchangeStatus = SmbCeExchangeNotFinalized;
        }
    } else {
        *pExchangeStatus = SmbCeExchangeAlreadyFinalized;
    }

    if (fFinalizeExchange &&
        (pExchange->RxContext != NULL)) {
        NTSTATUS Status;
        PMRXSMB_RX_CONTEXT pMRxSmbContext;

        pMRxSmbContext = MRxSmbGetMinirdrContext(pExchange->RxContext);
        pMRxSmbContext->pCancelContext = NULL;

        Status = RxSetMinirdrCancelRoutine(
                     pExchange->RxContext,
                     NULL);
    }

    return fFinalizeExchange;
}

SMBCE_EXCHANGE_STATUS
SmbCeFinalizeExchange(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

   This routine finalizes an exchange instance.

Arguments:

    pExchange  - the exchange to be finalized.

Return Value:

    appropriate exchange status

Notes:

    When an exchange is initiated and the start routine is invoked a number of
    SMB's are sent. This routine is invoked when all processing pertaining to the
    SMB's that have been sent has ceased.

    This routine encapsulates all the idiosyncratic behaviour associated with the
    transports.

--*/
{
    BOOLEAN               fFinalizeExchange = FALSE;

    SMBCE_EXCHANGE_STATUS ExchangeStatus;

    SmbCeAcquireSpinLock();

    fFinalizeExchange = SmbCeCanExchangeBeFinalized(
                            pExchange,
                            &ExchangeStatus);

    SmbCeReleaseSpinLock();

    if (fFinalizeExchange) {
        SmbCepFinalizeExchange(pExchange);
    }

    return ExchangeStatus;
}

NTSTATUS
SmbCeDecrementPendingOperations(
    PSMB_EXCHANGE pExchange,
    ULONG         PendingOperationMask,
    PVOID         FileName,
    ULONG         FileLine)
/*++

Routine Description:

   This routine decrements the corresponding pending operation count
   and finalizes an exchange instance if required

Arguments:

    pExchange  - the exchange to be finalized.

    PendingOperationsMask -- the pending operations to be decremented.

Return Value:

    appropriate exchange status

Notes:

    When an exchange is initiated and the start routine is invoked a number of
    SMB's are sent. This routine is invoked when all processing pertaining to the
    SMB's that have been sent has ceased.

    This routine encapsulates all the idiosyncratic behaviour associated with the
    transports.

--*/
{
    SmbCeAcquireSpinLock();

    ASSERT(!BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED));

    if (PendingOperationMask & SMBCE_LOCAL_OPERATION) {
        ASSERT(pExchange->LocalPendingOperations > 0);
        pExchange->LocalPendingOperations--;
    }

    if (PendingOperationMask & SMBCE_SEND_COMPLETE_OPERATION) {
        ASSERT(pExchange->SendCompletePendingOperations > 0);
        pExchange->SendCompletePendingOperations--;
    }

    if (PendingOperationMask & SMBCE_COPY_DATA_OPERATION) {
        ASSERT(pExchange->CopyDataPendingOperations > 0);
        pExchange->CopyDataPendingOperations--;
    }

    if ((PendingOperationMask & SMBCE_RECEIVE_OPERATION) &&
        (pExchange->ReceivePendingOperations > 0)) {
        pExchange->ReceivePendingOperations--;
    }
    SmbCeReleaseSpinLock();

    return STATUS_SUCCESS;
}

SMBCE_EXCHANGE_STATUS
SmbCeDecrementPendingOperationsAndFinalize(
    PSMB_EXCHANGE pExchange,
    ULONG         PendingOperationMask,
    PVOID         FileName,
    ULONG         FileLine)
/*++

Routine Description:

   This routine decrements the corresponding pending operation count
   and finalizes an exchange instance if required

Arguments:

    pExchange  - the exchange to be finalized.

    PendingOperationsMask -- the pending operations to be decremented.

Return Value:

    appropriate exchange status

Notes:

    When an exchange is initiated and the start routine is invoked a number of
    SMB's are sent. This routine is invoked when all processing pertaining to the
    SMB's that have been sent has ceased.

    This routine encapsulates all the idiosyncratic behaviour associated with the
    transports.

--*/
{
    BOOLEAN               fFinalizeExchange = FALSE;
    SMBCE_EXCHANGE_STATUS ExchangeStatus;

    SmbCeAcquireSpinLock();

    ASSERT(!BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED));

    if (PendingOperationMask & SMBCE_LOCAL_OPERATION) {
        ASSERT(pExchange->LocalPendingOperations > 0);
        pExchange->LocalPendingOperations--;
    }

    if (PendingOperationMask & SMBCE_SEND_COMPLETE_OPERATION) {
        ASSERT(pExchange->SendCompletePendingOperations > 0);
        pExchange->SendCompletePendingOperations--;
    }

    if (PendingOperationMask & SMBCE_COPY_DATA_OPERATION) {
        ASSERT(pExchange->CopyDataPendingOperations > 0);
        pExchange->CopyDataPendingOperations--;
    }

    if ((PendingOperationMask & SMBCE_RECEIVE_OPERATION) &&
        (pExchange->ReceivePendingOperations > 0)) {
        pExchange->ReceivePendingOperations--;
    }

    fFinalizeExchange = SmbCeCanExchangeBeFinalized(
                            pExchange,
                            &ExchangeStatus);


    SmbCeReleaseSpinLock();

    if (fFinalizeExchange) {
        SmbCepFinalizeExchange(pExchange);
    }

    return ExchangeStatus;
}

VOID
SmbCeFinalizeExchangeOnDisconnect(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

    This routine handles the finalization of an exchange instance during transport disconnects

Arguments:

    pExchange  - the exchange instance

--*/
{
    PAGED_CODE();

    if (pExchange != NULL) {
        pExchange->Status      = STATUS_CONNECTION_DISCONNECTED;
        pExchange->SmbStatus   = STATUS_CONNECTION_DISCONNECTED;
        pExchange->ReceivePendingOperations = 0;

        SmbCeFinalizeExchange(pExchange);
    }
}

VOID
SmbCeSetExpiryTime(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine sets the expiry time for a timed exchange,
   i.e., SMBCE_EXCHANGE_TIMED_OPERATION must be set

Arguments:

    pExchange  - the exchange instance.

Notes:

--*/
{
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ExpiryTimeInTicks;

    KeQueryTickCount( &CurrentTime );

    ExpiryTimeInTicks.QuadPart = (1000 * 1000 * 10) / KeQueryTimeIncrement();

    ExpiryTimeInTicks.QuadPart = MRxSmbConfiguration.SessionTimeoutInterval * ExpiryTimeInTicks.QuadPart;

    pExchange->ExpiryTime.QuadPart = CurrentTime.QuadPart + ExpiryTimeInTicks.QuadPart;
}

BOOLEAN
SmbCeDetectExpiredExchanges(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine periodically walks the list of timed exchanges and chooses the
    instances for finalization.

    A timed exchange choosen by this routine will have waited for some network
    response for the given time interval

Arguments:

    pServerEntry -- the server entry for which this needs to be done

Notes:

--*/
{
    BOOLEAN       ExpiredExchangesDetected = FALSE;
    PSMB_EXCHANGE pExchange;
    PLIST_ENTRY   pListHead;
    PLIST_ENTRY   pListEntry;
    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    KeQueryTickCount( &CurrentTime );

    SmbCeAcquireResource();

    pListHead = &pServerEntry->ActiveExchanges;
    pListEntry = pListHead->Flink;

    while (pListEntry != pListHead) {
        PLIST_ENTRY pNextListEntry;

        pNextListEntry = pListEntry->Flink;
        pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);

        // There are two kinds of exchanges that are candidates for
        // time out finalization.
        // (1) Any exchange which has a outstanding send complete
        // operation which has not completed.
        // (2) timed network operation exchanges which have a
        // receive or copy data operation pending.
        //
        // In all such cases the associated server entry is marked
        // for tear down and further processing is terminated.
        //

        if ((pExchange->SendCompletePendingOperations > 0) ||
            (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION) &&
             ((pExchange->CopyDataPendingOperations > 0) ||
              (pExchange->ReceivePendingOperations > 0)))) {
            if ((pExchange->ExpiryTime.QuadPart != 0) &&
                (pExchange->ExpiryTime.QuadPart < CurrentTime.QuadPart) &&
                !FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED)) {

                RxLog(("Marking server for tear down %lx \n",pServerEntry));

                ExpiredExchangesDetected = TRUE;

                break;
            }
        }

        pListEntry = pNextListEntry;
    }

    SmbCeReleaseResource();

    return ExpiredExchangesDetected;
}

//
// Default handler implementation of exchange handler functions.
//

NTSTATUS
DefaultSmbExchangeIndError(
    IN PSMB_EXCHANGE pExchange)     // the SMB exchange instance
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
DefaultSmbExchangeIndReceive(
    IN PSMB_EXCHANGE    pExchange)    // The exchange instance
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
DefaultSmbExchangeIndSendCallback(
    IN PSMB_EXCHANGE    pExchange)    // The exchange instance
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_NOT_IMPLEMENTED;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\sndrcv.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    sndrcv.c

Abstract:

    This module implements all functions related to transmitting and recieving SMB's on
    all transports. The functionality common to all transports are handled in this
    module while transport specific functionality are handled in the appropriate
    ??sndrcv.c modules.

      vcsndrcv.c  -- virtual circuit(connection) related send/receive functionality

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeSend)
#pragma alloc_text(PAGE, SmbCeSendToServer)
#endif

RXDT_DefineCategory(SMBSNDRCV);
#define Dbg        (DEBUG_TRACE_SMBSNDRCV)

#ifdef RDBSSLOG
//this stuff must be in nonpaged memory
                               ////       1 2 3 4 5 6 7 8 9
char MRxSmbMiniSniff_SurrogateFormat[] = "%S%S%N%N%N%N%N%N%N";
                            ////                     2       3       4       5       6         7        8        9
char MRxSmbMiniSniff_ActualFormat[]    = "Minisniff (%s) srv %lx cmd/mid %lx status %lx len %04lx flg %06lx xc %08lx rx %08lx";

char MRxSmbMiniSniffTranceive[] = "Tranceive";
char MRxSmbMiniSniffReceive[] = "Receive";
char MRxSmbMiniSniffReceiveEcho[] = "RcvEcho";
char MRxSmbMiniSniffReceiveDiscard[] = "RcvDiscard";
char MRxSmbMiniSniffReceiveDiscardOplock[] = "RcvDiscardOplock";
char MRxSmbMiniSniffReceiveIndicateOplock[] = "RcvIndicateOplock";
char MRxSmbMiniSniffSend[] = "Send";
char MRxSmbMiniSniffSendSrv[] = "SendToServer";

VOID
RxMiniSniffer(
    IN PSZ TagString,
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN ULONG Length,
    IN PSMB_EXCHANGE pExchange,
    IN PSMB_HEADER   pSmbHeader
    )
{
    PRX_CONTEXT RxContext = NULL;

    //return;

    if (pExchange!=NULL) {
        RxContext = pExchange->RxContext;
    }
    RxLog((MRxSmbMiniSniff_SurrogateFormat, MRxSmbMiniSniff_ActualFormat,
                    TagString,
                    pServerEntry,
                    (ULONG)(pSmbHeader->Command<<24) | SmbGetUshort(&pSmbHeader->Mid),
                    SmbGetUlong( & ((PNT_SMB_HEADER)pSmbHeader)->Status.NtStatus ),
                    Length,
                    (pSmbHeader->Flags<<16)|SmbGetUshort(&pSmbHeader->Flags2),
                    pExchange,RxContext));
}
#else
#define RxMiniSniffer(a,b,c,d,e) {NOTHING;}
#endif //ifdef RDBSSLOG


NTSTATUS
SmbCeTranceive(
      PSMB_EXCHANGE   pExchange,
      ULONG           SendOptions,
      PMDL            pSmbMdl,
      ULONG           SendLength)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

    STATUS_PENDING - the transmit/receive request has been passed on successfully to the underlying
                     connection engine.

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS                Status = STATUS_SUCCESS;

   PSMBCEDB_SERVER_ENTRY   pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);

   PSMB_HEADER             pSmbHeader   = MmGetSystemAddressForMdlSafe(pSmbMdl,LowPagePriority);
   USHORT                  Mid;

   PVOID                   pSendCompletionContext = NULL;

   if (pSmbHeader == NULL) {
       Status = STATUS_INSUFFICIENT_RESOURCES;
   } else {
       Status = SmbCeIncrementPendingOperations(
                      pExchange,
                      (SMBCE_LOCAL_OPERATION | SMBCE_SEND_COMPLETE_OPERATION | SMBCE_RECEIVE_OPERATION),
                      __FILE__,
                      __LINE__);
   }

   if (Status == STATUS_SUCCESS) {
       PSMBCE_SERVER_TRANSPORT pTransport;

      // Ensure that the transport associated with the exchange is valid.
      // It is not always possible to make decisions w.r.t changing
      // transports since it is a function of the protocol choosen at the
      // higher level. Therefore no attempts to reconnect are made at this
      // level.

      pTransport = pServerEntry->pTransport;

      if (pTransport == NULL) {
          Status = STATUS_CONNECTION_DISCONNECTED;
      }

      if (Status == STATUS_SUCCESS &&
          !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID)) {
         // Associate the exchange with a mid
         Status = SmbCeAssociateExchangeWithMid(pServerEntry,pExchange);
      }

      if (Status == STATUS_SUCCESS) {
         if (pExchange->pDispatchVector->SendCompletionHandler != NULL) {
            Status = SmbCeAssociateBufferWithExchange(pServerEntry,pExchange,pSmbMdl);

            if (Status == STATUS_SUCCESS) {
               pSendCompletionContext = pSmbMdl;
            }
         }

         // If there is no send completion handling associated with this tranceive
         // decrement the count.
         if (pSendCompletionContext == NULL) {
            SmbCeDecrementPendingSendCompleteOperations(pExchange);
         }

         if (Status == STATUS_SUCCESS) {
            // Stamp the MID allocated for the request and send the SMB.
            pSmbHeader->Mid = pExchange->Mid;

            //RxLog(("Smb (TR) %lx %lx %lx\n",pServerEntry,pSmbHeader->Command,pSmbHeader->Mid));
            RxMiniSniffer(MRxSmbMiniSniffTranceive,pServerEntry,SendLength,pExchange,pSmbHeader);

            // Update the expiry time on the exchange if required.
            SmbCeSetExpiryTime(pExchange);

            if (InterlockedCompareExchange(
                    &pExchange->CancellationStatus,
                    SMBCE_EXCHANGE_NOT_CANCELLED,
                    SMBCE_EXCHANGE_NOT_CANCELLED) == SMBCE_EXCHANGE_NOT_CANCELLED) {

                if (Status == STATUS_SUCCESS) {
                    // Update the operation counts for the exchange instance.
                    // Refer to Header for detailed explanation
                    Status = (pTransport->pDispatchVector->Tranceive)(
                                    pTransport,
                                    pServerEntry,
                                    pExchange,
                                    SendOptions,
                                    pSmbMdl,
                                    SendLength,
                                    pSendCompletionContext);
                }
            } else {
                if (pSendCompletionContext != NULL) {
                    SmbCeDecrementPendingSendCompleteOperations(pExchange);
                }
                Status = STATUS_CANCELLED;
            }

            if ((Status != STATUS_PENDING) &&
                (Status != STATUS_SUCCESS)) {
               pExchange->Status = Status;
               SmbCeDecrementPendingReceiveOperations(pExchange);
               InterlockedIncrement(&MRxSmbStatistics.InitiallyFailedOperations);
            } else {
                ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsTransmitted,1);
                ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesTransmitted,SendLength);
            }
         }
      } else {
         SmbCeDecrementPendingReceiveOperations(pExchange);
         SmbCeDecrementPendingSendCompleteOperations(pExchange);
      }

      if ((Status != STATUS_SUCCESS) && (Status != STATUS_PENDING)) {
         pExchange->SmbStatus = Status;
      }

      SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);
      Status = STATUS_PENDING;
   }

   return Status;
}

NTSTATUS
SmbCeReceive(
   PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This routine receives a SMB for a give exchange

Arguments:

    pExchange  - the exchange instance issuing this SMB.

Return Value:

    STATUS_SUCCESS - the exchange has been setup for receiving an SMB

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   ASSERT(pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID);

   Status = SmbCeIncrementPendingOperations(pExchange, (SMBCE_RECEIVE_OPERATION),__FILE__,__LINE__);

   if (Status == STATUS_SUCCESS) {
       // Update the expiry time on the exchange if required.
       SmbCeSetExpiryTime(pExchange);
   }

   return Status;
}


NTSTATUS
SmbCeSend(
   PSMB_EXCHANGE pExchange,
   ULONG         SendOptions,
   PMDL          pSmbMdl,
   ULONG         SendLength)
/*++

Routine Description:

    This routine transmits a SMB for a give exchange

Arguments:

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

For asynchronous sends ....

    STATUS_PENDING - the request was passed onto the underlying transport and
                     the quiescent state routine will be called in the future.

    any other status code -- indicates an error in passing the request and the
                     quiescent state routine will never be called in the future.


For synchronous sends

    the appropriate status but will never return STATUS_PENDING.

Notes:

    This routine always expects an exchange with the appropriate SendCompletionHandler.

--*/
{
    NTSTATUS              Status       = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
    PSMB_HEADER           pSmbHeader   = (PSMB_HEADER)MmGetSystemAddressForMdlSafe(pSmbMdl,LowPagePriority);
    PVOID                 pSendCompletionContext = NULL;

    PAGED_CODE();

    ASSERT(pExchange != NULL);

    if (pSmbHeader == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        Status = SmbCeIncrementPendingOperations(
                     pExchange,
                     (SMBCE_LOCAL_OPERATION | SMBCE_SEND_COMPLETE_OPERATION),
                     __FILE__,
                     __LINE__);
    }

    if (Status == STATUS_SUCCESS) {
        PSMBCE_SERVER_TRANSPORT pTransport;

        // Ensure that the transport associated with the exchange is valid.
        // It is not always possible to make decisions w.r.t changing
        // transports since it is a function of the protocol choosen at the
        // higher level. Therefore no attempts to reconnect are made at this
        // level.

        pTransport = pServerEntry->pTransport;

        ASSERT(pTransport != NULL);

        if (SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER) {
            if (!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID)) {
                // Associate the exchange with a mid if it does not already have a valid mid.
                Status = SmbCeAssociateExchangeWithMid(pServerEntry,pExchange);
            }

            if (Status == STATUS_SUCCESS) {
                // if the MID association was successful copy the MID onto the SMB and setup
                // a send completion context if required
                pSmbHeader->Mid = pExchange->Mid;
                if (!(SendOptions & RXCE_SEND_SYNCHRONOUS)) {
                    ASSERT(pExchange->pDispatchVector->SendCompletionHandler != NULL);
                    Status = SmbCeAssociateBufferWithExchange(pServerEntry,pExchange,pSmbMdl);
                    if (Status == STATUS_SUCCESS) {
                        pSendCompletionContext = pSmbMdl;
                    }
                }
            }
        }

        if ((pSendCompletionContext == NULL) ||
            (Status != STATUS_SUCCESS)) {
            SmbCeDecrementPendingSendCompleteOperations(pExchange);
        }

        if (Status == STATUS_SUCCESS) {
            // Update the expiry time on the exchange if required.
            SmbCeSetExpiryTime(pExchange);

            if (InterlockedCompareExchange(
                    &pExchange->CancellationStatus,
                    SMBCE_EXCHANGE_NOT_CANCELLED,
                    SMBCE_EXCHANGE_NOT_CANCELLED) == SMBCE_EXCHANGE_NOT_CANCELLED) {

                if (Status == STATUS_SUCCESS) {
                    Status = (pTransport->pDispatchVector->Send)(
                                 pTransport,
                                 pServerEntry,
                                 SendOptions,
                                 pSmbMdl,
                                 SendLength,
                                 pSendCompletionContext);
                }
            } else {
                if (pSendCompletionContext != NULL) {
                    SmbCeDecrementPendingSendCompleteOperations(pExchange);
                }
                Status = STATUS_CANCELLED;
            }
        }

        RxMiniSniffer(MRxSmbMiniSniffSend,pServerEntry,SendLength,pExchange,pSmbHeader);

        if ((Status != STATUS_SUCCESS) && (Status != STATUS_PENDING)) {
            pExchange->SmbStatus = Status;
            InterlockedIncrement(&MRxSmbStatistics.InitiallyFailedOperations);
        } else {
            ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsTransmitted,1);
            ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesTransmitted,SendLength);
        }

        SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

        if (!(SendOptions & RXCE_SEND_SYNCHRONOUS)) {
            Status = STATUS_PENDING;
        } else {
            ASSERT(Status != STATUS_PENDING);
        }
    }

    return Status;
}

NTSTATUS
SmbCeSendToServer(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   ULONG                 SendOptions,
   PMDL                  pSmbMdl,
   ULONG                 SendLength)
/*++

Routine Description:

    This routine transmits a SMB to a given server synchronously.

Arguments:

    pServerEntry - the server entry

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

    STATUS_SUCCESS if successful

    otherwise appropriate error code

--*/
{
   NTSTATUS    Status = STATUS_SUCCESS;
   PSMB_HEADER pSmbHeader = (PSMB_HEADER)MmGetSystemAddressForMdlSafe(pSmbMdl,LowPagePriority);
   PVOID       pSendCompletionContext = NULL;

   PAGED_CODE();

   if (pSmbHeader == NULL) {
       Status = STATUS_INSUFFICIENT_RESOURCES;
   } else {
       if (pServerEntry->pTransport != NULL) {
           Status = (pServerEntry->pTransport->pDispatchVector->Send)(
                        pServerEntry->pTransport,
                        pServerEntry,
                        (SendOptions | RXCE_SEND_SYNCHRONOUS),
                        pSmbMdl,
                        SendLength,
                        pSendCompletionContext);
          
           if (!NT_SUCCESS(Status)) {
               InterlockedIncrement(&MRxSmbStatistics.InitiallyFailedOperations);
           } else {
               ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsTransmitted,1);
               ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesTransmitted,SendLength);
              
               RxMiniSniffer(MRxSmbMiniSniffSendSrv,pServerEntry,SendLength,NULL,pSmbHeader);
           }
       } else {
           Status = STATUS_CONNECTION_DISCONNECTED;
       }
   }

   ASSERT(Status != STATUS_PENDING);
   return Status;
}


NTSTATUS
SmbCeReceiveInd(
      IN PSMBCEDB_SERVER_ENTRY pServerEntry,
      IN ULONG                 BytesIndicated,
      IN ULONG                 BytesAvailable,
      OUT ULONG                *pBytesTaken,
      IN PVOID                 pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
      OUT PMDL                 *pDataBufferPointer,    // the buffer in which data is to be copied.
      OUT PULONG               pDataBufferSize,        // amount of data to copy
      IN ULONG                 ReceiveFlags
     )
/*++

Routine Description:

    This routine handles the receive indication for SMB's along all vcs in a connection to a
    server.

Arguments:

    pServerEntry       - the server entry

    BytesIndicated     - the bytes that are present in the indication.

    BytesAvailable     - the total data available

    pTsdu              - the data

    pDataBufferPointer - the buffer for copying the data not indicated.

    pDataBufferSize    - the length of the buffer

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS Status;

   BYTE                     *pSmbCommand;
   PSMB_EXCHANGE            pExchange;
   PSMB_HEADER              pSmbHeader = (PSMB_HEADER)pTsdu;

   // Perform the quick tests by which ill formed SMB's, mangled SMB's can be rejected.
   // e.g., any indication which is of non zero length which is less then the length of
   // a SMB_HEADER plus the minimum SMB message body length of 3 bytes cannot be a valid
   // SMB.

   if ((BytesAvailable < sizeof(SMB_HEADER) + 2) ||
       (SmbGetUlong(((PULONG )pSmbHeader->Protocol)) != (ULONG)SMB_HEADER_PROTOCOL) ||
       (pSmbHeader->Command == SMB_COM_NO_ANDX_COMMAND)  ) {
      RxLog(("SmbCeReceiveInd: Invalid Response for %lx\n",pServerEntry));
      *pBytesTaken = BytesIndicated;
      return STATUS_SUCCESS;
   }

   ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

   if (pSmbHeader->Command == SMB_COM_ECHO) {
       PSMBCE_RESUMPTION_CONTEXT pResumptionContext = NULL;

       InterlockedExchange(
           &pServerEntry->Server.EchoProbeState,
           ECHO_PROBE_IDLE);
       pServerEntry->Server.EchoExpiryTime.QuadPart = 0;

       *pBytesTaken = BytesIndicated;
       RxMiniSniffer(MRxSmbMiniSniffReceiveEcho,pServerEntry,BytesIndicated,NULL,pSmbHeader);

       ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
       ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,BytesIndicated);

       return STATUS_SUCCESS;
   }

   //RxLog(("Smb (Rece) %lx %lx %lx\n",pServerEntry,pSmbHeader->Command,pSmbHeader->Mid));

   // Perform the tests for detecting oplock break SMB's. These are SMB's with the
   // command SMB_COM_LOCKING_ANDX with the LOCKING_ANDX_OPLOCK_RELEASE bit set.
   // These SMB's are transformed into buffering state change requests which are
   // processed by the RDBSS.
   //

   if (pSmbHeader->Command == SMB_COM_LOCKING_ANDX) {
      if (BytesIndicated == LOCK_BROKEN_SIZE) {
         PREQ_LOCKING_ANDX pOplockBreakRequest = (PREQ_LOCKING_ANDX)(pSmbHeader + 1);

         if (SmbGetUshort(&pOplockBreakRequest->LockType) & LOCKING_ANDX_OPLOCK_RELEASE) {
            ULONG NewOplockLevel;

            switch (pOplockBreakRequest->OplockLevel) {
            case OPLOCK_BROKEN_TO_II:
               NewOplockLevel = SMB_OPLOCK_LEVEL_II;
               break;
            case OPLOCK_BROKEN_TO_NONE:
            default:
               NewOplockLevel = SMB_OPLOCK_LEVEL_NONE;
            }

            RxMiniSniffer(MRxSmbMiniSniffReceiveIndicateOplock,pServerEntry,BytesIndicated,NULL,pSmbHeader);
            ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
            ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,BytesIndicated);

            if (pServerEntry->pRdbssSrvCall != NULL) {
                RxIndicateChangeOfBufferingState(
                         pServerEntry->pRdbssSrvCall,
                         MRxSmbMakeSrvOpenKey(pSmbHeader->Tid,pOplockBreakRequest->Fid),
                         ULongToPtr(NewOplockLevel));
            }

            RxDbgTrace(0,Dbg,("SmbCeReceiveInd: OPLOCK Break Request TID(%lx) FID(%lx)\n",
                                               pSmbHeader->Tid,pOplockBreakRequest->Fid));

            RxLog(("OPLOCK Break: FID %lx Level %x\n",pOplockBreakRequest->Fid,pOplockBreakRequest->OplockLevel));
            //DbgPrint("OPLOCK Break: FID %lx Level %x\n",pOplockBreakRequest->Fid,pOplockBreakRequest->OplockLevel);

            *pBytesTaken = BytesIndicated;
            return STATUS_SUCCESS;
         }
      }
   }

   // Handle the cases when the server responds to the oplock break response.
   if (pSmbHeader->Mid == SMBCE_OPLOCK_RESPONSE_MID) {
      *pBytesTaken = BytesIndicated;
      ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
      ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,BytesIndicated);
      RxMiniSniffer(MRxSmbMiniSniffReceiveDiscardOplock,pServerEntry,BytesIndicated,NULL,pSmbHeader);
      return STATUS_SUCCESS;
   }

   InterlockedIncrement(&pServerEntry->Server.SmbsReceivedSinceLastStrobe);

   // Initialize the copy data buffer and size to begin with.
   *pDataBufferPointer = NULL;
   *pDataBufferSize    = 0;

   // Map the MID to the associated exchange.
   if (pSmbHeader->Command == SMB_COM_NEGOTIATE) {
       pExchange = SmbResetServerEntryNegotiateExchange(pServerEntry);
       if (pExchange != NULL) {
           SmbCeDecrementPendingLocalOperations(pExchange);
       }
   } else {
       pExchange = SmbCeMapMidToExchange(pServerEntry,pSmbHeader->Mid);
   }

   RxMiniSniffer(MRxSmbMiniSniffReceive,pServerEntry,BytesIndicated,pExchange,pSmbHeader);

   // Note that the absence of a request entry cannot be asserted. It is conceivable that
   // requests could have been cancelled.
   if ((pExchange != NULL) &&
       (SmbCeIncrementPendingOperations(
               pExchange,
               (SMBCE_LOCAL_OPERATION | SMBCE_COPY_DATA_OPERATION),
               __FILE__,
               __LINE__) == STATUS_SUCCESS)) {
      // Invoke the receive indication handler
      Status = SMB_EXCHANGE_DISPATCH(pExchange,
                                     Receive,
                                     (pExchange,
                                      BytesIndicated,
                                      BytesAvailable,
                                      pBytesTaken,
                                      pTsdu,
                                      pDataBufferPointer,
                                      pDataBufferSize,
                                      ReceiveFlags));

      ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
      ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,*pBytesTaken);

      RxDbgTrace(0, Dbg, ("SmbCeReceiveInd: SMB_EXCHANGE_DISPATCH returned %lx,taken/mdl=%08lx/%08lx\n",
                                          Status,*pBytesTaken,*pDataBufferPointer));
      ASSERT ( (Status==STATUS_MORE_PROCESSING_REQUIRED)==((*pDataBufferPointer)!=NULL));

      if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
         Status = SmbCeAssociateBufferWithExchange(pServerEntry,pExchange,*pDataBufferPointer);
         if (Status != STATUS_SUCCESS) {
            DbgPrint("VctIndReceive:Error handling copy data request %lx\n",Status);
            pExchange->Status = Status;
            *pBytesTaken = BytesAvailable;
            Status = STATUS_SUCCESS;
         } else {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
         }
      }

      if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
         SmbCeDecrementPendingCopyDataOperations(pExchange);
      } else {
          // Update the expiry time on the exchange if required.
          SmbCeSetExpiryTime(pExchange);
      }

      SmbCeDecrementPendingReceiveOperations(pExchange);

      SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

      if (((*pBytesTaken + *pDataBufferSize) < BytesAvailable)  &&
          (Status != STATUS_MORE_PROCESSING_REQUIRED)) {
         RxDbgTrace(0,Dbg,("SmbCeReceiveInd:Not consuming all indicated data\n"));
         *pBytesTaken = BytesAvailable;
      }
   } else {
      // Should we change over to a strategy in which the transport pipeline is kept
      // open by consuming all indicated data
      // DbgBreakPoint();
      RxLog(("SmbCeReceiveInd:No resumption context %lx\n",pServerEntry));
      Status = STATUS_SUCCESS;
      *pBytesTaken = BytesAvailable;
   }

   ASSERT((*pBytesTaken + *pDataBufferSize) >= BytesAvailable);
   ASSERT(Status == STATUS_SUCCESS ||
          Status == STATUS_DATA_NOT_ACCEPTED ||
          Status == STATUS_MORE_PROCESSING_REQUIRED);
   return Status;
}


NTSTATUS
SmbCeDataReadyInd(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PMDL                  pBuffer,
   IN ULONG                 DataSize,
   IN NTSTATUS              CopyDataStatus
   )
/*++

Routine Description:

    This routine handles the indication when the requested data has been copied

Arguments:

    pServerEntry  - the server instance

    pBuffer       - the buffer being returned

    DataSize      - the amount of data copied in bytes

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS      Status;
   PSMB_EXCHANGE pExchange;

   // Map the buffer to the exchange
   pExchange = SmbCeGetExchangeAssociatedWithBuffer(pServerEntry,pBuffer);

   RxDbgTrace(0, Dbg, ("VctIndDataReady: Processing Exchange %lx\n",pExchange));
   if (pExchange != NULL) {
      if (CopyDataStatus == STATUS_SUCCESS) {
         // Notify the exchange of the completion
         //ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
         ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,DataSize);
         SMB_EXCHANGE_DISPATCH(
                           pExchange,
                           CopyDataHandler,
                           (pExchange,pBuffer,DataSize));
      } else {
          pExchange->Status    = STATUS_CONNECTION_DISCONNECTED;
          pExchange->SmbStatus = STATUS_CONNECTION_DISCONNECTED;
      }

      // Resume the exchange that was waiting for the data.
      SmbCeDecrementPendingCopyDataOperationsAndFinalize(pExchange);
   } else {
      // the exchange was cancelled while the copy was in progress. Free up the buffer
      
      if (pBuffer != NULL) {
          IoFreeMdl(pBuffer);
      }
   }

   return STATUS_SUCCESS;
}

NTSTATUS
SmbCeErrorInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN NTSTATUS              IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
   NTSTATUS                 Status;
   PSMB_EXCHANGE            pExchange;

   DbgPrint("@@@@@@ Error Indication for %lx @@@@@\n",pServerEntry);
   InterlockedIncrement(&MRxSmbStatistics.NetworkErrors);
   // Post to the worker queue to resume all the outstanding requests
   pServerEntry->ServerStatus = IndicatedStatus;
   SmbCeReferenceServerEntry(pServerEntry);
   Status = RxDispatchToWorkerThread(
                  MRxSmbDeviceObject,
                  CriticalWorkQueue,
                  SmbCeResumeAllOutstandingRequestsOnError,
                  pServerEntry);
   if (Status != STATUS_SUCCESS) {
      DbgPrint("Error Indication not dispatched\n");
      RxLog(("SmbCeErrorInd(SE) %lx\n", pServerEntry));
   }

   return STATUS_SUCCESS;
}


NTSTATUS
SmbCeSendCompleteInd(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PVOID                 pCompletionContext,
   IN NTSTATUS              SendCompletionStatus
   )
/*++

Routine Description:

    This routine handles the send complete indication for asynchronous sends

Arguments:

    pServerEntry - the server instance

    pCompletionContext - the context for identifying the send request

    SendCompletionStatus - the send completion status

Return Value:

    STATUS_SUCCESS always ..

--*/
{
   NTSTATUS      Status;

   PSMB_EXCHANGE pExchange;
   PVOID         pSendBuffer = pCompletionContext;

   if (pCompletionContext != NULL) {
      // Map the MID to the associated exchange
      pExchange = SmbCeGetExchangeAssociatedWithBuffer(
                        pServerEntry,
                        pSendBuffer);

      if (pExchange != NULL) {
         // Resume the exchange which was waiting for this response
         RxDbgTrace(0, Dbg, ("SmbCeSendCompleteInd: Send Completion Status %lx\n",SendCompletionStatus));

         if (pExchange->pDispatchVector->SendCompletionHandler != NULL) {
            Status = SMB_EXCHANGE_DISPATCH(pExchange,
                                           SendCompletionHandler,
                                           (pExchange,
                                            pSendBuffer,
                                            SendCompletionStatus));
         }

         RxDbgTrace(0, Dbg, ("SmbCeSendCompleteInd: SMB_EXCHANGE_DISPATCH returned %lx\n",Status));

         SmbCeDecrementPendingSendCompleteOperationsAndFinalize(pExchange);
      }
   }

   return STATUS_SUCCESS;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\stuffer.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    Stuffer.c

Abstract:

    This module implements the SMBstuffer formating primitives. the following controlstring
    characters are defined for the stuffer: (** means nyi...**d means downlevel part not implemented)

      0     placeholder for the wct
      1     pad to word boundary
      X     placeholderfor&X
      W,w   format a word from the next parameter
      D,d   format the next parameter as a Dword
      Y,y   format the next parameter as a byte
      L,l   the next parameter is a PLARGE_INTEGER; format it in
      M,m   format a zero byte
  **  2     the next parameter points to a tagged dialect ASCIZI string to be copied in
  **  3     the next parameter points to a tagged devicename ASCIIZ string
      4     the next parameter is either 04-tagged ASCIIZ or UNICODEZ as determined by flags2
      >     the next parameters is ASCIIZ or UNICODEZ as determined by flags2; it is to be appended
                              to the previous 04-tagged item by backing up over the previous null.
      A,a   the next parameter is an ASCIIZ string
      U,u   the next parameter is a UNICODEZ string
      V,v   the next parameter is a UNICODEnoZ string
      z     the next parameter is a PUNICODE_STRING to be stringed as ASCIZI
            or UNICODEZ as determined by flags2
      N,n   the next parameter is a PNET_ROOT whose name is to be stringed as ASCIIZ
            or UNICODEZ as determined by flags2
      R,r   the next 2 parameters are a PBYTE* and a size; reserve the region and store the pointer
      Q,q   the current position is the data offset WORD...remember it
      5     the current position is the start of the data; fill in the data pointer
      P,p   the current position is the parameter offset WORD...remember it
      6     the current position is the start of the parameters; fill in the param pointer
      B,b   the current position is the Bcc WORD...remember it; also, fill in wct
      s     the next parameter has the alignment information....pad accordingly
      S     pad to DWORD
      c     the next 2 parameters are count/addr...copy in the data.
      !     End of this protocol; fill in the bcc field
      ?     next parameter is BOOLEAN_ULONG; 0=>immediate return
      .     NOOP

    For controls with a upper/lowercase pair, the uppercase version indicates that a position tag
    is supplied in the checked version.

--*/

#include "precomp.h"
#pragma hdrstop
#include <stdio.h>
#include <stdarg.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbMrxInitializeStufferFacilities)
#pragma alloc_text(PAGE, SmbMrxFinalizeStufferFacilities)
#pragma alloc_text(PAGE, MRxSmbSetInitialSMB)
#pragma alloc_text(PAGE, MRxSmbStartSMBCommand)
#pragma alloc_text(PAGE, MrxSMBWillThisFit)
#pragma alloc_text(PAGE, MRxSmbStuffSMB)
#pragma alloc_text(PAGE, MRxSmbStuffAppendRawData)
#pragma alloc_text(PAGE, MRxSmbStuffAppendSmbData)
#pragma alloc_text(PAGE, MRxSmbStuffSetByteCount)
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_ALWAYS)


#define MRXSMB_INITIAL_WCT  (0xcc)
#define MRXSMB_INITIAL_BCC  (0xface)
#define MRXSMB_INITIAL_DATAOFFSET  (0xd0ff)
#define MRXSMB_INITIAL_PARAMOFFSET (0xb0ff)
#define MRXSMB_INITIAL_ANDX (0xdede00ff)


NTSTATUS
SmbMrxInitializeStufferFacilities(
    void
    )
/*++
Routine Description:

     This routine initializes things for the SMB minirdr. we will allocate enough stuff
     to get us going. right now....we do nothing.

Arguments:

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    return(STATUS_SUCCESS);
}

NTSTATUS
SmbMrxFinalizeStufferFacilities(
    void
    )
/*++
Routine Description:

     This routine finalizes things for the SMB minirdr. we give back everything that
     we have allocated. right now....we do nothing.

Arguments:

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    return(STATUS_SUCCESS);
}

#define BUILD_HEADER_ROUTINE SmbCeBuildSmbHeader

NTSTATUS
MRxSmbSetInitialSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    STUFFERTRACE_CONTROLPOINT_ARGS
    )
{
    NTSTATUS       Status;
    PNT_SMB_HEADER NtSmbHeader;
    ULONG          BufferConsumed;
    PBYTE          ScanPosition;
    PUCHAR         pCommand;

    PAGED_CODE();

    ASSERT ( StufferState != NULL );
    ASSERT ( sizeof(NT_SMB_HEADER) == sizeof(SMB_HEADER) );
    //RxDbgTrace(0, Dbg, ("MrxSMBSetInitialSMB  base=%08lx,limit=%08lx\n",
    //                                StufferState->BufferBase,StufferState->BufferLimit));
    ASSERT ( (StufferState->BufferLimit - StufferState->BufferBase) > sizeof(SMB_HEADER));
    NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);
    RtlZeroMemory(NtSmbHeader,sizeof(NT_SMB_HEADER));

    //this stuff is reinitialized
    StufferState->DataMdl = NULL; //note that this is not finalized or anything
    StufferState->DataSize = 0;
    StufferState->CurrentWct = NULL;
    StufferState->PreviousCommand = SMB_COM_NO_ANDX_COMMAND;
    StufferState->CurrentCommand = SMB_COM_NO_ANDX_COMMAND;
    StufferState->FlagsCopy = 0;
    StufferState->Flags2Copy = 0;
    StufferState->CurrentPosition = ((PBYTE)NtSmbHeader);

    Status = BUILD_HEADER_ROUTINE(
                  StufferState->Exchange,
                  NtSmbHeader,
                  (ULONG)(StufferState->BufferLimit - StufferState->BufferBase),
                  &BufferConsumed,
                  &StufferState->PreviousCommand,
                  &pCommand);

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg, ("MrxSMBSetInitialSMB  buildhdr failure st=%08lx\n",Status));
        RxLog(("BuildHdr failed %lx %lx",StufferState->Exchange,Status));
        return Status;
    }

    //copy the flags
    StufferState->FlagsCopy = NtSmbHeader->Flags;
    StufferState->Flags2Copy = SmbGetAlignedUshort(&NtSmbHeader->Flags2);
    if (StufferState->Exchange->Type == ORDINARY_EXCHANGE) {
       PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
       if (BooleanFlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_TURNON_DFS_FLAG)) {
          StufferState->Flags2Copy |= SMB_FLAGS2_DFS;
          SmbPutUshort(&NtSmbHeader->Flags2,(USHORT)StufferState->Flags2Copy);
       }
    }

    StufferState->CurrentPosition += BufferConsumed;

    if (BufferConsumed > sizeof(SMB_HEADER)) {
        if (pCommand != NULL) {
            *pCommand = SMB_COM_NO_ANDX_COMMAND;
        }

        StufferState->CurrentWct = StufferState->CurrentPosition;
    }

    return Status;
}

#define RETURN_A_START_PROBLEM(xxyy) {\
        RxDbgTrace(0,Dbg,("MRxSmbStartSMBCommand gotta problem= %lu\n",xxyy));   \
        StufferState->SpecificProblem = xxyy;       \
        return(STATUS_INVALID_PARAMETER);        \
}
NTSTATUS
MRxSmbStartSMBCommand (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     INITIAL_SMBBUG_DISPOSITION InitialSMBDisposition,
    IN UCHAR Command,
    IN ULONG MaximumBufferUsed,
    IN ULONG MaximumSize,
    IN ULONG InitialAlignment,
    IN ULONG MaximumResponseHeader,
    IN UCHAR Flags,
    IN UCHAR FlagsMask,
    IN USHORT Flags2,
    IN USHORT Flags2Mask
    STUFFERTRACE_CONTROLPOINT_ARGS
    )
/*++

Routine Description:

    The routine checks to see if the condition is stable. If not, it
    goes into a wait loop alternately getting the resource and then
    waiting on the event.


Arguments:
     StufferState - the header buffer being used
     InitialSMBDisposition tells when/if to reinit the stuffer state
     Command - the smb command being set up
     MaximumBufferUsed - the amount of the header buffer that will be used (as opposed to the data)
                         this has to be conjured up in advance. if you're not willing to do this, then
                         just push out the current smb. this value should include any data pads!
     MaximumSize - the size of the data. this is to keep from overrunning the srv's smbbuf
     InitialAlignment - a compound argument (i.e. you get it from a constant) the top half
                        tells the alignment unit and the bottom gives the spacing within
     MaximumResponseHeader - how much of the srv's response buffer this will use up
     Flags - the required flags settings
     FlagsMask - which bits of the flags are important
     Flags2 - the required flags2 settings
     Flags2Mask - which flags2 bits are important

Return Value:

    none.

--*/
{
    UCHAR NewFlags;
    USHORT NewFlags2;
    PBYTE *CurrentPosition = &(StufferState->CurrentPosition);
    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);
    ULONG AlignmentUnit = InitialAlignment >> 16;
    ULONG StufferStateRequirement = MaximumBufferUsed + AlignmentUnit;
#if DBG
    PBYTE OriginalPosition = *CurrentPosition;
#endif

    PAGED_CODE();

    if (StufferState->DataSize) {
        StufferState->SpecificProblem = xSMBbufSTATUS_CANT_COMPOUND;
        return(STATUS_INVALID_PARAMETER);
    }

    if ((InitialSMBDisposition==SetInitialSMB_yyUnconditionally)
        || ((InitialSMBDisposition==SetInitialSMB_ForReuse)&&(StufferState->Started))) {
        MRxSmbSetInitialSMB( StufferState STUFFERTRACE_NOPREFIX(ControlPoint,EnablePrints) );
    }

    StufferState->Started = TRUE;

    switch (StufferState->CurrentCommand) {
    case SMB_COM_LOCKING_ANDX:
    case SMB_COM_OPEN_ANDX:
    case SMB_COM_READ_ANDX:
    case SMB_COM_WRITE_ANDX:
    case SMB_COM_SESSION_SETUP_ANDX:
    //case SMB_COM_LOGOFF_ANDX:
    case SMB_COM_TREE_CONNECT_ANDX:
    case SMB_COM_NT_CREATE_ANDX:
    case SMB_COM_NO_ANDX_COMMAND:
        break;
    default:
        StufferState->SpecificProblem = xSMBbufSTATUS_CANT_COMPOUND;
        return(STATUS_INVALID_PARAMETER);
    }

    if (*CurrentPosition+StufferStateRequirement >= StufferState->BufferLimit ) {
        StufferState->SpecificProblem = xSMBbufSTATUS_CANT_COMPOUND;
        return(STATUS_INVALID_PARAMETER);
    }

    if (StufferState->RxContext) {
        PRX_CONTEXT RxContext = StufferState->RxContext;
        PMRX_SRV_CALL SrvCall;
        ULONG CurrentOffset;
        if (RxContext->MajorFunction != IRP_MJ_CREATE) {
            SrvCall = RxContext->pFcb->pNetRoot->pSrvCall;
        } else {
            SrvCall = RxContext->Create.pSrvCall;
        }
        ASSERT(SrvCall);
        CurrentOffset = (ULONG)(*CurrentPosition - StufferState->BufferBase);
        if (CurrentOffset+StufferStateRequirement+MaximumSize
                    > GetServerMaximumBufferSize(SrvCall) ) {
            StufferState->SpecificProblem = xSMBbufSTATUS_SERVER_OVERRUN;
            return(STATUS_INVALID_PARAMETER);
        }
    }

    NewFlags = Flags | (UCHAR)(StufferState->FlagsCopy);
    NewFlags2 = Flags2 | (USHORT)(StufferState->Flags2Copy);
    if ( ((NewFlags&FlagsMask)!=Flags) ||
         ((NewFlags2&Flags2Mask)!=Flags2) ) {
        StufferState->SpecificProblem = xSMBbufSTATUS_FLAGS_CONFLICT;
        return(STATUS_INVALID_PARAMETER);
    }
    StufferState->FlagsCopy = NtSmbHeader->Flags = NewFlags;
    StufferState->Flags2Copy = NewFlags2;
    SmbPutAlignedUshort(&NtSmbHeader->Flags2, NewFlags2);

    if (!StufferState->CurrentWct) {
        NtSmbHeader->Command = Command;
    } else {
        PGENERIC_ANDX GenericAndX = (PGENERIC_ANDX)StufferState->CurrentWct;
        if (AlignmentUnit) {
            ULONG AlignmentMask = (AlignmentUnit-1);
            ULONG AlignmentResidue = InitialAlignment&AlignmentMask;
            RxDbgTrace(0, Dbg, ("Aligning start of smb cp&m,m,r=%08lx %08lx %08lx\n",
                                 ((ULONG_PTR)(*CurrentPosition))&AlignmentMask,
                                 AlignmentMask, AlignmentResidue)
                       );
            for (;(((ULONG_PTR)(*CurrentPosition))&AlignmentMask)!=AlignmentResidue;) {
                **CurrentPosition = ',';
                *CurrentPosition += 1;
            }
        }
        GenericAndX->AndXCommand = Command;
        GenericAndX->AndXReserved = 0;
        SmbPutUshort (&GenericAndX->AndXOffset,
                      (USHORT)(*CurrentPosition - StufferState->BufferBase));
    }
    StufferState->CurrentWct = *CurrentPosition;
    StufferState->CurrentCommand = Command;
    StufferState->CurrentDataOffset = 0;
    return STATUS_SUCCESS;
}

BOOLEAN
MrxSMBWillThisFit(
    IN PSMBSTUFFER_BUFFER_STATE StufferState,
    IN ULONG AlignmentUnit,
    IN ULONG DataSize
    )
{
    return(StufferState->CurrentPosition+AlignmentUnit+DataSize<StufferState->BufferLimit);
}

#if RDBSSTRACE
#define StufferFLoopTrace(Z) { if (StufferState->PrintFLoop) {RxDbgTraceLV__norx(0,StufferState->ControlPoint,900,Z);}}
#define StufferCLoopTrace(Z) { if (StufferState->PrintCLoop) {RxDbgTraceLV__norx(0,StufferState->ControlPoint,800,Z);}}
#else // DBG
#define StufferFLoopTrace(Z)
#define StufferCLoopTrace(Z)
#endif // DBG

NTSTATUS
MRxSmbStuffSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    ...
    )
{
    va_list AP;
    PBYTE BufferBase = (StufferState->BufferBase);
    PBYTE *CurrentPosition = &(StufferState->CurrentPosition);
    PBYTE *CurrentWct = &(StufferState->CurrentWct);
    PBYTE *CurrentBcc = &(StufferState->CurrentBcc);
    PBYTE *CurrentDataOffset = &(StufferState->CurrentDataOffset);
    PBYTE *CurrentParamOffset = &(StufferState->CurrentParamOffset);
    SMB_STUFFER_CONTROLS CurrentStufferControl = STUFFER_CTL_NORMAL;
    PSMB_HEADER SmbHeader = (PSMB_HEADER)BufferBase;
    PSZ CurrentFormatString = NULL;
    ULONG arg;
    UCHAR WordCount;
    USHORT ByteCount;
#define PADBYTE ((UCHAR)0xee)
    PBYTE CopyPtr; ULONG CopyCount,EarlyReturn;
    PBYTE *RegionPtr;
    PUNICODE_STRING Zstring;
    PSZ Astring;
    PNET_ROOT NetRoot;
    PLARGE_INTEGER LargeInteger;
    PBYTE PreviousPosition;
#if DBG
    ULONG offset, required_WCT;
    ULONG CurrentOffset_tmp;
#endif

    PAGED_CODE();

    va_start(AP,StufferState);
    for (;;) {
        switch (CurrentStufferControl) {
        case STUFFER_CTL_SKIP:
        case STUFFER_CTL_NORMAL:
            CurrentFormatString = va_arg(AP,PSZ);
            StufferCLoopTrace(("StufferAC = %s\n",CurrentFormatString));
            ASSERT (CurrentFormatString);
            for (;*CurrentFormatString;CurrentFormatString++) {
                char CurrentFormatChar = *CurrentFormatString;
#if DBG
                { char msgbuf[80];
                switch (CurrentFormatChar) {
                case 'W': case 'w':
                case 'D': case 'd':
                case 'Y': case 'y':
                case 'M': case 'm':
                case 'L': case 'l':
                case 'c': case '4': case '>':
                case '!':
                    //this guys are skipable
                    break;
                default:
                    if (CurrentStufferControl != STUFFER_CTL_SKIP) break;
                    DbgPrint("Bad skip char '%c'\n",*CurrentFormatString);
                    DbgBreakPoint();
                }}
                //these are the ones that we do the offset check for
                { char msgbuf[80];
#ifndef WIN9X
                RxSprintf(msgbuf,"control char '%c'\n",*CurrentFormatString);
#endif
                switch (CurrentFormatChar) {
                case 'W': case 'D': case 'Y': case 'M': case 'B':
                case 'Q': case 'A': case 'U': case 'V':
                case 'N':
                case 'L':
                case 'R':
                case 'P':
                    offset = va_arg(AP,ULONG);
                    required_WCT = offset>>16;
                    offset = offset & 0xffff;
                    CurrentOffset_tmp = (ULONG)(*CurrentPosition-*CurrentWct);
                    if (offset && (offset != CurrentOffset_tmp)){
                        DbgPrint("Bad offset %d; should be %d\n",offset,CurrentOffset_tmp);
                        DbgBreakPoint();
                    }
                    break;
                default:
                    break;
                }}
#endif
                switch (CurrentFormatChar) {
                case '0':
                    StufferFLoopTrace(("  StufferFloop '0'\n",0));
                    //just do the wct field...
                    **CurrentPosition = (UCHAR)MRXSMB_INITIAL_WCT;
                    *CurrentPosition+=1;
                    break;
                case 'X':
                    StufferFLoopTrace(("  StufferFloop 'X'\n",0));
                    //do the wct field and the &x
                    **CurrentPosition = (UCHAR)MRXSMB_INITIAL_WCT;
                    *CurrentPosition+=1;
                    SmbPutUlong (*CurrentPosition, (ULONG)MRXSMB_INITIAL_ANDX);
                    *CurrentPosition+=sizeof(ULONG);
                    break;
                case 'W':
                case 'w':
                    arg = va_arg(AP,ULONG);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'w' arg=%lu\n",arg));
                    SmbPutUshort (*CurrentPosition, (USHORT)arg);
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case 'Y':
                case 'y':
                    arg = va_arg(AP,UCHAR);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'y' arg=%lu\n",arg));
                    **CurrentPosition =  (UCHAR)arg;
                    *CurrentPosition+=sizeof(UCHAR);
                    break;
                case 'M':
                case 'm':
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'm'\n",0));
                    **CurrentPosition =  0;
                    *CurrentPosition+=sizeof(UCHAR);
                    break;
                case 'D':
                case 'd':
                    arg = va_arg(AP,ULONG);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'd' arg=%lu\n",arg));
                    SmbPutUlong (*CurrentPosition, arg);
                    *CurrentPosition+=sizeof(ULONG);
                    break;
                case 'L':
                case 'l':
                    LargeInteger = va_arg(AP,PLARGE_INTEGER);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'l' arg=%0lx %0lx\n",
                            LargeInteger->HighPart, LargeInteger->LowPart));
                    SmbPutUlong (*CurrentPosition, LargeInteger->LowPart);
                    SmbPutUlong (*CurrentPosition, LargeInteger->HighPart);
                    *CurrentPosition+=2*sizeof(ULONG);
                    break;
                case 'B':
                case 'b':
                    ASSERT (**CurrentWct == MRXSMB_INITIAL_WCT);
                    WordCount = (UCHAR)((*CurrentPosition-*CurrentWct)>>1); //the one gets shifted off
                    StufferFLoopTrace(("  StufferFloop 'b' Wct=%lu\n",WordCount));
                    DbgDoit( ASSERT(!required_WCT || (WordCount == (required_WCT&0x7fff)));  )
                    **CurrentWct = (UCHAR)WordCount;
                    SmbPutUshort (*CurrentPosition, (USHORT)MRXSMB_INITIAL_BCC);
                    *CurrentBcc = *CurrentPosition;
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case 'Q':
                case 'q':
                    StufferFLoopTrace(("  StufferFloop 'q' \n",0));
                    SmbPutUshort (*CurrentPosition, (USHORT)MRXSMB_INITIAL_DATAOFFSET);
                    *CurrentDataOffset = *CurrentPosition;
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case '5':
                    //fill in the data offset
                    ASSERT (SmbGetUshort (*CurrentDataOffset) == MRXSMB_INITIAL_DATAOFFSET);
                    ByteCount = (USHORT)(*CurrentPosition-BufferBase);
                    StufferFLoopTrace(("  StufferFloop '5' offset=%lu\n",ByteCount));
                    SmbPutUshort (*CurrentDataOffset, (USHORT)ByteCount);
                    break;
                case 'P':
                case 'p':
                    StufferFLoopTrace(("  StufferFloop 'p' \n",0));
                    SmbPutUshort (*CurrentPosition, (USHORT)MRXSMB_INITIAL_PARAMOFFSET);
                    *CurrentParamOffset = *CurrentPosition;
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case '6':
                    //fill in the data offset
                    ASSERT (SmbGetUshort (*CurrentParamOffset) == MRXSMB_INITIAL_PARAMOFFSET);
                    ByteCount = (USHORT)(*CurrentPosition-BufferBase);
                    StufferFLoopTrace(("  StufferFloop '6' offset=%lu\n",ByteCount));
                    SmbPutUshort (*CurrentParamOffset, (USHORT)ByteCount);
                    break;
                case 'S':
                    // pad to ULONG; we loop behind instead of adding so we can clear
                    // out behind ourselves; apparently, some server croak on nonzero padding
                    StufferFLoopTrace(("  StufferFloop 'S' \n",0));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition = (PBYTE)QuadAlignPtr(*CurrentPosition);
                    for (;PreviousPosition!=*CurrentPosition;) {
                        //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = PADBYTE;
                    }
                    break;
                case 's':
                    // pad to arg; we loop behind instead of adding so we can clear
                    // out behind ourselves; apparently, some server croak on nonzero padding
                    arg = va_arg(AP,ULONG);
                    StufferFLoopTrace(("  StufferFloop 's' arg=\n",arg));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += arg-1;
                    *CurrentPosition = (PBYTE)( ((ULONG_PTR)(*CurrentPosition)) & ~((LONG)(arg-1)) );
                    for (;PreviousPosition!=*CurrentPosition;) {
                        //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = PADBYTE;
                    }
                    break;
                case '1':
                    // pad to USHORT; we loop behind instead of adding so we can clear
                    // out behind ourselves; apparently, some server croak on nonzero padding
                    StufferFLoopTrace(("  StufferFloop '1' Curr=%08lx \n",*CurrentPosition));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += sizeof(USHORT)-1;
                    StufferFLoopTrace(("                   Curr=%08lx \n",*CurrentPosition));
                    *CurrentPosition = (PBYTE)( ((ULONG_PTR)(*CurrentPosition)) & ~((LONG)(sizeof(USHORT)-1)) );
                    StufferFLoopTrace(("                   Curr=%08lx \n",*CurrentPosition));
                    for (;PreviousPosition!=*CurrentPosition;) {
                        StufferFLoopTrace(("      StufferFloop '1' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = PADBYTE;
                    }
                    break;
                case 'c':
                    // copy in the bytes....used a lot in transact
                    CopyCount = va_arg(AP,ULONG);
                    CopyPtr = va_arg(AP,PBYTE);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'c' copycount = %lu\n", CopyCount));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += CopyCount;
                    for (;PreviousPosition!=*CurrentPosition;) {
                        //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = *CopyPtr++;
                    }
                    break;
                case 'R':
                case 'r':
                    // copy in the bytes....used a lot in transact
                    RegionPtr = va_arg(AP,PBYTE*);
                    CopyCount = va_arg(AP,ULONG);
                    StufferFLoopTrace(("  StufferFloop 'r' regionsize = %lu\n", CopyCount));
                    *RegionPtr = *CurrentPosition;
                    *CurrentPosition += CopyCount;
                    IF_DEBUG {
                        PreviousPosition = *RegionPtr;
                        for (;PreviousPosition!=*CurrentPosition;) {
                            //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                            *PreviousPosition++ = '-';
                        }
                    }
                    break;
                case 'A':
                case 'a':
                    //copy byte from an asciiz including the trailing NULL
                    Astring = va_arg(AP,PSZ);
                    StufferFLoopTrace(("  StufferFloop 'a' stringing = %s\n", Astring));
                    CopyCount = strlen(Astring)+1;
                    //if (((ULONG)(*CurrentPosition))&1) {
                    //    StufferFLoopTrace(("  StufferFloop 'a' aligning\n", 0));
                    //    *CurrentPosition+=1;
                    //}
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += CopyCount;
                    if (*CurrentPosition >= StufferState->BufferLimit) {
                        StufferFLoopTrace(("  StufferFloop 'a' bufferoverrun\n", 0));
                        ASSERT(!"BufferOverrun");
                        return(STATUS_BUFFER_OVERFLOW);
                    }
                    RtlCopyMemory(PreviousPosition,Astring,CopyCount);
                    break;
                case 'z':
                case '4':
                case '>':
                    Zstring = va_arg(AP,PUNICODE_STRING);
                    StufferFLoopTrace(("  StufferFloop '4/z/>' stringing = %wZ, cp=\n", Zstring,*CurrentPosition ));
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    if (CurrentFormatChar=='4') {
                        //first lay down a x'04' and then copy either a asciiz or a unicodez depending on the flags setting
                        **CurrentPosition = (UCHAR)4; //ascii marker
                        *CurrentPosition+=1;
                    } else if (CurrentFormatChar=='>'){
                        //back up over the previous NULL
                        
                        *CurrentPosition-=(FlagOn(SmbHeader->Flags2,SMB_FLAGS2_UNICODE)?sizeof(WCHAR):sizeof(char));
                        StufferFLoopTrace(("  StufferFloop '4/z/>' afterroolback, cp=\n", *CurrentPosition ));
                    }
                    if (FlagOn(SmbHeader->Flags2,SMB_FLAGS2_UNICODE)){

                        if (((ULONG_PTR)(*CurrentPosition))&1) {
                            StufferFLoopTrace(("  StufferFloop '4/z/>' aligning\n", 0));
                            *CurrentPosition+=1;
                        }
                        PreviousPosition = *CurrentPosition;
                        *CurrentPosition += (Zstring->Length + sizeof(WCHAR));
                        if (*CurrentPosition >= StufferState->BufferLimit) {
                            StufferFLoopTrace(("  StufferFloop '4/z/>' bufferoverrun\n", 0));
                            ASSERT(!"BufferOverrun");
                            return(STATUS_BUFFER_OVERFLOW);
                        }
                        RtlCopyMemory(PreviousPosition,Zstring->Buffer,Zstring->Length);
                        *(((PWCHAR)(*CurrentPosition))-1) = 0;

                    } else {

                        NTSTATUS Status;
                        OEM_STRING OemString;

                        OemString.Length =
                             OemString.MaximumLength =
                                 (USHORT)( StufferState->BufferLimit - *CurrentPosition  - sizeof(CHAR));
                        OemString.Buffer = *CurrentPosition;

                        if (FlagOn(SmbHeader->Flags,SMB_FLAGS_CASE_INSENSITIVE) &&
                            !FlagOn(SmbHeader->Flags2,SMB_FLAGS2_KNOWS_LONG_NAMES)) {
                            Status = RtlUpcaseUnicodeStringToOemString(
                                             &OemString,
                                             Zstring,
                                             FALSE);
                        } else {
                            Status = RtlUnicodeStringToOemString(
                                             &OemString,
                                             Zstring,
                                             FALSE);
                        }

                        if (!NT_SUCCESS(Status)) {
                            StufferFLoopTrace(("  StufferFloop '4/z/>' bufferoverrun(ascii)\n", 0));
                            ASSERT(!"BufferOverrun");
                            return(STATUS_BUFFER_OVERFLOW);
                        }

                        *CurrentPosition += OemString.Length + 1;
                        *(*CurrentPosition-1) = 0;

                    }
                    break;
                case 'U':
                case 'u':
                    //copy bytes from an UNICODE string including a trailing NULL
                    Zstring = va_arg(AP,PUNICODE_STRING);
                    StufferFLoopTrace(("  StufferFloop 'u' stringing = %wZ\n", Zstring));
                    if (((ULONG_PTR)(*CurrentPosition))&1) {
                        StufferFLoopTrace(("  StufferFloop 'u' aligning\n", 0));
                        *CurrentPosition+=1;
                    }
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += (Zstring->Length + sizeof(WCHAR));
                    if (*CurrentPosition >= StufferState->BufferLimit) {
                        StufferFLoopTrace(("  StufferFloop 'u' bufferoverrun\n", 0));
                        return(STATUS_BUFFER_OVERFLOW);
                    }
                    RtlCopyMemory(PreviousPosition,Zstring->Buffer,Zstring->Length);
                    *(((PWCHAR)(*CurrentPosition))-1) = 0;
                    break;
                case 'V':
                case 'v':
                    //copy bytes from an UNICODE string no trailing NUL
                    Zstring = va_arg(AP,PUNICODE_STRING);
                    StufferFLoopTrace(("  StufferFloop 'v' stringing = %wZ\n", Zstring));
                    if (((ULONG_PTR)(*CurrentPosition))&1) {
                        StufferFLoopTrace(("  StufferFloop 'v' aligning\n", 0));
                        *CurrentPosition+=1;
                    }
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += Zstring->Length;
                    if (*CurrentPosition >= StufferState->BufferLimit) {
                        StufferFLoopTrace(("  StufferFloop 'v' bufferoverrun\n", 0));
                        ASSERT(!"BufferOverrun");
                        return(STATUS_BUFFER_OVERFLOW);
                    }
                    RtlCopyMemory(PreviousPosition,Zstring->Buffer,Zstring->Length);
                    break;
                case 'N':
                case 'n':
                    //copy bytes from a NetRoot name....w null
                    NetRoot = va_arg(AP,PNET_ROOT);
                    ASSERT(NodeType(NetRoot)==RDBSS_NTC_NETROOT);
                    Zstring = &NetRoot->PrefixEntry.Prefix;
                    StufferFLoopTrace(("  StufferFloop 'n' stringing = %wZ\n", Zstring));
                    if (StufferState->Flags2Copy&SMB_FLAGS2_UNICODE) {
                        if (((ULONG_PTR)(*CurrentPosition))&1) {
                            StufferFLoopTrace(("  StufferFloop 'n' aligning\n", 0));
                            *CurrentPosition+=1;
                        }
                        PreviousPosition = *CurrentPosition;
                        *CurrentPosition += (Zstring->Length + 2 * sizeof(WCHAR));  //extra \ plus a nul
                        if (*CurrentPosition >= StufferState->BufferLimit) {
                            StufferFLoopTrace(("  StufferFloop 'n' bufferoverrun\n", 0));
                            ASSERT(!"BufferOverrun");
                            return(STATUS_BUFFER_OVERFLOW);
                        }
                        *((PWCHAR)PreviousPosition) = '\\';
                        RtlCopyMemory(PreviousPosition+sizeof(WCHAR),Zstring->Buffer,Zstring->Length);
                        *(((PWCHAR)(*CurrentPosition))-1) = 0;
                    }
                    break;
                case '?':
                    //early out....used in transact to do the setup
                    EarlyReturn = va_arg(AP,ULONG);
                    StufferFLoopTrace(("  StufferFloop '?' out if 0==%08lx\n",EarlyReturn));
                    if (EarlyReturn==0) return STATUS_SUCCESS;
                    break;
                case '.':
                    //noop...used to reenter without a real formatting string
                    StufferFLoopTrace(("  StufferFloop '.'\n",0));
                    break;
                case '!':
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    ASSERT (SmbGetUshort (*CurrentBcc) == MRXSMB_INITIAL_BCC);
                    ByteCount = (USHORT)(*CurrentPosition-*CurrentBcc-sizeof(USHORT));
                    StufferFLoopTrace(("  StufferFloop '!' arg=%lu\n",ByteCount));
                    SmbPutUshort (*CurrentBcc, (USHORT)ByteCount);
                    return STATUS_SUCCESS;
                default:
                    StufferFLoopTrace(("  StufferFloop '%c' BADBADBAD\n",*CurrentFormatString));
                    ASSERT(!"Illegal Controlstring character\n");
                } //switch
            }//for
            break;
        case 0:
            return STATUS_SUCCESS;
        default:
            StufferCLoopTrace(("  StufferCloop %u BADBADBAD\n",CurrentStufferControl));
            ASSERT(!"IllegalStufferControl\n");
        }//switch

        CurrentStufferControl = va_arg(AP,SMB_STUFFER_CONTROLS);
        StufferCLoopTrace(("  StufferCloop NewStufferControl=%u \n",CurrentStufferControl));

    } //for

    return STATUS_SUCCESS;
}

VOID
MRxSmbStuffAppendRawData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    )
{
    PMDL pMdl;

    PAGED_CODE();

    ASSERT(!StufferState->DataMdl);
    pMdl = StufferState->DataMdl = Mdl;
    StufferState->DataSize = 0;

    while (pMdl != NULL) {
        StufferState->DataSize += pMdl->ByteCount;
        pMdl = pMdl->Next;
    }

    return;
}

VOID
MRxSmbStuffAppendSmbData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    )
{
    ULONG Offset;

    PAGED_CODE();

    ASSERT(!StufferState->DataMdl);
    StufferState->DataMdl = Mdl;
    StufferState->DataSize = Mdl->ByteCount;
    //now reach back into the buffer and set the SMB data offset; if it is already set...just get out
    if (SmbGetUshort (StufferState->CurrentDataOffset) == MRXSMB_INITIAL_DATAOFFSET){
        Offset = (ULONG)(StufferState->CurrentPosition - StufferState->BufferBase);
        RxDbgTrace(0, Dbg,("MRxSmbStuffAppendSmbData offset=%lu\n",Offset));
        SmbPutUshort (StufferState->CurrentDataOffset, (USHORT)Offset);
    }
    return;
}

VOID
MRxSmbStuffSetByteCount(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    )
{
    ULONG ByteCount;

    PAGED_CODE();

    ASSERT (SmbGetUshort (StufferState->CurrentBcc) == MRXSMB_INITIAL_BCC);
    ByteCount = (ULONG)(StufferState->CurrentPosition
                        - StufferState->CurrentBcc
                        - sizeof(USHORT)
                        + StufferState->DataSize);
    RxDbgTrace(0, Dbg,("MRxSmbStuffSetByteCount ByteCount=%lu\n",ByteCount));
    SmbPutUshort (StufferState->CurrentBcc, (USHORT)ByteCount);
    return;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\stuffer.h ===
/*++

Copyright (c) 1991 - 1999  Microsoft Corporation

Module Name:

    Stuffer.h

Abstract:

    Prototypes for the SMBstuffer formating primitives

--*/

#ifndef _SMBSTUFFER_INCLUDED_
#define _SMBSTUFFER_INCLUDED_

IMPORTANT_STRUCTURE(SMBSTUFFER_BUFFER_STATE);

#define COVERED_CALL(x) {\
    Status = x;                         \
    if (Status != STATUS_SUCCESS) {  \
        RxDbgTrace(0, Dbg,("nonSUCCESS covered status = %lx\n",Status));    \
        goto FINALLY;                   \
    }                                   \
    ASSERT (StufferState->SpecificProblem == 0); \
}

#define MRXSMB_PROCESS_ID_ZERO (MRXSMB_PROCESS_ID - 1)
#define MRXSMB_MULTIPLX_ID_ZERO (0xdead)
#define MRXSMB_USER_ID_ZERO ((USHORT)'jj')
#define MRXSMB_TREE_ID_ZERO (0xbaba)

#define GetServerMaximumBufferSize(SRVCALL) 4356

#define SMB_REQUEST_SIZE(___x) (FIELD_OFFSET(REQ_##___x,Buffer[0]))
#if DBG
#define SMB_OFFSET_CHECK(___x,___y) (FIELD_OFFSET(REQ_##___x,___y)),
#define SMB_WCTBCC_CHECK(___x,___y) ( ((0x8000|(___z))<<16)+(FIELD_OFFSET(REQ_##___x,ByteCount)) ),
#define SMB_WCT_CHECK(___z) ((0x8000|(___z))<<16),
#else
#define SMB_OFFSET_CHECK(___x,___y)
#define SMB_WCTBCC_CHECK(___x,___y,___z)
#define SMB_WCT_CHECK(___z)
#endif

typedef enum _SMBbuf_STATUS_DETAIL {
    xSMBbufSTATUS_OK,
    xSMBbufSTATUS_CANT_COMPOUND,
    xSMBbufSTATUS_HEADER_OVERRUN,
    xSMBbufSTATUS_BUFFER_OVERRUN,
    xSMBbufSTATUS_SERVER_OVERRUN,
    xSMBbufSTATUS_FLAGS_CONFLICT,
    xSMBbufSTATUS_MAXIMUM
} SMBbuf_STATUS_DETAIL;

//#define STUFFER_STATE_SIGNATURE ('fftS')
typedef struct _SMBSTUFFER_BUFFER_STATE {
    NODE_TYPE_CODE        NodeTypeCode;     // node type.
    NODE_BYTE_SIZE        NodeByteSize;     // node size.
    // this stuff is fixed
    PMDL HeaderMdl;
    PMDL HeaderPartialMdl; //used for breaking up writes to avoid reallocation
    PBYTE ActualBufferBase;
    PBYTE BufferBase;
    PBYTE BufferLimit;
    //this stuff is reinitialized
    PRX_CONTEXT RxContext;
    PSMB_EXCHANGE Exchange;
    PMDL DataMdl;
    ULONG DataSize;
    //PRXCE_DATA_BUFFER FinalMdl; //for later with no chain-send rule
    PBYTE CurrentPosition;
    PBYTE CurrentWct;
    PBYTE CurrentBcc;
    PBYTE CurrentDataOffset;
    PBYTE CurrentParamOffset;
    UCHAR  PreviousCommand;
    UCHAR  CurrentCommand;
    UCHAR  SpecificProblem;  //SMBbuf_STATUS_DETAIL this is set to pass back what happened
    BOOLEAN Started;
    ULONG FlagsCopy;
    ULONG Flags2Copy;
    //ULONG FlagsMask;
    //ULONG Flags2Mask;
#if DBG
    ULONG Signature;
    PDEBUG_TRACE_CONTROLPOINT ControlPoint;
    BOOLEAN PrintFLoop;
    BOOLEAN PrintCLoop;
#endif
} SMBSTUFFER_BUFFER_STATE;


typedef enum _SMB_STUFFER_CONTROLS {
    STUFFER_CTL_NORMAL=1,
    STUFFER_CTL_SKIP, // only w,d,b can be in a skip string
    STUFFER_CTL_NOBYTES,
    STUFFER_CTL_ENDOFARGUMENTS,
    STUFFER_CTL_MAXIMUM
} SMB_STUFFER_CONTROLS;

#define StufferCondition(___c) ((___c)?STUFFER_CTL_NORMAL:STUFFER_CTL_SKIP)


NTSTATUS
SmbMrxInitializeStufferFacilities(
    void
    );

NTSTATUS
SmbMrxFinalizeStufferFacilities(
    void
    );

#ifdef RDBSSTRACE

#define STUFFERTRACE(CONTROLPOINT,__b__) ,(&RxDTPrefixRx CONTROLPOINT),(__b__)
#define STUFFERTRACE_NOPREFIX(CONTROLPOINT,__b__) ,(CONTROLPOINT),(__b__)
#define STUFFERTRACE_CONTROLPOINT_ARGS \
    ,IN PDEBUG_TRACE_CONTROLPOINT ControlPoint,IN ULONG EnablePrints

#else

#define STUFFERTRACE(__a__,__b__)
#define STUFFERTRACE_NOPREFIX(__a__,__b__)
#define STUFFERTRACE_CONTROLPOINT_ARGS

#endif

NTSTATUS
MRxSmbSetInitialSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    STUFFERTRACE_CONTROLPOINT_ARGS
    );

#define NO_EXTRA_DATA 0
#define SMB_BEST_ALIGNMENT(__x,__y) ((__x<<16)|__y)
#define NO_SPECIAL_ALIGNMENT 0
#define RESPONSE_HEADER_SIZE_NOT_SPECIFIED 0

typedef enum _INITIAL_SMBBUF_DISPOSITION {
    SetInitialSMB_yyUnconditionally,  //no one should be using this right now!
    SetInitialSMB_ForReuse,
    SetInitialSMB_Never
} INITIAL_SMBBUG_DISPOSITION;

NTSTATUS
MRxSmbStartSMBCommand (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     INITIAL_SMBBUG_DISPOSITION InitialSMBDisposition,
    IN UCHAR Command,
    IN ULONG MaximumBufferUsed,
    IN ULONG MaximumSize,
    IN ULONG InitialAlignment,
    IN ULONG MaximumResponseHeader,
    IN UCHAR Flags,
    IN UCHAR FlagsMask,
    IN USHORT Flags2,
    IN USHORT Flags2Mask
    STUFFERTRACE_CONTROLPOINT_ARGS
    );

NTSTATUS
MRxSmbStuffSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    ...
    );

VOID
MRxSmbStuffAppendRawData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    );

VOID
MRxSmbStuffAppendSmbData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    );

VOID
MRxSmbStuffSetByteCount(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    );

BOOLEAN
MrxSMBWillThisFit(
    IN PSMBSTUFFER_BUFFER_STATE StufferState,
    IN ULONG AlignmentUnit,
    IN ULONG DataSize
    );

#define MRxSmbDumpStufferState(a,b,c)

#endif   // ifndef _SMBSTUFFER_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\srvcall.c ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    srvcall.c

Abstract:

    This module implements the routines for handling the creation/manipulation of
    server entries in the connection engine database. It also contains the routines
    for parsing the negotiate response from  the server.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeCreateSrvCall)
#pragma alloc_text(PAGE, MRxSmbCreateSrvCall)
#pragma alloc_text(PAGE, MRxSmbFinalizeSrvCall)
#pragma alloc_text(PAGE, MRxSmbSrvCallWinnerNotify)
#pragma alloc_text(PAGE, MRxSmbInitializeEchoProbeService)
#pragma alloc_text(PAGE, MRxSmbTearDownEchoProbeService)
#pragma alloc_text(PAGE, BuildNegotiateSmb)
#endif

RXDT_DefineCategory(SRVCALL);
#define Dbg        (DEBUG_TRACE_SRVCALL)

VOID
SmbCeCreateSrvCall(
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the information required
   by the mini redirector.

Arguments:

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure;
    PMRX_SRV_CALL pSrvCall;

    PAGED_CODE();

    SrvCalldownStructure =
        (PMRX_SRVCALLDOWN_STRUCTURE)(pCallbackContext->SrvCalldownStructure);

    pSrvCall = SrvCalldownStructure->SrvCall;

    ASSERT( pSrvCall );
    ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

    SmbCeInitializeServerEntry(
        pSrvCall,
        pCallbackContext,
        SrvCalldownStructure->RxContext->Create.TreeConnectOpenDeferred);
}


NTSTATUS
MRxSmbCreateSrvCall(
    PMRX_SRV_CALL                  pSrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the information required
   by the mini redirector.

Arguments:

    RxContext        - Supplies the context of the original create/ioctl

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Certain transport related interfaces require handle to be passed in. This
    implies that the SRV_CALL instances need to be initialized in the context
    of a well known process, i.e., the RDBSS process.

    In the normal course of event is this request was issued within the context
    of the system process we should continue without having to post. However
    there are cases in MIPS  when stack overflows. In order to avoid such situations
    the request is posted in all cases.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING ServerName;

    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = pCallbackContext;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(pCallbackContext->SrvCalldownStructure);

    PAGED_CODE();

    ASSERT( pSrvCall );
    ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

    // Dispatch the request to a system thread.
    Status = RxDispatchToWorkerThread(
                 MRxSmbDeviceObject,
                 DelayedWorkQueue,
                 SmbCeCreateSrvCall,
                 pCallbackContext);

    if (Status == STATUS_SUCCESS) {
        // Map the return value since the wrapper expects PENDING.
        Status = STATUS_PENDING;
    } else {
        // There was an error in dispatching the SmbCeCreateSrvCall method to
        // a worker thread. Complete the request and return STATUS_PENDING.

        SCCBC->Status = Status;
        SrvCalldownStructure->CallBack(SCCBC);
        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
MRxSmbFinalizeSrvCall(
    PMRX_SRV_CALL pSrvCall,
    BOOLEAN       Force)
/*++

Routine Description:

   This routine destroys a given server call instance

Arguments:

    pSrvCall  - the server call instance to be disconnected.

    Force     - TRUE if a disconnection is to be enforced immediately.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS              Status = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    // if the server entry is not filled in, then there's nothing to do. this occurs
    // on a srvcall that we never successfuly hooked up to........
    if (pSrvCall->Context == NULL) {
        return(Status);
    }


    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    if (pServerEntry != NULL) {
        InterlockedCompareExchangePointer(
            &pServerEntry->pRdbssSrvCall,
            NULL,
            pSrvCall);
        SmbCeDereferenceServerEntry(pServerEntry);
    }

    pSrvCall->Context = NULL;

    return Status;
}

NTSTATUS
MRxSmbSrvCallWinnerNotify(
    IN PMRX_SRV_CALL  pSrvCall,
    IN BOOLEAN        ThisMinirdrIsTheWinner,
    IN OUT PVOID      pSrvCallContext)
/*++

Routine Description:

   This routine finalizes the mini rdr context associated with an RDBSS Server call instance

Arguments:

    pSrvCall               - the Server Call

    ThisMinirdrIsTheWinner - TRUE if this mini rdr is the choosen one.

    pSrvCallContext  - the server call context created by the mini redirector.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The two phase construction protocol for Server calls is required because of parallel
    initiation of a number of mini redirectors. The RDBSS finalizes the particular mini
    redirector to be used in communicating with a given server based on quality of
    service criterion.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pServerEntry = (PSMBCEDB_SERVER_ENTRY)pSrvCallContext;

    if (!ThisMinirdrIsTheWinner) {

        //
        // Some other mini rdr has been choosen to connect to the server. Destroy
        // the data structures created for this mini redirector.
        //
        SmbCeUpdateServerEntryState(pServerEntry,SMBCEDB_MARKED_FOR_DELETION);
        SmbCeDereferenceServerEntry(pServerEntry);
        return STATUS_SUCCESS;
    }

    pSrvCall->Context  = pServerEntry;

    pSrvCall->Flags   |= SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS |
                         SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES;

    pSrvCall->MaximumNumberOfCloseDelayedFiles = MRxSmbConfiguration.DormantFileLimit + 1;
    pServerEntry->Server.IsLoopBack = FALSE;

    return STATUS_SUCCESS;
}

//
// The following type defines and data structures are used for parsing negotiate SMB
// responses.
//


typedef enum _SMB_NEGOTIATE_TYPE_ {
    SMB_CORE_NEGOTIATE,
    SMB_EXTENDED_NEGOTIATE,
    SMB_NT_NEGOTIATE
} SMB_NEGOTIATE_TYPE, *PSMB_NEGOTIATE_TYPE;

typedef struct _SMB_DIALECTS_ {
    SMB_NEGOTIATE_TYPE   NegotiateType;
    USHORT               DispatchVectorIndex;
} SMB_DIALECTS, *PSMB_DIALECTS;

SMBCE_SERVER_DISPATCH_VECTOR
s_SmbServerDispatchVectors[] = {
    {BuildSessionSetupSmb,CoreBuildTreeConnectSmb},
    {BuildSessionSetupSmb,LmBuildTreeConnectSmb},
    {BuildSessionSetupSmb,NtBuildTreeConnectSmb},
    };

SMB_DIALECTS
s_SmbDialects[] = {
    { SMB_CORE_NEGOTIATE, 0},
    //{ SMB_CORE_NEGOTIATE, 0 },
    //{ SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_NT_NEGOTIATE, 2 },
};

CHAR s_DialectNames[] = {
    "\2"  PCNET1 "\0"
    //\2notyet"  XENIXCORE "\0"
    //\2notyet"  MSNET103 "\0"
    "\2"  LANMAN10 "\0"
    "\2"  WFW10 "\0"
    "\2"  LANMAN12
    "\0\2"  LANMAN21
//    "\0\2"  NTLANMAN
    };

#define __second(a,b) (b)
ULONG
MRxSmbDialectFlags[] = {
    __second( PCNET1,    DF_CORE ),

    //__second( XENIXCORE, DF_CORE | DF_MIXEDCASEPW | DF_MIXEDCASE ),

    //__second( MSNET103,  DF_CORE | DF_OLDRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT ),

    __second( LANMAN10,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 ),

    __second( WFW10,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 | DF_WFW),

    __second( LANMAN12,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 | DF_LANMAN20 |
                    DF_MIXEDCASE | DF_LONGNAME | DF_SUPPORTEA ),

    __second( LANMAN21,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 | DF_LANMAN20 |
                    DF_MIXEDCASE | DF_LONGNAME | DF_SUPPORTEA |
                    DF_LANMAN21),

    __second( NTLANMAN,  DF_CORE | DF_NEWRAWIO |
                    DF_NTPROTOCOL | DF_NTNEGOTIATE |
                    DF_MIXEDCASEPW | DF_LANMAN10 | DF_LANMAN20 |
                    DF_LANMAN21 | DF_MIXEDCASE | DF_LONGNAME |
                    DF_SUPPORTEA | DF_TIME_IS_UTC )
};

ULONG s_NumberOfDialects = sizeof(s_SmbDialects) / sizeof(s_SmbDialects[0]);

PBYTE s_pNegotiateSmb =  NULL;
ULONG s_NegotiateSmbLength = 0;

PBYTE s_pEchoSmb  = NULL;
BYTE  s_EchoData[] = "JlJmIhClBsr";

#define SMB_ECHO_COUNT (1)

// Number of ticks 100ns ticks in a day.
LARGE_INTEGER s_MaxTimeZoneBias;

extern NTSTATUS
GetNTSecurityParameters(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange,
    PSMBCE_SERVER       pServer,
    PUNICODE_STRING     pDomainName,
    PRESP_NT_NEGOTIATE  pNtNegotiateResponse,
    ULONG               BytesIndicated,
    ULONG               BytesAvailable,
    PULONG              pBytesTaken,
    PMDL                *pDataBufferPointer,
    PULONG              pDataSize);

extern NTSTATUS
GetLanmanSecurityParameters(
    PSMBCE_SERVER    pServer,
    PRESP_NEGOTIATE  pNegotiateResponse);

extern VOID
GetLanmanTimeBias(
    PSMBCE_SERVER   pServer,
    PRESP_NEGOTIATE pNegotiateResponse);

// Number of 100 ns ticks in one minute
#define ONE_MINUTE_IN_TIME (60 * 1000 * 10000)

NTSTATUS
MRxSmbInitializeEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext)
/*++

Routine Description:

    This routine builds the echo SMB

Return Value:

    STATUS_SUCCESS if construction of an ECHO smb was successful

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       DialectIndex;

    PSMB_HEADER    pSmbHeader = NULL;
    PREQ_ECHO      pReqEcho   = NULL;

    PAGED_CODE();

    pEchoProbeContext->EchoSmbLength = sizeof(SMB_HEADER) +
                                     FIELD_OFFSET(REQ_ECHO,Buffer) +
                                     sizeof(s_EchoData);

    pEchoProbeContext->pEchoSmb = (PBYTE)RxAllocatePoolWithTag(
                                           NonPagedPool,
                                           pEchoProbeContext->EchoSmbLength,
                                           MRXSMB_ECHO_POOLTAG);

    if (pEchoProbeContext->pEchoSmb != NULL) {
        pSmbHeader = (PSMB_HEADER)pEchoProbeContext->pEchoSmb;
        pReqEcho   = (PREQ_ECHO)((PBYTE)pEchoProbeContext->pEchoSmb + sizeof(SMB_HEADER));

        // Fill in the header
        RtlZeroMemory( pSmbHeader, sizeof( SMB_HEADER ) );

        *(PULONG)(&pSmbHeader->Protocol) = (ULONG)SMB_HEADER_PROTOCOL;

        // By default, paths in SMBs are marked as case insensitive and
        // canonicalized.
        pSmbHeader->Flags =
            SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS;

        // Get the flags2 field out of the SmbContext
        SmbPutAlignedUshort(
            &pSmbHeader->Flags2,
            (SMB_FLAGS2_KNOWS_LONG_NAMES |
             SMB_FLAGS2_KNOWS_EAS        |
             SMB_FLAGS2_IS_LONG_NAME     |
             SMB_FLAGS2_NT_STATUS        |
             SMB_FLAGS2_UNICODE));

        // Fill in the process id.
        SmbPutUshort(&pSmbHeader->Pid, MRXSMB_PROCESS_ID );
        SmbPutUshort(&pSmbHeader->Tid,0xffff); // Invalid TID

        // Lastly, fill in the smb command code.
        pSmbHeader->Command = (UCHAR) SMB_COM_ECHO;

        pReqEcho->WordCount = 1;

        RtlMoveMemory( pReqEcho->Buffer, s_EchoData, sizeof( s_EchoData ) );

        SmbPutUshort(&pReqEcho->EchoCount, SMB_ECHO_COUNT);
        SmbPutUshort(&pReqEcho->ByteCount, (USHORT) sizeof( s_EchoData ) );
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

VOID
MRxSmbTearDownEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext)
/*++

Routine Description:

    This routine tears down the echo processing context

--*/
{
    PAGED_CODE();

    if (pEchoProbeContext->pEchoSmb != NULL) {
        RxFreePool(pEchoProbeContext->pEchoSmb);
        pEchoProbeContext->pEchoSmb = NULL;
    }
}



NTSTATUS
BuildNegotiateSmb(
    PVOID    *pSmbBufferPointer,
    PULONG   pSmbBufferLength)
/*++

Routine Description:

    This routine builds the negotiate SMB

Arguments:

    pSmbBufferPointer    - a placeholder for the smb buffer

    pNegotiateSmbLength  - the smb buffer size

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       DialectIndex;
    PSMB_HEADER    pSmbHeader    = NULL;
    PREQ_NEGOTIATE pReqNegotiate = NULL;

    PAGED_CODE();

    if (s_pNegotiateSmb == NULL) {
        s_NegotiateSmbLength = sizeof(SMB_HEADER) +
                               FIELD_OFFSET(REQ_NEGOTIATE,Buffer) +
                               sizeof(s_DialectNames);

        s_pNegotiateSmb = (PBYTE)RxAllocatePoolWithTag(
                                     PagedPool,
                                     s_NegotiateSmbLength + TRANSPORT_HEADER_SIZE,
                                     MRXSMB_ADMIN_POOLTAG);

        if (s_pNegotiateSmb != NULL) {

            s_pNegotiateSmb += TRANSPORT_HEADER_SIZE;

            pSmbHeader = (PSMB_HEADER)s_pNegotiateSmb;
            pReqNegotiate = (PREQ_NEGOTIATE)(s_pNegotiateSmb + sizeof(SMB_HEADER));

            // Fill in the header
            RtlZeroMemory( pSmbHeader, sizeof( SMB_HEADER ) );

            *(PULONG)(&pSmbHeader->Protocol) = (ULONG)SMB_HEADER_PROTOCOL;

            // By default, paths in SMBs are marked as case insensitive and
            // canonicalized.
            pSmbHeader->Flags =
                SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS;

            // Put our flags2 field. The Ox10 is a temporary flag for SLM
            // corruption detection
            SmbPutAlignedUshort(
                &pSmbHeader->Flags2,
                (SMB_FLAGS2_KNOWS_LONG_NAMES
                     | SMB_FLAGS2_KNOWS_EAS
                     | SMB_FLAGS2_IS_LONG_NAME
                     | SMB_FLAGS2_NT_STATUS
                     | SMB_FLAGS2_UNICODE
                 ));

            // Fill in the process id.
            SmbPutUshort( &pSmbHeader->Pid, MRXSMB_PROCESS_ID );

            // Lastly, fill in the smb command code.
            pSmbHeader->Command = (UCHAR) SMB_COM_NEGOTIATE;

            pReqNegotiate->WordCount = 0;

            RtlMoveMemory(
                pReqNegotiate->Buffer,
                s_DialectNames,
                sizeof( s_DialectNames ) );

            SmbPutUshort(
                &pReqNegotiate->ByteCount,
                (USHORT) sizeof( s_DialectNames ) );

            // Initialize the maximum time zone bias used in negotiate response parsing.
            s_MaxTimeZoneBias.QuadPart = Int32x32To64(24*60*60,1000*10000);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(Status)) {
        *pSmbBufferLength  = s_NegotiateSmbLength;
        *pSmbBufferPointer = s_pNegotiateSmb;
    }

    return Status;
}


ULONG MRxSmbSrvWriteBufSize = 0xffff; //use the negotiated size

NTSTATUS
ParseNegotiateResponse(
    IN OUT PSMB_ADMIN_EXCHANGE pSmbAdminExchange,
    IN     ULONG               BytesIndicated,
    IN     ULONG               BytesAvailable,
       OUT PULONG              pBytesTaken,
    IN     PSMB_HEADER         pSmbHeader,
       OUT PMDL                *pDataBufferPointer,
       OUT PULONG              pDataSize)
/*++

Routine Description:

    This routine parses the response from the server

Arguments:

    pServer            - the server instance

    pDomainName        - the domain name string to be extracted from the response

    pSmbHeader         - the response SMB

    BytesAvailable     - length of the response

    pBytesTaken        - response consumed

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    The SMB servers can speak a variety of dialects of the SMB protocol. The initial
    negotiate response can come in one of three possible flavours. Either we get the
    NT negotiate response SMB from a NT server or the extended response from DOS and
    OS/2 servers or the CORE response from other servers.

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY pServerEntry;
    PSMBCE_SERVER         pServer;
    PUNICODE_STRING       pDomainName;

    USHORT          DialectIndex;
    PRESP_NEGOTIATE pNegotiateResponse;
    ULONG           NegotiateSmbLength;

    ASSERT( pSmbHeader != NULL );

    pServerEntry = SmbCeGetExchangeServerEntry(pSmbAdminExchange);
    pServer = &pServerEntry->Server;

    pDomainName = &pSmbAdminExchange->Negotiate.DomainName;

    pNegotiateResponse = (PRESP_NEGOTIATE) (pSmbHeader + 1);
    NegotiateSmbLength = sizeof(SMB_HEADER);
    *pBytesTaken       = NegotiateSmbLength;

    // Assume that the indicated response is sufficient.
    // The TDI imposed minimum of 128 bytes subsumes the negotiate response.

    *pDataBufferPointer = NULL;
    *pDataSize          = 0;

    DialectIndex = SmbGetUshort( &pNegotiateResponse->DialectIndex );
    if (DialectIndex == (USHORT) -1) {
        // means server cannot accept any requests from
        *pBytesTaken = BytesAvailable;
        pServerEntry->ServerStatus = STATUS_REQUEST_NOT_ACCEPTED;

        return Status;
    }

    if (pNegotiateResponse->WordCount < 1 || DialectIndex > s_NumberOfDialects) {
        *pBytesTaken = BytesAvailable;
        pServerEntry->ServerStatus = STATUS_INVALID_NETWORK_RESPONSE;
        return Status;
    }

    // set the domain name length to zero ( default initialization )
    pDomainName->Length = 0;

    // Fix up the dialect type and the corresponding dispatch vector.
    pServer->Dialect        = (SMB_DIALECT)DialectIndex;
    pServer->DialectFlags   = MRxSmbDialectFlags[DialectIndex];
    pServer->pDispatch      = &s_SmbServerDispatchVectors[s_SmbDialects[DialectIndex].DispatchVectorIndex];

    // Parse the response based upon the type of negotiate response expected.

    switch (s_SmbDialects[DialectIndex].NegotiateType) {
    case SMB_NT_NEGOTIATE:
        {
            ULONG              NegotiateResponseLength;
            LARGE_INTEGER      ZeroTime;
            LARGE_INTEGER      LocalTimeBias;
            LARGE_INTEGER      ServerTimeBias;
            PRESP_NT_NEGOTIATE pNtNegotiateResponse = (PRESP_NT_NEGOTIATE) pNegotiateResponse;

            ASSERT(BytesAvailable > sizeof(RESP_NT_NEGOTIATE));

            if (pNtNegotiateResponse->WordCount != 17) {
                *pBytesTaken = BytesAvailable;
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            } else {
                // parse and map the capabilities.
                ULONG NtCapabilities;

                NegotiateResponseLength = FIELD_OFFSET(RESP_NT_NEGOTIATE,Buffer) +
                                          SmbGetUshort(&pNtNegotiateResponse->ByteCount);
                NegotiateSmbLength += NegotiateResponseLength;

                //Start with a clean slate
                pServer->Capabilities = 0;

                // Initialize server based constants
                pServer->MaximumRequests   = SmbGetUshort( &pNtNegotiateResponse->MaxMpxCount );
                pServer->MaximumVCs        = SmbGetUshort( &pNtNegotiateResponse->MaxNumberVcs );
                pServer->MaximumBufferSize = SmbGetUlong( &pNtNegotiateResponse->MaxBufferSize );

                NtCapabilities = pServer->NtServer.NtCapabilities = SmbGetUlong(&pNtNegotiateResponse->Capabilities);
                if (NtCapabilities & CAP_RAW_MODE) {
                    pServer->Capabilities |= (RAW_READ_CAPABILITY | RAW_WRITE_CAPABILITY);
                }

                if (NtCapabilities & CAP_DFS) {
                    pServer->Capabilities |= CAP_DFS;
                }

                //copy other nt capabilities into the dialog flags

                if (NtCapabilities & CAP_UNICODE) {
                    pServer->DialectFlags |= DF_UNICODE;
                }

                if (NtCapabilities & CAP_LARGE_FILES) {
                    pServer->DialectFlags |= DF_LARGE_FILES;
                }

                if (NtCapabilities & CAP_NT_SMBS) {
                    pServer->DialectFlags |= DF_NT_SMBS | DF_NT_FIND;
                }

                if (NtCapabilities & CAP_NT_FIND) {
                    pServer->DialectFlags |= DF_NT_FIND;
                }

                if (NtCapabilities & CAP_RPC_REMOTE_APIS) {
                    pServer->DialectFlags |= DF_RPC_REMOTE;
                }

                if (NtCapabilities & CAP_NT_STATUS) {
                    pServer->DialectFlags |= DF_NT_STATUS;
                }

                if (NtCapabilities & CAP_LEVEL_II_OPLOCKS) {
                    pServer->DialectFlags |= DF_OPLOCK_LVL2;
                }

                if (NtCapabilities & CAP_LOCK_AND_READ) {
                    pServer->DialectFlags |= DF_LOCKREAD;
                }

                if (NtCapabilities & CAP_INFOLEVEL_PASSTHRU) {
                    pServer->DialectFlags |= DF_NT_INFO_PASSTHROUGH;
                }

                // For non disk files the LARGE_READX capability is not useful.
                pServer->MaximumNonDiskFileReadBufferSize =
                    pServer->MaximumBufferSize -
                    QuadAlign(
                        sizeof(SMB_HEADER) +
                        FIELD_OFFSET(
                            REQ_NT_READ_ANDX,
                            Buffer[0]));

                if (NtCapabilities & CAP_LARGE_READX) {
                    if (NtCapabilities & CAP_LARGE_WRITEX) {
                        pServer->MaximumDiskFileReadBufferSize = 60*1024;
                    } else {
                        // The maximum size for reads to servers which support
                        // large read and x is constrained by the USHORT to record
                        // lengths in the SMB. Thus the maximum length that can be used
                        // is (65536 - 1) . This length should accomodate the header as
                        // well as the rest of the SMB. Actually, tho, we cut back to 60K.
                        pServer->MaximumDiskFileReadBufferSize = 60*1024;
                    }
                } else {
                    pServer->MaximumDiskFileReadBufferSize = pServer->MaximumNonDiskFileReadBufferSize;
                }

                // Specifying a zero local time will give you the time zone bias
                ZeroTime.HighPart = ZeroTime.LowPart = 0;
                ExLocalTimeToSystemTime( &ZeroTime, &LocalTimeBias );

                ServerTimeBias = RtlEnlargedIntegerMultiply(
                                    (LONG)SmbGetUshort(
                                        &pNtNegotiateResponse->ServerTimeZone),
                                    ONE_MINUTE_IN_TIME );

                pServer->TimeZoneBias.QuadPart = ServerTimeBias.QuadPart -
                                                 LocalTimeBias.QuadPart;

                if (!FlagOn(pServer->DialectFlags,DF_NT_SMBS)) {
                    //sigh...........
                    pServer->DialectFlags &= ~(DF_MIXEDCASEPW);
                    pServer->DialectFlags |= DF_W95;
                }

                Status = GetNTSecurityParameters(
                             pSmbAdminExchange,
                             pServer,
                             pDomainName,
                             pNtNegotiateResponse,
                             BytesIndicated,
                             BytesAvailable,
                             pBytesTaken,
                             pDataBufferPointer,
                             pDataSize);

                pServer->MaximumNonDiskFileWriteBufferSize =
                    min(
                        MRxSmbSrvWriteBufSize,
                        pServer->MaximumBufferSize -
                        QuadAlign(
                            sizeof(SMB_HEADER) +
                            FIELD_OFFSET(
                                REQ_NT_WRITE_ANDX,
                                Buffer[0])));
                
                if (NtCapabilities & CAP_LARGE_WRITEX) {
                    pServer->DialectFlags |= DF_LARGE_WRITEX;
                    pServer->MaximumDiskFileWriteBufferSize = 0x10000;
                } else {
                    pServer->MaximumDiskFileWriteBufferSize =
                        pServer->MaximumNonDiskFileWriteBufferSize;
                }
            }
        }
        break;

    case SMB_EXTENDED_NEGOTIATE :
        {
            // An SMB_EXTENDED_NEGOTIATE response is never partially indicated. The response
            // length is ithin the TDI minimum for indication.

            USHORT RawMode;

            // DOS or OS2 server
            if (pNegotiateResponse->WordCount != 13 &&
                pNegotiateResponse->WordCount != 10 &&
                pNegotiateResponse->WordCount != 8) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            } else {
                NegotiateSmbLength += FIELD_OFFSET(RESP_NEGOTIATE,Buffer) +
                                      SmbGetUshort(&pNegotiateResponse->ByteCount);

                ASSERT(
                    (BytesIndicated >= NegotiateSmbLength) &&
                    (BytesIndicated == BytesAvailable));

                RawMode = SmbGetUshort( &pNegotiateResponse->RawMode );
                pServer->Capabilities |= ((RawMode & 0x1) != 0
                                          ? RAW_READ_CAPABILITY : 0);
                pServer->Capabilities |= ((RawMode & 0x2) != 0
                                          ? RAW_WRITE_CAPABILITY : 0);

                if (pSmbHeader->Flags & SMB_FLAGS_LOCK_AND_READ_OK) {
                    pServer->DialectFlags |= DF_LOCKREAD;
                }

                pServer->EncryptPasswords = FALSE;
                pServer->MaximumVCs       = 1;

                pServer->MaximumBufferSize     = SmbGetUshort( &pNegotiateResponse->MaxBufferSize );
                pServer->MaximumDiskFileReadBufferSize =
                    pServer->MaximumBufferSize -
                    QuadAlign(
                        sizeof(SMB_HEADER) +
                        FIELD_OFFSET(
                            RESP_READ_ANDX,
                            Buffer[0]));

                pServer->MaximumNonDiskFileReadBufferSize  = pServer->MaximumDiskFileReadBufferSize;
                pServer->MaximumDiskFileWriteBufferSize    = pServer->MaximumDiskFileReadBufferSize;
                pServer->MaximumNonDiskFileWriteBufferSize = pServer->MaximumDiskFileReadBufferSize;

                pServer->MaximumRequests  = SmbGetUshort(
                                                &pNegotiateResponse->MaxMpxCount );
                pServer->MaximumVCs       = SmbGetUshort(
                                                &pNegotiateResponse->MaxNumberVcs );

                if (pNegotiateResponse->WordCount == 13) {
                    //CODE.IMPROVEMENT use the DF_bit for this
                    switch (pServer->Dialect) {
                    case LANMAN10_DIALECT:
                    case WFW10_DIALECT:
                    case LANMAN12_DIALECT:
                    case LANMAN21_DIALECT:
                        GetLanmanTimeBias( pServer,pNegotiateResponse );
                        break;
                    }

                    Status = GetLanmanSecurityParameters( pServer,pNegotiateResponse );
                }
            }

            *pBytesTaken = BytesAvailable;
        }
        break;

    case SMB_CORE_NEGOTIATE :
    default :
        {
            // An SMB_CORE_NEGOTIATE response is never partially indicated. The response
            // length is ithin the TDI minimum for indication.

            pServer->SecurityMode = SECURITY_MODE_SHARE_LEVEL;
            pServer->EncryptPasswords = FALSE;
            pServer->MaximumBufferSize = 0;
            pServer->MaximumRequests = 1;
            pServer->MaximumVCs = 1;
            pServer->SessionKey = 0;

            if (pSmbHeader->Flags & SMB_FLAGS_OPLOCK) {
                pServer->DialectFlags |= DF_OPLOCK;
            }
            
            *pBytesTaken = BytesAvailable;
            ASSERT(BytesIndicated == BytesAvailable);
        }
    }

    if (pServer->MaximumRequests == 0) {
        //
        // If this is a Lanman 1.0 or better server, this is a invalid negotiate
        // response. For others it would have been set to 1.
        //
        Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    if ((Status == STATUS_SUCCESS) ||
        (Status == STATUS_MORE_PROCESSING_REQUIRED)) {
        // Note that this code relies on the minimum incication size covering
        // the negotiate response header.
        //  Check to make sure that the time zone bias isn't more than +-24
        //  hours.
        //
        if ((pServer->TimeZoneBias.QuadPart > s_MaxTimeZoneBias.QuadPart) ||
            (-pServer->TimeZoneBias.QuadPart > s_MaxTimeZoneBias.QuadPart)) {

            //  Set the bias to 0 - assume local time zone.
            pServer->TimeZoneBias.LowPart = pServer->TimeZoneBias.HighPart = 0;
        }

        //  Do not allow negotiated buffersize to exceed the size of a USHORT.
        //  Remove 4096 bytes to avoid overrun and make it easier to handle
        //  than 0xffff

        pServer->MaximumBufferSize =
            (pServer->MaximumBufferSize < 0x00010000) ? pServer->MaximumBufferSize :
                                             0x00010000 - 4096;
    } else {
        pServerEntry->ServerStatus = Status;
        *pBytesTaken = BytesAvailable;
    }

    if ((pServer->DialectFlags & DF_NTNEGOTIATE)!=0) {

        InterlockedIncrement(&MRxSmbStatistics.LanmanNtConnects);

    } else if ((pServer->DialectFlags & DF_LANMAN21)!=0) {

        InterlockedIncrement(&MRxSmbStatistics.Lanman21Connects);

    } else if ((pServer->DialectFlags & DF_LANMAN20)!=0) {

        InterlockedIncrement(&MRxSmbStatistics.Lanman20Connects);

    } else {

        InterlockedIncrement(&MRxSmbStatistics.CoreConnects);

    }

    if ((pServer->Dialect == NTLANMAN_DIALECT) &&
        !pServer->EncryptPasswords) {
        // Encrypted password is required on NTLANMAN
        pServer->Dialect = LANMAN21_DIALECT;
    }

    return Status;
}

NTSTATUS
GetNTSecurityParameters(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange,
    PSMBCE_SERVER       pServer,
    PUNICODE_STRING     pDomainName,
    PRESP_NT_NEGOTIATE  pNtNegotiateResponse,
    ULONG               BytesIndicated,
    ULONG               BytesAvailable,
    PULONG              pBytesTaken,
    PMDL                *pDataBufferPointer,
    PULONG              pDataSize)
/*++

Routine Description:

    This routine extracts the security parameters from an NT server

Arguments:

    pServer                 - the server

    pDomainName             - the domain name

    pNtNegotiateResponse    - the response

    NegotiateResponseLength - size of the negotiate response

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS   Status = STATUS_SUCCESS;
    USHORT     ByteCount;
    PUSHORT    pByteCountInSmb =
               ((PUSHORT)((PUCHAR) pNtNegotiateResponse + 1)) +
               pNtNegotiateResponse->WordCount;
    PUCHAR     pBuffer = (PUCHAR)(pByteCountInSmb + 1);

    *pBytesTaken += FIELD_OFFSET(RESP_NT_NEGOTIATE,Buffer);

    ByteCount = SmbGetUshort(pByteCountInSmb);

    pServer->SecurityMode = (((pNtNegotiateResponse->SecurityMode & NEGOTIATE_USER_SECURITY) != 0)
                             ? SECURITY_MODE_USER_LEVEL
                             : SECURITY_MODE_SHARE_LEVEL);

    pServer->EncryptPasswords = ((pNtNegotiateResponse->SecurityMode & NEGOTIATE_ENCRYPT_PASSWORDS) != 0);
    pServer->EncryptionKeyLength = 0;

    
    *pBytesTaken = BytesAvailable;

    pServer->SessionKey = SmbGetUlong( &pNtNegotiateResponse->SessionKey );

    if (pServer->EncryptPasswords) {
        pServer->EncryptionKeyLength = pNtNegotiateResponse->EncryptionKeyLength;

        if (pServer->EncryptionKeyLength != 0) {

            ASSERT( CRYPT_TXT_LEN == MSV1_0_CHALLENGE_LENGTH );

            if (pServer->EncryptionKeyLength != CRYPT_TXT_LEN) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            } else {

                RtlCopyMemory(
                    pServer->EncryptionKey,
                    pBuffer,
                    pServer->EncryptionKeyLength );

                if (ByteCount - pServer->EncryptionKeyLength > 0) {
                    ASSERT((pDomainName->Buffer != NULL) &&
                           (pDomainName->MaximumLength >= (ByteCount - pServer->EncryptionKeyLength)));

                    pBuffer = pBuffer + pServer->EncryptionKeyLength;
                    pDomainName->Length = ByteCount - pServer->EncryptionKeyLength;

                    if (pDomainName->Length & 1) {
                        // The remainder of the length is odd. This implies that the server did
                        // some alignment.
                        pBuffer++;
                        pDomainName->Length -= 1;
                    }

                    RtlCopyMemory(
                        pDomainName->Buffer,
                        pBuffer,
                        pDomainName->Length);
                }
            }
        }
    }
    
    return Status;
}

NTSTATUS
GetLanmanSecurityParameters(
    PSMBCE_SERVER    pServer,
    PRESP_NEGOTIATE  pNegotiateResponse)
/*++

Routine Description:

    This routine extracts the security parameters from a LANMAN server

Arguments:

    pServer              - the server

    pNtNegotiateResponse - the response

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{

    USHORT i;
    USHORT SecurityMode;

    pServer->SessionKey = SmbGetUlong( &pNegotiateResponse->SessionKey );

    SecurityMode = SmbGetUshort( &pNegotiateResponse->SecurityMode );
    pServer->SecurityMode = (((SecurityMode & 1) != 0)
                             ? SECURITY_MODE_USER_LEVEL
                             : SECURITY_MODE_SHARE_LEVEL);
    pServer->EncryptPasswords = ((SecurityMode & 2) != 0);

    if (pServer->EncryptPasswords) {
        if (pServer->Dialect == LANMAN21_DIALECT) {
            pServer->EncryptionKeyLength = SmbGetUshort(&pNegotiateResponse->EncryptionKeyLength);
        } else {
            pServer->EncryptionKeyLength = SmbGetUshort(&pNegotiateResponse->ByteCount);
        }

        if (pServer->EncryptionKeyLength != 0) {
            if (pServer->EncryptionKeyLength > CRYPT_TXT_LEN) {
                return( STATUS_INVALID_NETWORK_RESPONSE );
            }

            for (i = 0; i < pServer->EncryptionKeyLength; i++) {
                pServer->EncryptionKey[i] = pNegotiateResponse->Buffer[i];
            }
        }
    }

    return( STATUS_SUCCESS );
}

LARGE_INTEGER
ConvertSmbTimeToTime (
    IN SMB_TIME Time,
    IN SMB_DATE Date
    )
/*++

Routine Description:

    This routine converts an SMB time to an NT time structure.

Arguments:

    IN SMB_TIME Time - Supplies the time of day to convert
    IN SMB_DATE Date - Supplies the day of the year to convert
    IN PSERVERLISTENTRY Server - if supplied, supplies the server for tz bias.

Return Value:

    LARGE_INTEGER - Time structure describing input time.


--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER OutputTime;

    //
    // This routine cannot be paged because it is called from both the
    // RdrFileDiscardableSection and the RdrVCDiscardableSection.
    //

    if (SmbIsTimeZero(&Date) && SmbIsTimeZero(&Time)) {
        OutputTime.LowPart = OutputTime.HighPart = 0;
    } else {
        TimeFields.Year = Date.Struct.Year + (USHORT )1980;
        TimeFields.Month = Date.Struct.Month;
        TimeFields.Day = Date.Struct.Day;

        TimeFields.Hour = Time.Struct.Hours;
        TimeFields.Minute = Time.Struct.Minutes;
        TimeFields.Second = Time.Struct.TwoSeconds*(USHORT )2;
        TimeFields.Milliseconds = 0;

        //
        //  Make sure that the times specified in the SMB are reasonable
        //  before converting them.
        //

        if (TimeFields.Year < 1601) {
            TimeFields.Year = 1601;
        }

        if (TimeFields.Month > 12) {
            TimeFields.Month = 12;
        }

        if (TimeFields.Hour >= 24) {
            TimeFields.Hour = 23;
        }
        if (TimeFields.Minute >= 60) {
            TimeFields.Minute = 59;
        }
        if (TimeFields.Second >= 60) {
            TimeFields.Second = 59;

        }

        if (!RtlTimeFieldsToTime(&TimeFields, &OutputTime)) {
            OutputTime.HighPart = 0;
            OutputTime.LowPart = 0;

            return OutputTime;
        }

        ExLocalTimeToSystemTime(&OutputTime, &OutputTime);

    }

    return OutputTime;

}

VOID
GetLanmanTimeBias(
    PSMBCE_SERVER   pServer,
    PRESP_NEGOTIATE pNegotiateResponse)
/*++

Routine Description:

    This routine extracts the time bias from a Lanman server

Arguments:

    pServer              - the server

    pNtNegotiateResponse - the response

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{
    //  If this is a LM 1.0 or 2.0 server (ie a non NT server), we
    //  remember the timezone and bias our time based on this value.
    //
    //  The redirector assumes that all times from these servers are
    //  local time for the server, and converts them to local time
    //  using this bias. It then tells the user the local time for
    //  the file on the server.
    LARGE_INTEGER Workspace, ServerTime, CurrentTime;
    BOOLEAN Negated = FALSE;
    SMB_TIME SmbServerTime;
    SMB_DATE SmbServerDate;

    SmbMoveTime(&SmbServerTime, &pNegotiateResponse->ServerTime);

    SmbMoveDate(&SmbServerDate, &pNegotiateResponse->ServerDate);

    ServerTime = ConvertSmbTimeToTime(SmbServerTime, SmbServerDate);

    KeQuerySystemTime(&CurrentTime);

    Workspace.QuadPart = CurrentTime.QuadPart - ServerTime.QuadPart;

    if ( Workspace.HighPart < 0) {
        //  avoid using -ve large integers to routines that accept only unsigned
        Workspace.QuadPart = -Workspace.QuadPart;
        Negated = TRUE;
    }

    //
    //  Workspace has the exact difference in 100ns intervals
    //  between the server and redirector times. To remove the minor
    //  difference between the time settings on the two machines we
    //  round the Bias to the nearest 30 minutes.
    //
    //  Calculate ((exact bias+15minutes)/30minutes)* 30minutes
    //  then convert back to the bias time.
    //

    Workspace.QuadPart += ((LONGLONG) ONE_MINUTE_IN_TIME) * 15;

    //  Workspace is now  exact bias + 15 minutes in 100ns units

    Workspace.QuadPart /= ((LONGLONG) ONE_MINUTE_IN_TIME) * 30;

    pServer->TimeZoneBias.QuadPart = Workspace.QuadPart * ((LONGLONG) ONE_MINUTE_IN_TIME) * 30;

    if ( Negated == TRUE ) {
        pServer->TimeZoneBias.QuadPart = -pServer->TimeZoneBias.QuadPart;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\wmlkm.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cldskwmi.c

Abstract:

    km wmi tracing code. 
    
    Will be shared between our drivers.

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:

Comments:

        This code is a quick hack to enable WMI tracing in cluster drivers.
        It should eventually go away.

        WmlTinySystemControl will be replaced with WmilibSystemControl from wmilib.sys .

        WmlTrace or equivalent will be added to the kernel in addition to IoWMIWriteEvent(&TraceBuffer);

--*/
#include "precomp.h"
#pragma hdrstop

//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>


// #include <wmistr.h>
// #include <evntrace.h>

// #include "wmlkm.h"

BOOLEAN
WmlpFindGuid(
    IN PVOID GuidList,
    IN ULONG GuidCount,
    IN LPVOID Guid,
    OUT PULONG GuidIndex
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid
        
Return Value:

    TRUE if guid is found else FALSE

--*/
{

    return(FALSE);
}


NTSTATUS
WmlTinySystemControl(
    IN OUT PVOID WmiLibInfo,
    IN PVOID DeviceObject,
    IN PVOID Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    return(STATUS_WMI_GUID_NOT_FOUND);
}

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPVOID TraceGuid,
    IN ULONG64 LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    return STATUS_SUCCESS;
}


ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN ULONG64 LoggerHandle,
    IN PCHAR FormatString,
    ... // printf var args
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\wmlkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlkm.h

Abstract:

    Kernel mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved

--*/
#ifndef WMLKM_H
#define WMLKM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#include "wmlmacro.h"
#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TRACE_GUIDS_PER_CONTROL  3

typedef struct _WML_CONTROL_GUID_REG {
    GUID        Guid;
    GUID        TraceGuids[MAX_TRACE_GUIDS_PER_CONTROL];
    ULONG       EnableFlags;
    ULONG       EnableLevel;
    TRACEHANDLE LoggerHandle;
} WML_CONTROL_GUID_REG, *PWML_CONTROL_GUID_REG;

typedef struct _WML_TINY_INFO {
    PWML_CONTROL_GUID_REG    ControlGuids;
    ULONG                    GuidCount;
    PDEVICE_OBJECT           LowerDeviceObject;
    PUNICODE_STRING          DriverRegPath;
} WML_TINY_INFO, *PWML_TINY_INFO;


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // var args
    );



#ifdef __cplusplus
};
#endif

#endif // WMLKM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\transact.h ===
/*++

Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    smbcxchng.h

Abstract:

    This is the include file that defines all constants and types for
    SMB exchange implementation.

--*/

#ifndef _TRANSACT_H_
#define _TRANSACT_H_

typedef enum _TRANSACT_EXCHANGE_STATE_ {
   TRANSACT_EXCHANGE_START,
   TRANSACT_EXCHANGE_ERROR,
   TRANSACT_EXCHANGE_SUCCESS,
   TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST,
   TRANSACT_EXCHANGE_RECEIVED_INTERIM_RESPONSE,
   TRANSACT_EXCHANGE_TRANSMITTED_SECONDARY_REQUESTS,
   TRANSACT_EXCHANGE_RECEIVED_PRIMARY_RESPONSE
} TRANSACT_EXCHANGE_STATE, *PTRANSACT_EXCHANGE_STATE;

typedef struct _SMB_TRANSACTION_RESUMPTION_CONTEXT{
    struct _SMB_TRANSACT_EXCHANGE *pTransactExchange;
    SMBCE_RESUMPTION_CONTEXT SmbCeResumptionContext;
    ULONG SetupBytesReceived;
    ULONG DataBytesReceived;
    ULONG ParameterBytesReceived;
    NTSTATUS FinalStatusFromServer;
    ULONG ServerVersion;
} SMB_TRANSACTION_RESUMPTION_CONTEXT, *PSMB_TRANSACTION_RESUMPTION_CONTEXT;

#define TRAILING_BYTES_BUFFERSIZE 8
typedef struct _SMB_TRANSACT_EXCHANGE {
    SMB_EXCHANGE;

    TRANSACT_EXCHANGE_STATE State;

    // Client supplied parameters for the transact exchange
    //PRX_CONTEXT             RxContext;
    PMDL            pSendDataMdl;
    ULONG                   SendDataBufferSize;
    ULONG                   DataBytesSent;
    PMDL            pReceiveDataMdl;
    ULONG                   ReceiveDataBufferSize;
    ULONG                   DataBytesReceived;
    PMDL            pSendParamMdl; //used if we cannot subsume
    PVOID                   pSendParamBuffer;
    ULONG                   SendParamBufferSize;
    ULONG                   ParamBytesSent;
    PMDL            pReceiveParamMdl;
    ULONG                   ReceiveParamBufferSize;
    ULONG                   ParamBytesReceived;
    PVOID                   pSendSetupMdl;
    ULONG                   SendSetupBufferSize;
    PMDL            pReceiveSetupMdl;
    ULONG                   ReceiveSetupBufferSize;
    ULONG                   SetupBytesReceived;

    // Transact exchange intrinsic fields
    ULONG                     PrimaryRequestSmbSize;
    PVOID                     pActualPrimaryRequestSmbHeader;     // Original buffer allocated
    PSMB_HEADER               pPrimaryRequestSmbHeader;           // Start of header
    ULONG                     ParameterBytesSeen;
    ULONG                     DataBytesSeen;
    LONG                      PendingCopyRequests;
    BOOLEAN                   fParamsSubsumedInPrimaryRequest;
    UCHAR                     SmbCommand;
    USHORT                    Flags;
    USHORT                    NtTransactFunction;
    SMB_FILE_ID               Fid;
    ULONG                     TransactionNameLength;
    ULONG                     MaximumTransmitSmbBufferSize;
                                 //used to cache value and also to force
                                 //smaller value for testing
    PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext;

    struct {
        MDL  TrailingBytesMdl;
        ULONG Pages[3]; //you need 2...one pad; this must cover an smbbuf
    };
    NTSTATUS SaveTheRealStatus;
    PVOID    DiscardBuffer;
    struct {
        ULONG Bytes[TRAILING_BYTES_BUFFERSIZE/sizeof(ULONG)];
    } TrailingBytesBuffer;
} SMB_TRANSACT_EXCHANGE, *PSMB_TRANSACT_EXCHANGE;

typedef struct SMB_TRANSACTION_PARAMETERS {
   USHORT Flags;
   USHORT SetupLength;      // the steup buffer length
   union {
      PVOID pSetup;         // the setup buffer
      PMDL  pSetupMdl;      // the MDL version of the buffer
   };
   ULONG ParamLength;
   PVOID pParam;            //you need the bufptr is you're subsuming
   PMDL  pParamMdl;         //you need the MDL is you can't subsume
   PMDL  pDataMdl;          // the data buffer
   ULONG DataLength;        // this is total length...not the length
                            // of the 1st mdl in the chain
} SMB_TRANSACTION_PARAMETERS, *PSMB_TRANSACTION_PARAMETERS;

typedef SMB_TRANSACTION_PARAMETERS          SMB_TRANSACTION_SEND_PARAMETERS;
typedef SMB_TRANSACTION_SEND_PARAMETERS*    PSMB_TRANSACTION_SEND_PARAMETERS;
typedef SMB_TRANSACTION_PARAMETERS          SMB_TRANSACTION_RECEIVE_PARAMETERS;
typedef SMB_TRANSACTION_RECEIVE_PARAMETERS* PSMB_TRANSACTION_RECEIVE_PARAMETERS;

#define SMBCE_DEFAULT_TRANSACTION_TIMEOUT (0xffffffff)
#define SMBCE_TRANSACTION_TIMEOUT_NOT_USED (0x0)

typedef struct SMB_TRANSACTION_OPTIONS {
   USHORT     NtTransactFunction;
   USHORT     Flags;
   PUNICODE_STRING pTransactionName;
   ULONG      TimeoutIntervalInMilliSeconds;
   ULONG      MaximumTransmitSmbBufferSize;
} SMB_TRANSACTION_OPTIONS, *PSMB_TRANSACTION_OPTIONS;

#define DEFAULT_TRANSACTION_OPTIONS {0,0,NULL,SMBCE_TRANSACTION_TIMEOUT_NOT_USED,0xffff}
extern SMB_TRANSACTION_OPTIONS RxDefaultTransactionOptions;

#define TRANSACTION_SEND_PARAMETERS_FLAG    (0x1)
#define TRANSACTION_RECEIVE_PARAMETERS_FLAG (0x2)

// xact and xact_options have the same flags so we have to be careful to strip off these bits
// when we format up the smb ( the flags field is a USHORT)
#define SMB_XACT_FLAGS_REPARSE                      (0x8000)
#define SMB_XACT_FLAGS_FID_NOT_NEEDED               (0x4000)
#define SMB_XACT_FLAGS_CALLERS_SENDDATAMDL          (0x2000)
#define SMB_XACT_FLAGS_TID_FOR_FID                  (0x1000)
#define SMB_XACT_FLAGS_MAILSLOT_OPERATION           (0x0800)
#define SMB_XACT_FLAGS_INDEFINITE_DELAY_IN_RESPONSE (0x0400)
#define SMB_XACT_FLAGS_DFS_AWARE                    (0x0200)
#define SMB_XACT_FLAGS_ASYNCHRONOUS                 (0x0100)
//#define SMB_XACT_FLAGS_COPY_ON_ERROR                (0x080)

#define SMB_XACT_INTERNAL_FLAGS_MASK               \
            ( SMB_XACT_FLAGS_REPARSE               \
              | SMB_XACT_FLAGS_FID_NOT_NEEDED      \
              | SMB_XACT_FLAGS_CALLERS_SENDDATAMDL \
              | SMB_XACT_FLAGS_TID_FOR_FID         \
              | SMB_XACT_FLAGS_MAILSLOT_OPERATION  \
              | SMB_XACT_FLAGS_INDEFINITE_DELAY_IN_RESPONSE \
              | SMB_XACT_FLAGS_DFS_AWARE                    \
              | SMB_XACT_FLAGS_ASYNCHRONOUS                 \
            )

#define SMB_TRANSACTION_VALID_FLAGS (\
        SMB_TRANSACTION_DISCONNECT   \
     |  SMB_TRANSACTION_NO_RESPONSE  \
   )

#if ((SMB_XACT_INTERNAL_FLAGS_MASK & SMB_TRANSACTION_VALID_FLAGS) != 0)
#error SMB_XACT_INTERNAL_FLAGS_MASK has overrun the transact flags
#endif

extern NTSTATUS
SmbCeInitializeTransactionParameters(
   PVOID  pSetup,
   USHORT SetupLength,
   PVOID  pParam,
   ULONG  ParamLength,
   PVOID  pData,
   ULONG  DataLength,
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters);

#define SmbCeProvideTransactionDataAsMdl(pTransactionParameters,pMdl,Length) { \
          ASSERT( (pTransactionParameters)->DataLength == 0 );                   \
          ASSERT( (pTransactionParameters)->pDataMdl == NULL );                  \
          ASSERT( FlagOn((pTransactionParameters)->Flags,TRANSACTION_SEND_PARAMETERS_FLAG) ); \
          (pTransactionParameters)->DataLength = Length;                         \
          (pTransactionParameters)->pDataMdl = pMdl;                             \
          (pTransactionParameters)->Flags |= SMB_XACT_FLAGS_CALLERS_SENDDATAMDL;    \
  }

extern VOID
SmbCeUninitializeTransactionParameters(
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters);

extern VOID
SmbCeDiscardTransactExchange(PSMB_TRANSACT_EXCHANGE pTransactExchange);

INLINE NTSTATUS
SmbCeInitializeTransactionSendParameters(
      PVOID  pSetup,
      USHORT SetupLength,
      PVOID  pParam,
      ULONG  ParamLength,
      PVOID  pData,
      ULONG  DataLength,
      PSMB_TRANSACTION_SEND_PARAMETERS pSendParameters)
{
   ((PSMB_TRANSACTION_PARAMETERS)pSendParameters)->Flags = TRANSACTION_SEND_PARAMETERS_FLAG;
   return SmbCeInitializeTransactionParameters(
                pSetup,SetupLength,pParam,ParamLength,pData,DataLength,pSendParameters);

}

INLINE NTSTATUS
SmbCeInitializeTransactionReceiveParameters(
      PVOID  pSetup,
      USHORT SetupLength,
      PVOID  pParam,
      ULONG  ParamLength,
      PVOID  pData,
      ULONG  DataLength,
      PSMB_TRANSACTION_RECEIVE_PARAMETERS pReceiveParameters)
{
   ((PSMB_TRANSACTION_PARAMETERS)pReceiveParameters)->Flags = TRANSACTION_RECEIVE_PARAMETERS_FLAG;
   return SmbCeInitializeTransactionParameters(
                pSetup,SetupLength,pParam,ParamLength,pData,DataLength,pReceiveParameters);

}

#define SmbCeUninitializeTransactionSendParameters(pSendParameters)  \
        ASSERT((pSendParameters)->Flags & TRANSACTION_SEND_PARAMETERS_FLAG); \
        SmbCeUninitializeTransactionParameters(pSendParameters);

#define SmbCeUninitializeTransactionReceiveParameters(pReceiveParameters)  \
        ASSERT((pReceiveParameters)->Flags & TRANSACTION_RECEIVE_PARAMETERS_FLAG); \
        SmbCeUninitializeTransactionParameters(pReceiveParameters)

INLINE VOID
SmbCeInitializeTransactionResumptionContext(
   PSMB_TRANSACTION_RESUMPTION_CONTEXT ptResumptionContext)
{
   SmbCeInitializeResumptionContext(&(ptResumptionContext)->SmbCeResumptionContext);
   ptResumptionContext->SetupBytesReceived = 0;
   ptResumptionContext->DataBytesReceived = 0;
   ptResumptionContext->ParameterBytesReceived = 0;
   ptResumptionContext->FinalStatusFromServer = (STATUS_SUCCESS);
}

INLINE VOID
SmbCeInitializeAsynchronousTransactionResumptionContext(
   PSMB_TRANSACTION_RESUMPTION_CONTEXT ptResumptionContext,
   PRX_WORKERTHREAD_ROUTINE            pResumptionRoutine,
   PVOID                               pResumptionRoutineParam)
{
   SmbCeInitializeAsynchronousResumptionContext(
        &ptResumptionContext->SmbCeResumptionContext,
        pResumptionRoutine,
        pResumptionRoutineParam);

   ptResumptionContext->SetupBytesReceived     = 0;
   ptResumptionContext->DataBytesReceived      = 0;
   ptResumptionContext->ParameterBytesReceived = 0;
   ptResumptionContext->FinalStatusFromServer  = (STATUS_SUCCESS);
}

INLINE VOID
SmbCeWaitOnTransactionResumptionContext(
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pTransactionResumptionContext)
{
   SmbCeSuspend(&pTransactionResumptionContext->SmbCeResumptionContext);
}


extern NTSTATUS
SmbCeSubmitTransactionRequest(
   PRX_CONTEXT                 RxContext,
   PSMB_TRANSACTION_OPTIONS    pOptions,
   PSMB_TRANSACTION_PARAMETERS pSendParameters,
   PSMB_TRANSACTION_PARAMETERS pReceiveParameters,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT   pResumptionContext );

extern NTSTATUS
_SmbCeTransact(
   PRX_CONTEXT                         RxContext,
   PSMB_TRANSACTION_OPTIONS            pOptions,
   PVOID                               pInputSetupBuffer,
   ULONG                               InputSetupBufferlength,
   PVOID                               pOutputSetupBuffer,
   ULONG                               OutputSetupBufferLength,
   PVOID                               pInputParamBuffer,
   ULONG                               InputParamBufferLength,
   PVOID                               pOutputParamBuffer,
   ULONG                               OutputParamBufferLength,
   PVOID                               pInputDataBuffer,
   ULONG                               InputDataBufferLength,
   PVOID                               pOutputDataBuffer,
   ULONG                               OutputDataBufferLength,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext);


INLINE NTSTATUS
SmbCeTransact(
   PRX_CONTEXT                         RxContext,
   PSMB_TRANSACTION_OPTIONS            pOptions,
   PVOID                               pInputSetupBuffer,
   ULONG                               InputSetupBufferlength,
   PVOID                               pOutputSetupBuffer,
   ULONG                               OutputSetupBufferLength,
   PVOID                               pInputParamBuffer,
   ULONG                               InputParamBufferLength,
   PVOID                               pOutputParamBuffer,
   ULONG                               OutputParamBufferLength,
   PVOID                               pInputDataBuffer,
   ULONG                               InputDataBufferLength,
   PVOID                               pOutputDataBuffer,
   ULONG                               OutputDataBufferLength,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext)
{
   SmbCeInitializeTransactionResumptionContext(pResumptionContext);

   return _SmbCeTransact(
               RxContext,
               pOptions,
               pInputSetupBuffer,
               InputSetupBufferlength,
               pOutputSetupBuffer,
               OutputSetupBufferLength,
               pInputParamBuffer,
               InputParamBufferLength,
               pOutputParamBuffer,
               OutputParamBufferLength,
               pInputDataBuffer,
               InputDataBufferLength,
               pOutputDataBuffer,
               OutputDataBufferLength,
               pResumptionContext);
}

INLINE NTSTATUS
SmbCeAsynchronousTransact(
   PRX_CONTEXT                         RxContext,
   PSMB_TRANSACTION_OPTIONS            pOptions,
   PVOID                               pInputSetupBuffer,
   ULONG                               InputSetupBufferlength,
   PVOID                               pOutputSetupBuffer,
   ULONG                               OutputSetupBufferLength,
   PVOID                               pInputParamBuffer,
   ULONG                               InputParamBufferLength,
   PVOID                               pOutputParamBuffer,
   ULONG                               OutputParamBufferLength,
   PVOID                               pInputDataBuffer,
   ULONG                               InputDataBufferLength,
   PVOID                               pOutputDataBuffer,
   ULONG                               OutputDataBufferLength,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext)
{
    pOptions->Flags |= SMB_XACT_FLAGS_ASYNCHRONOUS;
    return _SmbCeTransact(
               RxContext,
               pOptions,
               pInputSetupBuffer,
               InputSetupBufferlength,
               pOutputSetupBuffer,
               OutputSetupBufferLength,
               pInputParamBuffer,
               InputParamBufferLength,
               pOutputParamBuffer,
               OutputParamBufferLength,
               pInputDataBuffer,
               InputDataBufferLength,
               pOutputDataBuffer,
               OutputDataBufferLength,
               pResumptionContext);
}

#endif // _TRANSACT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\transprt.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    transprt.h

Abstract:

    This module implements all transport related functions in the SMB connection
    engine

Notes:


--*/

#ifndef _TRANSPRT_H_
#define _TRANSPRT_H_

// The SMBCE_TRANSPORT data structure encapsulates all the information w.r.t a
// particular transport for the connection engine. All the transports that are
// of interest to the SMB mini redirector are maintained in a doubly linked list
//
// The connection engine tries all the transports in this list when trying to
// establish a connection to a server. Currently only connection oriented
// transports are handled.

typedef struct _SMBCE_TRANSPORT_ {
   SMBCE_OBJECT_HEADER;

   RXCE_TRANSPORT   RxCeTransport;
   RXCE_ADDRESS     RxCeAddress;

   ULONG            Priority;       // the priority in the binding list.

   BOOLEAN          Active;

   // Additional information regarding quality of service and other selection
   // criterion for a transport will be included here.

} SMBCE_TRANSPORT, *PSMBCE_TRANSPORT;

typedef struct _SMBCE_TRANSPORT_ARRAY_ {
    ULONG               ReferenceCount;
    ULONG               Count;
    PSMBCE_TRANSPORT    *SmbCeTransports;
    PRXCE_ADDRESS       *LocalAddresses;
} SMBCE_TRANSPORT_ARRAY, *PSMBCE_TRANSPORT_ARRAY;


typedef struct _SMBCE_TRANSPORTS_ {
   RX_SPIN_LOCK             Lock;
   PSMBCE_TRANSPORT_ARRAY   pTransportArray;
} SMBCE_TRANSPORTS, *PSMBCE_TRANSPORTS;

extern SMBCE_TRANSPORTS MRxSmbTransports;


// Transport entries are added to the list of known transports upon receipt of
// PnP notifications. Currently the list is static since transport disabling
// notifications are not handled by the underlying TDI/PnP layer.
// The following routines provide the ability for adding/deleting entries to
// this list.

extern
PSMBCE_TRANSPORT_ARRAY
SmbCeReferenceTransportArray(VOID);

extern NTSTATUS
SmbCeDereferenceTransportArray(PSMBCE_TRANSPORT_ARRAY pTransportArray);

extern NTSTATUS
SmbCeAddTransport(PSMBCE_TRANSPORT pTransport);

extern NTSTATUS
SmbCeRemoveTransport(PSMBCE_TRANSPORT pTransport);

#define SmbCeGetAvailableTransportCount()   \
        (MRxSmbTransports.Count)

// The connection engine maintains a reference count associated with each transport
// which indicates the number of servers that are using the transport. This will
// eventually provide the mechanism for disabling/enabling transport on receipt
// of PnP notifications.

#define SmbCeReferenceTransport(pTransport)                                   \
        SmbCepReferenceTransport(pTransport)

#define SmbCeDereferenceTransport(pTransport)                                 \
        SmbCepDereferenceTransport(pTransport)

// The server transport types encapsulate the various usages of the underlying
// transport to communicate with a server.
//
// The interactions are currently classified into four types, MAILSOT, Virtual
// Circuit, Datagram and Htbrid ( VC + Datagram ).
//
// The type chosen will depend upon the characterstics of the available
// connection. Each type is associated with its own dispatch vector which
// encapsulates the interaction between the connection engine and the transport.
//
// This includes Send,Receive, Receive Ind. etc. These are modelled after the
// TDI interfaces.


typedef enum _SMBCE_SERVER_TRANSPORT_TYPE_ {
    SMBCE_STT_VC       = 1,
    SMBCE_STT_DATAGRAM = 2,
    SMBCE_STT_HYBRID   = 4
} SMBCE_SERVER_TRANSPORT_TYPE, *PSMBCE_SERVER_TRANSPORT_TYPE;

typedef struct SMBCE_SERVER_TRANSPORT {
   SMBCE_OBJECT_HEADER;

   struct TRANSPORT_DISPATCH_VECTOR *pDispatchVector;
   struct _SMBCE_TRANSPORT_         *pTransport;

   PKEVENT                          pRundownEvent;      // used for finalization.

   ULONG                            MaximumSendSize;    // max data size
} SMBCE_SERVER_TRANSPORT, *PSMBCE_SERVER_TRANSPORT;

// The SMBCE_SERVER_TRANSPORT instances are reference counted. The following
// routines provide the referencing mechanism. Defining them as macros also
// provides us with a easy debugging capability, i.e., it can be easily modified
// to include a FILE/LINE number each time an instance is referenced and
// dereferenced

#define SmbCeReferenceServerTransport(pServerTransportPointer)                    \
        SmbCepReferenceServerTransport(pServerTransportPointer)

#define SmbCeDereferenceServerTransport(pServerTransportPointer)           \
        SmbCepDereferenceServerTransport(pServerTransportPointer)

// The server transport establishment mechanism requires a callback mechanism
// to handle the asynchronous connection establishment cases.

typedef
VOID
(*PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK)(
    PVOID   pContext);

typedef
VOID
(*PSMBCE_SERVER_TRANSPORT_DESTRUCTION_CALLBACK)(
    PVOID   pContext);

typedef enum _SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE {
    SmbCeServerTransportConstructionBegin,
    SmbCeServerVcTransportConstructionBegin,
    SmbCeServerVcTransportConstructionEnd,
    SmbCeServerTransportConstructionEnd
} SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE,
  *PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE;

typedef struct _SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT {
    NTSTATUS                      Status;

    SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE State;

    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK pCompletionRoutine;
    PMRX_SRVCALL_CALLBACK_CONTEXT                 pCallbackContext;

    PKEVENT                       pCompletionEvent;

    PSMBCEDB_SERVER_ENTRY         pServerEntry;
    ULONG                         TransportsToBeConstructed;

    PSMBCE_SERVER_TRANSPORT pTransport;

    RX_WORK_QUEUE_ITEM    WorkQueueItem;
} SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT,
  *PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT;

// The SERVER transport dispatch vector prototypes

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_SEND)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_SEND_DATAGRAM)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_TRANCEIVE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_RECEIVE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_INITIALIZE_EXCHANGE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE         pExchange);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_UNINITIALIZE_EXCHANGE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE         pExchange);

typedef
VOID
(*PTRANSPORT_DISPATCH_TEARDOWN)(
    PSMBCE_SERVER_TRANSPORT    pTransport);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_INITIATE_DISCONNECT)(
    PSMBCE_SERVER_TRANSPORT    pTransport);

typedef struct TRANSPORT_DISPATCH_VECTOR {
   PTRANSPORT_DISPATCH_SEND                  Send;
   PTRANSPORT_DISPATCH_SEND_DATAGRAM         SendDatagram;
   PTRANSPORT_DISPATCH_TRANCEIVE             Tranceive;
   PTRANSPORT_DISPATCH_RECEIVE               Receive;
   PRX_WORKERTHREAD_ROUTINE                  TimerEventHandler;
   PTRANSPORT_DISPATCH_INITIALIZE_EXCHANGE   InitializeExchange;
   PTRANSPORT_DISPATCH_UNINITIALIZE_EXCHANGE UninitializeExchange;
   PTRANSPORT_DISPATCH_TEARDOWN              TearDown;
   PTRANSPORT_DISPATCH_INITIATE_DISCONNECT   InitiateDisconnect;
} TRANSPORT_DISPATCH_VECTOR, *PTRANSPORT_DISPATCH_VECTOR;

// A macro for invoking a routine through the SMBCE_SERVER_TRANSPORT
// dispatch vector.

#define SMBCE_TRANSPORT_DISPATCH(pServerEntry,Routine,Arguments)        \
      (*((pServerEntry)->pTransport->pDispatchVector->Routine))##Arguments

// The currently known transport type dispatch vectors and the mechanisms
// for instanting an instance.

extern TRANSPORT_DISPATCH_VECTOR MRxSmbVctTransportDispatch;
extern TRANSPORT_DISPATCH_VECTOR MRxSmbMsTransportDispatch;

extern NTSTATUS
MsInstantiateServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext);

extern NTSTATUS
VctInstantiateServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext);

extern VOID
SmbCeConstructServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext);

// The following routines constitute the interface by which the clients of
// the connection engine initialize/send/receive/uninitialize data to the
// remote servers

extern NTSTATUS
SmbCeInitializeExchangeTransport(
    PSMB_EXCHANGE         pExchange);

extern NTSTATUS
SmbCeUninitializeExchangeTransport(
    PSMB_EXCHANGE         pExchange);

extern NTSTATUS
SmbCeInitiateDisconnect(
    IN OUT PSMBCEDB_SERVER_ENTRY pServerEntry);


// The routines for constructing the transports provide the flexibility to
// construct certain combination of transports. This is provided by the
// SmbCepInitializeServerTransport routine and the different flavours of
// construction routines provided

#define SMBCE_CONSTRUCT_ALL_TRANSPORTS \
            (SMBCE_STT_VC)

extern NTSTATUS
SmbCepInitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                         pServerEntry,
    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK pCallbackRoutine,
    PMRX_SRVCALL_CALLBACK_CONTEXT                 pCallbackContext,
    ULONG                                         TransportsToBeConsstructed);


#define SmbCeInitializeServerTransport(pServerEntry,pCallbackRoutine,pCallbackContext) \
        SmbCepInitializeServerTransport(                                               \
            (pServerEntry),                                                            \
            (pCallbackRoutine),                                                        \
            (pCallbackContext),                                                        \
            SMBCE_CONSTRUCT_ALL_TRANSPORTS)


extern NTSTATUS
SmbCeUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                        pServerEntry,
    PSMBCE_SERVER_TRANSPORT_DESTRUCTION_CALLBACK pCallbackRoutine,
    PVOID                                        pCallbackContext);

extern VOID
SmbCeCompleteUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

extern NTSTATUS
SmbCepReferenceTransport(
    IN OUT PSMBCE_TRANSPORT pTransport);

extern NTSTATUS
SmbCepDereferenceTransport(
    IN OUT PSMBCE_TRANSPORT pTransport);

extern PSMBCE_TRANSPORT
SmbCeFindTransport(
    PUNICODE_STRING pTransportName);

extern NTSTATUS
SmbCepReferenceServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT *pTransportPointer);

extern NTSTATUS
SmbCepDereferenceServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT *pTransportPointer);

extern PFILE_OBJECT
SmbCepReferenceEndpointFileObject(
    IN PSMBCE_SERVER_TRANSPORT pTransport);

extern NTSTATUS
SmbCeSend(
    PSMB_EXCHANGE         pExchange,
    ULONG                 SendOptions,
    PMDL            pSmbMdl,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeSendToServer(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    ULONG                 SendOptions,
    PMDL            pSmbMdl,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeSendDatagram(
    PSMB_EXCHANGE         pExchange,
    ULONG                 SendOptions,
    PMDL            pSmbMdl,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeTranceive(
    PSMB_EXCHANGE         pExchange,
    ULONG                 SendOptions,
    PMDL            pRxCeDataBuffer,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeReceive(
    PSMB_EXCHANGE         pExchange);


//
// Call ups from the transport to the connection engine
//

extern NTSTATUS
SmbCeReceiveInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN ULONG                 BytesIndicated,
    IN ULONG                 BytesAvailable,
    OUT ULONG                *pBytesTaken,
    IN PVOID                 pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL                 *pDataBufferPointer,    // the buffer in which data is to be copied.
    OUT PULONG               pDataBufferSize,        // amount of data to copy
    IN ULONG                 ReceiveFlags
    );

extern NTSTATUS
SmbCeDataReadyInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN PMDL            pBuffer,
    IN ULONG                 DataSize,
    IN NTSTATUS              DataReadyStatus
    );

extern NTSTATUS
SmbCeErrorInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN NTSTATUS              IndicatedStatus
    );

extern NTSTATUS
SmbCeSendCompleteInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN PVOID                 pCompletionContext,
    IN NTSTATUS              SendCompletionStatus
    );

#endif // _TRANSPRT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\transprt.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    transport.c

Abstract:

    This module implements all transport related functions in the SMB connection engine

--*/

#include "precomp.h"
#pragma hdrstop

#include "tdikrnl.h"

NTSTATUS
SmbCeIsServerAvailable(
    PUNICODE_STRING Name
);

VOID
SmbCeServerIsUnavailable(
    PUNICODE_STRING Name,
    NTSTATUS Status
);

VOID
SmbCeDiscardUnavailableServerList( );

VOID
MRxSmbpOverrideBindingPriority(
    PUNICODE_STRING pTransportName,
    PULONG pPriority
    );

VOID
MRxSmbPnPBindingHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  pTransportName,
    IN PWSTR            BindingList
    );

NTSTATUS
MRxSmbPnPPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeFindTransport)
#pragma alloc_text(PAGE, SmbCepInitializeServerTransport)
#pragma alloc_text(PAGE, SmbCeInitializeExchangeTransport)
#pragma alloc_text(PAGE, SmbCeUninitializeExchangeTransport)
#pragma alloc_text(PAGE, SmbCepDereferenceTransport)
#pragma alloc_text(PAGE, MRxSmbpBindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbpBindTransportWorkerThreadRoutine)
#pragma alloc_text(PAGE, MRxSmbpUnbindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbpOverrideBindingPriority)
#pragma alloc_text(PAGE, MRxSmbPnPBindingHandler)
#pragma alloc_text(PAGE, MRxSmbRegisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxSmbDeregisterForPnpNotifications)
#pragma alloc_text(PAGE, SmbCeDereferenceTransportArray)
#pragma alloc_text(PAGE, SmbCeIsServerAvailable)
#pragma alloc_text(PAGE, SmbCeServerIsUnavailable)
#pragma alloc_text(PAGE, SmbCeDiscardUnavailableServerList)
#endif

SMBCE_TRANSPORTS MRxSmbTransports;

//
// The head of the list of servers that are currently unavailable
//
LIST_ENTRY UnavailableServerList = { &UnavailableServerList, &UnavailableServerList };

//
// Each entry in the UnavailableServerList is one of these:
//
typedef struct {
    LIST_ENTRY ListEntry;
    UNICODE_STRING Name;        // Name of server that is unavailable
    NTSTATUS Status;            // Status received when we tried to connect to it
    LARGE_INTEGER Time;         // Time when we last attempted to connect
} *PUNAVAILABLE_SERVER;

//
// Protects UnavailableServerList
//
ERESOURCE  UnavailableServerListResource = {0};

//
// Time (seconds) that we keep an entry in the UnavailableServerList.
// We will not retry a connection attempt to a server
//  for UNAVAILABLE_SERVER_TIME seconds
//
#define UNAVAILABLE_SERVER_TIME 10

RXDT_DefineCategory(TRANSPRT);
#define Dbg        (DEBUG_TRACE_TRANSPRT)

NTSTATUS
MRxSmbInitializeTransport()
/*++

Routine Description:

    This routine initializes the transport related data structures

Returns:

    STATUS_SUCCESS if the transport data structures was successfully initialized

Notes:

--*/
{
    KeInitializeSpinLock(&MRxSmbTransports.Lock);

    MRxSmbTransports.pTransportArray = NULL;

    ExInitializeResource( &UnavailableServerListResource );

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbUninitializeTransport()
/*++

Routine Description:

    This routine uninitializes the transport related data structures

Notes:

--*/
{
    PSMBCE_TRANSPORT pTransport;
    KIRQL            SavedIrql;
    ULONG            TransportCount = 0;
    PSMBCE_TRANSPORT_ARRAY pTransportArray = NULL;

    KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);

    if (MRxSmbTransports.pTransportArray != NULL) {
        pTransportArray = MRxSmbTransports.pTransportArray;
        MRxSmbTransports.pTransportArray = NULL;
    }

    KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

    if (pTransportArray != NULL) {
        SmbCeDereferenceTransportArray(pTransportArray);
    }

    SmbCeDiscardUnavailableServerList();

    ExDeleteResource( &UnavailableServerListResource );

    return STATUS_SUCCESS;
}


NTSTATUS
SmbCeAddTransport(
    PSMBCE_TRANSPORT pNewTransport)
/*++

Routine Description:

    This routine adds a new instance to the known list of transports

Parameters:

    pNewTransport -- the transport instance to be added

Notes:

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    KIRQL                   SavedIrql;

    LONG                    Count;
    PSMBCE_TRANSPORT_ARRAY  pNewTransportArray = NULL;
    PSMBCE_TRANSPORT_ARRAY  pOldTransportArray;
    PSMBCE_TRANSPORT        *pTransports = NULL;
    PRXCE_ADDRESS           *LocalAddresses = NULL;

    SmbCeAcquireResource();

    pOldTransportArray = SmbCeReferenceTransportArray();

    if (pOldTransportArray != NULL)
        Count = pOldTransportArray->Count + 1;
    else
        Count = 1;

    pNewTransportArray = (PSMBCE_TRANSPORT_ARRAY)RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(SMBCE_TRANSPORT_ARRAY),
                                MRXSMB_TRANSPORT_POOLTAG);
    if (pNewTransportArray == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        pTransports = (PSMBCE_TRANSPORT *)RxAllocatePoolWithTag(
                             NonPagedPool,
                             Count * sizeof(PSMBCE_TRANSPORT),
                             MRXSMB_TRANSPORT_POOLTAG);
        if (pTransports == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    if (Status == STATUS_SUCCESS) {
        LocalAddresses = (PRXCE_ADDRESS *)RxAllocatePoolWithTag(
                             NonPagedPool,
                             Count * sizeof(PRXCE_ADDRESS),
                             MRXSMB_TRANSPORT_POOLTAG);
        if (LocalAddresses == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (Status == STATUS_SUCCESS) {
        LONG  i;

        if (Count > 1) {
            PSMBCE_TRANSPORT *pOldTransports;

            pOldTransports = pOldTransportArray->SmbCeTransports;

            for (i=0;i<Count-1;i++) {
                if (pNewTransport->Priority < pOldTransports[i]->Priority) { // The lower number, the higher priority
                    break;
                }
                pTransports[i] = pOldTransports[i];
                LocalAddresses[i] = &pOldTransports[i]->RxCeAddress;
            }
            pTransports[i] = pNewTransport;
            LocalAddresses[i] = &pNewTransport->RxCeAddress;
            for (;i<Count-1;i++) {
                pTransports[i+1] = pOldTransports[i];
                LocalAddresses[i+1] = &pOldTransports[i]->RxCeAddress;
            }

        } else {
            pTransports[0] = pNewTransport;
            LocalAddresses[0] = &pNewTransport->RxCeAddress;
        }

        for(i=0;i<Count;i++)
            SmbCeReferenceTransport(pTransports[i]);

        pNewTransportArray->ReferenceCount = 1;
        pNewTransportArray->Count = Count;
        pNewTransportArray->SmbCeTransports = &pTransports[0];
        pNewTransportArray->LocalAddresses = &LocalAddresses[0];

        KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);
        MRxSmbTransports.pTransportArray = pNewTransportArray;
        KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

        // Double dereferencing is necessary to ensure that
        // the old transport array is destroyed.

        SmbCeDereferenceTransportArray(pOldTransportArray);
    }

    SmbCeDereferenceTransportArray(pOldTransportArray);

    SmbCeReleaseResource();

    if (Status != STATUS_SUCCESS) {
        if (pNewTransportArray != NULL) {
            RxFreePool(pNewTransportArray);
        }
        if (pTransports != NULL) {
            RxFreePool(pTransports);
        }
        if (LocalAddresses != NULL) {
            RxFreePool(LocalAddresses);
        }
    }

    SmbCeDiscardUnavailableServerList();

    return Status;
}

NTSTATUS
SmbCeRemoveTransport(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine removes a transport from the list of known transports

Parameters:

    pTransport - the transport instance to be removed.

Notes:

--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    KIRQL                   SavedIrql;

    LONG                    Count;
    PSMBCE_TRANSPORT_ARRAY  pTransportArray = NULL;
    PSMBCE_TRANSPORT_ARRAY  pOldTransportArray = NULL;
    PSMBCE_TRANSPORT        *pTransports = NULL;
    PRXCE_ADDRESS           *pLocalAddresses = NULL;

    SmbCeAcquireResource();

    pOldTransportArray = SmbCeReferenceTransportArray();

    if (pOldTransportArray != NULL) {
        LONG                Index;
        BOOLEAN             Found = FALSE;
        PSMBCE_TRANSPORT    *pOldTransports;

        // Establish the fact that the given transport is part of the array.
        // if it is not then no further action is necessary

        pOldTransports = pOldTransportArray->SmbCeTransports;

        for (Index = 0; Index < (LONG)pOldTransportArray->Count; Index++) {
            if (pTransport == pOldTransports[Index]) {
                Found = TRUE;
            }
        }

        if (Found) {
            Count = pOldTransportArray->Count - 1;

            if (Count > 0) {


                pTransportArray = (PSMBCE_TRANSPORT_ARRAY)RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     sizeof(SMBCE_TRANSPORT_ARRAY),
                                     MRXSMB_TRANSPORT_POOLTAG);
                if (pTransportArray == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                if (Status == STATUS_SUCCESS) {
                    pTransports = (PSMBCE_TRANSPORT *)RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     Count * sizeof(PSMBCE_TRANSPORT),
                                     MRXSMB_TRANSPORT_POOLTAG);
                    if (pTransports == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (Status == STATUS_SUCCESS) {
                    pLocalAddresses = (PRXCE_ADDRESS *)RxAllocatePoolWithTag(
                                         NonPagedPool,
                                         Count * sizeof(PRXCE_ADDRESS),
                                         MRXSMB_TRANSPORT_POOLTAG);
                    if (pLocalAddresses == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (Status == STATUS_SUCCESS) {
                    LONG i, j;

                    for (i=0, j=0;i<Count+1;i++) {
                        if (pTransport != pOldTransports[i]) {
                            pTransports[j] = pOldTransports[i];
                            pLocalAddresses[j] = &pOldTransports[i]->RxCeAddress;
                            j++;
                        }
                    }

                    for(i=0;i<Count;i++)
                        SmbCeReferenceTransport(pTransports[i]);

                    pTransportArray->ReferenceCount = 1;
                    pTransportArray->Count = Count;
                    pTransportArray->SmbCeTransports = &pTransports[0];
                    pTransportArray->LocalAddresses = &pLocalAddresses[0];
                }
            }

            if (Status == STATUS_SUCCESS) {
                KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);
                MRxSmbTransports.pTransportArray = pTransportArray;
                KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

                // Double dereferencing is necessary to ensure that
                // the old transport array is destroyed.

                SmbCeDereferenceTransportArray(pOldTransportArray);
            } else {
                if (pTransportArray != NULL) {
                    RxFreePool(pTransportArray);
                }

                if (pTransports != NULL) {
                    RxFreePool(pTransports);
                }

                if (pLocalAddresses != NULL) {
                    RxFreePool(pLocalAddresses);
                }
            }
        }

        SmbCeDereferenceTransportArray(pOldTransportArray);
    }

    SmbCeReleaseResource();

    SmbCeDiscardUnavailableServerList();

    return Status;
}


PSMBCE_TRANSPORT
SmbCeFindTransport(
    PUNICODE_STRING pTransportName)
/*++

Routine Description:

    This routine maps a transport name to the appropriate
    PSMBCE_TRANSPORT instance

Arguments:

    pTransportName - the transport name

Return Value:

    a valid PSMBCE_TRANSPORT if one exists otherwise NULL

Notes:

--*/
{
    KIRQL                   SavedIrql;
    PLIST_ENTRY             pEntry;
    PSMBCE_TRANSPORT        pTransport;
    BOOLEAN                 Found = FALSE;
    PSMBCE_TRANSPORT_ARRAY  pTransportArray;

    PAGED_CODE();

    pTransportArray = SmbCeReferenceTransportArray();

    if (pTransportArray == NULL) {
        RxDbgTrace(0, Dbg, ("SmbCeFindTransport : Transport not available.\n"));
        return NULL;
    }

    if (pTransportArray != NULL) {
        ULONG i;

        for (i=0;i<pTransportArray->Count;i++) {
            pTransport = pTransportArray->SmbCeTransports[i];

            if (RtlEqualUnicodeString(
                    &pTransport->RxCeTransport.Name,
                    pTransportName,
                    TRUE)) {
                SmbCeReferenceTransport(pTransport);
                Found = TRUE;
                break;
            }
        }
    }

    if (!Found) {
        pTransport = NULL;
    }

    SmbCeDereferenceTransportArray(pTransportArray);

    return pTransport;
}


VOID
SmbCepTearDownServerTransport(
    PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine uninitializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Notes:


--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SMBCEDB_SERVER_TYPE     ServerType   = SmbCeGetServerType(pServerEntry);

    BOOLEAN WaitForTransportRundown = FALSE;
    BOOLEAN TearDown = FALSE;

    SmbCeAcquireSpinLock();

    if (!pServerEntry->IsTransportDereferenced) {

        // ServerEntry takes only one reference count of transport, which should only be
        // dereferenced once when it comes to tear down transport. Multiple dereference called
        // from construct server transport and PNP unbind transport needs to be prevented.
        pServerEntry->IsTransportDereferenced = TRUE;
        TearDown = TRUE;

        KeInitializeEvent(&pServerEntry->TransportRundownEvent,NotificationEvent,FALSE);

        if (pServerEntry->pTransport != NULL) {
            pServerEntry->pTransport->State = SMBCEDB_MARKED_FOR_DELETION;
            pServerEntry->pTransport->pRundownEvent = &pServerEntry->TransportRundownEvent;

            WaitForTransportRundown = TRUE;
        }
    } else {
        if (pServerEntry->pTransport != NULL) {
            WaitForTransportRundown = TRUE;
        }
    }

    SmbCeReleaseSpinLock();

    if (TearDown) {
        if (pServerEntry->pTransport != NULL) {
            SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
        }
    }

    if (WaitForTransportRundown) {
        KeWaitForSingleObject(
            &pServerEntry->TransportRundownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL );
    }
}

VOID
SmbCeTearDownServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
/*++

Routine Description:

    This routine tears down the server transport instance

Arguments:

    pContext - the server transport construction context

Notes:


--*/
{
    SmbCepTearDownServerTransport(pContext->pServerEntry);

    if (pContext->pCompletionEvent != NULL) {
        ASSERT(pContext->pCallbackContext == NULL);
        ASSERT(pContext->pCompletionRoutine == NULL);
        KeSetEvent(
            pContext->pCompletionEvent,
            0,
            FALSE );
    } else if (pContext->pCallbackContext != NULL) {
        ASSERT(pContext->pCompletionEvent == NULL);
        (pContext->pCompletionRoutine)(pContext->pCallbackContext);
    }

    RxFreePool(pContext);
}

VOID
SmbCepUpdateTransportConstructionState(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
{
    SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE State;

    if (pContext->Status == STATUS_SUCCESS) {
        if (pContext->TransportsToBeConstructed & SMBCE_STT_VC) {
            pContext->TransportsToBeConstructed &= ~SMBCE_STT_VC;
            State = SmbCeServerVcTransportConstructionBegin;
        } else {
            State = SmbCeServerTransportConstructionEnd;
        }
    } else {
        State = SmbCeServerTransportConstructionEnd;
    }

    pContext->State = State;
}

VOID
SmbCeConstructServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
/*++

Routine Description:

    This routine constructs the server transport instance

Arguments:

    pContext - the server transport construction context

Notes:


--*/
{
    NTSTATUS               Status;
    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    SMBCEDB_SERVER_TYPE    ServerType;

    BOOLEAN  ContinueConstruction = TRUE;
    BOOLEAN  UpdateUnavailableServerlist = TRUE;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pServerEntry = pContext->pServerEntry;
    ServerType   = SmbCeGetServerType(pServerEntry);

    do {
        switch (pContext->State) {
        case  SmbCeServerTransportConstructionBegin :
            {
                if (pServerEntry->pTransport != NULL) {
                    SmbCepTearDownServerTransport(pServerEntry);
                }

                ASSERT(pServerEntry->pTransport == NULL);

                pContext->Status = STATUS_SUCCESS;

                // See if we have any reason to believe this server is unavailable
                pContext->Status = SmbCeIsServerAvailable( &pServerEntry->Name );

                if (pContext->Status != STATUS_SUCCESS) {
                    UpdateUnavailableServerlist = FALSE;
                }

                SmbCepUpdateTransportConstructionState(pContext);
            }
            break;

        case SmbCeServerVcTransportConstructionBegin:
            {
                Status = VctInstantiateServerTransport(
                            pContext);

                if (Status == STATUS_PENDING) {
                    ContinueConstruction = FALSE;
                    break;
                }

                ASSERT(pContext->State == SmbCeServerVcTransportConstructionEnd);
            }
            // lack of break intentional

        case SmbCeServerVcTransportConstructionEnd:
            {
                SmbCepUpdateTransportConstructionState(pContext);
            }
            break;

        case SmbCeServerTransportConstructionEnd:
            {
                pServerEntry->ServerStatus = pContext->Status;

                if (pServerEntry->ServerStatus == STATUS_SUCCESS) {
                    SmbCeAcquireSpinLock();

                    if (pContext->pTransport != NULL) {
                        pContext->pTransport->SwizzleCount = 1;
                    }

                    pServerEntry->pTransport         = pContext->pTransport;

                    pContext->pTransport = NULL;

                    if (pContext->pCallbackContext != NULL) {
                        pContext->pCallbackContext->Status = STATUS_SUCCESS;
                    }

                    pServerEntry->IsTransportDereferenced = FALSE;

                    SmbCeReleaseSpinLock();
                } else {
                    PRX_CONTEXT pRxContext =  NULL;

                    if (UpdateUnavailableServerlist) {
                        SmbCeServerIsUnavailable( &pServerEntry->Name, pServerEntry->ServerStatus );
                    }

                    if (pContext->pTransport != NULL) {
                        pContext->pTransport->pDispatchVector->TearDown(
                            pContext->pTransport);
                    }

                    pContext->pTransport = NULL;
                    pServerEntry->pTransport = NULL;

                    if ((pContext->pCallbackContext) &&
                        (pContext->pCallbackContext->SrvCalldownStructure)) {
                        pRxContext =
                            pContext->pCallbackContext->SrvCalldownStructure->RxContext;
                    }

                    if (pContext->pCallbackContext != NULL) {
                        pContext->pCallbackContext->Status = pServerEntry->ServerStatus;
                    }
                }

                if (pContext->pCompletionEvent != NULL) {
                    ASSERT(pContext->pCallbackContext == NULL);
                    ASSERT(pContext->pCompletionRoutine == NULL);
                    KeSetEvent(
                        pContext->pCompletionEvent,
                        0,
                        FALSE );
                } else if (pContext->pCallbackContext != NULL) {
                    ASSERT(pContext->pCompletionEvent == NULL);

                    (pContext->pCompletionRoutine)(pContext->pCallbackContext);
                } else {
                    ASSERT(!"ill formed transport initialization context");
                }

                // pServerEntry->ConstructionContext = NULL;
                RxFreePool(pContext);

                ContinueConstruction = FALSE;
            }
        }
    } while (ContinueConstruction);
}

NTSTATUS
SmbCepInitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                         pServerEntry,
    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK pCallbackRoutine,
    PMRX_SRVCALL_CALLBACK_CONTEXT                 pCallbackContext,
    ULONG                                         TransportsToBeConstructed)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

    pCallbackRoutine - the callback routine

    pCallbackContext - the callback context

    TransportsToBeConstructed -- the transports to be constructed

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Currently, only connection oriented transports are handled.

--*/
{
    NTSTATUS Status;

    BOOLEAN  CompleteConstruction;

    PAGED_CODE();

    if ((pServerEntry->ServerStatus == STATUS_SUCCESS) &&
        (pServerEntry->pTransport != NULL)) {
        Status = STATUS_SUCCESS;
        CompleteConstruction = TRUE;
    } else {
        PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext;

        pContext = RxAllocatePoolWithTag(
                       NonPagedPool,
                       sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT),
                       MRXSMB_TRANSPORT_POOLTAG);

        CompleteConstruction = (pContext == NULL);

        if (pContext != NULL) {
            KEVENT  CompletionEvent;

            RtlZeroMemory(
                pContext,
                sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT));

            pContext->Status             = STATUS_SUCCESS;
            pContext->pServerEntry       = pServerEntry;
            pContext->State              = SmbCeServerTransportConstructionBegin;
            pContext->TransportsToBeConstructed = TransportsToBeConstructed;

            if (pCallbackContext == NULL) {
                KeInitializeEvent(
                    &CompletionEvent,
                    NotificationEvent,
                    FALSE);

                pContext->pCompletionEvent = &CompletionEvent;
            } else {
                pContext->pCallbackContext   = pCallbackContext;
                pContext->pCompletionRoutine = pCallbackRoutine;
            }

            pServerEntry->ConstructionContext = (PVOID)pContext;

            Status = STATUS_PENDING;

            if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                SmbCeConstructServerTransport(pContext);
            } else {
                Status = RxPostToWorkerThread(
                             MRxSmbDeviceObject,
                             CriticalWorkQueue,
                             &pContext->WorkQueueItem,
                             SmbCeConstructServerTransport,
                             pContext);

                if (Status == STATUS_SUCCESS) {
                    Status = STATUS_PENDING;
                } else {
                    pServerEntry->ConstructionContext = NULL;
                    RxFreePool(pContext);
                    CompleteConstruction = TRUE;
                }
            }

            if ((Status == STATUS_PENDING) && (pCallbackContext == NULL)) {
                KeWaitForSingleObject(
                    &CompletionEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL );

                Status = pServerEntry->ServerStatus;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (CompleteConstruction) {
        pServerEntry->ServerStatus = Status;

        if (pCallbackRoutine != NULL) {
            pCallbackContext->Status = Status;

            (pCallbackRoutine)(pCallbackContext);

            Status = STATUS_PENDING;
        }
    }

    return Status;
}

NTSTATUS
SmbCeUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                        pServerEntry,
    PSMBCE_SERVER_TRANSPORT_DESTRUCTION_CALLBACK pCallbackRoutine,
    PVOID                                        pCallbackContext)
/*++

Routine Description:

    This routine uninitializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Returns:

    STATUS_SUCCESS if successful

Notes:

    Currently, only connection oriented transports are handled.

    In order to handle async. operations the uninitialization has to be coordinated
    with the referencing mechanism. It is for this reason that this routine sets up
    a rundown event and waits for it to be set.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if (pCallbackRoutine == NULL &&
        IoGetCurrentProcess() == RxGetRDBSSProcess()) {
        SmbCepTearDownServerTransport(pServerEntry);
    } else {
        PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext;

        pContext = RxAllocatePoolWithTag(
                       NonPagedPool,
                       sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT),
                       MRXSMB_TRANSPORT_POOLTAG);

        if (pContext != NULL) {
            KEVENT  CompletionEvent;

            RtlZeroMemory(
                pContext,
                sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT));

            pContext->Status = STATUS_SUCCESS;
            pContext->pServerEntry = pServerEntry;

            if (pCallbackRoutine == NULL) {
                KeInitializeEvent(
                    &CompletionEvent,
                    NotificationEvent,
                    FALSE);

                pContext->pCompletionEvent = &CompletionEvent;
            } else {
                pContext->pCallbackContext   = pCallbackContext;
                pContext->pCompletionRoutine = pCallbackRoutine;
            }

            if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                SmbCeTearDownServerTransport(pContext);
            } else {
                Status = RxPostToWorkerThread(
                             MRxSmbDeviceObject,
                             CriticalWorkQueue,
                             &pContext->WorkQueueItem,
                             SmbCeTearDownServerTransport,
                             pContext);
            }

            if (Status == STATUS_SUCCESS) {
                if (pCallbackRoutine == NULL) {
                    KeWaitForSingleObject(
                        &CompletionEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL );
                } else {
                    Status = STATUS_PENDING;
                }
            } else {
                RxFreePool(pContext);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return Status;
}

VOID
SmbCeCompleteUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
{
    // in case of async uninitialize server transport, an additional reference count of
    // server entry should be taken so that uninitialize server transport will not be
    // called once again from tear down server entry if its reference count comes to 0
    // before uninitialize server transport is done.
    SmbCeDereferenceServerEntry(pServerEntry);
}

NTSTATUS
SmbCeInitiateDisconnect(
    PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine initiates the TDI disconnect

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMBCE_SERVER_TRANSPORT pTransport;

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    Status = SmbCeReferenceServerTransport(&pServerEntry->pTransport);

    if (Status == STATUS_SUCCESS) {
        Status = (pServerEntry->pTransport->pDispatchVector->InitiateDisconnect)(
                    pServerEntry->pTransport);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg, ("SmbCeInitiateDisconnect : Status %lx\n",Status));
        }

        SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
    }

    return STATUS_SUCCESS;
}

LONG Initializes[SENTINEL_EXCHANGE] = {0,0,0,0};
LONG Uninitializes[SENTINEL_EXCHANGE] = {0,0,0,0};

NTSTATUS
SmbCeInitializeExchangeTransport(
   PSMB_EXCHANGE         pExchange)
/*++

Routine Description:

    This routine initializes the transport associated with the exchange

Arguments:

    pExchange - the exchange to be initialized

Return Value:

    STATUS_SUCCESS - the exchange transport initialization has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    Status = pExchange->SmbStatus;
    if (Status == STATUS_SUCCESS) {
        PSMBCE_SERVER_TRANSPORT *pTransportPointer;

        pTransportPointer = &pServerEntry->pTransport;

        if (*pTransportPointer != NULL) {
            Status = SmbCeReferenceServerTransport(pTransportPointer);

            if (Status == STATUS_SUCCESS) {
                Status = ((*pTransportPointer)->pDispatchVector->InitializeExchange)(
                             *pTransportPointer,
                             pExchange);

                if (Status == STATUS_SUCCESS) {
                    ULONG TransportInitialized;

                    InterlockedIncrement(&Initializes[pExchange->Type]);
                    TransportInitialized = InterlockedExchange(&pExchange->ExchangeTransportInitialized,1);
                    ASSERT(TransportInitialized == 0);
                } else {
                    SmbCeDereferenceServerTransport(pTransportPointer);
                }
            }
        } else {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
   }

   return Status;
}

NTSTATUS
SmbCeUninitializeExchangeTransport(
   PSMB_EXCHANGE         pExchange)
/*++

Routine Description:

    This routine uniinitializes the transport associated with the exchange

Arguments:

    pExchange - the exchange to be initialized

Return Value:

    STATUS_SUCCESS - the exchange transport initialization has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    if (InterlockedExchange(&pExchange->ExchangeTransportInitialized,0)==1) {
        PSMBCE_SERVER_TRANSPORT *pTransportPointer;

        pTransportPointer = &pServerEntry->pTransport;

        if (*pTransportPointer != NULL) {
            Status = ((*pTransportPointer)->pDispatchVector->UninitializeExchange)(
                        *pTransportPointer,
                        pExchange);

            SmbCeDereferenceServerTransport(pTransportPointer);
            InterlockedIncrement(&Uninitializes[pExchange->Type]);

            return Status;
        } else {
            return STATUS_CONNECTION_DISCONNECTED;
        }
    } else {
        return pExchange->SmbStatus;
    }
}

NTSTATUS
SmbCepReferenceServerTransport(
    PSMBCE_SERVER_TRANSPORT *pServerTransportPointer)
/*++

Routine Description:

    This routine references the transport associated with a server entry

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport was successfully referenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    SmbCeAcquireSpinLock();

    if (*pServerTransportPointer != NULL &&
        (*pServerTransportPointer)->State == SMBCEDB_ACTIVE) {
        InterlockedIncrement(&(*pServerTransportPointer)->SwizzleCount);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    SmbCeReleaseSpinLock();

    return Status;
}

NTSTATUS
SmbCepDereferenceServerTransport(
    PSMBCE_SERVER_TRANSPORT *pServerTransportPointer)
/*++

Routine Description:

    This routine dereferences the transport associated with a server entry

Arguments:

    pServerTransportPointer - the server entry transport instance pointer

Return Value:

    STATUS_SUCCESS - the server transport was successfully dereferenced

    Other Status codes correspond to error situations.

Notes:

    On finalization this routine sets the event to enable the process awaiting
    tear down to restart. It also tears down the associated server transport
    instance.

    As a side effect the pointer value is set to NULL under the protection of a
    spin lock.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    SmbCeAcquireSpinLock();

    if (*pServerTransportPointer != NULL) {
        LONG    FinalRefCount;
        PKEVENT pRundownEvent;
        PSMBCE_SERVER_TRANSPORT pServerTransport;

        pServerTransport = *pServerTransportPointer;

        FinalRefCount = InterlockedDecrement(&pServerTransport->SwizzleCount);

        if (FinalRefCount == 0) {
            pServerTransport->State = SMBCEDB_INVALID;

            // transport is set to NULL before the spinlock is release so that no
            // exchange should reference it after it's been torn down
            *pServerTransportPointer = NULL;
            pRundownEvent = pServerTransport->pRundownEvent;
        }

        SmbCeReleaseSpinLock();

        if (FinalRefCount == 0) {
            if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                pServerTransport->pDispatchVector->TearDown(pServerTransport);
            } else {
                Status = RxDispatchToWorkerThread(
                             MRxSmbDeviceObject,
                             CriticalWorkQueue,
                             pServerTransport->pDispatchVector->TearDown,
                             pServerTransport);
            }
        }
    } else {
        SmbCeReleaseSpinLock();
        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    return Status;
}


NTSTATUS
SmbCepReferenceTransport(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine references the transport instance

Arguments:

    pTransport - the transport instance

Return Value:

    STATUS_SUCCESS - the server transport was successfully referenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (pTransport != NULL) {
        SmbCeAcquireSpinLock();

        if (pTransport->Active) {
            InterlockedIncrement(&pTransport->SwizzleCount);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }

        SmbCeReleaseSpinLock();
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
SmbCepDereferenceTransport(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine dereferences the transport

Arguments:

    pTransport - the transport instance

Return Value:

    STATUS_SUCCESS - the server transport was successfully dereferenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AttachToSystemProcess = FALSE;
    KAPC_STATE ApcState;

    PAGED_CODE();

    if (pTransport != NULL) {
        LONG FinalRefCount;

        FinalRefCount = InterlockedDecrement(&pTransport->SwizzleCount);

        if (FinalRefCount == 0) {
            SmbCeRemoveTransport(pTransport);

            if (IoGetCurrentProcess() != RxGetRDBSSProcess()) {
                KeStackAttachProcess(RxGetRDBSSProcess(),&ApcState);
                AttachToSystemProcess = TRUE;
            }

            RxCeTearDownAddress(&pTransport->RxCeAddress);

            RxCeTearDownTransport(&pTransport->RxCeTransport);

            if (AttachToSystemProcess) {
                KeUnstackDetachProcess(&ApcState);
            }

            RxFreePool(pTransport);
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}







HANDLE MRxSmbTdiNotificationHandle = NULL;

KEVENT TdiNetStartupCompletionEvent;

LONG   TdiBindRequestsActive = 0;

BOOLEAN TdiPnpNetReadyEventReceived = FALSE;

// The TRANSPORT_BIND_CONTEXT contains the result of the priority determination
// as well as the name. The priority is used to order the transports in the order
// in which connection attempts will be made

typedef struct _TRANSPORT_BIND_CONTEXT_ {
    ULONG           Priority;
    UNICODE_STRING  TransportName;
} TRANSPORT_BIND_CONTEXT, *PTRANSPORT_BIND_CONTEXT;

VOID
SmbCeSignalNetReadyEvent()
/*++

Routine Description:

    The routine signals the net ready event if all the bind requests
    have been completed and if the net ready event has been received from TDI

Arguments:

--*/
{
    BOOLEAN SignalNetReadyEvent = FALSE;

    SmbCeAcquireSpinLock();

    if (TdiPnpNetReadyEventReceived &&
        TdiBindRequestsActive == 0) {
        SignalNetReadyEvent = TRUE;
    }

    SmbCeReleaseSpinLock();

    if (SignalNetReadyEvent) {
        KeSetEvent(
            &TdiNetStartupCompletionEvent,
            IO_NETWORK_INCREMENT,
            FALSE);
    }
}

VOID
MRxSmbpBindTransportCallback(
    IN PTRANSPORT_BIND_CONTEXT pTransportContext)
/*++

Routine Description:

    TDI calls this routine whenever a transport creates a new device object.

Arguments:

    TransportName - the name of the newly created device object

    TransportBindings - the transport bindings ( multi sz)

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCE_TRANSPORT   pTransport;

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

    PUNICODE_STRING pTransportName;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pTransportName = &pTransportContext->TransportName;

    RxDbgTrace( 0, Dbg, ("MrxSmbpBindTransportCallback, Transport Name = %wZ\n", pTransportName ));

    pTransport = RxAllocatePoolWithTag(
                     NonPagedPool,
                     sizeof(SMBCE_TRANSPORT),
                     MRXSMB_TRANSPORT_POOLTAG);

    if (pTransport != NULL) {
        Status = RxCeBuildTransport(
                     &pTransport->RxCeTransport,
                     pTransportName,
                     0xffff);

        if (Status == STATUS_SUCCESS) {
            PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

            pProviderInfo = pTransport->RxCeTransport.pProviderInfo;

            if (!(pProviderInfo->ServiceFlags & TDI_SERVICE_CONNECTION_MODE) ||
                !(pProviderInfo->ServiceFlags & TDI_SERVICE_ERROR_FREE_DELIVERY)) {
                RxCeTearDownTransport(
                    &pTransport->RxCeTransport);

                Status = STATUS_PROTOCOL_UNREACHABLE;

                RxFreePool(pTransport);
            }
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        // The connection capabilities match the capabilities required by the
        // SMB mini redirector. Attempt to register the local address with the
        // transport and if successful update the local transport list to include
        // this transport for future connection considerations.

        OEM_STRING   OemServerName;
        CHAR  TransportAddressBuffer[TDI_TRANSPORT_ADDRESS_LENGTH +
                          TDI_ADDRESS_LENGTH_NETBIOS];
        PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)TransportAddressBuffer;
        PTDI_ADDRESS_NETBIOS pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)pTransportAddress->Address[0].Address;

        pTransportAddress->TAAddressCount = 1;
        pTransportAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
        pTransportAddress->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS;
        pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        OemServerName.MaximumLength = NETBIOS_NAME_LEN;
        OemServerName.Buffer        = pNetbiosAddress->NetbiosName;

        Status = RtlUpcaseUnicodeStringToOemString(
                     &OemServerName,
                     &SmbCeContext.ComputerName,
                     FALSE);

        if (NT_SUCCESS(Status)) {
            // Ensure that the name is always of the desired length by padding
            // white space to the end.
            RtlCopyMemory(
                &OemServerName.Buffer[OemServerName.Length],
                "                ",
                NETBIOS_NAME_LEN - OemServerName.Length);

            OemServerName.Buffer[NETBIOS_NAME_LEN - 1] = '\0';

            // Register the Transport address for this mini redirector with the connection
            // engine.

            Status = RxCeBuildAddress(
                        &pTransport->RxCeAddress,
                        &pTransport->RxCeTransport,
                        pTransportAddress,
                        &MRxSmbVctAddressEventHandler,
                        &SmbCeContext);

            if (Status == STATUS_SUCCESS) {
                RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Adding new transport\n"));

                pTransport->Active       = TRUE;
                pTransport->Priority     = pTransportContext->Priority;
                pTransport->SwizzleCount = 0;

                pTransport->ObjectCategory = SMB_SERVER_TRANSPORT_CATEGORY;
                pTransport->ObjectType     = SMBCEDB_OT_TRANSPORT;
                pTransport->State          = 0;
                pTransport->Flags          = 0;

                SmbCeAddTransport(pTransport);
                RxDbgTrace( 0, Dbg, ("MrxSmbpBindTransportCallback, Transport %wZ added\n", pTransportName ));
            } else {
                RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Address registration failed %lx\n",Status));
            }
        }

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace( 0, Dbg, ("MrxSmbpBindTransportCallback, Transport %wZ unreachable 0x%x\n",
                                 pTransportName, Status ));
            RxCeTearDownTransport(
                &pTransport->RxCeTransport);

            Status = STATUS_PROTOCOL_UNREACHABLE;
            RxFreePool(pTransport);
        }
    }

    InterlockedDecrement(&TdiBindRequestsActive);
    SmbCeSignalNetReadyEvent();
}

VOID
MRxSmbpBindTransportWorkerThreadRoutine(
    IN PTRANSPORT_BIND_CONTEXT pTransportContext)
/*++

Routine Description:

    The TDI callbacks always do not occur in the context of the FSP process.
    Since there are a few TDi interfaces that accept handles we need to ensure
    that such calls always gets funnelled back to the FSP.

Arguments:

    pTransportContext - the transport binding context

--*/
{
    PAGED_CODE();

    MRxSmbpBindTransportCallback(pTransportContext);

    RxFreePool(pTransportContext);
}

VOID
MRxSmbpUnbindTransportCallback(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    The Unbind callback routine which is always executed in the context of the
    RDR process so that handles can be closed correctly

Arguments:

    pTransport - the transport for which the PNP_OP_DEL was received

Notes:

    On entry to this routine the appropriate transport must have been referenced
    This routine will dereference it and invalidate the existing exchanges using
    this transport.

--*/
{
    PAGED_CODE();

    // Remove this transport from the list of transports under consideration
    // in the mini redirector.

    SmbCeRemoveTransport(pTransport);

    // Enumerate the servers and mark those servers utilizing this transport
    // as having an invalid transport.
    SmbCeHandleTransportInvalidation(pTransport);

    // dereference the transport
    SmbCeDereferenceTransport(pTransport);
}


VOID
MRxSmbpOverrideBindingPriority(
    PUNICODE_STRING pTransportName,
    PULONG pPriority
    )

/*++

Routine Description:

This function obtains a overriding priority value from the registry for a given
transport.

The priority of a transport controls the order in which connections are accepted.  It is
sometimes useful for a customer to control which transport is used first in the redirector.

The priority is usually determined by the order of the transports in the binding list.  With
the new Connections UI model for network setup, it will no longer be possible to adjust
the order of the bindings in the binding list.  Thus, another mechanism is needed when the
user wants to override the priority assigned to a given binding.

Arguments:

    pTransportName - pointer to UNICODE_STRING descriptor for transport string, for example
        "\Device\Netbt_tcpip_{guid}"
    pPriority - pointer to LONG to receive new priority on success, otherwise not touched

Return Value:

    None

--*/

{
    WCHAR valueBuffer[128];
    UNICODE_STRING path, value, key;
    USHORT length,ulength;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    HANDLE parametersHandle;
    ULONG temp;

    PAGED_CODE();

    // Validate input

    if (pTransportName->Length == 0) {
        return;
    }

    // Open parameters key

    RtlInitUnicodeString( &path, SMBMRX_MINIRDR_PARAMETERS );

    InitializeObjectAttributes(
        &objectAttributes,
        &path,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = ZwOpenKey (&parametersHandle, KEY_READ, &objectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Construct value name = "BindingPriority" + transportname
    // First, find the last slash.  Then form the value from the prefix and
    // the remainder of the transport name.
    ulength = pTransportName->Length / sizeof(WCHAR);
    for( length = ulength - 1; length != 0; length-- ) {
        if (pTransportName->Buffer[length] == L'\\') {
            break;
        }
    }

    length++;
    key.Buffer = pTransportName->Buffer + length;
    key.Length = (ulength - length) * sizeof(WCHAR);

    value.Buffer = valueBuffer;
    value.MaximumLength = 128 * sizeof(WCHAR);
    value.Length = 0;

    RtlAppendUnicodeToString( &value, L"BindingPriority" );
    RtlAppendUnicodeStringToString( &value, &key );

    // Check if the value is present.  If so, replace priority
    // A value of zero is valid and indicates do not bind this one

    status = MRxSmbGetUlongRegistryParameter(
                 parametersHandle,
                 value.Buffer,
                 (PULONG)&temp,
                 FALSE );

    if (NT_SUCCESS(status)) {
        *pPriority = temp;
    }

    ZwClose(parametersHandle);
}

VOID
MRxSmbPnPBindingHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  pTransportName,
    IN PWSTR            BindingList)
/*++

Routine Description:

    The TDI callbacks routine for binding changes

Arguments:

    PnPOpcode - the PNP op code

    pTransportName - the transport name

    BindingList - the binding order

--*/
{
    ULONG Priority;

    PAGED_CODE();

    switch (PnPOpcode) {
    case TDI_PNP_OP_ADD:
        {
            BOOLEAN        fBindToTransport = FALSE;
            PWSTR          pSmbMRxTransports;
            UNICODE_STRING SmbMRxTransport;
            NTSTATUS       Status;

            Status = SmbCeGetConfigurationInformation();

            if (Status != STATUS_SUCCESS) {
                return;
            }

            pSmbMRxTransports = (PWSTR)SmbCeContext.Transports.Buffer;
            Priority = 1;
            while (*pSmbMRxTransports) {
                SmbMRxTransport.Length = wcslen(pSmbMRxTransports) * sizeof(WCHAR);

                if (SmbMRxTransport.Length == pTransportName->Length) {
                    SmbMRxTransport.MaximumLength = SmbMRxTransport.Length;
                    SmbMRxTransport.Buffer = pSmbMRxTransports;

                    if (RtlCompareUnicodeString(
                           &SmbMRxTransport,
                           pTransportName,
                           TRUE) == 0) {
                        fBindToTransport = TRUE;
                        break;
                    }
                }

                pSmbMRxTransports += (SmbMRxTransport.Length / sizeof(WCHAR) + 1);
                Priority++;
            }

            // Provide a local registry means to alter binding priority
//            if (fBindToTransport) {
//                MRxSmbpOverrideBindingPriority( pTransportName, &Priority );
//                fBindToTransport = (Priority != 0);
//            }

            if (fBindToTransport) {
                InterlockedIncrement(&TdiBindRequestsActive);

                if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                    TRANSPORT_BIND_CONTEXT TransportContext;

                    TransportContext.Priority = Priority;
                    TransportContext.TransportName = *pTransportName;
                    MRxSmbpBindTransportCallback(&TransportContext);
                } else {
                    PTRANSPORT_BIND_CONTEXT pNewTransportContext;

                    NTSTATUS Status;

                    pNewTransportContext = RxAllocatePoolWithTag(
                                               PagedPool,
                                               sizeof(TRANSPORT_BIND_CONTEXT) + pTransportName->Length,
                                               MRXSMB_TRANSPORT_POOLTAG);

                    if (pNewTransportContext != NULL) {
                        pNewTransportContext->Priority = Priority;
                        pNewTransportContext->TransportName.MaximumLength = pTransportName->MaximumLength;
                        pNewTransportContext->TransportName.Length = pTransportName->Length;
                        pNewTransportContext->TransportName.Buffer = (PWCHAR)((PBYTE)pNewTransportContext +
                                                                      sizeof(TRANSPORT_BIND_CONTEXT));

                        RtlCopyMemory(
                            pNewTransportContext->TransportName.Buffer,
                            pTransportName->Buffer,
                            pTransportName->Length);

                        Status = RxDispatchToWorkerThread(
                                     MRxSmbDeviceObject,
                                     CriticalWorkQueue,
                                     MRxSmbpBindTransportWorkerThreadRoutine,
                                     pNewTransportContext);
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }

                    if (Status != STATUS_SUCCESS) {
                        InterlockedDecrement(&TdiBindRequestsActive);
                        SmbCeSignalNetReadyEvent();
                    }
                }
            }
        }
        break;

    case TDI_PNP_OP_DEL:
        {
            PSMBCE_TRANSPORT pTransport;

            pTransport = SmbCeFindTransport(pTransportName);

            if (pTransport != NULL) {
                if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                    MRxSmbpUnbindTransportCallback(pTransport);
                } else {
                    NTSTATUS Status;

                    Status = RxDispatchToWorkerThread(
                                 MRxSmbDeviceObject,
                                 CriticalWorkQueue,
                                 MRxSmbpUnbindTransportCallback,
                                 pTransport);
                }
            }
        }
        break;

    case TDI_PNP_OP_UPDATE:
        {
        }
        break;

    case  TDI_PNP_OP_NETREADY:
        {
            TdiPnpNetReadyEventReceived = TRUE;
            SmbCeSignalNetReadyEvent();
        }
        break;

    default:
        break;
    }
}

NTSTATUS
MRxSmbPnPPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
)
/*++

Routine Description:

    This routine deals with power changes

Notes:

    The implementation needs to be completed

--*/
{
    NTSTATUS Status;
    LONG     NumberOfActiveOpens;

    Status = STATUS_SUCCESS;

    FsRtlEnterFileSystem();

    RxPurgeAllFobxs(MRxSmbDeviceObject);

    RxScavengeAllFobxs(MRxSmbDeviceObject);
    NumberOfActiveOpens = MRxSmbNumberOfSrvOpens;

    switch (PowerEvent->NetEvent) {
    case NetEventQueryPower:
        {
            // If the redirector were to return an error on this request there
            // is no underlying support to tell the user about the files that
            // are open. There are two approaches to doing this.. either the RDR
            // rolls its own UI or the PNP manager provides the infra structure.
            // The problem with the former is that hibernation becomes a painstaking
            // process wherein the user has to contend with a variety of UI.
            // Till this is resolved the decision was to use the power mgmt. API
            // to manage system initiated hibernate requests and succeed user
            // initiated requests after appropriate purging/scavenging.

            if (MRxSmbNumberOfSrvOpens > 0) {
                DbgPrint(
                    "RDR: PNP Hibernate Request Status %lx Number of Opens %lx\n",
                    Status,
                    MRxSmbNumberOfSrvOpens);
            }

            Status = STATUS_SUCCESS;
        }
        break;

    case NetEventQueryRemoveDevice:
        {
            PSMBCEDB_SERVER_ENTRY pServerEntry;
            ULONG                 NumberOfFilesOpen = 0;
            PSMBCE_TRANSPORT      pTransport = NULL;

            pTransport = SmbCeFindTransport(DeviceName);

            if (pTransport != NULL) {
                SmbCeAcquireSpinLock();

                pServerEntry = SmbCeGetFirstServerEntry();

                while (pServerEntry != NULL) {
                    if ((pServerEntry->pTransport != NULL) &&
                        (pTransport == pServerEntry->pTransport->pTransport)) {
                        NumberOfFilesOpen += pServerEntry->Server.NumberOfSrvOpens;
                    }

                    pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
                }

                SmbCeReleaseSpinLock();

                SmbCeDereferenceTransport(pTransport);
            }
        }
        break;

    default:
        break;
    }

    FsRtlExitFileSystem();

    return Status;
}

NTSTATUS
MRxSmbRegisterForPnpNotifications()
/*++

Routine Description:

    This routine registers with TDI for receiving transport notifications

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(MRxSmbTdiNotificationHandle == NULL ) {
        UNICODE_STRING ClientName;

        TDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo;

        RtlInitUnicodeString(&ClientName,L"LanmanWorkStation");

        ClientInterfaceInfo.MajorTdiVersion = 2;
        ClientInterfaceInfo.MinorTdiVersion = 0;

        ClientInterfaceInfo.Unused = 0;
        ClientInterfaceInfo.ClientName = &ClientName;

        ClientInterfaceInfo.BindingHandler = MRxSmbPnPBindingHandler;
        ClientInterfaceInfo.AddAddressHandler = NULL;
        ClientInterfaceInfo.DelAddressHandler = NULL;
        ClientInterfaceInfo.PnPPowerHandler = MRxSmbPnPPowerHandler;

        KeInitializeEvent(
            &TdiNetStartupCompletionEvent,
            NotificationEvent,
            FALSE);

        Status = TdiRegisterPnPHandlers (
                     &ClientInterfaceInfo,
                     sizeof(ClientInterfaceInfo),
                     &MRxSmbTdiNotificationHandle );

        if (Status == STATUS_SUCCESS) {
            LARGE_INTEGER WaitInterval;

            WaitInterval.QuadPart = -( 10000 * 2 * 60 * 1000 );

            Status = KeWaitForSingleObject(
                         &TdiNetStartupCompletionEvent,
                         Executive,
                         KernelMode,
                         TRUE,
                         &WaitInterval);
        }
    }

    return Status;
}

NTSTATUS
MRxSmbDeregisterForPnpNotifications()
/*++

Routine Description:

    This routine deregisters the TDI notification mechanism

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if( MRxSmbTdiNotificationHandle != NULL ) {
        Status = TdiDeregisterPnPHandlers( MRxSmbTdiNotificationHandle );

        if( NT_SUCCESS( Status ) ) {
            MRxSmbTdiNotificationHandle = NULL;
        }
    }

    return Status;
}



PSMBCE_TRANSPORT_ARRAY
SmbCeReferenceTransportArray(VOID)
/*++

Routine Description:

    This routine references and returns the current transport array instance

Return Value:

    PSMBCE_TRANSPORT_ARRAY - the pointer of the current transport array instance

Notes:

--*/
{
    KIRQL                  SavedIrql;
    PSMBCE_TRANSPORT_ARRAY pTransportArray;

    KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);

    pTransportArray = MRxSmbTransports.pTransportArray;

    if (pTransportArray != NULL) {
        InterlockedIncrement(&pTransportArray->ReferenceCount);
    }

    KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

    return pTransportArray;
}

NTSTATUS
SmbCeDereferenceTransportArray(
    PSMBCE_TRANSPORT_ARRAY pTransportArray)
/*++

Routine Description:

    This routine dereferences the transport array instance

Arguments:

    pTransportArray - the transport array instance

Return Value:

    STATUS_SUCCESS - the server transport was successfully dereferenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    KIRQL    SavedIrql;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if (pTransportArray != NULL) {
        ASSERT( pTransportArray->ReferenceCount > 0 );

        if(InterlockedDecrement(&pTransportArray->ReferenceCount)==0) {
            ULONG i;

            for(i=0;i<pTransportArray->Count;i++) {
                SmbCeDereferenceTransport(pTransportArray->SmbCeTransports[i]);
            }

            RxFreePool(pTransportArray->SmbCeTransports);
            RxFreePool(pTransportArray->LocalAddresses);
            RxFreePool(pTransportArray);
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
SmbCeIsServerAvailable(
    PUNICODE_STRING Name
)
/*++

Routine Description:

    This routine scans the list of "unreachable" servers and returns the status
    of the last failed connection attempt.

Return:
    STATUS_SUCCESS -> we have no reason to believe this server is unreachable
    other -> server is unreachable for this reason
--*/
{
    PUNAVAILABLE_SERVER server;
    LARGE_INTEGER now;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    KeQueryTickCount( &now );

    ExAcquireResourceExclusive( &UnavailableServerListResource, TRUE );

    for( server  = (PUNAVAILABLE_SERVER)UnavailableServerList.Flink;
         server != (PUNAVAILABLE_SERVER)&UnavailableServerList;
         server  = (PUNAVAILABLE_SERVER)server->ListEntry.Flink ) {

        //
        // If this entry has timed out, remove it.
        //
        if( now.QuadPart > server->Time.QuadPart ) {
            PUNAVAILABLE_SERVER tmp;
            //
            // Unlink this entry from the list and discard it
            //
            tmp = (PUNAVAILABLE_SERVER)(server->ListEntry.Blink);
            RemoveEntryList( &server->ListEntry );
            RxFreePool( server );
            server = tmp;
            continue;
        }

        //
        // See if this entry is the one we want
        //
        if( RtlCompareUnicodeString( &server->Name, Name, TRUE ) == 0 ) {

            status = server->Status;

            RxDbgTrace(0, Dbg, ("SmbCeIsServerAvailable: Found %wZ %X\n",
                        &server->Name, status ));
        }
    }

    ExReleaseResource( &UnavailableServerListResource );

    return status;
}

VOID
SmbCeServerIsUnavailable(
    PUNICODE_STRING Name,
    NTSTATUS Status
)
{
    PUNAVAILABLE_SERVER server;

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ExpiryTimeInTicks;

    PAGED_CODE();

    server = (PUNAVAILABLE_SERVER)RxAllocatePoolWithTag(
                                        PagedPool,
                                        sizeof( *server ) + Name->Length,
                                        MRXSMB_TRANSPORT_POOLTAG
                                        );

    if( server == NULL ) {
        return;
    }

    RxDbgTrace(0, Dbg, ("SmbCeServerIsUnavailable: Add %wZ %X\n", Name, Status ));

    server->Name.Buffer = (PUSHORT)(server + 1);
    server->Name.MaximumLength = Name->Length;
    RtlCopyUnicodeString( &server->Name, Name );

    KeQueryTickCount( &CurrentTime );

    ExpiryTimeInTicks.QuadPart = (1000 * 1000 * 10) / KeQueryTimeIncrement();

    ExpiryTimeInTicks.QuadPart = UNAVAILABLE_SERVER_TIME * ExpiryTimeInTicks.QuadPart;

    server->Time.QuadPart = CurrentTime.QuadPart + ExpiryTimeInTicks.QuadPart;

    server->Status = Status;

    ExAcquireResourceExclusive( &UnavailableServerListResource, TRUE );
    InsertHeadList( &UnavailableServerList, &server->ListEntry );
    ExReleaseResource( &UnavailableServerListResource );
}

VOID
SmbCeDiscardUnavailableServerList(
)
{
    PUNAVAILABLE_SERVER server;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("SmbCeDiscardUnavailableServerList\n" ));

    ExAcquireResourceExclusive( &UnavailableServerListResource, TRUE );

    while( UnavailableServerList.Flink != &UnavailableServerList ) {
        server  = (PUNAVAILABLE_SERVER)UnavailableServerList.Flink;
        RemoveEntryList( &server->ListEntry );
        RxFreePool( server );
    }

    ExReleaseResource( &UnavailableServerListResource );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\vcsndrcv.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    vcsndrcv.c

Abstract:

    This module implements all functions related to transmitting and recieving SMB's on a
    connection based transport.

--*/

#include "precomp.h"
#pragma hdrstop

#include "vcsndrcv.h"

//
// Forward declarations
//

NTSTATUS
VctTranceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

NTSTATUS
VctReceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
VctSend(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

NTSTATUS
VctSendDatagram(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

struct _SMBCE_VC *
VctSelectVc(
    struct SMBCE_SERVER_VC_TRANSPORT *pVcTransport,
    BOOLEAN                    fMultiplexed);

NTSTATUS
VctInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
VctUninitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
VctIndReceive(
    IN PVOID              pEventContext,
    IN PRXCE_VC           pVc,
    IN ULONG              ReceiveFlags,
    IN ULONG              BytesIndicated,
    IN ULONG              BytesAvailable,
    OUT ULONG             *pBytesTaken,
    IN PVOID              pTsdu,
    OUT PMDL *pDataBufferPointer,
    OUT PULONG            pDataBufferSize
    );

NTSTATUS
VctIndDataReady(
    IN PVOID        pEventContext,
    IN PMDL         pBuffer,
    IN ULONG        DataSize,
    IN NTSTATUS     CopyDataStatus
    );

NTSTATUS
VctIndEndpointError(
    IN PVOID          pEventContext,
    IN NTSTATUS       IndicatedStatus
    );

NTSTATUS
VctIndSendPossible(
    IN PVOID          pEventContext,
    IN PRXCE_VC       pRxCeVc,
    IN ULONG          BytesAvailable
    );

NTSTATUS
VctIndReceiveDatagram(
    IN PVOID   pRxCeEventContext,
    IN int     SourceAddressLength,
    IN PVOID   SourceAddress,
    IN int     OptionsLength,
    IN PVOID   Options,
    IN ULONG   ReceiveDatagramFlags,
    IN ULONG   BytesIndicated,
    IN ULONG   BytesAvailable,
    OUT ULONG  *BytesTaken,
    IN PVOID   Tsdu,
    OUT PMDL   *pDataBufferPointer,
    OUT PULONG pDataBufferSize
    );

NTSTATUS
VctIndSendComplete(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pRxCeVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       SendCompletionStatus
   );

NTSTATUS
VctCompleteInitialization(
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    PSMBCE_TRANSPORT           pTransport,
    struct SMBCE_SERVER_VC_TRANSPORT *pVcTransport);

NTSTATUS
VctUninitialize(
    PVOID pTransport);

NTSTATUS
VctpTranslateNetbiosNameToIpAddress(
    IN  OEM_STRING *pName,
    OUT ULONG      *pIpAddress
    );

ULONG
VctComputeTransportAddressSize(
   IN PUNICODE_STRING pServerName);

NTSTATUS
VctBuildTransportAddress (
    IN  PTRANSPORT_ADDRESS pTransportAddress,
    IN  ULONG              TransportAddressLength,
    IN  PUNICODE_STRING    pServerName,
    OUT PULONG             pServerIpAddress
    );

NTSTATUS
VctpCreateConnection(
    IN PSMBCEDB_SERVER_ENTRY    pServerEntry,
    IN PTRANSPORT_ADDRESS       pTransportAddress,
    IN ULONG                    TransportAddressLength,
    IN PUNICODE_STRING          pServerName,
    OUT PSMBCE_TRANSPORT        *pTransportPtr,
    IN OUT PRXCE_CONNECTION     pRxCeConnection,
    IN OUT PRXCE_VC             pRxCeVc);

VOID
VctpInitializeServerTransport(
    struct _RXCE_VC_CONNECT_CONTEXT *pRxCeConnectContext);

NTSTATUS
VctpInvokeTransportFunction(
    struct _RXCE_VC_CONNECT_CONTEXT *pRxCeConnectContext);

VOID
VctpUninitializeServerTransport(
    struct _RXCE_VC_CONNECT_CONTEXT *pRxCeConnectContext);

NTSTATUS
VctTearDownServerTransport(
   PSMBCE_SERVER_TRANSPORT pServerTransport);

NTSTATUS
VctInitiateDisconnect(
    PSMBCE_SERVER_TRANSPORT pServerTransport);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, VctTranceive)
#pragma alloc_text(PAGE, VctReceive)
#pragma alloc_text(PAGE, VctSend)
#pragma alloc_text(PAGE, VctSendDatagram)
#pragma alloc_text(PAGE, VctSelectVc)
#pragma alloc_text(PAGE, VctInitializeExchange)
#pragma alloc_text(PAGE, VctUninitializeExchange)
#pragma alloc_text(PAGE, VctIndEndpointError)
#pragma alloc_text(PAGE, VctIndSendPossible)
#pragma alloc_text(PAGE, VctCompleteInitialization)
#pragma alloc_text(PAGE, VctUninitialize)
#pragma alloc_text(PAGE, VctpTranslateNetbiosNameToIpAddress)
#pragma alloc_text(PAGE, VctComputeTransportAddressSize)
#pragma alloc_text(PAGE, VctBuildTransportAddress)
#pragma alloc_text(PAGE, VctpCreateConnection)
#pragma alloc_text(PAGE, VctpInitializeServerTransport)
#pragma alloc_text(PAGE, VctpUninitializeServerTransport)
#pragma alloc_text(PAGE, VctpInvokeTransportFunction)
#pragma alloc_text(PAGE, VctInstantiateServerTransport)
#pragma alloc_text(PAGE, VctTearDownServerTransport)
#pragma alloc_text(PAGE, VctInitiateDisconnect)
#endif

RXDT_DefineCategory(VCSNDRCV);
#define Dbg        (DEBUG_TRACE_VCSNDRCV)

// Move this def to a common .h file.
#define MAX_SMB_PACKET_SIZE (65536)

#define MIN(a,b) ((a) < (b) ? (a) : (b))

//
// Forward references of functions ....
//

extern NTSTATUS
VctTearDownServerTransport(
    PSMBCE_SERVER_TRANSPORT pTransport);

extern NTSTATUS
VctInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE            pExchange);

extern PSMBCE_VC
VctSelectVc(
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport,
    BOOLEAN                    fMultiplexed);

#define SmbMmInitializeVcEntry(pVcEntry)                      \
         SmbMmInitializeHeader((pVcEntry));

#define SmbMmUninitializeVcEntry(pVcEntry)    \
         ASSERT(IsListEmpty(&(pVcEntry)->Requests.ListHead))

#define VctSelectMultiplexedVcEntry(pVcTransport)  VctSelectVc(pVcTransport,TRUE)
#define VctSelectRawVcEntry(pVcTransport)          VctSelectVc(pVcTransport,FALSE)

//
// Inline functions to update the state of a VC.
//

INLINE BOOLEAN
VctUpdateVcStateLite(
    PSMBCE_VC       pVc,
    SMBCE_VC_STATE  NewState)
{
    BOOLEAN Result = TRUE;

    ASSERT(SmbCeSpinLockAcquired());

    if (NewState == SMBCE_VC_STATE_RAW) {
        if (pVc->SwizzleCount != 0) {
            Result = FALSE;
        } else {
            pVc->State = NewState;
        }
    } else {
        pVc->State = NewState;
    }

    return Result;
}

INLINE BOOLEAN
VctUpdateVcState(
    PSMBCE_VC       pVc,
    SMBCE_VC_STATE  NewState)
{
    BOOLEAN Result = TRUE;

    SmbCeAcquireSpinLock();

    Result = VctUpdateVcStateLite(pVc,NewState);

    SmbCeReleaseSpinLock();

    return Result;
}

NTSTATUS
VctTranceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pTransport    - the transport

    pServerEntry  - the server entry

    pExchange     - the exchange instance issuing this SMB.

    SendOptions   - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

    pSendCompletionContext - the send completion context

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS                   Status = STATUS_SUCCESS;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;
    PSMB_HEADER                pSmbHeader = MmGetSystemAddressForMdlSafe(pSmbMdl,LowPagePriority);
    USHORT                     Mid;
    BOOLEAN                    fInvokeSendCompleteHandler = TRUE;

    PAGED_CODE();

    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    if (pSmbHeader == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

        // Ensure that the connection is still active before satisfying the request.
        if (SmbCeIsEntryInUse(&pServerEntry->Header)) {
            pVc = pExchange->SmbCeContext.TransportContext.Vcs.pVc;
            if (pVc == NULL) {
                Status = STATUS_CONNECTION_DISCONNECTED;
            }

            if ((Status == STATUS_SUCCESS) &&
                (pVc->State == SMBCE_VC_STATE_MULTIPLEXED)) {
                Status = RxCeSend(
                             &pVc->RxCeVc,
                             SendOptions,
                             pSmbMdl,
                             SendLength,
                             pSendCompletionContext);

                if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
                    Status = STATUS_PENDING;
                    // The underlying connection engine assumes the responsibility of
                    // invoking the send complete handler from this point.
                    fInvokeSendCompleteHandler = FALSE;
                }
            } else {
                RxDbgTrace(0, Dbg, ("VctTranceive: Disconnected connection detected\n"));
                Status = STATUS_CONNECTION_DISCONNECTED;
            }
        } else {
            // The server entry is not valid ...
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
    }

    if (Status != STATUS_PENDING) {
        RxDbgTrace(0, Dbg, ("VctTranceive: Return Status %lx\n",Status));
    }

    // There are instances in which the send was aborted even before the underlying
    // transport was invoked. In such cases the appropriate send complete handler
    // needs to be called so that the associated exchange can be finalized.

    if (fInvokeSendCompleteHandler) {
        NTSTATUS LocalStatus;

        LocalStatus = SmbCeSendCompleteInd(
                          pServerEntry,
                          pSendCompletionContext,
                          Status);

        RxDbgTrace(0, Dbg, ("VctTranceive: Send Complete Handler Return Status %lx\n",LocalStatus));
    }

    return Status;
}


NTSTATUS
VctReceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pTransport   - the server transport

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

Return Value:

    STATUS_PENDING - the request has been queued

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS                   Status = STATUS_SUCCESS;
    PSMBCEDB_NET_ROOT_ENTRY    pNetRootEntry;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

    PAGED_CODE();

    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;
    pVc          = pExchange->SmbCeContext.TransportContext.Vcs.pVc;

    // Ensure that the connection is still active before satisfying the request.
    if (SmbCeIsEntryInUse(&pServerEntry->Header) &&
        (pVc != NULL)) {
        Status = STATUS_SUCCESS;
    } else {
        // The server entry is not valid ...
        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    return Status;
}

NTSTATUS
VctSend(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pTransport - the server transport

    pServer    - the recepient server

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be sent

    pSendCompletionContext - the send completion context

Return Value:

    STATUS_SUCCESS - the send was successful.

    STATUS_PENDING - the send has been queued

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS                   Status = STATUS_CONNECTION_DISCONNECTED;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;
    BOOLEAN                    fInvokeSendCompleteHandler = TRUE;

    PAGED_CODE();

    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;
    pVc = VctSelectMultiplexedVcEntry(pVcTransport);

    if  (pVc != NULL) {
        if (pVc->State == SMBCE_VC_STATE_MULTIPLEXED) {
            Status = RxCeSend(
                         &pVc->RxCeVc,
                         SendOptions,
                         pSmbMdl,
                         SendLength,
                         pSendCompletionContext);

            if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
                // The underlying connection engine assumes the responsibility of
                // invoking the send complete handler from this point.
                fInvokeSendCompleteHandler = FALSE;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace(0, Dbg, ("VctSend: RxCeSend returned %lx\n",Status));
    }

    // There are instances in which the send was aborted even before the underlying
    // transport was invoked. In such cases the appropriate send complete handler
    // needs to be called so that the associated exchange can be finalized.

    if (fInvokeSendCompleteHandler) {
        NTSTATUS LocalStatus;

        LocalStatus = SmbCeSendCompleteInd(
                          pServerEntry,
                          pSendCompletionContext,
                          Status);

        RxDbgTrace(0, Dbg, ("VctTranceive: Send Complete Handler Return Status %lx\n",LocalStatus));
    }

    return Status;
}

NTSTATUS
VctSendDatagram(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pTransport - the server transport

    pServer    - the recepient server

    SendOptions - options for send

    pSmbMdl     - the SMB that needs to be sent.

    SendLength  - length of data to be sent

    pSendCompletionContext - the send completion context

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}

PSMBCE_VC
VctSelectVc(
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport,
    BOOLEAN                    fMultiplexed)
/*++

Routine Description:

    This routine embodies the logic for the selection of a VC on which the SMB exchange
    will transpire

Arguments:

    pVcTransport  - the transport structure

    fMultiplexed  - the desired mode

Return Value:

    a referenced VC entry if successful otherwise NULL

--*/
{
    NTSTATUS        Status;
    PSMBCE_VC       pVc = NULL;
    ULONG           VcIndex,NumberOfActiveVcs = 0;
    SMBCE_VC_STATE  DesiredState;

    PAGED_CODE();

    if (fMultiplexed) {
        RxDbgTrace(0, Dbg, ("VctSelectVc: Referencing Multiplexed entry\n"));
        DesiredState = SMBCE_VC_STATE_MULTIPLEXED;
    } else {
        RxDbgTrace(0, Dbg, ("VctSelectVc: Referencing Raw entry\n"));
        DesiredState = SMBCE_VC_STATE_RAW;
    }

    // Acquire the resource
    SmbCeAcquireResource();

    // Choose the first VC that can support multiplexed requests
    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        PSMBCE_VC pTempVc = &pVcTransport->Vcs[VcIndex];

        NumberOfActiveVcs++;

        if (pTempVc->State == SMBCE_VC_STATE_MULTIPLEXED) {
            if (DesiredState == SMBCE_VC_STATE_MULTIPLEXED) {
                pVc = pTempVc;
                break;
            } else {
                // If the current number of active references to a VC is zero, it can
                // be transformed into the raw mode.
                if (VctUpdateVcState(pTempVc,SMBCE_VC_STATE_RAW)) {
                    pVc = pTempVc;
                    break;
                } else {
                    NumberOfActiveVcs++;
                }
            }
        }
    }

    if (pVc == NULL) {
        // Check if it is O.K. to add VCs to this connection. Currently the server
        // implementation supports only one VC per connection. Therefore if an
        // active VC exists which has been grabbed for raw mode use an error is returned.
        // Subsequently when the server is upgraded to handle multiple VCs the logic
        // for adding a new VC will be implemented as part of this routine.
    }

    if (pVc != NULL) {
        VctReferenceVc(pVc);
    }

    // release the resource
    SmbCeReleaseResource();

    return pVc;
}

NTSTATUS
VctInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine initializes the transport information pertinent to a exchange

Arguments:

    pTransport         - the transport structure

    pExchange          - the exchange instance

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
    PSMBCEDB_SERVER_ENTRY      pServerEntry;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

    PAGED_CODE();

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

    ASSERT(pExchange->SmbCeContext.TransportContext.Vcs.pVc == NULL);

    pExchange->SmbCeContext.TransportContext.Vcs.pVc
                     = VctSelectMultiplexedVcEntry(pVcTransport);

    if (pExchange->SmbCeContext.TransportContext.Vcs.pVc == NULL) {
        RxDbgTrace(0, Dbg, ("VctInitializeExchange: Unsuccessful\n"));
        return STATUS_CONNECTION_DISCONNECTED;
    } else {
        RxDbgTrace(0, Dbg, ("VctInitializeExchange: Successful\n"));
        return STATUS_SUCCESS;
    }
}

NTSTATUS
VctUninitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine uninitializes the transport information pertinent to a exchange

Arguments:

    pExchange          - the exchange instance

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

    PAGED_CODE();

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

    RxDbgTrace(0, Dbg, ("VctUninitializeExchange: Successful\n"));

    if (pExchange->SmbCeContext.TransportContext.Vcs.pVc != NULL) {
        VctDereferenceVc(pExchange->SmbCeContext.TransportContext.Vcs.pVc);
    }

    pExchange->SmbCeContext.TransportContext.Vcs.pVc = NULL;

    return STATUS_SUCCESS;
}


NTSTATUS
VctIndReceive(
    IN PVOID              pEventContext,
    IN PRXCE_VC           pVc,
    IN ULONG              ReceiveFlags,
    IN ULONG              BytesIndicated,
    IN ULONG              BytesAvailable,
    OUT ULONG             *pBytesTaken,
    IN PVOID              pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL              *pDataBufferPointer,    // the buffer in which data is to be copied.
    OUT PULONG            pDataBufferSize         // amount of data to copy
    )
/*++

Routine Description:

    This routine handles the receive indication for SMB's along all vcs in a connection to a
    server.

Arguments:

    pEventContext      - the server entry

    hVc                - the Vc on which the SMB has been received

    ReceiveFlags       - options for receive

    BytesIndicated     - the bytes that are present in the indication.

    BytesAvailable     - the total data available

    pTsdu              - the data

    pDataBufferPointer - the buffer for copying the data not indicated.

    pDataBufferSize    - the length of the buffer

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY  pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

    Status = SmbCeReceiveInd(
                 pServerEntry,
                 BytesIndicated,
                 BytesAvailable,
                 pBytesTaken,
                 pTsdu,
                 pDataBufferPointer,
                 pDataBufferSize,
                 ReceiveFlags);

    return Status;
}

NTSTATUS
VctIndDataReady(
    IN PVOID        pEventContext,
    IN PMDL         pBuffer,
    IN ULONG        DataSize,
    IN NTSTATUS     CopyDataStatus
    )
/*++

Routine Description:

    This routine handles the indication when the requested data has been copied

Arguments:

    pEventContext - the server instance

    pBuffer       - the buffer being returned

    DataSize      - the amount of data copied in bytes

    CopyDataStatus - CopyDataStatus

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY  pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

    Status = SmbCeDataReadyInd(
                 pServerEntry,
                 pBuffer,
                 DataSize,
                 CopyDataStatus);

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndDisconnect(
    IN PVOID          pEventContext,
    IN PRXCE_VC       pRxCeVc,
    IN int            DisconnectDataLength,
    IN PVOID          DisconnectData,
    IN int            DisconnectInformationLength,
    IN PVOID          DisconnectInformation,
    IN ULONG          DisconnectFlags
    )
/*++

Routine Description:

    This routine handles the disconnect indication for a VC.

Arguments:

    pEventContext               - the server instance

    hVc                         - the virtual circuit

    DisconnectDataLength        -

    DisconnectData              -

    DisconnectInformationLength -

    DisconnectInformation       -

    DisconnectFlags             -

Return Value:

    STATUS_SUCCESS - the disconnect indication has been handled

--*/
{
    PSMBCEDB_SERVER_ENTRY       pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;
    PSMBCEDB_SERVER_ENTRY       pListEntry;
    PSMBCE_VC                   pVc;
    PSMBCEDB_REQUEST_ENTRY      pRequestEntry;
    PSMB_EXCHANGE               pExchange;
    PSMBCE_SERVER_VC_TRANSPORT  pVcTransport;

    BOOLEAN fValidServerEntry = FALSE;

    // Traverse the list of server entries to ensure that the disconnect was on a
    // valid server entry. If it is not on a valid server entry ignore it.

    SmbCeAcquireSpinLock();

    pListEntry = SmbCeGetFirstServerEntry();

    while (pListEntry != NULL) {
        if (pListEntry == pServerEntry) {
            // The invalidation needs to hold onto an extra reference to avoid
            // race conditions which could lead to premature destruction of
            // this server entry.
            SmbCeReferenceServerEntry(pServerEntry);
            fValidServerEntry = TRUE;
            break;
        }
        pListEntry = SmbCeGetNextServerEntry(pListEntry);
    }

    if (fValidServerEntry) {
        pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;

        if (pVcTransport != NULL) {
            ULONG VcIndex;

            for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
                pVc = &pVcTransport->Vcs[VcIndex];

                if (&pVc->RxCeVc == pRxCeVc) {
                    VctUpdateVcStateLite(pVc,SMBCE_VC_STATE_DISCONNECTED);
                    pVc->Status   = STATUS_CONNECTION_DISCONNECTED;
                    break;
                }
            }
        }
    }

    // Release the resource
    SmbCeReleaseSpinLock();

    if (fValidServerEntry) {
        RxDbgTrace(0,Dbg,("@@@@@@ Disconnect Indication for %lx @@@@@\n",pServerEntry));
        InterlockedIncrement(&MRxSmbStatistics.ServerDisconnects);

        // Update the Server entry if this is the only VC associated with the transport.
        SmbCeTransportDisconnectIndicated(pServerEntry);

        InitializeListHead(&pServerEntry->WorkQueueItem.List);

        RxPostToWorkerThread(
            MRxSmbDeviceObject,
            CriticalWorkQueue,
            &pServerEntry->WorkQueueItem,
            SmbCepDereferenceServerEntry,
            pServerEntry);

        RxDbgTrace(0, Dbg, ("VctIndDisconnect: Processing Disconnect indication on VC entry %lx\n",pVc));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndError(
    IN PVOID          pEventContext,
    IN PRXCE_VC       pRxCeVc,
    IN NTSTATUS       IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    pRxCeVc       - the RxCe virtual circuit

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS                   Status;
    ULONG                      VcIndex;
    PSMBCEDB_SERVER_ENTRY      pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;

    // Acquire the resource
    SmbCeAcquireSpinLock();

    // Map the RXCE vc handle to the appropriate SMBCE entry and get the request
    // list associated with it.

    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        pVc = &pVcTransport->Vcs[VcIndex];

        if (&pVc->RxCeVc == pRxCeVc) {
            VctUpdateVcStateLite(pVc,SMBCE_VC_STATE_DISCONNECTED);
            pVc->Status   = IndicatedStatus;
            break;
        }
    }

    // Release the resource
    SmbCeReleaseSpinLock();

    RxDbgTrace(0, Dbg, ("VctIndError: Processing Error indication on VC entry %lx\n",pVc));

    Status = SmbCeErrorInd(
                 pServerEntry,
                 IndicatedStatus);

    return Status;
}

NTSTATUS
VctIndEndpointError(
    IN PVOID          pEventContext,
    IN NTSTATUS       IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndSendPossible(
    IN PVOID          pEventContext,    // the event context.
    IN PRXCE_VC       pRxCeVc,
    IN ULONG          BytesAvailable
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    hVc           - the VC instance

    BytesAvailable - the number of bytes that can be sent

Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndReceiveDatagram(
    IN PVOID   pRxCeEventContext,      // the event context
    IN int     SourceAddressLength,    // length of the originator of the datagram
    IN PVOID   SourceAddress,          // string describing the originator of the datagram
    IN int     OptionsLength,          // options for the receive
    IN PVOID   Options,                //
    IN ULONG   ReceiveDatagramFlags,   //
    IN ULONG   BytesIndicated,         // number of bytes this indication
    IN ULONG   BytesAvailable,         // number of bytes in complete Tsdu
    OUT ULONG  *BytesTaken,            // number of bytes used
    IN PVOID   Tsdu,                   // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL   *pDataBufferPointer,    // the buffer in which data is to be copied.
    OUT PULONG pDataBufferSize         // amount of data to copy
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
VctIndSendComplete(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pRxCeVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       SendCompletionStatus
   )
/*++

Routine Description:

    This routine handles the send complete indication for asynchronous sends

Arguments:

    pEventContext - the server instance

    pRxCeVc       - the RxCe VC instance

    pCompletionContext - the context for identifying the send request

    SendCompletionStatus - the send completion status

Return Value:

    STATUS_SUCCESS always ..

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SERVER_ENTRY    pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

    Status = SmbCeSendCompleteInd(
                 pServerEntry,
                 pCompletionContext,
                 SendCompletionStatus);

    return Status;
}

//
// Static dispatch vectors for Virtual Circuit based transports
//

RXCE_ADDRESS_EVENT_HANDLER
MRxSmbVctAddressEventHandler = {
                                   VctIndEndpointError,
                                   VctIndReceiveDatagram,
                                   VctIndDataReady,
                                   VctIndSendPossible,
                                   NULL
                               };

RXCE_CONNECTION_EVENT_HANDLER
MRxSmbVctConnectionEventHandler = {
                                      VctIndDisconnect,
                                      VctIndError,
                                      VctIndReceive,
                                      VctIndReceiveDatagram,
                                      VctIndReceive,
                                      VctIndSendPossible,
                                      VctIndDataReady,
                                      VctIndSendComplete
                                  };

TRANSPORT_DISPATCH_VECTOR
MRxSmbVctTransportDispatch = {
                                VctSend,
                                VctSendDatagram,
                                VctTranceive,
                                VctReceive,
                                NULL,
                                VctInitializeExchange,
                                VctUninitializeExchange,
                                VctTearDownServerTransport,
                                VctInitiateDisconnect
                             };


typedef enum _RXCE_VC_FUNCTION_CODE {
   VcConnect,
   VcDisconnect
} RXCE_VC_FUNCTION_CODE, *PRXCE_VC_FUNCTION_CODE;

typedef struct _RXCE_VC_CONNECT_CONTEXT {
   RXCE_VC_FUNCTION_CODE         FunctionCode;
   PRX_WORKERTHREAD_ROUTINE      pRoutine;
   PSMBCEDB_SERVER_ENTRY         pServerEntry;
   PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext;
   PSMBCE_SERVER_TRANSPORT       pServerTransport;
   NTSTATUS                      Status;
   KEVENT                        SyncEvent;
} RXCE_VC_CONNECT_CONTEXT, *PRXCE_VC_CONNECT_CONTEXT;

NTSTATUS
VctCompleteInitialization(
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    PSMBCE_TRANSPORT           pTransport,
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    The remote address can be either deduced from the information in the Rx Context
    or a NETBIOS address needs to be built from the server name.
    This transport address is used subsequently to establish the connection.

--*/
{
    NTSTATUS Status;
    PSMBCE_VC                  pVc;

    RXCE_CONNECTION_INFO         ConnectionInfo;
    RXCE_TRANSPORT_PROVIDER_INFO ProviderInfo;

    PAGED_CODE();

    pVc = &pVcTransport->Vcs[0];

    // Query the transport information ...
    Status = RxCeQueryInformation(
                  &pVc->RxCeVc,
                  RxCeTransportProviderInformation,
                  &ProviderInfo,
                  sizeof(ProviderInfo));

    if (NT_SUCCESS(Status)) {
        pVcTransport->MaximumSendSize = MIN( ProviderInfo.MaxSendSize,
                                           MAXIMUM_PARTIAL_BUFFER_SIZE );
    } else {
        ASSERT( 1024 <= MAXIMUM_PARTIAL_BUFFER_SIZE );
        pVcTransport->MaximumSendSize = 1024;
    }

    // Query the connection information ....
    Status = RxCeQueryInformation(
                 &pVc->RxCeVc,
                 RxCeConnectionEndpointInformation,
                 &ConnectionInfo,
                 sizeof(ConnectionInfo));

    if (NT_SUCCESS(Status)) {
        // The setting of the delay parameter is an important heuristic
        // that determines how quickly and how often timeouts occur. As
        // a first cut a very conservative estimate for the time has been
        // choosen, i.e., double the time required to transmit a 64 k packet.
        // This parameter should be fine tuned.

        pVcTransport->Delay.QuadPart = (-ConnectionInfo.Delay.QuadPart) +
                           (-ConnectionInfo.Delay.QuadPart);
        if (ConnectionInfo.Throughput.LowPart != 0) {
            pVcTransport->Delay.QuadPart +=
                     (MAX_SMB_PACKET_SIZE/ConnectionInfo.Throughput.LowPart) * 1000 * 10000;
        }

        RxDbgTrace( 0, Dbg, ("Connection delay set to %ld 100ns ticks\n",pVcTransport->Delay.LowPart));

        pVcTransport->pDispatchVector = &MRxSmbVctTransportDispatch;
        pVcTransport->MaximumNumberOfVCs = 1;

        pVc->State     = SMBCE_VC_STATE_MULTIPLEXED;

        pVcTransport->State = SMBCEDB_ACTIVE;
    } else {
        RxDbgTrace(0, Dbg, ("VctInitialize : RxCeQueryInformation returned %lx\n",Status));
    }

    if (NT_SUCCESS(Status)) {
        pVcTransport->pTransport   = pTransport;
    } else {
        RxDbgTrace(0, Dbg, ("VctInitialize : Connection Initialization Failed %lx\n",Status));
    }

    return Status;
}

NTSTATUS
VctUninitialize(
    PVOID pTransport)
/*++

Routine Description:

    This routine uninitializes the transport instance

Arguments:

    pVcTransport - the VC transport instance

Return Value:

    STATUS_SUCCESS - the server transport construction has been uninitialzied.

    Other Status codes correspond to error situations.

Notes:


--*/
{
    NTSTATUS                   Status = STATUS_SUCCESS;
    ULONG                      VcIndex;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;
    ULONG                      TransportFlags;

    PAGED_CODE();

    // The spinlock needs to be acquired for manipulating the list of Vcs because of
    // indications that will be processed till the appropriate RXCE data structures are
    // dismantled

    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        pVc = &pVcTransport->Vcs[VcIndex];

        // Assert the fact that the request list associated with the VC is empty.
        // Tear down the VC entry
        Status = RxCeTearDownVC(&pVc->RxCeVc);
        ASSERT(Status == STATUS_SUCCESS);
    }

    // Tear down the connection endpoint ..
    Status = RxCeTearDownConnection(&pVcTransport->RxCeConnection);
    ASSERT(Status == STATUS_SUCCESS);

    RxDbgTrace(0, Dbg, ("VctUninitialize : RxCeDisconnect returned %lx\n",Status));

    // Dereference the underlying transport
    if (pVcTransport->pTransport != NULL) {
        SmbCeDereferenceTransport(pVcTransport->pTransport);
    }

    ASSERT((pVcTransport->Vcs[0].RxCeVc.hEndpoint == INVALID_HANDLE_VALUE) ||
           (pVcTransport->Vcs[0].RxCeVc.hEndpoint == NULL));

    ASSERT(pVcTransport->Vcs[0].RxCeVc.pEndpointFileObject == NULL);

    // Free up the transport entry
    RxFreePool(pVcTransport);

    return Status;
}

NTSTATUS
VctpTranslateNetbiosNameToIpAddress(
    IN  OEM_STRING *pName,
    OUT ULONG      *pIpAddress
    )
/*++

Routine Description:

    This routine converts ascii ipaddr (11.101.4.25) into a ULONG.  This is
    based on the inet_addr code in winsock

Arguments:
    pName   - the string containing the ipaddress

Return Value:

    the ipaddress as a ULONG if it's a valid ipaddress.  Otherwise, 0.

Notes:

    The body of this routine has been borrowed fron NetBt.

--*/
{
    NTSTATUS  Status;
    PCHAR    pStr;
    int      i;
    int      len, fieldLen;
    int      fieldsDone;
    ULONG    IpAddress;
    BYTE     ByteVal;
    PCHAR    pIpPtr;
    BOOLEAN  fDotFound;
    BOOLEAN  fieldOk;

    PAGED_CODE();

    Status = STATUS_INVALID_ADDRESS_COMPONENT;

    if (pName->Length > NETBIOS_NAME_LEN) {
        return Status;
    }

    pStr = pName->Buffer;
    len = 0;
    pIpPtr = (PCHAR)&IpAddress;
    pIpPtr += 3;                   // so that we store in network order
    fieldsDone=0;

    //
    // the 11.101.4.25 format can be atmost 15 chars, and pName is guaranteed
    // to be at least 16 chars long (how convenient!!).  Convert the string to
    // a ULONG.
    //
    while(len < NETBIOS_NAME_LEN)
    {
        fieldLen=0;
        fieldOk = FALSE;
        ByteVal = 0;
        fDotFound = FALSE;

        //
        // This loop traverses each of the four fields (max len of each
        // field is 3, plus 1 for the '.'
        //
        while (fieldLen < 4)
        {
            if (*pStr >='0' && *pStr <='9')
            {
                ByteVal = (ByteVal*10) + (*pStr - '0');
                fieldOk = TRUE;
            }

            else if (*pStr == '.' || *pStr == ' ' || *pStr == '\0')
            {
                *pIpPtr = ByteVal;
                pIpPtr--;
                fieldsDone++;

                if (*pStr == '.')
                    fDotFound = TRUE;

                // if we got a space or 0, assume it's the 4th field
                if (*pStr == ' ' || *pStr == '\0')
                {
                    break;
                }
            }

            // unacceptable char: can't be ipaddr
            else
            {
                return(Status);
            }

            pStr++;
            len++;
            fieldLen++;

            // if we found the dot, we are done with this field: go to the next one
            if (fDotFound)
                break;
        }

        // this field wasn't ok (e.g. "11.101..4" or "11.101.4." etc.)
        if (!fieldOk)
        {
            return(Status);
        }

        // if we are done with all 4 fields, we are done with the outer loop too
        if ( fieldsDone == 4)
            break;

        if (!fDotFound)
        {
            return(Status);
        }
    }

    //
    // make sure the remaining chars are spaces or 0's (i.e. don't allow
    // 11.101.4.25xyz to succeed)
    //
    for (i=len; i<NETBIOS_NAME_LEN; i++, pStr++)
    {
        if (*pStr != ' ' && *pStr != '\0')
        {
            return(Status);
        }
    }

    *pIpAddress = IpAddress;
    return( STATUS_SUCCESS );
}


ULONG
VctComputeTransportAddressSize(
   IN PUNICODE_STRING pServerName)

/*++

Routine Description:

    This routine takes a computer name (PUNICODE_STRING) and computes the size of the
    TRANSPORT_ADDRESSS buffer required to connect to it.

Arguments:

    IN PUNICODE_STRING Name - Supplies the name to put into the transport

Return Value:

    size of the buffer.

Notes:

    The compound transport address passed to the transports consists of two
    TDI_NETBIOS_EX_ADDRESSes and a TDI_NETBIOS_ADDRESS. The two NETBIOS_EX addresses refer
    to the two different endpoints registered by the server, i.e., *SMBSERVER and
    the Server name padded upto NETBIOS_NAME_LEN with blanks. The order in which
    the two NETBIOS_EX addresses are constructed depend upon the length of the server
    name. If it is greater than NETBIOS_NAME_LEN *SMBSERVER is the first enpoint
    and vice versa

--*/
{
   ULONG NetbiosAddressLength,NetbiosExAddressLength,TransportAddressSize;
   ULONG OemServerNameLength;

   PAGED_CODE();

   OemServerNameLength = RtlUnicodeStringToOemSize(pServerName);

   NetbiosAddressLength = sizeof(TDI_ADDRESS_NETBIOS);
   if( OemServerNameLength > NETBIOS_NAME_LEN ) {
       NetbiosAddressLength += OemServerNameLength - NETBIOS_NAME_LEN;
   }

   NetbiosExAddressLength = FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,NetbiosAddress) +
                        NetbiosAddressLength;

   TransportAddressSize = FIELD_OFFSET(TRANSPORT_ADDRESS,Address) +
                          3 * FIELD_OFFSET(TA_ADDRESS,Address) +
                          NetbiosAddressLength +
                          2 * NetbiosExAddressLength;

   return TransportAddressSize;
}

NTSTATUS
VctBuildTransportAddress (
    IN  PTRANSPORT_ADDRESS pTransportAddress,
    IN  ULONG              TransportAddressLength,
    IN  PUNICODE_STRING    pServerName,
    OUT PULONG             pServerIpAddress
    )
/*++

Routine Description:

    This routine takes a computer name (PUNICODE_STRING) and converts it into an
    acceptable form for passing in as transport address.

Arguments:

    pTransportAddress      - Supplies the structure to fill in

    TransportAddressLength - Supplies the length of the buffer at TransportAddress

    pServerName            - Supplies the name to put into the transport

    pServerNameIsInIpAddressFormat = Server Name is of the dotted IP address kind

Return Value:

    None.

Notes:

    The compound transport address passed to the transports consists of two
    TDI_NETBIOS_EX_ADDRESSes and a TDI_NETBIOS_ADDRESS. The two NETBIOS_EX addresses refer
    to the two different endpoints registered by the server, i.e., *SMBSERVER and
    the Server name padded upto NETBIOS_NAME_LEN with blanks. The order in which
    the two NETBIOS_EX addresses are constructed depend upon the length of the server
    name. If it is greater than NETBIOS_NAME_LEN *SMBSERVER is the first enpoint
    and vice versa

    The WINS database can be inconsistent for extended periods of time. In order to
    account for this inconsistency on NETBIOS names and DNS names we will not
    issue the address for *SMBSERVER. This will be revisited when we have a better
    mechanism for identifying/authenticating the server and the client machine to each other.

--*/

{
    OEM_STRING OemServerName;
    NTSTATUS   Status;

    PTDI_ADDRESS_NETBIOS_EX pTdiNetbiosExAddress;
    PTDI_ADDRESS_NETBIOS    pTdiNetbiosAddress;
    PTA_ADDRESS             pFirstNetbiosExAddress,pSecondNetbiosExAddress,pNetbiosAddress;

    PCHAR  FirstEndpointName,SecondEndpointName;
    CHAR   EndpointNameBuffer[NETBIOS_NAME_LEN];
    USHORT NetbiosAddressLength,NetbiosExAddressLength;
    USHORT NetbiosAddressType = TDI_ADDRESS_TYPE_NETBIOS;

    ULONG  ComponentLength;

    ULONG   RemoteIpAddress;
    BOOLEAN ServerNameIsInIpAddressForm;

    PAGED_CODE();

    if (TransportAddressLength < VctComputeTransportAddressSize(pServerName)) {
       return STATUS_BUFFER_OVERFLOW;
    }

    pFirstNetbiosExAddress = &pTransportAddress->Address[0];

    pTdiNetbiosExAddress = (PTDI_ADDRESS_NETBIOS_EX)pFirstNetbiosExAddress->Address;
    pTdiNetbiosExAddress->NetbiosAddress.NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;

    OemServerName.Length = pServerName->Length;
    OemServerName.MaximumLength = OemServerName.Length + 1;
    OemServerName.Buffer = pTdiNetbiosExAddress->NetbiosAddress.NetbiosName;

    Status = RtlUpcaseUnicodeStringToOemString(&OemServerName, pServerName, FALSE);
    if( !NT_SUCCESS( Status ) ) {
        return STATUS_BAD_NETWORK_PATH;
    }

    if (OemServerName.Length < NETBIOS_NAME_LEN) {
       RtlCopyMemory( &OemServerName.Buffer[ OemServerName.Length ],
                      "                ",
                      NETBIOS_NAME_LEN - OemServerName.Length
                    );
       OemServerName.Length = NETBIOS_NAME_LEN;
    }

    Status = VctpTranslateNetbiosNameToIpAddress(&OemServerName,&RemoteIpAddress);
    if (Status == STATUS_SUCCESS) {
        if ((RemoteIpAddress == 0) || (RemoteIpAddress == 0xffffffff)) {
           // If the server name is a valid IP address and matches with one of the two
           // broadcast addresses used by IP turn back the request.
           return STATUS_INVALID_ADDRESS_COMPONENT;
        }

        *pServerIpAddress = RemoteIpAddress;
        ServerNameIsInIpAddressForm = TRUE;
    } else {
        *pServerIpAddress = 0;
        ServerNameIsInIpAddressForm = FALSE;
    }


    NetbiosAddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    if( OemServerName.Length > NETBIOS_NAME_LEN ) {
        NetbiosAddressLength += OemServerName.Length - NETBIOS_NAME_LEN;
    }

    NetbiosExAddressLength = (USHORT)(FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,NetbiosAddress) +
                             NetbiosAddressLength);

    pFirstNetbiosExAddress->AddressLength = NetbiosExAddressLength;
    pFirstNetbiosExAddress->AddressType   = TDI_ADDRESS_TYPE_NETBIOS_EX;

    pTransportAddress->TAAddressCount = 2;

    pNetbiosAddress = (PTA_ADDRESS)((PCHAR)pFirstNetbiosExAddress +
                                    FIELD_OFFSET(TA_ADDRESS,Address) +
                                    NetbiosExAddressLength);
    if (ServerNameIsInIpAddressForm) {
       FirstEndpointName = SMBSERVER_LOCAL_ENDPOINT_NAME;
    } else {
       // Scan the server name till the first delimiter (DNS delimiter .) and form
       // the endpoint name by padding the remaining name with blanks.

       RtlCopyMemory(
             EndpointNameBuffer,
             OemServerName.Buffer,
             NETBIOS_NAME_LEN);

       ComponentLength = 0;
       while (ComponentLength < NETBIOS_NAME_LEN) {
          if (EndpointNameBuffer[ComponentLength] == '.') {
             break;
          }
          ComponentLength++;
       }

       if (ComponentLength == NETBIOS_NAME_LEN) {
          EndpointNameBuffer[NETBIOS_NAME_LEN - 1] = ' ';
       } else {
          RtlCopyMemory(&EndpointNameBuffer[ComponentLength],
                        "                ",
                        NETBIOS_NAME_LEN - ComponentLength);
       }

       FirstEndpointName  = EndpointNameBuffer;
    }

    // Copy the first endpoint name
    RtlCopyMemory(
        pTdiNetbiosExAddress->EndpointName,
        FirstEndpointName,
        NETBIOS_NAME_LEN);

    ASSERT(pTransportAddress->TAAddressCount == 2);
    // The Netbios address associated with the first NETBIOS_EX address is the last netbios
    // address that is passed in.

    RtlCopyMemory(
         ((PCHAR)pNetbiosAddress),
         &NetbiosAddressLength,
         sizeof(USHORT));

    RtlCopyMemory(
         ((PCHAR)pNetbiosAddress + FIELD_OFFSET(TA_ADDRESS,AddressType)),
         &NetbiosAddressType,
         sizeof(USHORT));

    RtlCopyMemory(
         ((PCHAR)pNetbiosAddress + FIELD_OFFSET(TA_ADDRESS,Address)),
         &pTdiNetbiosExAddress->NetbiosAddress,
         NetbiosAddressLength);

    return STATUS_SUCCESS;
}

typedef struct _SMBCE_VC_CONNECTION_COMPLETION_CONTEXT {
    RXCE_CONNECTION_COMPLETION_CONTEXT;

    PSMBCE_TRANSPORT_ARRAY     pTransportArray;
    PSMBCE_TRANSPORT           pTransport;
    PSMBCE_SERVER_VC_TRANSPORT pServerTransport;

    ULONG                   TransportAddressLength;
    PTRANSPORT_ADDRESS      pTransportAddress;

    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext;
} SMBCE_VC_CONNECTION_COMPLETION_CONTEXT,
  *PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT;

NTSTATUS
VctpCreateConnectionCallback(
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT pContext)
/*++

Routine Description:

    This is the connection callback routine initiated when the underlying
    transports have completed initialization

Arguments:

    pCOntext = the connection completion context

Notes:

--*/
{
    NTSTATUS Status;

    PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT      pVcCompletionContext;
    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pSmbCeContext;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pVcCompletionContext = (PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT)pContext;
    pSmbCeContext        = pVcCompletionContext->pContext;

    pServerEntry = pSmbCeContext->pServerEntry;

    pSmbCeContext->Status = pVcCompletionContext->Status;

    Status = pVcCompletionContext->Status;

    if (Status == STATUS_SUCCESS) {
        if (pVcCompletionContext->pTransport == NULL) {
            pVcCompletionContext->pTransport =
                pVcCompletionContext->pTransportArray->SmbCeTransports[
                    pVcCompletionContext->AddressIndex];

            SmbCeReferenceTransport(pVcCompletionContext->pTransport);
        }

        // The Server IP address is not known. Query the underlying
        // transport for the remote transport address, i.e., NETBIOS
        // name or IP address. This will be subsequently used to
        // determine the VC number to be used in session setup and X for
        // downlevel servers.

        Status = RxCeQueryInformation(
                    pVcCompletionContext->pVc,
                    RxCeRemoteAddressInformation,
                    pVcCompletionContext->pTransportAddress,
                    pVcCompletionContext->TransportAddressLength);

        if (Status == STATUS_SUCCESS) {
            ULONG   NumberOfAddresses;
            USHORT  AddressLength;
            USHORT  AddressType;
            PBYTE   pBuffer = (PBYTE)pVcCompletionContext->pTransportAddress;

            // All Transports currently return a data structure in which
            // the first four bytes are a ULONG which encodes the number
            // of connections opened to the given remote address. The
            // actual Transport address follows.
            pBuffer += sizeof(ULONG);

            // The buffer contains a TRANSPORT_ADDRESS, the first field
            // of which is the count.
            NumberOfAddresses = SmbGetUlong(pBuffer);

            // This is followed by an array of variable length TA_ADDRESS
            // structures. At this point pBuffer points to the first
            // TA_ADDRESS.
            pBuffer += sizeof(ULONG);

            while (NumberOfAddresses-- > 0) {
                AddressLength = SmbGetUshort(pBuffer);
                pBuffer += sizeof(USHORT);

                AddressType = SmbGetUshort(pBuffer);

                if (AddressType != TDI_ADDRESS_TYPE_IP) {
                    // skip to the next TA_ADDRESS
                    pBuffer += AddressLength + sizeof(USHORT);
                } else {
                    // Skip past the type field to position at the
                    // corresponding TDI_ADDRESS_IP structure
                    pBuffer += sizeof(USHORT);

                    // skip to the in_addr field
                    pBuffer += FIELD_OFFSET(TDI_ADDRESS_IP,in_addr);

                    // Extract the IP address
                    RtlCopyMemory(
                        &pServerEntry->Server.IpAddress,
                        pBuffer,
                        sizeof(ULONG));

                    break;
                }
            }
        } else {
           RxDbgTrace(0, Dbg, ("Remote Address Query returned %lx\n",Status));
        }

        if (NT_SUCCESS(Status)) {
            Status = VctCompleteInitialization(
                         pServerEntry,                            // The server entry
                         pVcCompletionContext->pTransport,        // the transport/address information
                         pVcCompletionContext->pServerTransport); // the server transport instance
        }

        if (NT_SUCCESS(Status)) {
            pSmbCeContext->pTransport =
                (PSMBCE_SERVER_TRANSPORT)pVcCompletionContext->pServerTransport;
            pVcCompletionContext->pServerTransport = NULL;
            pVcCompletionContext->pTransport = NULL;
        }

        pSmbCeContext->Status = Status;
    }

    if (!NT_SUCCESS(Status)) {
        RxCeTearDownVC(pVcCompletionContext->pVc);
        RxCeTearDownConnection(pVcCompletionContext->pConnection);
        SmbCeDereferenceTransport(pVcCompletionContext->pTransport);
        pVcCompletionContext->pTransport = NULL;
    }

    if (pVcCompletionContext->pTransportArray != NULL) {
        SmbCeDereferenceTransportArray(pVcCompletionContext->pTransportArray);
    }

    if (pVcCompletionContext->pTransportAddress != NULL) {
        RxFreePool(pVcCompletionContext->pTransportAddress);
    }

    ASSERT(pVcCompletionContext->pTransport == NULL);

    if (pVcCompletionContext->pServerTransport != NULL) {
        SmbMmFreeServerTransport(
            (PSMBCE_SERVER_TRANSPORT)pVcCompletionContext->pServerTransport);
    }

    RxFreePool(pVcCompletionContext);

    pSmbCeContext->State  = SmbCeServerVcTransportConstructionEnd;

    SmbCeConstructServerTransport(pSmbCeContext);
    return STATUS_SUCCESS;
}

NTSTATUS
VctInstantiateServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pContext - the transport construction context

Return Value:

    STATUS_PENDING - asynchronous construction has been initiated

Notes:

    Currently, only connection oriented transports are handled. The current TDI
    spec expects handles to be passed in as part of the connect request. This
    implies that connect/reconnect/disconnect requests need to be issued from the
    process which created the connection. In the case of the SMB mini rdr there
    is no FSP associated with it ( threads are borrowed/commandeered ) from the
    system process to do all the work. This is the reason for special casing VC
    initialization into a separate routine. The server transport initialization
    routine handles the other transport initialization and also provides the
    context for VC initialization.

--*/
{
    NTSTATUS Status = STATUS_PENDING;

    PSMBCE_TRANSPORT_ARRAY pTransportArray;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pTransportArray   = SmbCeReferenceTransportArray();

    if (pTransportArray == NULL) {
        Status = STATUS_NETWORK_UNREACHABLE;
    } else {
        PSMBCEDB_SERVER_ENTRY  pServerEntry;
        UNICODE_STRING         ServerName;

        PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT pCompletionContext;

        ULONG ServerIpAddress;

        pServerEntry = pContext->pServerEntry;

        ServerName.Buffer        = pServerEntry->Name.Buffer + 1;
        ServerName.Length        = pServerEntry->Name.Length - sizeof(WCHAR);
        ServerName.MaximumLength = pServerEntry->Name.MaximumLength - sizeof(WCHAR);

        pServerEntry->Server.IpAddress = 0;

        pCompletionContext = (PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT)
                             RxAllocatePoolWithTag(
                                 NonPagedPool,
                                 sizeof(SMBCE_VC_CONNECTION_COMPLETION_CONTEXT),
                                 MRXSMB_VC_POOLTAG);
        
        if (pCompletionContext != NULL) {
            pCompletionContext->pConnectionInformation = NULL;
            
            pCompletionContext->pContext = pContext;

            pCompletionContext->TransportAddressLength = VctComputeTransportAddressSize(
                                                             &ServerName);

            pCompletionContext->pTransportAddress = (PTRANSPORT_ADDRESS)
                                                    RxAllocatePoolWithTag(
                                                        NonPagedPool,
                                                        pCompletionContext->TransportAddressLength,
                                                        MRXSMB_VC_POOLTAG);

            if (pCompletionContext->pTransportAddress == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                Status = VctBuildTransportAddress(
                             pCompletionContext->pTransportAddress,
                             pCompletionContext->TransportAddressLength,
                             &ServerName,
                             &ServerIpAddress);
            }

            if (Status == STATUS_SUCCESS) {
                pCompletionContext->pServerTransport = (PSMBCE_SERVER_VC_TRANSPORT)
                                                       SmbMmAllocateServerTransport(
                                                           SMBCE_STT_VC);

                if (pCompletionContext->pServerTransport == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    pCompletionContext->pConnection =
                        &(pCompletionContext->pServerTransport->RxCeConnection);
                    pCompletionContext->pVc =
                        &(pCompletionContext->pServerTransport->Vcs[0].RxCeVc);
                }
            }

            if (Status == STATUS_SUCCESS) {
                RXCE_CONNECTION_INFORMATION InitialConnectionInformation;

                PSMBCE_TRANSPORT        pTransport;

                PAGED_CODE();

                InitialConnectionInformation.UserDataLength = 0;
                InitialConnectionInformation.OptionsLength  = 0;
                InitialConnectionInformation.RemoteAddressLength =
                    pCompletionContext->TransportAddressLength;
                InitialConnectionInformation.RemoteAddress       =
                    pCompletionContext->pTransportAddress;

                pCompletionContext->pTransport = NULL;
                pCompletionContext->pTransportArray   = pTransportArray;

                if (pServerEntry->PreferredTransport != NULL) {
                    pTransport = pServerEntry->PreferredTransport;

                    Status = RxCeBuildConnection(
                                 &pTransport->RxCeAddress,
                                 &InitialConnectionInformation,
                                 &MRxSmbVctConnectionEventHandler,
                                 pServerEntry,
                                 pCompletionContext->pConnection,
                                 pCompletionContext->pVc);

                    if (Status == STATUS_SUCCESS) {
                        pCompletionContext->pTransport = pTransport;
                        SmbCeReferenceTransport(pTransport);
                    }

                    ASSERT(Status != STATUS_PENDING);

                    if (Status != STATUS_SUCCESS) {
                        SmbCeDereferenceTransport(pServerEntry->PreferredTransport);
                        pServerEntry->PreferredTransport = NULL;
                    }

                    pCompletionContext->Status = Status;

                    VctpCreateConnectionCallback(
                        (PRXCE_CONNECTION_COMPLETION_CONTEXT)pCompletionContext);

                    Status = STATUS_PENDING;
                } else {

                    Status = RxCeBuildConnectionOverMultipleTransports(
                                 MRxSmbDeviceObject,
//                                 MRxSmbObeyBindingOrder ?
//                                    RxCeSelectBestSuccessfulTransport :
                                    RxCeSelectFirstSuccessfulTransport,

                                 pCompletionContext->pTransportArray->Count,
                                 pCompletionContext->pTransportArray->LocalAddresses,
                                 &ServerName,
                                 &InitialConnectionInformation,
                                 &MRxSmbVctConnectionEventHandler,
                                 pServerEntry,
                                 VctpCreateConnectionCallback,
                                 (PRXCE_CONNECTION_COMPLETION_CONTEXT) pCompletionContext);

                    ASSERT(Status == STATUS_PENDING);
                }
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (Status != STATUS_PENDING) {
            if (pCompletionContext != NULL) {
                RxFreePool(pCompletionContext);
            }

            SmbCeDereferenceTransportArray(pTransportArray);
        }
    }

    if (Status != STATUS_PENDING) {
        ASSERT(Status != STATUS_SUCCESS);

        pContext->State  = SmbCeServerVcTransportConstructionEnd;
        pContext->Status = Status;

        // Call the construct server transport routine to complete the construction
        SmbCeConstructServerTransport(pContext);

        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
VctTearDownServerTransport(
   PSMBCE_SERVER_TRANSPORT pServerTransport)
{
    NTSTATUS Status;
    PKEVENT pRundownEvent = pServerTransport->pRundownEvent;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    Status = VctUninitialize(pServerTransport);

    if (pRundownEvent != NULL) {
        KeSetEvent(pRundownEvent, 0, FALSE );
    }

    return Status;
}

NTSTATUS
VctInitiateDisconnect(
    PSMBCE_SERVER_TRANSPORT pServerTransport)
{
    ULONG                      VcIndex;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerTransport;

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        NTSTATUS Status;

        pVc = &pVcTransport->Vcs[VcIndex];

        Status = RxCeInitiateVCDisconnect(&pVc->RxCeVc);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg, ("VctInitiateDisconnect: Disconnected Status %lxd\n",Status));
        }
    }

    return STATUS_SUCCESS;
}

PFILE_OBJECT
SmbCepReferenceEndpointFileObject(
    PSMBCE_SERVER_TRANSPORT pTransport)
/*++

Routine Description:

    This routine returns the connection file object associated with
    a transport

Arguments:

    pTransport - the transport instance

Notes:

    This routine currently returns this for VC transports. When we implement
    other transports a suitable abstraction needs to be implemented

--*/
{
    PFILE_OBJECT         pEndpointFileObject =  NULL;
    PSMBCE_OBJECT_HEADER pHeader = (PSMBCE_OBJECT_HEADER)pTransport;

    if ((pHeader != NULL) && (pHeader->ObjectType == SMBCE_STT_VC)) {
        PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

        pEndpointFileObject = pVcTransport->Vcs[0].RxCeVc.pEndpointFileObject;

        if (pEndpointFileObject != NULL) {
            ObReferenceObject(pEndpointFileObject);
        }

    }

    return pEndpointFileObject;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\transact.c ===
/*++
Copyright (c) 1987 - 1999  Microsoft Corporation

Module Name:

    transact.c

Abstract:

    This file conatins the implementation of the transact exchange.

--*/

#include "precomp.h"
#pragma hdrstop

#pragma warning(error:4100)   // Unreferenced formal parameter

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeInitializeTransactionParameters)
#pragma alloc_text(PAGE, SmbCeUninitializeTransactionParameters)
#pragma alloc_text(PAGE, SmbCeDiscardTransactExchange)
#pragma alloc_text(PAGE, SmbCeSubmitTransactionRequest)
#pragma alloc_text(PAGE, _SmbCeTransact)
#pragma alloc_text(PAGE, SmbTransactBuildHeader)
#pragma alloc_text(PAGE, SmbTransactExchangeStart)
#pragma alloc_text(PAGE, SmbTransactExchangeAbort)
#pragma alloc_text(PAGE, SmbTransactExchangeErrorHandler)
#pragma alloc_text(PAGE, SmbTransactExchangeSendCallbackHandler)
#pragma alloc_text(PAGE, SmbCeInitializeTransactExchange)
#pragma alloc_text(PAGE, SendSecondaryRequests)
#endif

//#define SET_DONTSUBSUME_PARAMS
#ifdef SET_DONTSUBSUME_PARAMS
ULONG MRxSmbDontSubsumeParams = 1;
#else
ULONG MRxSmbDontSubsumeParams = 0;
#endif
#if DBG
#define DONTSUBSUME_PARAMS MRxSmbDontSubsumeParams
#else
#define DONTSUBSUME_PARAMS FALSE
#endif

SMB_TRANSACTION_OPTIONS RxDefaultTransactionOptions = DEFAULT_TRANSACTION_OPTIONS;

RXDT_DefineCategory(TRANSACT);
#define Dbg        (DEBUG_TRACE_TRANSACT)

#define MIN(x,y)  ((x) < (y) ? (x) : (y))

#define SMB_TRANSACT_MAXIMUM_PARAMETER_SIZE (0xffff)
#define SMB_TRANSACT_MAXIMUM_DATA_SIZE      (0xffff)

typedef struct _SMB_TRANSACT_RESP_FORMAT_DESCRIPTION {
    ULONG WordCount;
    ULONG TotalParameterCount;
    ULONG TotalDataCount;
    ULONG ParameterCount;
    ULONG ParameterOffset;
    ULONG ParameterDisplacement;
    ULONG DataCount;
    ULONG DataOffset;
    ULONG DataDisplacement;
    ULONG ByteCount;
    ULONG ApparentMsgLength;
} SMB_TRANSACT_RESP_FORMAT_DESCRIPTION, *PSMB_TRANSACT_RESP_FORMAT_DESCRIPTION;

NTSTATUS
SmbTransactAccrueAndValidateFormatData(
    IN struct _SMB_TRANSACT_EXCHANGE *pTransactExchange,    // The exchange instance
    IN  PSMB_HEADER pSmbHeader,
    IN  ULONG        BytesIndicated,
    OUT PSMB_TRANSACT_RESP_FORMAT_DESCRIPTION Format
    );

extern NTSTATUS
SmbTransactExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize);

extern NTSTATUS
ParseTransactResponse(
    IN struct _SMB_TRANSACT_EXCHANGE *pTransactExchange,    // The exchange instance
    IN PSMB_TRANSACT_RESP_FORMAT_DESCRIPTION Format,
    IN ULONG        BytesIndicated,
    IN ULONG        BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pCopyRequestMdlPointer,
    OUT PULONG      pCopyRequestSize);


extern NTSTATUS
SendSecondaryRequests(PVOID pContext);

extern NTSTATUS
SmbCeInitializeTransactExchange(
    PSMB_TRANSACT_EXCHANGE              pTransactExchange,
    PRX_CONTEXT                         RxContext,
    PSMB_TRANSACTION_OPTIONS            pOptions,
    PSMB_TRANSACTION_SEND_PARAMETERS    pSendParameters,
    PSMB_TRANSACTION_RECEIVE_PARAMETERS pReceiveParameters,
    PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext);

NTSTATUS
SmbCeInitializeTransactionParameters(
   PVOID  pSetup,
   USHORT SetupLength,
   PVOID  pParam,
   ULONG  ParamLength,
   PVOID  pData,
   ULONG  DataLength,
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters
)
/*++

Routine Description:

    This routine initializes the transaction parameters

Arguments:

    pSetup             - the setup buffer

    SetupLength        - the setup buffer length

    pParam             - the param buffer

    ParamLength        - the param buffer length

    pData              - the data buffer

    DataLength         - the data buffer length

    pTransactionParameters - the transaction parameters instance

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The TRANSACTION parameters come in two flavours -- the send parameters for the data
    that is to be sent to the server and the receive parameters for receiving the data
    from the server. There is one subtle difference in the way in which the parameters are
    stored and referenced in these two cases. In the send case the Setup buffer is stored
    as a pointer itself while in the receive case it is stored in the form of a MDL.

    This is because the SMB protocol requires that the Header + setup information for a
    transaction request cannot be greated then the maximum SMB buffer size, i.e., setup
    information cannot spill to a secondary request. The buffer that is allocated for the
    header is made sufficiently large enough to hold the setup data as well. On the other
    hand the receives are handled in a two phase manner, -- the indication at the DPC
    level followed by a copy data request if required. In order to avoid having to transition
    between DPC level and a worker thread the MDL's for the buffers are eagerly evaluated.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PMDL     pSetupMdl = NULL;
    PMDL     pParamMdl = NULL;
    PMDL     pDataMdl  = NULL;

    PAGED_CODE();

    if (pTransactionParameters->Flags & TRANSACTION_RECEIVE_PARAMETERS_FLAG) {
        if (pSetup != NULL) {
            pSetupMdl = RxAllocateMdl(pSetup,SetupLength);
            if (pSetupMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RxProbeAndLockPages(pSetupMdl,KernelMode,IoModifyAccess,Status);
                if (Status != STATUS_SUCCESS) {
                    IoFreeMdl(pSetupMdl);
                    pSetupMdl = NULL;
                } else {
                    if (MmGetSystemAddressForMdlSafe(pSetupMdl,LowPagePriority) == NULL) { //this maps the Mdl
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }
        }

        if ((Status == STATUS_SUCCESS) && (pParam != NULL)) {
            pParamMdl = RxAllocateMdl(pParam,ParamLength);
            if (pParamMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RxProbeAndLockPages(pParamMdl,KernelMode,IoModifyAccess,Status);
                if ((Status != STATUS_SUCCESS)) {
                    IoFreeMdl(pParamMdl);
                    pParamMdl = NULL;
                } else {
                    if (MmGetSystemAddressForMdlSafe(pParamMdl,LowPagePriority) == NULL) { //this maps the Mdl
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }
        }

        pTransactionParameters->SetupLength = SetupLength;
        pTransactionParameters->ParamLength = ParamLength;
        pTransactionParameters->pParamMdl = pParamMdl;
        pTransactionParameters->pSetupMdl = pSetupMdl;
    } else {
        pTransactionParameters->SetupLength = SetupLength;
        pTransactionParameters->pSetup      = pSetup;
        pTransactionParameters->ParamLength = ParamLength;
        pTransactionParameters->pParam      = pParam;
        pTransactionParameters->pParamMdl = NULL;
    }

    ASSERT( !((pData == NULL)&&(DataLength!=0)) );
    if ((Status == STATUS_SUCCESS) && (pData != NULL) && (DataLength > 0)) {
        pDataMdl = RxAllocateMdl(pData,DataLength);
        if (pDataMdl == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            RxProbeAndLockPages(pDataMdl,KernelMode,IoModifyAccess,Status);
            if ((Status != STATUS_SUCCESS)) {
                IoFreeMdl(pDataMdl);
                pDataMdl = NULL;
            } else {
                if (MmGetSystemAddressForMdlSafe(pDataMdl,LowPagePriority) == NULL) { //this maps the Mdl
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
    }

    pTransactionParameters->pDataMdl  = pDataMdl;
    pTransactionParameters->DataLength  = DataLength;
    ASSERT((Status != STATUS_SUCCESS) || (DataLength == 0) || (pDataMdl != NULL));

    if ((Status != STATUS_SUCCESS)) {
        if (pTransactionParameters->Flags & TRANSACTION_RECEIVE_PARAMETERS_FLAG) {
            if (pSetupMdl != NULL) {
                MmUnlockPages(pSetupMdl);  //this unmaps as well
                IoFreeMdl(pSetupMdl);
            }

            if (pParamMdl != NULL) {
                MmUnlockPages(pParamMdl);
                IoFreeMdl(pParamMdl);
            }
        }

        if (pDataMdl != NULL) {
            MmUnlockPages(pDataMdl);
            IoFreeMdl(pDataMdl);
        }
    }

    return Status;
}

VOID
SmbCeUninitializeTransactionParameters(
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters
)
/*++

Routine Description:

    This routine uninitializes the transaction parameters, i.e., free the associated MDL's

Arguments:

    pTransactionParameters - the parameter instance for uninitialization

--*/
{
    PAGED_CODE();

    if (pTransactionParameters->Flags & TRANSACTION_RECEIVE_PARAMETERS_FLAG) {
        if (pTransactionParameters->pSetupMdl != NULL) {
            MmUnlockPages(pTransactionParameters->pSetupMdl);
            IoFreeMdl(pTransactionParameters->pSetupMdl);
        }
    }

    if (pTransactionParameters->pParamMdl != NULL) {
         MmUnlockPages(pTransactionParameters->pParamMdl);
        IoFreeMdl(pTransactionParameters->pParamMdl);
    }

    if (pTransactionParameters->pDataMdl != NULL
        && !BooleanFlagOn(pTransactionParameters->Flags,SMB_XACT_FLAGS_CALLERS_SENDDATAMDL)) {
        MmUnlockPages(pTransactionParameters->pDataMdl);
        IoFreeMdl(pTransactionParameters->pDataMdl);
    }
}

VOID
SmbCeDiscardTransactExchange(PSMB_TRANSACT_EXCHANGE pTransactExchange)
/*++

Routine Description:

    This routine discards a transact exchange

Arguments:

    pExchange - the exchange instance

--*/
{
    PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext;

    PAGED_CODE();

    // Deallocate any transact exchange specfic allocations ...
    if (pTransactExchange->pActualPrimaryRequestSmbHeader != NULL) {
        RxFreePool(pTransactExchange->pActualPrimaryRequestSmbHeader);
    }

    if (pTransactExchange->pReceiveSetupMdl != NULL) {
        MmUnlockPages(pTransactExchange->pReceiveSetupMdl);
        IoFreeMdl(pTransactExchange->pReceiveSetupMdl);
    }

    if (pTransactExchange->pReceiveParamMdl != NULL) {
        MmUnlockPages(pTransactExchange->pReceiveParamMdl);
        IoFreeMdl(pTransactExchange->pReceiveParamMdl);
    }

    if (pTransactExchange->pReceiveDataMdl != NULL) {
        MmUnlockPages(pTransactExchange->pReceiveDataMdl);
        IoFreeMdl(pTransactExchange->pReceiveDataMdl);
    }

    if (pTransactExchange->pSendSetupMdl != NULL) {
        MmUnlockPages(pTransactExchange->pSendSetupMdl);
        IoFreeMdl(pTransactExchange->pSendSetupMdl);
    }

    if ((pTransactExchange->pSendDataMdl != NULL) &&
         !BooleanFlagOn(pTransactExchange->Flags,SMB_XACT_FLAGS_CALLERS_SENDDATAMDL)) {
        MmUnlockPages(pTransactExchange->pSendDataMdl);
        IoFreeMdl(pTransactExchange->pSendDataMdl);
    }

    if (pTransactExchange->pSendParamMdl != NULL) {
        MmUnlockPages(pTransactExchange->pSendParamMdl);
        IoFreeMdl(pTransactExchange->pSendParamMdl);
    }

    if ((pResumptionContext = pTransactExchange->pResumptionContext) != NULL) {
        NTSTATUS FinalStatus;
        PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry((PSMB_EXCHANGE)pTransactExchange);

        RxDbgTrace(0, Dbg,
                 ("SmbCeTransactExchangeFinalize: everythings is good! parambytes (%ld) databytes (%ld)\n",
                  pTransactExchange->ParamBytesReceived, pTransactExchange->DataBytesReceived
                ));

        FinalStatus = pTransactExchange->Status;

        if (pServerEntry->ServerStatus != STATUS_SUCCESS) {
            // If the server entry is in error state, the transact cannot receive a response from server.
            // In this case, we return the server status.
            pResumptionContext->FinalStatusFromServer = pServerEntry->ServerStatus;
        } else {
            // If the server entry is in good or disconnected state, we return the smb status.
            pResumptionContext->FinalStatusFromServer = pTransactExchange->SmbStatus;
        }

        if ((FinalStatus == STATUS_SUCCESS)||
            (FinalStatus == STATUS_MORE_PROCESSING_REQUIRED)) {

            FinalStatus = pResumptionContext->FinalStatusFromServer;
        }

        pResumptionContext->SmbCeResumptionContext.Status = FinalStatus;
        pResumptionContext->SetupBytesReceived = pTransactExchange->SetupBytesReceived;
        pResumptionContext->DataBytesReceived = pTransactExchange->DataBytesReceived;
        pResumptionContext->ParameterBytesReceived = pTransactExchange->ParamBytesReceived;
        pResumptionContext->ServerVersion = pTransactExchange->ServerVersion;

        SmbCeResume(&pResumptionContext->SmbCeResumptionContext);
    }

    SmbCeDereferenceAndDiscardExchange((PSMB_EXCHANGE)pTransactExchange);
}

NTSTATUS
SmbCeSubmitTransactionRequest(
    PRX_CONTEXT                           RxContext,
    PSMB_TRANSACTION_OPTIONS              pOptions,
    PSMB_TRANSACTION_PARAMETERS           pSendParameters,
    PSMB_TRANSACTION_PARAMETERS           pReceiveParameters,
    PSMB_TRANSACTION_RESUMPTION_CONTEXT   pResumptionContext )
/*++

Routine Description:

    This routine submits a transaction request, i.e., allocates/initializes a transaction
    exchange, sets up the completion information and initiates it

Arguments:

    pNetRoot           - the netroot for which the transaction request is intended

    pOptions           - the transaction options

    pSendParameters    - the transaction parameters to be sent to the server

    pReceiveParameters - the transaction results from the server

    pResumptionContext - the context for resuming the local activity on completion of the
                         transaction

Return Value:

    RXSTATUS - The return status for the operation
      STATUS_PENDING -- if the transcation was initiated successfully
      Other error codes if the request could not be submitted successfully

Notes:

    Whenever a status of STATUS_PENDING is returned it implies that the transact
    exchange has assumed ownership of the MDLs passed in as receive and send
    parameters. They will be released on completion of the exchange.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_V_NET_ROOT pVNetRoot = NULL;

    PSMB_TRANSACT_EXCHANGE pTransactExchange;
    PSMB_EXCHANGE          pExchange = NULL;

    PAGED_CODE();

    if (capFobx == NULL) {
        if (RxContext->MajorFunction == IRP_MJ_CREATE) {
            pVNetRoot = RxContext->Create.pVNetRoot;
        }
    } else {
        // These are the root objects which are associated with the device FCB. In
        // such cases

        pVNetRoot = (PMRX_V_NET_ROOT)capFobx;

        if (NodeType(pVNetRoot) != RDBSS_NTC_V_NETROOT) {
            pVNetRoot = capFobx->pSrvOpen->pVNetRoot;
        }
    }

    if (pVNetRoot == NULL) {
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

        // Allocate and initialize an exchange for the given net root.
        Status = SmbCeInitializeExchange2(
                    &pExchange,
                    RxContext,
                    pServerEntry,
                    TRANSACT_EXCHANGE,
                    &TransactExchangeDispatch);
    } else {
        // Allocate and initialize an exchange for the given net root.
        Status = SmbCeInitializeExchange(
                    &pExchange,
                    RxContext,
                    pVNetRoot,
                    TRANSACT_EXCHANGE,
                    &TransactExchangeDispatch);
    }

    if (Status == STATUS_SUCCESS) {
        // Initialize the transact exchange
        pTransactExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;

        Status = SmbCeInitializeTransactExchange(
                     pTransactExchange,
                     RxContext,
                     pOptions,
                     pSendParameters,
                     pReceiveParameters,
                     pResumptionContext);

        if (Status == STATUS_SUCCESS) {
            // The transact exchange can be either asynchronous or synchronous. In
            // the asynchronous case an additional reference is taken which is
            // passed onto the caller alongwith the exchange squirelled away in the
            // RX_CONTEXT if STATUS_PENDING is being returned. This enables the
            // caller to control when the exchange is discarded. This works
            // especially well in dealing with cancellation of asynchronous
            // exchanges.

            // This reference will be accounted for by the finalization routine
            // of the transact exchange.
            SmbCeReferenceExchange((PSMB_EXCHANGE)pTransactExchange);

            if (BooleanFlagOn(pOptions->Flags,SMB_XACT_FLAGS_ASYNCHRONOUS)) {
                // The corresponding dereference is the callers responsibility
                SmbCeReferenceExchange((PSMB_EXCHANGE)pTransactExchange);
            }

            pResumptionContext->pTransactExchange = pTransactExchange;
            pResumptionContext->SmbCeResumptionContext.Status = STATUS_SUCCESS;

            SmbCeIncrementPendingLocalOperations(pExchange);

            // Initiate the exchange
            Status = SmbCeInitiateExchange(pExchange);

            if (Status != STATUS_PENDING) {
                pExchange->Status = Status;

                if (pExchange->SmbStatus == STATUS_SUCCESS) {
                    pExchange->SmbStatus = Status;
                }

                if (BooleanFlagOn(pOptions->Flags,SMB_XACT_FLAGS_ASYNCHRONOUS)) {
                    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

                    pMRxSmbContext->pExchange     = NULL;

                    // Since the exchange has already been completed there is no
                    // point in returning the additional reference to the caller
                    SmbCeDereferenceExchange((PSMB_EXCHANGE)pTransactExchange);
                }
            }

            SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

            // Map the status to STATUS_PENDING so that continuation routines
            // do not attempt to finalize.
            Status = STATUS_PENDING;
        } else {
            PMRXSMB_RX_CONTEXT MRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

            ASSERT(MRxSmbContext->pExchange == pExchange);
            MRxSmbContext->pExchange = NULL;

            SmbCeDiscardExchange(pExchange);
        }
    }

    return Status;
}

NTSTATUS
_SmbCeTransact(
   PRX_CONTEXT                         RxContext,
   PSMB_TRANSACTION_OPTIONS            pOptions,
   PVOID                               pInputSetupBuffer,
   ULONG                               InputSetupBufferLength,
   PVOID                               pOutputSetupBuffer,
   ULONG                               OutputSetupBufferLength,
   PVOID                               pInputParamBuffer,
   ULONG                               InputParamBufferLength,
   PVOID                               pOutputParamBuffer,
   ULONG                               OutputParamBufferLength,
   PVOID                               pInputDataBuffer,
   ULONG                               InputDataBufferLength,
   PVOID                               pOutputDataBuffer,
   ULONG                               OutputDataBufferLength,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext)
/*++

Routine Description:

    This routine implements a standardized mechanism of submitting transaction requests,
    and synchronizing with their completion. This does not provide the smae amount of control
    that SmbCeSubmitTransactRequest provides. Nevertheless, this implements a common mechanism
    that should satisfy most needs

Arguments:

    RxContext               - the context for the transaction

    pOptions                - the transaction options

    pSetupBuffer            - the transaction setup buffer

    SetupBufferlength       - the setup buffer length

    pInputParamBuffer       - the Input param buffer

    InputParamBufferLength  - the input param buffer length

    pOutputParamBuffer      - the output param buffer

    OutputParamBufferlength - the output param buffer length

    pInputDataBuffer        - the Input data buffer

    InputDataBufferLength   - the input data buffer length

    pOutputDataBuffer       - the output data buffer

    OutputDataBufferlength  - the output data buffer length

    pResumptionContext       - the transaction resumption context

Return Value:

    RXSTATUS - The return status for the operation
      STATUS_SUCCESS if successfull.
      Other error codes if the request could not be submitted successfully

Notes:

    In the case of asynchronous exchanges if STATUS_PENDING is returned the
    Exchange instance is squirelled away in the minirdr context associated with
    the given RX_CONTEXT instance. This exchange will not be discarded without
    the callers intervention. It is the callers responsibility to invoke
    SmbCeDereferenceAndDiscardExchange to discard the exchange

--*/
{
    NTSTATUS Status;

    SMB_TRANSACTION_SEND_PARAMETERS     SendParameters;
    SMB_TRANSACTION_RECEIVE_PARAMETERS  ReceiveParameters;
    BOOLEAN                             fAsynchronous;

    PAGED_CODE();

    fAsynchronous = BooleanFlagOn(pOptions->Flags,SMB_XACT_FLAGS_ASYNCHRONOUS);

    Status = SmbCeInitializeTransactionSendParameters(
                 pInputSetupBuffer,
                 (USHORT)InputSetupBufferLength,
                 pInputParamBuffer,
                 InputParamBufferLength,
                 pInputDataBuffer,
                 InputDataBufferLength,
                 &SendParameters);

    if (Status == STATUS_SUCCESS) {
        Status = SmbCeInitializeTransactionReceiveParameters(
                     pOutputSetupBuffer,        // the setup information expected in return
                     (USHORT)OutputSetupBufferLength,   // the length of the setup information
                     pOutputParamBuffer,        // the buffer for the param information
                     OutputParamBufferLength,   // the length of the param buffer
                     pOutputDataBuffer,         // the buffer for data
                     OutputDataBufferLength,    // the length of the buffer
                     &ReceiveParameters);

        if (Status != STATUS_SUCCESS) {
            SmbCeUninitializeTransactionSendParameters(&SendParameters);
        }
    }

    if (Status == STATUS_SUCCESS) {
        Status = SmbCeSubmitTransactionRequest(
                     RxContext,                    // the RXContext for the transaction
                     pOptions,                     // transaction options
                     &SendParameters,              // input parameters
                     &ReceiveParameters,           // expected results
                     pResumptionContext            // the context for resumption.
                     );

        if ((Status != STATUS_SUCCESS) &&
            (Status != STATUS_PENDING)) {
            SmbCeUninitializeTransactionReceiveParameters(&ReceiveParameters);
            SmbCeUninitializeTransactionSendParameters(&SendParameters);
        } else {
            if (!fAsynchronous) {
                if (Status == STATUS_PENDING) {
                    SmbCeWaitOnTransactionResumptionContext(pResumptionContext);
                    Status = pResumptionContext->SmbCeResumptionContext.Status;
                    if (Status != STATUS_SUCCESS) {
                        RxDbgTrace(0,Dbg,("SmbCeTransact: Transaction Request Completion Status %lx\n",Status));
                    }
                } else if (Status != STATUS_SUCCESS) {
                    RxDbgTrace(0,Dbg,("SmbCeTransact: SmbCeSubmitTransactRequest returned %lx\n",Status));
                } else {
                    Status = pResumptionContext->SmbCeResumptionContext.Status;
                }
            }
        }
    }

    ASSERT(fAsynchronous || (Status != STATUS_PENDING));

    if (fAsynchronous && (Status != STATUS_PENDING)) {
        pResumptionContext->SmbCeResumptionContext.Status = Status;
        SmbCeResume(&pResumptionContext->SmbCeResumptionContext);
        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
SmbTransactBuildHeader(
    PSMB_TRANSACT_EXCHANGE  pTransactExchange,
    UCHAR                   SmbCommand,
    PSMB_HEADER             pHeader)
/*++

Routine Description:

    This routine builds the SMB header for transact exchanges

Arguments:

    pTransactExchange  - the exchange instance

    SmbCommand - the SMB command

    pHeader    - the SMB buffer header

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;
    ULONG    BufferConsumed;

    UCHAR    LastCommandInHeader;
    PUCHAR   pCommand;

    PAGED_CODE();

    // Initialize the SMB header  ...
    Status = SmbCeBuildSmbHeader(
                 (PSMB_EXCHANGE)pTransactExchange,
                 pHeader,
                 sizeof(SMB_HEADER),
                 &BufferConsumed,
                 &LastCommandInHeader,
                 &pCommand);

    if (Status == STATUS_SUCCESS) {
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        ASSERT(LastCommandInHeader == SMB_COM_NO_ANDX_COMMAND);
        *pCommand = SmbCommand;

        pServerEntry = SmbCeGetExchangeServerEntry(pTransactExchange);

        if (FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
            // for NT servers, we have to set the pid/pidhigh fields so that RPC will work.
            SmbCeSetFullProcessIdInHeader(
                (PSMB_EXCHANGE)pTransactExchange,
                RxGetRequestorProcessId(pTransactExchange->RxContext),
                ((PNT_SMB_HEADER)pHeader));
        }

        if (pTransactExchange->Flags & SMB_XACT_FLAGS_DFS_AWARE) {
            pHeader->Flags2 |= SMB_FLAGS2_DFS;
        }
    }

    return Status;
}


NTSTATUS
SmbTransactExchangeStart(
      PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for transact exchanges. This initiates the construction of the
    appropriate SMB's if required.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_TRANSACT_EXCHANGE pTransactExchange;
    PVOID                  pActualPrimaryRequestSmbHeader;
    PSMB_HEADER            pPrimaryRequestSmbHeader;

    // The MDL's used in sending the primary request associated with the TRANSACT SMB
    PMDL  pPartialDataMdl       = NULL;
    PMDL  pPartialParamMdl      = NULL;
    PMDL  pPaddingMdl           = NULL;
    PMDL  pPrimaryRequestSmbMdl = NULL;
    PMDL  pLastMdlInChain       = NULL;

    ULONG   MaximumSmbBufferSize;
    ULONG   PrimaryRequestSmbSize = 0;
    ULONG   PaddingLength = 0;
    BOOLEAN QuadwordAlignmentRequired = FALSE;

    ULONG ParamBytesToBeSent = 0;
    ULONG DataBytesToBeSent = 0;

    ULONG ParamOffset,DataOffset;
    ULONG SmbLength;
    ULONG BccOffset;
    ULONG MdlLength;

    USHORT *pBcc;

    PAGED_CODE();

    pTransactExchange        = (PSMB_TRANSACT_EXCHANGE)pExchange;

    pActualPrimaryRequestSmbHeader = pTransactExchange->pActualPrimaryRequestSmbHeader;
    pPrimaryRequestSmbHeader = pTransactExchange->pPrimaryRequestSmbHeader;

    ASSERT(pActualPrimaryRequestSmbHeader != NULL);
    ASSERT(pPrimaryRequestSmbHeader != NULL);

    ASSERT(!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) &&
           !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR));

    // Initialize the SMB header  ...
    Status = SmbTransactBuildHeader(
                 pTransactExchange,
                 pTransactExchange->SmbCommand,
                 pPrimaryRequestSmbHeader);

    if ((Status != STATUS_SUCCESS)) {
        // Finalize the exchange.
        pExchange->Status = Status;
        return Status;
    }

    PrimaryRequestSmbSize = sizeof(SMB_HEADER);

    // Compute the BccOffset and the ParamOffset which is in turn used in computing the
    // param and data bytes to be sent as part of the primary request.
    switch (pTransactExchange->SmbCommand) {
    case SMB_COM_TRANSACTION:
    case SMB_COM_TRANSACTION2:
        {
            PREQ_TRANSACTION pTransactRequest = (PREQ_TRANSACTION)
                                             (pPrimaryRequestSmbHeader + 1);
            USHORT SetupLength = pTransactRequest->SetupCount * sizeof(WORD);

            BccOffset = sizeof(SMB_HEADER) +
                        FIELD_OFFSET(REQ_TRANSACTION,Buffer) +
                        SetupLength;

            ParamOffset = ROUND_UP_COUNT(
                              (BccOffset +
                              pTransactExchange->TransactionNameLength +
                              sizeof(USHORT)),
                              sizeof(DWORD));

            pBcc = (PUSHORT)((PBYTE)pPrimaryRequestSmbHeader + BccOffset);
        }
        break;

    case SMB_COM_NT_TRANSACT:
        {
            PREQ_NT_TRANSACTION pNtTransactRequest = (PREQ_NT_TRANSACTION)
                                                  (pPrimaryRequestSmbHeader + 1);
            USHORT SetupLength = pNtTransactRequest->SetupCount * sizeof(WORD);

            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeSTAAT1: init for NT_T (p,d,mp,md) %d %d %d %d\n",
                         pNtTransactRequest->TotalParameterCount, pNtTransactRequest->TotalDataCount,
                         pNtTransactRequest->MaxParameterCount, pNtTransactRequest->MaxDataCount));
            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeSTAyuk: init for NT_T (s,ms) %d %d \n",
                         pNtTransactRequest->SetupCount,  pNtTransactRequest->MaxSetupCount));


            BccOffset = sizeof(SMB_HEADER) +
                        FIELD_OFFSET(REQ_NT_TRANSACTION,Buffer[0]) +
                        SetupLength;

            ParamOffset = ROUND_UP_COUNT(
                              (BccOffset + sizeof(USHORT)),
                              sizeof(DWORD));

            pBcc = (PUSHORT)((PBYTE)pPrimaryRequestSmbHeader + BccOffset);

            if (pTransactExchange->NtTransactFunction == NT_TRANSACT_SET_QUOTA) {
                QuadwordAlignmentRequired = TRUE;
            }
       }
       break;

    default:
        ASSERT(!"Valid Smb Command for initiating Transaction");
        return STATUS_INVALID_PARAMETER;
    }

    // Compute the data/param bytes that can be sent as part of the primary request
    MaximumSmbBufferSize = pTransactExchange->MaximumTransmitSmbBufferSize;

    ParamBytesToBeSent = MIN(
                             (MaximumSmbBufferSize - ParamOffset),
                             pTransactExchange->SendParamBufferSize);
    if (!QuadwordAlignmentRequired) {
        DataOffset = ROUND_UP_COUNT(ParamOffset + ParamBytesToBeSent, sizeof(DWORD));
    } else {
        DataOffset = ROUND_UP_COUNT(ParamOffset + ParamBytesToBeSent, 2*sizeof(DWORD));
    }

    if (DataOffset < MaximumSmbBufferSize) {
        DataBytesToBeSent = MIN((MaximumSmbBufferSize - DataOffset),
                                pTransactExchange->SendDataBufferSize);
        PaddingLength = DataOffset - (ParamOffset + ParamBytesToBeSent);
    } else {
        DataBytesToBeSent = 0;
    }

    if ( DataBytesToBeSent == 0) {
        DataOffset = PaddingLength = 0;
    }

    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: params,padding,data=%d,%d,%d\n",
                           ParamBytesToBeSent,PaddingLength,DataBytesToBeSent  ));
    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: paramsoffset,dataoffset=%d,%d\n",
                           ParamOffset,DataOffset  ));
    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: phdr,pbcc=%08lx,%08lx\n",
                           pPrimaryRequestSmbHeader,pBcc  ));

    // Update the primary request buffer with the final sizes of the data/parameter etc.
    switch (pTransactExchange->SmbCommand) {
    case SMB_COM_TRANSACTION:
    case SMB_COM_TRANSACTION2:
        {
            PREQ_TRANSACTION pTransactRequest = (PREQ_TRANSACTION)
                                             (pPrimaryRequestSmbHeader + 1);

            RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: TRANSACTION/TRANSACTION2\n"));

            SmbPutUshort( &pTransactRequest->ParameterCount, (USHORT)ParamBytesToBeSent );
            SmbPutUshort( &pTransactRequest->ParameterOffset, (USHORT)ParamOffset);
            SmbPutUshort( &pTransactRequest->DataCount, (USHORT)DataBytesToBeSent);
            SmbPutUshort( &pTransactRequest->DataOffset, (USHORT)DataOffset);
        }
        break;

   case SMB_COM_NT_TRANSACT:
        {
            PREQ_NT_TRANSACTION pNtTransactRequest = (PREQ_NT_TRANSACTION)
                                                  (pPrimaryRequestSmbHeader + 1);

            RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: NT transacton\n"));
            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeSTAAT2: init for NT_T (p,d,mp,md) %d %d %d %d\n",
                         pNtTransactRequest->TotalParameterCount, pNtTransactRequest->TotalDataCount,
                         pNtTransactRequest->MaxParameterCount, pNtTransactRequest->MaxDataCount));


            SmbPutUlong( &pNtTransactRequest->ParameterCount, ParamBytesToBeSent);
            SmbPutUlong( &pNtTransactRequest->ParameterOffset, ParamOffset);
            SmbPutUlong( &pNtTransactRequest->DataCount, DataBytesToBeSent);
            SmbPutUlong( &pNtTransactRequest->DataOffset, DataOffset);
        }
        break;

    default:
        ASSERT(!"Valid Smb Command for initiating Transaction");
        return STATUS_INVALID_PARAMETER;
    }

    // Update the Bcc field in the SMB and compute the SMB length
    SmbPutUshort(
        pBcc,
        (USHORT)((ParamOffset - BccOffset - sizeof(USHORT)) +
                 ParamBytesToBeSent +
                 PaddingLength +
                 DataBytesToBeSent)
        );

    SmbLength = ParamOffset +
                ParamBytesToBeSent +
                PaddingLength +
                DataBytesToBeSent;

    // The primary request buffer should be locked down for transmission. In order to
    // preclude race conditions while freeing this routine assumes ownership of the buffer.
    // There are two reasons why this model has to be adopted ...
    // 1) Inititaiting a transaction request can possibly involve a reconnection attempt
    // which will involve network traffic. Consequently the transmission of the primary
    // request can potentially occur in a worker thread which is different from the one
    // initializing the exchange. This problem can be worked around by carrying all the
    // possible context around and actually constructing the header as part of this routine.
    // But this would imply that those requests which could have been filtered out easily
    // because of error conditions etc. will be handled very late.

    pTransactExchange->pActualPrimaryRequestSmbHeader = NULL;
    pTransactExchange->pPrimaryRequestSmbHeader = NULL;

    // Ensure that the MDL's have been probed & locked. The new MDL's have been allocated.
    // The partial MDL's are allocated to be large enough to span the maximum buffer
    // length possible.

    MdlLength = ParamOffset;
    if (pTransactExchange->fParamsSubsumedInPrimaryRequest) {
        MdlLength += ParamBytesToBeSent + PaddingLength;
    }

    RxAllocateHeaderMdl(
        pPrimaryRequestSmbHeader,
        MdlLength,
        pPrimaryRequestSmbMdl
        );

    if (pPrimaryRequestSmbMdl != NULL) {
        Status = STATUS_SUCCESS;
    } else {
        RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: Insuffcient resources for MDL's\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ((DataBytesToBeSent > 0) &&
       (Status == STATUS_SUCCESS)) {
        pPartialDataMdl = RxAllocateMdl(
                              0,
                              (MIN(pTransactExchange->SendDataBufferSize,MaximumSmbBufferSize) +
                               PAGE_SIZE - 1)
                              );

        if (pPartialDataMdl != NULL) {
            Status = STATUS_SUCCESS;
        } else {
            RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: Insuffcient resources for MDL's\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if ((ParamBytesToBeSent > 0) &&
        !pTransactExchange->fParamsSubsumedInPrimaryRequest &&
        (Status == STATUS_SUCCESS)) {

        pPartialParamMdl = RxAllocateMdl(
                               pTransactExchange->pSendParamBuffer,
                               ParamBytesToBeSent);

        if (PaddingLength!= 0) {
            pPaddingMdl = RxAllocateMdl(0,(sizeof(DWORD) + PAGE_SIZE - 1));
        } else {
            pPaddingMdl = NULL;
        }

        if ((pPartialParamMdl != NULL) &&
            ((pPaddingMdl != NULL)||(PaddingLength==0))) {
            Status = STATUS_SUCCESS;
        } else {
            RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: no param/pad MDLs %08lx %08lx\n",
               pPartialParamMdl,pPaddingMdl));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // At this point the validity of all the parameters will have been ascertained. The trivial
    // cases have been filtered out. Start the transact exchange.

    // Implementation Note: The Transact exchange implementation relies upon chaining the
    // MDL's together to build the relevant request buffers that need be sent. This ensures
    // that redundant copying of data is avoided altogether. Depending upon the parameters
    // specified the composite MDL that is sent is composed of the following MDL's.
    // TRANSACT2 and NT TRANSACT exchanges ...
    //          The composite buffer is made up off atmost four MDL's that are chained together. These
    //           are the header buffer, the setup buffer, parameter buffer and the data buffer.
    //          All the secondary requests are made up off atmost three MDL's that are chained together.
    //          These are the header buffer, the parameter buffer and the data buffer.
    // TRANSACT exchanges ....
    //          The composite buffer is made up off atmost three MDL's that are chained together. These are
    //          the header buffer ( includes the name and the setup information) , the parameter buffer
    //          and the data buffer.
    // All the secondary requests are made up off atmost three MDL's that are chained together.
    // These are the header buffer, the parameter buffer and the data buffer.
    // In all of these cases the number of MDL's can go up by 1 if a padding MDL is required
    // between the parameter buffer and the data buffer to ensure that all alignment requirements
    // are satisfied.

    if ((Status == STATUS_SUCCESS)) {

        RxProbeAndLockHeaderPages(pPrimaryRequestSmbMdl,KernelMode,IoModifyAccess,Status);
        if (Status != STATUS_SUCCESS) {  //do this now. the code below will try to unlock
            IoFreeMdl(pPrimaryRequestSmbMdl);
            pPrimaryRequestSmbMdl = NULL;
        } else {
            if (MmGetSystemAddressForMdlSafe(pPrimaryRequestSmbMdl,LowPagePriority) == NULL) { //map it
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if ((Status == STATUS_SUCCESS)) {
        pLastMdlInChain = pPrimaryRequestSmbMdl;

        if (ParamBytesToBeSent > 0) {
            RxDbgTrace(
                0,
                Dbg,
                ("SmbCeTransactExchangeStart: Sending Param bytes %ld at offset %ld\n",
                 ParamBytesToBeSent,
                 ParamOffset)
                );
            pTransactExchange->ParamBytesSent = ParamBytesToBeSent;

            if (!pTransactExchange->fParamsSubsumedInPrimaryRequest) {
                IoBuildPartialMdl(
                    pTransactExchange->pSendParamMdl,
                    pPartialParamMdl,
                    (PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pSendParamMdl),
                    ParamBytesToBeSent);

                // Chain the MDL's together
                pLastMdlInChain->Next = pPartialParamMdl;
                pLastMdlInChain       = pPartialParamMdl;
            }
        }

        // Link the data buffer or portions of it if the size constraints are satisfied
        // If padding is required between the parameter and data portions in the
        // primary request include the padding MDL, otherwise chain the data MDL
        // directly.
        if (DataBytesToBeSent > 0) {
            if (!pTransactExchange->fParamsSubsumedInPrimaryRequest &&
                (PaddingLength > 0)) {
                RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: Padding Length %ld\n",PaddingLength));

                RxBuildPaddingPartialMdl(pPaddingMdl,PaddingLength);
                pLastMdlInChain->Next = pPaddingMdl;
                pLastMdlInChain = pPaddingMdl;
            }

            RxDbgTrace( 0, Dbg,("SmbCeTransactExchangeStart: Sending Data bytes %ld at offset %ld\n",
                 DataBytesToBeSent, DataOffset) );

            pTransactExchange->DataBytesSent = DataBytesToBeSent;

            IoBuildPartialMdl(
                pTransactExchange->pSendDataMdl,
                pPartialDataMdl,
                (PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pSendDataMdl),
                DataBytesToBeSent);

            pLastMdlInChain->Next = pPartialDataMdl;
            pLastMdlInChain       = pPartialDataMdl;
        }

        if ((Status == STATUS_SUCCESS)) {
            // There are cases in which the transaction exchange can be completed by merely sending
            // the primary request SMB. This should be distinguished from those cases in which either
            // a response is expected or a number of secondary requests need to be issued based upon
            // the parameter buffer length, data buffer length and the flags specified.
            if ((pTransactExchange->Flags & SMB_TRANSACTION_NO_RESPONSE ) &&
                (pTransactExchange->SendDataBufferSize == DataBytesToBeSent) &&
                (pTransactExchange->SendParamBufferSize == ParamBytesToBeSent)) {
                // No response is expected in this case. Therefore Send should suffice instead of
                // Tranceive

                // since we don't expect to do any more here, set the exchange status to success
                pExchange->Status = STATUS_SUCCESS;
                pTransactExchange->pResumptionContext->FinalStatusFromServer = STATUS_SUCCESS;

                RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: SmbCeSend(No Response expected)\n"));
                Status = SmbCeSend(
                             pExchange,
                             RXCE_SEND_SYNCHRONOUS,
                             pPrimaryRequestSmbMdl,
                             SmbLength);

                if ((Status != STATUS_SUCCESS)) {
                    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: SmbCeSend returned %lx\n",Status));
                }
            } else {
                // This transaction involves ttansmit/receive of multiple SMB's. A tranceive is in
                // order.

                if ((pTransactExchange->SendDataBufferSize == DataBytesToBeSent) &&
                    (pTransactExchange->SendParamBufferSize == ParamBytesToBeSent)) {
                    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: No Secondary Requests\n"));
                    pTransactExchange->State = TRANSACT_EXCHANGE_TRANSMITTED_SECONDARY_REQUESTS;
                } else {
                    pTransactExchange->State = TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST;
                }

                RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: SmbCeTranceive(Response expected)\n"));
                Status = SmbCeTranceive(
                             pExchange,
                             RXCE_SEND_SYNCHRONOUS,
                             pPrimaryRequestSmbMdl,
                             SmbLength);

                if ((Status != STATUS_SUCCESS)) {
                    RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: SmbCeTranceive returned %lx\n",Status));
                }
            }
        }
    }

    if (pPartialParamMdl != NULL) {
        IoFreeMdl(pPartialParamMdl);
    }

    if (pPartialDataMdl != NULL) {
        IoFreeMdl(pPartialDataMdl);
    }

    if (pPaddingMdl != NULL) {
        IoFreeMdl(pPaddingMdl);
    }

    if (pPrimaryRequestSmbMdl != NULL) {
        RxUnlockHeaderPages(pPrimaryRequestSmbMdl);
        IoFreeMdl(pPrimaryRequestSmbMdl);
    }

    RxFreePool(pActualPrimaryRequestSmbHeader);

    if (Status != STATUS_PENDING) {
        pExchange->Status = Status;
    }

    return Status;
}

NTSTATUS
SmbTransactExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,    // The exchange instance
    IN ULONG          BytesIndicated,
    IN ULONG          BytesAvailable,
    OUT ULONG        *pBytesTaken,
    IN  PSMB_HEADER   pSmbHeader,
    OUT PMDL *pDataBufferPointer,
    OUT PULONG        pDataSize,
    IN ULONG          ReceiveFlags)
/*++

Routine Description:

    This is the recieve indication handling routine for transact exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - the byte buffer

    pDataBufferPointer - the buffer into which the remaining data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS Status;
    PNTSTATUS pFinalSmbStatus;

    BOOLEAN fError = FALSE;
    BOOLEAN fIndicationNotSufficient = FALSE;
    BOOLEAN fMoreParsingRequired     = FALSE;
    BOOLEAN fDoErrorProcessing       = FALSE;

    SMB_TRANSACT_RESP_FORMAT_DESCRIPTION Format;

    GENERIC_ANDX  CommandToProcess;

    ULONG TransactResponseSize       = 0;
    ULONG SetupBytesOffsetInResponse = 0;
    ULONG SetupBytesInResponse       = 0;
    ULONG CopyDataSize               = 0;

    PMDL  pSetupMdl       = NULL;
    PMDL  pCopyRequestMdl = NULL;

    PSMB_TRANSACT_EXCHANGE pTransactExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;

    RxDbgTrace( 0, Dbg,
               ("SmbTransactExchangeReceive: Entering w/ Bytes Available (%ld) Bytes Indicated (%ld) State (%ld)\n",
                BytesAvailable,
                BytesIndicated,
                pTransactExchange->State
               ));
    RxDbgTrace( 0, Dbg,
               ("SmbTransactExchangeReceive: Buffer %08lx Consumed (%ld) MDL (%08lx)\n",
                pSmbHeader,
                *pBytesTaken,
                *pDataBufferPointer
               ));

    pFinalSmbStatus = &pTransactExchange->SmbStatus;
    Status = SmbCeParseSmbHeader(
                 pExchange,
                 pSmbHeader,
                 &CommandToProcess,
                 pFinalSmbStatus,
                 BytesAvailable,
                 BytesIndicated,
                 pBytesTaken);

    if (Status != STATUS_SUCCESS) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    //this need some explanation. parseheader is written so as to take some extra smbs off the from
    //of the packet...specifically, stuff like sessionsetup&X and TC&X. since no transact is a valid followon
    //it would not make since if (a) not enough were indicated or (b) an early command had an error. so
    //we must have success.

    if (*((PBYTE)(pSmbHeader+1)) == 0 && (pTransactExchange->State!=TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST)) {
        RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: FinalSmbStatus = %lx\n", *pFinalSmbStatus));

        if (NT_SUCCESS(*pFinalSmbStatus)) {
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            goto FINALLY;
        }
    }

    //we know that status is SUCCESS from the assert above. but we will still continue to check so as
    //to be more resilient when we don't have msg boundaries. we have the following cases depending on the
    //characteristics of the smbresponse
    //
    //   non-error:   get the data and then return the stored responsestatus. the process of getting the data
    //                causes us to update the param and data counts so that we know when we have reached the
    //                end of the data. the parse routine re-ups the receive if needed.
    //   error:       there are main cases:
    //                    a) the server has sent no data. here we discard the packet and we can just get out. the
    //                       finalize routine will pickup the status correctly.
    //                    b) here, we have to discard the packet AND update the byte counts AND re-up the receive
    //                       if necessary. to discard the packet, we must either compute the apparent msg length from
    //                       the WC and BC parameters (best) OR use our maximum buffer size

    fMoreParsingRequired = FALSE;

    if (Status == STATUS_SUCCESS) {
        if (TRUE) { //maybe sometimes we wont copy!
            if (CommandToProcess.WordCount > 0) {
                ULONG TransactResponseSize = 0;

                // Ensure that at the very least enough bytes have been indicated to determine
                // the length of the setup, parameters and data for the transaction.

                switch (CommandToProcess.AndXCommand) {
                case SMB_COM_NT_TRANSACT:
                case SMB_COM_NT_TRANSACT_SECONDARY:
                    TransactResponseSize = FIELD_OFFSET(RESP_NT_TRANSACTION,Buffer);
                    break;

                case SMB_COM_TRANSACTION:
                case SMB_COM_TRANSACTION2:
                case SMB_COM_TRANSACTION_SECONDARY:
                case SMB_COM_TRANSACTION2_SECONDARY:
                    TransactResponseSize = FIELD_OFFSET(RESP_TRANSACTION,Buffer);
                    break;

                default:
                    TransactResponseSize = 0xffffffff;
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
                    break;
                }

                if (BytesIndicated >= (sizeof(SMB_HEADER) + TransactResponseSize)) {
                    fMoreParsingRequired = TRUE;
                } else {
                    fIndicationNotSufficient = TRUE;
                    *pFinalSmbStatus = STATUS_INVALID_NETWORK_RESPONSE;
                }
            } else {
                // allow a response with wordcount==0 to go thru if we're the right state
                fMoreParsingRequired = (pTransactExchange->State==TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST);
            }
        }
    }

    if (fMoreParsingRequired) {
        // The header was successfully parsed and the SMB response did not contain any errors
        // The stage is set for processing the transaction response.

        switch (pTransactExchange->State) {
        case TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST:
            {
                // The primary request for the transaction has been sent and there are
                // secondary requests to be sent.
                // The only response expected at this time is an interim response. Any
                // other response will be treated as an error.
                PRESP_TRANSACTION_INTERIM pInterimResponse;

                RxDbgTrace(0,Dbg,("SmbCeTransactExchangeReceive: Processing interim response\n"));

                if ((*pBytesTaken + FIELD_OFFSET(RESP_TRANSACTION_INTERIM,Buffer)) <= BytesIndicated) {
                    pInterimResponse = (PRESP_TRANSACTION_INTERIM)((PBYTE)pSmbHeader + *pBytesTaken);
                    if ((pSmbHeader->Command == pTransactExchange->SmbCommand) &&
                        (SmbGetUshort(&pInterimResponse->WordCount) == 0) &&
                        (SmbGetUshort(&pInterimResponse->ByteCount) == 0)) {

                        // The interim response was valid. Transition the state of the exchange
                        // and transmit the secondary requests.
                        *pBytesTaken += FIELD_OFFSET(RESP_TRANSACTION_INTERIM,Buffer);
                        pTransactExchange->State = TRANSACT_EXCHANGE_RECEIVED_INTERIM_RESPONSE;

                        // Determine if any secondary transaction requests need to be sent. if none are
                        // required then modify the state
                        ASSERT((pTransactExchange->ParamBytesSent < pTransactExchange->SendParamBufferSize) ||
                               (pTransactExchange->DataBytesSent < pTransactExchange->SendDataBufferSize));
                        ASSERT((pTransactExchange->ParamBytesSent <= pTransactExchange->SendParamBufferSize) &&
                               (pTransactExchange->DataBytesSent <= pTransactExchange->SendDataBufferSize));

                        if (!(pTransactExchange->Flags & SMB_TRANSACTION_NO_RESPONSE )) {
                            Status = SmbCeReceive(pExchange);
                        }

                        if (Status != STATUS_SUCCESS) {
                            pExchange->Status = Status;
                        } else {
                            Status = STATUS_SUCCESS;
                            SmbCeIncrementPendingLocalOperations(pExchange);
                            RxPostToWorkerThread(
                                MRxSmbDeviceObject,
                                CriticalWorkQueue,
                                &pExchange->WorkQueueItem,
                                SendSecondaryRequests,
                                pExchange);
                        }
                    } else {
                        RxDbgTrace(0,Dbg,("SmbCeTransactExchangeReceive: Invalid interim response\n"));
                        Status = STATUS_INVALID_NETWORK_RESPONSE;
                    }
                } else {
                    fIndicationNotSufficient = TRUE;
                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                }
            }
            break;

        case TRANSACT_EXCHANGE_RECEIVED_INTERIM_RESPONSE:
            RxDbgTrace(0,Dbg,("SmbCeTransactExchangeReceive: received again while in interim response\n"));
          //no break: this is okay
        case TRANSACT_EXCHANGE_TRANSMITTED_SECONDARY_REQUESTS:
        case TRANSACT_EXCHANGE_RECEIVED_PRIMARY_RESPONSE:
            {
                BOOLEAN fPrimaryResponse = FALSE;
                PRESP_TRANSACTION    pTransactResponse;
                PRESP_NT_TRANSACTION pNtTransactResponse;
                ULONG TotalParamBytesInResponse;
                ULONG TotalDataBytesInResponse;

                RxDbgTrace(0,Dbg,("SmbCeTransactExchangeReceive: Processing Primary/Secondary response\n"));

                //do this here so there's only one copy if the code
                pTransactResponse = (PRESP_TRANSACTION)((PBYTE)pSmbHeader +
                                              SmbGetUshort(&CommandToProcess.AndXOffset));

                // All the requests ( both primary and secondary have been sent ). The
                // only responses expected in this state are (1) a primary response and (2) a
                // secondary response. Any other response is an error.
                if (pSmbHeader->Command == pTransactExchange->SmbCommand) {
                    switch (pSmbHeader->Command) {
                    case SMB_COM_TRANSACTION:
                    case SMB_COM_TRANSACTION2:
                        //pTransactResponse = (PRESP_TRANSACTION)((PBYTE)pSmbHeader +
                        //                                        SmbGetUshort(&CommandToProcess.AndXOffset));
                        fPrimaryResponse = TRUE;
                        SetupBytesOffsetInResponse = FIELD_OFFSET(RESP_TRANSACTION,Buffer);
                        SetupBytesInResponse = sizeof(USHORT) * pTransactResponse->SetupCount;

                        // Initialize the total count of data and param bytes that will be received from
                        // the server during the course ofthe transaction response.
                        TotalParamBytesInResponse = SmbGetUshort(&pTransactResponse->TotalParameterCount);
                        TotalDataBytesInResponse  = SmbGetUshort(&pTransactResponse->TotalDataCount);

                    // fall through
                    case SMB_COM_TRANSACTION_SECONDARY:
                    case SMB_COM_TRANSACTION2_SECONDARY:
                        TransactResponseSize = FIELD_OFFSET(RESP_TRANSACTION,Buffer);
                        break;
                    case SMB_COM_NT_TRANSACT:
                        //pNtTransactResponse = (PRESP_NT_TRANSACTION)((PBYTE)pSmbHeader +
                        //                                        SmbGetUshort(&CommandToProcess.AndXOffset));
                        pNtTransactResponse = (PRESP_NT_TRANSACTION)pTransactResponse;
                        fPrimaryResponse = TRUE;
                        SetupBytesOffsetInResponse = FIELD_OFFSET(RESP_NT_TRANSACTION,Buffer);
                        SetupBytesInResponse = sizeof(USHORT) * pNtTransactResponse->SetupCount;

                        // Initialize the total count of data and param bytes that will be received from
                        // the server during the course ofthe transaction response.
                        TotalParamBytesInResponse = SmbGetUshort(&pNtTransactResponse->TotalParameterCount);
                        TotalDataBytesInResponse  = SmbGetUshort(&pNtTransactResponse->TotalDataCount);

                        // fall through ..
                    case SMB_COM_NT_TRANSACT_SECONDARY:
                        TransactResponseSize = FIELD_OFFSET(RESP_NT_TRANSACTION,Buffer);
                        break;

                    default:
                        // Abort the exchange. An unexpected response was received during the
                        // course of the transaction.
                        ASSERT(!"Valid network response");
                        Status = STATUS_INVALID_NETWORK_RESPONSE;
                    }

                    if (Status == STATUS_SUCCESS) {
                        if (fPrimaryResponse) {
                            RxDbgTrace( 0,
                                 Dbg,
                                 ("SmbTransactExchangeReceive: Primary Response Setup Bytes(%ld) Param Bytes (%ld) Data Bytes (%ld)\n",
                                  SetupBytesInResponse,
                                  TotalParamBytesInResponse,
                                  TotalDataBytesInResponse
                                 )
                               );

                            if ((TotalParamBytesInResponse > pTransactExchange->ReceiveParamBufferSize) ||
                                (TotalDataBytesInResponse > pTransactExchange->ReceiveDataBufferSize)) {
                                Status = STATUS_INVALID_NETWORK_RESPONSE;
                                goto FINALLY;
                            } else {
                                pTransactExchange->ReceiveParamBufferSize = TotalParamBytesInResponse;
                                pTransactExchange->ReceiveDataBufferSize  = TotalDataBytesInResponse;
                            }
                        }

                        if (Status == STATUS_SUCCESS &&
                            TransactResponseSize + *pBytesTaken <= BytesIndicated) {
                            if (fPrimaryResponse &&
                                (SetupBytesInResponse > 0)) {

                                PBYTE pSetupStartAddress;
                                ULONG SetupBytesIndicated = MIN(SetupBytesInResponse,
                                                            BytesIndicated - SetupBytesOffsetInResponse);

                                if( pTransactExchange->pReceiveSetupMdl ) {
                                    pSetupStartAddress = (PBYTE)MmGetSystemAddressForMdlSafe(
                                                                pTransactExchange->pReceiveSetupMdl,
                                                                LowPagePriority
                                                                );

                                    if( pSetupStartAddress == NULL ) {
                                        Status = STATUS_INSUFFICIENT_RESOURCES;
                                    } else {
                                        if (SetupBytesInResponse == SetupBytesIndicated) {
                                            RtlCopyMemory(
                                                pSetupStartAddress,
                                                ((PBYTE)pSmbHeader + SetupBytesOffsetInResponse),
                                                SetupBytesIndicated);

                                            pSetupStartAddress += SetupBytesIndicated;
                                            SetupBytesInResponse -= SetupBytesIndicated;
                                            SetupBytesOffsetInResponse += SetupBytesIndicated;
                                            pTransactExchange->SetupBytesReceived = SetupBytesInResponse;
                                        } else {
                                            ASSERT(!"this code doesn't work");
                                            RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: Setup Bytes Partially Indicated\n"));
                                            // Some setup bytes have not been indicated. An MDL needs to be
                                            // created for copying the data. This MDL should also include the padding
                                            // MDL for copying the padding bytes ...
                                            pSetupMdl = RxAllocateMdl(pSetupStartAddress,SetupBytesInResponse);

                                            if ( pSetupMdl != NULL ) {
                                                IoBuildPartialMdl(
                                                     pTransactExchange->pReceiveSetupMdl,
                                                     pSetupMdl,
                                                     pSetupStartAddress,
                                                     SetupBytesInResponse);
                                            } else {
                                                Status = STATUS_INSUFFICIENT_RESOURCES;
                                            }
                                        }
                                    }
                                }

                                RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: Setup Bytes Indicated (%ld)\n",SetupBytesIndicated));
                            }

                            if (Status == STATUS_SUCCESS) {
                                // from here, we cannot go back and redo the header....so we have to change state so
                                //that the copy routine doesn't try to reparse
                                pTransactExchange->State = TRANSACT_EXCHANGE_RECEIVED_PRIMARY_RESPONSE;

                                Status = SmbTransactAccrueAndValidateFormatData(
                                             pTransactExchange,
                                             pSmbHeader,
                                             BytesIndicated,
                                             &Format);

                                if (Status != STATUS_SUCCESS) {
                                    goto FINALLY;
                                }

                                Status = ParseTransactResponse(
                                             pTransactExchange,&Format,
                                             BytesIndicated,
                                             BytesAvailable,
                                             pBytesTaken,
                                             pSmbHeader,
                                             &pCopyRequestMdl,
                                             &CopyDataSize);

                                if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                                    // Link the setup MDL with the MDL returned
                                    if (pSetupMdl != NULL) {
                                        if (pCopyRequestMdl != NULL) {
                                            pSetupMdl->Next = pCopyRequestMdl;
                                        }

                                        pCopyRequestMdl = pSetupMdl;
                                        CopyDataSize += SetupBytesInResponse;
                                    }
                                }

                                //check if the server has sent extra bytes.....
                                // ---------------------------------------------------------------------------------------------
                                {
                                    ULONG ApparentMsgLength = max(BytesAvailable,Format.ApparentMsgLength);
                                    ULONG DeficitBytes = ApparentMsgLength - (*pBytesTaken+CopyDataSize);

                                    if (ApparentMsgLength < *pBytesTaken+CopyDataSize) {
                                        Status = STATUS_INVALID_NETWORK_RESPONSE;
                                        goto FINALLY;
                                    }

                                    if (DeficitBytes > 0) {
                                        RxLog(("XtraBytes %lx %lx",pTransactExchange,DeficitBytes));

                                        if (CopyDataSize==0) {
                                            if (*pBytesTaken > BytesAvailable) {
                                                Status = STATUS_INVALID_NETWORK_RESPONSE;
                                                goto FINALLY;
                                            }

                                            RxLog(("Extra Bytes were sent and copydatasize==0........\n"));
                                            *pBytesTaken = BytesAvailable; //cant take more than this
                                        } else {
                                            PMDL LastMdl,TrailingBytesMdl;

                                            if ( DeficitBytes > TRAILING_BYTES_BUFFERSIZE) {
                                                Status = STATUS_INVALID_NETWORK_RESPONSE;
                                                goto FINALLY;
                                            }

                                            TrailingBytesMdl = &pTransactExchange->TrailingBytesMdl;

                                            MmInitializeMdl(
                                                TrailingBytesMdl,
                                                &pTransactExchange->TrailingBytesBuffer.Bytes[0],
                                                DeficitBytes
                                                );
                                            MmBuildMdlForNonPagedPool(TrailingBytesMdl);
                                            LastMdl = pCopyRequestMdl;
                                            ASSERT(LastMdl != NULL);
                                            for (;LastMdl->Next!=NULL;LastMdl=LastMdl->Next) ;
                                            ASSERT(LastMdl != NULL);
                                            ASSERT(LastMdl->Next == NULL);
                                            LastMdl->Next = TrailingBytesMdl;
                                            CopyDataSize += DeficitBytes;
                                        }
                                    }
                                }
                                // ---------------------------------------------------------------------------------------------


                                RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: ParseTransactResponse returned %lx\n",Status));
                            }

                            *pDataBufferPointer = pCopyRequestMdl;
                            *pDataSize          = CopyDataSize;
                        } else {
                            RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: Indication not sufficient: trsz %08lx bytestakn %08lx \n",
                                         TransactResponseSize, *pBytesTaken));
                            fIndicationNotSufficient = TRUE;

                            if (Status == STATUS_SUCCESS) {
                                Status = STATUS_MORE_PROCESSING_REQUIRED;
                            }
                        }
                    }
                } else {
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
                }
            }
            break;

        default:
            {
                ASSERT(!"Valid Transact Exchange State for receiving responses");
                RxDbgTrace( 0, Dbg, ("SmbTransactExchangeReceive: Aborting Exchange -- invalid state\n"));
            }
            break;
        }
    } else {
        // We get here if either the status or the smbstatus is not success.
        // If sufficient bytes were not indicated for processing the header a copy data request
        // needs to be posted. this occurs if status is status_more_processing_required
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeReceive: bad status(es) from parseheadr %08lx %08lx\n",
                            Status,*pFinalSmbStatus));
        fDoErrorProcessing       = TRUE;
    }

    if ((Status == STATUS_SUCCESS) &&
        (pTransactExchange->ParamBytesReceived == pTransactExchange->ReceiveParamBufferSize) &&
        (pTransactExchange->DataBytesReceived  == pTransactExchange->ReceiveDataBufferSize) &&
        (pTransactExchange->PendingCopyRequests == 0)) {

        NOTHING;

    } else if (fDoErrorProcessing) {
        BOOLEAN DoItTheShortWay = TRUE;
        ULONG ApparentMsgLength;
        RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: Error processing response %lx .. Exchange aborted\n",Status));

        if (BytesAvailable > BytesIndicated ||
            !FlagOn(ReceiveFlags,TDI_RECEIVE_ENTIRE_MESSAGE)) {

            Status = SmbTransactAccrueAndValidateFormatData(
                         pTransactExchange,
                         pSmbHeader,
                         BytesIndicated,
                         &Format);

            if (Status != STATUS_SUCCESS) {
                goto FINALLY;
            }

            ApparentMsgLength = max(BytesAvailable,Format.ApparentMsgLength);

            //if wordcount!=0 then the server is sending us bytes.....we have to continue doing
            //receives until we have seen all the bytes
            if ((pTransactExchange->ParameterBytesSeen<Format.ParameterCount) ||
                (pTransactExchange->DataBytesSeen<Format.DataCount)) {
                NTSTATUS ReceiveStatus;

                // The exchange has been successfully completed. Finalize it.
                RxDbgTrace(0,Dbg,("ParseTransactResponse: Register for more error responses\n"));
                RxLog(("TxErr: %lx %lx %lx",pTransactExchange,
                       pTransactExchange->ParameterBytesSeen,pTransactExchange->DataBytesSeen));
                ReceiveStatus = SmbCeReceive((PSMB_EXCHANGE)pTransactExchange);
                if (ReceiveStatus != STATUS_SUCCESS) {
                    // There was an error in registering the receive. Abandon the transaction.
                    Status = ReceiveStatus;
                    RxLog(("TxErrAbandon %lx",pTransactExchange));
                    //Make it fail the next two tests.....
                    ApparentMsgLength = 0; DoItTheShortWay = FALSE;
                }
            }

            //netbt will not allow us to discard the packet by setting taken=available. so, check for
            //available>indicated. if true, take the bytes by conjuring up a buffer

            if (ApparentMsgLength>BytesIndicated) {
                BOOLEAN BytesAvailable = TRUE;
                //we'll have to lay down a buffer for this so that NetBT won't blow the session away
                ASSERT(pTransactExchange->Status == STATUS_MORE_PROCESSING_REQUIRED);
                pTransactExchange->DiscardBuffer = RxAllocatePoolWithTag(
                                                       NonPagedPool,
                                                       ApparentMsgLength,
                                                       MRXSMB_XACT_POOLTAG);
                if (pTransactExchange->DiscardBuffer!=NULL) {
                    *pBytesTaken = 0;
                    *pDataSize = ApparentMsgLength;
                    *pDataBufferPointer = &pTransactExchange->TrailingBytesMdl;
                    MmInitializeMdl(*pDataBufferPointer,
                        pTransactExchange->DiscardBuffer,
                        ApparentMsgLength
                        );

                    MmBuildMdlForNonPagedPool(*pDataBufferPointer);
                    pTransactExchange->SaveTheRealStatus = Status;
                    RxLog(("XRtakebytes %lx %lx\n",pTransactExchange,Status));
                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                    DoItTheShortWay = FALSE;
                }
            }
        }

        if (DoItTheShortWay) {
            goto FINALLY;
        }
    }

    RxDbgTrace( 0, Dbg,
               ("SmbTransactExchangeReceiveExit: Bytes Consumed (%ld) Status (%08lx) MDL (%08lx) size(%08lx)\n",
                *pBytesTaken, Status, *pDataBufferPointer, *pDataSize
               ));

    return Status;

FINALLY:
    *pBytesTaken = BytesAvailable;
    *pDataBufferPointer = NULL;

    // Abort the exchange
    pTransactExchange->Status = Status;
    Status = STATUS_SUCCESS;

    RxDbgTrace(0,Dbg,("SmbTransactExchangeReceive: Exchange aborted.\n",Status));

    return Status;

    UNREFERENCED_PARAMETER(ReceiveFlags);
}

NTSTATUS
SmbTransactExchangeAbort(
      PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the abort routine for transact exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    // The SMB exchange completed with an error. Invoke the RDBSS callback routine
    // and scavenge the exchange instance.

    pExchange->Status = STATUS_REQUEST_ABORTED;

    return STATUS_SUCCESS;
}

NTSTATUS
SmbTransactExchangeErrorHandler(
    IN PSMB_EXCHANGE pExchange)     // the SMB exchange instance
/*++

Routine Description:

    This is the error indication handling routine for transact exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    // The SMB exchange completed with an error. Invoke the RDBSS callback routine
    // and scavenge the exchange instance.
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pExchange);
}

NTSTATUS
SmbTransactExchangeSendCallbackHandler(
    IN PSMB_EXCHANGE    pExchange,    // The exchange instance
    IN PMDL             pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus)
/*++

Routine Description:

    This is the send call back indication handling routine for transact exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(pExchange);
    UNREFERENCED_PARAMETER(pXmitBuffer);
    UNREFERENCED_PARAMETER(SendCompletionStatus);
}

NTSTATUS
SmbTransactExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,    // The exchange instance
    IN PMDL             pDataBuffer,  // the buffer
    IN ULONG            DataSize)
/*++

Routine Description:

    This is the copy data handling routine for transact exchanges

Arguments:

    pExchange - the exchange instance

    pDataBuffer - the buffer

    DataSize    - the amount of data returned

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMB_TRANSACT_EXCHANGE pTransactExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;

    PMDL  pCopyRequestMdl = NULL;
    PMDL  pCurMdl = NULL;
    ULONG CopyRequestSize = 0;
    PMDL TrailingBytesMdl = &pTransactExchange->TrailingBytesMdl;

    ULONG BytesConsumed;

    RxDbgTrace(+1,Dbg,("SmbTransactExchangeCopyDataHandler: Entered\n"));

    if (pTransactExchange->DiscardBuffer!=NULL) {
        //we just copied to get rid of the buffer....
        //free the buffer, set the status and get out
        RxFreePool(pTransactExchange->DiscardBuffer);
        Status = pTransactExchange->SaveTheRealStatus;
        RxDbgTrace(-1,Dbg,("SmbTransactExchangeCopyDataHandler: Discard Exit, status =%08lx\n"));
        DbgPrint("copyHandlerDiscard, st=%08lx\n",Status);
        return Status;
    }

    switch (pTransactExchange->State) {
    case TRANSACT_EXCHANGE_TRANSMITTED_PRIMARY_REQUEST :
    case TRANSACT_EXCHANGE_TRANSMITTED_SECONDARY_REQUESTS :
        {
            PSMB_HEADER pSmbHeader = (PSMB_HEADER)MmGetSystemAddressForMdlSafe(pDataBuffer,LowPagePriority);

            RxDbgTrace(0,Dbg,("SmbTransactExchangeCopyDataHandler: Reparsing response\n"));

            if (pSmbHeader == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                // The response could not be parsed with the indicated bytes. Invoke
                // the receive method to resume parsing of the complete SMB
                Status = SmbTransactExchangeReceive(
                             pExchange,
                             DataSize,
                             DataSize,
                             &BytesConsumed,
                             pSmbHeader,
                             &pCopyRequestMdl,
                             &CopyRequestSize,
                             TDI_RECEIVE_ENTIRE_MESSAGE);
            }

            if (Status == STATUS_SUCCESS) {
                ASSERT(BytesConsumed == DataSize);
                ASSERT(pCopyRequestMdl == NULL);
                ASSERT(CopyRequestSize == 0);
            }
        }
        break;

    case TRANSACT_EXCHANGE_RECEIVED_PRIMARY_RESPONSE :
        {
            RxDbgTrace(0,Dbg,("SmbTransactExchangeCopyDataHandler: Completing secondary response processing\n"));

            // In this state only secondary responses will be received. All the secondary
            // responses can be parsed from the indication. Therefore it is sufficient to
            // merely free the MDL's and re-register with the connection engine for
            // receiving subsequent requests.
            InterlockedDecrement(&pTransactExchange->PendingCopyRequests);

            if ((pTransactExchange->ParamBytesReceived == pTransactExchange->ReceiveParamBufferSize) &&
                (pTransactExchange->DataBytesReceived  == pTransactExchange->ReceiveDataBufferSize) &&
                (pTransactExchange->PendingCopyRequests == 0)) {
                // The exchange has been successfully completed. Finalize it.
                RxDbgTrace(0,Dbg,("SmbTransactExchangeCopyDataHandler: Processed last secondary response successfully\n"));
                pExchange->Status = STATUS_SUCCESS;
            }
        }
        break;

    default:
        {
            ASSERT(!"Valid State fore receiving copy data completion indication");
            pExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        }
        break;
    }

    // Free up the data buffers.
    pCurMdl = pDataBuffer;

    while (pCurMdl != NULL) {
        PMDL pPrevMdl = pCurMdl;
        pCurMdl = pCurMdl->Next;
        if (pPrevMdl!=TrailingBytesMdl) {
            IoFreeMdl(pPrevMdl);
        }
    }

    RxDbgTrace(-1,Dbg,("SmbTransactExchangeCopyDataHandler: Exit\n"));
    return Status;
}

NTSTATUS
SmbCeInitializeTransactExchange(
    PSMB_TRANSACT_EXCHANGE              pTransactExchange,
    PRX_CONTEXT                         RxContext,
    PSMB_TRANSACTION_OPTIONS            pOptions,
    PSMB_TRANSACTION_SEND_PARAMETERS    pSendParameters,
    PSMB_TRANSACTION_RECEIVE_PARAMETERS pReceiveParameters,
    PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext)
/*++

Routine Description:

    This routine initializes a transact exchange instance

Arguments:

    pTransactExchange - the exchange instance

    RxContext         - RDBSS context for the file involved in the transaction.

    pOptions          - the transaction options

    pSendParameters   - the parameters to be sent to the server

    pReceiveParameters - the results from the server

    pResumptionContext   - the resumption context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFobx;

    UCHAR SmbCommand;

    PMDL pSendDataMdl;
    PMDL pSendParamMdl; //used if we can't subsume
    PMDL pReceiveDataMdl;
    PMDL pReceiveParamMdl;

    PVOID pSendSetupBuffer;
    ULONG SendSetupBufferSize;

    PMDL  pReceiveSetupMdl;
    ULONG ReceiveSetupBufferSize;

    ULONG SendDataBufferSize;
    ULONG ReceiveDataBufferSize;

    PVOID pSendParamBuffer;
    ULONG SendParamBufferSize;
    ULONG ReceiveParamBufferSize;

    ULONG MaxSmbBufferSize = 0;
    ULONG PrimaryRequestSmbSize = 0;

    // The fields in theSMB request that are dialect independent and need to be filled in
    PUSHORT pBcc;    // the byte count field
    PUSHORT pSetup;  // the setup data
    PBYTE   pParam;  // the param data

    BOOLEAN fTransactionNameInUnicode = FALSE;

    PSMB_EXCHANGE pExchange = (PSMB_EXCHANGE)pTransactExchange;

    PVOID         pActualPrimaryRequestSmbHeader;
    PSMB_HEADER   pPrimaryRequestSmbHeader;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    ASSERT(pTransactExchange->Type == TRANSACT_EXCHANGE);

    pTransactExchange->RxContext = RxContext;
    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    {
        PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);
        pMRxSmbContext->pExchange     = (PSMB_EXCHANGE)pTransactExchange;
    }

    ASSERT(pSendParameters != NULL);
    if (pSendParameters != NULL) {
        pSendDataMdl        = pSendParameters->pDataMdl;
        pSendParamBuffer    = pSendParameters->pParam;
        SendParamBufferSize = pSendParameters->ParamLength;
        pSendParamMdl       = pSendParameters->pParamMdl;
        pSendSetupBuffer    = pSendParameters->pSetup;
        SendSetupBufferSize = pSendParameters->SetupLength;
        SendDataBufferSize  = pSendParameters->DataLength;
        ASSERT( !((pSendDataMdl == NULL)&&(SendDataBufferSize!=0)) );
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: at the top pbuf/psize/dsize=%08lx/%08lx\n"
                                 ,pSendParamBuffer,SendParamBufferSize,SendDataBufferSize));
    } else {
        Status = STATUS_INVALID_PARAMETER;
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Invalid Parameters\n",Status));
        return Status;
    }

    if (pReceiveParameters != NULL) {
        pReceiveDataMdl  = pReceiveParameters->pDataMdl;
        pReceiveParamMdl = pReceiveParameters->pParamMdl;
        pReceiveSetupMdl = pReceiveParameters->pSetupMdl;

        ReceiveDataBufferSize  = ((pReceiveDataMdl != NULL) ? MmGetMdlByteCount(pReceiveDataMdl) : 0);
        ASSERT (ReceiveDataBufferSize==pReceiveParameters->DataLength);
        ReceiveParamBufferSize = ((pReceiveParamMdl != NULL) ? MmGetMdlByteCount(pReceiveParamMdl) : 0);
        ReceiveSetupBufferSize = ((pReceiveSetupMdl != NULL) ? MmGetMdlByteCount(pReceiveSetupMdl) : 0);
    } else {
        pReceiveDataMdl = pReceiveParamMdl = pReceiveSetupMdl = NULL;
        ReceiveDataBufferSize = ReceiveParamBufferSize = ReceiveDataBufferSize = 0;
    }

    MaxSmbBufferSize = MIN (pServerEntry->Server.MaximumBufferSize,
                           pOptions->MaximumTransmitSmbBufferSize);
    pTransactExchange->MaximumTransmitSmbBufferSize = MaxSmbBufferSize;

    // Ensure that the SMB dialect supports the exchange capability.
    switch (pServerEntry->Server.Dialect) {
    case NTLANMAN_DIALECT:
        {
            if (FlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE)) {
                fTransactionNameInUnicode = TRUE;
            }
        }
        break;

    case LANMAN10_DIALECT:
    case WFW10_DIALECT:
        {
            // these guys only support transact...not T2 or NT. look for the name.....
            if (pOptions->pTransactionName == NULL) {
                RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Server Dialect does not support nameless transactions\n"));
                return STATUS_NOT_SUPPORTED;
            }
        }
       //no break intentional........
    case LANMAN12_DIALECT:
    case LANMAN21_DIALECT:
        {
            //  The NT_TRANSACT SMB is supported by NT servers only. Ensure that no attempt is being made
            //  to send an NT_TRANSACT SMB to a non NT server aka downlevel
            if (pOptions->NtTransactFunction != 0) {
                RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Server Dialect does not support transactions\n"));
                return STATUS_NOT_SUPPORTED;
            }

            fTransactionNameInUnicode = FALSE;
        }
        break;
    default:
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Server Dialect does not support transactions\n"));
        return STATUS_NOT_SUPPORTED;
    }

    PrimaryRequestSmbSize = sizeof(SMB_HEADER) + SendSetupBufferSize;

    // Ensure that the parameter sizes are all valid. The parameter and the data buffer
    // must be less than the maximum size to begin with.
    if ( pOptions->NtTransactFunction == 0) {
        if ((SendParamBufferSize > SMB_TRANSACT_MAXIMUM_PARAMETER_SIZE) ||
            (ReceiveParamBufferSize > SMB_TRANSACT_MAXIMUM_PARAMETER_SIZE) ||
            (SendDataBufferSize > SMB_TRANSACT_MAXIMUM_DATA_SIZE) ||
            (ReceiveDataBufferSize  > SMB_TRANSACT_MAXIMUM_DATA_SIZE)) {
            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Parameters exceed maximum value\n"));
            return STATUS_INVALID_PARAMETER;
        }

        PrimaryRequestSmbSize += sizeof(REQ_TRANSACTION);

        // In all cases the name is sent as a UNICODE string if the appropriate capability is
        // supported. The only exception to this rule is for mail slots for which the name is
        // always transmitted as an ANSI string. Account for the null character as well in the
        // transaction name length.
        if (pOptions->pTransactionName != NULL) {
            if (!fTransactionNameInUnicode) {
                pTransactExchange->TransactionNameLength = RtlUnicodeStringToAnsiSize(pOptions->pTransactionName);
            } else {
                pTransactExchange->TransactionNameLength = pOptions->pTransactionName->Length + sizeof(WCHAR);

                PrimaryRequestSmbSize += (ULONG)((PBYTE)ALIGN_SMB_WSTR(PrimaryRequestSmbSize)
                                      - (PBYTE)(ULONG_PTR)PrimaryRequestSmbSize);
            }

            SmbCommand = SMB_COM_TRANSACTION;
        } else {
            // SMB protocol requires that a single NULL byte be sent as part of all
            // TRANSACT2 transactions.
            pTransactExchange->TransactionNameLength = 1;

            SmbCommand = SMB_COM_TRANSACTION2;
        }

        PrimaryRequestSmbSize += pTransactExchange->TransactionNameLength;
    } else {
        PrimaryRequestSmbSize += sizeof(REQ_NT_TRANSACTION);
        SmbCommand = SMB_COM_NT_TRANSACT;
        pTransactExchange->TransactionNameLength = 0;
    }

    // The header, setup bytes and the name if specified must be part of the primary
    // request SMB for a transaction to be successful. The secondary requests have no
    // provision for sending setup/name.
    if (PrimaryRequestSmbSize > MaxSmbBufferSize) {
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Primary request + setup exceeds maximum buffer size\n"));
        return STATUS_INVALID_PARAMETER;
    }

    // Include the byte count size and then align the size to a DWORD boundary.
    PrimaryRequestSmbSize = ROUND_UP_COUNT(PrimaryRequestSmbSize+sizeof(USHORT),sizeof(DWORD));

    // Try to allocate for the param buffer as well if possible.    The additional DWORD
    // takes into account the worst case of alignment padding required.
    //if ( (PrimaryRequestSmbSize + SendParamBufferSize + sizeof(DWORD)) > MaxSmbBufferSize)
    if ((SendParamBufferSize!=0)
         && (((PrimaryRequestSmbSize + SendParamBufferSize) > MaxSmbBufferSize)
              || (DONTSUBSUME_PARAMS))    ){
        // The param will spill over to a secondary request. Do not attempt to over
        // allocate the primary request. if we can't subsume the params, then we'll need an MDL
        // to partial from.

        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: cannot subsume params\n"));
        pTransactExchange->fParamsSubsumedInPrimaryRequest = FALSE;
        pSendParamMdl = RxAllocateMdl(pSendParamBuffer,SendParamBufferSize);
        if (pSendParamMdl == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: BIGPARAMMDL %08lx\n",pSendParamMdl));
            RxProbeAndLockPages(pSendParamMdl,KernelMode,IoModifyAccess,Status);
            if (Status != STATUS_SUCCESS) {
                IoFreeMdl(pSendParamMdl);
            } else {
                if (MmGetSystemAddressForMdlSafe(pSendParamMdl,LowPagePriority) == NULL) { //map it
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                pSendParameters->pParamMdl = pSendParamMdl; // save it away
            }
        }
    } else {
        PrimaryRequestSmbSize = ROUND_UP_COUNT(PrimaryRequestSmbSize+SendParamBufferSize,sizeof(DWORD));

        // Update the transact exchange to reflect the fact that no separate param MDL is
        // required.
        pTransactExchange->fParamsSubsumedInPrimaryRequest = TRUE;
    }

    pActualPrimaryRequestSmbHeader = (PSMB_HEADER)RxAllocatePoolWithTag(
                                                PagedPool,
                               (PrimaryRequestSmbSize + 4 + TRANSPORT_HEADER_SIZE),
                                                MRXSMB_XACT_POOLTAG); //up to 4 pad bytes

    if (pActualPrimaryRequestSmbHeader == NULL) {
        RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: Cannot allocate primary request SMB\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        (PCHAR) pPrimaryRequestSmbHeader =
            (PCHAR) pActualPrimaryRequestSmbHeader + TRANSPORT_HEADER_SIZE;
    }

    if (Status == STATUS_SUCCESS) {
        switch (SmbCommand) {
        case SMB_COM_TRANSACTION :
        case SMB_COM_TRANSACTION2:
            {
                PREQ_TRANSACTION pTransactRequest;

                pTransactRequest  = (PREQ_TRANSACTION)(pPrimaryRequestSmbHeader + 1);
                pTransactRequest->WordCount = (UCHAR)(14 + (SendSetupBufferSize/sizeof(USHORT)));
                SmbPutUshort(
                    &pTransactRequest->TotalParameterCount,
                    (USHORT)SendParamBufferSize);
                SmbPutUshort(
                    &pTransactRequest->TotalDataCount,
                    (USHORT)SendDataBufferSize);
                SmbPutUshort(
                    &pTransactRequest->MaxParameterCount,
                    (USHORT)ReceiveParamBufferSize);
                SmbPutUshort(
                    &pTransactRequest->MaxDataCount,
                    (USHORT)ReceiveDataBufferSize);

                pTransactRequest->MaxSetupCount = (UCHAR)(ReceiveSetupBufferSize/sizeof(USHORT));

                pTransactRequest->Reserved = 0;
                pTransactRequest->Reserved3 = 0;
                SmbPutUshort(&pTransactRequest->Reserved2, 0);

                SmbPutUshort( &pTransactRequest->Flags, pOptions->Flags&~SMB_XACT_INTERNAL_FLAGS_MASK );
                pTransactRequest->SetupCount = (UCHAR)(SendSetupBufferSize/sizeof(USHORT));
                SmbPutUlong(&pTransactRequest->Timeout, pOptions->TimeoutIntervalInMilliSeconds);
                pSetup = (PUSHORT)pTransactRequest->Buffer;

                // Copy the transact name and align the buffer if required.
                if (pOptions->pTransactionName != NULL) {
                    PBYTE pName;
                    ULONG TransactionNameLength = pTransactExchange->TransactionNameLength;

                    // Set the name field in the SMB.
                    pName = (PBYTE)pSetup +
                            SendSetupBufferSize +
                            sizeof(USHORT);          // account for the bcc field

                    ASSERT(SmbCommand == SMB_COM_TRANSACTION);
                    RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: TransactionName(Length %ld) %ws\n",
                                    TransactionNameLength,
                                    pOptions->pTransactionName->Buffer));

                    if (fTransactionNameInUnicode) {
                        pName = ALIGN_SMB_WSTR(pName);
                        Status = SmbPutUnicodeString(&pName,
                                     pOptions->pTransactionName,
                                     &TransactionNameLength);
                    } else {
                        Status = SmbPutUnicodeStringAsOemString(&pName,
                                     pOptions->pTransactionName,
                                     &TransactionNameLength);
                    }
                }

                pParam = (PBYTE)pSetup +
                         SendSetupBufferSize +
                         sizeof(USHORT) +                          // the bcc field
                         pTransactExchange->TransactionNameLength;
                pParam = ROUND_UP_POINTER(pParam, sizeof(DWORD));
            }
            break;

        case SMB_COM_NT_TRANSACT:
            {
                PREQ_NT_TRANSACTION pNtTransactRequest;

                pNtTransactRequest = (PREQ_NT_TRANSACTION)(pPrimaryRequestSmbHeader + 1);
                pNtTransactRequest->WordCount = (UCHAR)(19 + (SendSetupBufferSize/sizeof(USHORT)));

                SmbPutUlong( &pNtTransactRequest->TotalParameterCount, SendParamBufferSize);
                SmbPutUlong( &pNtTransactRequest->TotalDataCount, SendDataBufferSize);
                SmbPutUlong( &pNtTransactRequest->MaxParameterCount, ReceiveParamBufferSize);
                SmbPutUlong( &pNtTransactRequest->MaxDataCount, ReceiveDataBufferSize);
                RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: init for NT_T (p,d,mp,md) %d %d %d %d\n",
                           pNtTransactRequest->TotalParameterCount, pNtTransactRequest->TotalDataCount,
                           pNtTransactRequest->MaxParameterCount, pNtTransactRequest->MaxDataCount));

                pNtTransactRequest->MaxSetupCount = (UCHAR)(ReceiveSetupBufferSize / sizeof(USHORT));
                SmbPutUshort( &pNtTransactRequest->Flags, pOptions->Flags&~SMB_XACT_INTERNAL_FLAGS_MASK );
                SmbPutUshort( &pNtTransactRequest->Function, pOptions->NtTransactFunction );
                pNtTransactRequest->SetupCount = (UCHAR)(SendSetupBufferSize/sizeof(USHORT));
                pSetup = (PUSHORT)pNtTransactRequest->Buffer;
                pParam = (PBYTE)pSetup +
                         SendSetupBufferSize +
                         sizeof(USHORT);                          // the bcc field
                pParam = ROUND_UP_POINTER(pParam, sizeof(DWORD));
            }
            break;

        default:
            ASSERT(!"Valid Smb Command Type for Transact exchange");
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    if (Status == STATUS_SUCCESS) {
        // All related initialization of a transaction exchange has been
        // completed. At this point the transact exchange assumes ownership
        // of the various buffers ( specified as MDLs ) in the receive and
        // send parameters. It will get rid of them during finalization
        // of the exchange. In order to ensure that the caller does not
        // attempt to free any of these buffers they are reset in the
        // receive/send parameters.

        // Copy the setup data
        RtlCopyMemory(pSetup,pSendSetupBuffer,SendSetupBufferSize);

        if (pTransactExchange->fParamsSubsumedInPrimaryRequest) {
            RxDbgTrace( 0, Dbg, ("SmbTransactExchangeInitialize: subsuming where/size=%08lx/%08lx\n"
                                 ,pSendParamBuffer,SendParamBufferSize));
            RtlCopyMemory(pParam,pSendParamBuffer,SendParamBufferSize);
        }

        // Initialize the transact exchange.
        pTransactExchange->Status = STATUS_MORE_PROCESSING_REQUIRED;

        pTransactExchange->Mid = 0;
        pTransactExchange->SmbCommand = SmbCommand;
        pTransactExchange->pActualPrimaryRequestSmbHeader = pActualPrimaryRequestSmbHeader;
        pTransactExchange->pPrimaryRequestSmbHeader = pPrimaryRequestSmbHeader;
        pTransactExchange->PrimaryRequestSmbSize    = PrimaryRequestSmbSize;

        pTransactExchange->pSendDataMdl = pSendDataMdl;
        pTransactExchange->SendDataBufferSize = SendDataBufferSize;
        pTransactExchange->pReceiveDataMdl  = pReceiveDataMdl;
        pTransactExchange->ReceiveDataBufferSize = ReceiveDataBufferSize;
        pTransactExchange->DataBytesSent = 0;
        pTransactExchange->DataBytesReceived = 0;

        pTransactExchange->pSendParamBuffer = pSendParamBuffer;
        pTransactExchange->SendParamBufferSize = SendParamBufferSize;
        pTransactExchange->pSendParamMdl  = pSendParamMdl;
        pTransactExchange->pReceiveParamMdl  = pReceiveParamMdl;
        pTransactExchange->ReceiveParamBufferSize = ReceiveParamBufferSize;
        pTransactExchange->ParamBytesSent = 0;
        pTransactExchange->ParamBytesReceived = 0;

        pTransactExchange->pReceiveSetupMdl       = pReceiveSetupMdl;
        pTransactExchange->ReceiveSetupBufferSize = ReceiveSetupBufferSize;
        pTransactExchange->SetupBytesReceived = 0;

        pTransactExchange->NtTransactFunction  = pOptions->NtTransactFunction;
        pTransactExchange->Flags               = pOptions->Flags;

        if ((capFobx != NULL) &&
            BooleanFlagOn(capFobx->Flags,FOBX_FLAG_DFS_OPEN)) {
            pTransactExchange->Flags |= SMB_XACT_FLAGS_DFS_AWARE;
        } else if (RxContext->MajorFunction == IRP_MJ_CREATE) {
            PMRX_NET_ROOT pNetRoot = RxContext->pFcb->pNetRoot;

            if (pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT &&
                RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT)) {
                    pTransactExchange->Flags |= SMB_XACT_FLAGS_DFS_AWARE;
            }
        }

        pTransactExchange->pResumptionContext  = pResumptionContext;

        // Reset the Send and Receive parameter data structures to transfer
        // the ownership of the MDLs to the exchange.

        if (pSendParameters->Flags & SMB_XACT_FLAGS_CALLERS_SENDDATAMDL) {
            pTransactExchange->Flags |= SMB_XACT_FLAGS_CALLERS_SENDDATAMDL;
        }

        RtlZeroMemory(
            pSendParameters,
            sizeof(SMB_TRANSACTION_SEND_PARAMETERS));

        RtlZeroMemory(
            pReceiveParameters,
            sizeof(SMB_TRANSACTION_RECEIVE_PARAMETERS));
    }

    if (Status != STATUS_SUCCESS) {
        // Clean up the memory allocated in an effort to initialize the transact exchange
        if (pActualPrimaryRequestSmbHeader) {

            RxFreePool(pActualPrimaryRequestSmbHeader);
        }
    } else {
        PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

        pMRxSmbContext->pExchange = (PSMB_EXCHANGE)pTransactExchange;

        pTransactExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_ATTEMPT_RECONNECTS;

        if (pOptions->Flags & SMB_XACT_FLAGS_INDEFINITE_DELAY_IN_RESPONSE ) {
            pTransactExchange->SmbCeFlags |= SMBCE_EXCHANGE_INDEFINITE_DELAY_IN_RESPONSE;
        }
    }

    return Status;
}

NTSTATUS
SmbTransactExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize)
/*++

Routine Description:

    This routine finalizes the transact exchange. It resumes the RDBSS by invoking
    the call back and discards the exchange

Arguments:

    pExchange - the exchange instance

    CurrentIrql - the interrupt request level

    pPostFinalize - set to TRUE if the request is to be posted

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_TRANSACT_EXCHANGE               pTransactExchange;
    PSMB_TRANSACTION_RESUMPTION_CONTEXT  pResumptionContext;
    LONG                                 References;

    ASSERT(pExchange->Type == TRANSACT_EXCHANGE);

    pTransactExchange  = (PSMB_TRANSACT_EXCHANGE)pExchange;

    RxLog((">>>XE %lx",pTransactExchange));

    if ((pTransactExchange->ReceiveParamBufferSize > 0) &&
        (pTransactExchange->ReceiveParamBufferSize !=
        pTransactExchange->ParamBytesReceived)) {
        RxDbgTrace(0, Dbg,
                 ("SmbCeTransactExchangeFinalize: Param Bytes Receive error ... expected(%ld) received(%ld)\n",
                  pTransactExchange->ReceiveParamBufferSize, pTransactExchange->ParamBytesReceived
                ));
    }

    if ((pTransactExchange->ReceiveDataBufferSize > 0) &&
        (pTransactExchange->ReceiveDataBufferSize !=
        pTransactExchange->DataBytesReceived)) {
        RxDbgTrace(0, Dbg,
                 ("SmbCeTransactExchangeFinalize: Data Bytes Receive error ... expected(%ld) received(%ld)\n",
                  pTransactExchange->ReceiveDataBufferSize, pTransactExchange->DataBytesReceived
                 ));
    }

    if (RxShouldPostCompletion()) {
        RxPostToWorkerThread(
            MRxSmbDeviceObject,
            CriticalWorkQueue,
            &pExchange->WorkQueueItem,
            SmbCeDiscardTransactExchange,
            pTransactExchange);
    } else {
        SmbCeDiscardTransactExchange(pTransactExchange);
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pPostFinalize);
}

NTSTATUS
SmbTransactAccrueAndValidateFormatData(
    IN struct _SMB_TRANSACT_EXCHANGE *pTransactExchange,    // The exchange instance
    IN  PSMB_HEADER                  pSmbHeader,
    IN  ULONG                        BytesIndicated,
    OUT PSMB_TRANSACT_RESP_FORMAT_DESCRIPTION Format
    )
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:


Return Value:

    RXSTATUS - The return status for the operation
          STATUS_SUCCESS -- all the data was indicated and it was valid
          STATUS_INVALID_NETWORK_RESPONSE -- something about the format parameters is untoward.

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PRESP_TRANSACTION pTransactResponse = (PRESP_TRANSACTION)(pSmbHeader+1);
    PBYTE WordCountPtr;
    UCHAR WordCount;
    PBYTE ByteCountPtr;
    USHORT ByteCount;

    RtlZeroMemory(Format,sizeof(*Format));

    Format->WordCount = WordCount = pTransactResponse->WordCount;
    ByteCountPtr = (&pTransactResponse->WordCount)+1+(sizeof(USHORT)*WordCount);

    if (((ULONG)(ByteCountPtr+sizeof(USHORT)-((PBYTE)pSmbHeader)))>BytesIndicated) {
        ByteCount = SmbGetUshort(ByteCountPtr);
        DbgPrint("ExtraTransactBytes wc,bcp,bc,smbh %lx,%lx,%lx,%lx\n",
                 WordCount,ByteCountPtr,ByteCount,pSmbHeader);
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    Format->ByteCount = ByteCount = SmbGetUshort(ByteCountPtr);
    Format->ApparentMsgLength = (ULONG)((ByteCountPtr+sizeof(USHORT)-((PBYTE)pSmbHeader))+ByteCount);

    if (WordCount==0) {
        return(STATUS_SUCCESS);
    }

    switch (pSmbHeader->Command) {
    case SMB_COM_TRANSACTION2:
    case SMB_COM_TRANSACTION:
    case SMB_COM_TRANSACTION_SECONDARY:
    case SMB_COM_TRANSACTION2_SECONDARY:
        {
            Format->TotalParameterCount    = SmbGetUshort(&pTransactResponse->TotalParameterCount);
            Format->TotalDataCount         = SmbGetUshort(&pTransactResponse->TotalDataCount);

            Format->ParameterCount          = SmbGetUshort(&pTransactResponse->ParameterCount);
            Format->ParameterOffset         = SmbGetUshort(&pTransactResponse->ParameterOffset);
            Format->ParameterDisplacement   = SmbGetUshort(&pTransactResponse->ParameterDisplacement);

            Format->DataCount         = SmbGetUshort(&pTransactResponse->DataCount);
            Format->DataOffset        = SmbGetUshort(&pTransactResponse->DataOffset);
            Format->DataDisplacement  = SmbGetUshort(&pTransactResponse->DataDisplacement);
        }
        break;

    case SMB_COM_NT_TRANSACT:
    case SMB_COM_NT_TRANSACT_SECONDARY:
        {
            PRESP_NT_TRANSACTION pNtTransactResponse;

            pNtTransactResponse = (PRESP_NT_TRANSACTION)(pTransactResponse);

            Format->TotalParameterCount  = SmbGetUlong(&pNtTransactResponse->TotalParameterCount);
            Format->TotalDataCount = SmbGetUlong(&pNtTransactResponse->TotalDataCount);

            Format->ParameterCount  = SmbGetUlong(&pNtTransactResponse->ParameterCount);
            Format->ParameterOffset = SmbGetUlong(&pNtTransactResponse->ParameterOffset);
            Format->ParameterDisplacement = SmbGetUlong(&pNtTransactResponse->ParameterDisplacement);

            Format->DataCount   = SmbGetUlong(&pNtTransactResponse->DataCount);
            Format->DataOffset  = SmbGetUlong(&pNtTransactResponse->DataOffset);
            Format->DataDisplacement  = SmbGetUlong(&pNtTransactResponse->DataDisplacement);
        }
        break;

    default:
        // Bug Check
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    //do this here so we can use it as validation criterion
    pTransactExchange->ParameterBytesSeen += Format->ParameterCount;
    pTransactExchange->DataBytesSeen += Format->DataCount;

    return Status;
}

NTSTATUS
ParseTransactResponse(
    IN struct _SMB_TRANSACT_EXCHANGE *pTransactExchange,    // The exchange instance
    IN PSMB_TRANSACT_RESP_FORMAT_DESCRIPTION Format,
    IN ULONG        BytesIndicated,
    IN ULONG        BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pCopyRequestMdlPointer,
    OUT PULONG      pCopyRequestSize)
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:

    pTransactExchange - the exchange instance

    BytesIndicated    - the number of bytes indicated

    Bytes Available   - the number of bytes available

    pBytesTaken       - the number of bytes consumed

    pSmbHeader        - the byte buffer

    pCopyRequestMdlPointer - the buffer into which the remaining data is to be copied.

    pCopyRequestSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation
          STATUS_MORE_PROCESSING_REQUIRED -- if a copy of the data needs to be done before
          processing can be completed. This occurs because all the data was not indicated
          STATUS_SUCCESS -- all the data was indicated and it was valid
          STATUS_* -- They indicate an error which would normally leads to the abortion of the
          exchange.

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG ParamBytesInResponse  = 0;
    ULONG ParamOffsetInResponse = 0;
    ULONG DataBytesInResponse   = 0;
    ULONG DataOffsetInResponse  = 0;

    ULONG PaddingLength = 0;

    PMDL  pFirstMdlInCopyDataRequestChain = NULL;
    PMDL  pLastMdlInCopyDataRequestChain = NULL;
    PMDL  pParamMdl = NULL;
    PMDL  pPaddingMdl = NULL;
    PMDL  pDataMdl  = NULL;

    PBYTE pParamStartAddress;
    PBYTE pDataStartAddress;
    PBYTE pSmbBuffer = (PBYTE)pSmbHeader;

    switch (pSmbHeader->Command) {
    case SMB_COM_TRANSACTION2:
    case SMB_COM_TRANSACTION:
    case SMB_COM_TRANSACTION_SECONDARY:
    case SMB_COM_TRANSACTION2_SECONDARY:
        {
            PRESP_TRANSACTION pTransactResponse;

            pTransactResponse = (PRESP_TRANSACTION)(pSmbBuffer + *pBytesTaken);
            *pBytesTaken = *pBytesTaken + sizeof(RESP_TRANSACTION);
        }
        break;
    case SMB_COM_NT_TRANSACT:
    case SMB_COM_NT_TRANSACT_SECONDARY:
        {
            PRESP_NT_TRANSACTION pNtTransactResponse;

            pNtTransactResponse = (PRESP_NT_TRANSACTION)(pSmbBuffer + *pBytesTaken);
            *pBytesTaken = *pBytesTaken + sizeof(RESP_NT_TRANSACTION);
        }
        break;
    default:
        // Bug Check
        ASSERT(!"Valid SMB command in Transaction response");
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    ParamBytesInResponse  = Format->ParameterCount;
    ParamOffsetInResponse = Format->ParameterOffset;
    DataBytesInResponse   = Format->DataCount;
    DataOffsetInResponse  = Format->DataOffset;

    if (ParamBytesInResponse > 0) {
        ASSERT(pTransactExchange->pReceiveParamMdl != NULL);
        pParamStartAddress = (PBYTE)MmGetSystemAddressForMdlSafe(pTransactExchange->pReceiveParamMdl,LowPagePriority);

        if (pParamStartAddress == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            pParamStartAddress += Format->ParameterDisplacement;
        }
    } else {
        pParamStartAddress = NULL;
    }

    if (DataBytesInResponse > 0) {
        ASSERT(pTransactExchange->pReceiveDataMdl != NULL);
        pDataStartAddress  = (PBYTE)MmGetSystemAddressForMdlSafe(pTransactExchange->pReceiveDataMdl,LowPagePriority);

        if (pDataStartAddress == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            pDataStartAddress  += Format->DataDisplacement;
        }
    } else {
        pDataStartAddress = NULL;
    }

    RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Param Bytes(%ld) Param Offset (%ld) Data Bytes (%ld) Data Offset(%ld)\n",
                        ParamBytesInResponse,
                        ParamOffsetInResponse,
                        DataBytesInResponse,
                        DataOffsetInResponse));

    // If either the param bytes or the data bytes have already been indicated, copy
    // them into the respective buffers and trim the size of the MDL for the copy
    // data request.

    if (ParamOffsetInResponse <= BytesIndicated) {
        *pBytesTaken = ParamOffsetInResponse;
        if (ParamBytesInResponse > 0) {
            ULONG ParamBytesIndicated = MIN(
                                            ParamBytesInResponse,
                                            BytesIndicated - ParamOffsetInResponse);

            RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Param Bytes indicated %ld\n",ParamBytesIndicated));
            RtlCopyMemory(
                pParamStartAddress,
                (pSmbBuffer + ParamOffsetInResponse),
                ParamBytesIndicated);

            *pBytesTaken = *pBytesTaken + ParamBytesIndicated;
            pParamStartAddress += ParamBytesIndicated;
            ParamBytesInResponse -= ParamBytesIndicated;
            ParamOffsetInResponse += ParamBytesIndicated;
            pTransactExchange->ParamBytesReceived  += ParamBytesIndicated;
        }
    }

    if (DataOffsetInResponse <= BytesIndicated) {
        *pBytesTaken = DataOffsetInResponse;  //you have to move up EVEN IF NO BYTES!!!!!
        if (DataBytesInResponse > 0) {
            ULONG DataBytesIndicated = MIN(
                                           DataBytesInResponse,
                                           BytesIndicated - DataOffsetInResponse);

            RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Data Bytes indicated %ld\n",DataBytesIndicated));
            RtlCopyMemory(
                pDataStartAddress,
                (pSmbBuffer + DataOffsetInResponse),
                DataBytesIndicated);

            *pBytesTaken = *pBytesTaken + DataBytesIndicated;
            pDataStartAddress += DataBytesIndicated;
            DataBytesInResponse -= DataBytesIndicated;
            DataOffsetInResponse += DataBytesIndicated;
            pTransactExchange->DataBytesReceived  += DataBytesIndicated;
        }
    }

    RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Made it past the copies......... \n"));

    if (ParamBytesInResponse > 0) {
        // There are more param bytes that have not been indicated. Set up an MDL
        // to copy them over.

        RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Posting Copy request for Param Bytes %ld\n",ParamBytesInResponse));
        pParamMdl = RxAllocateMdl(
                        ((PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pReceiveParamMdl)
                        + pTransactExchange->ParamBytesReceived),
                        ParamBytesInResponse);

        if (pParamMdl != NULL) {
            IoBuildPartialMdl(
                pTransactExchange->pReceiveParamMdl,
                pParamMdl,
                ((PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pReceiveParamMdl)
                 + pTransactExchange->ParamBytesReceived),
                ParamBytesInResponse);
            pFirstMdlInCopyDataRequestChain = pParamMdl;
            pLastMdlInCopyDataRequestChain  = pParamMdl;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        pTransactExchange->ParamBytesReceived += ParamBytesInResponse;
    }

    if ((Status == STATUS_SUCCESS) &&
        (DataBytesInResponse > 0)) {

        RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Posting Copy request for Data Bytes %ld\n",DataBytesInResponse));

        // In certain cases a padding MDL needs to be inserted between the param and data portions
        // of the response to consume the padding bytes sent by the server.
        if ((ParamBytesInResponse > 0) &&
            ((PaddingLength = DataOffsetInResponse -
                           (ParamBytesInResponse + ParamOffsetInResponse)) > 0)) {
            RxDbgTrace( 0, Dbg, ("ParseTransactResponse: Posting Copy request for padding bytes %ld\n",PaddingLength));
            // There are some padding bytes present. Construct an MDL to consume them
            //pPaddingMdl = RxAllocateMdl(&MRxSmb_pPaddingData,PaddingLength);
            ASSERT(!"this doesn't work");
            if (pPaddingMdl != NULL) {
                if (pLastMdlInCopyDataRequestChain != NULL) {
                    pLastMdlInCopyDataRequestChain->Next = pPaddingMdl;
                } else {
                    pFirstMdlInCopyDataRequestChain = pPaddingMdl;
                }
                pLastMdlInCopyDataRequestChain = pPaddingMdl;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        // There are more data bytes which have not been indicated. Set up an MDL
        // to copy them over.
        if (Status == STATUS_SUCCESS) {
            if (pTransactExchange->pReceiveDataMdl->ByteCount >= DataBytesInResponse) {
                pDataMdl = RxAllocateMdl(
                               ((PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pReceiveDataMdl)
                                + pTransactExchange->DataBytesReceived),
                               DataBytesInResponse);

                if (pDataMdl != NULL) {
                    IoBuildPartialMdl(
                        pTransactExchange->pReceiveDataMdl,
                        pDataMdl,
                        ((PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pReceiveDataMdl)
                         + pTransactExchange->DataBytesReceived),
                        DataBytesInResponse);

                    if (pLastMdlInCopyDataRequestChain != NULL) {
                        pLastMdlInCopyDataRequestChain->Next = pDataMdl;
                    } else {
                        pFirstMdlInCopyDataRequestChain = pDataMdl;
                    }

                    pLastMdlInCopyDataRequestChain = pDataMdl;
                    pTransactExchange->DataBytesReceived += DataBytesInResponse;
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }
        }
    }

    if (Status != STATUS_SUCCESS) {
        if (pDataMdl != NULL) {
            IoFreeMdl(pDataMdl);
        }

        if (pPaddingMdl != NULL) {
            IoFreeMdl(pPaddingMdl);
        }

        if (pParamMdl != NULL) {
            IoFreeMdl(pParamMdl);
        }
    } else {
        if (pFirstMdlInCopyDataRequestChain != NULL) {
            ULONG MdlLength = ParamBytesInResponse+PaddingLength+DataBytesInResponse;
            *pCopyRequestMdlPointer = pFirstMdlInCopyDataRequestChain;
            *pCopyRequestSize = MdlLength;
            RxDbgTrace( 0, Dbg, ("ParseTransactResponse: final mdl and copy size %08lx %08lx(%ld)\n",
                              pFirstMdlInCopyDataRequestChain,MdlLength,MdlLength));
            IF_DEBUG {
                PMDL imdl = pFirstMdlInCopyDataRequestChain;
                ULONG mdllength = MdlLength;
                mdllength -= MmGetMdlByteCount(imdl);
                for (;;) {
                    if (!(imdl=imdl->Next)) break;
                    mdllength -= MmGetMdlByteCount(imdl);
                }
                ASSERT(mdllength==0);
            }

            InterlockedIncrement(&pTransactExchange->PendingCopyRequests);
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        }

        if ((pTransactExchange->ParamBytesReceived < pTransactExchange->ReceiveParamBufferSize) ||
            (pTransactExchange->DataBytesReceived  < pTransactExchange->ReceiveDataBufferSize)) {
            NTSTATUS ReceiveStatus;

            // The exchange has been successfully completed. Finalize it.
            RxDbgTrace(0,Dbg,("ParseTransactResponse: Register for more responses\n"));
            ReceiveStatus = SmbCeReceive((PSMB_EXCHANGE)pTransactExchange);
            if (ReceiveStatus != STATUS_SUCCESS) {
                // There was an error in registering the receive. Abandon the
                // transaction.
                Status = ReceiveStatus;
            }
        }
    }

    return Status;

    UNREFERENCED_PARAMETER(BytesAvailable);

}

#if DBG
ULONG SmbSendBadSecondary = 0;
#endif
NTSTATUS
SendSecondaryRequests(PVOID pContext)
/*++

Routine Description:

    This routine sends all the secondary requests associated with the transaction

Arguments:

    pTransactExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    PSMB_EXCHANGE pExchange = (PSMB_EXCHANGE)pContext;
    PSMB_TRANSACT_EXCHANGE pTransactExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;

    NTSTATUS Status = STATUS_SUCCESS;

    ULONG MaximumSmbBufferSize;

    // The MDL's used in sending the primary request associated with the TRANSACT SMB
    PMDL  pPartialDataMdl         = NULL;
    PMDL  pPartialParamMdl        = NULL;
    PMDL  pPaddingMdl             = NULL;
    PMDL  pSecondaryRequestSmbMdl = NULL;
    PMDL  pLastMdlInChain         = NULL;

    ULONG SecondaryRequestSmbSize = 0;
    ULONG SmbLength;
    ULONG PaddingLength;

    ULONG ParamOffset,ParamDisplacement;
    ULONG DataOffset,DataDisplacement;
    ULONG ByteCountOffset;
    USHORT ByteCount;
    PUSHORT pByteCount;

    ULONG ParamBytesToBeSent;        // Param bytes to be sent per request
    ULONG DataBytesToBeSent;         // data bytes to be sent per request
    ULONG SendParamBufferSize;       // Total param bytes to be sent in secondary requests
    ULONG SendDataBufferSize;        // Total data bytes to be sent in secondary requests
    PBYTE pSendParamStartAddress = NULL;
    PBYTE pSendDataStartAddress  = NULL;
    PBYTE pOriginalParamBuffer = NULL;
    PBYTE pOriginalDataBuffer = NULL;
    ULONG TotalParamBytes,TotalDataBytes;

    BOOLEAN ParamPartialMdlAlreadyUsed = FALSE;
    BOOLEAN DataPartialMdlAlreadyUsed = FALSE;

    PVOID pActualSecondaryRequestSmbHeader = NULL;
    PSMB_HEADER pSecondaryRequestSmbHeader = NULL;

    PAGED_CODE();

    ASSERT(pTransactExchange->State == TRANSACT_EXCHANGE_RECEIVED_INTERIM_RESPONSE);


    TotalParamBytes = pTransactExchange->SendParamBufferSize;
    SendParamBufferSize = TotalParamBytes - pTransactExchange->ParamBytesSent;

    TotalDataBytes = pTransactExchange->SendDataBufferSize;
    SendDataBufferSize = TotalDataBytes - pTransactExchange->DataBytesSent;

    ASSERT((SendParamBufferSize > 0) || (SendDataBufferSize > 0));

    switch (pTransactExchange->SmbCommand) {
    case SMB_COM_TRANSACTION:
        SecondaryRequestSmbSize = sizeof(SMB_HEADER) +
            FIELD_OFFSET(REQ_TRANSACTION_SECONDARY,Buffer);
        break;

    case SMB_COM_TRANSACTION2:
        SecondaryRequestSmbSize = sizeof(SMB_HEADER) +
            FIELD_OFFSET(REQ_TRANSACTION_SECONDARY,Buffer)
            + sizeof(USHORT);  //add in the extra word
        break;

    case SMB_COM_NT_TRANSACT:
        SecondaryRequestSmbSize = sizeof(SMB_HEADER) +
            FIELD_OFFSET(REQ_NT_TRANSACTION_SECONDARY,Buffer);
        break;

    default:
        ASSERT(!"Valid Smb Command in transaction exchange");
        Status = STATUS_TRANSACTION_ABORTED;
    }

    SecondaryRequestSmbSize = QuadAlign(SecondaryRequestSmbSize); //pad to quadword boundary

    pActualSecondaryRequestSmbHeader = (PSMB_HEADER)
                                 RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     SecondaryRequestSmbSize + TRANSPORT_HEADER_SIZE,
                                     MRXSMB_XACT_POOLTAG);

    if ((Status == STATUS_SUCCESS) && pActualSecondaryRequestSmbHeader != NULL) {

        (PCHAR) pSecondaryRequestSmbHeader =
            (PCHAR) pActualSecondaryRequestSmbHeader + TRANSPORT_HEADER_SIZE;

        // Initialize the SMB header  ...

        ASSERT(
                 ((SMB_COM_TRANSACTION+1) == SMB_COM_TRANSACTION_SECONDARY)
               &&((SMB_COM_TRANSACTION2+1)== SMB_COM_TRANSACTION2_SECONDARY)
               &&((SMB_COM_NT_TRANSACT+1) == SMB_COM_NT_TRANSACT_SECONDARY)
             );

        Status = SmbTransactBuildHeader(
                     pTransactExchange,                        // the exchange instance
                     (UCHAR)(pTransactExchange->SmbCommand+1), // the SMB command ..see the asserts above
                     pSecondaryRequestSmbHeader);              // the SMB buffer

        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: SmbCeBuildSmbHeader returned %lx\n",Status));
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        MaximumSmbBufferSize = pTransactExchange->MaximumTransmitSmbBufferSize;

        // Ensure that the MDL's have been probed & locked. The new MDL's have been allocated.
        // The partial MDL's are allocated to be large enough to span the maximum buffer
        // length possible.

        // Initialize the data related MDL's for the secondary request
        if (SendDataBufferSize > 0) {
            RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: Data Bytes remaining %ld\n",SendDataBufferSize));

            pOriginalDataBuffer = (PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pSendDataMdl);
            pSendDataStartAddress = pOriginalDataBuffer + pTransactExchange->DataBytesSent;

            pPartialDataMdl = RxAllocateMdl(
                                  0,
                                  (MIN(pTransactExchange->SendDataBufferSize,
                                       MaximumSmbBufferSize) +
                                       PAGE_SIZE - 1));

            if (pPartialDataMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        // Initialize the parameter related MDL's for the secondary request
        if ((SendParamBufferSize > 0) && (Status == STATUS_SUCCESS)) {
            RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: Param Bytes remaining %ld\n",SendParamBufferSize));
            pOriginalParamBuffer = (PBYTE)MmGetMdlVirtualAddress(pTransactExchange->pSendParamMdl);
            pSendParamStartAddress = pOriginalParamBuffer + pTransactExchange->ParamBytesSent;

            pPartialParamMdl  = RxAllocateMdl(
                                    0,
                                    (MIN(pTransactExchange->SendParamBufferSize,
                                         MaximumSmbBufferSize) +
                                         PAGE_SIZE - 1));

            pPaddingMdl       = RxAllocateMdl(0,(sizeof(DWORD) + PAGE_SIZE - 1));

            if ((pPartialParamMdl == NULL) ||
                (pPaddingMdl == NULL)) {
                RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: Error allocating param MDLS\n"));
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        // Initialize the secondary request SMB MDL
        if (Status == STATUS_SUCCESS) {

            RxAllocateHeaderMdl(
                pSecondaryRequestSmbHeader,
                SecondaryRequestSmbSize,
                pSecondaryRequestSmbMdl
                );

            if (pSecondaryRequestSmbMdl != NULL) {

                RxProbeAndLockHeaderPages(
                    pSecondaryRequestSmbMdl,
                    KernelMode,
                    IoModifyAccess,
                    Status);

                if (Status != STATUS_SUCCESS) {
                    IoFreeMdl(pSecondaryRequestSmbMdl);
                    pSecondaryRequestSmbMdl = NULL;
                } else {
                    if (MmGetSystemAddressForMdlSafe(pSecondaryRequestSmbMdl,LowPagePriority) == NULL) { //map it
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            } else {
                RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: Error allocating 2ndsmb MDL\n"));
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    while ((Status == STATUS_SUCCESS) &&
           ((SendParamBufferSize > 0) || (SendDataBufferSize > 0))) {
        PaddingLength      = 0;
        DataBytesToBeSent  = 0;
        ParamBytesToBeSent = 0;
        ParamDisplacement = 0;
        pLastMdlInChain    = pSecondaryRequestSmbMdl;

        ParamOffset = DataOffset = SecondaryRequestSmbSize;

        ParamBytesToBeSent = MIN((MaximumSmbBufferSize - ParamOffset),
                               SendParamBufferSize);

        if (ParamBytesToBeSent > 0) {
            // Form a MDL for the portion of the parameter buffer being transmitted
            if (ParamPartialMdlAlreadyUsed) {
                MmPrepareMdlForReuse(pPartialParamMdl);
            }

            ParamPartialMdlAlreadyUsed = TRUE;
            IoBuildPartialMdl(
                pTransactExchange->pSendParamMdl,
                pPartialParamMdl,
                pSendParamStartAddress,
                ParamBytesToBeSent);

            ParamDisplacement  = (ULONG)(pSendParamStartAddress - pOriginalParamBuffer);
            pSendParamStartAddress  += ParamBytesToBeSent;
            SendParamBufferSize     -= ParamBytesToBeSent;
            DataOffset              += QuadAlign(ParamBytesToBeSent);

            pLastMdlInChain->Next = pPartialParamMdl;
            pLastMdlInChain = pPartialParamMdl;
        } else {
            // don't do this! the padding stuff uses it. you can set it later
            // ParamOffset = 0;
        }

        if ((DataOffset < MaximumSmbBufferSize) && (SendDataBufferSize > 0) ) {
            // There is room for data bytes to be sent
            // Check if we need a padding MDL ....
            PaddingLength = DataOffset - (ParamOffset + ParamBytesToBeSent);

            if (PaddingLength > 0) {
                RxDbgTrace( 0, Dbg, ("SmbCeTransactExchangeStart: Padding Length %ld\n",PaddingLength));
                RxBuildPaddingPartialMdl(pPaddingMdl,PaddingLength);
                pLastMdlInChain->Next = pPaddingMdl;
                pLastMdlInChain = pPaddingMdl;
            }

            // Link the data buffer or portions of it if the size constraints are satisfied
            DataBytesToBeSent = MIN((MaximumSmbBufferSize - DataOffset),
                                  SendDataBufferSize);
            ASSERT (DataBytesToBeSent > 0);

            // Form a MDL for the portions of the data buffer being sent
            if (DataPartialMdlAlreadyUsed) {
                MmPrepareMdlForReuse(pPartialDataMdl);
            }

            DataPartialMdlAlreadyUsed = TRUE;
            IoBuildPartialMdl(
                pTransactExchange->pSendDataMdl,
                pPartialDataMdl,
                pSendDataStartAddress,
                DataBytesToBeSent);

            //  chain the data MDL
            pLastMdlInChain->Next = pPartialDataMdl;
            pLastMdlInChain = pPartialDataMdl;

            DataDisplacement  = (ULONG)(pSendDataStartAddress - pOriginalDataBuffer);
            pSendDataStartAddress   += DataBytesToBeSent;
            SendDataBufferSize      -= DataBytesToBeSent;
        } else {
            DataOffset = DataDisplacement  = 0;
            DbgDoit(if (SmbSendBadSecondary){DataOffset = QuadAlign(ParamOffset + ParamBytesToBeSent);});
        }

        if (ParamBytesToBeSent == 0) {
            ParamOffset = 0;
        }

        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: Secondary Request Param(%ld) padding(%ld) Data(%ld)\n",
                            ParamBytesToBeSent,
                            PaddingLength,
                            DataBytesToBeSent));
        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests:  ParamO(%ld) DataO(%ld)\n",ParamOffset,DataOffset));
        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests:  ParamD(%ld) DataD(%ld)\n",ParamDisplacement,DataDisplacement));
        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests:  TotParam(%ld) TotData(%ld)\n",TotalParamBytes,TotalDataBytes));

        // Update the secondary request buffer with the final sizes of the data/parameter etc.
        switch (pTransactExchange->SmbCommand) {
        case SMB_COM_TRANSACTION:
        case SMB_COM_TRANSACTION2:
            {
                PREQ_TRANSACTION_SECONDARY pTransactRequest;

                //ASSERT(!"this has not been tested");

                pTransactRequest = (PREQ_TRANSACTION_SECONDARY)(pSecondaryRequestSmbHeader + 1);

                pTransactRequest->WordCount = 8;                                     // Count of parameter words = 8
                SmbPutUshort(&pTransactRequest->TotalParameterCount, (USHORT)TotalParamBytes); // Total parameter bytes being sent
                SmbPutUshort(&pTransactRequest->TotalDataCount, (USHORT)TotalDataBytes);      // Total data bytes being sent
                SmbPutUshort(&pTransactRequest->ParameterCount, (USHORT)ParamBytesToBeSent);   // Parameter bytes sent this buffer
                SmbPutUshort(&pTransactRequest->ParameterOffset, (USHORT)ParamOffset);          // Offset (from header start) to params
                SmbPutUshort(&pTransactRequest->ParameterDisplacement, (USHORT)ParamDisplacement);    // Displacement of these param bytes
                SmbPutUshort(&pTransactRequest->DataCount, (USHORT)DataBytesToBeSent);   // Parameter bytes sent this buffer
                SmbPutUshort(&pTransactRequest->DataOffset, (USHORT)DataOffset);               // Offset (from header start) to Datas
                SmbPutUshort(&pTransactRequest->DataDisplacement, (USHORT)DataDisplacement);   // Displacement of these Data bytes
                ByteCountOffset = FIELD_OFFSET(REQ_TRANSACTION_SECONDARY,ByteCount);
                if (pTransactExchange->SmbCommand == SMB_COM_TRANSACTION2 ) {
                    ByteCountOffset += sizeof(USHORT);
                    pTransactRequest->WordCount++;  //one extra word
                    SmbPutUshort((&pTransactRequest->DataDisplacement)+1, 0); //the +1 is to move up 1 USHORT
                }
            }
            break;

        case SMB_COM_NT_TRANSACT:
            {
                PREQ_NT_TRANSACTION_SECONDARY pNtTransactRequest;

                pNtTransactRequest= (PREQ_NT_TRANSACTION_SECONDARY)(pSecondaryRequestSmbHeader + 1);

                pNtTransactRequest->WordCount = 18;                                     // Count of parameter words = 18
                pNtTransactRequest->Reserved1 = 0;                                      // MBZ
                SmbPutUshort(&pNtTransactRequest->Reserved2, 0);                        // MBZ
                SmbPutUlong(&pNtTransactRequest->TotalParameterCount, TotalParamBytes); // Total parameter bytes being sent
                SmbPutUlong(&pNtTransactRequest->TotalDataCount, TotalDataBytes);      // Total data bytes being sent
                SmbPutUlong(&pNtTransactRequest->ParameterCount, ParamBytesToBeSent);   // Parameter bytes sent this buffer
                SmbPutUlong(&pNtTransactRequest->ParameterOffset, ParamOffset);          // Offset (from header start) to params
                SmbPutUlong(&pNtTransactRequest->ParameterDisplacement, ParamDisplacement);    // Displacement of these param bytes
                SmbPutUlong(&pNtTransactRequest->DataCount, DataBytesToBeSent);   // Parameter bytes sent this buffer
                SmbPutUlong(&pNtTransactRequest->DataOffset, DataOffset);               // Offset (from header start) to Datas
                SmbPutUlong(&pNtTransactRequest->DataDisplacement, DataDisplacement);   // Displacement of these Data bytes
                pNtTransactRequest->Reserved3 = 0;                                      // MBZ

                ByteCountOffset = FIELD_OFFSET(REQ_NT_TRANSACTION_SECONDARY,ByteCount);
            }
            break;

        default:
            ASSERT(!"Valid Smb Command for initiating Transaction");
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        // Send the secondary SMB
        SmbLength = SecondaryRequestSmbSize +
                    ParamBytesToBeSent +
                    PaddingLength +
                    DataBytesToBeSent;

        ByteCount = (USHORT)(SmbLength-(sizeof(SMB_HEADER)+ByteCountOffset+sizeof(USHORT)));
        pByteCount = (PUSHORT)((PBYTE)pSecondaryRequestSmbHeader+sizeof(SMB_HEADER)+ByteCountOffset);
        SmbPutUshort(pByteCount,ByteCount);

        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: len %d bytecount %d(%x)\n", SmbLength, ByteCount, ByteCount));
        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: msgmdl=%08lx\n", pSecondaryRequestSmbHeader));

        RxLog(("2nd: %lx %lx %lx %lx %lx %lx",ParamOffset,ParamDisplacement,TotalParamBytes,DataOffset,DataDisplacement,TotalDataBytes));
        RxLog(("2nd:: %lx %lx",ByteCount,SmbLength));

        Status = SmbCeSend(
                     pExchange,
                     RXCE_SEND_SYNCHRONOUS,
                     pSecondaryRequestSmbMdl,
                     SmbLength);

        RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: SmbCeSend returned %lx\n",Status));
        if ((Status != STATUS_PENDING) && (Status != STATUS_SUCCESS)) {
            RxDbgTrace( 0, Dbg, ("SendSecondaryRequests: SmbCeSend returned bad status %lx\n",Status));
            //here we should just get out
            goto FINALLY;    //yes we cold have said break....but that's not what we're doing
        } else {
            Status = STATUS_SUCCESS;
        }
    }

FINALLY:
    if (pPartialDataMdl != NULL) {
        IoFreeMdl(pPartialDataMdl);
    }

    if (pActualSecondaryRequestSmbHeader != NULL) {
        RxFreePool(pActualSecondaryRequestSmbHeader);
    }

    if (pPartialParamMdl != NULL) {
        IoFreeMdl(pPartialParamMdl);
    }

    if (pPaddingMdl != NULL) {
        IoFreeMdl(pPaddingMdl);
    }

    if (pSecondaryRequestSmbMdl != NULL) {
        RxUnlockHeaderPages(pSecondaryRequestSmbMdl);
        IoFreeMdl(pSecondaryRequestSmbMdl);
    }

    //we always finalize......but we only set the status if there's an error or
    //                        we expect no response
    if ((Status != STATUS_SUCCESS) || (pTransactExchange->Flags & SMB_TRANSACTION_NO_RESPONSE )) {
        pExchange->Status = Status;
    }

    SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

    return Status;
}




SMB_EXCHANGE_DISPATCH_VECTOR
TransactExchangeDispatch = {
                            SmbTransactExchangeStart,
                            SmbTransactExchangeReceive,
                            SmbTransactExchangeCopyDataHandler,
                            NULL,                                  // SmbTransactExchangeSendCallbackHandler
                            SmbTransactExchangeFinalize,
                            NULL
                           };



#ifndef RX_NO_DBGFIELD_HLPRS

#define DECLARE_FIELD_HLPR(x) ULONG SmbPseTxeField_##x = FIELD_OFFSET(SMB_TRANSACT_EXCHANGE,x);
#define DECLARE_FIELD_HLPR2(x,y) ULONG SmbPseTxeField_##x##y = FIELD_OFFSET(SMB_TRANSACT_EXCHANGE,x.y);

DECLARE_FIELD_HLPR(RxContext);
DECLARE_FIELD_HLPR(ReferenceCount);
DECLARE_FIELD_HLPR(State);
DECLARE_FIELD_HLPR(pSendDataMdl);
DECLARE_FIELD_HLPR(pReceiveDataMdl);
DECLARE_FIELD_HLPR(pSendParamMdl);
DECLARE_FIELD_HLPR(pReceiveParamMdl);
DECLARE_FIELD_HLPR(pSendSetupMdl);
DECLARE_FIELD_HLPR(pReceiveSetupMdl);
DECLARE_FIELD_HLPR(PrimaryRequestSmbSize);
DECLARE_FIELD_HLPR(SmbCommand);
DECLARE_FIELD_HLPR(NtTransactFunction);
DECLARE_FIELD_HLPR(Flags);
DECLARE_FIELD_HLPR(Fid);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\vnrcntxt.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    smbcedb.c

Abstract:

    This module implements all functions related to accessing the SMB connection engine
    database

Notes:

    The mapping between MRX_V_NET_ROOT and a mini rdr data structure is a many to
    one relationship, i.e., more than one MRX_V_NET_ROOT instance can be associated with the
    same mini rdr data structure.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeCompleteVNetRootContextInitialization)
#pragma alloc_text(PAGE, SmbCeDestroyAssociatedVNetRootContext)
#pragma alloc_text(PAGE, SmbCeTearDownVNetRootContext)
#endif

RXDT_Extern(SMBCEDB);
#define Dbg        (DEBUG_TRACE_SMBCEDB)


NTSTATUS
SmbCeFindOrConstructVNetRootContext(
    PMRX_V_NET_ROOT         pVNetRoot,
    BOOLEAN                 fDeferNetworkInitialization)
/*++

Routine Description:

    This routine finds or constructs a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRoot - the MRX_V_NET_ROOT instance

    fDeferNetworkInitialization - a directive to delay network initialization for new
                                  instances.

Return Value:

    STATUS_SUCCESS if the MRX_V_NET_ROOT instance was successfully initialized

Notes:

    The algorithm that has been implemented tries to delay the construction of a
    new instance as much as possible. It does this be either reusing a context
    that has already been active or a context instance that has been marked for
    scavenging but has not been scavenged.

--*/
{
    NTSTATUS Status;

    PMRX_SRV_CALL pSrvCall;
    PMRX_NET_ROOT pNetRoot;

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;

    PSMBCEDB_SERVER_ENTRY   pServerEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry = NULL;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;

    BOOLEAN  fInitializeNetRoot;
    BOOLEAN  fDereferenceSessionEntry = FALSE;
    BOOLEAN  fDereferenceNetRootEntry = FALSE;

    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;

    SmbCeAcquireResource();

    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    // The V_NET_ROOT is associated with a NET_ROOT. The two cases of interest are as
    // follows
    // 1) the V_NET_ROOT and the associated NET_ROOT are being newly created.
    // 2) a new V_NET_ROOT associated with an existing NET_ROOT is being created.
    //
    // These two cases can be distinguished by checking if the context associated with
    // NET_ROOT is NULL. Since the construction of NET_ROOT's/V_NET_ROOT's are serialized
    // by the wrapper this is a safe check.
    // ( The wrapper cannot have more then one thread tryingto initialize the same
    // NET_ROOT).

    pNetRootEntry = (PSMBCEDB_NET_ROOT_ENTRY)pNetRoot->Context;
    fInitializeNetRoot = (pNetRootEntry == NULL);

    pVNetRoot->Context = NULL;

    // Find or construct the session entry that will be associated with the context. The
    // one error that deserves special consideration is STATUS_NETWORK_CREDENTIAL_CONFLICT.
    // This error signifies that the credentials presented with the MRX_V_NET_ROOT instance
    // conflicted with an existing session. This conflict could be either becuase there
    // exists an active session or because a previously active session is awaiting
    // scavenging. In the former case the error needs to be propagated back but in the
    // later case the contexts must be selectively scavenged.
    //
    // The scavenging should be limited only to those contexts to the appropriate server.

    Status = SmbCeFindOrConstructSessionEntry(
                 pVNetRoot,
                 &pSessionEntry);


    if (Status == STATUS_NETWORK_CREDENTIAL_CONFLICT) {
        NTSTATUS ScavengingStatus;

        SmbCeReleaseResource();

        ScavengingStatus = SmbCeScavengeRelatedContexts(pServerEntry);

        if (ScavengingStatus == STATUS_SUCCESS) {
            SmbCeAcquireResource();

            Status = SmbCeFindOrConstructSessionEntry(
                         pVNetRoot,
                         &pSessionEntry);
        } else {
            return Status;
        }
    }

    fDereferenceSessionEntry = (Status == STATUS_SUCCESS);

    if (Status == STATUS_SUCCESS) {
        if (fInitializeNetRoot) {
            pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;

            // Initialize the device type and state for a new MRX_NET_ROOT instance
            switch (pNetRoot->Type) {
            case NET_ROOT_DISK:
               {
                   pNetRoot->DeviceType = RxDeviceType(DISK);

                   RxInitializeNetRootThrottlingParameters(
                       &pNetRoot->DiskParameters.LockThrottlingParameters,
                       MRxSmbConfiguration.LockIncrement,
                       MRxSmbConfiguration.MaximumLock
                       );
               }
               break;

            case NET_ROOT_PIPE:
               pNetRoot->DeviceType = RxDeviceType(NAMED_PIPE);
               break;
            case NET_ROOT_COMM:
               pNetRoot->DeviceType = RxDeviceType(SERIAL_PORT);
               break;
            case NET_ROOT_PRINT:
               pNetRoot->DeviceType = RxDeviceType(PRINTER);
               break;
            case NET_ROOT_MAILSLOT:
               pNetRoot->DeviceType = RxDeviceType(MAILSLOT);
               break;
            case NET_ROOT_WILD:
               break;
            default:
               ASSERT(!"Valid Net Root Type");
            }

            Status = SmbCeFindOrConstructNetRootEntry(
                         pNetRoot,
                         &pNetRootEntry);

            RxDbgTrace( 0, Dbg, ("SmbCeOpenNetRoot %lx\n",Status));
        } else {
            SmbCeLog(("ReuseNREntry %lx\n",pNetRootEntry));
            SmbCeReferenceNetRootEntry(pNetRootEntry);
        }

        fDereferenceNetRootEntry = (Status == STATUS_SUCCESS);
    }

    if (Status == STATUS_SUCCESS) {
        PSMBCE_V_NET_ROOT_CONTEXTS pVNetRootContexts;

        // Search through the list of contexts marked for scavenging to determine
        // if a context instance can be reused.

        pVNetRootContexts = &MRxSmbScavengerServiceContext.VNetRootContexts;

        pVNetRootContext = SmbCeGetFirstVNetRootContext(
                                pVNetRootContexts);

        while (pVNetRootContext != NULL) {
            pVNetRootContext = SmbCeGetNextVNetRootContext(
                                   pVNetRootContexts,
                                   pVNetRootContext);
        }
        if (pVNetRootContext != NULL) {
            // An existing instance can be reused. No more work to be done
            SmbCeReferenceVNetRootContext(pVNetRootContext);
        } else {
            // None of the existing instances can be reused. A new instance needs to be
            // constructed.

            pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)
                               RxAllocatePoolWithTag(
                                    NonPagedPool,
                                    sizeof(SMBCE_V_NET_ROOT_CONTEXT),
                                    MRXSMB_VNETROOT_POOLTAG);

            if (pVNetRootContext != NULL) {
                // Initialize the new instance

                RtlZeroMemory(
                    pVNetRootContext,
                    sizeof(SMBCE_V_NET_ROOT_CONTEXT));

                // Transfer the references made during the construction of the session and
                // the net root entries to the new context. Disable the dereferencing at
                // the end of this routine.

                fDereferenceSessionEntry = FALSE;
                fDereferenceNetRootEntry = FALSE;

                SmbCeReferenceServerEntry(pServerEntry);

                pVNetRootContext->Header.NodeType = SMB_CONNECTION_ENGINE_NTC(
                                                        SMBCEDB_OT_VNETROOTCONTEXT);

                pVNetRootContext->Header.State = SMBCEDB_INVALID;
                pVNetRootContext->Flags = 0;

                InitializeListHead(&pVNetRootContext->Requests.ListHead);

                pVNetRootContext->pServerEntry  = pServerEntry;
                pVNetRootContext->pSessionEntry = pSessionEntry;
                pVNetRootContext->pNetRootEntry = pNetRootEntry;

                SmbCeReferenceVNetRootContext(pVNetRootContext);

                // Add it to the list of active contexts
                SmbCeAddVNetRootContext(
                    &pServerEntry->VNetRootContexts,
                    pVNetRootContext);

                SmbCeLog(("NewVNetRootContext %lx\n",pVNetRootContext));
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (Status == STATUS_SUCCESS) {
        // If everything was successful set up the MRX_V_NET_ROOT and MRX_NET_ROOT
        // instances
        pVNetRoot->Context = pVNetRootContext;
        pVNetRootContext->pRdbssVNetRoot = pVNetRoot;

        if (fInitializeNetRoot) {
            ASSERT(pNetRootEntry->pRdbssNetRoot == NULL);

            InterlockedExchangePointer(
                &pNetRootEntry->pRdbssNetRoot,
                pNetRoot);

            SmbCeUpdateNetRoot(pNetRootEntry,pNetRoot);

            SmbCeReferenceNetRootEntry(pNetRootEntry);
            pNetRoot->Context = pNetRootEntry;
        } else {
            if (FlagOn(pNetRoot->Flags,NETROOT_FLAG_FINALIZE_INVOKED)) {
                ClearFlag(pNetRoot->Flags,NETROOT_FLAG_FINALIZE_INVOKED);
                SmbCeReferenceNetRootEntry(pNetRootEntry);
            }
        }

        if (!pVNetRootContext->NumberOfActiveVNetRootIncremented) {
            InterlockedIncrement(&pSessionEntry->Session.NumberOfActiveVNetRoot);
            pVNetRootContext->NumberOfActiveVNetRootIncremented = TRUE;
        }
    } else {
        pVNetRoot->Context = NULL;
        if (fInitializeNetRoot) {
            pNetRoot->Context  = NULL;
        }
    }

    SmbCeReleaseResource();

    if (fDereferenceSessionEntry) {
        SmbCeDereferenceSessionEntry(pSessionEntry);
    }

    if (fDereferenceNetRootEntry) {
        SmbCeDereferenceNetRootEntry(pNetRootEntry);
    }

    if (!fDeferNetworkInitialization &&
        (Status == STATUS_SUCCESS)) {

        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER) {
        ASSERT((Status != STATUS_SUCCESS) || (pVNetRoot->Context != NULL));
    }

    return Status;
}

VOID
SmbCeCompleteVNetRootContextInitialization(
    PVOID  pContext)
/*++

Routine Description:

    This routine is invoked in the context of a worker thread to finalize the
    construction of a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pContext  - the SMBCE_V_NET_ROOT_CONTEXT instance


Notes:

    PRE_CONDITION: The VNetRootContext must have been referenced to ensure that
    even it has been finalized it will not be deleted.

--*/
{
    NTSTATUS Status;

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    PSMBCEDB_REQUEST_ENTRY    pRequestEntry;
    SMBCEDB_REQUESTS          Requests;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("Net Root Entry Finalization\n"));

    pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)pContext;

    ASSERT(pVNetRootContext->Header.ObjectType == SMBCEDB_OT_VNETROOTCONTEXT);

    SmbCeAcquireResource();

    pVNetRootContext->pExchange = NULL;

    SmbCeTransferRequests(&Requests,&pVNetRootContext->Requests);

    if (pVNetRootContext->Header.State == SMBCEDB_ACTIVE) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INVALID_CONNECTION;
        SmbCeUpdateVNetRootContextState(
            pVNetRootContext,
            SMBCEDB_INVALID);
    }

    SmbCeReleaseResource();

    // Iterate over the list of pending requests and resume all of them
    SmbCeResumeOutstandingRequests(&Requests,Status);

    SmbCeDereferenceVNetRootContext(pVNetRootContext);
}

VOID
SmbCepDereferenceVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext)
/*++

Routine Description:

    This routine dereferences a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRootContext  - the SMBCE_V_NET_ROOT_CONTEXT instance

Notes:

    There are two intersting points to note. A mini redirector can avoid potential
    network traffic by delaying the scavenging of the SMBCE_V_NET_ROOT_CONTEXT
    instance since it contains all the relevant network setup to satisfy requests.

    This is a policy that is implemented in the mini redirector and is different from
    the wrapper policies.

    Once the decision to delay scavenging has been made, there are two options. The
    successful and unsuccessful instances can be delayed or only the successful
    instances. The current algorithm is to delay the scavenging of the successful
    SMBCE_V_NET_ROOT_CONTEXT instances only.

    Also there are three components to a VNetRootContext that can be scavenged
    independently. If the server exists and a session setup to the server fails
    because of wrong credentials there is no point in throwing away the server
    entry eagerly. This routine selectively gathers the failed fields for eager
    scavenging and retains the VNetRootContext skeleton alongwith the other
    structures that can be deferred.

--*/
{
    if (pVNetRootContext != NULL) {
        LONG FinalRefCount;

        MRXSMB_PRINT_REF_COUNT(VNETROOT_CONTEXT,pVNetRootContext->Header.SwizzleCount);

        FinalRefCount = InterlockedDecrement(
                            &pVNetRootContext->Header.SwizzleCount);

        if (FinalRefCount == 0) {
            LARGE_INTEGER CurrentTime;
            BOOLEAN       TearDownVNetRootContext = FALSE;

            PSMBCE_SERVER           pServer = &pVNetRootContext->pServerEntry->Server;
            PSMBCE_SESSION          pSession = &pVNetRootContext->pSessionEntry->Session;

            SmbCeAcquireResource();

            if (pVNetRootContext->Header.SwizzleCount == 0) {
                // Remove the instance from the active list of contexts to the server.
                SmbCeRemoveVNetRootContext(
                    &pVNetRootContext->pSessionEntry->pServerEntry->VNetRootContexts,
                    pVNetRootContext);

                // if it was a successful instance mark it for scavenging, otherwise
                // tear it down immediately

                if ((pVNetRootContext->pSessionEntry != NULL) &&
                    (pVNetRootContext->pSessionEntry->Header.State != SMBCEDB_ACTIVE ||
                     pSession->pUserName != NULL ||
                     pSession->pPassword != NULL ||
                     pSession->pUserDomainName != NULL)) {
                    TearDownVNetRootContext = TRUE;
                }

                if ((pVNetRootContext->pNetRootEntry != NULL) &&
                    (pVNetRootContext->pNetRootEntry->Header.State != SMBCEDB_ACTIVE ||
                     TearDownVNetRootContext)) {
                    TearDownVNetRootContext = TRUE;
                }

                InterlockedIncrement(&pServer->NumberOfVNetRootContextsForScavenging);

                if (!TearDownVNetRootContext &&
                    (pVNetRootContext->pNetRootEntry != NULL) &&
                    (pVNetRootContext->pSessionEntry != NULL) &&
                    pServer->NumberOfVNetRootContextsForScavenging < MaximumNumberOfVNetRootContextsForScavenging) {

                    KeQueryTickCount( &CurrentTime );

                    pVNetRootContext->ExpireTime.QuadPart = CurrentTime.QuadPart +
                        (LONGLONG) ((MRXSMB_V_NETROOT_CONTEXT_SCAVENGER_INTERVAL * 10 * 1000 * 1000) / KeQueryTimeIncrement());

                    SmbCeAddVNetRootContext(
                        &MRxSmbScavengerServiceContext.VNetRootContexts,
                        pVNetRootContext);

                    MRxSmbActivateRecurrentService(
                        (PRECURRENT_SERVICE_CONTEXT)&MRxSmbScavengerServiceContext);

                    SmbCeLog(("ScavngVNetRootCntxt %lx\n",pVNetRootContext));
                } else {
                    TearDownVNetRootContext = TRUE;
                }
            }

            SmbCeReleaseResource();

            if (TearDownVNetRootContext) {
                pVNetRootContext->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                SmbCeTearDownVNetRootContext(pVNetRootContext);
            }
        }
    }
}

NTSTATUS
SmbCeDestroyAssociatedVNetRootContext(
    PMRX_V_NET_ROOT pVNetRoot)
/*++

Routine Description:

    This routine derferences a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRootContext - the SMBCE_V_NET_ROOT_CONTEXT instance to be dereferenced

--*/
{
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    PAGED_CODE();

    pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)pVNetRoot->Context;

    if (pVNetRootContext != NULL) {
        pVNetRootContext->pRdbssVNetRoot = NULL;

        SmbCeDereferenceVNetRootContext(pVNetRootContext);
    }

    pVNetRoot->Context = NULL;


    return STATUS_SUCCESS;
}

VOID
SmbCeTearDownVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext)
/*++

Routine Description:

    This routine tears down a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRootContext - the SMBCE_V_NET_ROOT_CONTEXT instance to be torn down

--*/
{
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    PAGED_CODE();

    SmbCeLog(("TearVNetRootContext %lx\n",pVNetRootContext));

    pNetRootEntry = pVNetRootContext->pNetRootEntry;

    if ((pNetRootEntry != NULL) &&
        BooleanFlagOn(pVNetRootContext->Flags,SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID) &&
        (SmbCeGetServerType(pVNetRootContext->pServerEntry) == SMBCEDB_FILE_SERVER)) {

        SmbCeDisconnect(pVNetRootContext);
    }

    if (pNetRootEntry != NULL) {
        pVNetRootContext->pNetRootEntry = NULL;
        SmbCeDereferenceNetRootEntry(pNetRootEntry);
    }

    if (pVNetRootContext->pSessionEntry != NULL) {
        SmbCeDecrementNumberOfActiveVNetRootOnSession(pVNetRootContext);
        SmbCeDereferenceSessionEntry(pVNetRootContext->pSessionEntry);
    }

    InterlockedDecrement(&pVNetRootContext->pServerEntry->Server.NumberOfVNetRootContextsForScavenging);

    SmbCeDereferenceServerEntry(pVNetRootContext->pServerEntry);

    RxFreePool(pVNetRootContext);
}

NTSTATUS
SmbCeScavenger(
    PVOID pContext)
/*++

Routine Description:

    This routine scavenges SMBCE_V_NET_ROOT_CONTEXT instances

Arguments:

    pContext - the scavenger service context

Notes:

    Since the contexts for scavenging are threaded together in an entry that
    is managed in a FIFO fashion, if the first entry fails the time interval
    test ( expiry time has not elapsed ) all the other entries in the list
    are guaranteed to fail the test. This is an important property that eases
    the implementation of scavenging.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext;
    LARGE_INTEGER             CurrentTime;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    BOOLEAN                   fTerminateScavenging = FALSE;

    pScavengerServiceContext = (PMRXSMB_SCAVENGER_SERVICE_CONTEXT)pContext;

    do {

        SmbCeAcquireResource();

        KeQueryTickCount( &CurrentTime );

        pVNetRootContext = SmbCeGetFirstVNetRootContext(
                               &pScavengerServiceContext->VNetRootContexts);

        fTerminateScavenging = (pVNetRootContext == NULL);

        if (!fTerminateScavenging) {
            if ((CurrentTime.QuadPart >= pVNetRootContext->ExpireTime.QuadPart) ||
                (pScavengerServiceContext->RecurrentServiceContext.State == RECURRENT_SERVICE_SHUTDOWN)) {
                SmbCeRemoveVNetRootContext(
                    &pScavengerServiceContext->VNetRootContexts,
                    pVNetRootContext);
            } else {
                fTerminateScavenging = TRUE;
            }
        }

        SmbCeReleaseResource();

        if (!fTerminateScavenging &&
            (pVNetRootContext != NULL)) {
            SmbCeTearDownVNetRootContext(pVNetRootContext);
        }
    } while (!fTerminateScavenging);

    return Status;
}

NTSTATUS
SmbCeScavengeRelatedContexts(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine scavenges SMBCE_V_NET_ROOT_CONTEXT instances for a given
    server entry

Arguments:

    pServerEntry - the server entry

Notes:

--*/
{
    NTSTATUS Status;
    SMBCE_V_NET_ROOT_CONTEXTS VNetRootContexts;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    InitializeListHead(&VNetRootContexts.ListHead);

    SmbCeAcquireResource();

    pVNetRootContext = SmbCeGetFirstVNetRootContext(
                           &MRxSmbScavengerServiceContext.VNetRootContexts);
    while (pVNetRootContext != NULL) {
        PSMBCE_V_NET_ROOT_CONTEXT pNextVNetRootContext;


        pNextVNetRootContext = SmbCeGetNextVNetRootContext(
                                   &MRxSmbScavengerServiceContext.VNetRootContexts,
                                   pVNetRootContext);

        if (pVNetRootContext->pServerEntry == pServerEntry) {
            SmbCeRemoveVNetRootContext(
                &MRxScavengerServiceContext.VNetRootContexts,
                pVNetRootContext);

            SmbCeAddVNetRootContext(
                &VNetRootContexts,
                pVNetRootContext);
        }

        pVNetRootContext = pNextVNetRootContext;
    }

    SmbCeReleaseResource();

    pVNetRootContext = SmbCeGetFirstVNetRootContext(
                           &VNetRootContexts);

    if (pVNetRootContext != NULL) {
        do {
            SmbCeRemoveVNetRootContext(
                &VNetRootContexts,
                pVNetRootContext);

            SmbCeTearDownVNetRootContext(pVNetRootContext);

            pVNetRootContext = SmbCeGetFirstVNetRootContext(
                                   &VNetRootContexts);
        } while ( pVNetRootContext != NULL );

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    SmbCeLog(("Scavctxts Srv %lx Status %lx\n",pServerEntry,Status));

    return Status;
}

VOID
SmbCeDecrementNumberOfActiveVNetRootOnSession(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext
    )
{
    ULONG   NumberOfVNetRoot;
    BOOLEAN fLogOffRequired = FALSE;

    PSMBCEDB_SERVER_ENTRY  pServerEntry = NULL;
    PSMBCEDB_SESSION_ENTRY pSessionEntry = NULL;

    SmbCeAcquireResource();

    if (pVNetRootContext->NumberOfActiveVNetRootIncremented) {
        pVNetRootContext->NumberOfActiveVNetRootIncremented = FALSE;

        NumberOfVNetRoot = InterlockedDecrement(&pVNetRootContext->pSessionEntry->Session.NumberOfActiveVNetRoot);

        if (NumberOfVNetRoot == 0) {
            pSessionEntry = pVNetRootContext->pSessionEntry;
            pServerEntry  = pVNetRootContext->pServerEntry;

            pSessionEntry->Session.Flags |= SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION;

            if (!FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {
                SmbCeRemoveSessionEntry(pServerEntry,pSessionEntry);
                SmbCeRemoveDefaultSessionEntry(pSessionEntry);

                InterlockedDecrement(
                    &pServerEntry->Server.NumberOfActiveSessions);
            }

            if ((pSessionEntry->Session.UserId != (SMB_USER_ID)(SMBCE_SHARE_LEVEL_SERVER_USERID)) &&
                (pSessionEntry->Session.UserId != 0) &&
                !FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {
                SmbCeReferenceServerEntry(pServerEntry);
                SmbCeReferenceSessionEntry(pSessionEntry);
                fLogOffRequired = TRUE;
            }

            pSessionEntry->Session.Flags |= SMBCE_SESSION_FLAGS_LOGGED_OFF;
        }
    }

    SmbCeReleaseResource();

    if (fLogOffRequired) {
        SmbCeLogOff(pServerEntry,pSessionEntry);

        SmbCeDereferenceServerEntry(pServerEntry);
    }
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\vcsndrcv.h ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    vcsndrcv.h

Abstract:

    This is the include file that defines all constants and types for VC
    (Virtual Circuit) related Send/Receive/INitialization etc.

Notes:

--*/

#ifndef _VCSNDRCV_H_
#define _VCSNDRCV_H_

// The connection oriented transport to a server can utilize multiple VC's to
// acheive better throughput to a server. It is for this reason that the
// VC transport data structure is built around multiple VC's. Howvever this
// feature is not utilized currently.
//
// Though the SMB protocol permits multiple number of VC's to be associated with
// a particular connection to a share, the data transfer of data is done in the
// raw mode. In this mode of operation the SMB protocol does not permit multiple
// outstanding requests. In the SMB protocol a number of requests can be multiplexed
// along a connection to the server There are certain kind of requests which can
// be completed on the client, i.e., no acknowledgement is neither expected nor
// received. In these cases the send call is completed synchronoulsy. On the
// other hand there is a second class of sends which cannot be resumed locally
// till the appropriate acknowledgement is recieved from the server. In such
// cases a list of requests is built up with each VC. On receipt of the appropriate
// acknowledgement these requests are resumed.
//

typedef enum _SMBCE_VC_STATE_ {
    SMBCE_VC_STATE_MULTIPLEXED,
    SMBCE_VC_STATE_RAW,
    SMBCE_VC_STATE_DISCONNECTED,
} SMBCE_VC_STATE, *PSMBCE_VC_STATE;

typedef struct _SMBCE_VC {
    SMBCE_OBJECT_HEADER;                // the struct header

    RXCE_VC     RxCeVc;

    NTSTATUS    Status;      // Status of the VC.
} SMBCE_VC, *PSMBCE_VC;

typedef struct SMBCE_SERVER_VC_TRANSPORT {
    SMBCE_SERVER_TRANSPORT;     // Anonymous struct for common fields

    RXCE_CONNECTION RxCeConnection;     // the connection handle
    LARGE_INTEGER   Delay;           // the estimated delay on the connection
    ULONG           MaximumNumberOfVCs;

    SMBCE_VC                    Vcs[1];          // Vcs associated with the connection.
} SMBCE_SERVER_VC_TRANSPORT, *PSMBCE_SERVER_VC_TRANSPORT;


#define VctReferenceVc(pVc)                           \
            InterlockedIncrement(&(pVc)->SwizzleCount)

#define VctReferenceVcLite(pVc)                       \
            ASSERT(SmbCeSpinLockAcquired());                    \
            (pVc)->SwizzleCount++


#define VctDereferenceVc(pVc)                           \
            InterlockedDecrement(&(pVc)->SwizzleCount)

#define VctDereferenceVcLite(pVc)                       \
            ASSERT(SmbCeSpinLockAcquired());                    \
            (pVc)->SwizzleCount--

#endif // _VCSNDRCV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\write.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the mini redirector call down routines pertaining
    to write of file system objects.

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbWrite)
#pragma alloc_text(PAGE, MRxSmbBuildWriteRequest)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Write)
#pragma alloc_text(PAGE, MRxSmbFinishWrite)
#endif

#define MAX(a,b) ((a) > (b) ? (a) : (b))

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

#ifndef FORCE_NO_NTWRITEANDX
#define MRxSmbForceNoNtWriteAndX FALSE
#else
BOOLEAN MRxSmbForceNoNtWriteAndX = TRUE;
#endif

#define WRITE_COPY_THRESHOLD 64
#define FORCECOPYMODE FALSE

#ifdef SETFORCECOPYMODE
#undef  FORCECOPYMODE
#define FORCECOPYMODE MRxSmbForceCopyMode
ULONG MRxSmbForceCopyMode = TRUE;
#endif

NTSTATUS
SmbPseExchangeStart_Write(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

ULONG MRxSmbWriteSendOptions = 0;

NTSTATUS
MRxSmbWrite (
    IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine opens a file across the network.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    
    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbWrite\n", 0 ));

    if (RxContext->pFcb->pNetRoot->Type == NET_ROOT_PIPE) {
        Status = STATUS_NOT_SUPPORTED;

        RxDbgTrace(-1, Dbg, ("MRxSmbWrite: Pipe write returned %lx\n",Status));
        return Status;
    }

    if ( NodeType(capFcb) == RDBSS_NTC_MAILSLOT ) {

        Status = STATUS_NOT_SUPPORTED;

        RxDbgTrace(-1, Dbg, ("MRxSmbWrite: Mailslot write returned %lx\n",Status));
        return Status;
    }

    if(NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE) {
        PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
        smbFcb->MFlags |= SMB_FCB_FLAG_WRITES_PERFORMED;
    }

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    SrvOpen = capFobx->pSrvOpen;
    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    if (smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_II &&
        !BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,
                       LOWIO_READWRITEFLAG_PAGING_IO)) {
        PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
        PMRX_SRV_CALL             pSrvCall;

        pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;
        pSrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;

        RxIndicateChangeOfBufferingStateForSrvOpen(
            pSrvCall,
            SrvOpen,
            MRxSmbMakeSrvOpenKey(pVNetRootContext->TreeId,smbSrvOpen->Fid),
            ULongToPtr(SMB_OPLOCK_LEVEL_NONE));
        SmbCeLog(("Breaking oplock to None in Write SO %lx\n",SrvOpen));
    }

    do {
        Status = __SmbPseCreateOrdinaryExchange(
                               RxContext,
                               capFobx->pSrvOpen->pVNetRoot,
                               SMBPSE_OE_FROM_WRITE,
                               SmbPseExchangeStart_Write,
                               &OrdinaryExchange);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));

            return Status;
        }

        Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

        if ( Status != STATUS_PENDING ) {
            BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            ASSERT( FinalizationComplete );
        } else {
            ASSERT(BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
        }

        if ((Status == STATUS_RETRY) &&
            BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
            MRxSmbResumeAsyncReadWriteRequests(RxContext);
            Status = STATUS_PENDING;
        }
    } while (Status == STATUS_RETRY);


    RxDbgTrace(-1, Dbg, ("MRxSmbWrite  exit with status=%08lx\n", Status ));

    return(Status);
} // MRxSmbWrite


NTSTATUS
MRxSmbBuildWriteRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    BOOLEAN                    IsPagingIo,
    UCHAR                      WriteCommand,
    ULONG                      ByteCount,
    PLARGE_INTEGER             ByteOffsetAsLI,
    PBYTE                      Buffer,
    PMDL                       BufferAsMdl)
/*++

Routine Description:

    This is the start routine for write.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PRX_CONTEXT RxContext = StufferState->RxContext;

    RxCaptureFcb;
    RxCaptureFobx;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    ULONG OffsetLow,OffsetHigh;

    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    USHORT  WriteMode = 0;
    ULONG   DataLengthLow,DataLengthHigh;
    ULONG   BytesRemaining = 0;
    BOOLEAN AddLengthBytes = FALSE;
    ULONG   WriteCommandSize;

    PSMBCE_SERVER pServer = SmbCeGetExchangeServer((PSMB_EXCHANGE)OrdinaryExchange);
    BOOLEAN UseNtVersion;

    UseNtVersion = BooleanFlagOn(pServer->DialectFlags,DF_NT_SMBS) &&
                   !MRxSmbForceNoNtWriteAndX;

    // The data length field in SMB is a USHORT, and hence the data length given
    // needs to be split up into two parts -- DataLengthHigh and DataLengthLow
    DataLengthLow  = (ByteCount & 0xffff);
    DataLengthHigh = ((ByteCount & 0xffff0000) >> 16);

    OffsetLow  = ByteOffsetAsLI->LowPart;
    OffsetHigh = ByteOffsetAsLI->HighPart;

    switch (WriteCommand) {
    case SMB_COM_WRITE_ANDX:
        WriteCommandSize = SMB_REQUEST_SIZE(NT_WRITE_ANDX);
        break;
    case SMB_COM_WRITE:
        WriteCommandSize = SMB_REQUEST_SIZE(WRITE);
        break;
    case SMB_COM_WRITE_PRINT_FILE:
        WriteCommandSize = SMB_REQUEST_SIZE(WRITE_PRINT_FILE);
        break;
    }

    Status = MRxSmbStartSMBCommand(
                 StufferState,
                 SetInitialSMB_Never,
                 WriteCommand,
                 WriteCommandSize,
                 NO_EXTRA_DATA,
                 NO_SPECIAL_ALIGNMENT,
                 RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                 0,0,0,0 STUFFERTRACE(Dbg,'FC'));

    MRxSmbDumpStufferState(
        1000,
        "SMB Write Request before stuffing",
        StufferState);

    switch (WriteCommand) {
    case SMB_COM_WRITE_ANDX :
        {
            if ( UseNtVersion && IsPagingIo ) {
                SmbPutAlignedUshort(
                    &NtSmbHeader->Flags2,
                    SmbGetAlignedUshort(&NtSmbHeader->Flags2)|SMB_FLAGS2_PAGING_IO );
            }

            //
            //  If the file object was opened in write through mode, set write
            //  through on the write operation.
            if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WRITE_THROUGH)) {
                WriteMode |= SMB_WMODE_WRITE_THROUGH;
            }

            MRxSmbStuffSMB (
                StufferState,
                "XwddwwwwQ",
                                                  //  X UCHAR WordCount;
                                                  //    UCHAR AndXCommand;
                                                  //    UCHAR AndXReserved;
                                                  //    _USHORT( AndXOffset );
                smbSrvOpen->Fid,                  //  w _USHORT( Fid );
                OffsetLow,                        //  d _ULONG( Offset );
                -1,                               //  d _ULONG( Timeout );
                WriteMode,                        //  w _USHORT( WriteMode );
                BytesRemaining,                   //  w _USHORT( Remaining );
                DataLengthHigh,                   //  w _USHORT( DataLengthHigh );
                DataLengthLow,                    //  w _USHORT( DataLength );
                                                  //  Q _USHORT( DataOffset );
                SMB_OFFSET_CHECK(WRITE_ANDX,DataOffset)
                StufferCondition(UseNtVersion), "D",
                SMB_OFFSET_CHECK(NT_WRITE_ANDX,OffsetHigh)
                OffsetHigh,                       //  D NTonly  _ULONG( OffsetHigh );
                                                  //
                STUFFER_CTL_NORMAL, "BS5",
                                                  //  B _USHORT( ByteCount );
                SMB_WCT_CHECK(((UseNtVersion)?14:12))
                                                  //    UCHAR Buffer[1];
                                                  //  S //UCHAR Pad[];
                                                  //  5 //UCHAR Data[];
                StufferCondition(AddLengthBytes), "w", LowIoContext->ParamsFor.ReadWrite.ByteCount,
                StufferCondition(Buffer!=NULL), "c!",
                ByteCount,
                Buffer,                           //  c the actual data
                0
                );
        }
        break;

    case SMB_COM_WRITE :
        {
            MRxSmbStuffSMB (
                StufferState,
                "0wwdwByw",
                                       //  0   UCHAR WordCount;                    // Count of parameter words = 5
                smbSrvOpen->Fid,       //  w   _USHORT( Fid );                     // File handle
                DataLengthLow,         //  w   _USHORT( Count );                   // Number of bytes to be written
                OffsetLow,             //  d   _ULONG( Offset );                   // Offset in file to begin write
                BytesRemaining,        //  w   _USHORT( Remaining );               // Bytes remaining to satisfy request
                SMB_WCT_CHECK(5)       //  B   _USHORT( ByteCount );               // Count of data bytes
                                            //      //UCHAR Buffer[1];                  // Buffer containing:
                0x01,                  //  y     UCHAR BufferFormat;               //  0x01 -- Data block
                DataLengthLow,            //  w     _USHORT( DataLength );            //  Length of data
                                       //        ULONG Buffer[1];                  //  Data
                StufferCondition(Buffer!=NULL), "c!",
                ByteCount,
                Buffer,     //  c     the actual data
                0
                );
        }
        break;

    case SMB_COM_WRITE_PRINT_FILE:
        {
            MRxSmbStuffSMB (
                StufferState,
                "0wByw",
                                       // 0  UCHAR WordCount;                    // Count of parameter words = 1
                smbSrvOpen->Fid,       // w  _USHORT( Fid );                     // File handle
                SMB_WCT_CHECK(1)       // B  _USHORT( ByteCount );               // Count of data bytes; min = 4
                                            //    UCHAR Buffer[1];                    // Buffer containing:
                0x01,                  // y  //UCHAR BufferFormat;               //  0x01 -- Data block
                DataLengthLow,         // w  //USHORT DataLength;                //  Length of data
                                            //    //UCHAR Data[];                     //  Data
                StufferCondition(Buffer!=NULL), "c!",
                ByteCount,
                Buffer,     //  c     the actual data
                0
                );
        }
        break;

    default:
        Status = STATUS_UNSUCCESSFUL ;
        break;
    }

    if ( BufferAsMdl ) {
        MRxSmbStuffAppendRawData( StufferState, BufferAsMdl );
        MRxSmbStuffSetByteCount( StufferState );
    }

    MRxSmbDumpStufferState(
        700,
        "SMB Write Request after stuffing",
        StufferState);

    if (Status==STATUS_SUCCESS) {
        InterlockedIncrement(&MRxSmbStatistics.SmallWriteSmbs);
    }

    return Status;
}

BOOLEAN DisableLargeWrites = 0;

NTSTATUS
SmbPseExchangeStart_Write (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for write.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    ULONG StartEntryCount;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PMDL OriginalDataMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FCB  SmbFcb = MRxSmbGetFcbExtension(capFcb);

    BOOLEAN SynchronousIo, IsPagingIo;
    BOOLEAN WriteToTheEnd = FALSE;
    UCHAR   WriteCommand;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Write\n"));

    ASSERT( OrdinaryExchange->Type == ORDINARY_EXCHANGE );

    ASSERT(
        (
            (OriginalDataMdl!=NULL) &&
            (
                RxMdlIsLocked(OriginalDataMdl) ||
                RxMdlSourceIsNonPaged(OriginalDataMdl)
            )
        ) ||
        (
            (OriginalDataMdl==NULL) &&
            (LowIoContext->ParamsFor.ReadWrite.ByteCount==0)
        )
        );

    ASSERT((OrdinaryExchange->SmbCeFlags&SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) == 0 );

    OrdinaryExchange->StartEntryCount++;
    StartEntryCount = OrdinaryExchange->StartEntryCount;

    SynchronousIo = !BooleanFlagOn(
                        RxContext->Flags,
                        RX_CONTEXT_FLAG_ASYNC_OPERATION);

    IsPagingIo = BooleanFlagOn(
                     LowIoContext->ParamsFor.ReadWrite.Flags,
                     LOWIO_READWRITEFLAG_PAGING_IO);

    // Ensure that the Fid is validated
    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

    for (;;) {
        PSMBCE_SERVER         pServer;
        PSMBCE_NET_ROOT       pNetRoot;

        pServer  = SmbCeGetExchangeServer(OrdinaryExchange);
        pNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);

        switch (OrdinaryExchange->OpSpecificState) {
        case SmbPseOEInnerIoStates_Initial:
            {
                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;

                if ( !SynchronousIo ) {
                    OrdinaryExchange->AsyncResumptionRoutine = SmbPseExchangeStart_Write;
                }

                MRxSmbSetInitialSMB( StufferState STUFFERTRACE(Dbg,'FC') );

                rw->UserBufferBase = RxLowIoGetBufferAddress( RxContext );
                rw->ByteOffsetAsLI.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
                rw->RemainingByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;

                if (rw->ByteOffsetAsLI.QuadPart == -1 ) {
                    WriteToTheEnd = TRUE;
                    rw->ByteOffsetAsLI.QuadPart = smbSrvOpen->FileInfo.Standard.EndOfFile.QuadPart;
                }

                if (OriginalDataMdl != NULL) {
                    rw->UserBufferBase = RxLowIoGetBufferAddress( RxContext );
                } else {
                    rw->UserBufferBase = (PBYTE)1;   //any nonzero value will do
                }

                rw->ThisBufferOffset = 0;

                rw->PartialExchangeMdlInUse = FALSE;
                rw->PartialDataMdlInUse     = FALSE;
            }
            //lack of break is intentional

        case SmbPseOEInnerIoStates_ReadyToSend:
            {
                ULONG MaximumBufferSizeThisIteration;
                PCHAR Buffer = NULL;
                PMDL  BufferAsMdl = NULL;

                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationOutstanding;
                OrdinaryExchange->SendOptions = MRxSmbWriteSendOptions;

                if (FlagOn(pServer->DialectFlags,DF_LANMAN10) &&
                    FlagOn(pServer->DialectFlags,DF_LARGE_FILES) &&
                    (StufferState->RxContext->pFcb->pNetRoot->Type != NET_ROOT_PRINT)) {
                    WriteCommand = SMB_COM_WRITE_ANDX;
                } else if (StufferState->RxContext->pFcb->pNetRoot->Type == NET_ROOT_PRINT){
                    WriteCommand = SMB_COM_WRITE_PRINT_FILE;
                } else {
                    WriteCommand = SMB_COM_WRITE;
                }

                MaximumBufferSizeThisIteration = pNetRoot->MaximumWriteBufferSize;

                // There are four parameters pertaining to a write request
                //
                //  1. Write Length -- rw->ThisByteCount
                //  2. Write Offset -- rw->ByteOffsetAsLI
                //  3. Write Buffer -- Buffer
                //  4. Write Buffer as a MDL -- BufferAsMdl
                //
                // All writes can be classified into one of the following
                // categories ...
                //
                //  1. Extremely Small writes
                //      These are writes lesser than the COPY_THRESHOLD or
                //      we are in a debug mode that forces us to do only small
                //      writes.
                //
                //  2. Write requests against downlevel servers or non disk
                //     file write requests against up level servers.
                //      In all these cases we are constrained by the Server
                //      which limits the number of bytes to roughly 4k. This
                //      is based upon the Smb Buffer size returned during
                //      negotiation.
                //
                //  3. Write requests against uplevel (NT5+)
                //     servers
                //      These write requests can be arbitrarily large
                //


                if ((rw->RemainingByteCount < WRITE_COPY_THRESHOLD) ||
                    FORCECOPYMODE) {
                    if (FORCECOPYMODE &&
                        (rw->ThisByteCount > MaximumBufferSizeThisIteration) ) {
                        rw->ThisByteCount = MaximumBufferSizeThisIteration;
                    } else {
                        rw->ThisByteCount = rw->RemainingByteCount;
                    }

                    Buffer = rw->UserBufferBase + rw->ThisBufferOffset;

                    ASSERT( WRITE_COPY_THRESHOLD <= pNetRoot->MaximumWriteBufferSize );
                } else {
                    rw->ThisByteCount = min(
                                            rw->RemainingByteCount,
                                            MaximumBufferSizeThisIteration);

                    if ((rw->ThisBufferOffset != 0) ||
                        (rw->ThisByteCount != OriginalDataMdl->ByteCount)) {
                        MmInitializeMdl(
                            &rw->PartialDataMdl,
                            0,
                            MAX_PARTIAL_DATA_MDL_BUFFER_SIZE);

                        IoBuildPartialMdl(
                            OriginalDataMdl,
                            &rw->PartialDataMdl,
                            (PCHAR)MmGetMdlVirtualAddress(OriginalDataMdl) +
                                rw->ThisBufferOffset,
                            rw->ThisByteCount );

                        BufferAsMdl = &rw->PartialDataMdl;
                    } else {
                        BufferAsMdl = OriginalDataMdl;
                    }
                }

                Status = MRxSmbBuildWriteRequest(
                             OrdinaryExchange,
                             IsPagingIo,
                             WriteCommand,
                             rw->ThisByteCount,
                             &rw->ByteOffsetAsLI,
                             Buffer,
                             BufferAsMdl);

                if (Status != STATUS_SUCCESS) {
                    RxDbgTrace(0, Dbg, ("bad write stuffer status........\n"));
                    goto FINALLY;
                }

                InterlockedIncrement(&MRxSmbStatistics.WriteSmbs);

                Status = SmbPseOrdinaryExchange(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             SMBPSE_OETYPE_WRITE );

                if ( Status == STATUS_PENDING) {
                    ASSERT( !SynchronousIo );
                    goto FINALLY;
                }
            }
            //lack of break is intentional

        case SmbPseOEInnerIoStates_OperationOutstanding:
        case SmbPseOEInnerIoStates_OperationCompleted:
            {
                SetFlag(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_SUBSEQUENT_OPERATION);

                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;

                if (rw->PartialExchangeMdlInUse) {
                    MmPrepareMdlForReuse(
                        &rw->PartialExchangeMdl);
                    rw->PartialDataMdlInUse = FALSE;
                }

                if (rw->PartialDataMdlInUse) {
                    MmPrepareMdlForReuse(
                        &rw->PartialDataMdl);
                    rw->PartialDataMdlInUse = FALSE;
                }

                Status = OrdinaryExchange->Status;

                if (Status == STATUS_SMB_USE_STANDARD) {
                    // Send the remaining data using Restart all over again and
                    rw->UserBufferBase = RxLowIoGetBufferAddress( RxContext );
                    rw->ByteOffsetAsLI.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
                    rw->RemainingByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;

                    if (rw->ByteOffsetAsLI.QuadPart == -1 ) {
                        WriteToTheEnd = TRUE;
                        rw->ByteOffsetAsLI.QuadPart = smbSrvOpen->FileInfo.Standard.EndOfFile.QuadPart;
                    }

                    rw->BytesReturned = 0;
                    rw->ThisByteCount = 0;
                    rw->ThisBufferOffset = 0;

                    RxContext->InformationToReturn = 0;

                    OrdinaryExchange->Status = STATUS_SUCCESS;
                    Status = STATUS_SUCCESS;
                }

                rw->RemainingByteCount -= rw->BytesReturned;
                RxContext->InformationToReturn += rw->BytesReturned;

                if (Status == STATUS_SUCCESS) {
                    rw->ByteOffsetAsLI.QuadPart += rw->BytesReturned;
                    rw->ThisBufferOffset += rw->BytesReturned;

                    if (WriteToTheEnd) {
                        smbSrvOpen->FileInfo.Standard.EndOfFile.QuadPart += rw->BytesReturned;
                    }
                }

                if ((Status != STATUS_SUCCESS) ||
                    (rw->RemainingByteCount == 0)) {
                    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(OrdinaryExchange);

                    RxDbgTrace(
                        0,
                        Dbg,
                        (
                         "OE %lx TBC %lx RBC %lx BR %lx TBO %lx\n",
                         OrdinaryExchange,rw->ThisByteCount,
                         rw->RemainingByteCount,
                         rw->BytesReturned,
                         rw->ThisBufferOffset )
                        );

                    RxDbgTrace(
                        0,
                        Dbg,
                        ("Bytes written %lx\n",
                         RxContext->InformationToReturn)
                        );

                    goto FINALLY;
                }

                RxDbgTrace(
                    0,
                    Dbg,
                    ( "Next Iteration OE %lx RBC %lx TBO %lx\n",
                      OrdinaryExchange,
                      rw->RemainingByteCount,
                      rw->ThisBufferOffset)
                    );

                RxDbgTrace(
                    0,
                    Dbg,
                    ("OE %lx TBC %lx, BR %lx\n",
                     OrdinaryExchange,
                     rw->ThisByteCount,
                     rw->BytesReturned));

                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
            }
            break;
        }
    }


FINALLY:
    if ( Status != STATUS_PENDING) {
        if (Status != STATUS_RETRY) {
            SmbPseAsyncCompletionIfNecessary(OrdinaryExchange,RxContext);
        }
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Write exit w %08lx\n", Status ));
    return Status;

} // SmbPseExchangeStart_Write


NTSTATUS
MRxSmbFinishWrite (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    IN      PBYTE                       ResponseBuffer
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the write response and finishes
    the write. Everything you need is locked down... so we can finish in the
    indication routine

Arguments:

    OrdinaryExchange - the exchange instance

    ResponseBuffer - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesReturned;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishWrite\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishWrite:");

    switch (OrdinaryExchange->LastSmbCommand) {
    case SMB_COM_WRITE_ANDX:
        {
            PSMBCE_SERVER    pServer;
            PSMBCE_NET_ROOT  pNetRoot;
            PRESP_WRITE_ANDX Response = (PRESP_WRITE_ANDX)ResponseBuffer;

            if (Response->WordCount != 6 ||
                SmbGetUshort(&Response->ByteCount) != 0) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            pServer = SmbCeGetExchangeServer((PSMB_EXCHANGE)OrdinaryExchange);
            pNetRoot = SmbCeGetExchangeNetRoot((PSMB_EXCHANGE)OrdinaryExchange);

            BytesReturned = SmbGetUshort( &Response->Count );

            if (FlagOn(pServer->DialectFlags,DF_LARGE_WRITEX)) {
                ULONG BytesReturnedHigh;

                BytesReturnedHigh = SmbGetUshort(&Response->CountHigh);

                BytesReturned = (BytesReturnedHigh << 16) | BytesReturned;
            }

            if ((OrdinaryExchange->Status == STATUS_SUCCESS) &&
                (OrdinaryExchange->ReadWrite.ThisByteCount > 2) &&
                (BytesReturned == 0)) {
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            //if we added 2 headerbytes then let's get rid of them......
            if ( FlagOn(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_REDUCE_RETURNCOUNT) ) {
                // BytesReturned -= sizeof(USHORT);
                ClearFlag(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_REDUCE_RETURNCOUNT);
            }
        }
        break;

    case SMB_COM_WRITE :
        {
            PRESP_WRITE  Response = (PRESP_WRITE)ResponseBuffer;

            if (Response->WordCount != 1 ||
                SmbGetUshort(&Response->ByteCount) != 0) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            BytesReturned = SmbGetUshort( &Response->Count );
        }
        break;

    case SMB_COM_WRITE_PRINT_FILE:
        {
            PRESP_WRITE_PRINT_FILE Response = (PRESP_WRITE_PRINT_FILE)ResponseBuffer;

            if (Response->WordCount != 0) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            //the response does not tell how many bytes were taken! get the byte count from the exchange
            BytesReturned = OrdinaryExchange->ReadWrite.ThisByteCount;
        }
        break;

    default :
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        break;
    }

    RxDbgTrace(0, Dbg, ("-->BytesReturned=%08lx\n", BytesReturned));

    OrdinaryExchange->ReadWrite.BytesReturned = BytesReturned;

    if (Status == STATUS_SUCCESS &&
        OrdinaryExchange->ReadWrite.ThisByteCount > 2 &&
        BytesReturned > OrdinaryExchange->ReadWrite.ThisByteCount) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishWrite   returning %08lx\n", Status ));

    return Status;
} // MRxSmbFinishWrite




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\local_nt.mrx\mrxlcl0.h ===
#define MINIRDR__NAME MrxLocal
#define ___MINIRDR_IMPORTS_NAME MRxLocalRxImports




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\local_nt.mrx\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the Nt Local Minirdr.

Author:

    Joe Linn [JoeLinn]    2-2-95

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include "NtDdNfs2.h"

RXSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MRxLocalUnload(
    IN PDRIVER_OBJECT DriverObject
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, MRxLocalUnload)
#endif


PDEVICE_OBJECT MRxLocalDeviceObject;

struct _MINIRDR_DISPATCH  MRxLocalDispatch;
PRDBSS_EXPORTS ___MINIRDR_IMPORTS_NAME;

//declare the shadow debugtrace controlpoints

RXDT_DefineCategory(CREATE);
RXDT_DefineCategory(CLEANUP);
RXDT_DefineCategory(READ);
RXDT_DefineCategory(WRITE);
RXDT_DefineCategory(LOCKCTRL);
RXDT_DefineCategory(DIRCTRL);
RXDT_DefineCategory(FILEINFO);
RXDT_DefineCategory(VOLINFO);
RXDT_DefineCategory(FLUSH);
RXDT_DefineCategory(PREFIX);
RXDT_DefineCategory(FCBSTRUCTS);
RXDT_DefineCategory(DISPATCH);


RXSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Rx file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    RXSTATUS Status;
    UNICODE_STRING UnicodeString;

    //DbgBreakPoint();

    // Get the data exports.....first thing!!!!
    //

    ___MINIRDR_IMPORTS_NAME = RxRegisterMinirdr('LCL ', &MRxLocalDispatch, NULL);

    // Create the device object.
    //

    //DbgBreakPoint();
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxLocalDriverEntry: DriverObject =%08lx\n", DriverObject ));
    RtlInitUnicodeString(&UnicodeString, DD_NTLOCAL_MINIRDR_DEVICE_NAME_U);

    Status = IoCreateDevice(DriverObject,
                            sizeof(MRXLOCAL_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT),
                            &UnicodeString,
                            FILE_DEVICE_NETWORK_FILE_SYSTEM,
                            FILE_REMOTE_DEVICE,
                            FALSE,
                            &MRxLocalDeviceObject);

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    //DbgBreakPoint();
    MRxLocalInitializeCalldownTable();

    KeInitializeSpinLock( &MrxLocalOplockSpinLock );

    //
    //  Setup Unload Routine

    DriverObject->DriverUnload = MRxLocalUnload;

    //
    //
    //  And return to our caller

    return( RxStatus(SUCCESS) );
}


//
//  Unload routine
//

VOID
MRxLocalUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the MRXLOCAL.

Arguments:

     DriverObject - pointer to the driver object for the MRXLOCAL

Return Value:

     None

--*/

{
    UNICODE_STRING LinkName;

    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxLocalUnload: DriverObject =%08lx\n", DriverObject ));
//    DbgBreakPoint();

    IoDeleteDevice((PDEVICE_OBJECT)MRxLocalDeviceObject);

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\local_nt.mrx\innerio.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    InnerIo.c

Abstract:

    This module implements the read, write, and lockctrl routines for the local minirdr
Author:

    Joe Linn      [JoeLinn]      11-Oct-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_INNERIO)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

#ifdef ALLOC_PRAGMA
#endif

PIRP
MRxLocalBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PETHREAD UsersThread,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN ULONG Key OPTIONAL,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN

    This routine provides a simple, fast interface to the device driver w/o
    having to put the knowledge of how to build an IRP into all of the FSDs
    (and device drivers) in the system.

    This is just lifted from io\iosubs.c plus the addition of the fileobject stuff.
    plus the completion routine and context.

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    FileObject - Pointer to the file object on the device object.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    Key - the key to be used....required for read/write.

    CompletionRoutine - the IrpCompletionRoutine
    Context - context of the completion routine

Return Value:

    The function value is a pointer to the IRP representing the specified
    request.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );   //joejoe ???
    if (!irp) {
        return irp;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //

    irp->Tail.Overlay.Thread = UsersThread;

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );  //ok4ioget
    irpSp->FileObject = FileObject;            //ok4->FileObj
    {   BOOLEAN EnableCalls = CompletionRoutine!=NULL;

        IoSetCompletionRoutine(irp, CompletionRoutine, Context,
                                EnableCalls,EnableCalls,EnableCalls);
    }


    //
    // Set the major function code.
    //

    irpSp->MajorFunction = (UCHAR) MajorFunction;

    if (MajorFunction != IRP_MJ_FLUSH_BUFFERS && MajorFunction != IRP_MJ_SHUTDOWN) {

        //
        // Now allocate a buffer or lock the pages of the caller's buffer into
        // memory based on whether the target device performs direct or buffered
        // I/O operations.
        //

        if (DeviceObject->Flags & DO_BUFFERED_IO) {

            //
            // The target device supports buffered I/O operations.  Allocate a
            // system buffer and, if this is a write, fill it in.  Otherwise,
            // the copy will be done into the caller's buffer in the completion
            // code.  Also note that the system buffer should be deallocated on
            // completion.  Also, set the parameters based on whether this is a
            // read or a write operation.
            //

            irp->AssociatedIrp.SystemBuffer = RxAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                                     Length,
                                                                     'oIxR' );
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }

            if (MajorFunction == IRP_MJ_WRITE) {
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer, Buffer, Length );
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            } else {
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION;
                irp->UserBuffer = Buffer;
            }

        } else if (DeviceObject->Flags & DO_DIRECT_IO) {

            //
            // The target device supports direct I/O operations.  Allocate
            // an MDL large enough to map the buffer and lock the pages into
            // memory.
            //

            irp->MdlAddress = IoAllocateMdl( Buffer,
                                             Length,
                                             FALSE,
                                             FALSE,
                                             (PIRP) NULL );
            if (irp->MdlAddress == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }

            MmProbeAndLockPages( irp->MdlAddress,
                                 KernelMode,
                                 (LOCK_OPERATION) (MajorFunction == IRP_MJ_READ ? IoWriteAccess : IoReadAccess) );

        } else {

            //
            // The operation is neither buffered nor direct.  Simply pass the
            // address of the buffer in the packet to the driver.
            //

            irp->UserBuffer = Buffer;
        }

        //
        // Set the parameters according to whether this is a read or a write
        // operation.  Notice that these parameters must be set even if the
        // driver has not specified buffered or direct I/O.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            irpSp->Parameters.Write.Length = Length;
            irpSp->Parameters.Write.Key = Key;
            irpSp->Parameters.Write.ByteOffset = *StartingOffset;
        } else {
            irpSp->Parameters.Read.Length = Length;
            irpSp->Parameters.Read.Key = Key;
            irpSp->Parameters.Read.ByteOffset = *StartingOffset;
        }

    }

    //
    // Finally, return a pointer to the IRP.
    //

    return irp;
}

RXSTATUS
MRxLocalCalldownReadCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine for calldown reads. we just call the lowio completion
    and exit

Arguments:

    DeviceObject - Pointer to target device object for the request.

    CalldownIrp - Pointer to I/O request packet used to call down to the underlying filesystem

    Context - Irpcontext of the original request to the rdbss

Return Value:

    RXSTATUS - If RxStatus(MORE_PROCESSING_REQUIRED) is returned.


--*/

{
    PRX_CONTEXT RxContext = Context;
    RxCaptureRequestPacket;

    RxDbgTrace ( 0, Dbg, ( "MRxLocalCalldownReadCompletion\n"));
    RxLog(('XRz',0));
    //DbgBreakPoint();
    if (CalldownIrp->PendingReturned){
        capReqPacket->IoStatus = CalldownIrp->IoStatus;
        RxDbgTrace ( 0, Dbg, ( "MRxLocalCalldownReadCompletion iostat=%08lx/%08lx\n",
                          capReqPacket->IoStatus.Status, capReqPacket->IoStatus.Information));
        RxLog(('YRz',2, capReqPacket->IoStatus.Status, capReqPacket->IoStatus.Information ));
        RxContext->StoredStatus = CalldownIrp->IoStatus.Status;
        IoFreeIrp(CalldownIrp);
        RxLowIoCompletion(RxContext);
    }
    //don't call unless pended RxLowIoCompletion(RxContext);

    RxLog(('ZRz',0));
    return(RxStatus(MORE_PROCESSING_REQUIRED));
}


RXSTATUS
MRxLocalRead (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine implements local read call. we fill in the info and stuff here BUT we
    do not complete the Irp.

Arguments:

Return Value:

    RXSTATUS - Returns the status for the read

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    PIRP CalldownIrp;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
    PVOID Buffer;
    LARGE_INTEGER ByteOffsetAsLI;

    BOOLEAN Wait = FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT)!=0;


    ByteOffsetAsLI.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;

    RxDbgTrace(+1, Dbg, ("MRxRead.... ByteCount = %08lx, ByteOffset = %08lx %08lx\n",
                            LowIoContext->ParamsFor.ReadWrite.ByteCount,
                            ByteOffsetAsLI.LowPart, ByteOffsetAsLI.HighPart));

    RxLog(('dRz',3,SrvOpen,LowIoContext->ParamsFor.ReadWrite.ByteCount,
                            ByteOffsetAsLI.LowPart));
    //ASSERT (Wait);   //we can try without this
    ASSERT (localSrvOpen->UnderlyingFileObject);

    Buffer = RxLowIoGetBufferAddress(RxContext);
    RxDbgTrace ( 0, Dbg, ( "MRxRead....  ->Buffer       = %8lx\n", Buffer));

    CalldownIrp = MRxLocalBuildAsynchronousFsdRequest(
                        IRP_MJ_READ,                           // IN ULONG MajorFunction,
                        localSrvOpen->UnderlyingDeviceObject,  // IN PDEVICE_OBJECT DeviceObject,
                        localSrvOpen->UnderlyingFileObject,    // IN PFILE_OBJECT FileObject,
                        capReqPacket->Tail.Overlay.Thread,             //IN PTHREAD UsersThread,
                        Buffer,                                // IN OUT PVOID Buffer OPTIONAL,
                        LowIoContext->ParamsFor.ReadWrite.ByteCount, // IN ULONG Length OPTIONAL,
                        &ByteOffsetAsLI,                        // IN PLARGE_INTEGER StartingOffset OPTIONAL,
                        capPARAMS->Parameters.Read.Key,            // IN ULONG Key OPTIONAL,
                        MRxLocalCalldownReadCompletion,        // IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                        RxContext                             // IN PVOID Context
                        );

    if (!CalldownIrp){
        Status = RxContext->StoredStatus = RxStatus(INSUFFICIENT_RESOURCES);
        return(Status);
    }

    Status = IoCallDriver(
                 localSrvOpen->UnderlyingDeviceObject,
                 CalldownIrp
                 );

    if (Status != RxStatus(PENDING)) {
        //copy up the status
        capReqPacket->IoStatus = CalldownIrp->IoStatus;
        IoFreeIrp(CalldownIrp);
        RxContext->StoredStatus = Status;
    }

    RxDbgTrace(-1, Dbg, ("MRxRead.... ---->Initial Status = %08lx, Initial Block status/Info    = %08lx %08lx \n",
                         Status, capReqPacket->IoStatus.Status, capReqPacket->IoStatus.Information));

    return(Status);
}

//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//
//  The local debug trace level
//

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_WRITE)



RXSTATUS
MRxLocalCalldownWriteCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine for calldown writes. we just call the lowio completion
    and exit. it is almost identical to reads BUT separate for debugging.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    CalldownIrp - Pointer to I/O request packet used to call down to the underlying filesystem

    Context - Irpcontext of the original request to the rdbss

Return Value:

    RXSTATUS - If RxStatus(MORE_PROCESSING_REQUIRED) is returned.


--*/

{
    PRX_CONTEXT RxContext = Context;
    RxCaptureRequestPacket;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PNON_PAGED_FCB NonPagedFcb;
    PERESOURCE Resource;

    RxDbgTrace ( 0, Dbg, ("MRxLocalCalldownWriteCompletion           = %08lx\n", 0));
    RxLog(('XWz',0));
    //DbgBreakPoint();
    if (CalldownIrp->PendingReturned){
        capReqPacket->IoStatus = CalldownIrp->IoStatus;
        RxLog(('YWz',2, capReqPacket->IoStatus.Status, capReqPacket->IoStatus.Information ));
        RxContext->StoredStatus = CalldownIrp->IoStatus.Status;
        IoFreeIrp(CalldownIrp);
    }

    //
    //  If this was a special async write, decrement the count.  Set the
    //  event if this was the final outstanding I/O for the file. Also, release the resource

    NonPagedFcb = LowIoContext->ParamsFor.ReadWrite.NonPagedFcb;
    if (NonPagedFcb){
        if ((ExInterlockedAddUlong( &NonPagedFcb->OutstandingAsyncWrites,
                                    0xffffffff,
                                    &RxStrucSupSpinLock ) == 1)) {

            KeSetEvent( NonPagedFcb->OutstandingAsyncEvent, 0, FALSE );
        }


        Resource = LowIoContext->Resource;

        if (Resource != NULL) {

            ExReleaseResourceForThread( Resource,
                                        LowIoContext->ResourceThreadId );
        }
    }


    RxLowIoCompletion(RxContext);

    RxLog(('ZWz',0));
    return(RxStatus(MORE_PROCESSING_REQUIRED));
}


RXSTATUS
MRxLocalWrite (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine implements local write call. we fill in the info and stuff here BUT we
    do not complete the Irp.

Arguments:

Return Value:

    RXSTATUS - Returns the status for the write

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    PIRP CalldownIrp;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
    PVOID Buffer;
    LARGE_INTEGER ByteOffsetAsLI;

    BOOLEAN Wait = FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT)!=0;


    ByteOffsetAsLI.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;

    RxDbgTrace(+1, Dbg, ("MRxWrite.... ByteCount = %08lx, ByteOffset = %08lx %08lx\n",
                            LowIoContext->ParamsFor.ReadWrite.ByteCount,
                            ByteOffsetAsLI.LowPart, ByteOffsetAsLI.HighPart));
    RxLog(('rWz',3,SrvOpen,LowIoContext->ParamsFor.ReadWrite.ByteCount,
                            ByteOffsetAsLI.LowPart));

    //ASSERT (Wait);   //we can try without this
    ASSERT (localSrvOpen->UnderlyingFileObject);

    Buffer = RxLowIoGetBufferAddress(RxContext);
    RxDbgTrace ( 0, Dbg, ("  ->Buffer       = %8lx\n", Buffer));

    CalldownIrp = MRxLocalBuildAsynchronousFsdRequest(
                        IRP_MJ_WRITE,                           // IN ULONG MajorFunction,
                        localSrvOpen->UnderlyingDeviceObject,  // IN PDEVICE_OBJECT DeviceObject,
                        localSrvOpen->UnderlyingFileObject,    // IN PFILE_OBJECT FileObject,
                        capReqPacket->Tail.Overlay.Thread,             //IN PTHREAD UsersThread,
                        Buffer,                                // IN OUT PVOID Buffer OPTIONAL,
                        LowIoContext->ParamsFor.ReadWrite.ByteCount, // IN ULONG Length OPTIONAL,
                        &ByteOffsetAsLI,                        // IN PLARGE_INTEGER StartingOffset OPTIONAL,
                        capPARAMS->Parameters.Read.Key,            // IN ULONG Key OPTIONAL,
                        MRxLocalCalldownWriteCompletion,        // IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                        RxContext                             // IN PVOID Context
                        );

    if (!CalldownIrp){
        Status = RxContext->StoredStatus = RxStatus(INSUFFICIENT_RESOURCES);
        return(Status);
    }

    Status = IoCallDriver(
                 localSrvOpen->UnderlyingDeviceObject,
                 CalldownIrp
                 );

    if (Status != RxStatus(PENDING)) {
        //copy up the status
        capReqPacket->IoStatus = CalldownIrp->IoStatus;
        RxContext->StoredStatus = Status;
        IoFreeIrp(CalldownIrp);
    }

    RxDbgTrace(-1, Dbg, (" ---->Initial Status = %08lx, Initial Block status/Info    = %08lx %08lx \n",
                         Status, capReqPacket->IoStatus.Status, capReqPacket->IoStatus.Information));

    return(Status);
}



RXSTATUS
MRxLocalExtendForCache(
    IN PRX_CONTEXT RxContext,
    IN OUT PFCB Fcb,
    IN PLONGLONG pNewFileSize
    )


/*++

Routine Description:

    This routine extends the file allocation so that the we can do a copywrite. the fcb lock
    is exclusive here; we will take the opportunity to find out the actual allocation so that
    we'll get the fast path.  another minirdr might want to guess instead since it might be actual net ios
    otherwise.

Arguments:

Return Value:

    RXSTATUS - Returns the status for the set file allocation...could be an error if disk full

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
    PFILE_OBJECT UnderlyingFileObject = localSrvOpen->UnderlyingFileObject;

    PFILE_ALLOCATION_INFORMATION Buffer;
    FILE_ALLOCATION_INFORMATION FileAllocationInformationBuffer;
    ULONG Length;

    RxDbgTrace(+1, Dbg, ("MRxLocalExtendForCache.. pnewfilesize=%08lx\n", *pNewFileSize));
    RxLog(('4ez',2,SrvOpen,*pNewFileSize));
    ASSERT  ( RxIsFcbAcquiredExclusive ( Fcb )  );

    Buffer = &FileAllocationInformationBuffer;
    Length = sizeof(FILE_ALLOCATION_INFORMATION);
    ASSERT (UnderlyingFileObject);

    if (capFcb->Header.AllocationSize.QuadPart >= *pNewFileSize) {
        Status = RxStatus(SUCCESS);
        RxDbgTrace(-1, Dbg, (" PlentyAllocation               = %08lx\n", Status));
        return(Status);
    }

    { LONGLONG CurrentExtend = (*pNewFileSize)-Fcb->Header.AllocationSize.QuadPart;
    Buffer->AllocationSize.QuadPart = Fcb->Header.AllocationSize.QuadPart
                                        + 32 * CurrentExtend;
    }
    RxDbgTrace( 0, Dbg, ("    Extending to %08lx from %08lx!\n",
                          Buffer->AllocationSize.LowPart,
                          Fcb->Header.AllocationSize.LowPart));
    Status = IoSetInformation(
                UnderlyingFileObject,       //IN PFILE_OBJECT FileObject,
                FileAllocationInformation,  //IN FILE_INFORMATION_CLASS FileInformationClass,
                Length,                     //IN ULONG Length,
                Buffer                      //IN PVOID FileInformation
                );

    //joejoe here we should now read it back and see what we actually got; for smallio we will be
    //seeing subcluster extension when, in fact, we get a cluster at a time.

    if (Status == RxStatus(SUCCESS)) {
        Fcb->Header.AllocationSize = Buffer->AllocationSize;
        RxDbgTrace(-1, Dbg, (" ---->Status               = %08lx\n", Status));
        return(Status);
    }

    RxDbgTrace( 0, Dbg, ("    EXTEND1 FAILED!!!!!!%c\n", '!'));

    //try for exactly what we need

    Buffer->AllocationSize.QuadPart = *pNewFileSize;
    Status = IoSetInformation(
                UnderlyingFileObject,       //IN PFILE_OBJECT FileObject,
                FileAllocationInformation,  //IN FILE_INFORMATION_CLASS FileInformationClass,
                Length,                     //IN ULONG Length,
                Buffer                      //IN PVOID FileInformation
                );


    if (Status == RxStatus(SUCCESS)) {
        Fcb->Header.AllocationSize = Buffer->AllocationSize;
        RxDbgTrace(-1, Dbg, (" ---->Status               = %08lx\n", Status));
        return(Status);
    }

    RxDbgTrace( 0, Dbg, ("    EXTEND1 FAILED!!!!!!%c\n", '!'));

    RxDbgTrace(-1, Dbg, (" ---->Status               = %08lx\n", Status));

    return(Status);
}

//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//
//  The local debug trace level
//

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_LOCKCTRL)


PIRP
MRxBuildLockRequest (
    IN PIRP irp OPTIONAL,
    IN PFILE_OBJECT fileObject,
    IN PETHREAD UsersThread,
    IN UCHAR MinorCode,
    IN RXVBO ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN UCHAR Flags,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This function builds an I/O request packet for a lock request.

Arguments:

    Irp - Supplies a pointer to an IRP; allocates one if one is not provided.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The local minirdr accomplishes this by holding a pointer
        (a REFERENCED ptr) to the fileobject in its srvopen while the fileobject is
        open.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    StartingBlock - the block number of the beginning of the locked
        range.

    ByteOffset - the offset within block of the beginning of the locked
        range.

    Length - the length of the locked range.

    Key - the key value to be associated with the lock.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    if (irp) {
        ASSERT( irp->StackCount >= deviceObject->StackSize );
    } else {
        irp = IoAllocateIrp( deviceObject->StackSize, TRUE );  //joejoe should i charge quota??
    }

    if (!irp) {

        //
        // An IRP could not be allocated.

        return NULL;
    }

    // we have to make sure that the thread that takes the lock is the same as the one that reads
    irp->Tail.Overlay.Thread = UsersThread;
    irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    {   BOOLEAN EnableCalls = CompletionRoutine!=NULL;

        IoSetCompletionRoutine(irp, CompletionRoutine, Context,
                                EnableCalls,EnableCalls,EnableCalls);
    }



    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = MinorCode;
    irpSp->FileObject = fileObject;   //ok4->FileObj
    irpSp->DeviceObject = deviceObject;

    irpSp->Flags = Flags;

    irpSp->Parameters.LockControl.Length = Length;
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset.QuadPart = ByteOffset;

    return irp;

}

RXSTATUS
MRxLocalCalldownLockCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine for calldown lock requests. we just call the lowio completion
    and exit

Arguments:

    DeviceObject - Pointer to target device object for the request.

    CalldownIrp - Pointer to I/O request packet used to call down to the underlying filesystem

    Context - Irpcontext of the original request to the rdbss

Return Value:

    RXSTATUS - RxStatus(MORE_PROCESSING_REQUIRED) is returned.


--*/

{
    PRX_CONTEXT RxContext = Context;

    RxDbgTrace ( 0, Dbg, ("MRxLocalCalldownLockCompletion           = %08lx\n", 0));
    //DbgBreakPoint();
    if (CalldownIrp->PendingReturned){
        RxContext->CurrentIrp->IoStatus = CalldownIrp->IoStatus;
        RxContext->StoredStatus = CalldownIrp->IoStatus.Status;
    }
    RxLowIoCompletion(RxContext);

    IoFreeIrp(CalldownIrp);
    return(RxStatus(MORE_PROCESSING_REQUIRED));
}


RXSTATUS
MRxLocalLocks (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine implements local read call. we fill in the info and stuff here BUT we
    do not complete the Irp.

Arguments:

Return Value:

    RXSTATUS - Returns the status for the read

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    PIRP CalldownIrp;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;

    BOOLEAN Wait = FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT)!=0;
    PLARGE_INTEGER LengthAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length;
    PLARGE_INTEGER OffsetAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.ByteOffset;

    char *whichop;

    switch (LowIoContext->Operation) {
    case LOWIO_OP_SHAREDLOCK:     whichop = "SHAREDLOCK"; break;
    case LOWIO_OP_EXCLUSIVELOCK:  whichop = "EXCLUSIVELOCK"; break;
    case LOWIO_OP_UNLOCK:         whichop = "UNLOCK"; break;
    case LOWIO_OP_UNLOCKALL:      whichop = "UNLOCKALL"; break;
    case LOWIO_OP_UNLOCKALLBYKEY:  whichop = "UNLOCKALLBYKEY"; break;
    }

    RxDbgTrace (+1, Dbg, ("MRxExclusiveLock...%s, Flags = %08lx, Key = %08lx\n", whichop,
              LowIoContext->ParamsFor.Locks.Flags,
              LowIoContext->ParamsFor.Locks.Key));
    RxDbgTrace( 0, Dbg, ("  ->Length     = %08lx %08lx\n",
              LengthAsLI->LowPart,
              LengthAsLI->HighPart));
    RxDbgTrace( 0, Dbg, ("  ->ByteOffset    = %08lx %08lx\n",
              OffsetAsLI->LowPart,
              OffsetAsLI->HighPart));
    RxLog(('kLz',3,SrvOpen, LengthAsLI->LowPart, OffsetAsLI->LowPart));

    ASSERT (localSrvOpen->UnderlyingFileObject);

    CalldownIrp =  MRxBuildLockRequest (
                        NULL                                    ,//IN PIRP irp OPTIONAL,
                        localSrvOpen->UnderlyingFileObject      ,//IN PFILE_OBJECT fileObject,
                        capReqPacket->Tail.Overlay.Thread                ,//IN PTHREAD UsersThread,
                        capPARAMS->MinorFunction                    ,//IN UCHAR MinorCode,
                        LowIoContext->ParamsFor.Locks.ByteOffset,//IN RXVBO ByteOffset,
                        LengthAsLI                              ,//IN PLARGE_INTEGER Length,
                        LowIoContext->ParamsFor.Locks.Key       ,//IN ULONG Key,
                        (UCHAR)LowIoContext->ParamsFor.Locks.Flags     ,//IN UCHAR Flags,
                        MRxLocalCalldownLockCompletion          ,//IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                        RxContext                               //IN PVOID Context OPTIONAL
                        );


    if (!CalldownIrp){
        Status = RxContext->StoredStatus = RxStatus(INSUFFICIENT_RESOURCES);
        return(Status);
    }

    Status = RxContext->StoredStatus =
           IoCallDriver(
                 localSrvOpen->UnderlyingDeviceObject,
                 CalldownIrp
                 );

    if (Status != RxStatus(PENDING)) {
        //copy up the status
        capReqPacket->IoStatus = CalldownIrp->IoStatus;
    }

    RxDbgTrace ( 0, Dbg, (" ---->Initial Status           = %08lx\n", Status));
    RxDbgTrace(-1, Dbg, (" ------> Initial Block status/Info    = %08lx %08lx\n",
                                    capReqPacket->IoStatus.Status, capReqPacket->IoStatus.Information));

    return(Status);
}


RXSTATUS
MRxLocalAssertLockCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine for calldown ios like querydirectory. the rub is that we
    turned synchronous opens into async opens. what we do here is set an event (in the case of a pended
    packet for a sync that we turned async) OR copyup the status;complete;free in the case of a call
    that was always async.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    CalldownIrp - Pointer to I/O request packet used to call down to the underlying filesystem

    Context - Irpcontext of the original request to the rdbss

Return Value:

    RXSTATUS - If RxStatus(MORE_PROCESSING_REQUIRED) is returned.


--*/

{
    PKEVENT Event = Context;

    RxDbgTrace ( 0, Dbg, ("  MRxLocalAssertLockCompletion           = %08lx\n", 0));

    if (CalldownIrp->PendingReturned){
        KeSetEvent( Event, 0, FALSE );
    }

    return(RxStatus(MORE_PROCESSING_REQUIRED));
}


RXSTATUS
MRxLocalAssertBufferedFileLocks (
    IN PSRV_OPEN SrvOpen
    )

/*++

Routine Description:

    This routine is called to assert all buffered file locks on a srvopen.


Arguments:

    SrvOpen - Supplies the file whose locks are to be asserted.


Return Value:

    RXSTATUS - Status of operation.


--*/

{
    RXSTATUS Status;
    PFILE_LOCK_INFO FileLock;
    PFCB Fcb = SrvOpen->Fcb;

    PIRP CalldownIrp = NULL;

    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;

    UCHAR Flags;
    BOOLEAN Wait = TRUE;

    PKEVENT Event;

    PAGED_CODE();

    RxDbgTrace (+1, Dbg, ("MRxLocalAssertBufferedFileLocks SrvOpen = %08lx", SrvOpen));
    ASSERT (localSrvOpen->UnderlyingFileObject);

    Event = RxAllocatePoolWithTag( NonPagedPool, sizeof(KEVENT), 'LAxR' );
    if (!CalldownIrp){
        Status = RxStatus(INSUFFICIENT_RESOURCES);
        return(Status);
    }

    try {
        for (FileLock = FsRtlGetNextFileLock(&Fcb->Specific.Fcb.FileLock, TRUE);
                  FileLock != NULL;
                        FileLock = FsRtlGetNextFileLock(&Fcb->Specific.Fcb.FileLock, FALSE)) {

            RxDbgTrace (0, Dbg, ("MRxLocalAssertBufferedFileLocks Exclusive = %08lx, Key = %08lx\n",
                      FileLock->ExclusiveLock,
                      FileLock->Key));
            RxDbgTrace( 0, Dbg, ("  ->Length     = %08lx %08lx\n",
                      FileLock->Length.LowPart,
                      FileLock->Length.HighPart));
            RxDbgTrace( 0, Dbg, ("  ->ByteOffset    = %08lx %08lx\n",
                      FileLock->StartingByte.LowPart,
                      FileLock->StartingByte.HighPart));

            if (FileLock->ExclusiveLock) {
                Flags = SL_EXCLUSIVE_LOCK | SL_FAIL_IMMEDIATELY;
            } else {
                Flags = SL_FAIL_IMMEDIATELY;
            }

            //joejoe we should reuse the irp.........
            CalldownIrp =  MRxBuildLockRequest (
                                NULL                                ,//IN PIRP irp OPTIONAL,
                                localSrvOpen->UnderlyingFileObject  ,//IN PFILE_OBJECT fileObject,
                                localSrvOpen->OriginalThread        ,//IN PTHREAD UsersThread,
                                IRP_MN_LOCK                         ,//IN UCHAR MinorCode,
                                FileLock->StartingByte.QuadPart     ,//IN RXVBO ByteOffset,
                                &FileLock->Length                   ,//IN PLARGE_INTEGER Length,
                                FileLock->Key                       ,//IN ULONG Key,
                                Flags                               ,//IN UCHAR Flags,
                                MRxLocalAssertLockCompletion        ,//IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                                &Event                                //IN PVOID Context OPTIONAL
                                );

            if (!CalldownIrp){
                Status = RxStatus(INSUFFICIENT_RESOURCES);
                try_return(Status);
            }

            CalldownIrp->Flags |= IRP_SYNCHRONOUS_API;

            KeInitializeEvent( Event, SynchronizationEvent, FALSE );

            Status = IoCallDriver(
                         localSrvOpen->UnderlyingDeviceObject,
                         CalldownIrp
                         );

            if (Status == RxStatus(PENDING)) {
                KeWaitForSingleObject(Event, UserRequest, KernelMode, FALSE, NULL);
                Status = CalldownIrp->IoStatus.Status;
            }

            RxDbgTrace ( 0, Dbg, (" ---->PerLock Status           = %08lx\n", Status));

        }

   try_exit:
        NOTHING;

    } finally {

        ExFreePool(Event);
        if (CalldownIrp) {
            IoFreeIrp(CalldownIrp);
        }
    }

    RxDbgTrace (-1, Dbg, ("--------->Final Status           = %08lx\n", Status));
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\monolithic\makefile.inc ===
copyforifskit:
# This is bogus.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\local_nt.mrx\misc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Misc.c

Abstract:

    This module implements the dirctrl, fileinfo and volinfo routines for the local minirdr.

Author:

    Joe Linn      [JoeLinn]      4-dec-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
//#include "fsctlbuf.h"
//#include "NtDdNfs2.h"
//#include "stdio.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_MISC)

//
//  The local debug trace level
//

#undef Dbg
#define Dbg                              (DEBUG_TRACE_DIRCTRL)




PIRP
MRxLocalBuildCoreOfSyncIoRequest (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN ForceSyncApi,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID Context
    )

/*++

Routine Description:

    This (local) function builds the request-independent portion of
    an I/O request packet for an I/O operation that will be performed
    synchronously.  It initializes a kernel event object, references
    the target file object, and allocates and initializes an IRP.

Arguments:

    FileObject - supplies a pointer to the target file object.

    Event - Supplies a pointer to a kernel event object.  This routine
        initializes the event.

    IoStatusBlock - Supplies a pointer to an I/O status block.  This
        pointer is placed in the IRP.

    DeviceObject - Supplies or receives the address of the device object
        associated with the target file object.  This address is
        subsequently used by StartIoAndWait.  *DeviceObject must be
        valid or NULL on entry if FileObject != NULL.

    CompletionRoutine - the IrpCompletionRoutine
    Context - context of the completion routine

Return Value:

    PIRP - Returns a pointer to the constructed IRP.

--*/

{
    RXSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    irp = IoAllocateIrp( DeviceObject->StackSize, TRUE );
    if ( irp == NULL ) {
        return NULL;
    }

    //
    // Fill in the service independent parameters in the IRP.

    if (ForceSyncApi) {
        irp->Flags = (LONG)IRP_SYNCHRONOUS_API;
    }

    //
    // Put the file object pointer in the stack location.

    irpSp = IoGetNextIrpStackLocation( irp ); //ok4ioget
    irpSp->FileObject = FileObject;           //ok4->FileObj
    irpSp->DeviceObject = DeviceObject;

    {   BOOLEAN EnableCalls = CompletionRoutine!=NULL;

        IoSetCompletionRoutine(irp, CompletionRoutine, Context,
                                EnableCalls,EnableCalls,EnableCalls);
    }

    return irp;

} // BuildCoreOfSyncIoRequest


RXSTATUS
MRxLocalStartIoAndWait (
    IN PRX_CONTEXT RxContext,
    IN PIRP CalldownIrp,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG pLengthRemaining
    )

/*++

Routine Description:

    This (local) function passes a fully built I/O request packet to the
    target driver, then waits for the driver to complete the request.

Arguments:

    RxContext - Supplies a pointer operation context.

    CalldownIrp - Supplies a pointer to the I/O request packet.

    DeviceObject - Supplies a pointer to the target device object.

Return Value:

    RXSTATUS - Either an error status returned by the driver from
        IoCallDriver, indicating that the driver rejected the request,
        or the I/O status placed in the I/O status block by the driver
        at I/O completion.

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    PKEVENT Event;
    PMRX_SYNCIO_CONTEXT SyncIoContext = (PMRX_SYNCIO_CONTEXT)&RxContext->LowIoContext;
    BOOLEAN Wait = FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT)!=0;
    ULONG ReturnedInformation;

    PAGED_CODE( );

    RxDbgTrace (+1, Dbg, ("MRxLocalStartIoAndWait   IrpC= %08lx, lengthR=%d\n", RxContext,*pLengthRemaining));
    RxLog(('TSz',0));

    if (Wait) {
        SyncIoContext->SyncEvent = Event = &SyncIoContext->TheActualEvent;;
        KeInitializeEvent( Event, SynchronizationEvent, FALSE );
    } else {
        ASSERT(!"we can't handle an async call to startioandwait.......");
        SyncIoContext->SyncEvent = NULL;
    }

    Status = IoCallDriver( DeviceObject, CalldownIrp );

    if ( Status == RxStatus(PENDING) ) {

        if (Event) {

            KeWaitForSingleObject(Event, UserRequest, KernelMode, FALSE, NULL);
            Status = CalldownIrp->IoStatus.Status;

        } else {
            //store nothing.....get out
            ASSERT(!"we can't handle an async call to startioandwait.......");
            RxDbgTrace (-1, Dbg, ("MRxLocalStartIoAndWait   pending= %08lx\n", Status));
            return Status;
        }
    }

    //
    // from the point of view of the guy above we never pended! so, just store the info....
    ReturnedInformation = CalldownIrp->IoStatus.Information;
    if (pLengthRemaining) {
        RxDbgTrace (0, Dbg, ("MRxLocalStartIoAndWait before   remaining= %08lx, info=%08lx\n",
                         *pLengthRemaining, ReturnedInformation));
        *pLengthRemaining -=  ReturnedInformation;
        RxDbgTrace (0, Dbg, ("MRxLocalStartIoAndWait after   remaining= %08lx, info=%08lx\n",
                         *pLengthRemaining, ReturnedInformation));
    } else {
        capReqPacket->IoStatus.Information =  ReturnedInformation;
    }
    // don't RxContext->StoredStatus = Status;
    IoFreeIrp(CalldownIrp);

    RxDbgTrace (-1, Dbg, ("MRxLocalStartIoAndWait   status= %08lx, info=%08lx\n",
                         Status, ReturnedInformation));
    return Status;

} // StartIoAndWait


RXSTATUS
MRxLocalCalldownSyncIoCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine for calldown ios like querydirectory. the rub is that we
    turned synchronous opens into async opens. what we do here is set an event (in the case of a pended
    packet for a sync that we turned async) OR copyup the status;complete;free in the case of a call
    that was always async.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    CalldownIrp - Pointer to I/O request packet used to call down to the underlying filesystem

    Context - Irpcontext of the original request to the rdbss

Return Value:

    RXSTATUS - If RxStatus(MORE_PROCESSING_REQUIRED) is returned.


--*/

{
    PRX_CONTEXT RxContext = Context;
    RxCaptureRequestPacket;
    PMRX_SYNCIO_CONTEXT SyncIoContext = (PMRX_SYNCIO_CONTEXT)&RxContext->LowIoContext;

    RxDbgTrace ( 0, Dbg, ("  MRxLocalCalldownSyncIoCompletion           = %08lx\n", 0));

    if (CalldownIrp->PendingReturned){
        if (SyncIoContext->SyncEvent){
            KeSetEvent( SyncIoContext->SyncEvent, 0, FALSE );
        } else {

            // there's no one waiting.....obviously this was a async from the start so
            // we just complete the packet from here......

            capReqPacket->IoStatus = CalldownIrp->IoStatus;
            RxContext->StoredStatus = CalldownIrp->IoStatus.Status;
            RxCompleteRequest(RxContext,
                              RxContext->StoredStatus); //joejoe this is anomolous
            IoFreeIrp(CalldownIrp);
        }
    }

    return(RxStatus(MORE_PROCESSING_REQUIRED));
}


RXSTATUS
MRxLocalQueryDirectory (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID                  Buffer,
    IN OUT PULONG                 pLengthRemaining
    )

/*++

Routine Description:

    This routine just reroutes the query to the local guy.  It is responsible
    for either completing of enqueuing the input Irp. i can't handle assync yet.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PMRX_SYNCIO_CONTEXT SyncIoContext = (PMRX_SYNCIO_CONTEXT)&RxContext->LowIoContext;

    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
    BOOLEAN Wait = BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT);

    PIRP CalldownIrp;
    PIO_STACK_LOCATION CalldownIrpSp;
    PDEVICE_OBJECT UnderlyingDeviceObject = localSrvOpen->UnderlyingDeviceObject;
    PFILE_OBJECT UnderlyingFileObject = localSrvOpen->UnderlyingFileObject;

    PAGED_CODE( );

    RxDbgTrace(+1, Dbg, ("MRxQueryDirectory...\n", 0));
    RxLog(('DQz',0));
    ASSERT(sizeof(MRX_SYNCIO_CONTEXT) <= sizeof(LOWIO_CONTEXT));
    ASSERT (localSrvOpen->UnderlyingFileObject);

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    CalldownIrp = MRxLocalBuildCoreOfSyncIoRequest (
                   UnderlyingFileObject ,//IN PFILE_OBJECT FileObject,
                   Wait ,//IN BOOLEAN ForceSyncApi,
                   UnderlyingDeviceObject ,//IN PDEVICE_OBJECT DeviceObject,
                   MRxLocalCalldownSyncIoCompletion ,//IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                   RxContext  //IN PVOID Context
              );

    if ( CalldownIrp == NULL ) {

        return RxStatus(INSUFFICIENT_RESOURCES);

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    CalldownIrpSp = IoGetNextIrpStackLocation( CalldownIrp );
    CalldownIrpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    CalldownIrpSp->MinorFunction = IRP_MN_QUERY_DIRECTORY;
    CalldownIrpSp->Parameters.QueryDirectory = capPARAMS->Parameters.QueryDirectory;
    ASSERT (
           (CalldownIrpSp->Parameters.QueryDirectory.FileInformationClass == FileInformationClass)
        && (CalldownIrpSp->Parameters.QueryDirectory.Length == *pLengthRemaining)
    );
    CalldownIrpSp->Flags = capPARAMS->Flags;

    //
    // Determine whether the driver wants buffered, direct, or "neither" I/O.
    // we only support neither.

    ASSERT ( (UnderlyingDeviceObject->Flags & ( DO_BUFFERED_IO | DO_DIRECT_IO)) == 0 );

    CalldownIrp->UserBuffer = Buffer;

//    RxDbgTrace( 0, Dbg, (" ->UserBufLength   = %08lx\n", CalldownIrpSp->Parameters.QueryDirectory.Length));
//    RxDbgTrace( 0, Dbg, (" ->FileName = %08lx\n", CalldownIrpSp->Parameters.QueryDirectory.FileName));
//    IF_DEBUG {
//        if (CalldownIrpSp->Parameters.QueryDirectory.FileName) {
//            RxDbgTrace( 0, Dbg, (" ->     %wZ\n", CalldownIrpSp->Parameters.QueryDirectory.FileName ));
//    }}
//    RxDbgTrace( 0, Dbg, (" ->FileInformationClass = %08lx\n", CalldownIrpSp->Parameters.QueryDirectory.FileInformationClass));
//    RxDbgTrace( 0, Dbg, (" ->FileIndex       = %08lx\n", CalldownIrpSp->Parameters.QueryDirectory.FileIndex));
//    RxDbgTrace( 0, Dbg, (" ->UserBuffer      = %08lx\n", CalldownIrp->UserBuffer));
//    RxDbgTrace( 0, Dbg, (" ->RestartScan     = %08lx\n", FlagOn( CalldownIrpSp->Flags, SL_RESTART_SCAN )));
//    RxDbgTrace( 0, Dbg, (" ->ReturnSingleEntry = %08lx\n", FlagOn( CalldownIrpSp->Flags, SL_RETURN_SINGLE_ENTRY )));
//    RxDbgTrace( 0, Dbg, (" ->IndexSpecified  = %08lx\n", FlagOn( CalldownIrpSp->Flags, SL_INDEX_SPECIFIED )));

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    Status = MRxLocalStartIoAndWait( RxContext, CalldownIrp, UnderlyingDeviceObject, pLengthRemaining );
    RxDbgTrace(-1, Dbg, ("MRxQueryDirectory status=%08lx\n", Status));
    //DbgBreakPoint();
    return Status;

} // MRxLocalQueryDirectory

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


//
//  The local debug trace level
//

#undef Dbg
#define Dbg                              (DEBUG_TRACE_FILEINFO)


//
//  Internal support routine
//

RXSTATUS
MRxLocalQueryFileInformation (
    IN PRX_CONTEXT RxContext,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID Buffer,
    IN OUT PULONG pLengthRemaining
    )

/*++

Routine Description:

    This routine implements the query file info call

Arguments:

Return Value:

    RXSTATUS - Returns the status for the query

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PFILE_OBJECT UnderlyingFileObject = ((PMRX_LOCAL_SRV_OPEN)(SrvOpen))->UnderlyingFileObject;

    ULONG ReturnedLength = 0;

    RxDbgTrace(+1, Dbg, ("MRxLocalQueryFileInfo...\n", 0));
    RxLog(('FQz',0));

    if ( !FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )  ){
        RxContext->PostRequest = TRUE;
        RxDbgTrace(-1, Dbg, ("MRxLocalQueryFileInfo...PENDING\n", 0));
        return(RxStatus(PENDING));
    }

    RxDbgTrace( 0, Dbg, (" ---->UserBuffer/remLength/Class = %08lx/%08lx/%08lx\n",
                             Buffer, *pLengthRemaining, FileInformationClass));
    ASSERT (UnderlyingFileObject);

    Status = IoQueryFileInformation(
                UnderlyingFileObject, //IN PFILE_OBJECT FileObject,
                FileInformationClass, //IN FILE_INFORMATION_CLASS FileInformationClass,
                *pLengthRemaining,               //IN ULONG Length,
                Buffer,               //OUT PVOID FileInformation,
                &ReturnedLength       //OUT PULONG ReturnedLength
                );


    *pLengthRemaining -= ReturnedLength;
    RxDbgTrace(-1, Dbg, (" ---->Status/remLen/retLen = %08lx\n",
                                      Status, *pLengthRemaining, ReturnedLength));
    return(Status);
}

RXSTATUS
MRxLocalSetFileInfoAtCleanup (
    IN PRX_CONTEXT RxContext,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine implements the set file info call called on cleanup or flush. We dont actually set the times but we do set
    the endoffile info.

Arguments:

Return Value:

    RXSTATUS - Returns the status for the set

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PFILE_OBJECT UnderlyingFileObject = ((PMRX_LOCAL_SRV_OPEN)(SrvOpen))->UnderlyingFileObject;

    if (FileInformationClass == FileBasicInformation) {
        return(RxStatus(SUCCESS));
    }
    RxDbgTrace(+1, Dbg, ("MRxLocalSetFileInfoAtCleanup...\n", 0));
    RxLog(('GSz',0));
    return MRxLocalSetFileInformation(RxContext,FileInformationClass,Buffer,Length);
}



RXSTATUS
MRxLocalSetFileInformation (
    IN PRX_CONTEXT RxContext,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine implements the set file info call. we do not take the opportunity to set
    allocationsize correctly on a setfilesize calldown.

Arguments:

Return Value:

    RXSTATUS - Returns the status for the set

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PFILE_OBJECT UnderlyingFileObject = ((PMRX_LOCAL_SRV_OPEN)(SrvOpen))->UnderlyingFileObject;

    RxDbgTrace(+1, Dbg, ("MRxLocalSetFileInfo...\n", 0));
    RxLog(('FSz',0));

    if(Length==0){
        //zero length means that this is the special calldown from the cachemanager...for now just boost
        //joejoe this should be fixed soon
        Length = sizeof(FILE_END_OF_FILE_INFORMATION);
    }

    RxDbgTrace( 0, Dbg, (" ---->UserBuffer           = %08lx\n", Buffer));
    ASSERT (UnderlyingFileObject);

    //this could be a setfileinfo that comes in from the lazywriter
    //after the underlying file has already been cleaned up
    if (UnderlyingFileObject == NULL) {
        Status = RxStatus(FILE_CLOSED);
        RxDbgTrace(-1, Dbg, (" ---->AlreadyClosed!!! Status = %08lx\n", Status));
        return(Status);
    }

    Status = IoSetInformation(
                UnderlyingFileObject,  //IN PFILE_OBJECT FileObject,
                FileInformationClass,  //IN FILE_INFORMATION_CLASS FileInformationClass,
                Length,                //IN ULONG Length,
                Buffer                 //IN PVOID FileInformation
                );

    RxDbgTrace(-1, Dbg, (" ---->Status = %08lx\n", Status));

    return(Status);
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

//
//  The local debug trace level
//

#undef Dbg
#define Dbg                              (DEBUG_TRACE_VOLINFO)


RXSTATUS
MRxLocalQueryVolumeInformation (
    IN OUT PRX_CONTEXT RxContext,
    IN     FS_INFORMATION_CLASS FsInformationClass,
    IN OUT PVOID Buffer,
    IN OUT PULONG pLengthRemaining
    )

/*++

Routine Description:

    This routine just reroutes the query to the local guy.  It is responsible
    for either completing of enqueuing the input Irp. i can't handle assync yet.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PMRX_SYNCIO_CONTEXT SyncIoContext = (PMRX_SYNCIO_CONTEXT)&RxContext->LowIoContext;

    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
    BOOLEAN Wait = BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT);

    PIRP CalldownIrp;
    PIO_STACK_LOCATION CalldownIrpSp;
    PDEVICE_OBJECT UnderlyingDeviceObject = localSrvOpen->UnderlyingDeviceObject;
    PFILE_OBJECT UnderlyingFileObject = localSrvOpen->UnderlyingFileObject;

    PAGED_CODE( );

    RxDbgTrace(+1, Dbg, ("MRxQueryVolumeInfo...\n", 0));
    RxLog(('VQz',0));
    ASSERT(sizeof(MRX_SYNCIO_CONTEXT) <= sizeof(LOWIO_CONTEXT));
    ASSERT (localSrvOpen->UnderlyingFileObject);

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    CalldownIrp = MRxLocalBuildCoreOfSyncIoRequest (
                   UnderlyingFileObject ,//IN PFILE_OBJECT FileObject,
                   Wait ,//IN BOOLEAN ForceSyncApi,
                   UnderlyingDeviceObject ,//IN PDEVICE_OBJECT DeviceObject,
                   MRxLocalCalldownSyncIoCompletion ,//IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                   RxContext  //IN PVOID Context
              );

    if ( CalldownIrp == NULL ) {

        return RxStatus(INSUFFICIENT_RESOURCES);

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    CalldownIrpSp = IoGetNextIrpStackLocation( CalldownIrp );
    CalldownIrpSp->MajorFunction = IRP_MJ_QUERY_VOLUME_INFORMATION;
    //CalldownIrpSp->MinorFunction = IRP_MN_QUERY_DIRECTORY;
    CalldownIrpSp->Parameters.QueryVolume = capPARAMS->Parameters.QueryVolume;
    ASSERT (
           (CalldownIrpSp->Parameters.QueryVolume.FsInformationClass == FsInformationClass)
        && (CalldownIrpSp->Parameters.QueryVolume.Length == *pLengthRemaining)
    );
    CalldownIrpSp->Flags = capPARAMS->Flags;

    //
    // Determine whether the driver wants buffered, direct, or "neither" I/O.
    // we only support neither.

    ASSERT ( (UnderlyingDeviceObject->Flags & ( DO_BUFFERED_IO | DO_DIRECT_IO)) == 0 );

    //CalldownIrp->UserBuffer = NULL;
    CalldownIrp->AssociatedIrp.SystemBuffer = Buffer;

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    Status = MRxLocalStartIoAndWait( RxContext, CalldownIrp, UnderlyingDeviceObject, pLengthRemaining );
    RxDbgTrace(-1, Dbg, ("MRxQueryVolumeInfo status=%08lx\n", Status));
    //DbgBreakPoint();
    return Status;

} // MRxLocalQueryVolumeInformation



//
//  The local debug trace level
//

#undef Dbg
#define Dbg                              (DEBUG_TRACE_FLUSH)


RXSTATUS
MRxLocalFlush (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine just reroutes the query to the local guy.  It is responsible
    for either completing of enqueuing the input Irp. we're already sync by the time we get here.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PMRX_SYNCIO_CONTEXT SyncIoContext = (PMRX_SYNCIO_CONTEXT)&RxContext->LowIoContext;

    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
    BOOLEAN Wait = BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT);

    PIRP CalldownIrp;
    PIO_STACK_LOCATION CalldownIrpSp;
    PDEVICE_OBJECT UnderlyingDeviceObject = localSrvOpen->UnderlyingDeviceObject;
    PFILE_OBJECT UnderlyingFileObject = localSrvOpen->UnderlyingFileObject;

    PAGED_CODE( );

    RxDbgTrace(+1, Dbg, ("MRxFlush...\n", 0));
    RxLog(('FFz',0));
    ASSERT(sizeof(MRX_SYNCIO_CONTEXT) <= sizeof(LOWIO_CONTEXT));
    ASSERT (localSrvOpen->UnderlyingFileObject);

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    CalldownIrp = MRxLocalBuildCoreOfSyncIoRequest (
                   UnderlyingFileObject ,//IN PFILE_OBJECT FileObject,
                   Wait ,//IN BOOLEAN ForceSyncApi,
                   UnderlyingDeviceObject ,//IN PDEVICE_OBJECT DeviceObject,
                   MRxLocalCalldownSyncIoCompletion ,//IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                   RxContext  //IN PVOID Context
              );

    if ( CalldownIrp == NULL ) {

        return RxStatus(INSUFFICIENT_RESOURCES);

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    CalldownIrpSp = IoGetNextIrpStackLocation( CalldownIrp );
    CalldownIrpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;


    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    Status = MRxLocalStartIoAndWait( RxContext, CalldownIrp, UnderlyingDeviceObject,NULL );
    RxDbgTrace(-1, Dbg, ("MRxFlush status=%08lx\n", Status));
    //DbgBreakPoint();
    return Status;

} // MRxLocalFlush



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\local_nt.mrx\mrxlocal.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    MrxLocal.h

Abstract:

    This module defines all of the structures and prototypes for the local minirdr.

Author:

    Joe Linn (JoeLinn)    10-27-94

Revision History:

--*/

#ifndef _MRXLOCALMINIRDR_
#define _MRXLOCALMINIRDR_

#define INVALID_HANDLE ((HANDLE)-1)

extern PRDBSS_EXPORTS ___MINIRDR_IMPORTS_NAME;
#define RxNetNameTable (*(*___MINIRDR_IMPORTS_NAME).pRxNetNameTable)
#define RxStrucSupSpinLock (*(*___MINIRDR_IMPORTS_NAME).pRxStrucSupSpinLock)

extern KSPIN_LOCK MrxLocalOplockSpinLock;

typedef struct _MRXLOCAL_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    //joejoe not clear when, if ever, for this other stuff.........so
#if 0

    ULONG PostedRequestCount;

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    ULONG OverflowQueueCount;

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue;

    //
    //  The following spinlock protects access to all the above fields.
    //

    KSPIN_LOCK OverflowQueueSpinLock;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;
#endif

} MRXLOCAL_DEVICE_OBJECT;

typedef MRXLOCAL_DEVICE_OBJECT *PMRXLOCAL_DEVICE_OBJECT;

extern MRXLOCAL_DEVICE_OBJECT MrxLocalDeviceObject;

extern struct _MINIRDR_DISPATCH  MRxLocalDispatch;


RXSTATUS MRxLocalInitializeCalldownTable(
    void
    );

RXSTATUS MRxLocalStart(
    PRX_CONTEXT RxContext,
    PVOID Context
    );

RXSTATUS MRxLocalStop(
    PRX_CONTEXT RxContext,
    PVOID Context
    );

RXSTATUS MRxLocalMinirdrControl(
    IN PRX_CONTEXT RxContext,
    IN PVOID Context,
    IN OUT PUCHAR InputBuffer,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    OUT PULONG CopyBackLength
    );

RXSTATUS MRxLocalCreateNetRoot(
    IN PRX_CONTEXT                RxContext,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

RXSTATUS
MRxLocalCreateSrvCall(
    IN PRX_CONTEXT RxContext,
    IN OUT PMRX_SRVCALL_CALLBACK_CONTEXT SrvCallCallBackContext
    );

RXSTATUS
MRxLocalSrvCallWinnerNotify(
    IN PRX_CONTEXT RxContext,
    IN BOOLEAN ThisMinirdrIsTheWinner,
    IN OUT PVOID DisconnectAfterLosingContext,
    IN PVOID MinirdrContext
    );

//joejoe T H I S   S T U F F   G E T S   M O V E D...... probably rxprocs.h--------------------------------

VOID
RxChangeBufferingState(
    PSRV_OPEN SrvOpen,
    PMRX_NEWSTATE_CALLDOWN ComputeNewState,
    PVOID Context
    );


// T H I S   S T U F F   G E T S   M O V E D...... probably rxprocs.h--------------------------------


typedef enum _MINIRDR_OPLOCK_TYPE {
    OplockTypeNone,
    OplockTypeBatch,
    OplockTypeExclusive,
    OplockTypeShareRead
} MINIRDR_OPLOCK_TYPE, *PMINIRDR_OPLOCK_TYPE;

typedef enum _MINIRDR_OPLOCK_STATE {
    OplockStateNone = 0,
    OplockStateOwnExclusive,
    OplockStateOwnBatch,
    OplockStateOwnLevelII
} MINIRDR_OPLOCK_STATE, *PMINIRDR_OPLOCK_STATE;

typedef struct _MINIRDR_OPLOCK_COMPLETION_CONTEXT{
    PSRV_OPEN SrvOpen;
    BOOLEAN RetryForLevelII;
    BOOLEAN OplockBreakPending; //interlocked access
    KEVENT RetryEvent;
    PIRP OplockIrp;
} MINIRDR_OPLOCK_COMPLETION_CONTEXT, *PMINIRDR_OPLOCK_COMPLETION_CONTEXT;

typedef struct _MRX_LOCAL_SRV_OPEN {
    SRV_OPEN inner;
    HANDLE UnderlyingHandle;
    PFILE_OBJECT UnderlyingFileObject;
    PDEVICE_OBJECT UnderlyingDeviceObject;
    PETHREAD OriginalThread;  //this is used to assert filelocks on oplockbreak
    PEPROCESS OriginalProcess; //this is just used in asserts...joejoe should be DBG
    MINIRDR_OPLOCK_STATE OplockState;
    PMINIRDR_OPLOCK_COMPLETION_CONTEXT Mocc;
} MRX_LOCAL_SRV_OPEN, *PMRX_LOCAL_SRV_OPEN;


//define the callouts and local stuff to the local guy here as well

extern struct _MINIRDR_DISPATCH  RxMRxLocalDispatch;

//joejoe this should be tied to the related prototypes in minirdr.h
#define LOCALHDR(nname) \
RXSTATUS \
MRxLocal##nname (  \
    IN PRX_CONTEXT RxContext  \
    )

LOCALHDR(Create);
LOCALHDR(Flush);
LOCALHDR(SetVolumeInformation);
LOCALHDR(Cleanup);
LOCALHDR(Close);
LOCALHDR(Read);
LOCALHDR(Write);
LOCALHDR(Locks);

RXSTATUS
MRxLocalForceClosed (
    IN PSRV_OPEN SrvOpen
    );

extern RXSTATUS
MRxLocalQueryDirectory (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID                  Buffer,
    IN OUT PULONG                 pLengthRemaining
    );

extern RXSTATUS
MRxLocalQueryVolumeInformation (
    IN OUT PRX_CONTEXT RxContext,
    IN     FS_INFORMATION_CLASS FsInformationClass,
    IN OUT PVOID Buffer,
    IN OUT PULONG pLengthRemaining
    );


RXSTATUS
MRxLocalQueryFileInformation (
    IN PRX_CONTEXT RxContext,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID Buffer,
    IN OUT PULONG pLengthRemaining
    );

RXSTATUS
MRxLocalSetFileInformation (
    IN PRX_CONTEXT RxContext,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID Buffer,
    IN ULONG Length
    );

RXSTATUS
MRxLocalSetFileInfoAtCleanup (
    IN PRX_CONTEXT RxContext,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID Buffer,
    IN ULONG Length
    );

RXSTATUS
MRxLocalExtendForCache (
    IN PRX_CONTEXT RxContext,
    IN OUT PFCB Fcb,
    IN PLONGLONG pNewFileSize
    );


RXSTATUS
MRxLocalAssertBufferedFileLocks (
    IN PSRV_OPEN SrvOpen
    );

PIRP
MRxLocalBuildAsynchronousFsdRequest (
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PETHREAD UsersThread,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN ULONG Key OPTIONAL,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID Context
    );


typedef struct _MRX_SYNCIO_CONTEXT {
    PKEVENT SyncEvent;
    KEVENT  TheActualEvent;
} MRX_SYNCIO_CONTEXT, *PMRX_SYNCIO_CONTEXT;

PIRP
MRxLocalBuildCoreOfSyncIoRequest (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN ForceSyncApi,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID Context
    );

RXSTATUS
MRxLocalStartIoAndWait (
    IN PRX_CONTEXT RxContext,
    IN PIRP CalldownIrp,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG pLengthRemaining
    );


#endif   // _MRXLOCALMINIRDR_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\local_nt.mrx\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create, Cleanup, and Close routines for the local minirdr
    including much oplock-client stuff.

Author:

    Joe Linn      [JoeLinn]    3-dec-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

#define StorageType(co) ((co) & FILE_STORAGE_TYPE_MASK)
#define StorageFlag(co) ((co) & FILE_STORAGE_TYPE_SPECIFIED)
#define IsStorageTypeSpecified(co)  (StorageFlag(co) == FILE_STORAGE_TYPE_SPECIFIED)

#ifdef _CAIRO_  //  OFS STORAGE
#define MustBeDirectory(co)                                 \
        (StorageFlag(co) == FILE_DIRECTORY_FILE ||          \
         (IsStorageTypeSpecified(co) &&                     \
          StorageType(co) == FILE_STORAGE_TYPE_DIRECTORY))
#define MustBeFile(co)                             \
        (StorageFlag(co) == FILE_NON_DIRECTORY_FILE ||      \
         (IsStorageTypeSpecified(co) &&                     \
          StorageType(co) == FILE_STORAGE_TYPE_FILE))
#else
#define MustBeDirectory(co) ((co) & FILE_DIRECTORY_FILE)
#define MustBeFile(co)      ((co) & FILE_NON_DIRECTORY_FILE)
#endif



#ifdef ALLOC_PRAGMA
#endif

//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------

BOOLEAN MRxLocalNoOplocks = FALSE;
BOOLEAN MRxRequestLevelII = TRUE;
ULONG   MRxOplockRequestType = OplockTypeBatch;

KSPIN_LOCK MrxLocalOplockSpinLock = 0;

ULONG MRxLocalTranslateStateToBufferMode [] = {
         0   //OplockStateNone
        ,0   //OplockStateOwnExclusive:
                           | FCB_STATE_WRITECACHEING_ENABLED
                           | FCB_STATE_WRITEBUFFERING_ENABLED
                           | FCB_STATE_READCACHEING_ENABLED
                           | FCB_STATE_READBUFFERING_ENABLED
                           | FCB_STATE_OPENSHARING_ENABLED
                           | FCB_STATE_LOCK_BUFFERING_ENABLED
                           | FCB_STATE_FILESIZE_IS_VALID
        ,0   //OplockStateOwnBatch:
                           | FCB_STATE_WRITECACHEING_ENABLED
                           | FCB_STATE_WRITEBUFFERING_ENABLED
                           | FCB_STATE_READCACHEING_ENABLED
                           | FCB_STATE_READBUFFERING_ENABLED
                           | FCB_STATE_OPENSHARING_ENABLED
                           | FCB_STATE_COLLAPSING_ENABLED
                           | FCB_STATE_LOCK_BUFFERING_ENABLED
                           | FCB_STATE_FILESIZE_IS_VALID
        ,0   //OplockStateOwnLevelII:
                           | FCB_STATE_READCACHEING_ENABLED
                           | FCB_STATE_READBUFFERING_ENABLED
                           | FCB_STATE_OPENSHARING_ENABLED
        };

VOID
MRxLocalGetFileObjectFromHandle(
    IN  PMRX_LOCAL_SRV_OPEN localSrvOpen,
    IN  HANDLE handle
    );

PIRP
MRxLocalBuildXxxCtlIrp(
    IN PIRP irp OPTIONAL,
    IN PFILE_OBJECT FileObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN DeviceIoControl,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context
    );

RXSTATUS
MRxLocalOplockCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

RXSTATUS
MRxLocalOplockBreakCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
MRxLocalFinalizeOplockContext (
    IN OUT PMINIRDR_OPLOCK_COMPLETION_CONTEXT cc
    )

/*++

Routine Description:

    This frees anything it needs to with respect to the completion context including
       1) the irp.
       2) the reference on the srvopen. //joejoe maybe we should finalize
       3) the context itself

    Because of (2), you have to have the FCB resource at least shared.........(there's an assert
    in DereferenceSrvOpen to catch this)....A small "disorder" is that the srvopen and fcb may already be gone.
    This will be the case is the SrvOpen field is null.

Arguments:

    cc - A pointer to the oplock_completion_context to be finalized.

Return Value:

    none.


--*/

{
    PSRV_OPEN SrvOpen = cc->SrvOpen;
#if DBG
    PMINIRDR_OPLOCK_COMPLETION_CONTEXT savecc = cc; //in case of wrapped free!
#endif

    RxDbgTrace( +1, Dbg,("MRxLocalFinalCC:   Irp=%08lx, SrvOpen=%08lx\n",cc->OplockIrp,SrvOpen));
    if (cc->OplockIrp) IoFreeIrp(cc->OplockIrp);
    ExFreePool(cc);
    if (SrvOpen) {
        PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)(SrvOpen);
        ASSERT (NodeType(SrvOpen)==RDBSS_NTC_SRVOPEN);
        ASSERT (localSrvOpen->Mocc == savecc);
        RxDereferenceSrvOpen(SrvOpen);
        localSrvOpen->Mocc = NULL;
    }
    //DebugTrace(-1, Dbg, NULL, 0);
    RxDbgTraceUnIndent(-1,Dbg);
    return;
}

VOID
MRxLocalComputeNewState (
    IN PVOID Context
    )
/*++

Routine Description:

    Here, we acknowledge the break in order to discover what the new state can be. We compute this new
    state and return it as the response. this routine doesn't yet break to level II

Arguments:

    Context - A pointer to the oplock_completion_context.

Return Value:

    none.


--*/

{
    PMINIRDR_OPLOCK_COMPLETION_CONTEXT cc = Context;
    PIRP Irp = cc->OplockIrp;
    RXSTATUS Status = Irp->IoStatus.Status;
    ULONG Information = Irp->IoStatus.Information;
    PSRV_OPEN SrvOpen = cc->SrvOpen;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
    PFCB Fcb = SrvOpen->Fcb;
    PUNICODE_STRING FileName = &(Fcb->PrefixEntry.Prefix);
    ULONG IoControlCode;

    RxDbgTrace( +1, Dbg,("MRxLocalComputeNewState:   Irp=%08lx, SrvOpen=%08lx\n",Irp,SrvOpen));
    RxDbgTrace(  0, Dbg,("     Status=%08lx, Info=%08lx\n",Status,Information));
    RxDbgTrace(  0, Dbg,("     fcb=%08lx, cond=%08lx, handle=%08lx\n",
                                Fcb,SrvOpen->Condition,localSrvOpen->UnderlyingHandle));

    ASSERT (Status != STATUS_CANCELLED);

    cc->OplockBreakPending = FALSE; //don't need the spinlock here

    if (!NT_SUCCESS(Status)
         || (localSrvOpen->UnderlyingHandle == INVALID_HANDLE)
         || (SrvOpen->Condition != Condition_Good)       ) {

        //here we never had an oplock....or the SrvOpen is no longer good. in this latter
        //case we probably are being broken by a close and we don't need to ack!
        //just finalize and get out

        MRxLocalFinalizeOplockContext(cc);
        RxDbgTrace( -1, Dbg,("MRxLocalComputeNewState:   Never had it or bad condition%c\n",'!'));
        SrvOpen->BufferingFlags = 0;
        localSrvOpen->OplockState = OplockStateNone;
        return;
    }


    // here, we need to ack the break

    //if (Information = FILE_OPLOCK_BROKEN_TO_NONE) {
    //    IoControlCode = FSCTL_OPLOCK_BREAK_ACKNOWLEDGE;
    //} else {
    //    IoControlCode = FSCTL_OPLOCK_BREAK_ACK_NO_2;
    //}
    IoControlCode = FSCTL_OPLOCK_BREAK_ACK_NO_2;   //for now

    //joejoe the following comment is wrong!!!!!
    //joejoe the code in the forceclosed routine is piggybacking this event
    // if we change this we may have to change that too

    cc->RetryForLevelII = FALSE;
    KeResetEvent(&cc->RetryEvent);
    //this will return pending if the guy is in a cleanup!
    Irp = MRxLocalBuildXxxCtlIrp(
                      Irp,             // PIRP irp OPTIONAL,
                      localSrvOpen->UnderlyingFileObject,  // IN PFILE_OBJECT FileObject,
                      IoControlCode,   // IN ULONG IoControlCode,
                      NULL,            // IN PVOID InputBuffer OPTIONAL,
                      0,               // IN ULONG InputBufferLength,
                      NULL,            // IN PVOID OutputBuffer OPTIONAL,
                      0,               // IN ULONG OutputBufferLength,
                      FALSE,           // IN BOOLEAN DeviceIoControl,
                      MRxLocalOplockBreakCompletionRoutine, // IN PIO_COMPLETION_ROUTINE CompletionRoutine,
                      cc               // IN PVOID Context
                    );

    localSrvOpen->OplockState = OplockStateNone;

    Status = IoCallDriver(
                 localSrvOpen->UnderlyingDeviceObject,
                 Irp
                 );

    KeWaitForSingleObject(&cc->RetryEvent, WaitAny, UserMode, FALSE, NULL);

    RxDbgTrace ( 0, Dbg,("MRxLocalComputeNewState:  return from obbreak acknowledge\n"));
    RxDbgTrace ( 0, Dbg,("    -----------> File=%wZ, Irp=%08lx, Status =%08lx, Info=%08lx\n",
                                 FileName, Irp, Irp->IoStatus.Status, Irp->IoStatus.Information));

    if ( (Irp->IoStatus.Status) != RxStatus(SUCCESS) ) {
        RxDbgTrace ( 0, Dbg, ("   ----->>>>>  Oplock ack NOT!@!!!!! successful!!!!******\n"));
    }

    MRxLocalFinalizeOplockContext(cc);
    RxDbgTrace( -1, Dbg,("MRxLocalComputeNewState:   exit%c\n",'!'));
    SrvOpen->BufferingFlags = MRxLocalTranslateStateToBufferMode[localSrvOpen->OplockState];
    return;
}


VOID
MRxLocalOplockBreak (
    IN PVOID Context
    )

/*++

Routine Description:

    This is the routine that actually processes an oplock break. If we come here
    then there was and oplock and it's now being broken....we don't come here if we didn't
    get the oplock. What we do is to call our newstate routine thru a wrapper provided by the
    RDBSS to get the resource. After we get back here we can finish up....like responding to the
    breaker (if we're on the net).

Arguments:

    Context - A pointer to the oplock_completion_context.

Return Value:

    none.


--*/

{
    PMINIRDR_OPLOCK_COMPLETION_CONTEXT cc = Context;
    PSRV_OPEN SrvOpen = cc->SrvOpen;
#ifdef RDBSSDBG
    PIRP Irp = cc->OplockIrp;
    RXSTATUS Status = Irp->IoStatus.Status;
    ULONG Information = Irp->IoStatus.Information;
#endif

    ASSERT (NodeType(SrvOpen)==RDBSS_NTC_SRVOPEN);
    RxDbgTrace( +1, Dbg,("MRxLocalOplockbreak: MRXOPENCLOSE  Irp=%08lx, SrvOpen=%08lx\n",Irp,SrvOpen));
    RxDbgTrace( 0, Dbg,("MRxLocalOplockbreak: MRXOPENCLOSE  Filename=%wZ\n",&SrvOpen->Fcb->PrefixEntry.Prefix));
    RxDbgTrace( 0, Dbg,("                                Status=%08lx, Info=%08lx\n",Status,Information));

    RxChangeBufferingState(SrvOpen,MRxLocalComputeNewState,cc);

    RxDbgTrace(-1, Dbg, ("MRxLocalOplockBreak SrvOPen=%08lx Fcb=%08lx, FcbState=%08lx\n",
                           SrvOpen, SrvOpen->Fcb, SrvOpen->Fcb->FcbState));

    //cant't do this here....don't have the resource
    //MRxLocalFinalizeOplockContext(cc);

    return;
}

RXSTATUS
MRxLocalOplockBreakCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine oplock acknowledgements. We just signal the event and get out

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    Context - oplock context containing the event to be signaled

Return Value:

    RXSTATUS - If RxStatus(MORE_PROCESSING_REQUIRED) is returned.


--*/

{
    PMINIRDR_OPLOCK_COMPLETION_CONTEXT cc = Context;

    //UNLOCKABLE_CODE( 8FIL );        joejoe ask chuck about this

    ASSERT (NodeType(cc->SrvOpen)==RDBSS_NTC_SRVOPEN);

    DeviceObject;   // prevent compiler warnings

    RxDbgTrace( 0, Dbg, ("Oplock Break Completion on %08lx\n", cc->SrvOpen ));

    KeSetEvent(&cc->RetryEvent, IO_NO_INCREMENT, FALSE );

    return RxStatus(MORE_PROCESSING_REQUIRED);
}

RXSTATUS
MRxLocalOplockCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine oplock requests. if we get error and if retry is
    desired we signal the retryevent and get out. otherwise we get to a thread. It must
    seem we could finalize from here. No, because we have to have the fcbresource to finalize!

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    Context - A pointer to a ptr to the retryevent; we actually pass the srvopen too
              but it's only for the message. for debugging, we also pass in the irpsp
              and compare it BUT ONLY IN THE ERROR CASE.

Return Value:

    RXSTATUS - If RxStatus(MORE_PROCESSING_REQUIRED) is returned, I/O
        completion processing by IoCompleteRequest terminates its
        operation.  Otherwise, IoCompleteRequest continues with I/O
        completion.  so, we always return S_M_P_R to halt processing!!!


--*/

{
    PMINIRDR_OPLOCK_COMPLETION_CONTEXT cc = Context;
    PSRV_OPEN SrvOpen;

    //UNLOCKABLE_CODE( 8FIL );        joejoe ask chuck about this

    KIRQL oldIrql;

    KeAcquireSpinLock( &MrxLocalOplockSpinLock, &oldIrql );
    SrvOpen = cc->SrvOpen;
    ASSERT (!SrvOpen || NodeType(SrvOpen)==RDBSS_NTC_SRVOPEN);

    RxDbgTrace( 0, Dbg, ("Oplock Completion cc/so/st/info %08lx %08lx %08lx %08lx\n",
                         cc, SrvOpen, Irp->IoStatus.Status, Irp->IoStatus.Information ));
    RxLog(('poz',1,cc,SrvOpen));

    // If a level I oplock request failed, and
    // we want to retry for level II, simply set the oplock retry event
    // and dismiss IRP processing.  Otherwise, we have to queue to a thread to
    // figure out how to get rid of our buffering state.


    if ( !NT_SUCCESS(Irp->IoStatus.Status)
         && cc->RetryForLevelII ) {

        //
        // Set the event that tells the oplock request routine that it
        // is OK to retry the request.
        //

        RxDbgTrace( 0, Dbg, ("Oplock Retry Event signal on %08lx, event=%08lx\n",
                     SrvOpen, &cc->RetryEvent ));

        KeReleaseSpinLock( &MrxLocalOplockSpinLock, oldIrql );
        KeSetEvent(&cc->RetryEvent, IO_DISK_INCREMENT, FALSE );

        return RxStatus(MORE_PROCESSING_REQUIRED);

    } else {

        PIO_STACK_LOCATION IrpSp = IoGetNextIrpStackLocation(Irp);
        PWORK_QUEUE_ITEM wkitem = (PWORK_QUEUE_ITEM)(IrpSp);

        cc->OplockBreakPending = TRUE;
        KeReleaseSpinLock( &MrxLocalOplockSpinLock, oldIrql );

        //joejoe this is bull.............i should have cancelled the irp instead.
        if (SrvOpen && ( ((PMRX_LOCAL_SRV_OPEN)SrvOpen)->UnderlyingHandle!=INVALID_HANDLE)) {
            RxDbgTrace( 0, Dbg, ("Posting Oplock Break SrvOpen = %08lx\n", cc->SrvOpen));

            // i need a work_queue_item to post this to a thread. so......we'll use the
            // parameters for the next stack location as a workqueueitem!

            ASSERT (sizeof(IO_STACK_LOCATION)>=sizeof(WORK_QUEUE_ITEM));
            ExInitializeWorkItem( wkitem, MRxLocalOplockBreak, cc );
            ExQueueWorkItem( wkitem, CriticalWorkQueue ); //joejoe maybe i should use delayed
        } else {
            //just get rid of the context...since no srvopen, i don't need the fcb resource
            MRxLocalFinalizeOplockContext(cc);
        }

    }

    return RxStatus(MORE_PROCESSING_REQUIRED);

    UNREFERENCED_PARAMETER(DeviceObject);   // prevent compiler warnings

}

VOID
MRxLocalGetFileObjectFromHandle(
    IN  PMRX_LOCAL_SRV_OPEN localSrvOpen,
    IN  HANDLE handle
    )
/*++

Routine Description:

    This routines gets a PFILE_OBJECT for the file handle stored in the SRV_OPEN and stores it back.

Arguments:

    localSrvOpen - the srvopen to do this for


Return Value:

    none

--*/

{
    RXSTATUS Status;
    //
    // Reference the file object to get the pointer
    //

    ASSERT (localSrvOpen->OriginalProcess == PsGetCurrentProcess());

    Status = ObReferenceObjectByHandle( handle, //localSrvOpen->UnderlyingHandle,
                                        0L,
                                        NULL,
                                        KernelMode,
                                        (PVOID *) &localSrvOpen->UnderlyingFileObject,
                                        NULL );
    ASSERT(NT_SUCCESS(Status));
    return;

}


PIRP
MRxLocalBuildXxxCtlIrp(
    IN PIRP irp OPTIONAL,
    IN PFILE_OBJECT fileObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN DeviceIoControl,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID Context
    )

/*++

Routine Description:

    This routines builds an Irp to submit an fsctl/ioctl to a lower component
    that is identified by a file handle.

Arguments:

    irp - either an irp to use or NULL to allocate an Irp //***THIS REQUIRES KNOWLEDGE OF IrpStructure**joejoe
                                                          //joejoe in fact, i don't reinitialize after using;
                                                          // maybe a problem

    FileObject - file that we're doing this fsctl on.

    IoControlCode - Subfunction code to determine exactly what operation is
        being performed.

    InputBuffer - Optionally supplies an input buffer to be passed to the
        driver.  Whether or not the buffer is actually optional is dependent
        on the IoControlCode.

    InputBufferLength - Length of the InputBuffer in bytes.

    OutputBuffer - Optionally supplies an output buffer to receive information
        from the driver.  Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    OutputBufferLength - Length of the OutputBuffer in bytes.

    DeviceIoControl - Determines whether this is a Device or File System
        Control function.

    CompletionRoutine - the IrpCompletionRoutine
    Context - context of the completion routine

Return Value:

    The status returned is success if the control operation was properly
    queued to the I/O system.   Once the operation completes, the status
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    ULONG method;

    PAGED_CODE();

    //
    // Get the method that the buffers are being passed.
    //

    method = IoControlCode & 3;

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    if (irp) {
        ASSERT( irp->StackCount >= deviceObject->StackSize );
    } else {
        irp = IoAllocateIrp( deviceObject->StackSize, TRUE );  //joejoe should i charge quota??
    }

    if (!irp) {

        //
        // An IRP could not be allocated.

        return NULL;
    }

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = DeviceIoControl ? IRP_MJ_DEVICE_CONTROL : IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->FileObject = fileObject;      //ok4->FileObj
    irpSp->DeviceObject = deviceObject;

    {   BOOLEAN EnableCalls = CompletionRoutine!=NULL;

        IoSetCompletionRoutine(irp, CompletionRoutine, Context,
                                EnableCalls,EnableCalls,EnableCalls);
    }


    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    irp->MdlAddress = (PMDL) NULL;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;

    switch ( method ) {

    case 0:

        //
        // For this case, allocate a buffer that is large enough to contain
        // both the input and the output buffers.  Copy the input buffer
        // to the allocated buffer and set the appropriate IRP fields.
        //

        if (InputBufferLength != 0 || OutputBufferLength != 0) {
            irp->AssociatedIrp.SystemBuffer = RxAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                                     InputBufferLength > OutputBufferLength ? InputBufferLength : OutputBufferLength,
                                                                     '  oI' );
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }
            if (ARGUMENT_PRESENT( InputBuffer )) {
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                               InputBuffer,
                               InputBufferLength );
            }
            irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            irp->UserBuffer = OutputBuffer;
            if (ARGUMENT_PRESENT( OutputBuffer )) {
                irp->Flags |= IRP_INPUT_OPERATION;
            }
        } else {
            irp->Flags = 0;
            irp->UserBuffer = (PVOID) NULL;
        }

        break;

    case 1:
    case 2:

        //
        // For these two cases, allocate a buffer that is large enough to
        // contain the input buffer, if any, and copy the information to
        // the allocated buffer.  Then build an MDL for either read or write
        // access, depending on the method, for the output buffer.  Note
        // that an output buffer must have been specified.
        //

        if (ARGUMENT_PRESENT( InputBuffer )) {
            irp->AssociatedIrp.SystemBuffer = RxAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                                     InputBufferLength,
                                                                     'CxRS' );
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }
            RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                           InputBuffer,
                           InputBufferLength );
            irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
        } else {
            irp->Flags = 0;
        }

        if (ARGUMENT_PRESENT( OutputBuffer )) {
            irp->MdlAddress = IoAllocateMdl( OutputBuffer,
                                             OutputBufferLength,
                                             FALSE,
                                             FALSE,
                                             (PIRP) NULL );
            if (irp->MdlAddress == NULL) {
                if (ARGUMENT_PRESENT( InputBuffer )) {
                    ExFreePool( irp->AssociatedIrp.SystemBuffer );
                }
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }
            MmProbeAndLockPages( irp->MdlAddress,
                                 KernelMode,
                                 (LOCK_OPERATION) ((method == 1) ? IoReadAccess : IoWriteAccess) );
        }

        break;

    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        irp->UserBuffer = OutputBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
    }

    return(irp);

}

BOOLEAN
MRxLocalRequestOplock (
    IN PSRV_OPEN SrvOpen,
    IN MINIRDR_OPLOCK_TYPE OplockType,
    IN BOOLEAN RequestIIOnFailure
    )

/*++

Routine Description:

    This function will attempt to request an oplock if the oplock was
    requested.  The only thing tricky here is the freeing of the oplockcontext. Until it has been
    submitted, this routine has the responsibility to finalize the context. Once it has been
    submitted (IoCallDriver), the packet will be finalized by the completion routine or by the oplock
    break routines. We use the presence of srvopen in the packet to tell.....

Arguments:

    SrvOpen - The SRV_OPEN on which to make the request.
    OplockType - Pointer to the oplock type being requested.  If the
        request was successful, this will contain the type of oplock
        that was obtained.
    RequestIIOnFailure - If TRUE, a level II oplock will be requested in
                         case the original request was denied.

Return Value:

    TRUE - The oplock was obtained.
    FALSE - The oplock was not obtained.

--*/


{
    RXSTATUS Status;
    BOOLEAN OplockGranted;
    ULONG ioControlCode;
    PMINIRDR_OPLOCK_COMPLETION_CONTEXT cc;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
    PMINIRDR_OPLOCK_STATE OplockState = &localSrvOpen->OplockState;
    MINIRDR_OPLOCK_STATE NewOplockState;
    PUNICODE_STRING FileName = &(SrvOpen->Fcb->PrefixEntry.Prefix);

    PAGED_CODE( );

//    if ( !SrvEnableOplocks && (*OplockType != OplockTypeServerBatch) ) {
//        return FALSE;
//    }

    //
    // If we already have an oplock, because this is a reclaiming of a
    // cached open, then we don't need to request one now.
    //

    if (NodeType(SrvOpen->Fcb) != RDBSS_NTC_STORAGE_TYPE_FILE) {
        return(FALSE);
    }
    //ASSERT(FALSE & FALSE);

    if ( *OplockState != OplockStateNone ) {
        RxDbgTrace( 0, Dbg,("MRxLocalRequestOplock: already own server oplock for %wZ\n",
                        FileName));
        ASSERT( ((*OplockState == OplockStateOwnBatch) &&
                 (OplockType == OplockTypeBatch)) );
        return TRUE;
    }

    RxDbgTrace(+1, Dbg,("MRxLocalRequestOplock: trying for oplock. SrvO= %08lx"
                     "file %wZ\n", SrvOpen, FileName));
    //
    // Set the  oplock state to the type of oplock we are requesting.

    if ( OplockType == OplockTypeExclusive ) {

        NewOplockState = OplockStateOwnExclusive;
        ioControlCode = FSCTL_REQUEST_OPLOCK_LEVEL_1;

    } else if ( OplockType == OplockTypeBatch ) {

        NewOplockState = OplockStateOwnBatch;
        ioControlCode = FSCTL_REQUEST_BATCH_OPLOCK;

    } else if ( OplockType == OplockTypeShareRead ) {

        NewOplockState = OplockStateOwnLevelII;
        ioControlCode = FSCTL_REQUEST_OPLOCK_LEVEL_2;

    } else {
        ASSERT(0);
        return(FALSE);
    }

    cc = RxAllocatePoolWithTag( NonPagedPool, sizeof(MINIRDR_OPLOCK_COMPLETION_CONTEXT), 'CCxR' );
    if (!cc) {
        RxDbgTrace( -1, Dbg,("MRxLocalRequestOplock: oplock attempt failed, "
                           "could not allocate context for %wZ\n", FileName));
        *OplockState = OplockStateNone;     //maybe we shouldn't change it
        return FALSE;
    }
    RtlZeroMemory(cc,sizeof(MINIRDR_OPLOCK_COMPLETION_CONTEXT));

    try {
        //
        // Generate and issue the oplock request IRP. This leaves a reference on the fileObj.

        cc->OplockIrp = MRxLocalBuildXxxCtlIrp(
                          NULL,                 // IN PIRP Irp OPTIONAL,
                          localSrvOpen->UnderlyingFileObject,       // IN PFILE_OBJECT FileObject,
                          ioControlCode,        // IN ULONG IoControlCode,
                          NULL,                 // IN PVOID InputBuffer OPTIONAL,
                          0,                    // IN ULONG InputBufferLength,
                          NULL,                 // IN PVOID OutputBuffer OPTIONAL,
                          0,                    // IN ULONG OutputBufferLength,
                          FALSE,                // IN BOOLEAN DeviceIoControl,
                          MRxLocalOplockCompletionRoutine, // IN PIO_COMPLETION_ROUTINE CompletionRoutine,
                          cc               // IN PVOID Context
                        );

        if ( cc->OplockIrp == NULL ) {
            RxDbgTrace( 0, Dbg,("MRxLocalRequestOplock: oplock attempt failed, could not allocate IRP for %wZ\n",
                            FileName));
            *OplockState = OplockStateNone;
            try_return(OplockGranted = FALSE);
        }

        //
        // Initialize the oplock completion packet including the event that
        // we use to do an oplock request retry
        // in case the original request fails.  This will prevent the completion
        // routine from cleaning up the irp. Also, get rid of the reference to the
        // file object

        cc->RetryForLevelII =RequestIIOnFailure;
        if ( RequestIIOnFailure ) {
            KeInitializeEvent( &cc->RetryEvent, SynchronizationEvent, FALSE );
        }
        RxReferenceSrvOpen(SrvOpen);
        cc->SrvOpen = SrvOpen;  //from here on, the free is in finalize routine
        localSrvOpen->Mocc = cc;

        //
        // Make the actual request.

        Status = IoCallDriver(
                     localSrvOpen->UnderlyingDeviceObject,
                     cc->OplockIrp
                     );

        //
        // If the driver returns RxStatus(PENDING), the oplock was granted.
        // The IRP will complete when (1) The driver wants to break to
        // oplock or (2) The file is being closed.

        if ( Status == RxStatus(PENDING) ) {

            RxDbgTrace( 0, Dbg,("MRxLocalRequestOplock: successful for %wZ, Irp/cc=%08lx/%08lx\n",
                            FileName,cc->OplockIrp,cc));
            *OplockState = NewOplockState;
            try_return(OplockGranted = TRUE);

        } else if ( RequestIIOnFailure ) {

            //
            // The caller wants us to attempt a level II oplock request.

            RxDbgTrace( 0, Dbg,("MRxLocalRequestOplock: level1 failed...try4 level2 %wZ\n", FileName));
            //
            // Wait for the completion routine to be run.  It will set
            // an event that will signal us to go on.

            KeWaitForSingleObject(&cc->RetryEvent, Executive, UserMode, FALSE, NULL);

            //
            // The Oplock Retry event was signaled. Proceed with the retry.

            RxDbgTrace( 0, Dbg,("MRxLocalRequestOplock: retry unwaited %wZ\n", FileName));

            //
            // Generate and issue the wait for oplock IRP. clear  the eventptr so that
            //  the completion routine will clean up the irp in case of failure.

            cc->RetryForLevelII = FALSE;
            cc->OplockIrp = MRxLocalBuildXxxCtlIrp(
                              cc->OplockIrp,            // PIRP irp OPTIONAL,
                              localSrvOpen->UnderlyingFileObject,       // IN PFILE_OBJECT FileObject,
                              FSCTL_REQUEST_OPLOCK_LEVEL_2,  // IN ULONG IoControlCode,
                              NULL,                 // IN PVOID InputBuffer OPTIONAL,
                              0,                    // IN ULONG InputBufferLength,
                              NULL,                 // IN PVOID OutputBuffer OPTIONAL,
                              0,                    // IN ULONG OutputBufferLength,
                              FALSE,                // IN BOOLEAN DeviceIoControl,
                              MRxLocalOplockCompletionRoutine, // IN PIO_COMPLETION_ROUTINE CompletionRoutine,
                              cc               // IN PVOID Context
                            );

            //
            // Set the  oplockstate to the type of oplock we are requesting.
            //

            NewOplockState = OplockStateOwnLevelII;

            Status = IoCallDriver(
                         localSrvOpen->UnderlyingDeviceObject,
                         cc->OplockIrp
                         );

            //
            // If the driver returns RxStatus(PENDING), the oplock was granted.
            // The IRP will complete when (1) The driver wants to break to
            // oplock or (2) The file is being closed.
            //

            if ( Status == RxStatus(PENDING) ) {

                RxDbgTrace( 0, Dbg,("MRxLocalRequestOplock:  OplockII attempt successful %wZ, Irp=%08lx\n",
                                             FileName, cc->OplockIrp));

                *OplockState = NewOplockState;
                try_return(OplockGranted = TRUE);

            }

        }

        //
        // Oplockrequest denied was denied.

        RxDbgTrace( 0, Dbg,("MRxLocalRequestOplock:  oplock attempt unsuccessful %wZ\n", FileName));
        try_return(OplockGranted = FALSE);

 try_exit:
        NOTHING;

    } finally{

        if (!cc->SrvOpen) MRxLocalFinalizeOplockContext(cc);
        //DebugTrace(-1,Dbg,NULL,0);
        RxDbgTraceUnIndent(-1,Dbg);
    }

    return(OplockGranted);

} // MRxLocalRequestOplock


RXSTATUS
MRxLocalCreate(
    IN struct _RX_CONTEXT *RxContext
    )


/*++

Routine Description:

    This routine actually completes an open to a local file. When called, the tablelock is held and
    there is a reference on the srvopen. What the routine must do is  try to open the file.
      if not successful, then set condition to bad,
                                               unwait waiters,
                                               deref, unlock
      if successful, then
        build fobx and fix up the file object in the irp,
        adjust fcb according to any info that we have,
        set condition to good,
        unwait waiters, unlock.
        in addition, we are are oplock client! so do the oplock stuff


Arguments:


Return Value:

    RXSTATUS - The status for the IRP.

--*/

{
    RXSTATUS Status;
    PUNICODE_STRING RemainingName;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureParamBlock;
    PSRV_OPEN SrvOpen = RxContext->Create.SrvOpen;
    RX_BLOCK_CONDITION FinalCondition;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE handle;
    ULONG FilteredCreateOptions;
    BOOLEAN MustRegainExclusiveResource = FALSE;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxLocalCreate\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    //RemainingName = &(capFcb->PrefixEntry.Prefix);
    RemainingName = &(capFcb->AlreadyPrefixedName);

    RxDbgTrace( 0, Dbg, ("MRXOPENCLOSE Attempt to open %wZ\n", RemainingName ));

    InitializeObjectAttributes(
        &ObjectAttributes,
        RemainingName,
        OBJ_CASE_INSENSITIVE,  // !!! can we do this?
        0,
        NULL                   // !!! Security     joejoe
        );

    FilteredCreateOptions = capPARAMS->Parameters.Create.Options
                          & ( FILE_VALID_OPTION_FLAGS
                             & ~(FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT) ); //always async
    RxDbgTrace( 0, Dbg, (" ---->FilteredCreateOptions           = %08lx\n", FilteredCreateOptions));
    RxLog(('rcz',2,FilteredCreateOptions,capFcb->OpenCount));

    if (capFcb->OpenCount > 0) {        //this is required because of oplock breaks
        MustRegainExclusiveResource = TRUE;
        RxReleaseFcb( RxContext, capFcb );
    }

    Status = IoCreateFile(
                 &handle,
                 (SrvOpen->DesiredAccess =
                            capPARAMS->Parameters.Create.SecurityContext->DesiredAccess & 0x1FF),
                 &ObjectAttributes,
                 &IoStatusBlock,
                 &capReqPacket->Overlay.AllocationSize,      //was NULL
                 capPARAMS->Parameters.Create.FileAttributes &  FILE_ATTRIBUTE_VALID_FLAGS,
                 SrvOpen->ShareAccess =
                           capPARAMS->Parameters.Create.ShareAccess & FILE_SHARE_VALID_FLAGS,
                 (((capPARAMS->Parameters.Create.Options)) >> 24) & 0x000000ff,
                 FilteredCreateOptions,
                 capReqPacket->AssociatedIrp.SystemBuffer,               // Ea buffer
                 capPARAMS->Parameters.Create.EaLength,                  // Ea length
                 CreateFileTypeNone,
                 NULL,               // extra parameters
                 IO_NO_PARAMETER_CHECKING
                 );

    if (MustRegainExclusiveResource) {        //this is required because of oplock breaks
        RxAcquireExclusiveFcb( RxContext, capFcb );
    }

    RxDbgTrace( 0, Dbg, ("Status of underlying open %08lx\n", Status ));
    RxLog(('1cz',1,Status));
//    DbgBreakPoint();

    if (NT_SUCCESS(Status)) {

        STORAGE_TYPE StorageType;
        FILE_BASIC_INFORMATION BasicInformation;
        FILE_STANDARD_INFORMATION StandardInformation;
        IO_STATUS_BLOCK Iosb;
        RXSTATUS InfoStatus;
        PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
        FCB_INIT_PACKET InitPacket;

        RxContext->Fobx = RxCreateNetFobx( RxContext, SrvOpen);
        ((PMRX_LOCAL_SRV_OPEN)SrvOpen)->UnderlyingHandle = handle;
        localSrvOpen->OriginalThread = PsGetCurrentThread();
        localSrvOpen->OriginalProcess = PsGetCurrentProcess();
        RxDbgTrace( 0, Dbg, ("MRXOPENCLOSE OThread=%08lx, OProcess=%08lx\n",
                    localSrvOpen->OriginalThread, localSrvOpen->OriginalProcess ));
        MRxLocalGetFileObjectFromHandle(localSrvOpen, handle); //this leaves a refernce!
        localSrvOpen->UnderlyingDeviceObject = IoGetRelatedDeviceObject( localSrvOpen->UnderlyingFileObject );
        capReqPacket->IoStatus.Information = IoStatusBlock.Information;
        FinalCondition = Condition_Good;

        ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
        StorageType = RxInferStorageType(RxContext);
        RxDbgTrace( 0, Dbg, ("Storagetype %08lx\n", StorageType ));

        if (capFcb->OpenCount == 0) {
            InfoStatus = ZwQueryInformationFile(handle, &Iosb,
                                   &BasicInformation,sizeof(BasicInformation),
                                   FileBasicInformation);
            if (!NT_SUCCESS(InfoStatus)){
                RxDbgTrace( 0, Dbg, ("Status of basicinfo %08lx\n", InfoStatus ));
            }
            InfoStatus = ZwQueryInformationFile(handle, &Iosb,
                                   &StandardInformation,sizeof(StandardInformation),
                                   FileStandardInformation);
            if (!NT_SUCCESS(InfoStatus)){
                RxDbgTrace( 0, Dbg, ("Status of stdinfo %08lx\n", InfoStatus ));
            }
            if (StorageType == 0) {
                StorageType = StandardInformation.Directory?(StorageTypeDirectory)
                                                           :(StorageTypeFile);
                RxDbgTrace( 0, Dbg, ("ChangedStoragetype %08lx\n", StorageType ));
            }
            RxFinishFcbInitialization( capFcb, StorageType,
                                            RxFormInitPacket(InitPacket, //note no &
                                                &BasicInformation.FileAttributes,
                                                &StandardInformation.NumberOfLinks,
                                                &BasicInformation.CreationTime,
                                                &BasicInformation.LastAccessTime,
                                                &BasicInformation.LastWriteTime,
                                                &StandardInformation.AllocationSize,
                                                &StandardInformation.EndOfFile,
                                                &StandardInformation.EndOfFile)
                                     );
            if (!MRxLocalNoOplocks) MRxLocalRequestOplock(SrvOpen,MRxOplockRequestType,MRxRequestLevelII);
            RxDbgTrace( 0, Dbg, ("MRxLocalCreate      oplockstate =%08lx\n", localSrvOpen->OplockState ));
            SrvOpen->BufferingFlags = MRxLocalTranslateStateToBufferMode[localSrvOpen->OplockState];

        } else {

            ASSERT( StorageType == 0 || NodeType(capFcb) ==  RDBSS_STORAGE_NTC(StorageType));

        }

        //only one transition since both use same event
        capFcb->Condition = Condition_Good;
        RxTransitionSrvOpen(SrvOpen, Condition_Good);

    } else { //open din't work

        if (!StableCondition(capFcb->Condition)) {
            capFcb->Condition = Condition_Closed;
        }
        RxTransitionSrvOpen(SrvOpen, Condition_Bad);  //keep for awhile

    }

    RxDbgTrace(-1, Dbg, ("MRxLocalCreate   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    return Status;
}

//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//
//  The local debug trace level
//

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  Internal support routine
//
RXSTATUS
MRxLocalCleanup (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine implements the cleanup portion of a close

Arguments:

Return Value:

    RXSTATUS - Returns the status for the query

--*/

{
    RXSTATUS Status = RxStatus(SUCCESS);
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
    BOOLEAN AttachedToProcess = FALSE;

    RxLog(('ncz',1,SrvOpen));
    ASSERT (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT));
    ASSERT (localSrvOpen->UnderlyingFileObject);

    if (capFobx->SrvOpen->UncleanCount > 1) {  return Status; }

    RxDbgTrace(+1, Dbg, ("MRxLocalCleanup...last\n", 0));

    if (PsGetCurrentProcess()!=localSrvOpen->OriginalProcess) {
        RxDbgTrace( 0, Dbg, ("MRXOPENCLOSE about to attach in cleanup oprocess=%08lx\n",
                             localSrvOpen->OriginalProcess ));
        ASSERTMSG("According to my understanding, this shouldn't be happening!\n",FALSE);
        KeAttachProcess(localSrvOpen->OriginalProcess);
        AttachedToProcess = TRUE;
    }
    Status = ZwClose(localSrvOpen->UnderlyingHandle);
    ASSERT(NT_SUCCESS(Status));
    if (AttachedToProcess) {
        KeDetachProcess();
    }


    localSrvOpen->UnderlyingHandle = INVALID_HANDLE;

    RxDbgTrace( -1, Dbg, ( " ---->Status               = %08lx\n", Status));

    return Status;
}



RXSTATUS
MRxLocalClose (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine implements the close portion of a close

Arguments:

Return Value:

    RXSTATUS - Returns the status for the query

--*/

{
    RXSTATUS Status = RxStatus(SUCCESS);
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;

    ASSERT (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT));
    ASSERT (localSrvOpen->UnderlyingFileObject);

    RxLog(('lcz',1,SrvOpen));
    if (SrvOpen->OpenCount > 1) {  return RxStatus(SUCCESS); }

    RxDbgTrace(+1, Dbg, ("MRxLocalClose...with CLOSE\n", 0));

    ASSERT (localSrvOpen->UnderlyingHandle == INVALID_HANDLE);

    Status = MRxLocalForceClosed(SrvOpen);

    //DebugTrace( -1, Dbg, NULL, 0);
    RxDbgTraceUnIndent(-1,Dbg);
    return ( Status );
}


RXSTATUS
MRxLocalForceClosed (
    IN PSRV_OPEN SrvOpen
    )
/*++

Routine Description:

    This routine is called during a forced finalization.

Arguments:

    SrvOpen - the srvopen being forced closed

Return Value:

    none

--*/

{
    RXSTATUS Status = RxStatus(SUCCESS);
    IO_STATUS_BLOCK Iosb;
    PMRX_LOCAL_SRV_OPEN localSrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;
    PMINIRDR_OPLOCK_COMPLETION_CONTEXT cc = localSrvOpen->Mocc;
    PFCB Fcb = SrvOpen->Fcb;
    KIRQL oldIrql;
    BOOLEAN OplockBreakPending;



    RxLog(('fcz',1,SrvOpen));

    RxDbgTrace(+1, Dbg, ("MRxLocalForceClosed..srvopen=%08lx\n", SrvOpen));

    if (localSrvOpen->UnderlyingFileObject) {

        RxDbgTrace( 0, Dbg, ("MRXOPENCLOSE Attempt to forceclose %wZ\n", &(Fcb->AlreadyPrefixedName) ));

        if (cc) {
            ASSERTMSG("Joejoe the right way to do this would be to CANCEL!!!!!!!!",FALSE);
            //since this is a force closed, we get rid of a pending break
            KeAcquireSpinLock( &MrxLocalOplockSpinLock, &oldIrql );
            OplockBreakPending = cc->OplockBreakPending;
            if (!OplockBreakPending) {
                cc->SrvOpen = NULL;
            }
            KeReleaseSpinLock( &MrxLocalOplockSpinLock, oldIrql );
            if (!OplockBreakPending) {
                //gotta lose the spinlock befoer the call
                RxDereferenceSrvOpen(SrvOpen); //elim ref!
            }
        } else {
            ASSERT (localSrvOpen->OplockState == OplockStateNone);
        }

        RxLog(('1fz',0));

        ObDereferenceObject(localSrvOpen->UnderlyingFileObject);

        localSrvOpen->UnderlyingFileObject = NULL;

        SrvOpen->Condition = Condition_Closed;
        RxLog(('!fz',0));
    }

    RxDbgTrace( -1, Dbg, (" ---->Status               = %08lx\n", 0));

    return ( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\local_nt.mrx\precomp.h ===
#include "mrxlcl0.h"
#include "rxprocs.h"
#include "mrxlocal.h"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\local_nt.mrx\netname.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NetName.c

Abstract:

    This module implements the local minirdr routines for initializing the dispatch vector
    and delaing with netnames.

Author:

    Joe Linn      [JoeLinn]      4-dec-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "fsctlbuf.h"
#include "NtDdNfs2.h"
#include "stdio.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_NETNAME)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DISPATCH)

BOOLEAN   //this is just a copy of the routine from string.c
RxCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING DestinationString,
    IN PCSZ SourceString
    )
{
    ANSI_STRING AnsiString;
    RXSTATUS Status;

    RtlInitAnsiString( &AnsiString, SourceString );
    Status = RtlAnsiStringToUnicodeString( DestinationString, &AnsiString, TRUE );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}

PSRV_CALL MrxLocalSrvCall;
RXSTATUS MRxLocalStart(
    PRX_CONTEXT RxContext,
    PVOID Context
    )
/*++

Routine Description:

     This routine sets up some initial (debug) netroots

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss and may contain a startup
                 linkage description

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RXSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    UNICODE_STRING MrxLocalSrvCallName,MyNetRootName,MyInnerPrefix;
    PNET_ROOT DosDevicesNetRoot,MyNetRoot;
    char c;

#ifdef RDBSSDBG
        ULONG SaveFCBSTRUCTSLevel;
        ULONG SavePREFIXLevel;
#endif // RDBSSDBG

    //local minirdr UNC stuff

    RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE );


#ifdef RDBSSTRACE
    SaveFCBSTRUCTSLevel = RxDbgTraceFindControlPoint((DEBUG_TRACE_FCBSTRUCTS))->PrintLevel;
    SavePREFIXLevel = RxDbgTraceFindControlPoint((DEBUG_TRACE_PREFIX))->PrintLevel;
    RxDbgTraceFindControlPoint((DEBUG_TRACE_FCBSTRUCTS))->PrintLevel = 0;
    RxDbgTraceFindControlPoint((DEBUG_TRACE_PREFIX))->PrintLevel = 0;
#endif // RDBSSTRACE

//joejoe we should be allocating our initial srvcall adn netroot together
    RtlInitUnicodeString(&MrxLocalSrvCallName,L"\\RX$$");
    MrxLocalSrvCall = RxCreateSrvCall(&MrxLocalSrvCallName,&MRxLocalDispatch,FALSE,
                                NULL,NULL,sizeof(FCB),sizeof(MRX_LOCAL_SRV_OPEN),sizeof(FOBX),0
                                );
    MrxLocalSrvCall->Condition = Condition_Good;


#ifdef RDBSSTRACE
    RxDbgTraceFindControlPoint((DEBUG_TRACE_FCBSTRUCTS))->PrintLevel = SaveFCBSTRUCTSLevel;
    RxDbgTraceFindControlPoint((DEBUG_TRACE_PREFIX))->PrintLevel = SavePREFIXLevel;
#endif // RDBSSTRACE

    RxReleasePrefixTableLock( &RxNetNameTable );

    return(RxStatus(SUCCESS));
}

RXSTATUS
MRxLocalMinirdrControl(
    IN PRX_CONTEXT RxContext,
    IN PVOID Context,
    IN OUT PUCHAR InputBuffer,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    OUT PULONG CopyBackLength
    )
/*++

Routine Description:

     This routine does nothing.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss and may contain a startup
                 linkage description

Return Value:

    RxStatus(SUCCESS)

--*/
{
    RXSTATUS Status = RxStatus(SUCCESS);
    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("MRxLocalMinirdrControl %-4.4s %-4.4s <%s>\n",
                           InputBuffer, InputBuffer+4,
                            ((OutputBuffer)?OutputBuffer:"")
               ));

    return(RxStatus(SUCCESS));
}

RXSTATUS MRxLocalStop(
    PRX_CONTEXT RxContext,
    PVOID Context
    )
/*++

Routine Description:

     This routine does nothing.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss and may contain a startup
                 linkage description

Return Value:

    RxStatus(SUCCESS)

--*/
{
    //RXSTATUS Status;

    return(RxStatus(SUCCESS));
}

RXSTATUS MRxLocalInitializeCalldownTable(
    void
    )
/*++

Routine Description:

     This routine does two things sets up the minirdr dispatch table for the local minirdr.
Arguments:


Return Value:

    RXSTATUS - The return status for the operation, alayws success

--*/
{
    RXSTATUS Status;

    //local minirdr dispatch table init
    ZeroAndInitializeNodeType( &MRxLocalDispatch, RDBSS_NTC_MINIRDR_DISPATCH, sizeof(MINIRDR_DISPATCH));
    MRxLocalDispatch.MRxStart = MRxLocalStart;
    MRxLocalDispatch.MRxStop = MRxLocalStop;
    MRxLocalDispatch.MRxMinirdrControl = MRxLocalMinirdrControl;
    MRxLocalDispatch.MRxCreate = MRxLocalCreate;
    MRxLocalDispatch.MRxFlush = MRxLocalFlush;
    MRxLocalDispatch.MRxQueryDirectory = MRxLocalQueryDirectory;

    MRxLocalDispatch.MRxLowIOSubmit[LOWIO_OP_READ] = MRxLocalRead;
    MRxLocalDispatch.MRxLowIOSubmit[LOWIO_OP_WRITE] = MRxLocalWrite;
    MRxLocalDispatch.MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK] = MRxLocalLocks;
    MRxLocalDispatch.MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK] = MRxLocalLocks;
    MRxLocalDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK] = MRxLocalLocks;
    MRxLocalDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCKALL] = MRxLocalLocks;
    MRxLocalDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCKALLBYKEY] = MRxLocalLocks;

    MRxLocalDispatch.MRxExtendForCache = MRxLocalExtendForCache;
    MRxLocalDispatch.MRxCleanup = MRxLocalCleanup;
    MRxLocalDispatch.MRxClose = MRxLocalClose;
    MRxLocalDispatch.MRxForceClosed = MRxLocalForceClosed;

    MRxLocalDispatch.MRxQueryVolumeInfo = MRxLocalQueryVolumeInformation;
    //MRxLocalDispatch.MRxSetVolumeInfo = MRxLocalSetVolumeInformation;
    MRxLocalDispatch.MRxQueryFileInfo = MRxLocalQueryFileInformation;
    MRxLocalDispatch.MRxSetFileInfo = MRxLocalSetFileInformation;
    MRxLocalDispatch.MRxSetFileInfoAtCleanup = MRxLocalSetFileInfoAtCleanup;

    MRxLocalDispatch.MRxAssertBufferedFileLocks = MRxLocalAssertBufferedFileLocks;

    MRxLocalDispatch.MRxCreateNetRoot = MRxLocalCreateNetRoot;
    MRxLocalDispatch.MRxCreateSrvCall = MRxLocalCreateSrvCall;
    MRxLocalDispatch.MRxSrvCallWinnerNotify = MRxLocalSrvCallWinnerNotify;

    MRxLocalDispatch.MRxTransportUpdateHandler = NULL;

    return(RxStatus(SUCCESS));
}


////
////  The local debug trace level
////
//
//#undef  Dbg
//#define Dbg                              (DEBUG_TRACE_CREATE)

RXSTATUS MRxLocalCreateNetRoot(
    IN PRX_CONTEXT                RxContext,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

     This routine looks for a device that it can setup as a local netroot.
     we can touch any field except the condition. any name that is not exactly
     one character long will fail.

Arguments:

    RxContext - Supplies the context of the original create/ioctl

    CallBack  - a routine that we call when we're finished.  if we returned
                pending, we would have to get to a thread to call. of course,
                we would have had to mark pending as well.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RXSTATUS Status;
    PNET_ROOT NetRoot = RxContext->Create.NetRoot;
    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    UNICODE_STRING MyInnerPrefix;
    PUNICODE_STRING NetRootName,SrvCallName;
    WCHAR c;
    ULONG Length,PoolAllocSize;

    ASSERT( NodeType(NetRoot) == RDBSS_NTC_NETROOT );
    ASSERT( NodeType(NetRoot->SrvCall) == RDBSS_NTC_SRVCALL );

    NetRootName = &NetRoot->PrefixEntry.Prefix;
    SrvCallName = &NetRoot->SrvCall->PrefixEntry.Prefix;

    Length = NetRootName->Length - SrvCallName->Length;
    c = NetRootName->Buffer[(NetRootName->Length/sizeof(WCHAR))-1];

    RxDbgTrace(0, Dbg, ("MRxLocalCreateNetRoot %wZ, length,c=%08lx<%02x>\n", NetRootName, Length, c));

    PoolAllocSize = sizeof(L"\\dosdevices\\d:")-sizeof(WCHAR);

    if ( (Length == 4) &&
          (MyInnerPrefix.Buffer = RxAllocatePoolWithTag(NonPagedPool,PoolAllocSize,'pixR'))
       )  {
        MyInnerPrefix.Length = 0;
        MyInnerPrefix.MaximumLength = (USHORT)PoolAllocSize;
        RtlAppendUnicodeToString(&MyInnerPrefix,L"\\dosdevices\\d:");
        MyInnerPrefix.Buffer[(MyInnerPrefix.Length/sizeof(WCHAR))-2] = (WCHAR)c;
        RxDbgTrace(0, Dbg, ("MRxLocalCreateNetRoot InnerPrefix=%wZ,buf=%08lx\n", &MyInnerPrefix, MyInnerPrefix.Buffer));
        RxFinishNetRootInitialization(NetRoot,&MRxLocalDispatch,
                        &MyInnerPrefix,
                        sizeof(FCB),sizeof(MRX_LOCAL_SRV_OPEN),sizeof(FOBX),
                        NETROOT_FLAG_DEVICE_NETROOT|NETROOT_FLAG_EXTERNAL_INNERNAMEPREFIX
                       );
        NetRoot->DeviceType = RxDeviceType(DISK);
        pCreateNetRootContext->Condition = Condition_Good;
        pCreateNetRootContext->Callback(RxContext,pCreateNetRootContext);
    } else {
        pCreateNetRootContext->Condition = Condition_Bad;
        pCreateNetRootContext->Callback(RxContext,pCreateNetRootContext);
    }

    return STATUS_PENDING;
}

RXSTATUS
MRxLocalCreateSrvCall(
    IN PRX_CONTEXT RxContext,
    IN OUT PMRX_SRVCALL_CALLBACK_CONTEXT SrvCallCallBackContext
    )
/*++

Routine Description:

     This routine looks for at the srvcall and determines if it can make a srvcall.
     of course, for the local case we can always have a call; so, we just look to see
     if the name is of the form \rx$$<z> for some Z. if it is, then we return success;
     otherwise failure.

     the rxcontext could refer either to a IoCtl (from the MUP) or an Open

     A real rdr could look for a netroot as well......

Arguments:

    RxContext - Supplies the context of the original create/ioctl

    CallBack  - a routine that we call when we're finished.  if we returned
                pending, we would have to get to a thread to call. of course,
                we would have had to mark pending as well.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RXSTATUS Status;
    PSRV_CALL SrvCall = RxContext->Create.SrvCall;
    PNET_ROOT NetRoot = RxContext->Create.NetRoot;
    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    //UNICODE_STRING MyInnerPrefix;
    PUNICODE_STRING NetRootName,SrvCallName;
    ULONG Length;
    PWCH Buffer;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = SrvCallCallBackContext;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(SCCBC->SrvCalldownStructure);
    KIRQL SavedIrql;

    if (SrvCall != NULL) {
       ASSERT( NodeType(SrvCall) == RDBSS_NTC_SRVCALL );
       ASSERT( !NetRoot || NodeType(NetRoot) == RDBSS_NTC_NETROOT );

       SrvCallName = &SrvCall->PrefixEntry.Prefix;

       Length = SrvCallName->Length;
       Buffer = SrvCallName->Buffer;

       RxDbgTrace(0, Dbg, ("MrxLocalCreateSrvCall %wZ, length=%08lx\n", SrvCallName, Length));

       if ( (Length >= 5)
             && ( (Buffer[1] == L'R') || (Buffer[1] == L'r') )
             && ( (Buffer[2] == L'X') || (Buffer[2] == L'x') )
             && ( (Buffer[3] == L'$')  )
             && ( (Buffer[4] == L'$')  )
          )  {
          SCCBC->Status = RxStatus(SUCCESS);
       } else {
          SCCBC->Status = RxStatus(BAD_NETWORK_PATH);
       }
    } else {
       SCCBC->Status = RxStatus(BAD_NETWORK_PATH);
    }

    KeAcquireSpinLock( SrvCalldownStructure->SpinLock, &SavedIrql );
    SrvCalldownStructure->CallBack(SCCBC);
    KeReleaseSpinLock( SrvCalldownStructure->SpinLock, SavedIrql );
    return SCCBC->Status; //actually the return value is ignored
}



RXSTATUS
MRxLocalSrvCallWinnerNotify(
    IN PRX_CONTEXT RxContext,
    IN BOOLEAN ThisMinirdrIsTheWinner,
    IN OUT PVOID DisconnectAfterLosingContext,
    IN PVOID MinirdrContext
    )
/*++

Routine Description:


Arguments:

    RxContext - Supplies the context of the original create/ioctl

    CallBack  - a routine that we call when we're finished.  if we returned
                pending, we would have to get to a thread to call. of course,
                we would have had to mark pending as well.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RXSTATUS Status;
    PSRV_CALL SrvCall = RxContext->Create.SrvCall;
    PNET_ROOT NetRoot = RxContext->Create.NetRoot;
    //RxCaptureRequestPacket;
    //RxCaptureParamBlock;
    //UNICODE_STRING MyInnerPrefix;
    PUNICODE_STRING SrvCallName;
    //ULONG Length,PoolAllocSize;

    ASSERT( NodeType(NetRoot->SrvCall) == RDBSS_NTC_SRVCALL );
    ASSERT( !NetRoot || NodeType(NetRoot) == RDBSS_NTC_NETROOT );

    SrvCallName = &SrvCall->PrefixEntry.Prefix;

    RxDbgTrace(0, Dbg, (" MRxLocalSrvCallWinnerNotify localmini wins %wZ\n", SrvCallName));

    SrvCall->Dispatch = &MRxLocalDispatch;

    // transition only the srvcall.....it'll come back for the netroot
    if (NetRoot) RxTransitionNetRoot(NetRoot,Condition_Bad);
    RxTransitionSrvCall(SrvCall,Condition_Good);

    return(RxStatus(SUCCESS));
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\allocsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    AllocSup.c

Abstract:

    This module implements the Allocation support routines for Rx.

Author:

    DavidGoebel     [DavidGoe]      31-Oct-90

Revision History:

    DavidGoebel     [DavidGoe]      31-Oct-90

        Add unwinding support.  Some steps had to be reordered, and whether
        operations cpuld fail carefully considered.  In particular, attention
        was paid to to the order of Mcb operations (see note below).


             #####     ##    #    #   ####   ######  #####
             #    #   #  #   ##   #  #    #  #       #    #
             #    #  #    #  # #  #  #       #####   #    #
             #    #  ######  #  # #  #  ###  #       #####
             #    #  #    #  #   ##  #    #  #       #   #
             #####   #    #  #    #   ####   ######  #    #
             ______________________________________________


            ++++++++++++++++++++++++++++++++++++++++++++++++++|
            |                                                 |
            | The unwinding aspects of this module depend on  |
            | operational details of the Mcb package.  Do not |
            | attempt to modify unwind procedures without     |
            | thoughoughly understanding the innerworkings of |
            | the Mcb package.                                |
            |                                                 |
            ++++++++++++++++++++++++++++++++++++++++++++++++++|


         #    #    ##    #####   #    #     #    #    #   ####
         #    #   #  #   #    #  ##   #     #    ##   #  #    #
         #    #  #    #  #    #  # #  #     #    # #  #  #
         # ## #  ######  #####   #  # #     #    #  # #  #  ###
         ##  ##  #    #  #   #   #   ##     #    #   ##  #    #
         #    #  #    #  #    #  #    #     #    #    #   ####
         ______________________________________________________
--*/

//    ----------------------joejoe-----------found-------------#include "RxProcs.h"
#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_ALLOCSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_ALLOCSUP)

//
//  Cluster/Index routines implemented in AllocSup.c
//

typedef enum _CLUSTER_TYPE {
    RxClusterAvailable,
    RxClusterReserved,
    RxClusterBad,
    RxClusterLast,
    RxClusterNext
} CLUSTER_TYPE;

//
//  This strucure is used by RxLookupRxEntry to remember a pinned page
//  of rx.
//

typedef struct _RDBSS_ENUMERATION_CONTEXT {

    VBO VboOfPinnedPage;
    PBCB Bcb;
    PVOID PinnedPage;

} RDBSS_ENUMERATION_CONTEXT, *PRDBSS_ENUMERATION_CONTEXT;

//
//  Local support routine prototypes
//

CLUSTER_TYPE
RxInterpretClusterType (
    IN PVCB Vcb,
    IN RDBSS_ENTRY Entry
    );

VOID
RxLookupRxEntry(
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN ULONG RxIndex,
    IN OUT PRDBSS_ENTRY RxEntry,
    IN OUT PRDBSS_ENUMERATION_CONTEXT Context
    );

VOID
RxSetRxEntry(
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN ULONG RxIndex,
    IN RDBSS_ENTRY RxEntry
    );

VOID
RxSetRxRun(
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN ULONG StartingRxIndex,
    IN ULONG ClusterCount,
    IN BOOLEAN ChainTogether
    );

UCHAR
RxLogOf(
    IN ULONG Value
    );


//
//  The following macros provide a convenient way of hiding the details
//  of bitmap allocation schemes.
//


//
//  VOID
//  RxLockFreeClusterBitMap (
//      IN PVCB Vcb
//      );
//

#define RxLockFreeClusterBitMap(VCB) {                             \
    RXSTATUS Status;                                                \
    Status = KeWaitForSingleObject( &(VCB)->FreeClusterBitMapEvent, \
                                    Executive,                      \
                                    KernelMode,                     \
                                    FALSE,                          \
                                    (PLARGE_INTEGER) NULL );        \
    ASSERT( NT_SUCCESS( Status ) );                                 \
}

//
//  VOID
//  RxUnlockFreeClusterBitMap (
//      IN PVCB Vcb
//      );
//

#define RxUnlockFreeClusterBitMap(VCB) {                                   \
    ULONG PreviousState;                                                    \
    PreviousState = KeSetEvent( &(VCB)->FreeClusterBitMapEvent, 0, FALSE ); \
    ASSERT( PreviousState == 0 );                                           \
}

//
//  BOOLEAN
//  RxIsClusterFree (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN ULONG RxIndex
//      );
//

#define RxIsClusterFree(RXCONTEXT,VCB,RDBSS_INDEX)             \
                                                               \
    (RtlCheckBit(&(VCB)->FreeClusterBitMap,(RDBSS_INDEX)) == 0)

//
//  BOOLEAN
//  RxIsClusterAllocated  (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN ULONG RxIndex
//      );
//

#define RxIsClusterAllocated(RXCONTEXT,VCB,RDBSS_INDEX)      \
                                                             \
    (RtlCheckBit(&(VCB)->FreeClusterBitMap,(RDBSS_INDEX)) != 0)

//
//  VOID
//  RxFreeClusters  (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN ULONG RxIndex,
//      IN ULONG ClusterCount
//      );
//

#ifdef DOUBLE_SPACE_WRITE

#define RxFreeClusters(RXCONTEXT,VCB,RDBSS_INDEX,CLUSTER_COUNT) {             \
                                                                              \
    ASSERTMSG("RxFreeClusters ", RtlCheckBit( &(VCB)->FreeClusterBitMap, 0 ) == 1 ); \
    ASSERTMSG("RxFreeClusters ", RtlCheckBit( &(VCB)->FreeClusterBitMap, 1 ) == 1 ); \
                                                                              \
    DebugTrace( 0, Dbg, "Free clusters (Index<<16 | Count) (%8lx)\n",         \
                        (RDBSS_INDEX)<<16 | (CLUSTER_COUNT));                   \
    if ((CLUSTER_COUNT) == 1) {                                               \
        RxSetRxEntry((RXCONTEXT),(VCB),(RDBSS_INDEX),RDBSS_CLUSTER_AVAILABLE); \
    } else {                                                                  \
        RxSetRxRun((RXCONTEXT),(VCB),(RDBSS_INDEX),(CLUSTER_COUNT),FALSE);   \
    }                                                                         \
    if ((VCB)->Dscb != NULL) {                                                \
        RxDblsDeallocateClusters((RXCONTEXT),(VCB)->Dscb,(RDBSS_INDEX),(CLUSTER_COUNT)); \
    }                                                                         \
}

#else

#define RxFreeClusters(RXCONTEXT,VCB,RDBSS_INDEX,CLUSTER_COUNT) {             \
                                                                              \
    ASSERTMSG("RxFreeClusters ", RtlCheckBit( &(VCB)->FreeClusterBitMap, 0 ) == 1 ); \
    ASSERTMSG("RxFreeClusters ", RtlCheckBit( &(VCB)->FreeClusterBitMap, 1 ) == 1 ); \
                                                                              \
    DebugTrace( 0, Dbg, "Free clusters (Index<<16 | Count) (%8lx)\n",         \
                        (RDBSS_INDEX)<<16 | (CLUSTER_COUNT));                   \
    if ((CLUSTER_COUNT) == 1) {                                               \
        RxSetRxEntry((RXCONTEXT),(VCB),(RDBSS_INDEX),RDBSS_CLUSTER_AVAILABLE); \
    } else {                                                                  \
        RxSetRxRun((RXCONTEXT),(VCB),(RDBSS_INDEX),(CLUSTER_COUNT),FALSE);   \
    }                                                                         \
}

#endif // DOUBLE_SPACE_WRITE

//
//  VOID
//  RxAllocateClusters  (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN ULONG RxIndex,
//      IN ULONG ClusterCount
//      );
//

#define RxAllocateClusters(RXCONTEXT,VCB,RDBSS_INDEX,CLUSTER_COUNT) {      \
                                                                           \
    ASSERTMSG("RxFreeClusters ", RtlCheckBit( &(VCB)->FreeClusterBitMap, 0 ) == 1 ); \
    ASSERTMSG("RxFreeClusters ", RtlCheckBit( &(VCB)->FreeClusterBitMap, 1 ) == 1 ); \
                                                                           \
    DebugTrace( 0, Dbg, "Allocate clusters (Index<<16 | Count) (%8lx)\n",  \
                        (RDBSS_INDEX)<<16 | (CLUSTER_COUNT));                \
    if ((CLUSTER_COUNT) == 1) {                                            \
        RxSetRxEntry((RXCONTEXT),(VCB),(RDBSS_INDEX),RDBSS_CLUSTER_LAST);   \
    } else {                                                               \
        RxSetRxRun((RXCONTEXT),(VCB),(RDBSS_INDEX),(CLUSTER_COUNT),TRUE); \
    }                                                                      \
}

//
//  VOID
//  RxUnreserveClusters  (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN ULONG RxIndex,
//      IN ULONG ClusterCount
//      );
//

#define RxUnreserveClusters(RXCONTEXT,VCB,RDBSS_INDEX,CLUSTER_COUNT) {   \
                                                                         \
    ASSERTMSG("RxFreeClusters ", RtlCheckBit( &(VCB)->FreeClusterBitMap, 0 ) == 1 ); \
    ASSERTMSG("RxFreeClusters ", RtlCheckBit( &(VCB)->FreeClusterBitMap, 1 ) == 1 ); \
                                                                         \
    RtlClearBits(&(VCB)->FreeClusterBitMap,(RDBSS_INDEX),(CLUSTER_COUNT)); \
}

//
//  VOID
//  RxReserveClusters  (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN ULONG RxIndex,
//      IN ULONG ClusterCount
//      );
//

#define RxReserveClusters(RXCONTEXT,VCB,RDBSS_INDEX,CLUSTER_COUNT) {   \
                                                                       \
    ASSERTMSG("RxFreeClusters ", RtlCheckBit( &(VCB)->FreeClusterBitMap, 0 ) == 1 ); \
    ASSERTMSG("RxFreeClusters ", RtlCheckBit( &(VCB)->FreeClusterBitMap, 1 ) == 1 ); \
                                                                       \
    RtlSetBits(&(VCB)->FreeClusterBitMap,(RDBSS_INDEX),(CLUSTER_COUNT)); \
}

//
//  ULONG
//  RxFindFreeClusterRun (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN ULONG ClusterCount,
//      IN PULONG AlternateClusterHint
//      );
//

#define RxFindFreeClusterRun(RXCONTEXT,VCB,CLUSTER_COUNT,CLUSTER_HINT)       \
                                                                               \
    RtlFindClearBits( &(VCB)->FreeClusterBitMap,                               \
                      (CLUSTER_COUNT),                                         \
                      ((CLUSTER_HINT) != 0)?(CLUSTER_HINT):(VCB)->ClusterHint )

//
//  ULONG
//  RxLongestFreeClusterRun (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN PULONG RxIndex,
//      );
//

#define RxLongestFreeClusterRun(RXCONTEXT,VCB,RDBSS_INDEX)        \
                                                                  \
    RtlFindLongestRunClear(&(VCB)->FreeClusterBitMap,(RDBSS_INDEX))

#if DBG
extern KSPIN_LOCK VWRSpinLock;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxLookupFileAllocation)
#pragma alloc_text(PAGE, RxAddFileAllocation)
#pragma alloc_text(PAGE, RxAllocateDiskSpace)
#pragma alloc_text(PAGE, RxDeallocateDiskSpace)
#pragma alloc_text(PAGE, RxInterpretClusterType)
#pragma alloc_text(PAGE, RxLogOf)
#pragma alloc_text(PAGE, RxLookupRxEntry)
#pragma alloc_text(PAGE, RxLookupFileAllocationSize)
#pragma alloc_text(PAGE, RxMergeAllocation)
#pragma alloc_text(PAGE, RxSetRxEntry)
#pragma alloc_text(PAGE, RxSetRxRun)
#pragma alloc_text(PAGE, RxSetupAllocationSupport)
#pragma alloc_text(PAGE, RxSplitAllocation)
#pragma alloc_text(PAGE, RxTearDownAllocationSupport)
#pragma alloc_text(PAGE, RxTruncateFileAllocation)
#endif



VOID
RxSetupAllocationSupport (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine fills in the Allocation Support structure in the Vcb.
    Most entries are computed using rx.h macros supplied with data from
    the Bios Parameter Block.  The free cluster count, however, requires
    going to the Rx and actually counting free sectors.  At the same time
    the free cluster bit map is initalized.

Arguments:

    Vcb - Supplies the Vcb to fill in.

--*/

{
    ULONG BitMapSize;
    PVOID BitMapBuffer;

    PBCB (*SavedBcbs)[2] = NULL;

    PBCB Bcbs[2][2];

    DebugTrace(+1, Dbg, "RxSetupAllocationSupport\n", 0);
    DebugTrace( 0, Dbg, "  Vcb = %8lx\n", Vcb);

    //
    //  Compute a number of fields for Vcb.AllocationSupport
    //

    Vcb->AllocationSupport.RootDirectoryLbo = RxRootDirectoryLbo( &Vcb->Bpb );
    Vcb->AllocationSupport.RootDirectorySize = RxRootDirectorySize( &Vcb->Bpb );

    Vcb->AllocationSupport.FileAreaLbo = RxFileAreaLbo( &Vcb->Bpb );

    Vcb->AllocationSupport.NumberOfClusters = RxNumberOfClusters( &Vcb->Bpb );

    Vcb->AllocationSupport.RxIndexBitSize = RxIndexBitSize( &Vcb->Bpb );

    Vcb->AllocationSupport.LogOfBytesPerSector = RxLogOf(Vcb->Bpb.BytesPerSector);
    Vcb->AllocationSupport.LogOfBytesPerCluster = RxLogOf(
                           RxBytesPerCluster( &Vcb->Bpb ));
    Vcb->AllocationSupport.NumberOfFreeClusters = 0;

    //
    //  Deal with a bug in DOS 5 format, if the Rx is not big enough to
    //  describe all the clusters on the disk, reduce this number.
    //

    {
        ULONG ClustersDescribableByRx;

        ClustersDescribableByRx = ( (Vcb->Bpb.SectorsPerRx *
                                      Vcb->Bpb.BytesPerSector * 8)
                                      / RxIndexBitSize(&Vcb->Bpb) ) - 2;

        if (Vcb->AllocationSupport.NumberOfClusters > ClustersDescribableByRx) {

            KdPrint(("FASTRDBSS: Mounting wierd volume!\n"));

            Vcb->AllocationSupport.NumberOfClusters = ClustersDescribableByRx;
        }
    }

    //
    //  Extend the virtual volume file to include the Rx
    //

    {
        CC_FILE_SIZES FileSizes;

        FileSizes.AllocationSize.QuadPart =
        FileSizes.FileSize.QuadPart =
               RxReservedBytes( &Vcb->Bpb ) +  RxBytesPerRx( &Vcb->Bpb );
        FileSizes.ValidDataLength = RxMaxLarge;

        if ( Vcb->VirtualVolumeFile->PrivateCacheMap == NULL ) {

            CcInitializeCacheMap( Vcb->VirtualVolumeFile,
                                  &FileSizes,
                                  TRUE,
                                  &RxData.CacheManagerNoOpCallbacks,
                                  Vcb );

        } else {

            CcSetFileSizes( Vcb->VirtualVolumeFile, &FileSizes );
        }
    }

    try {

        //
        //  Initialize the free cluster BitMap.  The number of bits is the
        //  number of clusters plus the two reserved entries.  Note that
        //  FsRtlAllocatePool will always allocate me something longword alligned.
        //

        BitMapSize = Vcb->AllocationSupport.NumberOfClusters + 2;

        BitMapBuffer = FsRtlAllocatePool( PagedPool, (BitMapSize + 7) / 8 );

        RtlInitializeBitMap( &Vcb->FreeClusterBitMap,
                             (PULONG)BitMapBuffer,
                             BitMapSize );

        //
        //  Read the rx and count up free clusters.
        //
        //  Rather than just reading rx entries one at a time, a faster
        //  approach is used.  The entire Rx is read in and and we read
        //  through it, keeping track of runs of free and runs of allocated
        //  clusters.  When we switch from free to aloocated or visa versa,
        //  the previous run is marked in the bit map.
        //

        {
            ULONG Page;
            ULONG RxIndex;
            RDBSS_ENTRY RxEntry;
            PRDBSS_ENTRY RxBuffer;

            ULONG ClustersThisRun;
            ULONG RxIndexBitSize;
            ULONG StartIndexOfThisRun;
            PULONG FreeClusterCount;

            enum RunType {
                FreeClusters,
                AllocatedClusters
            } CurrentRun;

            //
            //  Keep local copies of these variables around for speed.
            //

            FreeClusterCount = &Vcb->AllocationSupport.NumberOfFreeClusters;
            RxIndexBitSize = Vcb->AllocationSupport.RxIndexBitSize;

            //
            //  Read in one page of rx at a time.  We cannot read in the
            //  all of the rx we need because of cache manager limitations.
            //
            //  SavedBcb was initialized to be able to hold the largest
            //  possible number of pages in a rx plus and extra one to
            //  accomadate the boot sector, plus one more to make sure there
            //  is enough room for the RtlZeroMemory below that needs the mark
            //  the first Bcb after all the ones we will use as an end marker.
            //

            if ( RxIndexBitSize == 16 ) {

                ULONG NumberOfPages;
                ULONG Offset;

                NumberOfPages = ( RxReservedBytes(&Vcb->Bpb) +
                                  RxBytesPerRx(&Vcb->Bpb) +
                                  (PAGE_SIZE - 1) ) / PAGE_SIZE;

                //
                //  Figure out how much memory we will need for the Bcb
                //  buffer and fill it in.
                //

                SavedBcbs = FsRtlAllocatePool( PagedPool,
                                               (NumberOfPages + 1) * sizeof(PBCB) * 2 );

                RtlZeroMemory( &SavedBcbs[0][0], (NumberOfPages + 1) * sizeof(PBCB) * 2 );

                for ( Page = 0, Offset = 0;
                      Page < NumberOfPages;
                      Page++, Offset += PAGE_SIZE ) {

                    RxReadVolumeFile( RxContext,
                                       Vcb,
                                       Offset,
                                       PAGE_SIZE,
                                       &SavedBcbs[Page][0],
                                       (PVOID *)&SavedBcbs[Page][1] );
                }

                Page = RxReservedBytes(&Vcb->Bpb) / PAGE_SIZE;

                RxBuffer = (PRDBSS_ENTRY)((PUCHAR)SavedBcbs[Page][1] +
                                         RxReservedBytes(&Vcb->Bpb) % PAGE_SIZE) + 2;

            } else {

                //
                //  We read in the entire rx in the 12 bit case.
                //

                SavedBcbs = Bcbs;

                RtlZeroMemory( &SavedBcbs[0][0], 2 * sizeof(PBCB) * 2);

                RxReadVolumeFile( RxContext,
                                   Vcb,
                                   RxReservedBytes( &Vcb->Bpb ),
                                   RxBytesPerRx( &Vcb->Bpb ),
                                   &SavedBcbs[0][0],
                                   (PVOID *)&RxBuffer );
            }

            //
            //  For a rx, we know the first two clusters are allways
            //  reserved.  So start an allocated run.
            //

            CurrentRun = AllocatedClusters;
            StartIndexOfThisRun = 0;

            for (RxIndex = 2; RxIndex < BitMapSize; RxIndex++) {

                if (RxIndexBitSize == 12) {

                    RxLookup12BitEntry(RxBuffer, RxIndex, &RxEntry);

                } else {

                    //
                    //  If we just stepped onto a new page, grab a new pointer.
                    //

                    if (((ULONG)RxBuffer & (PAGE_SIZE - 1)) == 0) {

                        Page++;

                        RxBuffer = (PRDBSS_ENTRY)SavedBcbs[Page][1];
                    }

                    RxEntry = *RxBuffer;

                    RxBuffer += 1;
                }

                //
                //  Are we switching from a free run to an allocated run?
                //

                if ((CurrentRun == FreeClusters) &&
                    (RxEntry != RDBSS_CLUSTER_AVAILABLE)) {

                    ClustersThisRun = RxIndex - StartIndexOfThisRun;

                    *FreeClusterCount += ClustersThisRun;

                    RtlClearBits( &Vcb->FreeClusterBitMap,
                                  StartIndexOfThisRun,
                                  ClustersThisRun );

                    CurrentRun = AllocatedClusters;
                    StartIndexOfThisRun = RxIndex;
                }

                //
                //  Are we switching from an allocated run to a free run?
                //

                if ((CurrentRun == AllocatedClusters) &&
                    (RxEntry == RDBSS_CLUSTER_AVAILABLE)) {

                    ClustersThisRun = RxIndex - StartIndexOfThisRun;

                    RtlSetBits( &Vcb->FreeClusterBitMap,
                                StartIndexOfThisRun,
                                ClustersThisRun );

                    CurrentRun = FreeClusters;
                    StartIndexOfThisRun = RxIndex;
                }
            }

            //
            //  Now we have to record the final run we encoutered
            //

            ClustersThisRun = RxIndex - StartIndexOfThisRun;

            if ( CurrentRun == FreeClusters ) {

                *FreeClusterCount += ClustersThisRun;

                RtlClearBits( &Vcb->FreeClusterBitMap,
                              StartIndexOfThisRun,
                              ClustersThisRun );

            } else {

                RtlSetBits( &Vcb->FreeClusterBitMap,
                            StartIndexOfThisRun,
                            ClustersThisRun );
            }
        }

        ASSERT( RtlCheckBit( &Vcb->FreeClusterBitMap, 0 ) == 1 );
        ASSERT( RtlCheckBit( &Vcb->FreeClusterBitMap, 1 ) == 1 );

    } finally {

        ULONG i = 0;

        DebugUnwind( RxSetupAllocationSupport );

        //
        //  If we hit an exception, back out.
        //

        if (AbnormalTermination()) {

            RxTearDownAllocationSupport( RxContext, Vcb );
        }

        //
        //  We are done reading the Rx, so unpin the Bcbs.
        //

        if (SavedBcbs != NULL) {

            while ( SavedBcbs[i][0] != NULL ) {

                RxUnpinBcb( RxContext, SavedBcbs[i][0] );

                i += 1;
            }

            if (SavedBcbs != Bcbs) {

                ExFreePool( SavedBcbs );
            }
        }

        DebugTrace(-1, Dbg, "RxSetupAllocationSupport -> (VOID)\n", 0);
    }

    return;
}


VOID
RxTearDownAllocationSupport (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine prepares the volume for closing.  Specifically, we must
    release the free rx bit map buffer, and uninitialize the dirty rx
    Mcb.

Arguments:

    Vcb - Supplies the Vcb to fill in.

Return Value:

    VOID

--*/

{
    DebugTrace(+1, Dbg, "RxTearDownAllocationSupport\n", 0);
    DebugTrace( 0, Dbg, "  Vcb = %8lx\n", Vcb);

    //
    //  Free the memory associated with the free cluster bitmap.
    //

    if ( Vcb->FreeClusterBitMap.Buffer != NULL ) {

        ExFreePool( Vcb->FreeClusterBitMap.Buffer );

        //
        //  NULL this field as an flag.
        //

        Vcb->FreeClusterBitMap.Buffer = NULL;
    }

    //
    //  And remove all the runs in the dirty rx Mcb
    //

    FsRtlRemoveMcbEntry( &Vcb->DirtyRxMcb, 0, 0xFFFFFFFF );

    DebugTrace(-1, Dbg, "RxTearDownAllocationSupport -> (VOID)\n", 0);

    UNREFERENCED_PARAMETER( RxContext );

    return;
}


VOID
RxLookupFileAllocation (
    IN PRX_CONTEXT RxContext,
    IN PFCB FcbOrDcb,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount,
    OUT PBOOLEAN Allocated,
    OUT PULONG Index
    )

/*++

Routine Description:

    This routine looks up the existing mapping of VBO to LBO for a
    file/directory.  The information it queries is either stored in the
    mcb field of the fcb/dcb or it is stored on in the rx table and
    needs to be retrieved and decoded, and updated in the mcb.

Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being queried

    Vbo - Supplies the VBO whose LBO we want returned

    Lbo - Receives the LBO corresponding to the input Vbo if one exists

    ByteCount - Receives the number of bytes within the run the run
                that correpond between the input vbo and output lbo.

    Allocated - Receives TRUE if the Vbo does have a corresponding Lbo
                and FALSE otherwise.

    Index - Receives the Index of the run

--*/

{
    VBO CurrentVbo;
    LBO CurrentLbo;
    LBO PriorLbo;

    VBO FirstVboOfCurrentRun;
    LBO FirstLboOfCurrentRun;

    BOOLEAN LastCluster;
    ULONG Runs;

    PVCB Vcb;
    RDBSS_ENTRY RxEntry;
    ULONG BytesPerCluster;
    ULONG BytesOnVolume;

    RDBSS_ENUMERATION_CONTEXT Context;

    DebugTrace(+1, Dbg, "RxLookupFileAllocation\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  = %8lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  Vbo       = %8lx\n", Vbo);
    DebugTrace( 0, Dbg, "  Lbo       = %8lx\n", Lbo);
    DebugTrace( 0, Dbg, "  ByteCount = %8lx\n", ByteCount);
    DebugTrace( 0, Dbg, "  Allocated = %8lx\n", Allocated);

    Context.Bcb = NULL;

    //
    //  Check the trivial case that the mapping is already in our
    //  Mcb.
    //

    if ( FsRtlLookupMcbEntry(&FcbOrDcb->Mcb, Vbo, Lbo, ByteCount, Index) ) {

        *Allocated = TRUE;

        DebugTrace( 0, Dbg, "Found run in Mcb.\n", 0);
        DebugTrace(-1, Dbg, "RxLookupFileAllocation -> (VOID)\n", 0);
        return;
    }

    //
    //  Initialize the Vcb, the cluster size, LastCluster, and
    //  FirstLboOfCurrentRun (to be used as an indication of the first
    //  itteration through the following while loop).
    //

    Vcb = FcbOrDcb->Vcb;
    BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;
    BytesOnVolume = Vcb->AllocationSupport.NumberOfClusters * BytesPerCluster;

    LastCluster = FALSE;
    FirstLboOfCurrentRun = 0;

    //
    //  Discard the case that the request extends beyond the end of
    //  allocation.  Note that if the allocation size if not known
    //  AllocationSize is set to 0xffffffff.
    //

    if ( Vbo >= FcbOrDcb->Header.AllocationSize.LowPart ) {

        *Allocated = FALSE;

        DebugTrace( 0, Dbg, "Vbo beyond end of file.\n", 0);
        DebugTrace(-1, Dbg, "RxLookupFileAllocation -> (VOID)\n", 0);
        return;
    }

    //
    //  The Vbo is beyond the last Mcb entry.  So we adjust Current Vbo/Lbo
    //  and RxEntry to describe the beginning of the last entry in the Mcb.
    //  This is used as initialization for the following loop.
    //
    //  If the Mcb was empty, we start at the beginning of the file with
    //  CurrentVbo set to 0 to indicate a new run.
    //

    if (FsRtlLookupLastMcbEntry(&FcbOrDcb->Mcb, &CurrentVbo, &CurrentLbo)) {

        DebugTrace( 0, Dbg, "Current Mcb size = %8lx.\n", CurrentVbo + 1);

        CurrentVbo -= (BytesPerCluster - 1);
        CurrentLbo -= (BytesPerCluster - 1);

        Runs = FsRtlNumberOfRunsInMcb( &FcbOrDcb->Mcb );

    } else {

        DebugTrace( 0, Dbg, "Mcb empty.\n", 0);

        //
        //  Check for an FcbOrDcb that has no allocation
        //

        if (FcbOrDcb->FirstClusterOfFile == 0) {

            *Allocated = FALSE;

            DebugTrace( 0, Dbg, "File has no allocation.\n", 0);
            DebugTrace(-1, Dbg, "RxLookupFileAllocation -> (VOID)\n", 0);
            return;

        } else {

            CurrentVbo = 0;
            CurrentLbo = RxGetLboFromIndex( Vcb, FcbOrDcb->FirstClusterOfFile );
            FirstVboOfCurrentRun = CurrentVbo;
            FirstLboOfCurrentRun = CurrentLbo;

            Runs = 0;

            DebugTrace( 0, Dbg, "First Lbo of file = %8lx\n", CurrentLbo);
        }
    }

    //
    //  Now we know that we are looking up a valid Vbo, but it is
    //  not in the Mcb, which is a monotonically increasing list of
    //  Vbo's.  Thus we have to go to the Rx, and update
    //  the Mcb as we go.  We use a try-finally to unpin the page
    //  of rx hanging around.  Also we mark *Allocated = FALSE, so that
    //  the caller wont try to use the data if we hit an exception.
    //

    *Allocated = FALSE;

    try {

        RxEntry = (RDBSS_ENTRY)RxGetIndexFromLbo( Vcb, CurrentLbo );

        //
        //  ASSERT that CurrentVbo and CurrentLbo are now cluster alligned.
        //  The assumption here, is that only whole clusters of Vbos and Lbos
        //  are mapped in the Mcb.
        //

        ASSERT( ((CurrentLbo - Vcb->AllocationSupport.FileAreaLbo)
                                                    % BytesPerCluster == 0) &&
                (CurrentVbo % BytesPerCluster == 0) );

        //
        //  Starting from the first Vbo after the last Mcb entry, scan through
        //  the Rx looking for our Vbo. We continue through the Rx until we
        //  hit a noncontiguity beyond the desired Vbo, or the last cluster.
        //

        while ( !LastCluster ) {

            //
            //  Get the next rx entry, and update our Current variables.
            //

            RxLookupRxEntry( RxContext, Vcb, RxEntry, &RxEntry, &Context );

            PriorLbo = CurrentLbo;
            CurrentLbo = RxGetLboFromIndex( Vcb, RxEntry );
            CurrentVbo += BytesPerCluster;

            switch ( RxInterpretClusterType( Vcb, RxEntry )) {

            //
            //  Check for a break in the Rx allocation chain.
            //

            case RxClusterAvailable:
            case RxClusterReserved:
            case RxClusterBad:

                DebugTrace( 0, Dbg, "Break in allocation chain, entry = %d\n", RxEntry);
                DebugTrace(-1, Dbg, "RxLookupFileAllocation -> Rx Corrupt.  Raise Status.\n", 0);

                RxPopUpFileCorrupt( RxContext, FcbOrDcb );

                RxRaiseStatus( RxContext, RxStatus(FILE_CORRUPT_ERROR) );
                break;

            //
            //  If this is the last cluster, we must update the Mcb and
            //  exit the loop.
            //

            case RxClusterLast:

                //
                //  Assert we know where the current run started.  If the
                //  Mcb was empty when we were called, thenFirstLboOfCurrentRun
                //  was set to the start of the file.  If the Mcb contained an
                //  entry, then FirstLboOfCurrentRun was set on the first
                //  itteration through the loop.  Thus if FirstLboOfCurrentRun
                //  is 0, then there was an Mcb entry and we are on our first
                //  itteration, meaing that the last cluster in the Mcb was
                //  really the last allocated cluster, but we checked Vbo
                //  against AllocationSize, and found it OK, thus AllocationSize
                //  must be too large.
                //
                //  Note that, when we finally arrive here, CurrentVbo is actually
                //  the first Vbo beyond the file allocation and CurrentLbo is
                //  meaningless.
                //

                DebugTrace( 0, Dbg, "Read last cluster of file.\n", 0);

                LastCluster = TRUE;

                if (FirstLboOfCurrentRun != 0 ) {

                    DebugTrace( 0, Dbg, "Adding a run to the Mcb.\n", 0);
                    DebugTrace( 0, Dbg, "  Vbo    = %08lx.\n", FirstVboOfCurrentRun);
                    DebugTrace( 0, Dbg, "  Lbo    = %08lx.\n", FirstLboOfCurrentRun);
                    DebugTrace( 0, Dbg, "  Length = %08lx.\n", CurrentVbo - FirstVboOfCurrentRun);

                    (VOID)FsRtlAddMcbEntry( &FcbOrDcb->Mcb,
                                            FirstVboOfCurrentRun,
                                            FirstLboOfCurrentRun,
                                            CurrentVbo - FirstVboOfCurrentRun );

                    Runs += 1;
                }

                //
                //  Being at the end of allocation, make sure we have found
                //  the Vbo.  If we haven't, seeing as we checked VBO
                //  against AllocationSize, the real disk allocation is less
                //  than that of AllocationSize.  This comes about when the
                //  real allocation is not yet known, and AllocaitonSize
                //  contains MAXULONG.
                //
                //  KLUDGE! - If we were called by RxLookupFileAllocationSize
                //  Vbo is set to MAXULONG - 1, and AllocationSize to MAXULONG.
                //  Thus we merrily go along looking for a match that isn't
                //  there, but in the meantime building an Mcb.  If this is
                //  the case, fill in AllocationSize and return.
                //

                if ( Vbo >= CurrentVbo ) {

                    FcbOrDcb->Header.AllocationSize.QuadPart = CurrentVbo;
                    *Allocated = FALSE;

                    DebugTrace( 0, Dbg, "New file allocation size = %08lx.\n", CurrentVbo);

                    try_return ( NOTHING );
                }

                break;

            //
            //  This is a continuation in the chain.  If the run has a
            //  discontiguity at this point, update the Mcb, and if we are beyond
            //  the desired Vbo, this is the end of the run, so set LastCluster
            //  and exit the loop.
            //

            case RxClusterNext:

                //
                //  Do a quick check here for cycles in that Rx that can
                //  infinite loops here.
                //

                if ( CurrentVbo > BytesOnVolume ) {

                    RxPopUpFileCorrupt( RxContext, FcbOrDcb );

                    RxRaiseStatus( RxContext, RxStatus(FILE_CORRUPT_ERROR) );
                    break;
                }


                if ( PriorLbo + BytesPerCluster != CurrentLbo ) {

                    //
                    //  Note that on the first time through the loop
                    //  (FirstLboOfCurrentRun == 0), we don't add the
                    //  run to the Mcb since it curresponds to the last
                    //  run already stored in the Mcb.
                    //

                    if ( FirstLboOfCurrentRun != 0 ) {

                        DebugTrace( 0, Dbg, "Adding a run to the Mcb.\n", 0);
                        DebugTrace( 0, Dbg, "  Vbo    = %08lx.\n", FirstVboOfCurrentRun);
                        DebugTrace( 0, Dbg, "  Lbo    = %08lx.\n", FirstLboOfCurrentRun);
                        DebugTrace( 0, Dbg, "  Length = %08lx.\n", CurrentVbo - FirstVboOfCurrentRun);

                        FsRtlAddMcbEntry( &FcbOrDcb->Mcb,
                                          FirstVboOfCurrentRun,
                                          FirstLboOfCurrentRun,
                                          CurrentVbo - FirstVboOfCurrentRun );

                        Runs += 1;
                    }

                    //
                    //  Since we are at a run boundry, with CurrentLbo and
                    //  CurrentVbo being the first cluster of the next run,
                    //  we see if the run we just added encompases the desired
                    //  Vbo, and if so exit.  Otherwise we set up two new
                    //  First*boOfCurrentRun, and continue.
                    //

                    if (CurrentVbo > Vbo) {

                        LastCluster = TRUE;

                    } else {

                        FirstVboOfCurrentRun = CurrentVbo;
                        FirstLboOfCurrentRun = CurrentLbo;
                    }
                }
                break;

            default:

                DebugTrace(0, Dbg, "Illegal Cluster Type.\n", RxEntry);

                RxBugCheck( 0, 0, 0 );

                break;

            } // switch()
        } // while()

        //
        //  Load up the return parameters.
        //
        //  On exit from the loop, Vbo still contains the desired Vbo, and
        //  CurrentVbo is the first byte after the run that contained the
        //  desired Vbo.
        //

        *Allocated = TRUE;

        *Lbo = FirstLboOfCurrentRun + (Vbo - FirstVboOfCurrentRun);

        *ByteCount = CurrentVbo - Vbo;

        if (ARGUMENT_PRESENT(Index)) {

            *Index = Runs - 1;
        }

    try_exit: NOTHING;

    } finally {

        DebugUnwind( RxLookupFileAllocation );

        //
        //  We are done reading the Rx, so unpin the last page of rx
        //  that is hanging around
        //

        RxUnpinBcb( RxContext, Context.Bcb );

        DebugTrace(-1, Dbg, "RxLookupFileAllocation -> (VOID)\n", 0);
    }

    return;
}


VOID
RxAddFileAllocation (
    IN PRX_CONTEXT RxContext,
    IN PFCB FcbOrDcb,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN ULONG DesiredAllocationSize
    )

/*++

Routine Description:

    This routine adds additional allocation to the specified file/directory.
    Additional allocation is added by appending clusters to the file/directory.

    If the file already has a sufficient allocation then this procedure
    is effectively a noop.

Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being modified.
               This parameter must not specify the root dcb.

    FileObject - If supplied inform the cache manager of the change.

    DesiredAllocationSize - Supplies the minimum size, in bytes, that we want
                            allocated to the file/directory.

--*/

{
    PVCB Vcb;

    DebugTrace(+1, Dbg, "RxAddFileAllocation\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  =             %8lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  DesiredAllocationSize = %8lx\n", DesiredAllocationSize);

    //
    //  If we haven't yet set the correct AllocationSize, do so.
    //

    if (FcbOrDcb->Header.AllocationSize.LowPart == 0xffffffff) {

        RxLookupFileAllocationSize( RxContext, FcbOrDcb );
    }

    //
    //  Check for the benign case that the desired allocation is already
    //  within the allocation size.
    //

    if (DesiredAllocationSize <= FcbOrDcb->Header.AllocationSize.LowPart) {

        DebugTrace(0, Dbg, "Desired size within current allocation.\n", 0);

        DebugTrace(-1, Dbg, "RxAddFileAllocation -> (VOID)\n", 0);
        return;
    }

    DebugTrace( 0, Dbg, "InitialAllocation = %08lx.\n", FcbOrDcb->Header.AllocationSize.LowPart);

    //
    //  Get a chunk of disk space that will fullfill our needs.  If there
    //  was no initial allocation, start from the hint in the Vcb, otherwise
    //  try to allocate from the cluster after the initial allocation.
    //
    //  If there was no initial allocation to the file, we can just use the
    //  Mcb in the FcbOrDcb, otherwise we have to use a new one, and merge
    //  it to the one in the FcbOrDcb.
    //

    Vcb = FcbOrDcb->Vcb;

    if (FcbOrDcb->Header.AllocationSize.LowPart == 0) {

        PBCB Bcb = NULL;
        PDIRENT Dirent;
        LBO FirstLboOfFile;
        BOOLEAN UnwindWeAllocatedDiskSpace = FALSE;

        try {

            RxGetDirentFromFcbOrDcb( RxContext,
                                      FcbOrDcb,
                                      &Dirent,
                                      &Bcb );

            //
            //  Set this dirty right now since this call can fail.
            //

            RxSetDirtyBcb( RxContext, Bcb, Vcb );


            RxAllocateDiskSpace( RxContext,
                                  Vcb,
                                  0,
                                  &DesiredAllocationSize,
                                  &FcbOrDcb->Mcb );

            UnwindWeAllocatedDiskSpace = TRUE;

            //
            //  We have to update the dirent and FcbOrDcb copies of
            //  FirstClusterOfFile since before it was 0
            //

            FsRtlLookupMcbEntry( &FcbOrDcb->Mcb,
                                 0,
                                 &FirstLboOfFile,
                                 (PULONG)NULL,
                                 NULL );

            DebugTrace( 0, Dbg, "First Lbo of file will be %08lx.\n", FirstLboOfFile );

            FcbOrDcb->FirstClusterOfFile = RxGetIndexFromLbo( Vcb, FirstLboOfFile );

            FcbOrDcb->Header.AllocationSize.QuadPart = DesiredAllocationSize;

            Dirent->FirstClusterOfFile = (RDBSS_ENTRY)FcbOrDcb->FirstClusterOfFile;

            //
            //  Inform the cache manager to increase the section size
            //

            if ( ARGUMENT_PRESENT(FileObject) && CcIsFileCached(FileObject) ) {

                CcSetFileSizes( FileObject,
                                (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize );
            }

        } finally {

            DebugUnwind( RxAddFileAllocation );

            if ( AbnormalTermination() && UnwindWeAllocatedDiskSpace ) {

                RxDeallocateDiskSpace( RxContext, Vcb, &FcbOrDcb->Mcb );
            }

            RxUnpinBcb( RxContext, Bcb );

            DebugTrace(-1, Dbg, "RxAddFileAllocation -> (VOID)\n", 0);
        }

    } else {

        MCB NewMcb;
        LBO LastAllocatedLbo;
        VBO DontCare;
        ULONG NewAllocation;
        BOOLEAN UnwindWeInitializedMcb = FALSE;
        BOOLEAN UnwindWeAllocatedDiskSpace = FALSE;

        try {

            //
            //  Get the first cluster following the current allocation
            //

            FsRtlLookupLastMcbEntry( &FcbOrDcb->Mcb, &DontCare, &LastAllocatedLbo);

            //
            //  Try to get some disk space starting from there
            //

            NewAllocation = DesiredAllocationSize - FcbOrDcb->Header.AllocationSize.LowPart;

            FsRtlInitializeMcb( &NewMcb, PagedPool );
            UnwindWeInitializedMcb = TRUE;

            RxAllocateDiskSpace( RxContext,
                                  Vcb,
                                  RxGetIndexFromLbo(Vcb, LastAllocatedLbo + 1),
                                  &NewAllocation,
                                  &NewMcb );

            UnwindWeAllocatedDiskSpace = TRUE;

            //
            //  Tack the new Mcb onto the end of the FcbOrDcb one.
            //

            RxMergeAllocation( RxContext,
                                Vcb,
                                &FcbOrDcb->Mcb,
                                &NewMcb );

            //
            //  Now that we increased the allocation of the file, mark it in the
            //  FcbOrDcb.
            //

            FcbOrDcb->Header.AllocationSize.LowPart += NewAllocation;

            //
            //  Inform the cache manager to increase the section size
            //

            if ( ARGUMENT_PRESENT(FileObject) && CcIsFileCached(FileObject) ) {

                CcSetFileSizes( FileObject,
                                (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize );
            }

        } finally {

            DebugUnwind( RxAddFileAllocation );

            //
            //  Detect the case where RxMergeAllocation failed, and
            //  Deallocate the disk space
            //

            if ( (UnwindWeAllocatedDiskSpace == TRUE) &&
                 (FcbOrDcb->Header.AllocationSize.LowPart < DesiredAllocationSize) ) {

                RxDeallocateDiskSpace( RxContext, Vcb, &NewMcb );
            }

            if (UnwindWeInitializedMcb == TRUE) {

                FsRtlUninitializeMcb( &NewMcb );
            }

            DebugTrace(-1, Dbg, "RxAddFileAllocation -> (VOID)\n", 0);
        }
    }

    //
    //  Give FlushFileBuffer a clue here.
    //

    SetFlag(FcbOrDcb->FcbState, FCB_STATE_FLUSH_RDBSS);

    return;
}


VOID
RxTruncateFileAllocation (
    IN PRX_CONTEXT RxContext,
    IN PFCB FcbOrDcb,
    IN ULONG DesiredAllocationSize
    )

/*++

Routine Description:

    This routine truncates the allocation to the specified file/directory.

    If the file is already smaller than the indicated size then this procedure
    is effectively a noop.


Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being modified
               This parameter must not specify the root dcb.

    DesiredAllocationSize - Supplies the maximum size, in bytes, that we want
                            allocated to the file/directory.  It is rounded
                            up to the nearest cluster.

Return Value:

    VOID - TRUE if the operation completed and FALSE if it had to
        block but could not.

--*/

{
    PVCB Vcb;
    PBCB Bcb = NULL;
    MCB RemainingMcb;
    ULONG BytesPerCluster;
    PDIRENT Dirent = NULL;

    ULONG UnwindInitialAllocationSize;
    ULONG UnwindInitialFirstClusterOfFile;
    BOOLEAN UnwindWeAllocatedMcb = FALSE;

    DebugTrace(+1, Dbg, "RxTruncateFileAllocation\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  =             %8lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  DesiredAllocationSize = %8lx\n", DesiredAllocationSize);

    //
    //  If we haven't yet set the correct AllocationSize, do so.
    //

    if (FcbOrDcb->Header.AllocationSize.LowPart == 0xffffffff) {

        RxLookupFileAllocationSize( RxContext, FcbOrDcb );
    }

    //
    //  Round up the Desired Allocation Size to the next cluster size
    //

    Vcb = FcbOrDcb->Vcb;

    BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    DesiredAllocationSize = (DesiredAllocationSize + (BytesPerCluster - 1)) &
                            ~(BytesPerCluster - 1);
    //
    //  Check for the benign case that the file is already smaller than
    //  the desired truncation.
    //

    if (DesiredAllocationSize >= FcbOrDcb->Header.AllocationSize.LowPart) {

        DebugTrace(0, Dbg, "Desired size within current allocation.\n", 0);

        DebugTrace(-1, Dbg, "RxTruncateFileAllocation -> (VOID)\n", 0);
        return;
    }

    UnwindInitialAllocationSize = FcbOrDcb->Header.AllocationSize.LowPart;
    UnwindInitialFirstClusterOfFile = FcbOrDcb->FirstClusterOfFile;

    //
    //  Update the FcbOrDcb allocation size.  If it is now zero, we have the
    //  additional task of modifying the FcbOrDcb and Dirent copies of
    //  FirstClusterInFile.
    //
    //  Note that we must pin the dirent before actually deallocating the
    //  disk space since, in unwind, it would not be possible to reallocate
    //  deallocated disk space as someone else may have reallocated it and
    //  may cause an exception when you try to get some more disk space.
    //  Thus RxDeallocateDiskSpace must be the final dangerous operation.
    //

    try {

        FcbOrDcb->Header.AllocationSize.QuadPart = DesiredAllocationSize;

        //
        //  Special case 0
        //

        if (DesiredAllocationSize == 0) {

            //
            //  We have to update the dirent and FcbOrDcb copies of
            //  FirstClusterOfFile since before it was 0
            //

            RxGetDirentFromFcbOrDcb( RxContext, FcbOrDcb, &Dirent, &Bcb );

            Dirent->FirstClusterOfFile = 0;
            FcbOrDcb->FirstClusterOfFile = 0;

            RxSetDirtyBcb( RxContext, Bcb, Vcb );

            RxDeallocateDiskSpace( RxContext, Vcb, &FcbOrDcb->Mcb );

            FsRtlRemoveMcbEntry( &FcbOrDcb->Mcb, 0, 0xFFFFFFFF );

        } else {

            //
            //  Split the existing allocation into two parts, one we will keep, and
            //  one we will deallocate.
            //

            FsRtlInitializeMcb( &RemainingMcb, PagedPool );
            UnwindWeAllocatedMcb = TRUE;

            RxSplitAllocation( RxContext,
                                Vcb,
                                &FcbOrDcb->Mcb,
                                DesiredAllocationSize,
                                &RemainingMcb );

            RxDeallocateDiskSpace( RxContext, Vcb, &RemainingMcb );

            FsRtlUninitializeMcb( &RemainingMcb );
        }

    } finally {

        DebugUnwind( RxTruncateFileAllocation );

        if ( AbnormalTermination() ) {

            FcbOrDcb->Header.AllocationSize.LowPart = UnwindInitialAllocationSize;

            if ( (DesiredAllocationSize == 0) && (Dirent != NULL)) {

                Dirent->FirstClusterOfFile = (RDBSS_ENTRY)UnwindInitialFirstClusterOfFile;
                FcbOrDcb->FirstClusterOfFile = UnwindInitialFirstClusterOfFile;
            }

            if ( UnwindWeAllocatedMcb ) {

                FsRtlUninitializeMcb( &RemainingMcb );
            }

            //
            //  God knows what state we left the disk allocation in.
            //  Clear the Mcb.
            //

            FsRtlRemoveMcbEntry( &FcbOrDcb->Mcb, 0, 0xFFFFFFFF );
        }

        RxUnpinBcb( RxContext, Bcb );

        DebugTrace(-1, Dbg, "RxTruncateFileAllocation -> (VOID)\n", 0);
    }

    //
    //  Give FlushFileBuffer a clue here.
    //

    SetFlag(FcbOrDcb->FcbState, FCB_STATE_FLUSH_RDBSS);

    return;
}


VOID
RxLookupFileAllocationSize (
    IN PRX_CONTEXT RxContext,
    IN PFCB FcbOrDcb
    )

/*++

Routine Description:

    This routine retrieves the current file allocatio size for the
    specified file/directory.

Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being modified

--*/

{
    LBO Lbo;
    ULONG ByteCount;
    BOOLEAN Allocated;

    DebugTrace(+1, Dbg, "RxLookupAllocationSize\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  =      %8lx\n", FcbOrDcb);

    //
    //  We call RxLookupFileAllocation with Vbo of 0xffffffff - 1.
    //

    RxLookupFileAllocation( RxContext,
                             FcbOrDcb,
                             0xffffffff - 1,
                             &Lbo,
                             &ByteCount,
                             &Allocated,
                             NULL );
    //
    //  Assert that we found no allocation.
    //

    ASSERT( Allocated == FALSE );

    DebugTrace(-1, Dbg, "RxLookupFileAllocationSize -> (VOID)\n", 0);
    return;
}


VOID
RxAllocateDiskSpace (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN ULONG AlternativeClusterHint,
    IN PULONG ByteCount,
    OUT PMCB Mcb
    )

/*++

Routine Description:

    This procedure allocates additional disk space and builds an mcb
    representing the newly allocated space.  If the space cannot be
    allocated then this procedure raises an appropriate status.

    Searching starts from the hint index in the Vcb unless an alternative
    non-zero hint is given in AlternativeClusterHint.  If we are using the
    hint field in the Vcb, it is set to the cluster following our allocation
    when we are done.

    Disk space can only be allocated in cluster units so this procedure
    will round up any byte count to the next cluster boundary.

    Pictorially what is done is the following (where ! denotes the end of
    the rx chain (i.e., RDBSS_CLUSTER_LAST)):


        Mcb (empty)

    becomes

        Mcb |--a--|--b--|--c--!

                            ^
        ByteCount ----------+

Arguments:

    Vcb - Supplies the VCB being modified

    AlternativeClusterHint - Supplies an alternative hint index to start the
                             search from.  If this is zero we use, and update,
                             the Vcb hint field.

    ByteCount - Supplies the number of bytes that we are requesting, and
                receives the number of bytes that we got.

    Mcb - Receives the MCB describing the newly allocated disk space.  The
          caller passes in an initialized Mcb that is fill in by this procedure.

--*/

{
    UCHAR LogOfBytesPerCluster;
    ULONG BytesPerCluster;
    ULONG StartingCluster;
    ULONG ClusterCount;
#if DBG
    ULONG i;
    ULONG PreviousClear;
#endif

    DebugTrace(+1, Dbg, "RxAllocateDiskSpace\n", 0);
    DebugTrace( 0, Dbg, "  Vcb        = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  *ByteCount = %8lx\n", *ByteCount);
    DebugTrace( 0, Dbg, "  Mcb        = %8lx\n", Mcb);

    //
    //  Make sure byte count is not zero
    //

    if (*ByteCount == 0) {

        DebugTrace(0, Dbg, "Nothing to allocate.\n", 0);

        DebugTrace(-1, Dbg, "RxAllocateDiskSpace -> (VOID)\n", 0);
        return;
    }

    //
    //  Compute the cluster count based on the byte count, rounding up
    //  to the next cluster if there is any remainder.  Note that the
    //  pathalogical case BytesCount == 0 has been eliminated above.
    //

    LogOfBytesPerCluster = Vcb->AllocationSupport.LogOfBytesPerCluster;
    BytesPerCluster = 1 << LogOfBytesPerCluster;

    *ByteCount = (*ByteCount + (BytesPerCluster - 1))
                            & ~(BytesPerCluster - 1);

    //
    //  If ByteCount is NOW zero, then we rolled over and there is
    //  no way we can satisfy the request.
    //

    if (*ByteCount == 0) {

        DebugTrace(0, Dbg, "Disk Full.  Raise Status.\n", 0);
        RxRaiseStatus( RxContext, RxStatus(DISK_FULL) );
    }

    ClusterCount = (*ByteCount >> LogOfBytesPerCluster);

    //
    //  Make sure there are enough free clusters to start with, and
    //  take them so that nobody else does later. Bah Humbug!
    //

    RxLockFreeClusterBitMap( Vcb );

    if (ClusterCount <= Vcb->AllocationSupport.NumberOfFreeClusters) {

        Vcb->AllocationSupport.NumberOfFreeClusters -= ClusterCount;

    } else {

        RxUnlockFreeClusterBitMap( Vcb );

        DebugTrace(0, Dbg, "Disk Full.  Raise Status.\n", 0);
        RxRaiseStatus( RxContext, RxStatus(DISK_FULL) );
    }

    //
    //  Try to find a run of free clusters large enough for us.
    //

    StartingCluster = RxFindFreeClusterRun( RxContext,
                                             Vcb,
                                             ClusterCount,
                                             AlternativeClusterHint );

    //
    //  If the above call was successful, we can just update the rx
    //  and Mcb and exit.  Otherwise we have to look for smaller free
    //  runs.
    //

    if (StartingCluster != 0xffffffff) {

        try {

#if DBG
            //
            //  Verify that the Bits are all really zero.
            //

            for (i=0; i<ClusterCount; i++) {
                ASSERT( RtlCheckBit(&Vcb->FreeClusterBitMap,
                                    StartingCluster + i) == 0 );
            }

            PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif // DBG

            //
            //  Take the clusters we found, and unlock the bit map.
            //

            RxReserveClusters(RxContext, Vcb, StartingCluster, ClusterCount);

            ASSERT( RtlNumberOfClearBits( &Vcb->FreeClusterBitMap ) ==
                    PreviousClear - ClusterCount );

            RxUnlockFreeClusterBitMap( Vcb );

            //
            //  Note that this call will never fail since there is always
            //  room for one entry in an empty Mcb.
            //

            FsRtlAddMcbEntry( Mcb,
                              0,
                              RxGetLboFromIndex( Vcb, StartingCluster ),
                              *ByteCount);

            //
            //  Update the rx.
            //

            RxAllocateClusters(RxContext, Vcb, StartingCluster, ClusterCount);

            //
            //  If we used the Vcb hint index, update it.
            //

            if (AlternativeClusterHint == 0) {

                Vcb->ClusterHint = StartingCluster + ClusterCount;
            }

        } finally {

            DebugUnwind( RxAllocateDiskSpace );

            //
            //  If the allocate clusters failed, remove the run from the Mcb,
            //  unreserve the clusters, and reset the free cluster count.
            //

            if ( AbnormalTermination() ) {

                FsRtlRemoveMcbEntry( Mcb, 0, *ByteCount );

                RxLockFreeClusterBitMap( Vcb );
#if DBG
                PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif
                RxUnreserveClusters( RxContext, Vcb, StartingCluster, ClusterCount );

                ASSERT( RtlNumberOfClearBits( &Vcb->FreeClusterBitMap ) ==
                        PreviousClear + ClusterCount );

                Vcb->AllocationSupport.NumberOfFreeClusters += ClusterCount;

                RxUnlockFreeClusterBitMap( Vcb );
            }
        }

    } else {

        ULONG Index;
        ULONG CurrentVbo;
        ULONG PriorLastIndex;
        ULONG BytesFound;

        ULONG ClustersFound;
        ULONG ClustersRemaining;

        try {

            //
            //  While the request is still incomplete, look for the largest
            //  run of free clusters, mark them taken, allocate the run in
            //  the Mcb and Rx, and if this isn't the first time through
            //  the loop link it to prior run on the rx.  The Mcb will
            //  coalesce automatically.
            //

            ClustersRemaining = ClusterCount;
            CurrentVbo = 0;
            PriorLastIndex = 0;

            while (ClustersRemaining != 0) {

                //
                //  If we just entered the loop, the bit map is already locked
                //

                if ( CurrentVbo != 0 ) {

                    RxLockFreeClusterBitMap( Vcb );
                }

                //
                //  Find the largest run of free clusters.  If the run is
                //  bigger than we need, only use what we need.  Note that
                //  this will then be the last while() itteration.
                //

                ClustersFound = RxLongestFreeClusterRun( RxContext, Vcb, &Index );

#if DBG
                //
                //  Verify that the Bits are all really zero.
                //

                for (i=0; i<ClustersFound; i++) {
                    ASSERT( RtlCheckBit(&Vcb->FreeClusterBitMap,
                                        Index + i) == 0 );
                }

                PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif // DBG

                if (ClustersFound > ClustersRemaining) {

                    ClustersFound = ClustersRemaining;
                }

                //
                //  If we found no free cluster, then our Vcb free cluster
                //  count is messed up, or our bit map is corrupted, or both.
                //

                if (ClustersFound == 0) {

                    RxBugCheck( 0, 0, 0 );
                }

                //
                //  Take the clusters we found, and unlock the bit map.
                //

                RxReserveClusters( RxContext, Vcb, Index, ClustersFound );

                ASSERT( RtlNumberOfClearBits( &Vcb->FreeClusterBitMap ) ==
                        PreviousClear - ClustersFound );

                RxUnlockFreeClusterBitMap( Vcb );

                //
                //  Add the newly alloced run to the Mcb.
                //

                BytesFound = ClustersFound << LogOfBytesPerCluster;

                FsRtlAddMcbEntry( Mcb,
                                  CurrentVbo,
                                  RxGetLboFromIndex( Vcb, Index ),
                                  BytesFound );

                //
                //  Connect the last allocated run with this one, and allocate
                //  this run on the Rx.
                //

                if (PriorLastIndex != 0) {

                    RxSetRxEntry( RxContext,
                                    Vcb,
                                    PriorLastIndex,
                                    (RDBSS_ENTRY)Index );
                }

                //
                //  Update the rx
                //

                RxAllocateClusters( RxContext, Vcb, Index, ClustersFound );

                //
                //  Prepare for the next itteration.
                //

                CurrentVbo += BytesFound;

                ClustersRemaining -= ClustersFound;

                PriorLastIndex = Index + ClustersFound - 1;
            }

            //
            //  Now all the requested clusters have been allocgated.
            //  If we were using the Vcb hint index, update it.
            //

            if (AlternativeClusterHint == 0) {

                Vcb->ClusterHint = Index + ClustersFound;
            }

        } finally {

            DebugUnwind( RxAllocateDiskSpace );

            //
            //  Is there any unwinding to do?
            //

            if ( AbnormalTermination() ) {

                //
                //  We must have failed during either the add mcb entry or
                //  allocate clusters.   Thus we always have to unreserve
                //  the current run.  If the allocate sectors failed, we
                //  must also remove the mcb run.  We just unconditionally
                //  remove the entry since, if it is not there, the effect
                //  is benign.
                //

                RxLockFreeClusterBitMap( Vcb );
#if DBG
                PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif
                RxUnreserveClusters( RxContext, Vcb, Index, ClustersFound );
                Vcb->AllocationSupport.NumberOfFreeClusters += ClustersFound;

                ASSERT( RtlNumberOfClearBits( &Vcb->FreeClusterBitMap ) ==
                        PreviousClear + ClustersFound );

                RxUnlockFreeClusterBitMap( Vcb );

                FsRtlRemoveMcbEntry( Mcb, CurrentVbo, BytesFound );

                //
                //  Now we have tidyed up, we are ready to just send it
                //  off to deallocate disk space
                //

                RxDeallocateDiskSpace( RxContext, Vcb, Mcb );

                //
                //  Now finally, remove all the entries from the mcb
                //

                FsRtlRemoveMcbEntry( Mcb, 0, 0xFFFFFFFF );
            }

            DebugTrace(-1, Dbg, "RxAllocateDiskSpace -> (VOID)\n", 0);
        }
    }

    return;
}


VOID
RxDeallocateDiskSpace (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PMCB Mcb
    )

/*++

Routine Description:

    This procedure deallocates the disk space denoted by an input
    mcb.  Note that the input MCB does not need to necessarily describe
    a chain that ends with a RDBSS_CLUSTER_LAST entry.

    Pictorially what is done is the following

        Rx |--a--|--b--|--c--|
        Mcb |--a--|--b--|--c--|

    becomes

        Rx |--0--|--0--|--0--|
        Mcb |--a--|--b--|--c--|

Arguments:

    Vcb - Supplies the VCB being modified

    Mcb - Supplies the MCB describing the disk space to deallocate.  Note
          that Mcb is unchanged by this procedure.


Return Value:

    VOID - TRUE if the operation completed and FALSE if it had to
        block but could not.

--*/

{
    LBO Lbo;
    VBO Vbo;

    ULONG RunsInMcb;
    ULONG ByteCount;
    ULONG ClusterCount;
    ULONG ClusterIndex;
    ULONG McbIndex;

    UCHAR LogOfBytesPerCluster;

    DebugTrace(+1, Dbg, "RxDeallocateDiskSpace\n", 0);
    DebugTrace( 0, Dbg, "  Vcb = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Mcb = %8lx\n", Mcb);

    LogOfBytesPerCluster = Vcb->AllocationSupport.LogOfBytesPerCluster;

    RunsInMcb = FsRtlNumberOfRunsInMcb( Mcb );

    if ( RunsInMcb == 0 ) {

        DebugTrace(-1, Dbg, "RxDeallocateDiskSpace -> (VOID)\n", 0);
        return;
    }

    try {

        //
        //  Run though the Mcb, freeing all the runs in the rx.
        //
        //  We do this in two steps (first update the rx, then the bitmap
        //  (which can't fail)) to prevent other people from taking clusters
        //  that we need to re-allocate in the event of unwind.
        //

        RunsInMcb = FsRtlNumberOfRunsInMcb( Mcb );

        for ( McbIndex = 0; McbIndex < RunsInMcb; McbIndex++ ) {

            FsRtlGetNextMcbEntry( Mcb, McbIndex, &Vbo, &Lbo, &ByteCount );

            //
            //  Assert that Rx files have no holes.
            //

            ASSERT( Lbo != 0 );

            //
            //  Write RDBSS_CLUSTER_AVAILABLE to each cluster in the run.
            //

            ClusterCount = ByteCount >> LogOfBytesPerCluster;
            ClusterIndex = RxGetIndexFromLbo( Vcb, Lbo );

            RxFreeClusters( RxContext, Vcb, ClusterIndex, ClusterCount );
        }

        //
        //  From now on, nothing can go wrong .... (as in raise)
        //

        RxLockFreeClusterBitMap( Vcb );

        for ( McbIndex = 0; McbIndex < RunsInMcb; McbIndex++ ) {
#if DBG
            ULONG PreviousClear;
#endif

            FsRtlGetNextMcbEntry( Mcb, McbIndex, &Vbo, &Lbo, &ByteCount );

            //
            //  Write RDBSS_CLUSTER_AVAILABLE to each cluster in the run, and
            //  mark the bits clear in the FreeClusterBitMap.
            //

            ClusterCount = ByteCount >> LogOfBytesPerCluster;
            ClusterIndex = RxGetIndexFromLbo( Vcb, Lbo );
#if DBG
            PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif
            RxUnreserveClusters( RxContext, Vcb, ClusterIndex, ClusterCount );

            ASSERT( RtlNumberOfClearBits( &Vcb->FreeClusterBitMap ) ==
                    PreviousClear + ClusterCount );

            //
            //  Deallocation is now complete.  Adjust the free cluster count.
            //

            Vcb->AllocationSupport.NumberOfFreeClusters += ClusterCount;
        }

        RxUnlockFreeClusterBitMap( Vcb );

    } finally {

        DebugUnwind( RxDeallocateDiskSpace );

        //
        //  Is there any unwinding to do?
        //

        if ( AbnormalTermination() ) {

            LBO Lbo;
            VBO Vbo;

            ULONG Index;
            ULONG Clusters;
            ULONG RxIndex;
            ULONG PriorLastIndex;

            //
            //  For each entry we already deallocated, reallocate it,
            //  chaining together as nessecary.  Note that we continue
            //  up to and including the last "for" itteration even though
            //  the SetRxRun could not have been successful.  This
            //  allows us a convienent way to re-link the final successful
            //  SetRxRun.
            //

            PriorLastIndex = 0;

            for (Index = 0; Index <= McbIndex; Index++) {

                FsRtlGetNextMcbEntry(Mcb, Index, &Vbo, &Lbo, &ByteCount);

                RxIndex = RxGetIndexFromLbo( Vcb, Lbo );
                Clusters = ByteCount >> LogOfBytesPerCluster;

                //
                //  We must always restore the prior itteration's last
                //  entry, pointing it to the first cluster of this run.
                //

                if (PriorLastIndex != 0) {

                    RxSetRxEntry( RxContext,
                                    Vcb,
                                    PriorLastIndex,
                                    (RDBSS_ENTRY)RxIndex );
                }

                //
                //  If this is not the last entry (the one that failed)
                //  then reallocate the disk space on the rx.
                //

                if ( Index < McbIndex ) {

                    RxAllocateClusters(RxContext, Vcb, RxIndex, Clusters);

                    PriorLastIndex = RxIndex + Clusters - 1;
                }
            }
        }

        DebugTrace(-1, Dbg, "RxDeallocateDiskSpace -> (VOID)\n", 0);
    }

    return;
}


VOID
RxSplitAllocation (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN OUT PMCB Mcb,
    IN VBO SplitAtVbo,
    OUT PMCB RemainingMcb
    )

/*++

Routine Description:

    This procedure takes a single mcb and splits its allocation into
    two separate allocation units.  The separation must only be done
    on cluster boundaries, otherwise we bugcheck.

    On the disk this actually works by inserting a RDBSS_CLUSTER_LAST into
    the last index of the first part being split out.

    Pictorially what is done is the following (where ! denotes the end of
    the rx chain (i.e., RDBSS_CLUSTER_LAST)):


        Mcb          |--a--|--b--|--c--|--d--|--e--|--f--|

                                        ^
        SplitAtVbo ---------------------+

        RemainingMcb (empty)

    becomes

        Mcb          |--a--|--b--|--c--!


        RemainingMcb |--d--|--e--|--f--|

Arguments:

    Vcb - Supplies the VCB being modified

    Mcb - Supplies the MCB describing the allocation being split into
          two parts.  Upon return this Mcb now contains the first chain.

    SplitAtVbo - Supplies the VBO of the first byte for the second chain
                 that we creating.

    RemainingMcb - Receives the MCB describing the second chain of allocated
                   disk space.  The caller passes in an initialized Mcb that
                   is filled in by this procedure STARTING AT VBO 0.

Return Value:

    VOID - TRUE if the operation completed and FALSE if it had to
               block but could not.

--*/

{
    VBO SourceVbo;
    VBO TargetVbo;
    VBO DontCare;

    LBO Lbo;

    ULONG ByteCount;
    ULONG BytesPerCluster;

    DebugTrace(+1, Dbg, "RxSplitAllocation\n", 0);
    DebugTrace( 0, Dbg, "  Vcb          = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Mcb          = %8lx\n", Mcb);
    DebugTrace( 0, Dbg, "  SplitAtVbo   = %8lx\n", SplitAtVbo);
    DebugTrace( 0, Dbg, "  RemainingMcb = %8lx\n", RemainingMcb);

    BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    //
    //  Assert that the split point is cluster alligned
    //

    ASSERT( (SplitAtVbo & (BytesPerCluster - 1)) == 0 );

    //
    //  Assert we were given an empty target Mcb.
    //

    //
    //  This assert is commented out to avoid hitting in the Ea error
    //  path.  In that case we will be using the same Mcb's to split the
    //  allocation that we used to merge them.  The target Mcb will contain
    //  the runs that the split will attempt to insert.
    //
    //
    //  ASSERT( FsRtlNumberOfRunsInMcb( RemainingMcb ) == 0 );
    //

    try {

        //
        //  Move the runs after SplitAtVbo from the souce to the target
        //

        SourceVbo = SplitAtVbo;
        TargetVbo = 0;

        while (FsRtlLookupMcbEntry(Mcb, SourceVbo, &Lbo, &ByteCount, NULL)) {

            FsRtlAddMcbEntry( RemainingMcb, TargetVbo, Lbo, ByteCount );

            FsRtlRemoveMcbEntry( Mcb, SourceVbo, ByteCount );

            TargetVbo += ByteCount;
            SourceVbo += ByteCount;
        }

        //
        //  Mark the last pre-split cluster as a RDBSS_LAST_CLUSTER
        //

        if ( SplitAtVbo != 0 ) {

            FsRtlLookupLastMcbEntry( Mcb, &DontCare, &Lbo );

            RxSetRxEntry( RxContext,
                            Vcb,
                            RxGetIndexFromLbo( Vcb, Lbo ),
                            RDBSS_CLUSTER_LAST );
        }

    } finally {

        DebugUnwind( RxSplitAllocation );

        //
        //  If we got an exception, we must glue back together the Mcbs
        //

        if ( AbnormalTermination() ) {

            TargetVbo = SplitAtVbo;
            SourceVbo = 0;

            while (FsRtlLookupMcbEntry(RemainingMcb, SourceVbo, &Lbo, &ByteCount, NULL)) {

                FsRtlAddMcbEntry( Mcb, TargetVbo, Lbo, ByteCount );

                FsRtlRemoveMcbEntry( RemainingMcb, SourceVbo, ByteCount );

                TargetVbo += ByteCount;
                SourceVbo += ByteCount;
            }
        }

        DebugTrace(-1, Dbg, "RxSplitAllocation -> (VOID)\n", 0);
    }

    return;
}


VOID
RxMergeAllocation (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN OUT PMCB Mcb,
    IN PMCB SecondMcb
    )

/*++

Routine Description:

    This routine takes two separate allocations described by two MCBs and
    joins them together into one allocation.

    Pictorially what is done is the following (where ! denotes the end of
    the rx chain (i.e., RDBSS_CLUSTER_LAST)):


        Mcb       |--a--|--b--|--c--!

        SecondMcb |--d--|--e--|--f--|

    becomes

        Mcb       |--a--|--b--|--c--|--d--|--e--|--f--|

        SecondMcb |--d--|--e--|--f--|


Arguments:

    Vcb - Supplies the VCB being modified

    Mcb - Supplies the MCB of the first allocation that is being modified.
          Upon return this Mcb will also describe the newly enlarged
          allocation

    SecondMcb - Supplies the ZERO VBO BASED MCB of the second allocation
                that is being appended to the first allocation.  This
                procedure leaves SecondMcb unchanged.

Return Value:

    VOID - TRUE if the operation completed and FALSE if it had to
        block but could not.

--*/

{
    VBO SpliceVbo;
    LBO SpliceLbo;

    VBO SourceVbo;
    VBO TargetVbo;

    LBO Lbo;

    ULONG ByteCount;

    DebugTrace(+1, Dbg, "RxMergeAllocation\n", 0);
    DebugTrace( 0, Dbg, "  Vcb       = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Mcb       = %8lx\n", Mcb);
    DebugTrace( 0, Dbg, "  SecondMcb = %8lx\n", SecondMcb);

    try {

        //
        //  Append the runs from SecondMcb to Mcb
        //

        FsRtlLookupLastMcbEntry( Mcb, &SpliceVbo, &SpliceLbo );

        SourceVbo = 0;
        TargetVbo = SpliceVbo + 1;

        while (FsRtlLookupMcbEntry(SecondMcb, SourceVbo, &Lbo, &ByteCount, NULL)) {

            FsRtlAddMcbEntry( Mcb, TargetVbo, Lbo, ByteCount );

            SourceVbo += ByteCount;
            TargetVbo += ByteCount;
        }

        //
        //  Link the last pre-merge cluster to the first cluster of SecondMcb
        //

        FsRtlLookupMcbEntry( SecondMcb, 0, &Lbo, (PULONG)NULL, NULL );

        RxSetRxEntry( RxContext,
                        Vcb,
                        RxGetIndexFromLbo( Vcb, SpliceLbo ),
                        (RDBSS_ENTRY)RxGetIndexFromLbo( Vcb, Lbo ) );

    } finally {

        DebugUnwind( RxMergeAllocation );

        //
        //  If we got an exception, we must remove the runs added to Mcb
        //

        if ( AbnormalTermination() ) {

            ULONG CutLength;

            if ((CutLength = TargetVbo - (SpliceVbo + 1)) != 0) {

                FsRtlRemoveMcbEntry( Mcb, SpliceVbo + 1, CutLength);
            }
        }

        DebugTrace(-1, Dbg, "RxMergeAllocation -> (VOID)\n", 0);
    }

    return;
}


//
//  Internal support routine
//

CLUSTER_TYPE
RxInterpretClusterType (
    IN PVCB Vcb,
    IN RDBSS_ENTRY Entry
    )

/*++

Routine Description:

    This procedure tells the caller how to interpret the input rx table
    entry.  It will indicate if the rx cluster is available, resereved,
    bad, the last one, or the another rx index.  This procedure can deal
    with both 12 and 16 bit rx.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16 bit info

    Entry - Supplies the rx entry to examine

Return Value:

    CLUSTER_TYPE - Is the type of the input Rx entry

--*/

{
    DebugTrace(+1, Dbg, "InterpretClusterType\n", 0);
    DebugTrace( 0, Dbg, "  Vcb   = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Entry = %8lx\n", Entry);

    //
    //  check for 12 or 16 bit rx
    //

    if (Vcb->AllocationSupport.RxIndexBitSize == 12) {

        //
        //  for 12 bit rx check for one of the cluster types, but first
        //  make sure we only looking at 12 bits of the entry
        //

        ASSERT( Entry <= 0xfff );

        if (Entry == 0x000) {

            DebugTrace(-1, Dbg, "RxInterpretClusterType -> RxClusterAvailable\n", 0);

            return RxClusterAvailable;

        } else if (Entry < 0xff0) {

            DebugTrace(-1, Dbg, "RxInterpretClusterType -> RxClusterNext\n", 0);

            return RxClusterNext;

        } else if (Entry >= 0xff8) {

            DebugTrace(-1, Dbg, "RxInterpretClusterType -> RxClusterLast\n", 0);

            return RxClusterLast;

        } else if (Entry <= 0xff6) {

            DebugTrace(-1, Dbg, "RxInterpretClusterType -> RxClusterReserved\n", 0);

            return RxClusterReserved;

        } else if (Entry == 0xff7) {

            DebugTrace(-1, Dbg, "RxInterpretClusterType -> RxClusterBad\n", 0);

            return RxClusterBad;
        }

   } else {

        //
        //  for 16 bit rx check for one of the cluster types, but first
        //  make sure we are only looking at 16 bits of the entry
        //

        ASSERT( Entry <= 0xffff );

        if (Entry == 0x0000) {

            DebugTrace(-1, Dbg, "RxInterpretClusterType -> RxClusterAvailable\n", 0);

            return RxClusterAvailable;

        } else if (Entry < 0xfff0) {

            DebugTrace(-1, Dbg, "RxInterpretClusterType -> RxClusterNext\n", 0);

            return RxClusterNext;

        } else if (Entry >= 0xfff8) {

            DebugTrace(-1, Dbg, "RxInterpretClusterType -> RxClusterLast\n", 0);

            return RxClusterLast;

        } else if (Entry <= 0xfff6) {

            DebugTrace(-1, Dbg, "RxInterpretClusterType -> RxClusterReserved\n", 0);

            return RxClusterReserved;

        } else if (Entry == 0xfff7) {

            DebugTrace(-1, Dbg, "RxInterpretClusterType -> RxClusterBad\n", 0);

            return RxClusterBad;
        }
    }
}


//
//  Internal support routine
//

VOID
RxLookupRxEntry (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN ULONG RxIndex,
    IN OUT PRDBSS_ENTRY RxEntry,
    IN OUT PRDBSS_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine takes an index into the rx and gives back the value
    in the Rx at this index.  At any given time, for a 16 bit rx, this
    routine allows only one page per volume of the rx to be pinned in
    memory.  For a 12 bit bit rx, the entire rx (max 6k) is pinned.  This
    extra layer of caching makes the vast majority of requests very
    fast.  The context for this caching stored in a structure in the Vcb.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16 bit info,
          rx access context, etc.

    RxIndex - Supplies the rx index to examine.

    RxEntry - Receives the rx entry pointed to by RxIndex.  Note that
               it must point to non-paged pool.

    Context - This structure keeps track of a page of pinned rx between calls.

--*/

{
    DebugTrace(+1, Dbg, "RxLookupRxEntry\n", 0);
    DebugTrace( 0, Dbg, "  Vcb      = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  RxIndex = %4x\n", RxIndex);
    DebugTrace( 0, Dbg, "  RxEntry = %8lx\n", RxEntry);

    //
    //  Make sure they gave us a valid rx index.
    //

    RxVerifyIndexIsValid(RxContext, Vcb, RxIndex);

    //
    //  Case on 12 or 16 bit rxs.
    //
    //  In the 12 bit case (mostly floppies) we always have the whole rx
    //  (max 6k bytes) pinned during allocation operations.  This is possibly
    //  a wee bit slower, but saves headaches over rx entries with 8 bits
    //  on one page, and 4 bits on the next.
    //
    //  The 16 bit case always keeps the last used page pinned until all
    //  operations are done and it is unpinned.
    //

    //
    //  DEAL WITH 12 BIT CASE
    //

    if (Vcb->AllocationSupport.RxIndexBitSize == 12) {

        //
        //  Check to see if the rx is already pinned, otherwise pin it.
        //

        if (Context->Bcb == NULL) {

            RxReadVolumeFile( RxContext,
                               Vcb,
                               RxReservedBytes( &Vcb->Bpb ),
                               RxBytesPerRx( &Vcb->Bpb ),
                               &Context->Bcb,
                               &Context->PinnedPage );
        }

        //
        //  Load the return value.
        //

        RxLookup12BitEntry( Context->PinnedPage, RxIndex, RxEntry );

    } else {

        //
        //  DEAL WITH 16 BIT CASE
        //

        ULONG PageEntryOffset;
        ULONG OffsetIntoVolumeFile;

        //
        //  Initialize two local variables that help us.
        //

        OffsetIntoVolumeFile = RxReservedBytes(&Vcb->Bpb) + RxIndex * sizeof(RDBSS_ENTRY);
        PageEntryOffset = (OffsetIntoVolumeFile % PAGE_SIZE) / sizeof(RDBSS_ENTRY);

        //
        //  Check to see if we need to read in a new page of rx
        //

        if ((Context->Bcb == NULL) ||
            (OffsetIntoVolumeFile / PAGE_SIZE != Context->VboOfPinnedPage / PAGE_SIZE)) {

            //
            //  The entry wasn't in the pinned page, so must we unpin the current
            //  page (if any) and read in a new page.
            //

            RxUnpinBcb( RxContext, Context->Bcb );

            RxReadVolumeFile( RxContext,
                               Vcb,
                               OffsetIntoVolumeFile & ~(PAGE_SIZE - 1),
                               PAGE_SIZE,
                               &Context->Bcb,
                               &Context->PinnedPage );

            Context->VboOfPinnedPage = OffsetIntoVolumeFile & ~(PAGE_SIZE - 1);
        }

        //
        //  Grab the rx entry from the pinned page, and return
        //

        *RxEntry = ((PRDBSS_ENTRY)(Context->PinnedPage))[PageEntryOffset];
    }

    DebugTrace(-1, Dbg, "RxLookupRxEntry -> (VOID)\n", 0);
    return;
}


//
//  Internal support routine
//

VOID
RxSetRxEntry (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN ULONG RxIndex,
    IN RDBSS_ENTRY RxEntry
    )

/*++

Routine Description:

    This routine takes an index into the rx and puts a value in the Rx
    at this index.  The routine special cases 12 and 16 bit rxs.  In both
    cases we go to the cache manager for a piece of the rx.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16 bit info, etc.

    RxIndex - Supplies the destination rx index.

    RxEntry - Supplies the source rx entry.

--*/

{
    LBO Lbo;
    PBCB Bcb = NULL;
    ULONG SectorSize;
    ULONG OffsetIntoVolumeFile;
    BOOLEAN ReleaseMutex = FALSE;

    DebugTrace(+1, Dbg, "RxSetRxEntry\n", 0);
    DebugTrace( 0, Dbg, "  Vcb      = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  RxIndex = %4x\n", RxIndex);
    DebugTrace( 0, Dbg, "  RxEntry = %4x\n", RxEntry);

    //
    //  Make sure they gave us a valid rx index.
    //

    RxVerifyIndexIsValid(RxContext, Vcb, RxIndex);

    //
    //  Set Sector Size
    //

    SectorSize = 1 << Vcb->AllocationSupport.LogOfBytesPerSector;

    //
    //  Case on 12 or 16 bit rxs.
    //
    //  In the 12 bit case (mostly floppies) we always have the whole rx
    //  (max 6k bytes) pinned during allocation operations.  This is possibly
    //  a wee bit slower, but saves headaches over rx entries with 8 bits
    //  on one page, and 4 bits on the next.
    //
    //  In the 16 bit case we only read the page that we need to set the rx
    //  entry.
    //

    //
    //  DEAL WITH 12 BIT CASE
    //

    try {

        if (Vcb->AllocationSupport.RxIndexBitSize == 12) {

            PVOID PinnedRx;

            //
            //  Make sure we have a valid entry
            //

            RxEntry &= 0xfff;

            //
            //  We read in the entire rx.  Note that using prepare write marks
            //  the bcb pre-dirty, so we don't have to do it explicitly.
            //

            OffsetIntoVolumeFile = RxReservedBytes( &Vcb->Bpb ) + RxIndex * 3 / 2;

            RxPrepareWriteVolumeFile( RxContext,
                                       Vcb,
                                       RxReservedBytes( &Vcb->Bpb ),
                                       RxBytesPerRx( &Vcb->Bpb ),
                                       &Bcb,
                                       &PinnedRx,
                                       FALSE );

            //
            //  Mark the sector(s) dirty in the DirtyRxMcb.  This call is
            //  complicated somewhat for the 12 bit case since a single
            //  entry write can span two sectors (and pages).
            //
            //  Get the Lbo for the sector where the entry starts, and add it to
            //  the dirty rx Mcb.
            //

            Lbo = OffsetIntoVolumeFile & ~(SectorSize - 1);

            FsRtlAddMcbEntry( &Vcb->DirtyRxMcb, Lbo, Lbo, SectorSize);

            //
            //  If the entry started on the last byte of the sector, it continues
            //  to the next sector, so mark the next sector dirty as well.
            //
            //  Note that this entry will simply coalese with the last entry,
            //  so this operation cannot fail.  Also if we get this far, we have
            //  made it, so no unwinding will be needed.
            //

            if ( (OffsetIntoVolumeFile & (SectorSize - 1)) == (SectorSize - 1) ) {

                Lbo += SectorSize;

                FsRtlAddMcbEntry( &Vcb->DirtyRxMcb, Lbo, Lbo, SectorSize );
            }

            //
            //  Store the entry into the rx; we need a little synchonization
            //  here and can't use a spinlock since the bytes might not be
            //  resident.
            //

            RxLockFreeClusterBitMap( Vcb );

            ReleaseMutex = TRUE;

            RxSet12BitEntry( PinnedRx, RxIndex, RxEntry );

            ReleaseMutex = FALSE;

            RxUnlockFreeClusterBitMap( Vcb );

        } else {

            //
            //  DEAL WITH 16 BIT CASE
            //

            PRDBSS_ENTRY PinnedRxEntry;

            //
            //  Read in a new page of rx
            //

            OffsetIntoVolumeFile = RxReservedBytes( &Vcb->Bpb ) +
                                   RxIndex * sizeof( RDBSS_ENTRY );

            RxPrepareWriteVolumeFile( RxContext,
                                       Vcb,
                                       OffsetIntoVolumeFile,
                                       sizeof(RDBSS_ENTRY),
                                       &Bcb,
                                       (PVOID *)&PinnedRxEntry,
                                       FALSE );

            //
            //  Mark the sector dirty in the DirtyRxMcb
            //

            Lbo = OffsetIntoVolumeFile & ~(SectorSize - 1);

            FsRtlAddMcbEntry( &Vcb->DirtyRxMcb, Lbo, Lbo, SectorSize);

            //
            //  Store the RxEntry to the pinned page.
            //
            //  We need extra synchronization here for broken architectures
            //  like the ALPHA that don't support atomic 16 bit writes.
            //

#ifdef ALPHA
            RxLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;
            *PinnedRxEntry = RxEntry;
            ReleaseMutex = FALSE;
            RxUnlockFreeClusterBitMap( Vcb );
#else
            *PinnedRxEntry = RxEntry;
#endif // ALPHA
        }

    } finally {

        DebugUnwind( RxSetRxEntry );

        //
        //  If we still somehow have the Mutex, release it.
        //

        if (ReleaseMutex) {

            ASSERT( AbnormalTermination() );

            RxUnlockFreeClusterBitMap( Vcb );
        }

        //
        //  Unpin the Bcb
        //

        RxUnpinBcb(RxContext, Bcb);

        DebugTrace(-1, Dbg, "RxSetRxEntry -> (VOID)\n", 0);
    }

    return;
}


//
//  Internal support routine
//

VOID
RxSetRxRun (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN ULONG StartingRxIndex,
    IN ULONG ClusterCount,
    IN BOOLEAN ChainTogether
    )

/*++

Routine Description:

    This routine sets a continues run of clusters in the rx.  If ChainTogether
    is TRUE, then the clusters are linked together as in normal Rx fasion,
    with the last cluster receiving RDBSS_CLUSTER_LAST.  If ChainTogether is
    FALSE, all the entries are set to RDBSS_CLUSTER_AVAILABLE, effectively
    freeing all the clusters in the run.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16 bit info, etc.

    StartingRxIndex - Supplies the destination rx index.

    ClusterCount - Supplies the number of contiguous clusters to work on.

    ChainTogether - Tells us whether to fill the entries with links, or
                    RDBSS_CLUSTER_AVAILABLE


Return Value:

    VOID

--*/

{
    PBCB SavedBcbs[(0x10000 * sizeof(RDBSS_ENTRY) / PAGE_SIZE) + 2][2];

    ULONG SectorSize;
    ULONG Cluster;

    LBO StartSectorLbo;
    LBO FinalSectorLbo;
    LBO Lbo;

    PVOID PinnedRx;

    ULONG StartingPage;

    BOOLEAN ReleaseMutex = FALSE;

    DebugTrace(+1, Dbg, "RxSetRxRun\n", 0);
    DebugTrace( 0, Dbg, "  Vcb              = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  StartingRxIndex = %8x\n", StartingRxIndex);
    DebugTrace( 0, Dbg, "  ClusterCount     = %8lx\n", ClusterCount);
    DebugTrace( 0, Dbg, "  ChainTogether    = %s\n", ChainTogether ? "TRUE":"FALSE");

    //
    //  Make sure they gave us a valid rx run.
    //

    RxVerifyIndexIsValid(RxContext, Vcb, StartingRxIndex);
    RxVerifyIndexIsValid(RxContext, Vcb, StartingRxIndex + ClusterCount - 1);

    //
    //  Check special case
    //

    if (ClusterCount == 0) {

        DebugTrace(-1, Dbg, "RxSetRxRun -> (VOID)\n", 0);
        return;
    }

    //
    //  Set Sector Size
    //

    SectorSize = 1 << Vcb->AllocationSupport.LogOfBytesPerSector;

    //
    //  Case on 12 or 16 bit rxs.
    //
    //  In the 12 bit case (mostly floppies) we always have the whole rx
    //  (max 6k bytes) pinned during allocation operations.  This is possibly
    //  a wee bit slower, but saves headaches over rx entries with 8 bits
    //  on one page, and 4 bits on the next.
    //
    //  In the 16 bit case we only read one page at a time, as needed.
    //

    //
    //  DEAL WITH 12 BIT CASE
    //

    try {

        if (Vcb->AllocationSupport.RxIndexBitSize == 12) {

            StartingPage = 0;

            //
            //  We read in the entire rx.  Note that using prepare write marks
            //  the bcb pre-dirty, so we don't have to do it explicitly.
            //

            RtlZeroMemory( &SavedBcbs[0], 2 * sizeof(PBCB) * 2);

            RxPrepareWriteVolumeFile( RxContext,
                                       Vcb,
                                       RxReservedBytes( &Vcb->Bpb ),
                                       RxBytesPerRx( &Vcb->Bpb ),
                                       &SavedBcbs[0][0],
                                       &PinnedRx,
                                       FALSE );

            //
            //  Mark the affected sectors dirty.  Note that FinalSectorLbo is
            //  the Lbo of the END of the entry (Thus * 3 + 2).  This makes sure
            //  we catch the case of a dirty rx entry stragling a sector boundry.
            //
            //  Note that if the first AddMcbEntry succeeds, all following ones
            //  will simply coalese, and thus also succeed.
            //

            StartSectorLbo = (RxReservedBytes( &Vcb->Bpb ) + StartingRxIndex * 3 / 2)
                             & ~(SectorSize - 1);

            FinalSectorLbo = (RxReservedBytes( &Vcb->Bpb ) + ((StartingRxIndex +
                             ClusterCount) * 3 + 2) / 2) & ~(SectorSize - 1);

            for (Lbo = StartSectorLbo; Lbo <= FinalSectorLbo; Lbo += SectorSize) {

                FsRtlAddMcbEntry( &Vcb->DirtyRxMcb, Lbo, Lbo, SectorSize );
            }

            //
            //  Store the entries into the rx; we need a little
            //  synchonization here and can't use a spinlock since the bytes
            //  might not be resident.
            //

            RxLockFreeClusterBitMap( Vcb );

            ReleaseMutex = TRUE;

            for (Cluster = StartingRxIndex;
                 Cluster < StartingRxIndex + ClusterCount - 1;
                 Cluster++) {

                RxSet12BitEntry( PinnedRx,
                                  Cluster,
                                  ChainTogether ? Cluster + 1 : RDBSS_CLUSTER_AVAILABLE );
            }

            //
            //  Save the last entry
            //

            RxSet12BitEntry( PinnedRx,
                              Cluster,
                              ChainTogether ?
                              RDBSS_CLUSTER_LAST & 0xfff : RDBSS_CLUSTER_AVAILABLE );

            ReleaseMutex = FALSE;

            RxUnlockFreeClusterBitMap( Vcb );

        } else {

            //
            //  DEAL WITH 16 BIT CASE
            //

            VBO StartOffsetInVolume;
            VBO FinalOffsetInVolume;

            ULONG Page;
            ULONG FinalCluster;
            PRDBSS_ENTRY RxEntry;

            StartOffsetInVolume = RxReservedBytes(&Vcb->Bpb) +
                                        StartingRxIndex * sizeof(RDBSS_ENTRY);

            FinalOffsetInVolume = StartOffsetInVolume +
                                        (ClusterCount - 1) * sizeof(RDBSS_ENTRY);

            StartingPage = StartOffsetInVolume / PAGE_SIZE;

            //
            //  Read in one page of rx at a time.  We cannot read in the
            //  all of the rx we need because of cache manager limitations.
            //
            //  SavedBcb was initialized to be able to hold the largest
            //  possible number of pages in a rx plus and extra one to
            //  accomadate the boot sector, plus one more to make sure there
            //  is enough room for the RtlZeroMemory below that needs the mark
            //  the first Bcb after all the ones we will use as an end marker.
            //

            {
                ULONG NumberOfPages;
                ULONG Offset;

                NumberOfPages = (FinalOffsetInVolume / PAGE_SIZE) -
                                (StartOffsetInVolume / PAGE_SIZE) + 1;

                RtlZeroMemory( &SavedBcbs[0][0], (NumberOfPages + 1) * sizeof(PBCB) * 2 );

                for ( Page = 0, Offset = StartOffsetInVolume & ~(PAGE_SIZE - 1);
                      Page < NumberOfPages;
                      Page++, Offset += PAGE_SIZE ) {

                    RxPrepareWriteVolumeFile( RxContext,
                                               Vcb,
                                               Offset,
                                               PAGE_SIZE,
                                               &SavedBcbs[Page][0],
                                               (PVOID *)&SavedBcbs[Page][1],
                                               FALSE );

                    if (Page == 0) {

                        RxEntry = (PRDBSS_ENTRY)((PUCHAR)SavedBcbs[0][1] +
                                            (StartOffsetInVolume % PAGE_SIZE));
                    }
                }
            }

            //
            //  Mark the run dirty
            //

            StartSectorLbo = StartOffsetInVolume & ~(SectorSize - 1);
            FinalSectorLbo = FinalOffsetInVolume & ~(SectorSize - 1);

            for (Lbo = StartSectorLbo; Lbo <= FinalSectorLbo; Lbo += SectorSize) {

                FsRtlAddMcbEntry( &Vcb->DirtyRxMcb, Lbo, Lbo, SectorSize );
            }

            //
            //  Store the entries
            //
            //  We need extra synchronization here for broken architectures
            //  like the ALPHA that don't support atomic 16 bit writes.
            //

#ifdef ALPHA
            RxLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;
#endif // ALPHA

            FinalCluster = StartingRxIndex + ClusterCount - 1;
            Page = 0;

            for (Cluster = StartingRxIndex;
                 Cluster <= FinalCluster;
                 Cluster++, RxEntry++) {

                //
                //  If we just crossed a page boundry (as apposed to starting
                //  on one), update out idea of RxEntry.

                if ( (((ULONG)RxEntry & (PAGE_SIZE-1)) == 0) &&
                     (Cluster != StartingRxIndex) ) {

                    Page += 1;
                    RxEntry = (PRDBSS_ENTRY)SavedBcbs[Page][1];
                }

                *RxEntry = ChainTogether ? (RDBSS_ENTRY)(Cluster + 1) :
                                            RDBSS_CLUSTER_AVAILABLE;
            }

            //
            //  Fix up the last entry if we were chaining together
            //

            if ( ChainTogether ) {

                *(RxEntry-1) = RDBSS_CLUSTER_LAST;
            }
#ifdef ALPHA
            ReleaseMutex = FALSE;
            RxUnlockFreeClusterBitMap( Vcb );
#endif // ALPHA

        }

    } finally {

        ULONG i = 0;

        DebugUnwind( RxSetRxRun );

        //
        //  If we still somehow have the Mutex, release it.
        //

        if (ReleaseMutex) {

            ASSERT( AbnormalTermination() );

            RxUnlockFreeClusterBitMap( Vcb );
        }

        //
        //  Unpin the Bcbs
        //

        while ( SavedBcbs[i][0] != NULL ) {

            RxUnpinBcb( RxContext, SavedBcbs[i][0] );

            i += 1;
        }

        DebugTrace(-1, Dbg, "RxSetRxRun -> (VOID)\n", 0);
    }

    return;
}


//
//  Internal support routine
//

UCHAR
RxLogOf (
    IN ULONG Value
    )

/*++

Routine Description:

    This routine just computes the base 2 log of an integer.  It is only used
    on objects that are know to be powers of two.

Arguments:

    Value - The value to take the base 2 log of.

Return Value:

    UCHAR - The base 2 log of Value.

--*/

{
    UCHAR Log = 0;

    DebugTrace(+1, Dbg, "LogOf\n", 0);
    DebugTrace( 0, Dbg, "  Value = %8lx\n", Value);

    //
    //  Knock bits off until we we get a one at position 0
    //

    while ( (Value & 0xfffffffe) != 0 ) {

        Log++;
        Value >>= 1;
    }

    //
    //  If there was more than one bit set, the file system messed up,
    //  Bug Check.
    //

    if (Value != 0x1) {

        DebugTrace( 0, Dbg, "Received non power of 2.\n", 0);

        RxBugCheck( Value, Log, 0 );
    }

    DebugTrace(-1, Dbg, "LogOf -> %8lx\n", Log);

    return Log;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\dsdump.c ===
#include <nt.h>
#include <stdio.h>
#include <string.h>

//    ----------------------joejoe-----------found-------------#include "RxProcs.h"
#include "precomp.h"
#pragma hdrstop

UCHAR CompressedBuffer[0x8000];
UCHAR UncompressedBuffer[0x8000];


VOID
DsDumpSyntax (
    PCHAR argv0
    )
{
    printf("Syntax - %s -h <FileName>\n", argv0);
    printf("         %s -c <FileName> [0x]<Offset> [0x]<DecompressedLength> [0x]<CompressedLength> [<OutputFile>]\n", argv0);
    printf("         %s -d <FileName> [0x]<Offset> [0x]<CompressedLength> [0x]<DecompressedLength> [<OutputFile>]\n", argv0);
    return;
}

VOID
DumpHeader (
    ULONG argc,
    PCHAR argv[],
    FILE *pf
    )
{
    ULONG FileSize;

    PACKED_CVF_HEADER PackedCvfHeader;
    CVF_HEADER CvfHeader;
    CVF_LAYOUT CvfLayout;

    //
    //  Get the file size
    //

    (VOID)fseek( pf, 0, SEEK_END );
    FileSize = ftell( pf );

    //
    //  Read in and decode the cvf header
    //

    (VOID)fseek( pf, 0, SEEK_SET );
    (VOID)fread( &PackedCvfHeader, 1, sizeof(PACKED_CVF_HEADER), pf );
    CvfUnpackCvfHeader( &CvfHeader, &PackedCvfHeader );

    //
    //  Now compute the cvf layout
    //

    CvfLayout( &CvfLayout, &CvfHeader, FileSize );

    //
    //  Print the unpacked CvfHeader and the Layout
    //

    fprintf(stderr, "\n%s:\n", argv[2]);

    printf("\n");
    printf("CvfHeader.Bpb.BytesPerSector        = %08lx\n", CvfHeader.Bpb.BytesPerSector);
    printf("CvfHeader.Bpb.SectorsPerCluster     = %08lx\n", CvfHeader.Bpb.SectorsPerCluster);
    printf("CvfHeader.Bpb.ReservedSectors       = %08lx\n", CvfHeader.Bpb.ReservedSectors);
    printf("CvfHeader.Bpb.Rxs                  = %08lx\n", CvfHeader.Bpb.Rxs);
    printf("CvfHeader.Bpb.RootEntries           = %08lx\n", CvfHeader.Bpb.RootEntries);
    printf("CvfHeader.Bpb.Sectors               = %08lx\n", CvfHeader.Bpb.Sectors);
    printf("CvfHeader.Bpb.Media                 = %08lx\n", CvfHeader.Bpb.Media);
    printf("CvfHeader.Bpb.SectorsPerRx         = %08lx\n", CvfHeader.Bpb.SectorsPerRx);
    printf("CvfHeader.Bpb.SectorsPerTrack       = %08lx\n", CvfHeader.Bpb.SectorsPerTrack);
    printf("CvfHeader.Bpb.Heads                 = %08lx\n", CvfHeader.Bpb.Heads);
    printf("CvfHeader.Bpb.HiddenSectors         = %08lx\n", CvfHeader.Bpb.HiddenSectors);
    printf("CvfHeader.Bpb.LargeSectors          = %08lx\n", CvfHeader.Bpb.LargeSectors);
    printf("\n");
    printf("CvfHeader.CvfRxExtensionsLbnMinus1 = %08lx\n", CvfHeader.CvfRxExtensionsLbnMinus1);
    printf("CvfHeader.LogOfBytesPerSector       = %08lx\n", CvfHeader.LogOfBytesPerSector);
    printf("CvfHeader.DosBootSectorLbn          = %08lx\n", CvfHeader.DosBootSectorLbn);
    printf("CvfHeader.DosRootDirectoryOffset    = %08lx\n", CvfHeader.DosRootDirectoryOffset);
    printf("CvfHeader.CvfHeapOffset             = %08lx\n", CvfHeader.CvfHeapOffset);
    printf("CvfHeader.CvfRxFirstDataEntry      = %08lx\n", CvfHeader.CvfRxFirstDataEntry);
    printf("CvfHeader.CvfBitmap2KSize           = %08lx\n", CvfHeader.CvfBitmap2KSize);
    printf("CvfHeader.LogOfSectorsPerCluster    = %08lx\n", CvfHeader.LogOfSectorsPerCluster);
    printf("CvfHeader.Is12BitRx                = %08lx\n", CvfHeader.Is12BitRx);
    printf("CvfHeader.CvfMaximumCapacity        = %08lx\n", CvfHeader.CvfMaximumCapacity);
    printf("\n");
    printf("                                Lbo    Allocation    Size\n");
    printf("CvfLayout.CvfHeader        = %08lx   %08lx   %08lx\n",CvfLayout.CvfHeader.Lbo, CvfLayout.CvfHeader.Allocation, CvfLayout.CvfHeader.Size );
    printf("CvfLayout.CvfBitmap        = %08lx   %08lx   %08lx\n",CvfLayout.CvfBitmap.Lbo, CvfLayout.CvfBitmap.Allocation, CvfLayout.CvfBitmap.Size );
    printf("CvfLayout.CvfReservedArea1 = %08lx   %08lx   %08lx\n",CvfLayout.CvfReservedArea1.Lbo, CvfLayout.CvfReservedArea1.Allocation, CvfLayout.CvfReservedArea1.Size );
    printf("CvfLayout.CvfRxExtensions = %08lx   %08lx   %08lx\n",CvfLayout.CvfRxExtensions.Lbo, CvfLayout.CvfRxExtensions.Allocation, CvfLayout.CvfRxExtensions.Size );
    printf("CvfLayout.CvfReservedArea2 = %08lx   %08lx   %08lx\n",CvfLayout.CvfReservedArea2.Lbo, CvfLayout.CvfReservedArea2.Allocation, CvfLayout.CvfReservedArea2.Size );
    printf("CvfLayout.DosBootSector    = %08lx   %08lx   %08lx\n",CvfLayout.DosBootSector.Lbo, CvfLayout.DosBootSector.Allocation, CvfLayout.DosBootSector.Size );
    printf("CvfLayout.CvfReservedArea3 = %08lx   %08lx   %08lx\n",CvfLayout.CvfReservedArea3.Lbo, CvfLayout.CvfReservedArea3.Allocation, CvfLayout.CvfReservedArea3.Size );
    printf("CvfLayout.DosRx           = %08lx   %08lx   %08lx\n",CvfLayout.DosRx.Lbo, CvfLayout.DosRx.Allocation, CvfLayout.DosRx.Size );
    printf("CvfLayout.DosRootDirectory = %08lx   %08lx   %08lx\n",CvfLayout.DosRootDirectory.Lbo, CvfLayout.DosRootDirectory.Allocation, CvfLayout.DosRootDirectory.Size );
    printf("CvfLayout.CvfReservedArea4 = %08lx   %08lx   %08lx\n",CvfLayout.CvfReservedArea4.Lbo, CvfLayout.CvfReservedArea4.Allocation, CvfLayout.CvfReservedArea4.Size );
    printf("CvfLayout.CvfHeap          = %08lx   %08lx   %08lx\n",CvfLayout.CvfHeap.Lbo, CvfLayout.CvfHeap.Allocation, CvfLayout.CvfHeap.Size );
    printf("CvfLayout.CvfReservedArea5 = %08lx   %08lx   %08lx\n",CvfLayout.CvfReservedArea5.Lbo, CvfLayout.CvfReservedArea5.Allocation, CvfLayout.CvfReservedArea5.Size );

    //
    //  Read in and print the Cvf Rx Extensions that are in use
    //

    {
        ULONG i;
        CVF_RDBSS_EXTENSIONS Entry;
        BOOLEAN FirstTime = TRUE;

        for (i = 0; i < CvfLayout.CvfRxExtensions.Size; i += sizeof(CVF_RDBSS_EXTENSIONS)) {

            (VOID)fseek( pf, CvfLayout.CvfRxExtensions.Lbo + i, SEEK_SET );
            (VOID)fread( &Entry, 1, sizeof(CVF_RDBSS_EXTENSIONS), pf );

            if (Entry.IsEntryInUse) {

                if (FirstTime) {

                    FirstTime = FALSE;
                    printf("\n");
                    printf("  Entry  CvfHeap Compressed Uncompressed IsData\n");
                    printf(" Offset    Lbo     Length     Length   Compressed\n");
                }

                printf("%08lx %08lx %8lx %8lx %8lx\n", i,
                                                       (Entry.CvfHeapLbnMinus1+1) * CvfHeader.Bpb.BytesPerSector,
                                                       (Entry.CompressedSectorLengthMinus1+1) * CvfHeader.Bpb.BytesPerSector,
                                                       (Entry.UncompressedSectorLengthMinus1+1) * CvfHeader.Bpb.BytesPerSector,
                                                       Entry.IsDataUncompressed );
            }
        }
    }
}

VOID
Decompress (
    ULONG argc,
    PCHAR argv[],
    FILE *pf
    )

{
    ULONG Offset;
    ULONG CompressedCount;
    ULONG UncompressedCount;

    if (argc < 6) {
        DsDumpSyntax(argv[0]);
        return;
    }

    sscanf( argv[3], strncmp( argv[3], "0x", 2 ) ? "%ld" : "%lx", &Offset );
    sscanf( argv[4], strncmp( argv[4], "0x", 2 ) ? "%ld" : "%lx", &CompressedCount );
    sscanf( argv[5], strncmp( argv[5], "0x", 2 ) ? "%ld" : "%lx", &UncompressedCount );

    if (argc == 7) { freopen( argv[6], "wb", stdout ); }

    //
    //  Print the file name
    //

    fprintf(stderr, "\n%s:\n", argv[2]);

    fseek( pf, Offset, SEEK_SET );
    (VOID)fread( CompressedBuffer, 1, CompressedCount, pf );

    {
        MRCF_DECOMPRESS WorkSpace;
        ULONG UncompressedLength;

        UncompressedLength = MrcfDecompress( UncompressedBuffer,
                                             UncompressedCount,
                                             CompressedBuffer,
                                             CompressedCount,
                                             &WorkSpace );

        fprintf(stderr, "UncompressedLength = %d\n", UncompressedLength);

        fwrite( UncompressedBuffer, 1, UncompressedLength, stdout );
    }
}

VOID
Compress (
    ULONG argc,
    PCHAR argv[],
    FILE *pf
    )

{
    ULONG Offset;
    ULONG CompressedCount;
    ULONG UncompressedCount;

    if (argc < 6) {
        DsDumpSyntax(argv[0]);
        return;
    }

    sscanf( argv[3], strncmp( argv[3], "0x", 2 ) ? "%ld" : "%lx", &Offset );
    sscanf( argv[4], strncmp( argv[4], "0x", 2 ) ? "%ld" : "%lx", &UncompressedCount );
    sscanf( argv[4], strncmp( argv[4], "0x", 2 ) ? "%ld" : "%lx", &CompressedCount );

    if (argc == 7) { freopen( argv[6], "wb", stdout ); }

    //
    //  Print the file name
    //

    fprintf(stderr, "\n%s:\n", argv[2]);

    fseek( pf, Offset, SEEK_SET );
    (VOID)fread( UncompressedBuffer, 1, UncompressedCount, pf );

    {
        MRCF_STANDARD_COMPRESS WorkSpace;
        ULONG CompressedLength;

        CompressedLength = MrcfStandardCompress( CompressedBuffer,
                                                 CompressedCount,
                                                 UncompressedBuffer,
                                                 UncompressedCount,
                                                 &WorkSpace );

        fprintf(stderr, "CompressedLength = %d\n", CompressedLength);

        fwrite( CompressedBuffer, 1, CompressedLength, stdout );
    }
}

VOID
cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    FILE *pf;

    if (argc < 3) {

        DsDumpSyntax(argv[0]);
        return;
    }

    if (!(pf = fopen(argv[2], "rb"))) {

        fprintf(stderr, "%s error: invalid file name '%s'\n", argv[0], argv[2]);
        return;
    }

    if (!strcmp(argv[1],"-h") || !strcmp(argv[1],"-H")) {

        DumpHeader(argc,argv,pf);

    } else if (!strcmp(argv[1],"-c") || !strcmp(argv[1],"-C")) {

        Compress(argc,argv,pf);

    } else if (!strcmp(argv[1],"-d") || !strcmp(argv[1],"-D")) {

        Decompress(argc,argv,pf);

    } else {

        DsDumpSyntax(argv[0]);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\deviosup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DevIoSup.c

Abstract:

    This module implements the low lever disk read/write support for Rx.

Author:

    Gary Kimura     [GaryKi]    22-Jan-1990

Revision History:

    David Goebel    [DavidGoe]  05-Oct-1990

        Major changes for the new RDBSS


    Tom Miller      [TomM]      22-Apr-1990

        Added User Buffer Locking and Mapping routines
        Modified behavior of async I/O routines to use completion routines

--*/

//    ----------------------joejoe-----------found-------------#include "RxProcs.h"
#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_DEVIOSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVIOSUP)

//
// Completion Routine declarations
//

RXSTATUS
RxMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

RXSTATUS
RxMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

RXSTATUS
RxSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

RXSTATUS
RxSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

RXSTATUS
RxPagingFileCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MasterIrp
    );

VOID
RxSingleNonAlignedSync (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PUCHAR Buffer,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    );

//
//  The following macro decides whether to send a request directly to
//  the device driver, or to the double space routines.  It was meant to
//  replace IoCallDriver as transparently as possible.  It must only be
//  called with a read or write Irp.
//
//  RXSTATUS
//  RxLowLevelReadWrite (
//      PRX_CONTEXT RxContext,
//      PDEVICE_OBJECT DeviceObject,
//      PIRP Irp,
//      PVCB Vcb
//      );
//

#ifdef WE_WON_ON_APPEAL
#define RxLowLevelReadWrite(RXCONTEXT,DO,IRP,VCB) (      \
    (VCB)->Dscb == NULL ?                                  \
    IoCallDriver((DO),(IRP)) :                             \
    RxLowLevelDblsReadWrite((RXCONTEXT),(IRP),(VCB))     \
)
#else
#define RxLowLevelReadWrite(RXCONTEXT,DO,IRP,VCB) ( \
    IoCallDriver((DO),(IRP))                          \
)
#endif // WE_WON_ON_APPEAL

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxMultipleAsync)
#pragma alloc_text(PAGE, RxSingleAsync)
#pragma alloc_text(PAGE, RxSingleNonAlignedSync)
#pragma alloc_text(PAGE, RxToggleMediaEjectDisable)
#pragma alloc_text(PAGE, RxNonCachedIo)
#pragma alloc_text(PAGE, RxSingleNonAlignedSync)
#pragma alloc_text(PAGE, RxNonCachedNonAlignedRead)
#endif


VOID
RxPagingFileIo (
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    This routine nevers blocks, and should only be used with the paging
    file since no completion processing is performed.

Arguments:

    Irp - Supplies the requesting Irp.

    Fcb - Supplies the file to act on.

Return Value:

    None.

--*/

{
    //
    // Declare some local variables for enumeration through the
    // runs of the file.
    //

    VBO Vbo;
    ULONG ByteCount;

    PMDL Mdl;
    LBO NextLbo;
    VBO NextVbo;
    ULONG NextByteCount;
    BOOLEAN MustSucceed;

    ULONG FirstIndex;
    ULONG CurrentIndex;
    ULONG LastIndex;

    LBO LastLbo;
    ULONG LastByteCount;

    PIRP AssocIrp;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    ULONG BufferOffset;
    PDEVICE_OBJECT DeviceObject;

    DebugTrace(+1, Dbg, "RxPagingFileIo\n", 0);
    DebugTrace( 0, Dbg, "Irp = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "Fcb = %08lx\n", Fcb );

    //
    //  Initialize some locals.
    //

    BufferOffset = 0;
    DeviceObject = Fcb->Vcb->TargetDeviceObject;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    Vbo = IrpSp->Parameters.Read.ByteOffset.LowPart;
    ByteCount = IrpSp->Parameters.Read.Length;

    MustSucceed = FsRtlLookupMcbEntry( &Fcb->Mcb,
                                       Vbo,
                                       &NextLbo,
                                       &NextByteCount,
                                       &FirstIndex);

    //
    //  If this run isn't present, something is very wrong.
    //

    if (!MustSucceed) {

        RxBugCheck( Vbo, ByteCount, 0 );
    }

    //
    // See if the write covers a single valid run, and if so pass
    // it on.
    //

    if ( NextByteCount >= ByteCount ) {

        DebugTrace( 0, Dbg, "Passing Irp on to Disk Driver\n", 0 );

        //
        //  Setup the next IRP stack location for the disk driver beneath us.
        //

        NextIrpSp = IoGetNextIrpStackLocation( Irp );

        NextIrpSp->MajorFunction = IrpSp->MajorFunction;
        NextIrpSp->Parameters.Read.Length = ByteCount;
        NextIrpSp->Parameters.Read.ByteOffset.QuadPart = NextLbo;

        //
        //  Since this is Paging file IO, we'll just ignore the verify bit.
        //

        if (FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE) ||
            (Fcb->Vcb->VerifyThread == KeGetCurrentThread())) {

            SetFlag( IrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );
        }

        //
        //  Set up the completion routine address in our stack frame.
        //  This is only invoked on error or cancel, and just copies
        //  the error Status into master irp's iosb.
        //
        //  If the error implies a media problem, it also enqueues a
        //  worker item to write out the dirty bit so that the next
        //  time we run we will do a autochk /r
        //

        IoSetCompletionRoutine( Irp,
                                &RxPagingFileCompletionRoutine,
                                Irp,
                                FALSE,
                                TRUE,
                                TRUE );

        //
        //  Issue the read/write request
        //
        //  If IoCallDriver returns an error, it has completed the Irp
        //  and the error will be dealt with as a normal IO error.
        //

        (VOID)IoCallDriver( DeviceObject, Irp );

        DebugTrace(-1, Dbg, "RxPagingFileIo -> VOID\n", 0);
        return;
    }

    //
    //  Find out how may runs there are.
    //

    MustSucceed = FsRtlLookupMcbEntry( &Fcb->Mcb,
                                       Vbo + ByteCount - 1,
                                       &LastLbo,
                                       &LastByteCount,
                                       &LastIndex);

    //
    //  If this run isn't present, something is very wrong.
    //

    if (!MustSucceed) {

        RxBugCheck( Vbo + ByteCount - 1, 1, 0 );
    }

    CurrentIndex = FirstIndex;

    //
    //  Now set up the Irp->IoStatus.  It will be modified by the
    //  multi-completion routine in case of error or verify required.
    //

    Irp->IoStatus.Status = RxStatus(SUCCESS);
    Irp->IoStatus.Information = ByteCount;

    //
    //  Loop while there are still byte writes to satisfy.  If we fail to
    //  allocate resources the AssociatedIrp.IrpCount will be high enough
    //  that we can safely complete the Master Irp.
    //

    Irp->AssociatedIrp.IrpCount = LastIndex - FirstIndex + 1;

    while (CurrentIndex <= LastIndex) {

        //
        //  Reset this for unwinding purposes
        //

        AssocIrp = NULL;

        //
        // If next run is larger than we need, "ya get what you need".
        //

        if (NextByteCount > ByteCount) {
            NextByteCount = ByteCount;
        }

        //
        // Now that we have properly bounded this piece of the
        // transfer, it is time to read/write it.
        //

        AssocIrp = IoMakeAssociatedIrp( Irp, (CCHAR)(DeviceObject->StackSize + 1) );

        if (AssocIrp == NULL) {

            //
            //  This is a rare case, so just spin until all pending Associated
            //  Irps complete.
            //

            while (Irp->AssociatedIrp.IrpCount !=
                   (LONG)(LastIndex - CurrentIndex + 1)) {

                //
                // Wait for a short time so other processing can continue.
                //

                KeDelayExecutionThread (KernelMode, FALSE, &Rx30Milliseconds);
            }

            Irp->IoStatus.Status = RxStatus(INSUFFICIENT_RESOURCES);
            Irp->IoStatus.Information = 0;
            IoCompleteRequest( Irp, IO_DISK_INCREMENT );

            return;
        }

        //
        // Allocate and build a partial Mdl for the request.
        //

        Mdl = IoAllocateMdl( (PCHAR)Irp->UserBuffer + BufferOffset,
                             NextByteCount,
                             FALSE,
                             FALSE,
                             AssocIrp );

        if (Mdl == NULL) {

            IoFreeIrp( AssocIrp );

            //
            //  This is a rare case, so just spin until all pending Associated
            //  Irps complete.
            //

            while (Irp->AssociatedIrp.IrpCount !=
                   (LONG)(LastIndex - CurrentIndex + 1)) {

                //
                // Wait for a short time so other processing can continue.
                //

                KeDelayExecutionThread (KernelMode, FALSE, &Rx30Milliseconds);
            }

            Irp->IoStatus.Status = RxStatus(INSUFFICIENT_RESOURCES);
            Irp->IoStatus.Information = 0;
            IoCompleteRequest( Irp, IO_DISK_INCREMENT );

            return;
        }

        IoBuildPartialMdl( Irp->MdlAddress,
                           Mdl,
                           (PCHAR)Irp->UserBuffer + BufferOffset,
                           NextByteCount );

        //
        //  Get the first IRP stack location in the associated Irp
        //

        IoSetNextIrpStackLocation( AssocIrp );
        NextIrpSp = IoGetCurrentIrpStackLocation( AssocIrp );

        //
        //  Setup the Stack location to describe our read.
        //

        NextIrpSp->MajorFunction = IrpSp->MajorFunction;
        NextIrpSp->Parameters.Read.Length = NextByteCount;
        NextIrpSp->Parameters.Read.ByteOffset.QuadPart = Vbo;

        //
        //  We also need the RxDeviceObject in the Irp stack in case
        //  we take the failure path.
        //

        NextIrpSp->DeviceObject = IrpSp->DeviceObject;

        //
        //  Since this is Paging file IO, we'll just ignore the verify bit.
        //

        if (FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE) ||
            (Fcb->Vcb->VerifyThread == KeGetCurrentThread())) {

            SetFlag( IrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );
        }

        //
        //  Set up the completion routine address in our stack frame.
        //  This is only invoked on error or cancel, and just copies
        //  the error Status into master irp's iosb.
        //
        //  If the error implies a media problem, it also enqueues a
        //  worker item to write out the dirty bit so that the next
        //  time we run we will do a autochk /r
        //

        IoSetCompletionRoutine( AssocIrp,
                                &RxPagingFileCompletionRoutine,
                                Irp,
                                FALSE,
                                TRUE,
                                TRUE );

        //
        //  Setup the next IRP stack location in the associated Irp for the disk
        //  driver beneath us.
        //

        NextIrpSp = IoGetNextIrpStackLocation( AssocIrp );

        //
        //  Setup the Stack location to do a read from the disk driver.
        //

        NextIrpSp->MajorFunction = IrpSp->MajorFunction;
        NextIrpSp->Parameters.Read.Length = NextByteCount;
        NextIrpSp->Parameters.Read.ByteOffset.QuadPart = NextLbo;

        (VOID)IoCallDriver( DeviceObject, AssocIrp );

        //
        // Now adjust everything for the next pass through the loop.
        //

        Vbo += NextByteCount;
        BufferOffset += NextByteCount;
        ByteCount -= NextByteCount;

        //
        // Try to lookup the next run (if we are not done).
        //

        CurrentIndex += 1;

        if ( CurrentIndex <= LastIndex ) {

            ASSERT( ByteCount != 0 );

            FsRtlGetNextMcbEntry( &Fcb->Mcb,
                                  CurrentIndex,
                                  &NextVbo,
                                  &NextLbo,
                                  &NextByteCount );

            ASSERT( NextVbo == Vbo );
        }
    } // while ( CurrentIndex <= LastIndex )

    DebugTrace(-1, Dbg, "RxPagingFileIo -> VOID\n", 0);
    return;
}

RXSTATUS
RxNonCachedIo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB FcbOrDcb,
    IN ULONG StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    The choice of a single run is made if possible, otherwise multiple runs
    are executed.

Arguments:

    RxContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    FcbOrDcb - Supplies the file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    None.

--*/

{
    //
    // Declare some local variables for enumeration through the
    // runs of the file, and an array to store parameters for
    // parallel I/Os
    //

    BOOLEAN Wait;

    LBO NextLbo;
    VBO NextVbo;
    ULONG NextByteCount;
    BOOLEAN NextIsAllocated;

    LBO LastLbo;
    ULONG LastByteCount;
    BOOLEAN LastIsAllocated;

    ULONG FirstIndex;
    ULONG CurrentIndex;
    ULONG LastIndex;

    ULONG NextRun;
    ULONG BufferOffset;
    ULONG OriginalByteCount;

    IO_RUN StackIoRuns[RDBSS_MAX_IO_RUNS_ON_STACK];
    PIO_RUN IoRuns;

    DebugTrace(+1, Dbg, "RxNonCachedIo\n", 0);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "MajorFunction = %08lx\n", RxContext->MajorFunction );
    DebugTrace( 0, Dbg, "FcbOrDcb      = %08lx\n", FcbOrDcb );
    DebugTrace( 0, Dbg, "StartingVbo   = %08lx\n", StartingVbo );
    DebugTrace( 0, Dbg, "ByteCount     = %08lx\n", ByteCount );
//no longer used    DebugTrace( 0, Dbg, "Context       = %08lx\n", Context );

    //
    //  Initialize some locals.
    //

    NextRun = 0;
    BufferOffset = 0;
    OriginalByteCount = ByteCount;

    Wait = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);

    //
    // For nonbuffered I/O, we need the buffer locked in all
    // cases.
    //
    // This call may raise.  If this call succeeds and a subsequent
    // condition is raised, the buffers are unlocked automatically
    // by the I/O system when the request is completed, via the
    // Irp->MdlAddress field.
    //

    RxLockUserBuffer( RxContext,
                       (RxContext->MajorFunction == IRP_MJ_READ) ?
                       IoWriteAccess : IoReadAccess,
                       ByteCount );

#if 0 // The corruption was happening on the SCSI bus. (DavidGoe 1/11/93)

    //
    //  If we are writing a directory, add a spot check here that
    //  what we are writing is really a directory.
    //

    if ( !FlagOn(FcbOrDcb->Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) &&
         (NodeType(FcbOrDcb) != RDBSS_NTC_FCB) &&
         (RxContext->MajorFunction == IRP_MJ_WRITE) ) {

        PDIRENT Dirent;

        Dirent = RxMapUserBuffer( RxContext, Irp );

        //
        //  For the first page of a non-root directory, make sure that
        //  . and .. are present.
        //

        if ( (StartingVbo == 0) &&
             (NodeType(FcbOrDcb) != RDBSS_NTC_ROOT_DCB) ) {

            if ( (RtlCompareMemory( (PUCHAR)Dirent++,
                                   ".          ",
                                   11 ) != 11) ||
                 (RtlCompareMemory( (PUCHAR)Dirent,
                                   "..         ",
                                   11 ) != 11) ) {

                RxBugCheck( 0, 0, 0 );
            }

        } else {

            //
            //  Check that all the reserved bit in the second dirent are
            //  zero.  (The first one contains our dirty bit in the root dir)
            //

            PULONG Zeros;

            Dirent++;

            Zeros = (PULONG)&Dirent->Reserved[0];

            if ( (Dirent->FileName[0] != 0xE5) &&
                 ((*Zeros != 0) || (*(Zeros+1) != 0)) ) {

                RxBugCheck( 0, 0, 0 );
            }
        }
    }
#endif //0

    //
    // Try to lookup the first run.  If there is just a single run,
    // we may just be able to pass it on.
    //

    RxLookupFileAllocation( RxContext,
                             FcbOrDcb,
                             StartingVbo,
                             &NextLbo,
                             &NextByteCount,
                             &NextIsAllocated,
                             &FirstIndex );

    //
    // We just added the allocation, thus there must be at least
    // one entry in the mcb corresponding to our write, ie.
    // NextIsAllocated must be true.  If not, the pre-existing file
    // must have an allocation error.
    //

    if ( !NextIsAllocated ) {

        RxPopUpFileCorrupt( RxContext, FcbOrDcb );

        RxRaiseStatus( RxContext, RxStatus(FILE_CORRUPT_ERROR) );
    }

    //
    //  If the request was not aligned correctly, read in the first
    //  part first.
    //


    //
    // See if the write covers a single valid run, and if so pass
    // it on.
    //

    if ( NextByteCount >= ByteCount ) {

        DebugTrace( 0, Dbg, "Passing Irp on to Disk Driver\n", 0 );

        RxSingleAsync( RxContext,
                        FcbOrDcb->Vcb,
                        NextLbo,
                        ByteCount,
                        Irp );

        if (!Wait) {

            DebugTrace(-1, Dbg, "RxNonCachedIo -> RxStatus(PENDING\n)", 0);
            return RxStatus(PENDING);

        } else {

            RxWaitSync( RxContext );

            DebugTrace(-1, Dbg, "RxNonCachedIo -> 0x%08lx\n", Irp->IoStatus.Status);
            return Irp->IoStatus.Status;
        }
    }

    //
    //  If there we can't wait, and there are more runs than we can handle,
    //  we will have to post this request.
    //

    RxLookupFileAllocation( RxContext,
                             FcbOrDcb,
                             StartingVbo + ByteCount - 1,
                             &LastLbo,
                             &LastByteCount,
                             &LastIsAllocated,
                             &LastIndex );

    //
    // Since we already added the allocation for the whole
    // write, assert that we find runs until ByteCount == 0
    // Otherwise this file is corrupt.
    //

    if ( !LastIsAllocated ) {

        RxPopUpFileCorrupt( RxContext, FcbOrDcb );

        RxRaiseStatus( RxContext, RxStatus(FILE_CORRUPT_ERROR) );
    }

    if (LastIndex - FirstIndex + 1 > RDBSS_MAX_IO_RUNS_ON_STACK) {

        IoRuns = FsRtlAllocatePool(PagedPool,
                                   (LastIndex - FirstIndex + 1) * sizeof(IO_RUN));

    } else {

        IoRuns = StackIoRuns;
    }

    CurrentIndex = FirstIndex;

    //
    // Loop while there are still byte writes to satisfy.
    //

    while (CurrentIndex <= LastIndex) {

        //
        // If next run is larger than we need, "ya get what you need".
        //

        if (NextByteCount > ByteCount) {
            NextByteCount = ByteCount;
        }

        //
        // Now that we have properly bounded this piece of the
        // transfer, it is time to write it.
        //
        // We remember each piece of a parallel run by saving the
        // essential information in the IoRuns array.  The tranfers
        // are started up in parallel below.
        //

        IoRuns[NextRun].Vbo = StartingVbo;
        IoRuns[NextRun].Lbo = NextLbo;
        IoRuns[NextRun].Offset = BufferOffset;
        IoRuns[NextRun].ByteCount = NextByteCount;
        NextRun += 1;

        //
        // Now adjust everything for the next pass through the loop.
        //

        StartingVbo += NextByteCount;
        BufferOffset += NextByteCount;
        ByteCount -= NextByteCount;

        //
        // Try to lookup the next run (if we are not done).
        //

        CurrentIndex += 1;

        if ( CurrentIndex <= LastIndex ) {

            ASSERT( ByteCount != 0 );

            FsRtlGetNextMcbEntry( &FcbOrDcb->Mcb,
                                  CurrentIndex,
                                  &NextVbo,
                                  &NextLbo,
                                  &NextByteCount );

            ASSERT( NextVbo == StartingVbo );
        }

    } // while ( CurrentIndex <= LastIndex )

    //
    //  Now set up the Irp->IoStatus.  It will be modified by the
    //  multi-completion routine in case of error or verify required.
    //

    Irp->IoStatus.Status = RxStatus(SUCCESS);
    Irp->IoStatus.Information = OriginalByteCount;

    //
    //  OK, now do the I/O.
    //

    try {

        RxMultipleAsync( RxContext,
                          FcbOrDcb->Vcb,
                          Irp,
                          NextRun,
                          IoRuns );

    } finally {

        if (IoRuns != StackIoRuns) {

            ExFreePool( IoRuns );
        }
    }

    if (!Wait) {

        DebugTrace(-1, Dbg, "RxNonCachedIo -> RxStatus(PENDING\n)", 0);
        return RxStatus(PENDING);
    }

    RxWaitSync( RxContext );

    DebugTrace(-1, Dbg, "RxNonCachedIo -> 0x%08lx\n", Irp->IoStatus.Status);
    return Irp->IoStatus.Status;
}


VOID
RxNonCachedNonAlignedRead (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB FcbOrDcb,
    IN ULONG StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    This routine differs from the above in that the range does not have to be
    sector aligned.  This accomplished with the use of intermediate buffers.

Arguments:

    RxContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    FcbOrDcb - Supplies the file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    None.

--*/

{
    //
    // Declare some local variables for enumeration through the
    // runs of the file, and an array to store parameters for
    // parallel I/Os
    //

    LBO NextLbo;
    ULONG NextByteCount;
    BOOLEAN NextIsAllocated;

    ULONG SectorSize;
    ULONG BytesToCopy;
    ULONG OriginalByteCount;
    ULONG OriginalStartingVbo;

    PUCHAR UserBuffer;
    PUCHAR DiskBuffer = NULL;

    PMDL Mdl;
    PMDL SavedMdl;

    DebugTrace(+1, Dbg, "RxNonCachedNonAlignedRead\n", 0);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "MajorFunction = %08lx\n", RxContext->MajorFunction );
    DebugTrace( 0, Dbg, "FcbOrDcb      = %08lx\n", FcbOrDcb );
    DebugTrace( 0, Dbg, "StartingVbo   = %08lx\n", StartingVbo );
    DebugTrace( 0, Dbg, "ByteCount     = %08lx\n", ByteCount );

    //
    //  Initialize some locals.
    //

    OriginalByteCount = ByteCount;
    OriginalStartingVbo = StartingVbo;
    SectorSize = FcbOrDcb->Vcb->Bpb.BytesPerSector;

    ASSERT( FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT) );

    //
    // For nonbuffered I/O, we need the buffer locked in all
    // cases.
    //
    // This call may raise.  If this call succeeds and a subsequent
    // condition is raised, the buffers are unlocked automatically
    // by the I/O system when the request is completed, via the
    // Irp->MdlAddress field.
    //

    RxLockUserBuffer( RxContext,
                       IoWriteAccess,
                       ByteCount );

    UserBuffer = RxMapUserBuffer( RxContext );

    //
    //  Allocate the local buffer
    //

    DiskBuffer = FsRtlAllocatePool( NonPagedPoolCacheAligned,
                                    ROUND_TO_PAGES( SectorSize ));

    //
    //  We use a try block here to ensure the buffer is freed, and to
    //  fill in the correct byte count in the Iosb.Information field.
    //

    try {

        //
        //  If the beginning of the request was not aligned correctly, read in
        //  the first part first.
        //

        if ( StartingVbo & (SectorSize - 1) ) {

            VBO Hole;

            //
            // Try to lookup the first run.
            //

            RxLookupFileAllocation( RxContext,
                                     FcbOrDcb,
                                     StartingVbo,
                                     &NextLbo,
                                     &NextByteCount,
                                     &NextIsAllocated,
                                     NULL );

            //
            // We just added the allocation, thus there must be at least
            // one entry in the mcb corresponding to our write, ie.
            // NextIsAllocated must be true.  If not, the pre-existing file
            // must have an allocation error.
            //

            if ( !NextIsAllocated ) {

                RxPopUpFileCorrupt( RxContext, FcbOrDcb );

                RxRaiseStatus( RxContext, RxStatus(FILE_CORRUPT_ERROR) );
            }

            RxSingleNonAlignedSync( RxContext,
                                     FcbOrDcb->Vcb,
                                     DiskBuffer,
                                     NextLbo & ~(SectorSize - 1),
                                     SectorSize,
                                     Irp );

            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                try_return( NOTHING );
            }

            //
            //  Now copy the part of the first sector that we want to the user
            //  buffer.
            //

            Hole = StartingVbo & (SectorSize - 1);

            BytesToCopy = ByteCount >= SectorSize - Hole ?
                                       SectorSize - Hole : ByteCount;

            RtlCopyMemory( UserBuffer, DiskBuffer + Hole, BytesToCopy );

            StartingVbo += BytesToCopy;
            ByteCount -= BytesToCopy;

            if ( ByteCount == 0 ) {

                try_return( NOTHING );
            }
        }

        ASSERT( (StartingVbo & (SectorSize - 1)) == 0 );

        //
        //  If there is a tail part that is not sector aligned, read it.
        //

        if ( ByteCount & (SectorSize - 1) ) {

            VBO LastSectorVbo;

            LastSectorVbo = StartingVbo + (ByteCount & ~(SectorSize - 1));

            //
            // Try to lookup the last part of the requested range.
            //

            RxLookupFileAllocation( RxContext,
                                     FcbOrDcb,
                                     LastSectorVbo,
                                     &NextLbo,
                                     &NextByteCount,
                                     &NextIsAllocated,
                                     NULL );

            //
            // We just added the allocation, thus there must be at least
            // one entry in the mcb corresponding to our write, ie.
            // NextIsAllocated must be true.  If not, the pre-existing file
            // must have an allocation error.
            //

            if ( !NextIsAllocated ) {

                RxPopUpFileCorrupt( RxContext, FcbOrDcb );

                RxRaiseStatus( RxContext, RxStatus(FILE_CORRUPT_ERROR) );
            }

            RxSingleNonAlignedSync( RxContext,
                                     FcbOrDcb->Vcb,
                                     DiskBuffer,
                                     NextLbo,
                                     SectorSize,
                                     Irp );

            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                try_return( NOTHING );
            }

            //
            //  Now copy over the part of this last sector that we need.
            //

            BytesToCopy = ByteCount & (SectorSize - 1);

            UserBuffer += LastSectorVbo - OriginalStartingVbo;

            RtlCopyMemory( UserBuffer, DiskBuffer, BytesToCopy );

            ByteCount -= BytesToCopy;

            if ( ByteCount == 0 ) {

                try_return( NOTHING );
            }
        }

        ASSERT( ((StartingVbo | ByteCount) & (SectorSize - 1)) == 0 );

        //
        //  Now build a Mdl describing the sector aligned balance of the transfer,
        //  and put it in the Irp, and read that part.
        //

        SavedMdl = Irp->MdlAddress;
        Irp->MdlAddress = NULL;

        UserBuffer = MmGetMdlVirtualAddress( SavedMdl );

        Mdl = IoAllocateMdl( UserBuffer + (StartingVbo - OriginalStartingVbo),
                             ByteCount,
                             FALSE,
                             FALSE,
                             Irp );

        if (Mdl == NULL) {

            Irp->MdlAddress = SavedMdl;
            RxRaiseStatus( RxContext, RxStatus(INSUFFICIENT_RESOURCES) );
        }

        IoBuildPartialMdl( SavedMdl,
                           Mdl,
                           UserBuffer + (StartingVbo - OriginalStartingVbo),
                           ByteCount );

        //
        //  Try to read in the pages.
        //

        try {

            RxNonCachedIo( RxContext,
                            Irp,
                            FcbOrDcb,
                            StartingVbo,
                            ByteCount );

        } finally {

            IoFreeMdl( Irp->MdlAddress );

            Irp->MdlAddress = SavedMdl;
        }

    try_exit: NOTHING;

    } finally {

        ExFreePool( DiskBuffer );

        if ( !AbnormalTermination() && NT_SUCCESS(Irp->IoStatus.Status) ) {

            Irp->IoStatus.Information = OriginalByteCount;

            //
            //  We now flush the user's buffer to memory.
            //

            KeFlushIoBuffers( Irp->MdlAddress, TRUE, FALSE );
        }
    }

    DebugTrace(-1, Dbg, "RxNonCachedNonAlignedRead -> VOID\n", 0);
    return;
}


VOID
RxMultipleAsync (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PIRP MasterIrp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns
    )

/*++

Routine Description:

    This routine first does the initial setup required of a Master IRP that is
    going to be completed using associated IRPs.  This routine should not
    be used if only one async request is needed, instead the single read/write
    async routines should be called.

    A context parameter is initialized, to serve as a communications area
    between here and the common completion routine.  This initialization
    includes allocation of a spinlock.  The spinlock is deallocated in the
    RxWaitSync routine, so it is essential that the caller insure that
    this routine is always called under all circumstances following a call
    to this routine.

    Next this routine reads or writes one or more contiguous sectors from
    a device asynchronously, and is used if there are multiple reads for a
    master IRP.  A completion routine is used to synchronize with the
    completion of all of the I/O requests started by calls to this routine.

    Also, prior to calling this routine the caller must initialize the
    IoStatus field in the Context, with the correct success status and byte
    count which are expected if all of the parallel transfers complete
    successfully.  After return this status will be unchanged if all requests
    were, in fact, successful.  However, if one or more errors occur, the
    IoStatus will be modified to reflect the error status and byte count
    from the first run (by Vbo) which encountered an error.  I/O status
    from all subsequent runs will not be indicated.

Arguments:

    RxContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Vcb - Supplies the device to be read

    MasterIrp - Supplies the master Irp.

    MulitpleIrpCount - Supplies the number of multiple async requests
        that will be issued against the master irp.

    IoRuns - Supplies an array containing the Vbo, Lbo, BufferOffset, and
        ByteCount for all the runs to executed in parallel.

Return Value:

    None.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PMDL Mdl;
    BOOLEAN Wait;
    PRDBSS_IO_CONTEXT Context;

    ULONG UnwindRunCount = 0;

    BOOLEAN ExceptionExpected = TRUE;

    BOOLEAN CalledByRxVerifyVolume = FALSE;

    DebugTrace(+1, Dbg, "RxMultipleAsync\n", 0);
    DebugTrace( 0, Dbg, "MajorFunction    = %08lx\n", RxContext->MajorFunction );
    DebugTrace( 0, Dbg, "Vcb              = %08lx\n", Vcb );
    DebugTrace( 0, Dbg, "MasterIrp        = %08lx\n", MasterIrp );
    DebugTrace( 0, Dbg, "MultipleIrpCount = %08lx\n", MultipleIrpCount );
    DebugTrace( 0, Dbg, "IoRuns           = %08lx\n", IoRuns );

    //
    //  If this I/O originating during RxVerifyVolume, bypass the
    //  verify logic.
    //

    if ( Vcb->VerifyThread == KeGetCurrentThread() ) {

        CalledByRxVerifyVolume = TRUE;
    }

    //
    //  Set up things according to whether this is truely async.
    //

    Wait = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );

    Context = RxContext->RxIoContext;

    //
    //  Finish initializing Context, for use in Read/Write Multiple Asynch.
    //

    Context->MasterIrp = MasterIrp;

    try {

        //
        //  Itterate through the runs, doing everything that can fail
        //

        for ( UnwindRunCount = 0;
              UnwindRunCount < MultipleIrpCount;
              UnwindRunCount++ ) {

            //
            //  Create an associated IRP, making sure there is one stack entry for
            //  us, as well.
            //

            IoRuns[UnwindRunCount].SavedIrp = 0;

            Irp = IoMakeAssociatedIrp( MasterIrp,
                                       (CCHAR)(Vcb->TargetDeviceObject->StackSize + 1) );

            if (Irp == NULL) {

                RxRaiseStatus( RxContext, RxStatus(INSUFFICIENT_RESOURCES) );
            }

            IoRuns[UnwindRunCount].SavedIrp = Irp;

            //
            // Allocate and build a partial Mdl for the request.
            //

            Mdl = IoAllocateMdl( (PCHAR)MasterIrp->UserBuffer +
                                 IoRuns[UnwindRunCount].Offset,
                                 IoRuns[UnwindRunCount].ByteCount,
                                 FALSE,
                                 FALSE,
                                 Irp );

            if (Mdl == NULL) {

                RxRaiseStatus( RxContext, RxStatus(INSUFFICIENT_RESOURCES) );
            }

            //
            //  Sanity Check
            //

            ASSERT( Mdl == Irp->MdlAddress );

            IoBuildPartialMdl( MasterIrp->MdlAddress,
                               Mdl,
                               (PCHAR)MasterIrp->UserBuffer +
                               IoRuns[UnwindRunCount].Offset,
                               IoRuns[UnwindRunCount].ByteCount );

            //
            //  Get the first IRP stack location in the associated Irp
            //

            IoSetNextIrpStackLocation( Irp );
            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Setup the Stack location to describe our read.
            //

            IrpSp->MajorFunction = RxContext->MajorFunction;
            IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].ByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].Vbo;

            //
            // Set up the completion routine address in our stack frame.
            //

            IoSetCompletionRoutine( Irp,
                                    Wait ?
                                    &RxMultiSyncCompletionRoutine :
                                    &RxMultiAsyncCompletionRoutine,
                                    Context,
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Setup the next IRP stack location in the associated Irp for the disk
            //  driver beneath us.
            //

            IrpSp = IoGetNextIrpStackLocation( Irp );

            //
            //  Setup the Stack location to do a read from the disk driver.
            //

            IrpSp->MajorFunction = RxContext->MajorFunction;
            IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].ByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].Lbo;

            //
            //  If this Irp is the result of a WriteThough operation,
            //  tell the device to write it through.
            //

            if (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WRITE_THROUGH)) {

                SetFlag( IrpSp->Flags, SL_WRITE_THROUGH );
            }

            //
            //  If this I/O originating during RxVerifyVolume, bypass the
            //  verify logic.
            //

            if ( CalledByRxVerifyVolume ) {

                SetFlag( IrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );
            }
        }

        //
        //  Now we no longer expect an exception.  If the driver raises, we
        //  must bugcheck, because we do not know how to recover from that
        //  case.
        //

        ExceptionExpected = FALSE;

        //
        //  We only need to set the associated IRP count in the master irp to
        //  make it a master IRP.  But we set the count to one more than our
        //  caller requested, because we do not want the I/O system to complete
        //  the I/O.  We also set our own count.
        //

        Context->IrpCount = MultipleIrpCount;
        MasterIrp->AssociatedIrp.IrpCount = MultipleIrpCount;

        if (Wait) {

            MasterIrp->AssociatedIrp.IrpCount += 1;
        }

        //
        //  Now that all the dangerous work is done, issue the read requests
        //

        for (UnwindRunCount = 0;
             UnwindRunCount < MultipleIrpCount;
             UnwindRunCount++) {

            Irp = IoRuns[UnwindRunCount].SavedIrp;

            DebugDoit( RxIoCallDriverCount += 1);

            //
            //  If IoCallDriver returns an error, it has completed the Irp
            //  and the error will be caught by our completion routines
            //  and dealt with as a normal IO error.
            //

            (VOID)RxLowLevelReadWrite( RxContext,
                                        Vcb->TargetDeviceObject,
                                        Irp,
                                        Vcb );
        }

    } finally {

        ULONG i;

        DebugUnwind( RxMultipleAsync );

        //
        //  Only allocating the spinlock, making the associated Irps
        //  and allocating the Mdls can fail.
        //

        if ( AbnormalTermination() ) {

            //
            //  If the driver raised, we are hosed.  He is not supposed to raise,
            //  and it is impossible for us to figure out how to clean up.
            //

            if (!ExceptionExpected) {
                ASSERT( ExceptionExpected );
                RxBugCheck( 0, 0, 0 );
            }

            //
            //  Unwind
            //

            for (i = 0; i <= UnwindRunCount; i++) {

                if ( (Irp = IoRuns[i].SavedIrp) != NULL ) {

                    if ( Irp->MdlAddress != NULL ) {

                        IoFreeMdl( Irp->MdlAddress );
                    }

                    IoFreeIrp( Irp );
                }
            }
        }

        //
        //  And return to our caller
        //

        DebugTrace(-1, Dbg, "RxMultipleAsync -> VOID\n", 0);
    }

    return;
}


VOID
RxSingleAsync (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine reads or writes one or more contiguous sectors from a device
    asynchronously, and is used if there is only one read necessary to
    complete the IRP.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

Arguments:

    RxContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Vcb - Supplies the device to read

    Lbo - Supplies the starting Logical Byte Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

    Irp - Supplies the master Irp to associated with the async
          request.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    DebugTrace(+1, Dbg, "RxSingleAsync\n", 0);
    DebugTrace( 0, Dbg, "MajorFunction = %08lx\n", RxContext->MajorFunction );
    DebugTrace( 0, Dbg, "Vcb           = %08lx\n", Vcb );
    DebugTrace( 0, Dbg, "Lbo           = %08lx\n", Lbo);
    DebugTrace( 0, Dbg, "ByteCount     = %08lx\n", ByteCount);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp );

    //
    // Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( Irp,
                            FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT) ?
                            &RxSingleSyncCompletionRoutine :
                            &RxSingleAsyncCompletionRoutine,
                            RxContext->RxIoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = RxContext->MajorFunction;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = Lbo;

    //
    //  If this Irp is the result of a WriteThough operation,
    //  tell the device to write it through.
    //

    if (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WRITE_THROUGH)) {

        SetFlag( IrpSp->Flags, SL_WRITE_THROUGH );
    }

    //
    //  If this I/O originating during RxVerifyVolume, bypass the
    //  verify logic.
    //

    if ( Vcb->VerifyThread == KeGetCurrentThread() ) {

        SetFlag( IrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    }

    //
    //  Issue the read request
    //

    DebugDoit( RxIoCallDriverCount += 1);

    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    (VOID)RxLowLevelReadWrite( RxContext,
                                Vcb->TargetDeviceObject,
                                Irp,
                                Vcb );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "RxSingleAsync -> VOID\n", 0);

    return;
}


VOID
RxSingleNonAlignedSync (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PUCHAR Buffer,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine reads or writes one or more contiguous sectors from a device
    Synchronously, and does so to a buffer that must come from non paged
    pool.  It saves a pointer to the Irp's original Mdl, and creates a new
    one describing the given buffer.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

Arguments:

    RxContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Vcb - Supplies the device to read

    Buffer - Supplies a buffer from non-paged pool.

    Lbo - Supplies the starting Logical Byte Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

    Irp - Supplies the master Irp to associated with the async
          request.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PMDL Mdl;
    PMDL SavedMdl;

    DebugTrace(+1, Dbg, "RxSingleNonAlignedAsync\n", 0);
    DebugTrace( 0, Dbg, "MajorFunction = %08lx\n", RxContext->MajorFunction );
    DebugTrace( 0, Dbg, "Vcb           = %08lx\n", Vcb );
    DebugTrace( 0, Dbg, "Buffer        = %08lx\n", Buffer );
    DebugTrace( 0, Dbg, "Lbo           = %08lx\n", Lbo);
    DebugTrace( 0, Dbg, "ByteCount     = %08lx\n", ByteCount);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp );

    //
    //  Create a new Mdl describing the buffer, saving the current one in the
    //  Irp
    //

    SavedMdl = Irp->MdlAddress;

    Irp->MdlAddress = 0;

    Mdl = IoAllocateMdl( Buffer,
                         ByteCount,
                         FALSE,
                         FALSE,
                         Irp );

    if (Mdl == NULL) {

        Irp->MdlAddress = SavedMdl;

        RxRaiseStatus( RxContext, RxStatus(INSUFFICIENT_RESOURCES) );
    }

    //
    //  Lock the new Mdl in memory.
    //

    try {

        MmProbeAndLockPages( Mdl, KernelMode, IoWriteAccess );

    } finally {

        if ( AbnormalTermination() ) {

            IoFreeMdl( Mdl );
        }
    }

    //
    // Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( Irp,
                            &RxSingleSyncCompletionRoutine,
                            RxContext->RxIoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = RxContext->MajorFunction;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = Lbo;

    //
    //  If this I/O originating during RxVerifyVolume, bypass the
    //  verify logic.
    //

    if ( Vcb->VerifyThread == KeGetCurrentThread() ) {

        SetFlag( IrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    }

    //
    //  Issue the read request
    //

    DebugDoit( RxIoCallDriverCount += 1);

    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    try {

        (VOID)RxLowLevelReadWrite( RxContext,
                                    Vcb->TargetDeviceObject,
                                    Irp,
                                    Vcb );

        RxWaitSync( RxContext );

    } finally {

        MmUnlockPages( Mdl );

        IoFreeMdl( Mdl );

        Irp->MdlAddress = SavedMdl;
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "RxSingleNonAlignedSync -> VOID\n", 0);

    return;
}


//
// Internal Support Routine
//

RXSTATUS
RxMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    RxRead/WriteMultipleAsynch.  It must synchronize its operation for
    multiprocessor environments with itself on all other processors, via
    a spin lock found via the Context parameter.

    The completion routine has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        (essentially by Vbo), and if so it must correctly reduce the
        byte count and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    Contxt - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    The routine returns RxStatus(MORE_PROCESSING_REQUIRED) so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{

    PRDBSS_IO_CONTEXT Context = Contxt;
    PIRP MasterIrp = Context->MasterIrp;

    DebugTrace(+1, Dbg, "RxMultiSyncCompletionRoutine, Context = %08lx\n", Context );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    MasterIrp = Context->MasterIrp;

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        MasterIrp->IoStatus = Irp->IoStatus;
    }

    //
    //  We must do this here since IoCompleteRequest won't get a chance
    //  on this associated Irp.
    //

    IoFreeMdl( Irp->MdlAddress );
    IoFreeIrp( Irp );

    //
    //  Use a spin lock to synchronize access to Context->IrpCount.
    //

    if (ExInterlockedDecrementLong(&Context->IrpCount,
                                   &RxData.StrucSupSpinLock) == RESULT_ZERO) {

        KeSetEvent( &Context->Wait.SyncEvent, 0, FALSE );
    }

    DebugTrace(-1, Dbg, "RxMultiSyncCompletionRoutine -> SUCCESS\n", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return RxStatus(MORE_PROCESSING_REQUIRED);
}


//
// Internal Support Routine
//

RXSTATUS
RxMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    RxRead/WriteMultipleAsynch.  It must synchronize its operation for
    multiprocessor environments with itself on all other processors, via
    a spin lock found via the Context parameter.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        (essentially by Vbo), and if so it must correctly reduce the
        byte count and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    Contxt - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    The routine returns RxStatus(MORE_PROCESSING_REQUIRED) so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{

    PRDBSS_IO_CONTEXT Context = Contxt;
    PIRP MasterIrp = Context->MasterIrp;

    DebugTrace(+1, Dbg, "RxMultiAsyncCompletionRoutine, Context = %08lx\n", Context );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    MasterIrp = Context->MasterIrp;

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        MasterIrp->IoStatus = Irp->IoStatus;
    }

    //
    //  Use a spin lock to synchronize access to Context->IrpCount.
    //

    if (ExInterlockedDecrementLong(&Context->IrpCount,
                                   &RxData.StrucSupSpinLock) == RESULT_ZERO) {

        if (NT_SUCCESS(MasterIrp->IoStatus.Status)) {

            MasterIrp->IoStatus.Information =
                Context->Wait.Async.RequestedByteCount;

            //
            //  Now if this wasn't PagingIo, set either the read or write bit.
            //

            if (!FlagOn(MasterIrp->Flags, IRP_PAGING_IO)) {

                SetFlag( Context->Wait.Async.FileObject->Flags,
                         IoGetCurrentIrpStackLocation(MasterIrp)->MajorFunction == IRP_MJ_READ ?
                         FO_FILE_FAST_IO_READ : FO_FILE_MODIFIED );
            }
        }

        //
        //  If this was a special async write, decrement the count.  Set the
        //  event if this was the final outstanding I/O for the file.  We will
        //  also want to queue an APC to deal with any error conditionions.
        //

        if ((Context->Wait.Async.NonPagedFcb) &&
            (ExInterlockedAddUlong( &Context->Wait.Async.NonPagedFcb->OutstandingAsyncWrites,
                                    0xffffffff,
                                    &RxStrucSupSpinLock ) == 1)) {

            KeSetEvent( Context->Wait.Async.NonPagedFcb->OutstandingAsyncEvent, 0, FALSE );
        }

        //
        //  Now release the resource
        //

        if (Context->Wait.Async.Resource != NULL) {

            ExReleaseResourceForThread( Context->Wait.Async.Resource,
                                        Context->Wait.Async.ResourceThreadId );
        }

        //
        //  Mark the master Irp pending
        //

        IoMarkIrpPending( MasterIrp );

        //
        //  and finally, free the context record.
        //

        ExFreePool( Context );
    }

    DebugTrace(-1, Dbg, "RxMultiAsyncCompletionRoutine -> SUCCESS\n", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return RxStatus(SUCCESS);
}


//
// Internal Support Routine
//

RXSTATUS
RxPagingFileCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MasterIrp
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    RxPagingFileIo.  It should only be invoked on error or cancel.

    The completion routine has has the following responsibility:

        Since the individual request was completed with an error,
        this completion routine must stuff it into the master irp.

        If the error implies a media problem, it also enqueues a
        worker item to write out the dirty bit so that the next
        time we run we will do a autochk /r

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    MasterIrp - Pointer to the master Irp.

Return Value:

    Always returns RxStatus(SUCCESS).

--*/

{
    RXSTATUS Status;

    DebugTrace(+1, Dbg, "RxPagingFileCompletionRoutine, MasterIrp = %08lx\n", MasterIrp );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    ASSERT( !NT_SUCCESS( Irp->IoStatus.Status ));

    //
    //  If we were invoked with an assoicated Irp, copy the error over.
    //

    if (Irp != MasterIrp) {

        ((PIRP)MasterIrp)->IoStatus = Irp->IoStatus;
    }

    //
    //  If this was a media error, we want to chkdsk /r the next time we boot.
    //

    if (FsRtlIsTotalDeviceFailure(Irp->IoStatus.Status)) {

        Status = RxStatus(SUCCESS);

    } else {

        PCLEAN_AND_DIRTY_VOLUME_PACKET Packet;

        //
        //  We are going to try to mark the volume needing recover.
        //  If we can't get pool, oh well....
        //

        Packet = ExAllocatePool(NonPagedPool, sizeof(CLEAN_AND_DIRTY_VOLUME_PACKET));

        if ( Packet ) {

            Packet->Vcb = &((PRDBSS_DEVICE_OBJECT)IoGetCurrentIrpStackLocation(Irp)->DeviceObject)->Vcb;
            Packet->Irp = Irp;

            ExInitializeWorkItem( &Packet->Item,
                                  &RxFspMarkVolumeDirtyWithRecover,
                                  Packet );

            ExQueueWorkItem( &Packet->Item, CriticalWorkQueue );

            Status = RxStatus(MORE_PROCESSING_REQUIRED);

        } else {

            Status = RxStatus(SUCCESS);
        }
    }

    DebugTrace(-1, Dbg, "RxPagingFileCompletionRoutine => (RxStatus(SUCCESS))\n", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return Status;
}


//
// Internal Support Routine
//

RXSTATUS
RxSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    RxRead/WriteSingleAsynch.

    The completion routine has has the following responsibilities:

        Copy the I/O status from the Irp to the Context, since the Irp
        will no longer be accessible.

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
    be accessible after this routine returns.)

    Contxt - The context parameter which was specified in the call to
             RxRead/WriteSingleAsynch.

Return Value:

    Currently always returns RxStatus(SUCCESS).

--*/

{
    PRDBSS_IO_CONTEXT Context = Contxt;

    DebugTrace(+1, Dbg, "RxSingleSyncCompletionRoutine, Context = %08lx\n", Context );

    KeSetEvent( &Context->Wait.SyncEvent, 0, FALSE );

    DebugTrace(-1, Dbg, "RxSingleSyncCompletionRoutine -> RxStatus(MORE_PROCESSING_REQUIRED\n)", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return RxStatus(MORE_PROCESSING_REQUIRED);
}


//
// Internal Support Routine
//

RXSTATUS
RxSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    RxRead/WriteSingleAsynch.

    The completion routine has has the following responsibilities:

        Copy the I/O status from the Irp to the Context, since the Irp
        will no longer be accessible.

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
    be accessible after this routine returns.)

    Contxt - The context parameter which was specified in the call to
             RxRead/WriteSingleAsynch.

Return Value:

    Currently always returns RxStatus(SUCCESS).

--*/

{
    PRDBSS_IO_CONTEXT Context = Contxt;

    DebugTrace(+1, Dbg, "RxSingleAsyncCompletionRoutine, Context = %08lx\n", Context );

    //
    //  Fill in the information field correctedly if this worked.
    //

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        Irp->IoStatus.Information = Context->Wait.Async.RequestedByteCount;

        //
        //  Now if this wasn't PagingIo, set either the read or write bit.
        //

        if (!FlagOn(Irp->Flags, IRP_PAGING_IO)) {

            SetFlag( Context->Wait.Async.FileObject->Flags,
                     IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_READ ?
                     FO_FILE_FAST_IO_READ : FO_FILE_MODIFIED );
        }
    }

    //
    //  If this was a special async write, decrement the count.  Set the
    //  event if this was the final outstanding I/O for the file.  We will
    //  also want to queue an APC to deal with any error conditionions.
    //

    if ((Context->Wait.Async.NonPagedFcb) &&
        (ExInterlockedAddUlong( &Context->Wait.Async.NonPagedFcb->OutstandingAsyncWrites,
                                0xffffffff,
                                &RxStrucSupSpinLock ) == 1)) {

        KeSetEvent( Context->Wait.Async.NonPagedFcb->OutstandingAsyncEvent, 0, FALSE );
    }

    //
    //  Now release the resource
    //

    if (Context->Wait.Async.Resource != NULL) {

        ExReleaseResourceForThread( Context->Wait.Async.Resource,
                                    Context->Wait.Async.ResourceThreadId );
    }

    //
    //  Mark the Irp pending
    //

    IoMarkIrpPending( Irp );

    //
    //  and finally, free the context record.
    //

    ExFreePool( Context );

    DebugTrace(-1, Dbg, "RxSingleAsyncCompletionRoutine -> RxStatus(MORE_PROCESSING_REQUIRED\n)", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return RxStatus(SUCCESS);
}


VOID
RxToggleMediaEjectDisable (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN BOOLEAN PreventRemoval
    )

/*++

Routine Description:

    The routine either enables or disables the eject button on removable
    media.  Any error conditions are ignored.

Arguments:

    Vcb - Descibes the volume to operate on

    PreventRemoval - TRUE if we should disable the media eject button.  FALSE
        if we want to enable it.

Return Value:

    None.

--*/

{
    PIRP Irp;
    KEVENT Event;
    RXSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    PREVENT_MEDIA_REMOVAL Prevent;

    Prevent.PreventMediaRemoval = PreventRemoval;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_MEDIA_REMOVAL,
                                         Vcb->Vpb->RealDevice,
                                         &Prevent,
                                         sizeof(PREVENT_MEDIA_REMOVAL),
                                         NULL,
                                         0,
                                         FALSE,
                                         &Event,
                                         &Iosb );

    if ( Irp != NULL ) {

        Status = IoCallDriver( Vcb->TargetDeviceObject, Irp );

        if (Status == RxStatus(PENDING)) {
            Status = KeWaitForSingleObject( &Event,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL );
        }
    }
}

#ifdef WE_WON_ON_APPEAL


RXSTATUS
RxLowLevelDblsReadWrite (
    PRX_CONTEXT RxContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine passes on a non-cached read or write request to the
    double space routines.  The status is extracted from an exception
    handler in case of error.

Arguments:

    Vcb - Descibes the volume to operate on.

    Irp - Supplies the parameters for the read/write operation.

Return Value:

    The Status of the read or write operation.

--*/

{

    PIO_STACK_LOCATION IrpSp;
    ULONG BytesTransfered = 0;
    RXSTATUS Status = RxStatus(SUCCESS);

    IrpSp = IoGetNextIrpStackLocation( Irp );

    try {

#ifdef DOUBLE_SPACE_WRITE

        BytesTransfered = (IrpSp->MajorFunction == IRP_MJ_READ) ?

            RxDblsReadData( RxContext,
                             Vcb->Dscb,
                             IrpSp->Parameters.Read.ByteOffset.LowPart,
                             MmGetSystemAddressForMdl( Irp->MdlAddress ),
                             IrpSp->Parameters.Read.Length )
            :

            RxDblsWriteData( RxContext,
                              Vcb->Dscb,
                              IrpSp->Parameters.Write.ByteOffset.LowPart,
                              MmGetSystemAddressForMdl( Irp->MdlAddress ),
                              IrpSp->Parameters.Write.Length );

#else

        BytesTransfered =

            RxDblsReadData( RxContext,
                             Vcb->Dscb,
                             IrpSp->Parameters.Read.ByteOffset.LowPart,
                             MmGetSystemAddressForMdl( Irp->MdlAddress ),
                             IrpSp->Parameters.Read.Length );
#endif // DOUBLE_SPACE_WRITE

    } except(RxExceptionFilter( RxContext, GetExceptionInformation() )) {

        Status = RxContext->ExceptionStatus;
        RxContext->ExceptionStatus = 0;
    }

    //
    //  Load up the Status in the Irp
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = BytesTransfered;

    //
    //  Update the IRP stack to point to the next location so that our
    //  completion routine will get called.
    //

    Irp->CurrentLocation--;
    Irp->Tail.Overlay.CurrentStackLocation--;

    if (Irp->CurrentLocation <= 0) {

        KeBugCheckEx( NO_MORE_IRP_STACK_LOCATIONS, (ULONG) Irp, 0, 0, 0 );
    }

    IoCompleteRequest( Irp, IO_DISK_INCREMENT );

    return Status;
}

#endif // WE_WON_ON_APPEAL

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\dirsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DirSup.c

Abstract:

    This module implements the dirent support routines for Rx.

Author:

    DavidGoebel     [DavidGoe]      08-Nov-90

--*/

//    ----------------------joejoe-----------found-------------#include "RxProcs.h"
#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_DIRSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIRSUP)

//
//  The following three macro all assume the input dirent has been zeroed.
//

//
//  VOID
//  RxConstructDot (
//      IN PRX_CONTEXT RxContext,
//      IN PDCB Directory,
//      IN PDIRENT ParentDirent,
//      IN OUT PDIRENT Dirent
//      );
//
//  The following macro is called to initalize the "." dirent.
//

#define RxConstructDot(RXCONTEXT,DCB,PARENT,DIRENT) {                  \
                                                                         \
    RtlCopyMemory( (PUCHAR)(DIRENT), ".          ", 11 );                \
    (DIRENT)->Attributes = RDBSS_DIRENT_ATTR_DIRECTORY;                    \
    (DIRENT)->LastWriteTime = (PARENT)->LastWriteTime;                   \
    if (RxData.ChicagoMode) {                                           \
        (DIRENT)->CreationTime = (PARENT)->CreationTime;                 \
        (DIRENT)->CreationMSec = (PARENT)->CreationMSec;                 \
        (DIRENT)->LastAccessDate = (PARENT)->LastAccessDate;             \
    }                                                                    \
    (DIRENT)->FirstClusterOfFile = (RDBSS_ENTRY)(DCB)->FirstClusterOfFile; \
}

//
//  VOID
//  RxConstructDotDot (
//      IN PRX_CONTEXT RxContext,
//      IN PDCB Directory,
//      IN PDIRENT ParentDirent,
//      IN OUT PDIRENT Dirent
//      );
//
//  The following macro is called to initalize the ".." dirent.
//

#define RxConstructDotDot(RXCONTEXT,DCB,PARENT,DIRENT) {   \
                                                             \
    RtlCopyMemory( (PUCHAR)(DIRENT), "..         ", 11 );    \
    (DIRENT)->Attributes = RDBSS_DIRENT_ATTR_DIRECTORY;        \
    (DIRENT)->LastWriteTime = (PARENT)->LastWriteTime;       \
    if (RxData.ChicagoMode) {                               \
        (DIRENT)->CreationTime = (PARENT)->CreationTime;     \
        (DIRENT)->CreationMSec = (PARENT)->CreationMSec;     \
        (DIRENT)->LastAccessDate = (PARENT)->LastAccessDate; \
    }                                                        \
    (DIRENT)->FirstClusterOfFile = (RDBSS_ENTRY) (             \
        NodeType((DCB)->ParentDcb) == RDBSS_NTC_ROOT_DCB ?     \
        0 : (DCB)->ParentDcb->FirstClusterOfFile);           \
}

//
//  VOID
//  RxConstructEndDirent (
//      IN PRX_CONTEXT RxContext,
//      IN OUT PDIRENT Dirent
//      );
//
//  The following macro created the end dirent.  Note that since the
//  dirent was zeroed, the first byte of the name already contains 0x0,
//  so there is nothing to do.
//

#define RxConstructEndDirent(RXCONTEXT,DIRENT) NOTHING

//
//  VOID
//  RxReadDirent (
//      IN PRX_CONTEXT RxContext,
//      IN PDCB Dcb,
//      IN VBO Vbo,
//      OUT PBCB *Bcb,
//      OUT PVOID *Dirent,
//      OUT PRXSTATUS Status
//      );
//

//
//  This macro reads in a page of dirents when we step onto a new page,
//  or this is the first itteration of a loop and Bcb is NULL.
//

#define RxReadDirent(RXCONTEXT,DCB,VBO,BCB,DIRENT,STATUS)       \
if ((VBO) >= (DCB)->Header.AllocationSize.LowPart) {              \
    *(STATUS) = RxStatus(END_OF_FILE);                               \
    RxUnpinBcb( (RXCONTEXT), *(BCB) );                          \
} else if ( ((VBO) % PAGE_SIZE == 0) || (*(BCB) == NULL) ) {      \
    RxUnpinBcb( (RXCONTEXT), *(BCB) );                          \
    RxReadDirectoryFile( (RXCONTEXT),                           \
                          (DCB),                                  \
                          (VBO) & ~(PAGE_SIZE - 1),               \
                          PAGE_SIZE,                              \
                          FALSE,                                  \
                          (BCB),                                  \
                          (PVOID *)(DIRENT),                      \
                          (STATUS) );                             \
    *(DIRENT) = (PVOID)((PUCHAR)*(DIRENT) + ((VBO) % PAGE_SIZE)); \
}

//
//  Internal support routines
//

UCHAR
RxComputeLfnChecksum (
    PDIRENT Dirent
    );

VOID
RxRescanDirectory (
    PRX_CONTEXT RxContext,
    PDCB Dcb
    );

ULONG
RxDefragDirectory (
    IN PRX_CONTEXT RxContext,
    IN PDCB Dcb,
    IN ULONG DirentsNeeded
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxConstructDirent)
#pragma alloc_text(PAGE, RxConstructLabelDirent)
#pragma alloc_text(PAGE, RxCreateNewDirent)
#pragma alloc_text(PAGE, RxDeleteDirent)
#pragma alloc_text(PAGE, RxGetDirentFromFcbOrDcb)
#pragma alloc_text(PAGE, RxInitializeDirectoryDirent)
#pragma alloc_text(PAGE, RxIsDirectoryEmpty)
#pragma alloc_text(PAGE, RxLocateDirent)
#pragma alloc_text(PAGE, RxLocateSimpleOemDirent)
#pragma alloc_text(PAGE, RxLocateVolumeLabel)
#pragma alloc_text(PAGE, RxSetFileSizeInDirent)
#pragma alloc_text(PAGE, RxComputeLfnChecksum)
#pragma alloc_text(PAGE, RxRescanDirectory)
#pragma alloc_text(PSGE, RxDefragDirectory)
#endif


ULONG
RxCreateNewDirent (
    IN PRX_CONTEXT RxContext,
    IN PDCB ParentDirectory,
    IN ULONG DirentsNeeded
    )

/*++

Routine Description:

    This routine allocates on the disk a new dirent inside of the
    parent directory.  If a new dirent cannot be allocated (i.e.,
    because the disk is full or the root directory is full) then
    it raises the appropriate status.  The dirent itself is
    neither initialized nor pinned by this procedure.

Arguments:

    ParentDirectory - Supplies the DCB for the directory in which
        to create the new dirent

    DirentsNeeded - This is the number of continginous dirents required

Return Value:

    ByteOffset - Returns the VBO within the Parent directory where
        the dirent has been allocated

--*/

{
    VBO UnusedVbo;
    VBO DeletedHint;
    ULONG ByteOffset;

    PBCB Bcb = NULL;
    PDIRENT Dirent;
    RXSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "RxCreateNewDirent\n", 0);

    DebugTrace( 0, Dbg, "  ParentDirectory = %08lx\n", ParentDirectory);

    //
    //  If UnusedDirentVbo is within our current file allocation then we
    //  don't have to search through the directory at all; we know just
    //  where to put it.
    //
    //  If UnusedDirentVbo is beyond the current file allocation then
    //  there are no more unused dirents in the current allocation, though
    //  upon adding another cluster of allocation UnusedDirentVbo
    //  will point to an unused dirent.  Haveing found no unused dirents
    //  we use the DeletedDirentHint to try and find a deleted dirent in
    //  the current allocation.  In this also runs off the end of the file,
    //  we finally have to break down and allocate another sector.  Note
    //  that simply writing beyond the current allocation will automatically
    //  do just this.
    //
    //  We also must deal with the special case where UnusedDirentVbo and
    //  DeletedDirentHint have yet to be initialized.  In this case we must
    //  first walk through the directory looking for the first deleted entry
    //  first unused dirent.  After this point we continue as before.
    //  This virgin state is denoted by the special value of 0xffffffff.
    //

    UnusedVbo = ParentDirectory->Specific.Dcb.UnusedDirentVbo;
    DeletedHint = ParentDirectory->Specific.Dcb.DeletedDirentHint;

    //
    //  Check for our first call to this routine with this Dcb.  If so
    //  we have to correctly set the two hints in the Dcb.
    //

    if (UnusedVbo == 0xffffffff) {

        RxRescanDirectory( RxContext, ParentDirectory );

        UnusedVbo = ParentDirectory->Specific.Dcb.UnusedDirentVbo;
        DeletedHint = ParentDirectory->Specific.Dcb.DeletedDirentHint;
    }

    //
    //  Now we know that UnusedDirentVbo and DeletedDirentHint are correctly
    //  set so we check if there is already an unused dirent in the the
    //  current allocation.  This is the easy case.
    //

    DebugTrace( 0, Dbg, "  UnusedVbo   = %08lx\n", UnusedVbo);
    DebugTrace( 0, Dbg, "  DeletedHint = %08lx\n", DeletedHint);

    if ( UnusedVbo + (DirentsNeeded * sizeof(DIRENT)) <=
         ParentDirectory->Header.AllocationSize.LowPart ) {

        //
        //  Get this unused dirent for the caller.  We have a
        //  sporting chance that we won't have to wait.
        //

        DebugTrace( 0, Dbg, "There is a never used entry.\n", 0);

        ByteOffset = UnusedVbo;

        UnusedVbo += DirentsNeeded * sizeof(DIRENT);

    } else {

        //
        //  Life is tough.  We have to march from the DeletedDirentHint
        //  looking for a deleted dirent.  If we get to EOF without finding
        //  one, we will have to allocate a new cluster.
        //

        ByteOffset =
            RtlFindClearBits( &ParentDirectory->Specific.Dcb.FreeDirentBitmap,
                              DirentsNeeded,
                              DeletedHint / sizeof(DIRENT) );

        //
        //  Do a quick check for a root directory allocation that failed
        //  simply because of fragmentation.  Also, only attempt to defrag
        //  if the length is less that 0x40000.  This is to avoid
        //  complications arrising from crossing a cache manager VMCB block
        //  (by default on DOS the root directory is only 0x2000 long).
        //

        if ((ByteOffset == -1) &&
            (NodeType(ParentDirectory) == RDBSS_NTC_ROOT_DCB) &&
            (ParentDirectory->Header.AllocationSize.LowPart <= 0x40000)) {

            ByteOffset = RxDefragDirectory( RxContext, ParentDirectory, DirentsNeeded );
        }

        if (ByteOffset != -1) {

            //
            //  If we consuemed deleted dirents at Deleted Hint, update.
            //  We also may have consumed some un-used dirents as well,
            //  so be sure to check for that as well.
            //

            ByteOffset *= sizeof(DIRENT);

            if (ByteOffset == DeletedHint) {

                DeletedHint += DirentsNeeded * sizeof(DIRENT);
            }

            if (ByteOffset + DirentsNeeded * sizeof(DIRENT) > UnusedVbo) {

                UnusedVbo = ByteOffset + DirentsNeeded * sizeof(DIRENT);
            }

        } else {

            //
            //  We are going to have to allocate another cluster.  Do
            //  so, update both the UnusedVbo and the DeletedHint and bail.
            //

            DebugTrace( 0, Dbg, "We have to allocate another cluster.\n", 0);

            //
            //  Make sure we are not trying to expand the root directory.
            //

            if ( NodeType(ParentDirectory) == RDBSS_NTC_ROOT_DCB ) {

                DebugTrace(0, Dbg, "Disk Full.  Raise Status.\n", 0);

                RxRaiseStatus( RxContext, RxStatus(DISK_FULL) );
            }

            //
            //  Take the last dirent(s) in this cluster.  We will allocate
            //  another below.
            //

            ByteOffset = UnusedVbo;

            UnusedVbo += DirentsNeeded * sizeof(DIRENT);

            //
            //  OK, touch the dirent now to cause the space to get allocated.
            //

            Bcb = NULL;

            try {

                ULONG Offset;
                ULONG ClusterSize;

                ClusterSize =
                    1 << ParentDirectory->Vcb->AllocationSupport.LogOfBytesPerCluster;

                Offset = UnusedVbo & ~(ClusterSize - 1);

                RxPrepareWriteDirectoryFile( RxContext,
                                              ParentDirectory,
                                              Offset,
                                              sizeof(DIRENT),
                                              &Bcb,
                                              &Dirent,
                                              FALSE,
                                              &Status );

            } finally {

                RxUnpinBcb( RxContext, Bcb );
            }
        }
    }

    //
    //  If we are only requesting a single dirent, and we did not get the
    //  first dirent in a directory, then check that the preceding dirent
    //  is not an orphaned LFN.  If it is, then mark it deleted.  Thus
    //  reducing the possibility of an accidental pairing.
    //
    //  Only do this when we are in Chicago Mode.
    //

    Bcb = NULL;

    if (RxData.ChicagoMode &&
        (DirentsNeeded == 1) &&
        (ByteOffset > (NodeType(ParentDirectory) == RDBSS_NTC_ROOT_DCB ?
                       0 : 2 * sizeof(DIRENT)))) {
        try {

            RxReadDirent( RxContext,
                           ParentDirectory,
                           ByteOffset - sizeof(DIRENT),
                           &Bcb,
                           &Dirent,
                           &Status );

            if ((Status != RxStatus(SUCCESS)) ||
                (Dirent->FileName[0] == RDBSS_DIRENT_NEVER_USED)) {

                RxPopUpFileCorrupt( RxContext, ParentDirectory );

                RxRaiseStatus( RxContext, RxStatus(FILE_CORRUPT_ERROR) );
            }

            if ((Dirent->Attributes == RDBSS_DIRENT_ATTR_LFN) &&
                (Dirent->FileName[0] != RDBSS_DIRENT_DELETED)) {

                //
                //  Pin it, mark it, and set it dirty.
                //

                RxPinMappedData( RxContext,
                                  ParentDirectory,
                                  ByteOffset - sizeof(DIRENT),
                                  sizeof(DIRENT),
                                  &Bcb );

                Dirent->FileName[0] = RDBSS_DIRENT_DELETED;

                RxSetDirtyBcb( RxContext, Bcb, ParentDirectory->Vcb );

                ASSERT( RtlAreBitsSet( &ParentDirectory->Specific.Dcb.FreeDirentBitmap,
                                       (ByteOffset - sizeof(DIRENT))/ sizeof(DIRENT),
                                       DirentsNeeded ) );

                RtlClearBits( &ParentDirectory->Specific.Dcb.FreeDirentBitmap,
                              (ByteOffset - sizeof(DIRENT))/ sizeof(DIRENT),
                              DirentsNeeded );

            }

        } finally {

            RxUnpinBcb( RxContext, Bcb );
        }
    }

    //
    //  Assert that the dirents are in fact unused
    //

    try {

        ULONG i;

        Bcb = NULL;

        for (i = 0; i < DirentsNeeded; i++) {

            RxReadDirent( RxContext,
                           ParentDirectory,
                           ByteOffset + i*sizeof(DIRENT),
                           &Bcb,
                           &Dirent,
                           &Status );

            if ((Status != RxStatus(SUCCESS)) ||
                ((Dirent->FileName[0] != RDBSS_DIRENT_NEVER_USED) &&
                 (Dirent->FileName[0] != RDBSS_DIRENT_DELETED))) {

                RxPopUpFileCorrupt( RxContext, ParentDirectory );

                RxRaiseStatus( RxContext, RxStatus(FILE_CORRUPT_ERROR) );
            }
        }

    } finally {

        RxUnpinBcb( RxContext, Bcb );
    }

    //
    //  Set the Bits in the bitmap and move the Unused Dirent Vbo.
    //

    ASSERT( RtlAreBitsClear( &ParentDirectory->Specific.Dcb.FreeDirentBitmap,
                             ByteOffset / sizeof(DIRENT),
                             DirentsNeeded ) );

    RtlSetBits( &ParentDirectory->Specific.Dcb.FreeDirentBitmap,
                ByteOffset / sizeof(DIRENT),
                DirentsNeeded );

    //
    //  Save the newly computed values in the Parent Directory Fcb
    //

    ParentDirectory->Specific.Dcb.UnusedDirentVbo = UnusedVbo;
    ParentDirectory->Specific.Dcb.DeletedDirentHint = DeletedHint;

    DebugTrace(-1, Dbg, "RxCreateNewDirent -> (VOID)\n", 0);

    return ByteOffset;
}


VOID
RxInitializeDirectoryDirent (
    IN PRX_CONTEXT RxContext,
    IN PDCB Dcb,
    IN PDIRENT ParentDirent
    )

/*++

Routine Description:

    This routine converts a dirent into a directory on the disk.  It does this
    setting the directory flag in the dirent, and by allocating the necessary
    space for the "." and ".." dirents and initializing them.

    If a new dirent cannot be allocated (i.e., because the disk is full) then
    it raises the appropriate status.

Arguments:

    Dcb - Supplies the Dcb denoting the file that is to be made into a
        directory.  This must be input a completely empty file with
        an allocation size of zero.

    ParentDirent - Provides the parent Dirent for a time-stamp model.

Return Value:

    None.

--*/

{
    PBCB Bcb;
    PVOID Buffer;
    RXSTATUS DontCare;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "RxInitializeDirectoryDirent\n", 0);

    DebugTrace( 0, Dbg, "  Dcb = %08lx\n", Dcb);

    //
    //  Assert that we are not attempting this on the root directory.
    //

    ASSERT( NodeType(Dcb) != RDBSS_NTC_ROOT_DCB );

    //
    //  Assert that this is only attempted on newly created directories.
    //

    ASSERT( Dcb->Header.AllocationSize.LowPart == 0 );

    //
    //  Prepare the directory file for writing.  Note that we can use a single
    //  Bcb for these two entries because we know they are the first two in
    //  the directory, and thus together do not span a page boundry.  Also
    //  note that we prepare write 2 entries: one for "." and one for "..".
    //  The end of directory marker is automatically set since the whole
    //  directory is initially zero (DIRENT_NEVER_USED).
    //

    RxPrepareWriteDirectoryFile( RxContext,
                                  Dcb,
                                  0,
                                  2 * sizeof(DIRENT),
                                  &Bcb,
                                  &Buffer,
                                  FALSE,
                                  &DontCare );

    ASSERT( NT_SUCCESS( DontCare ));

    //
    //  Add the . and .. entries
    //

    RxConstructDot( RxContext, Dcb, ParentDirent, (PDIRENT)Buffer + 0);

    RxConstructDotDot( RxContext, Dcb, ParentDirent, (PDIRENT)Buffer + 1);

    //
    //  Unpin the buffer and return to the caller.
    //

    RxUnpinBcb( RxContext, Bcb );

    DebugTrace(-1, Dbg, "RxInitializeDirectoryDirent -> (VOID)\n", 0);
    return;
}


VOID
RxDeleteDirent (
    IN PRX_CONTEXT RxContext,
    IN PFCB FcbOrDcb,
    IN PDELETE_CONTEXT DeleteContext OPTIONAL,
    IN BOOLEAN DeleteEa
    )

/*++

Routine Description:

    This routine Deletes on the disk the indicated dirent.  It does
    this by marking the dirent as deleted.

Arguments:

    FcbOrDcb - Supplies the FCB/DCB for the file/directory being
        deleted.  For a file the file size and allocation must be zero.
        (Zero allocation is implied by a zero cluster index).
        For a directory the allocation must be zero.

    DeleteContext - This variable, if speicified, may be used to preserve
        the file size and first cluster of file information in the dirent
        fot the benefit of unerase utilities.

    DeleteEa - Tells us whether to delete the EA and whether to check
        for no allocation/  Mainly TRUE.  FALSE passed in from rename.

Return Value:

    None.

--*/

{
    PBCB Bcb = NULL;
    PDIRENT Dirent;
    RXSTATUS DontCare;
    ULONG Offset;
    ULONG DirentsToDelete;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "RxDeleteDirent\n", 0);

    DebugTrace( 0, Dbg, "  FcbOrDcb = %08lx\n", FcbOrDcb);

    //
    //  Assert that we are not attempting this on the root directory.
    //

    ASSERT( NodeType(FcbOrDcb) != RDBSS_NTC_ROOT_DCB );

    //
    //  Make sure all requests have zero allocation/file size
    //


    if (DeleteEa &&
        ((FcbOrDcb->Header.AllocationSize.LowPart != 0) ||
         ((NodeType(FcbOrDcb) == RDBSS_NTC_FCB) &&
          (FcbOrDcb->Header.FileSize.LowPart != 0)))) {

        DebugTrace( 0, Dbg, "Called with non zero allocation/file size.\n", 0);
        RxBugCheck( 0, 0, 0 );
    }

    //
    //  Now, mark the dirents deleted, unpin the Bcb, and return to the caller.
    //  Assert that there isn't any allocation associated with this dirent.
    //
    //  Note that this loop will end with Dirent pointing to the short name.
    //

    for ( Offset = FcbOrDcb->LfnOffsetWithinDirectory;
          Offset <= FcbOrDcb->DirentOffsetWithinDirectory;
          Offset += sizeof(DIRENT), Dirent += 1 ) {

        //
        //  If we stepped onto a new page, or this is the first itteration,
        //  unpin the old page, and pin the new one.
        //

        if ((Offset == FcbOrDcb->LfnOffsetWithinDirectory) ||
            ((Offset & (PAGE_SIZE - 1)) == 0)) {

            RxUnpinBcb( RxContext, Bcb );

            RxPrepareWriteDirectoryFile( RxContext,
                                          FcbOrDcb->ParentDcb,
                                          Offset,
                                          sizeof(DIRENT),
                                          &Bcb,
                                          (PVOID *)&Dirent,
                                          FALSE,
                                          &DontCare );
        }

        ASSERT( (Dirent->FirstClusterOfFile == 0) || !DeleteEa );
        Dirent->FileName[0] = RDBSS_DIRENT_DELETED;
    }

    //
    //  Back Dirent off by one to point back to the short dirent.
    //

    Dirent -= 1;

    //
    //  If there are extended attributes for this dirent, we will attempt
    //  to remove them.  We ignore any errors in removing Eas.
    //

    if (DeleteEa && (Dirent->ExtendedAttributes != 0)) {

        try {

            RxDeleteEa( RxContext,
                         FcbOrDcb->Vcb,
                         Dirent->ExtendedAttributes,
                         &FcbOrDcb->ShortName.Name.Oem );

        } except(RxExceptionFilter( RxContext, GetExceptionInformation() )) {

            //
            //  We catch all exceptions that Rx catches, but don't do
            //  anything with them.
            //
        }
    }

    //
    //  Now clear the bits in the free dirent mask.
    //

    DirentsToDelete = (FcbOrDcb->DirentOffsetWithinDirectory -
                       FcbOrDcb->LfnOffsetWithinDirectory) / sizeof(DIRENT) + 1;


    ASSERT( (FcbOrDcb->ParentDcb->Specific.Dcb.UnusedDirentVbo == 0xffffffff) ||
            RtlAreBitsSet( &FcbOrDcb->ParentDcb->Specific.Dcb.FreeDirentBitmap,
                           FcbOrDcb->LfnOffsetWithinDirectory / sizeof(DIRENT),
                           DirentsToDelete ) );

    RtlClearBits( &FcbOrDcb->ParentDcb->Specific.Dcb.FreeDirentBitmap,
                  FcbOrDcb->LfnOffsetWithinDirectory / sizeof(DIRENT),
                  DirentsToDelete );

    //
    //  Now, if the caller specified a DeleteContext, use it.
    //

    if ( ARGUMENT_PRESENT( DeleteContext ) ) {

        Dirent->FileSize = DeleteContext->FileSize;
        Dirent->FirstClusterOfFile = (RDBSS_ENTRY)DeleteContext->FirstClusterOfFile;
    }

    //
    //  If this newly deleted dirent is before the DeletedDirentHint, change
    //  the DeletedDirentHint to point here.
    //

    if (FcbOrDcb->DirentOffsetWithinDirectory <
                        FcbOrDcb->ParentDcb->Specific.Dcb.DeletedDirentHint) {

        FcbOrDcb->ParentDcb->Specific.Dcb.DeletedDirentHint =
                                        FcbOrDcb->LfnOffsetWithinDirectory;
    }

    RxUnpinBcb( RxContext, Bcb );

    DebugTrace(-1, Dbg, "RxDeleteDirent -> (VOID)\n", 0);
    return;
}


VOID
RxLocateDirent (
    IN PRX_CONTEXT RxContext,
    IN PDCB ParentDirectory,
    IN PFOBX Fobx,
    IN VBO OffsetToStartSearchFrom,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb,
    OUT PVBO ByteOffset,
    OUT PUNICODE_STRING LongFileName OPTIONAL
    )

/*++

Routine Description:

    This routine locates on the disk an undelted dirent matching a given name.

Arguments:

    ParentDirectory - Supplies the DCB for the directory in which
        to search

    Fobx - Contains a context control block with all matching information.

    OffsetToStartSearchFrom - Supplies the VBO within the parent directory
        from which to start looking for another real dirent.

    Dirent - Receives a pointer to the located dirent if one was found
        or NULL otherwise.

    Bcb - Receives the Bcb for the located dirent if one was found or
        NULL otherwise.

    ByteOffset - Receives the VBO within the Parent directory for
        the located dirent if one was found, or 0 otherwise.

    LongFileName - If specified, this parameter returns the long file name
        associated with the returned dirent.  Note that it is the caller's
        responsibility to provide the buffer (and set MaximumLength
        accordingly) for this unicode string.  The Length field is reset
        to 0 by this routine on invocation.

Return Value:

    None.

--*/

{
    RXSTATUS Status;

    OEM_STRING Name;
    UCHAR NameBuffer[12];

    UNICODE_STRING LocalUpcasedLfn;
    UNICODE_STRING PoolUpcasedLfn;
    PUNICODE_STRING UpcasedLfn;

    WCHAR LocalLfnBuffer[32];

    BOOLEAN LfnInProgress = FALSE;
    UCHAR LfnChecksum;
    ULONG LfnSize;
    ULONG LfnIndex;
    UCHAR Ordinal;
    VBO LfnByteOffset;

    TimerStart(Dbg);

    PAGED_CODE();

    DebugTrace(+1, Dbg, "RxLocateDirent\n", 0);

    DebugTrace( 0, Dbg, "  ParentDirectory         = %08lx\n", ParentDirectory);
//    DebugTrace( 0, Dbg, "  FileName                = %08lx\n", FileName);
    DebugTrace( 0, Dbg, "  Fobx                     = %08lx\n", Fobx);
    DebugTrace( 0, Dbg, "  OffsetToStartSearchFrom = %08lx\n", OffsetToStartSearchFrom);
    DebugTrace( 0, Dbg, "  Dirent                  = %08lx\n", Dirent);
    DebugTrace( 0, Dbg, "  Bcb                     = %08lx\n", Bcb);
    DebugTrace( 0, Dbg, "  ByteOffset              = %08lx\n", ByteOffset);

//nolonger    DebugTrace( 0, Dbg, "We are looking for the dirent %wZ.\n", FileName);

    //
    //  The algorithm here is pretty simple.  We just walk through the
    //  parent directory until we:
    //
    //      A)  Find a matching entry.
    //      B)  Can't Wait
    //      C)  Hit the End of Directory
    //      D)  Hit Eof
    //
    //  In the first case we found it, in the latter three cases we did not.
    //

    //
    //  Set up the strings that receives file names from our search
    //

    Name.MaximumLength = 12;
    Name.Buffer = NameBuffer;

    PoolUpcasedLfn.Length =
    PoolUpcasedLfn.MaximumLength = 0;
    PoolUpcasedLfn.Buffer = NULL;

    LocalUpcasedLfn.Length = 0;
    LocalUpcasedLfn.MaximumLength = 32*sizeof(WCHAR);
    LocalUpcasedLfn.Buffer = LocalLfnBuffer;

    //
    //  If we were given a non-NULL Bcb, compute the new Dirent address
    //  from the prior one, or unpin the Bcb if the new Dirent is not pinned.
    //

    if (*Bcb != NULL) {

        if ((OffsetToStartSearchFrom / PAGE_SIZE) == (*ByteOffset / PAGE_SIZE)) {

            *Dirent += (OffsetToStartSearchFrom - *ByteOffset) / sizeof(DIRENT);

        } else {

            RxUnpinBcb( RxContext, *Bcb );
        }
    }

    //
    //  Init the Lfn if we were given one.
    //

    if (ARGUMENT_PRESENT(LongFileName)) {

        LongFileName->Length = 0;
    }

    //
    //  Round up OffsetToStartSearchFrom to the nearest Dirent, and store
    //  in ByteOffset.  Note that this wipes out the prior value.
    //

    *ByteOffset = (OffsetToStartSearchFrom +  (sizeof(DIRENT) - 1))
                                           & ~(sizeof(DIRENT) - 1);

    try {

        while ( TRUE ) {

            BOOLEAN FoundValidLfn;

            //
            //  Try to read in the dirent
            //

            RxReadDirent( RxContext,
                           ParentDirectory,
                           *ByteOffset,
                           Bcb,
                           Dirent,
                           &Status );

            //
            //  If End Directory dirent or EOF, set all out parameters to
            //  indicate entry not found and, like, bail.
            //
            //  Note that the order of evaluation here is important since we
            //  cannot check the first character of the dirent until after we
            //  know we are not beyond EOF
            //

            if ((Status == RxStatus(END_OF_FILE)) ||
                ((*Dirent)->FileName[0] == RDBSS_DIRENT_NEVER_USED)) {

                DebugTrace( 0, Dbg, "End of directory: entry not found.\n", 0);

                //
                //  If there is a Bcb, unpin it and set it to null
                //

                RxUnpinBcb( RxContext, *Bcb );

                *Dirent = NULL;
                *ByteOffset = 0;
                break;
            }

            //
            //  If we have wandered onto an LFN entry, try to interpret it.
            //

            if (RxData.ChicagoMode &&
                ARGUMENT_PRESENT(LongFileName) &&
                ((*Dirent)->Attributes == RDBSS_DIRENT_ATTR_LFN)) {

                PLFN_DIRENT Lfn;

                Lfn = (PLFN_DIRENT)*Dirent;

                if (LfnInProgress) {

                    //
                    //  Check for a propper continuation of the Lfn in progress.
                    //

                    if ((Lfn->Ordinal & RDBSS_LAST_LONG_ENTRY) ||
                        (Lfn->Ordinal == 0) ||
                        (Lfn->Ordinal != Ordinal - 1) ||
                        (Lfn->Type != RDBSS_LONG_NAME_COMP) ||
                        (Lfn->Checksum != LfnChecksum) ||
                        (Lfn->MustBeZero != 0)) {

                        //
                        //  The Lfn is not propper, stop constructing it.
                        //

                        LfnInProgress = FALSE;

                    } else {

                        ASSERT( ((LfnIndex % 13) == 0) && LfnIndex );

                        LfnIndex -= 13;

                        RtlCopyMemory( &LongFileName->Buffer[LfnIndex+0],
                                       &Lfn->Name1[0],
                                       5*sizeof(WCHAR) );

                        RtlCopyMemory( &LongFileName->Buffer[LfnIndex+5],
                                       &Lfn->Name2[0],
                                       6 * sizeof(WCHAR) );

                        RtlCopyMemory( &LongFileName->Buffer[LfnIndex+11],
                                       &Lfn->Name3[0],
                                       2 * sizeof(WCHAR) );

                        Ordinal = Lfn->Ordinal;
                        LfnByteOffset = *ByteOffset;
                    }
                }

                //
                //  Now check (maybe again) if should analyse this entry
                //  for a possible last entry.
                //

                if ((!LfnInProgress) &&
                    (Lfn->Ordinal & RDBSS_LAST_LONG_ENTRY) &&
                    ((Lfn->Ordinal & ~RDBSS_LAST_LONG_ENTRY) <= MAX_LFN_DIRENTS) &&
                    (Lfn->Type == RDBSS_LONG_NAME_COMP) &&
                    (Lfn->MustBeZero == 0)) {

                    BOOLEAN CheckTail = FALSE;

                    Ordinal = Lfn->Ordinal & ~RDBSS_LAST_LONG_ENTRY;

                    LfnIndex = (Ordinal - 1) * 13;

                    RtlCopyMemory( &LongFileName->Buffer[LfnIndex+0],
                                   &Lfn->Name1[0],
                                   5*sizeof(WCHAR));

                    RtlCopyMemory( &LongFileName->Buffer[LfnIndex+5],
                                   &Lfn->Name2[0],
                                   6 * sizeof(WCHAR) );

                    RtlCopyMemory( &LongFileName->Buffer[LfnIndex+11],
                                   &Lfn->Name3[0],
                                   2 * sizeof(WCHAR) );

                    //
                    //  Now compute the Lfn size and make sure that the tail
                    //  bytes are correct.
                    //

                    while (LfnIndex != (ULONG)Ordinal * 13) {

                        if (!CheckTail) {

                            if (LongFileName->Buffer[LfnIndex] == 0x0000) {

                                LfnSize = LfnIndex;
                                CheckTail = TRUE;
                            }

                        } else {

                            if (LongFileName->Buffer[LfnIndex] != 0xffff) {

                                break;
                            }
                        }

                        LfnIndex += 1;
                    }

                    //
                    //  If we exited this loop prematurely, the LFN is not valid.
                    //

                    if (LfnIndex == (ULONG)Ordinal * 13) {

                        //
                        //  If we didn't find the NULL terminator, then the size
                        //  is LfnIndex.
                        //

                        if (!CheckTail) {

                            LfnSize = LfnIndex;
                        }

                        LfnIndex -= 13;
                        LfnInProgress = TRUE;
                        LfnChecksum = Lfn->Checksum;
                        LfnByteOffset = *ByteOffset;
                    }
                }

                //
                //  Move on to the next dirent.
                //

                goto GetNextDirent;
            }

            //
            //  If the file is not deleted and is not the volume label, check
            //  for a match.
            //

            if ( ((*Dirent)->FileName[0] == RDBSS_DIRENT_DELETED) ||
                 FlagOn((*Dirent)->Attributes, RDBSS_DIRENT_ATTR_VOLUME_ID)) {

                //
                //  Move on to the next dirent.
                //

                goto GetNextDirent;
            }

            //
            //  We may have just stepped off a valid Lfn run.  Check to see if
            //  it is indeed valid for the following dirent.
            //

            if (LfnInProgress &&
                (*ByteOffset == LfnByteOffset + sizeof(DIRENT)) &&
                (LfnIndex == 0) &&
                (RxComputeLfnChecksum(*Dirent) == LfnChecksum)) {

                ASSERT( Ordinal == 1);

                FoundValidLfn = TRUE;
                LongFileName->Length = (USHORT)(LfnSize * sizeof(WCHAR));

            } else {

                FoundValidLfn = FALSE;
            }

            //
            //  If we are supposed to match all entries, then match this entry.
            //

            if (FlagOn(Fobx->Flags, FOBX_FLAG_MATCH_ALL)) {

                break;
            }

            //
            //  Check against the short name given if one was.
            //

            if (TRUE){ //!FlagOn( Fobx->Flags, FOBX_FLAG_SKIP_SHORT_NAME_COMPARE )) {

                if (Fobx->ContainsWildCards) {

                    //
                    //  If we get one, note that all out parameters are already set.
                    //

                    (VOID)Rx8dot3ToString( RxContext, (*Dirent), FALSE, &Name );

                    //
                    //  For rx we special case the ".." dirent because we want it to
                    //  match ????????.??? and to do that we change ".." to "." before
                    //  calling the Fsrtl routine.  But only do this if the expression
                    //  is greater than one character long.
                    //

                    ASSERT(FALSE); //this shouldn't be called...get rid of it later joejoe
                    /*
                    if ((Name.Length == 2) &&
                        (Name.Buffer[0] == '.') &&
                        (Name.Buffer[1] == '.') &&
                        (Fobx->OemQueryTemplate.Wild.Length > 1)) {

                        Name.Length = 1;
                    }

                    if (RxIsNameInExpression( RxContext,
                                               Fobx->OemQueryTemplate.Wild,
                                               Name)) {

                        DebugTrace( 0, Dbg, "Entry found: Name = \"%wZ\"\n", &Name);
                        DebugTrace( 0, Dbg, "             VBO  = %08lx\n", *ByteOffset);

                        break;
                    }
                    */

                } else {

                    //
                    //  Do the quickest 8.3 equivalency check possible
                    //

                      ASSERT(FALSE); 
                   // if (!FlagOn((*Dirent)->Attributes, RDBSS_DIRENT_ATTR_VOLUME_ID) &&
                   //     (*(PULONG)&(Fobx->OemQueryTemplate.Constant[0]) == *(PULONG)&((*Dirent)->FileName[0])) &&
                   //     (*(PULONG)&(Fobx->OemQueryTemplate.Constant[4]) == *(PULONG)&((*Dirent)->FileName[4])) &&
                   //     (*(PUSHORT)&(Fobx->OemQueryTemplate.Constant[8]) == *(PUSHORT)&((*Dirent)->FileName[8])) &&
                   //     (*(PUCHAR)&(Fobx->OemQueryTemplate.Constant[10]) == *(PUCHAR)&((*Dirent)->FileName[10]))) {
                   //
                   //     DebugTrace( 0, Dbg, "Entry found.\n", 0);
                   //
                   //     break;
                   // }
                }
            }

            //
            //  No matches were found with the short name.  If an LFN exists,
            //  use it for the search.
            //

            if (FoundValidLfn) {

                //
                //  First do a quick check here for different sized constant
                //  name and expression before upcasing.
                //

                if (!Fobx->ContainsWildCards &&
                    Fobx->UnicodeQueryTemplate.Length != (USHORT)(LfnSize * sizeof(WCHAR))) {

                    //
                    //  Move on to the next dirent.
                    //

                    FoundValidLfn = FALSE;
                    LongFileName->Length = 0;

                    goto GetNextDirent;
                }

                //
                //  We need to upcase the name we found.
                //  We need a buffer.  Try to avoid doing an allocation.
                //

                if (LongFileName->Length <= 32*sizeof(WCHAR)) {

                    UpcasedLfn = &LocalUpcasedLfn;

                } else if (LongFileName->Length <= PoolUpcasedLfn.MaximumLength) {

                    UpcasedLfn = &PoolUpcasedLfn;

                } else {

                    //
                    //  Free the old buffer now, and get a new one.
                    //

                    if (PoolUpcasedLfn.Buffer) {

                        ExFreePool( PoolUpcasedLfn.Buffer );
                        PoolUpcasedLfn.Buffer = NULL;
                    }

                    PoolUpcasedLfn.Buffer =
                        FsRtlAllocatePool( PagedPool,
                                           LongFileName->Length );

                    PoolUpcasedLfn.MaximumLength = LongFileName->Length;

                    UpcasedLfn = &PoolUpcasedLfn;
                }

                Status = RtlUpcaseUnicodeString( UpcasedLfn,
                                                 LongFileName,
                                                 FALSE );

                if (!NT_SUCCESS(Status)) {

                    RxNormalizeAndRaiseStatus( RxContext, Status );
                }

                //
                //  OK, We are going to assume that the passed in UnicodeFileName
                //  has already been upcased.
                //

                if (Fobx->ContainsWildCards) {

                    if (FsRtlIsNameInExpression( &Fobx->UnicodeQueryTemplate,
                                                 UpcasedLfn,
                                                 TRUE,
                                                 NULL )) {
                        break;
                    }

                } else {

                    if (FsRtlAreNamesEqual( &Fobx->UnicodeQueryTemplate,
                                            UpcasedLfn,
                                            FALSE,
                                            NULL )) {
                        break;
                    }
                }

            }

            //
            //  This long name was not a match.  Zero out the Length field.
            //

            if (FoundValidLfn) {

                FoundValidLfn = FALSE;
                LongFileName->Length = 0;
            }

GetNextDirent:

            //
            //  Move on to the next dirent.
            //

            *ByteOffset += sizeof(DIRENT);
            *Dirent += 1;
        }

    } finally {

        if (PoolUpcasedLfn.Buffer != NULL) {

            ExFreePool( PoolUpcasedLfn.Buffer );
        }
    }

    DebugTrace(-1, Dbg, "RxLocateDirent -> (VOID)\n", 0);

    TimerStop(Dbg,"RxLocateDirent");

    return;
}


VOID
RxLocateSimpleOemDirent (
    IN PRX_CONTEXT RxContext,
    IN PDCB ParentDirectory,
    IN POEM_STRING FileName,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb,
    OUT PVBO ByteOffset
    )

/*++

Routine Description:

    This routine locates on the disk an undelted simple Oem dirent.  By simple
    I mean that FileName cannot contain any extended characters, and we do
    not search LFNs or return them.

Arguments:

    ParentDirectory - Supplies the DCB for the directory in which
        to search

    FileName - Supplies the filename to search for.  The name may contain
        wild cards

    OffsetToStartSearchFrom - Supplies the VBO within the parent directory
        from which to start looking for another real dirent.

    Dirent - Receives a pointer to the located dirent if one was found
        or NULL otherwise.

    Bcb - Receives the Bcb for the located dirent if one was found or
        NULL otherwise.

    ByteOffset - Receives the VBO within the Parent directory for
        the located dirent if one was found, or 0 otherwise.

Return Value:

    None.

--*/

{
    FOBX LocalFobx;

    PAGED_CODE();

    //
    //  Note, this routine is called rarely, so performance is not critical.
    //  Just fill in a Fobx structure on my stack with the values that are
    //  required.
    //
    ASSERT(FALSE); //this should never be called
//    RxStringTo8dot3( RxContext,
//                      *FileName,
//                      &LocalFobx.OemQueryTemplate.Constant );
    LocalFobx.ContainsWildCards = FALSE;
    LocalFobx.Flags = 0;

    RxLocateDirent( RxContext,
                     ParentDirectory,
                     &LocalFobx,
                     0,
                     Dirent,
                     Bcb,
                     ByteOffset,
                     NULL );

    return;
}


VOID
RxLocateVolumeLabel (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb,
    OUT PVBO ByteOffset
    )

/*++

Routine Description:

    This routine locates on the disk a dirent representing the volume
    label.  It does this by searching the root directory for a special
    volume label dirent.

Arguments:

    Vcb - Supplies the VCB for the volume to search

    Dirent - Receives a pointer to the located dirent if one was found
        or NULL otherwise.

    Bcb - Receives the Bcb for the located dirent if one was found or
        NULL otherwise.

    ByteOffset - Receives the VBO within the Parent directory for
        the located dirent if one was found, or 0 otherwise.

Return Value:

    None.

--*/

{
    RXSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "RxLocateVolumeLabel\n", 0);

    DebugTrace( 0, Dbg, "  Vcb        = %08lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Dirent     = %08lx\n", Dirent);
    DebugTrace( 0, Dbg, "  Bcb        = %08lx\n", Bcb);
    DebugTrace( 0, Dbg, "  ByteOffset = %08lx\n", ByteOffset);

    //
    //  The algorithm here is really simple.  We just walk through the
    //  root directory until we:
    //
    //      A)  Find the non-deleted volume label
    //      B)  Can't Wait
    //      C)  Hit the End of Directory
    //      D)  Hit Eof
    //
    //  In the first case we found it, in the latter three cases we did not.
    //

    *Bcb = NULL;
    *ByteOffset = 0;

    while ( TRUE ) {

        //
        //  Try to read in the dirent
        //

        RxReadDirent( RxContext,
                       Vcb->RootDcb,
                       *ByteOffset,
                       Bcb,
                       Dirent,
                       &Status );

        //
        //  If End Directory dirent or EOF, set all out parameters to
        //  indicate volume label not found and, like, bail.
        //
        //  Note that the order of evaluation here is important since we cannot
        //  check the first character of the dirent until after we know we
        //  are not beyond EOF
        //

        if ((Status == RxStatus(END_OF_FILE)) || ((*Dirent)->FileName[0] ==
                                                    RDBSS_DIRENT_NEVER_USED)) {

            DebugTrace( 0, Dbg, "Volume label not found.\n", 0);

            //
            //  If there is a Bcb, unpin it and set it to null
            //

            RxUnpinBcb( RxContext, *Bcb );

            *Dirent = NULL;
            *ByteOffset = 0;
            break;
        }

        //
        //  If the entry is the non-deleted volume label break from the loop.
        //
        //  Note that all out parameters are already correctly set.
        //

        if ((((*Dirent)->Attributes & ~RDBSS_DIRENT_ATTR_ARCHIVE) == RDBSS_DIRENT_ATTR_VOLUME_ID) &&
            ((*Dirent)->FileName[0] != RDBSS_DIRENT_DELETED)) {

            DebugTrace( 0, Dbg, "Volume label found at VBO = %08lx\n", *ByteOffset);

            //
            //  We may set this dirty, so pin it.
            //

            RxPinMappedData( RxContext,
                              Vcb->RootDcb,
                              *ByteOffset,
                              sizeof(DIRENT),
                              Bcb );

            break;
        }

        //
        //  Move on to the next dirent.
        //

        *ByteOffset += sizeof(DIRENT);
        *Dirent += 1;
    }


    DebugTrace(-1, Dbg, "RxLocateVolumeLabel -> (VOID)\n", 0);
    return;
}


VOID
RxGetDirentFromFcbOrDcb (
    IN PRX_CONTEXT RxContext,
    IN PFCB FcbOrDcb,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine reads locates on the disk the dirent denoted by the
    specified Fcb/Dcb.

Arguments:

    FcbOrDcb - Supplies the FCB/DCB for the file/directory whose dirent
        we are trying to read in.  This must not be the root dcb.

    Dirent - Receives a pointer to the dirent

    Bcb - Receives the Bcb for the dirent

Return Value:

    None.

--*/

{
    RXSTATUS DontCare;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "RxGetDirentFromFcbOrDcb\n", 0);

    DebugTrace( 0, Dbg, "  FcbOrDcb = %08lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  Dirent   = %08lx\n", Dirent);
    DebugTrace( 0, Dbg, "  Bcb      = %08lx\n", Bcb);

    //
    //  Assert that we are not attempting this on the root directory.
    //

    ASSERT( NodeType(FcbOrDcb) != RDBSS_NTC_ROOT_DCB );

    //
    //  We know the offset of the dirent within the directory file,
    //  so we just read it (with pinning).
    //

    RxReadDirectoryFile( RxContext,
                          FcbOrDcb->ParentDcb,
                          FcbOrDcb->DirentOffsetWithinDirectory,
                          sizeof(DIRENT),
                          TRUE,
                          Bcb,
                          (PVOID *)Dirent,
                          &DontCare );

    ASSERT( NT_SUCCESS( DontCare ));

    //
    //  We should never be accessing a deleted entry (except on removeable
    //  media where the dirent may have changed out from underneath us).
    //

    ASSERT( FlagOn( FcbOrDcb->Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) ?
            TRUE : (BOOLEAN)((*Dirent)->FileName[0] != RDBSS_DIRENT_DELETED ));

    DebugTrace(-1, Dbg, "RxGetDirentFromFcbOrDcb -> (VOID)\n", 0);
    return;
}


BOOLEAN
RxIsDirectoryEmpty (
    IN PRX_CONTEXT RxContext,
    IN PDCB Dcb
    )

/*++

Routine Description:

    This routine indicates to the caller if the specified directory
    is empty.  (i.e., it is not the root dcb and it only contains
    the "." and ".." entries, or deleted files).

Arguments:

    Dcb - Supplies the DCB for the directory being queried.

Return Value:

    BOOLEAN - Returns TRUE if the directory is empty and
        FALSE if the directory and is not empty.

--*/

{
    PBCB Bcb;
    ULONG ByteOffset;
    PDIRENT Dirent;

    BOOLEAN IsDirectoryEmpty;

    RXSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "RxIsDirectoryEmpty\n", 0);

    DebugTrace( 0, Dbg, "  Dcb              = %08lx\n", Dcb);
//    DebugTrace( 0, Dbg, "  IsDirectoryEmpty = %08lx\n", IsDirectoryEmpty);

    //
    //  Check to see if the first entry is an and of directory marker.
    //  For the root directory we check at Vbo = 0, for normal directories
    //  we check after the "." and ".." entries.
    //

    ByteOffset = (NodeType(Dcb) == RDBSS_NTC_ROOT_DCB) ? 0 : 2*sizeof(DIRENT);

    //
    //  We just march through the directory looking for anything other
    //  than deleted files, LFNs, an EOF, or end of directory marker.
    //

    Bcb = NULL;

    while ( TRUE ) {

        //
        //  Try to read in the dirent
        //

        RxReadDirent( RxContext,
                       Dcb,
                       ByteOffset,
                       &Bcb,
                       &Dirent,
                       &Status );

        //
        //  If End Directory dirent or EOF, set IsDirectoryEmpty to TRUE and,
        //  like, bail.
        //
        //  Note that the order of evaluation here is important since we cannot
        //  check the first character of the dirent until after we know we
        //  are not beyond EOF
        //

        if ((Status == RxStatus(END_OF_FILE)) ||
            (Dirent->FileName[0] == RDBSS_DIRENT_NEVER_USED)) {

            DebugTrace( 0, Dbg, "Empty.  Last exempt entry at VBO = %08lx\n", ByteOffset);

            IsDirectoryEmpty = TRUE;
            break;
        }

        //
        //  If this dirent is NOT deleted or an LFN set IsDirectoryEmpty to
        //  FALSE and, like, bail.
        //

        if ((Dirent->FileName[0] != RDBSS_DIRENT_DELETED) &&
            (Dirent->Attributes != RDBSS_DIRENT_ATTR_LFN)) {

            DebugTrace( 0, Dbg, "Not Empty.  First entry at VBO = %08lx\n", ByteOffset);

            IsDirectoryEmpty = FALSE;
            break;
        }

        //
        //  Move on to the next dirent.
        //

        ByteOffset += sizeof(DIRENT);
        Dirent += 1;
    }

    RxUnpinBcb( RxContext, Bcb );

    DebugTrace(-1, Dbg, "RxIsDirectoryEmpty -> %ld\n", IsDirectoryEmpty);

    return IsDirectoryEmpty;
}


VOID
RxConstructDirent (
    IN PRX_CONTEXT RxContext,
    IN OUT PDIRENT Dirent,
    IN POEM_STRING FileName,
    IN BOOLEAN ComponentReallyLowercase,
    IN BOOLEAN ExtensionReallyLowercase,
    IN PUNICODE_STRING Lfn OPTIONAL,
    IN UCHAR Attributes,
    IN BOOLEAN ZeroAndSetTimeFields
    )

/*++

Routine Description:

    This routine modifies the fields of a dirent.

Arguments:

    Dirent - Supplies the dirent being modified.

    FileName - Supplies the name to store in the Dirent.  This
        name must not contain wildcards.

    ComponentReallyLowercase - This boolean indicates that the User Specified
        compoent name was really all a-z and < 0x80 characters.  We set the
        magic bit in this case.

    ExtensionReallyLowercase - Same as above, but for the extension.

    Lfn - May supply a long file name.

    Attributes - Supplies the attributes to store in the dirent

    ZeroAndSetTimeFields - Tells whether or not to initially zero the dirent
        and update the time fields.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "RxConstructDirent\n", 0);

    DebugTrace( 0, Dbg, "  Dirent             = %08lx\n", Dirent);
    DebugTrace( 0, Dbg, "  FileName           = %wZ\n", FileName);
    DebugTrace( 0, Dbg, "  Attributes         = %08lx\n", Attributes);

    if (ZeroAndSetTimeFields) {

        RtlZeroMemory( Dirent, sizeof(DIRENT) );
    }

    //
    //  We just merrily go and fill up the dirent with the fields given.
    //

    RxStringTo8dot3( RxContext, *FileName, (PRDBSS8DOT3)&Dirent->FileName[0] );

    //
    //  Use the current time for all time fields.
    //

    if (ZeroAndSetTimeFields) {

        LARGE_INTEGER Time;

        KeQuerySystemTime( &Time );

        if (!RxNtTimeToRxTime( RxContext, Time, &Dirent->LastWriteTime )) {

            DebugTrace( 0, Dbg, "Current time invalid.\n", 0);

            RtlZeroMemory( &Dirent->LastWriteTime, sizeof(RDBSS_TIME_STAMP) );
            Time.LowPart = 0;
        }

        if (RxData.ChicagoMode) {

            Dirent->CreationTime = Dirent->LastWriteTime;
            Dirent->CreationMSec =
                (UCHAR)(((Time.LowPart + AlmostTenMSec) % TwoSeconds) / TenMSec);

            Dirent->LastAccessDate = Dirent->LastWriteTime.Date;
        }
    }

    //
    //  Copy the attributes
    //

    Dirent->Attributes = Attributes;

    //
    //  Set the magic bit here, to tell dirctrl.c that this name is really
    //  lowercase.
    //

    Dirent->NtByte = 0;

    if (ComponentReallyLowercase) {

        SetFlag( Dirent->NtByte, RDBSS_DIRENT_NT_BYTE_8_LOWER_CASE );
    }

    if (ExtensionReallyLowercase) {

        SetFlag( Dirent->NtByte, RDBSS_DIRENT_NT_BYTE_3_LOWER_CASE );
    }

    //
    //  See if we have to create an Lfn entry
    //

    if (ARGUMENT_PRESENT(Lfn)) {

        UCHAR DirentChecksum;
        UCHAR DirentsInLfn;
        UCHAR LfnOrdinal;
        PWCHAR LfnBuffer;
        PLFN_DIRENT LfnDirent;

        ASSERT( RxData.ChicagoMode );

        DirentChecksum = RxComputeLfnChecksum( Dirent );

        LfnOrdinal =
        DirentsInLfn = RDBSS_LFN_DIRENTS_NEEDED(Lfn);

        LfnBuffer = &Lfn->Buffer[(DirentsInLfn - 1) * 13];

        ASSERT( DirentsInLfn <= MAX_LFN_DIRENTS );

        for (LfnDirent = (PLFN_DIRENT)Dirent - DirentsInLfn;
             LfnDirent < (PLFN_DIRENT)Dirent;
             LfnDirent += 1, LfnOrdinal -= 1, LfnBuffer -= 13) {

            WCHAR FinalLfnBuffer[13];
            PWCHAR Buffer;

            //
            //  We need to special case the "final" dirent.
            //

            if (LfnOrdinal == DirentsInLfn) {

                ULONG i;
                ULONG RemainderChars;

                RemainderChars = (Lfn->Length / sizeof(WCHAR)) % 13;

                LfnDirent->Ordinal = LfnOrdinal | RDBSS_LAST_LONG_ENTRY;

                if (RemainderChars != 0) {

                    RtlCopyMemory( &FinalLfnBuffer,
                                   LfnBuffer,
                                   RemainderChars * sizeof(WCHAR) );

                    for (i = RemainderChars; i < 13; i++) {

                        //
                        //  Figure out which character to use.
                        //

                        if (i == RemainderChars) {

                            FinalLfnBuffer[i] = 0x0000;

                        } else {

                            FinalLfnBuffer[i] = 0xffff;
                        }
                    }

                    Buffer = FinalLfnBuffer;

                } else {

                    Buffer = LfnBuffer;
                }

            } else {

                LfnDirent->Ordinal = LfnOrdinal;

                Buffer = LfnBuffer;
            }

            //
            //  Now fill in the name.
            //

            RtlCopyMemory( &LfnDirent->Name1[0],
                           &Buffer[0],
                           5 * sizeof(WCHAR) );

            RtlCopyMemory( &LfnDirent->Name2[0],
                           &Buffer[5],
                           6 * sizeof(WCHAR) );

            RtlCopyMemory( &LfnDirent->Name3[0],
                           &Buffer[11],
                           2 * sizeof(WCHAR) );

            //
            //  And the other fields
            //

            LfnDirent->Attributes = RDBSS_DIRENT_ATTR_LFN;

            LfnDirent->Type = 0;

            LfnDirent->Checksum = DirentChecksum;

            LfnDirent->MustBeZero = 0;
        }
    }

    DebugTrace(-1, Dbg, "RxConstructDirent -> (VOID)\n", 0);
    return;
}


VOID
RxConstructLabelDirent (
    IN PRX_CONTEXT RxContext,
    IN OUT PDIRENT Dirent,
    IN POEM_STRING Label
    )

/*++

Routine Description:

    This routine modifies the fields of a dirent to be used for a label.

Arguments:

    Dirent - Supplies the dirent being modified.

    Label - Supplies the name to store in the Dirent.  This
            name must not contain wildcards.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "RxConstructLabelDirent\n", 0);

    DebugTrace( 0, Dbg, "  Dirent             = %08lx\n", Dirent);
    DebugTrace( 0, Dbg, "  Label              = %wZ\n", Label);

    RtlZeroMemory( Dirent, sizeof(DIRENT) );

    //
    //  We just merrily go and fill up the dirent with the fields given.
    //

    RtlCopyMemory( Dirent->FileName, Label->Buffer, Label->Length );

    //
    // Pad the label with spaces, not nulls.
    //

    RtlFillMemory( &Dirent->FileName[Label->Length], 11 - Label->Length, ' ');

    Dirent->LastWriteTime = RxGetCurrentRxTime( RxContext );

    Dirent->Attributes = RDBSS_DIRENT_ATTR_VOLUME_ID;
    Dirent->ExtendedAttributes = 0;
    Dirent->FileSize = 0;

    DebugTrace(-1, Dbg, "RxConstructLabelDirent -> (VOID)\n", 0);
    return;
}


VOID
RxSetFileSizeInDirent (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN PULONG AlternativeFileSize OPTIONAL
    )

/*++

Routine Description:

    This routine saves the file size in an fcb into its dirent.

Arguments:

    Fcb - Supplies the Fcb being referenced

    AlternativeFileSize - If non-null we use the ULONG it points to as
        the new file size.  Otherwise we use the one in the Fcb.

Return Value:

    None.

--*/

{
    PDIRENT Dirent;
    PBCB DirentBcb;

    PAGED_CODE();

    //****ASSERT( !FlagOn( Fcb->DirentRxFlags, RDBSS_DIRENT_ATTR_READ_ONLY ));

    RxGetDirentFromFcbOrDcb( RxContext,
                              Fcb,
                              &Dirent,
                              &DirentBcb );

    try {

        Dirent->FileSize = ARGUMENT_PRESENT( AlternativeFileSize ) ?
                           *AlternativeFileSize : Fcb->Header.FileSize.LowPart;

        RxSetDirtyBcb( RxContext, DirentBcb, Fcb->Vcb );

    } finally {

        RxUnpinBcb( RxContext, DirentBcb );
    }
}

//
//  Internal support routine
//

UCHAR
RxComputeLfnChecksum (
    PDIRENT Dirent
    )

/*++

Routine Description:

    This routine computes the Chicago long file name checksum.

Arguments:

    Dirent - Specifies the dirent that we are to compute a checksum for.

Return Value:

    The checksum.

--*/

{
    ULONG i;
    UCHAR Checksum;

    PAGED_CODE();

    Checksum = Dirent->FileName[0];

    for (i=1; i < 11; i++) {

        Checksum = ((Checksum & 1) ? 0x80 : 0) +
                    (Checksum >> 1) +
                    Dirent->FileName[i];
    }

    return Checksum;
}


//
//  Internal support routine
//

VOID
RxRescanDirectory (
    PRX_CONTEXT RxContext,
    PDCB Dcb
    )

/*++

Routine Description:

    This routine rescans the given directory, finding the first unused
    dirent, first deleted dirent, and setting the free dirent bitmap
    appropriately.

Arguments:

    Dcb - Supplies the directory to rescan.

Return Value:

    None.

--*/

{
    PBCB Bcb = NULL;
    PDIRENT Dirent;
    RXSTATUS Status;

    ULONG UnusedVbo;
    ULONG DeletedHint;
    ULONG DirentIndex;
    ULONG DirentsThisRun;
    ULONG StartIndexOfThisRun;

    enum RunType {
        InitialRun,
        FreeDirents,
        AllocatedDirents,
    } CurrentRun;

    PAGED_CODE();

    DebugTrace( 0, Dbg, "We must scan the whole directory.\n", 0);

    UnusedVbo = 0;
    DeletedHint = 0xffffffff;

    //
    //  To start with, we have to find out if the first dirent is free.
    //

    CurrentRun = InitialRun;
    DirentIndex =
    StartIndexOfThisRun = 0;

    while ( TRUE ) {

        BOOLEAN DirentDeleted;

        //
        //  Read a dirent
        //

        RxReadDirent( RxContext,
                       Dcb,
                       UnusedVbo,
                       &Bcb,
                       &Dirent,
                       &Status );

        //
        //  If EOF, or we found a NEVER_USED entry, we exit the loop
        //

        if ( (Status == RxStatus(END_OF_FILE) ) ||
             (Dirent->FileName[0] == RDBSS_DIRENT_NEVER_USED)) {

            break;
        }

        //
        //  If the dirent is DELETED, and it is the first one we found, set
        //  it in the deleted hint.
        //

        if (Dirent->FileName[0] == RDBSS_DIRENT_DELETED) {

            DirentDeleted = TRUE;

            if (DeletedHint == 0xffffffff) {

                DeletedHint = UnusedVbo;
            }

        } else {

            DirentDeleted = FALSE;
        }

        //
        //  Check for the first time through the loop, and determine
        //  the current run type.
        //

        if (CurrentRun == InitialRun) {

            CurrentRun = DirentDeleted ?
                         FreeDirents : AllocatedDirents;

        } else {

            //
            //  Are we switching from a free run to an allocated run?
            //

            if ((CurrentRun == FreeDirents) && !DirentDeleted) {

                DirentsThisRun = DirentIndex - StartIndexOfThisRun;

                RtlClearBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                              StartIndexOfThisRun,
                              DirentsThisRun );

                CurrentRun = AllocatedDirents;
                StartIndexOfThisRun = DirentIndex;
            }

            //
            //  Are we switching from an allocated run to a free run?
            //

            if ((CurrentRun == AllocatedDirents) && DirentDeleted) {

                DirentsThisRun = DirentIndex - StartIndexOfThisRun;

                RtlSetBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                            StartIndexOfThisRun,
                            DirentsThisRun );

                CurrentRun = FreeDirents;
                StartIndexOfThisRun = DirentIndex;
            }
        }

        //
        //  Move on to the next dirent.
        //

        UnusedVbo += sizeof(DIRENT);
        Dirent += 1;
        DirentIndex += 1;
    }

    //
    //  Now we have to record the final run we encoutered
    //

    DirentsThisRun = DirentIndex - StartIndexOfThisRun;

    if ((CurrentRun == FreeDirents) || (CurrentRun == InitialRun)) {

        RtlClearBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                      StartIndexOfThisRun,
                      DirentsThisRun );

    } else {

        RtlSetBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                    StartIndexOfThisRun,
                    DirentsThisRun );
    }

    //
    //  Now if there we bailed prematurely out of the loop because
    //  we hit an unused entry, set all the rest as free.
    //

    if (UnusedVbo < Dcb->Header.AllocationSize.LowPart) {

        StartIndexOfThisRun = UnusedVbo / sizeof(DIRENT);

        DirentsThisRun = (Dcb->Header.AllocationSize.LowPart -
                          UnusedVbo) / sizeof(DIRENT);

        RtlClearBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                      StartIndexOfThisRun,
                      DirentsThisRun);
    }

    //
    //  If there weren't any DELETED entries, set the index to our current
    //  position.
    //

    if (DeletedHint == 0xffffffff) { DeletedHint = UnusedVbo; }

    RxUnpinBcb( RxContext, Bcb );

    Dcb->Specific.Dcb.UnusedDirentVbo = UnusedVbo;
    Dcb->Specific.Dcb.DeletedDirentHint = DeletedHint;

    return;
}

//
//  Internal support routine
//

ULONG
RxDefragDirectory (
    IN PRX_CONTEXT RxContext,
    IN PDCB Dcb,
    IN ULONG DirentsNeeded
    )

/*++

Routine Description:

    This routine determines if the requested number of dirents can be found
    in the directory, looking for deleted dirents and orphaned LFNs.  If the
    request can be satisifed, orphaned LFNs are marked as deleted, and deleted
    dirents are all grouped together at the end of the directory.

    Note that this routine is currently used only on the root directory, but
    it is completely general and could be used on any directory.

Arguments:

    Dcb - Supplies the directory to defrag.

Return Value:

    The Index of the first dirent available for use, or -1 if the
    request cannot be satisfied.

--*/

{
    ULONG SavedRxContextFlag;
    PLIST_ENTRY Links;
    ULONG ReturnValue;
    PFCB Fcb;

    PBCB Bcb = NULL;
    PDIRENT Dirent = NULL;
    UNICODE_STRING Lfn = {0,0,NULL};

    MCB Mcb;
    BOOLEAN McbInitialized = FALSE;

    PUCHAR Directory;
    PUCHAR UnusedDirents;
    PUCHAR UnusedDirentBuffer = NULL;
    PUCHAR UsedDirents;
    PUCHAR UsedDirentBuffer = NULL;

    PBCB *Bcbs = NULL;
    ULONG Page;
    ULONG PagesPinned;

    ULONG DcbSize;
    ULONG TotalBytesAllocated = 0;

    PAGED_CODE();

    //
    //  We assume we own the Vcb.
    //

    ASSERT( RxVcbAcquiredExclusive(RxContext, Dcb->Vcb) );

    //
    //  We will only attempt this on directories less than 0x40000 bytes
    //  long (by default on DOS the root directory is only 0x2000 long).
    //  This is to avoid a cache manager complication.
    //

    DcbSize = Dcb->Header.AllocationSize.LowPart;

    if (DcbSize > 0x40000) {

        return (ULONG)-1;
    }

    //
    //  Force wait to TRUE
    //

    SavedRxContextFlag = RxContext->Flags;

    SetFlag( RxContext->Flags,
             RX_CONTEXT_FLAG_WAIT | RX_CONTEXT_FLAG_WRITE_THROUGH );

    //
    //  Now acquire all open Fcbs in the Dcb exclusive.
    //

    for (Links = Dcb->Specific.Dcb.ParentDcbQueue.Flink;
         Links != &Dcb->Specific.Dcb.ParentDcbQueue;
         Links = Links->Flink) {

        Fcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

        (VOID)ExAcquireResourceExclusive( Fcb->Header.Resource, TRUE );
    }

    try {

        FOBX Fobx;
        ULONG BytesUsed = 0;
        ULONG QueryOffset = 0;
        ULONG FoundOffset = 0;

        RXSTATUS DontCare;
        ULONG Run;
        ULONG TotalRuns;
        BOOLEAN Result;
        PUCHAR Char;

        //
        //  We are going to build a new, bitmap that will show all orphaned
        //  LFNs as well as deleted dirents as available.
        //
        //  Initialize our local FOBX that will match all files.
        //

        RtlZeroMemory( &Fobx, sizeof(FOBX) );
        Fobx.Flags = FOBX_FLAG_MATCH_ALL;

        //
        //  Init the Long File Name string.
        //

        Lfn.MaximumLength = 260 * sizeof(WCHAR);
        Lfn.Buffer = FsRtlAllocatePool( PagedPool, 260*sizeof(WCHAR) );

        //
        //  Initalize the Mcb.  We use this structure to keep track of runs
        //  of free and allocated dirents.  Runs are identity allocations, and
        //  holes are free dirents.
        //

        FsRtlInitializeMcb( &Mcb, PagedPool );

        McbInitialized = TRUE;

        do {

            RxLocateDirent( RxContext,
                             Dcb,
                             &Fobx,
                             QueryOffset,
                             &Dirent,
                             &Bcb,
                             &FoundOffset,
                             &Lfn );

            if (Dirent != NULL) {

                ULONG BytesUsed;
                ULONG LfnByteOffset;

                //
                //  Compute the LfnByteOffset.
                //

                LfnByteOffset = FoundOffset -
                                RDBSS_LFN_DIRENTS_NEEDED(&Lfn) * sizeof(LFN_DIRENT);

                BytesUsed = FoundOffset - LfnByteOffset + sizeof(DIRENT);

                //
                //  Set a run to represent all the dirent used for this
                //  file in the Dcb dir.  We add 0x40000 to the LBN so that
                //  it will always to non-zero and thus not confused with a
                //  hole.
                //

                Result = FsRtlAddMcbEntry( &Mcb,
                                           LfnByteOffset,
                                           LfnByteOffset + 0x40000,
                                           BytesUsed );

                ASSERT( Result );

                //
                //  Move on to the next dirent.
                //

                TotalBytesAllocated += BytesUsed;
                QueryOffset = FoundOffset + sizeof(DIRENT);
            }

        } while ((Dirent != NULL) && (QueryOffset < DcbSize));

        if (Bcb != NULL) {

            RxUnpinBcb( RxContext, Bcb );
        }

        //
        //  If we need more dirents than are available, bail.
        //

        if (DirentsNeeded > (DcbSize - TotalBytesAllocated)/sizeof(DIRENT)) {

            try_return(ReturnValue = (ULONG)-1);
        }

        //
        //  Now we are going to copy all the used and un-used parts of the
        //  directory to separate pool.
        //
        //  Allocate these buffers and pin the entire directory.
        //

        UnusedDirents =
        UnusedDirentBuffer = FsRtlAllocatePool( PagedPool,
                                                DcbSize - TotalBytesAllocated );

        UsedDirents =
        UsedDirentBuffer = FsRtlAllocatePool( PagedPool,
                                              TotalBytesAllocated );

        PagesPinned = (DcbSize + (PAGE_SIZE - 1 )) / PAGE_SIZE;

        Bcbs = FsRtlAllocatePool( PagedPool, PagesPinned * sizeof(PBCB) );

        RtlZeroMemory( Bcbs, PagesPinned * sizeof(PBCB) );

        for (Page = 0; Page < PagesPinned; Page += 1) {

            ULONG PinSize;

            //
            //  Don't try to pin beyond the Dcb size.
            //

            if ((Page + 1) * PAGE_SIZE > DcbSize) {

                PinSize = DcbSize - (Page * PAGE_SIZE);

            } else {

                PinSize = PAGE_SIZE;
            }

            RxPrepareWriteDirectoryFile( RxContext,
                                          Dcb,
                                          Page * PAGE_SIZE,
                                          PinSize,
                                          &Bcbs[Page],
                                          &Dirent,
                                          FALSE,
                                          &DontCare );

            if (Page == 0) {
                Directory = (PUCHAR)Dirent;
            }
        }

        TotalRuns = FsRtlNumberOfRunsInMcb( &Mcb );

        for (Run = 0; Run < TotalRuns; Run++) {

            VBO Vbo;
            LBO Lbo;

            Result = FsRtlGetNextMcbEntry( &Mcb,
                                           Run,
                                           &Vbo,
                                           &Lbo,
                                           &BytesUsed );

            ASSERT(Result);

            //
            //  Copy each run to their specific pool.
            //

            if (Lbo != 0) {

                RtlCopyMemory( UsedDirents,
                               Directory + Vbo,
                               BytesUsed );

                UsedDirents += BytesUsed;

            } else {

                RtlCopyMemory( UnusedDirents,
                               Directory + Vbo,
                               BytesUsed );

                UnusedDirents += BytesUsed;
            }
        }

        //
        //  Marking all the un-used dirents as "deleted".  This will reclaim
        //  storage used by orphaned LFNs.
        //

        for (Char = UnusedDirentBuffer; Char < UnusedDirents; Char += sizeof(DIRENT)) {

            *Char = RDBSS_DIRENT_DELETED;
        }

        //
        //  Now, for the permanent step.  Copy the two pool buffer back to the
        //  real Dcb directory, and flush the Dcb directory
        //

        ASSERT( TotalBytesAllocated == (ULONG)(UsedDirents - UsedDirentBuffer) );

        RtlCopyMemory( Directory, UsedDirentBuffer, TotalBytesAllocated );

        RtlCopyMemory( Directory + TotalBytesAllocated,
                       UnusedDirentBuffer,
                       UnusedDirents - UnusedDirentBuffer );

        //
        //  We need to unpin here so that the UnpinRepinned won't deadlock.
        //

        if (Bcbs) {
            for (Page = 0; Page < PagesPinned; Page += 1) {
                RxUnpinBcb( RxContext, Bcbs[Page] );
            }
            ExFreePool(Bcbs);
            Bcbs = NULL;
        }

        //
        //  Flush the directory to disk.
        //

        RxUnpinRepinnedBcbs( RxContext );

        //
        //  OK, now nothing can go wrong.  We have two more things to do.
        //  First, we have to fix up all the dirent offsets in any open Fcbs.
        //  If we cannot now find the Fcb, the file is marked invalid.  Also,
        //  we skip deleted files.
        //

        for (Links = Dcb->Specific.Dcb.ParentDcbQueue.Flink;
             Links != &Dcb->Specific.Dcb.ParentDcbQueue;
             Links = Links->Flink) {

            PBCB TmpBcb = NULL;
            ULONG TmpOffset;
            PDIRENT TmpDirent = NULL;
            ULONG PreviousLfnSpread;

            Fcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

            if (IsFileDeleted( RxContext, Fcb )) {

                continue;
            }

            RxLocateSimpleOemDirent( RxContext,
                                      Dcb,
                                      &Fcb->ShortName.Name.Oem,
                                      &TmpDirent,
                                      &TmpBcb,
                                      &TmpOffset );

            if (TmpBcb == NULL) {

                RxMarkFcbCondition( RxContext, Fcb, FcbBad );

            } else {

                RxUnpinBcb( RxContext, TmpBcb );

                PreviousLfnSpread = Fcb->DirentOffsetWithinDirectory -
                                    Fcb->LfnOffsetWithinDirectory;

                Fcb->DirentOffsetWithinDirectory = TmpOffset;
                Fcb->LfnOffsetWithinDirectory = TmpOffset - PreviousLfnSpread;
            }
        }

        //
        //  Now, finally, make the free dirent bitmap reflect the new
        //  state of the Dcb directory.
        //

        RtlSetBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                    0,
                    TotalBytesAllocated / sizeof(DIRENT) );

        RtlClearBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                      TotalBytesAllocated / sizeof(DIRENT),
                      (DcbSize - TotalBytesAllocated) / sizeof(DIRENT) );

        ReturnValue = TotalBytesAllocated / sizeof(DIRENT);

    try_exit: NOTHING;
    } finally {

        //
        //  Free all our resources and stuff.
        //

        if (McbInitialized) {
            FsRtlUninitializeMcb( &Mcb );
        }

        if (Lfn.Buffer) {
            ExFreePool( Lfn.Buffer );
        }

        if (UnusedDirentBuffer) {
            ExFreePool( UnusedDirentBuffer );
        }

        if (UsedDirentBuffer) {
            ExFreePool( UsedDirentBuffer );
        }

        if (Bcbs) {
            for (Page = 0; Page < PagesPinned; Page += 1) {
                RxUnpinBcb( RxContext, Bcbs[Page] );
            }
            ExFreePool(Bcbs);
        }

        for (Links = Dcb->Specific.Dcb.ParentDcbQueue.Flink;
             Links != &Dcb->Specific.Dcb.ParentDcbQueue;
             Links = Links->Flink) {

            Fcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

            ExReleaseResource( Fcb->Header.Resource );
        }

        RxContext->Flags = SavedRxContextFlag;
    }

    //
    //  Now return the offset of the first free dirent to the caller.
    //

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\acchksup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    AcChkSup.c

Abstract:

    This module implements the RDBSS access checking routine

Author:

    Gary Kimura     [GaryKi]    12-Jun-1989

Revision History:

--*/

//    ----------------------joejoe-----------found-------------#include "RxProcs.h"
#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_ACCHKSUP)

//
//  Our debug trace level
//

#define Dbg                              (DEBUG_TRACE_ACCHKSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCheckFileAccess)
#endif


BOOLEAN
RxCheckFileAccess (
    PRX_CONTEXT RxContext,
    IN UCHAR DirentAttributes,
    IN ULONG DesiredAccess
    )

/*++

Routine Description:

    This routine checks if a desired access is allowed to a file represented
    by the specified DirentAttriubutes.

Arguments:

    DirentAttributes - Supplies the Dirent attributes to check access for

    DesiredAccess - Supplies the desired access mask that we are checking for

Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise

--*/

{
    BOOLEAN Result;

    RxDbgTrace(+1, Dbg, ("RxCheckFileAccess\n", 0));
    RxDbgTrace( 0, Dbg, ("DirentAttributes = %8lx\n", DirentAttributes));
    RxDbgTrace( 0, Dbg, ("DesiredAccess    = %8lx\n", DesiredAccess));

    //
    //  This procedures is programmed like a string of filters each
    //  filter checks to see if some access is allowed,  if it is not allowed
    //  the filter return FALSE to the user without further checks otherwise
    //  it moves on to the next filter.  The filter check is to check for
    //  desired access flags that are not allowed for a particular dirent
    //

    Result = TRUE;

    try {

        //
        //  Check for Volume ID or Device Dirents, these are not allowed user
        //  access at all
        //

        if (FlagOn(DirentAttributes, RDBSS_DIRENT_ATTR_VOLUME_ID) ||
            FlagOn(DirentAttributes, RDBSS_DIRENT_ATTR_DEVICE)) {

            RxDbgTrace(0, Dbg, ("Cannot access volume id or device\n", 0));

            try_return( Result = FALSE );
        }

        //
        //  Check for a directory Dirent or non directory dirent
        //

        if (FlagOn(DirentAttributes, RDBSS_DIRENT_ATTR_DIRECTORY)) {

            //
            //  check the desired access for directory dirent
            //

            if (FlagOn(DesiredAccess, ~(DELETE |
                                        READ_CONTROL |
                                        WRITE_OWNER |
                                        WRITE_DAC |
                                        SYNCHRONIZE |
                                        ACCESS_SYSTEM_SECURITY |
                                        FILE_WRITE_DATA |
                                        FILE_READ_EA |
                                        FILE_WRITE_EA |
                                        FILE_READ_ATTRIBUTES |
                                        FILE_WRITE_ATTRIBUTES |
                                        FILE_LIST_DIRECTORY |
                                        FILE_TRAVERSE |
                                        FILE_DELETE_CHILD |
                                        FILE_APPEND_DATA))) {

                RxDbgTrace(0, Dbg, ("Cannot open directory\n", 0));

                try_return( Result = FALSE );
            }

        } else {

            //
            //  check the desired access for a non-directory dirent, we
            //  blackball
            //  FILE_LIST_DIRECTORY, FILE_ADD_FILE, FILE_TRAVERSE,
            //  FILE_ADD_SUBDIRECTORY, and FILE_DELETE_CHILD
            //

            if (FlagOn(DesiredAccess, ~(DELETE |
                                        READ_CONTROL |
                                        WRITE_OWNER |
                                        WRITE_DAC |
                                        SYNCHRONIZE |
                                        ACCESS_SYSTEM_SECURITY |
                                        FILE_READ_DATA |
                                        FILE_WRITE_DATA |
                                        FILE_READ_EA |
                                        FILE_WRITE_EA |
                                        FILE_READ_ATTRIBUTES |
                                        FILE_WRITE_ATTRIBUTES |
                                        FILE_EXECUTE |
                                        FILE_APPEND_DATA))) {

                RxDbgTrace(0, Dbg, ("Cannot open file\n", 0));

                try_return( Result = FALSE );
            }
        }

        //
        //  Check for a read-only Dirent
        //

        if (FlagOn(DirentAttributes, RDBSS_DIRENT_ATTR_READ_ONLY)) {

            //
            //  Check the desired access for a read-only dirent, we blackball
            //  WRITE, FILE_APPEND_DATA, FILE_ADD_FILE,
            //  FILE_ADD_SUBDIRECTORY, and FILE_DELETE_CHILD
            //

            if (FlagOn(DesiredAccess, ~(DELETE |
                                        READ_CONTROL |
                                        WRITE_OWNER |
                                        WRITE_DAC |
                                        SYNCHRONIZE |
                                        ACCESS_SYSTEM_SECURITY |
                                        FILE_READ_DATA |
                                        FILE_READ_EA |
                                        FILE_WRITE_EA |
                                        FILE_READ_ATTRIBUTES |
                                        FILE_WRITE_ATTRIBUTES |
                                        FILE_EXECUTE |
                                        FILE_LIST_DIRECTORY |
                                        FILE_TRAVERSE))) {

                RxDbgTrace(0, Dbg, ("Cannot open readonly\n", 0));

                try_return( Result = FALSE );
            }
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( RxCheckFileAccess );

        RxDbgTrace(-1, Dbg, ("RxCheckFileAccess -> %08lx\n", Result));
    }

    UNREFERENCED_PARAMETER( RxContext );

    return Result;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\dumpsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DumpSup.c

Abstract:

    This module implements a collection of data structure dump routines
    for debugging the Rx file system

Author:

    Gary Kimura     [GaryKi]    18-Jan-1990

Revision History:

--*/

//    ----------------------joejoe-----------found-------------#include "RxProcs.h"
#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_DUMPSUP)

//
//  The local debug trace level
//

#define Dbg                              (yaya)


#ifdef RDBSSDBG

VOID RxDump(IN PVOID Ptr);

VOID RxDumpDataHeader();
VOID RxDumpVcb(IN PVCB Ptr);
VOID RxDumpFcb(IN PFCB Ptr);
VOID RxDumpFobx(IN PFOBX Ptr);

ULONG RxDumpCurrentColumn;

#define DumpNewLine() {       \
    DbgPrint("\n");            \
    RxDumpCurrentColumn = 1; \
}

#define DumpLabel(Label,Width) {                                          \
    ULONG i, LastPeriod=0;                                                \
    CHAR _Str[20];                                                        \
    for(i=0;i<2;i++) { _Str[i] = UCHAR_SP;}                               \
    for(i=0;i<strlen(#Label);i++) {if (#Label[i] == '.') LastPeriod = i;} \
    strncpy(&_Str[2],&#Label[LastPeriod],Width);                          \
    for(i=strlen(_Str);i<Width;i++) {_Str[i] = UCHAR_SP;}                 \
    _Str[Width] = '\0';                                                   \
    DbgPrint("%s", _Str);                                                  \
}

#define DumpField(Field) {                                         \
    if ((RxDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    RxDumpCurrentColumn += 18 + 9 + 9;                            \
    DumpLabel(Field,18);                                           \
    DbgPrint(":%8lx", Ptr->Field);                                  \
    DbgPrint("         ");                                          \
}

#define DumpListEntry(Links) {                                     \
    if ((RxDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    RxDumpCurrentColumn += 18 + 9 + 9;                            \
    DumpLabel(Links,18);                                           \
    DbgPrint(":%8lx", Ptr->Links.Flink);                            \
    DbgPrint(":%8lx", Ptr->Links.Blink);                            \
}

#define DumpName(Field,Width) {                                    \
    ULONG i;                                                       \
    CHAR _String[256];                                             \
    if ((RxDumpCurrentColumn + 18 + Width) > 80) {DumpNewLine();} \
    RxDumpCurrentColumn += 18 + Width;                            \
    DumpLabel(Field,18);                                           \
    for(i=0;i<Width;i++) {_String[i] = (CHAR) Ptr->Field[i];}             \
    _String[Width] = '\0';                                         \
    DbgPrint("%s", _String);                                        \
}

#define TestForNull(Name) {                                 \
    if (Ptr == NULL) {                                      \
        DbgPrint("%s - Cannot dump a NULL pointer\n", Name); \
        return;                                             \
    }                                                       \
}


VOID
RxDump (
    IN PVOID Ptr
    )

/*++

Routine Description:

    This routine determines the type of internal record reference by ptr and
    calls the appropriate dump routine.

Arguments:

    Ptr - Supplies the pointer to the record to be dumped

Return Value:

    None

--*/

{
    TestForNull("RxDump");

    switch (NodeType(Ptr)) {

    case RDBSS_NTC_DATA_HEADER:

        RxDumpDataHeader();
        break;

    case RDBSS_NTC_VCB:

        RxDumpVcb(Ptr);
        break;

    case RDBSS_NTC_FCB:
    case RDBSS_NTC_DCB:
    case RDBSS_NTC_ROOT_DCB:

        RxDumpFcb(Ptr);
        break;

    case RDBSS_NTC_FOBX:

        RxDumpFobx(Ptr);
        break;

    default :

        DbgPrint("RxDump - Unknown Node type code %8lx\n", *((PNODE_TYPE_CODE)(Ptr)));
        break;
    }

    return;
}


VOID
RxDumpDataHeader (
    )

/*++

Routine Description:

    Dump the top data structures and all Device structures

Arguments:

    None

Return Value:

    None

--*/

{
    PRDBSS_DATA Ptr;
    PLIST_ENTRY Links;

    Ptr = &RxData;

    TestForNull("RxDumpDataHeader");

    DumpNewLine();
    DbgPrint("RxData@ %lx", (Ptr));
    DumpNewLine();

    DumpField           (NodeTypeCode);
    DumpField           (NodeByteSize);
    DumpListEntry       (VcbQueue);
    DumpField           (DriverObject);
    DumpField           (OurProcess);
    DumpNewLine();

    for (Links = Ptr->VcbQueue.Flink;
         Links != &Ptr->VcbQueue;
         Links = Links->Flink) {

        RxDumpVcb(CONTAINING_RECORD(Links, VCB, VcbLinks));
    }

    return;
}


VOID
RxDumpVcb (
    IN PVCB Ptr
    )

/*++

Routine Description:

    Dump an Device structure, its Fcb queue amd direct access queue.

Arguments:

    Ptr - Supplies the Device record to be dumped

Return Value:

    None

--*/

{
    TestForNull("RxDumpVcb");

    DumpNewLine();
    DbgPrint("Vcb@ %lx", (Ptr));
    DumpNewLine();

    DumpField           (NodeTypeCode);
    DumpField           (NodeByteSize);
    DumpListEntry       (VcbLinks);
    DumpField           (TargetDeviceObject);
    DumpField           (Vpb);
    DumpField           (VcbState);
    DumpField           (VcbCondition);
    DumpField           (RootDcb);
    DumpField           (DirectAccessOpenCount);
    DumpField           (OpenFileCount);
    DumpField           (ReadOnlyCount);
    DumpField           (AllocationSupport);
    DumpField           (AllocationSupport.RootDirectoryLbo);
    DumpField           (AllocationSupport.RootDirectorySize);
    DumpField           (AllocationSupport.FileAreaLbo);
    DumpField           (AllocationSupport.NumberOfClusters);
    DumpField           (AllocationSupport.NumberOfFreeClusters);
    DumpField           (AllocationSupport.RxIndexBitSize);
    DumpField           (AllocationSupport.LogOfBytesPerSector);
    DumpField           (AllocationSupport.LogOfBytesPerCluster);
    DumpField           (DirtyRxMcb);
    DumpField           (FreeClusterBitMap);
    DumpField           (VirtualVolumeFile);
    DumpField           (SectionObjectPointers.DataSectionObject);
    DumpField           (SectionObjectPointers.SharedCacheMap);
    DumpField           (SectionObjectPointers.ImageSectionObject);
    DumpField           (ClusterHint);
    DumpNewLine();

    RxDumpFcb(Ptr->RootDcb);

    return;
}


VOID
RxDumpFcb (
    IN PFCB Ptr
    )

/*++

Routine Description:

    Dump an Fcb structure, its various queues

Arguments:

    Ptr - Supplies the Fcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;

    TestForNull("RxDumpFcb");

    DumpNewLine();
    if      (NodeType(Ptr) == RDBSS_NTC_FCB)      {DbgPrint("Fcb@ %lx", (Ptr));}
    else if (NodeType(Ptr) == RDBSS_NTC_DCB)      {DbgPrint("Dcb@ %lx", (Ptr));}
    else if (NodeType(Ptr) == RDBSS_NTC_ROOT_DCB) {DbgPrint("RootDcb@ %lx", (Ptr));}
    else {DbgPrint("NonFcb NodeType @ %lx", (Ptr));}
    DumpNewLine();

    DumpField           (Header.NodeTypeCode);
    DumpField           (Header.NodeByteSize);
    DumpListEntry       (ParentDcbLinks);
    DumpField           (ParentDcb);
    DumpField           (Vcb);
    DumpField           (FcbState);
    DumpField           (FcbCondition);
    DumpField           (UncleanCount);
    DumpField           (OpenCount);
    DumpField           (DirentOffsetWithinDirectory);
    DumpField           (DirentRxFlags);
    DumpField           (FullFileName.Length);
    DumpField           (FullFileName.Buffer);
    DumpName            (FullFileName.Buffer, 32);
    DumpField           (ShortName.Name.Oem.Length);
    DumpField           (ShortName.Name.Oem.Buffer);
//    DumpField           (NonPagedFcb);
    DumpField           (NonPaged);
    DumpField           (Header.AllocationSize.LowPart);
    DumpField           (NonPaged->SectionObjectPointers.DataSectionObject);
    DumpField           (NonPaged->SectionObjectPointers.SharedCacheMap);
    DumpField           (NonPaged->SectionObjectPointers.ImageSectionObject);

    if ((Ptr->Header.NodeTypeCode == RDBSS_NTC_DCB) ||
        (Ptr->Header.NodeTypeCode == RDBSS_NTC_ROOT_DCB)) {

        DumpListEntry   (Specific.Dcb.ParentDcbQueue);
        DumpField       (Specific.Dcb.DirectoryFileOpenCount);
        DumpField       (Specific.Dcb.DirectoryFile);

    } else if (Ptr->Header.NodeTypeCode == RDBSS_NTC_FCB) {

        DumpField       (Header.FileSize.LowPart);

    } else {

        DumpNewLine();
        DbgPrint("Illegal Node type code");

    }
    DumpNewLine();

    if ((Ptr->Header.NodeTypeCode == RDBSS_NTC_DCB) ||
        (Ptr->Header.NodeTypeCode == RDBSS_NTC_ROOT_DCB)) {

        for (Links = Ptr->Specific.Dcb.ParentDcbQueue.Flink;
             Links != &Ptr->Specific.Dcb.ParentDcbQueue;
             Links = Links->Flink) {

            RxDumpFcb(CONTAINING_RECORD(Links, FCB, ParentDcbLinks));
        }
    }

    return;
}


VOID
RxDumpFobx (
    IN PFOBX Ptr
    )

/*++

Routine Description:

    Dump a Fobx structure

Arguments:

    Ptr - Supplies the Fobx record to be dumped

Return Value:

    None

--*/

{
    TestForNull("RxDumpFobx");

    DumpNewLine();
    DbgPrint("Fobx@ %lx", (Ptr));
    DumpNewLine();

    DumpField           (NodeTypeCode);
    DumpField           (NodeByteSize);
    DumpField           (UnicodeQueryTemplate.Length);
    DumpName            (UnicodeQueryTemplate.Buffer, 32);
    DumpNewLine();

    return;
}

#endif // RDBSSDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\easup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    EaSup.c

Abstract:

    This module implements the cluster operations on the EA file for Rx.

Author:

    Brian Andrew    [BrianAn]       07-Nov-1990

--*/

//    ----------------------joejoe-----------found-------------#include "RxProcs.h"
#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_EASUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxAddEaSet)
#pragma alloc_text(PAGE, RxAppendPackedEa)
#pragma alloc_text(PAGE, RxCreateEa)
#pragma alloc_text(PAGE, RxDeleteEa)
#pragma alloc_text(PAGE, RxDeleteEaSet)
#pragma alloc_text(PAGE, RxDeletePackedEa)
#pragma alloc_text(PAGE, RxGetEaFile)
#pragma alloc_text(PAGE, RxGetEaLength)
#pragma alloc_text(PAGE, RxGetNeedEaCount)
#pragma alloc_text(PAGE, RxIsEaNameValid)
#pragma alloc_text(PAGE, RxLocateEaByName)
#pragma alloc_text(PAGE, RxLocateNextEa)
#pragma alloc_text(PAGE, RxReadEaSet)
#pragma alloc_text(PAGE, RxPinEaRange)
#pragma alloc_text(PAGE, RxMarkEaRangeDirty)
#pragma alloc_text(PAGE, RxUnpinEaRange)
#endif

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))

//
//  Any access to the Ea file must recognize when a section boundary is being
//  crossed.
//

#define EA_SECTION_SIZE             (0x00040000)


VOID
RxGetEaLength (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PDIRENT Dirent,
    OUT PULONG EaLength
    )

/*++

Routine Description:

    This routine looks up the Ea length for the Eas of the file.  This
    length is the  length of the packed eas, including the 4 bytes which
    contain the Ea length.

    This routine pins down the Ea set for the desired file and copies
    this field from the Ea set header.

Arguments:

    Vcb - Vcb for the volume containing the Eas.

    Dirent - Supplies a pointer to the dirent for the file in question.

    EaLength - Supplies the address to store the length of the Eas.

Return Value:

    None

--*/

{
    PBCB EaBcb;
    BOOLEAN LockedEaFcb;
    EA_RANGE EaSetRange;

    DebugTrace(+1, Dbg, "RxGetEaLength ...\n", 0);

    //
    //  If the handle is 0 then the Ea length is 0.
    //

    if (Dirent->ExtendedAttributes == 0) {

        *EaLength = 0;
        DebugTrace(-1, Dbg, "RxGetEaLength -> %08lx\n", TRUE);
        return;
    }

    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    //
    //  Use a try to facilitate cleanup.
    //

    try {

        PDIRENT EaDirent;
        OEM_STRING ThisFilename;
        UCHAR Buffer[12];
        PEA_SET_HEADER EaSetHeader;

        //
        //  Initial the local values.
        //

        EaBcb = NULL;
        LockedEaFcb = FALSE;

        //
        //  Try to get the Ea file object.  Return FALSE on failure.
        //

        RxGetEaFile( RxContext,
                      Vcb,
                      &EaDirent,
                      &EaBcb,
                      FALSE,
                      FALSE );

        LockedEaFcb = TRUE;

        //
        //  If we didn't get the file because it doesn't exist, then the
        //  disk is corrupted.
        //

        if (Vcb->VirtualEaFile == NULL) {

            DebugTrace(0, Dbg, "RxGetEaLength:  Ea file doesn't exist\n", 0);
            RxRaiseStatus( RxContext, RxStatus(NO_EAS_ON_FILE) );
        }

        //
        //  Try to pin down the Ea set header for the index in the
        //  dirent.  If the operation doesn't complete, return FALSE
        //  from this routine.
        //

        ThisFilename.Buffer = Buffer;
        Rx8dot3ToString( RxContext, Dirent, FALSE, &ThisFilename );

        RxReadEaSet( RxContext,
                      Vcb,
                      Dirent->ExtendedAttributes,
                      &ThisFilename,
                      FALSE,
                      &EaSetRange );

        EaSetHeader = (PEA_SET_HEADER) EaSetRange.Data;

        //
        //  We now have the Ea set header for this file.  We simply copy
        //  the Ea length field.
        //

        CopyUchar4( EaLength, EaSetHeader->cbList );
        DebugTrace(0, Dbg, "RxGetEaLength:  Length of Ea is -> %08lx\n",
                   *EaLength);

    } finally {

        DebugUnwind( RxGetEaLength );

        //
        //  Unpin the EaDirent and the EaSetHeader if pinned.
        //

        RxUnpinBcb( RxContext, EaBcb );

        RxUnpinEaRange( RxContext, &EaSetRange );

        //
        //  Release the Fcb for the Ea file if locked.
        //

        if (LockedEaFcb) {

            RxReleaseFcb( RxContext, Vcb->EaFcb );
        }

        DebugTrace(-1, Dbg, "RxGetEaLength:  Ea length -> %08lx\n", *EaLength);
    }

    return;
}


VOID
RxGetNeedEaCount (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PDIRENT Dirent,
    OUT PULONG NeedEaCount
    )

/*++

Routine Description:

    This routine looks up the Need Ea count for the file.  The value is the
    in the ea header for the file.

Arguments:

    Vcb - Vcb for the volume containing the Eas.

    Dirent - Supplies a pointer to the dirent for the file in question.

    NeedEaCount - Supplies the address to store the Need Ea count.

Return Value:

    None

--*/

{
    PBCB EaBcb;
    BOOLEAN LockedEaFcb;
    EA_RANGE EaSetRange;

    DebugTrace(+1, Dbg, "RxGetNeedEaCount ...\n", 0);

    //
    //  If the handle is 0 then the Need Ea count is 0.
    //

    if (Dirent->ExtendedAttributes == 0) {

        *NeedEaCount = 0;
        DebugTrace(-1, Dbg, "RxGetNeedEaCount -> %08lx\n", TRUE);
        return;
    }

    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    //
    //  Use a try to facilitate cleanup.
    //

    try {

        PDIRENT EaDirent;
        OEM_STRING ThisFilename;
        UCHAR Buffer[12];
        PEA_SET_HEADER EaSetHeader;

        //
        //  Initial the local values.
        //

        EaBcb = NULL;
        LockedEaFcb = FALSE;

        //
        //  Try to get the Ea file object.  Return FALSE on failure.
        //

        RxGetEaFile( RxContext,
                      Vcb,
                      &EaDirent,
                      &EaBcb,
                      FALSE,
                      FALSE );

        LockedEaFcb = TRUE;

        //
        //  If we didn't get the file because it doesn't exist, then the
        //  disk is corrupted.
        //

        if (Vcb->VirtualEaFile == NULL) {

            DebugTrace(0, Dbg, "RxGetNeedEaCount:  Ea file doesn't exist\n", 0);
            RxRaiseStatus( RxContext, RxStatus(NO_EAS_ON_FILE) );
        }

        //
        //  Try to pin down the Ea set header for the index in the
        //  dirent.  If the operation doesn't complete, return FALSE
        //  from this routine.
        //

        ThisFilename.Buffer = Buffer;
        Rx8dot3ToString( RxContext, Dirent, FALSE, &ThisFilename );

        RxReadEaSet( RxContext,
                      Vcb,
                      Dirent->ExtendedAttributes,
                      &ThisFilename,
                      FALSE,
                      &EaSetRange );

        EaSetHeader = (PEA_SET_HEADER) EaSetRange.Data;

        //
        //  We now have the Ea set header for this file.  We simply copy
        //  the Need Ea field.
        //

        *NeedEaCount = EaSetHeader->NeedEaCount;

    } finally {

        DebugUnwind( RxGetNeedEaCount );

        //
        //  Unpin the EaDirent and the EaSetHeader if pinned.
        //

        RxUnpinBcb( RxContext, EaBcb );

        RxUnpinEaRange( RxContext, &EaSetRange );

        //
        //  Release the Fcb for the Ea file if locked.
        //

        if (LockedEaFcb) {

            RxReleaseFcb( RxContext, Vcb->EaFcb );
        }

        DebugTrace(-1, Dbg, "RxGetNeedEaCount:  NeedEaCount -> %08lx\n", *NeedEaCount);
    }

    return;
}


VOID
RxCreateEa (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PUCHAR Buffer,
    IN ULONG Length,
    IN POEM_STRING FileName,
    OUT PUSHORT EaHandle
    )

/*++

Routine Description:

    This routine adds an entire ea set to the Ea file.  The owning file
    is specified in 'FileName'.  This is used to replace the Ea set attached
    to an existing file during a supersede operation.

    NOTE: This routine may block, it should not be called unless the
    thread is waitable.

Arguments:

    Vcb - Supplies the Vcb for the volume.

    Buffer - Buffer with the Ea list to add.

    Length - Length of the buffer.

    FileName - The Ea's will be attached to this file.

    EaHandle - The new ea handle will be assigned to this address.

Return Value:

    None

--*/

{
    RxCaptureRequestPacket;
    PBCB EaBcb;
    BOOLEAN LockedEaFcb;

    PEA_SET_HEADER EaSetHeader;
    EA_RANGE EaSetRange;

    DebugTrace(+1, Dbg, "RxCreateEa...\n", 0);

    EaBcb = NULL;
    LockedEaFcb = FALSE;

    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    //
    //  Use 'try' to facilitate cleanup.
    //

    try {

        PDIRENT EaDirent;

        PPACKED_EA FirstPackedEa;
        ULONG PackedEasLength;
        ULONG AllocationLength;
        ULONG BytesPerCluster;

        PFILE_FULL_EA_INFORMATION FullEa;

        //
        //  We will allocate a buffer and copy the Ea list from the user's
        //  buffer to a RDBSS packed Ea list.  Initial allocation is one
        //  cluster, our starting offset into the packed Ea list is 0.
        //

        PackedEasLength = 0;

        BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

        AllocationLength = (PackedEasLength
                            + SIZE_OF_EA_SET_HEADER
                            + BytesPerCluster - 1)
                           & ~(BytesPerCluster - 1);

        //
        //  Allocate the memory and store the file name into it.
        //

        EaSetHeader = FsRtlAllocatePool( PagedPool, AllocationLength );

        RtlZeroMemory( EaSetHeader, AllocationLength );

        RtlCopyMemory( EaSetHeader->OwnerFileName,
                       FileName->Buffer,
                       FileName->Length );

        AllocationLength -= SIZE_OF_EA_SET_HEADER;

        FirstPackedEa = (PPACKED_EA) EaSetHeader->PackedEas;

        //
        //  Loop through the user's Ea list.  Catch any error for invalid
        //  name or non-existent Ea value.
        //

        for ( FullEa = (PFILE_FULL_EA_INFORMATION) Buffer;
              FullEa < (PFILE_FULL_EA_INFORMATION) &Buffer[Length];
              FullEa = (PFILE_FULL_EA_INFORMATION) (FullEa->NextEntryOffset == 0 ?
                                   &Buffer[Length] :
                                   (PUCHAR) FullEa + FullEa->NextEntryOffset)) {

            OEM_STRING EaName;
            ULONG EaOffset;

            EaName.Length = FullEa->EaNameLength;
            EaName.Buffer = &FullEa->EaName[0];

            //
            //  Make sure the ea name is valid
            //

            if (!RxIsEaNameValid( RxContext, EaName )) {

                DebugTrace(0, Dbg,
                           "RxCreateEa:  Invalid Ea Name -> %wZ\n",
                           EaName);

                capReqPacket->IoStatus.Information = (PUCHAR)FullEa - Buffer;
                capReqPacket->IoStatus.Status = RxStatus(INVALID_EA_NAME);
                RxRaiseStatus( RxContext, RxStatus(INVALID_EA_NAME) );
            }

            //
            //  Check that no invalid ea flags are set.
            //

            //
            //  TEMPCODE  We are returning RxStatus(INVALID_EA_NAME)
            //  until a more appropriate error code exists.
            //

            if (FullEa->Flags != 0
                && FullEa->Flags != FILE_NEED_EA) {

                capReqPacket->IoStatus.Information = (PUCHAR)FullEa - Buffer;
                capReqPacket->IoStatus.Status = RxStatus(INVALID_EA_NAME);
                RxRaiseStatus( RxContext, RxStatus(INVALID_EA_NAME) );
            }

            //
            //  If this is a duplicate name then delete the current ea
            //  value.
            //

            if (RxLocateEaByName( RxContext,
                                   FirstPackedEa,
                                   PackedEasLength,
                                   &EaName,
                                   &EaOffset )) {

                DebugTrace(0, Dbg, "RxCreateEa:  Duplicate name found\n", 0);

                RxDeletePackedEa( RxContext,
                                   EaSetHeader,
                                   &PackedEasLength,
                                   EaOffset );
            }

            //
            //  We ignore this value if the eavalue length is zero.
            //

            if (FullEa->EaValueLength == 0) {

                DebugTrace(0, Dbg,
                           "RxCreateEa:  Empty ea\n",
                           0);

                continue;
            }

            RxAppendPackedEa( RxContext,
                               &EaSetHeader,
                               &PackedEasLength,
                               &AllocationLength,
                               FullEa,
                               BytesPerCluster );
        }

        //
        //  If the resulting length isn't zero, then allocate a RDBSS cluster
        //  to store the data.
        //

        if (PackedEasLength != 0) {

            PEA_SET_HEADER NewEaSetHeader;

            //
            //  If the packed eas length (plus 4 bytes) is greater
            //  than the maximum allowed ea size, we return an error.
            //

            if (PackedEasLength + 4 > MAXIMUM_EA_SIZE) {

                DebugTrace( 0, Dbg, "Ea length is greater than maximum\n", 0 );

                RxRaiseStatus( RxContext, RxStatus(EA_TOO_LARGE) );
            }

            //
            //  Get the Ea file.
            //

            RxGetEaFile( RxContext,
                          Vcb,
                          &EaDirent,
                          &EaBcb,
                          TRUE,
                          TRUE );

            LockedEaFcb = TRUE;

            RxAddEaSet( RxContext,
                         Vcb,
                         PackedEasLength + SIZE_OF_EA_SET_HEADER,
                         EaBcb,
                         EaDirent,
                         EaHandle,
                         &EaSetRange );

            NewEaSetHeader = (PEA_SET_HEADER) EaSetRange.Data;

            //
            //  Store the length of the new Ea's into the NewEaSetHeader.
            //  This is the PackedEasLength + 4.
            //

            PackedEasLength += 4;

            CopyU4char( EaSetHeader->cbList, &PackedEasLength );

            //
            //  Copy all but the first four bytes of EaSetHeader into
            //  the new ea.  The signature and index fields have
            //  already been filled in.
            //

            RtlCopyMemory( &NewEaSetHeader->NeedEaCount,
                           &EaSetHeader->NeedEaCount,
                           PackedEasLength + SIZE_OF_EA_SET_HEADER - 8 );

            RxMarkEaRangeDirty( RxContext, Vcb->VirtualEaFile, &EaSetRange );
            RxUnpinEaRange( RxContext, &EaSetRange );

            CcFlushCache( Vcb->VirtualEaFile->SectionObjectPointer, NULL, 0, NULL );

        //
        //  There was no data added to the Ea file.  Return a handle
        //  of 0.
        //

        } else {

            *EaHandle = 0;
        }

    } finally {

        DebugUnwind( RxCreateEa );

        //
        //  Deallocate the EaSetHeader if present.
        //

        if (EaSetHeader) {

            ExFreePool( EaSetHeader );
        }

        //
        //  Release the EaFcb if held.
        //

        if (LockedEaFcb) {

            RxReleaseFcb( RxContext, Vcb->EaFcb );
        }

        //
        //  Unpin the dirents for the EaFcb and EaSetFcb if necessary.
        //

        RxUnpinBcb( RxContext, EaBcb );
        RxUnpinEaRange( RxContext, &EaSetRange );

        DebugTrace(-1, Dbg, "RxCreateEa -> Exit\n", 0);
    }

    return;
}

VOID
RxDeleteEa (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN USHORT EaHandle,
    IN POEM_STRING FileName
    )

/*++

Routine Description:

    This routine is called to remove an entire ea set.  Most of the work
    is done in the call to 'RxDeleteEaSet'.  This routine opens the
    Ea file and then calls the support routine.

    NOTE: This routine may block, it should not be called unless the
    thread is waitable.

Arguments:

    Vcb - Vcb for the volume

    EaHandle - The handle for the Ea's to remove.  This handle will be
               verified during this operation.

    FileName - The name of the file whose Ea's are being removed.  This
               name is compared against the Ea owner's name in the Ea set.

Return Value:

    None.

--*/

{
    PBCB EaBcb;
    BOOLEAN LockedEaFcb;

    DebugTrace(+1, Dbg, "RxDeleteEa...\n", 0);

    //
    //  Initialize local values.
    //

    EaBcb = NULL;
    LockedEaFcb = FALSE;

    //
    //  Use a try statement to facilitate cleanup.
    //

    try {

        PDIRENT EaDirent;

        //
        //  Get the Ea stream file.  If the file doesn't exist on the disk
        //  then the disk has been corrupted.
        //

        RxGetEaFile( RxContext,
                      Vcb,
                      &EaDirent,
                      &EaBcb,
                      FALSE,
                      TRUE );

        LockedEaFcb = TRUE;

        //
        //  If we didn't get the Ea file, then the disk is corrupt.
        //

        if ( EaBcb == NULL ) {


            DebugTrace(0, Dbg,
                       "RxDeleteEa:  No Ea file exists\n",
                       0);

            RxRaiseStatus( RxContext, RxStatus(NO_EAS_ON_FILE) );
        }

        //
        //  We now have everything we need to delete the ea set.  Call the
        //  support routine to do this.
        //

        RxDeleteEaSet( RxContext,
                        Vcb,
                        EaBcb,
                        EaDirent,
                        EaHandle,
                        FileName );

        CcFlushCache( Vcb->VirtualEaFile->SectionObjectPointer, NULL, 0, NULL );

    } finally {

        DebugUnwind( RxDeleteEa );

        //
        //  Release the EaFcb if held.
        //

        if (LockedEaFcb) {

            RxReleaseFcb( RxContext, Vcb->EaFcb );
        }

        //
        //  Unpin the dirent for the Ea file if pinned.
        //

        RxUnpinBcb( RxContext, EaBcb );

        DebugTrace(-1, Dbg, "RxDeleteEa -> Exit\n", 0);
    }

    return;
}


VOID
RxGetEaFile (
    IN PRX_CONTEXT RxContext,
    IN OUT PVCB Vcb,
    OUT PDIRENT *EaDirent,
    OUT PBCB *EaBcb,
    IN BOOLEAN CreateFile,
    IN BOOLEAN ExclusiveFcb
    )

/*++

Routine Description:

    This routine is used to completely initialize the Vcb and
    the Ea file for the Vcb.

    If the Vcb doesn't have the Ea file object, then we first try to
    lookup the Ea data file in the root directory and if that fails
    we try to create the file.  The 'CreateFile' flag is used to check
    whether it is necessary to create the Ea file.

    This routine will lock down the Fcb for exclusive or shared access before
    performing any operations.  If the operation does not complete due
    to blocking, exclusive or shared access will be given up before returning.

    If we are creating the Ea file and marking sections of it dirty,
    we can't use the repin feature through the cache map.  In that case
    we use a local RxContext and then unpin all of the Bcb's before
    continuing.

    Note: If this routine will be creating the Ea file, we are guaranteed
    to be waitable.

Arguments:

    Vcb - Vcb for the volume

    EaDirent - Location to store the address of the pinned dirent for the
               Ea file.

    EaBcb - Location to store the address of the Bcb for the pinned dirent.

    CreateFile - Boolean indicating whether we should create the Ea file
                 on the disk.

    ExclusiveFcb - Indicates whether shared or exclusive access is desired
                   for the EaFcb.

Return Value:

    None.

--*/

{
    PFILE_OBJECT EaStreamFile;
    EA_RANGE EaFileRange;

    BOOLEAN UnwindLockedEaFcb;
    BOOLEAN UnwindAllocatedDiskSpace;
    BOOLEAN UnwindEaDirentCreated;
    BOOLEAN UnwindUpdatedSizes;

    DebugTrace(+1, Dbg, "RxGetEaFile ...\n", 0);

    EaStreamFile = NULL;

    UnwindLockedEaFcb = FALSE;
    UnwindAllocatedDiskSpace = FALSE;
    UnwindEaDirentCreated = FALSE;
    UnwindUpdatedSizes = FALSE;

    RtlZeroMemory( &EaFileRange, sizeof( EA_RANGE ));

    //
    //  Use a try to facilitate cleanup
    //

    try {

        OEM_STRING EaFileName;
        LARGE_INTEGER SectionSize;

        //
        //  Check if the Vcb already has the file object.  If it doesn't, then
        //  we need to search the root directory for the Ea data file.
        //

        if (Vcb->VirtualEaFile == NULL) {

            //
            //  Always lock the Ea file exclusively if we have to create the file.
            //

            if ( !RxAcquireExclusiveFcb( RxContext, Vcb->EaFcb )) {

                DebugTrace(0, Dbg, "RxGetEaFile:  Can't grab exclusive\n", 0);
                RxRaiseStatus( RxContext, RxStatus(CANT_WAIT) );
            }

            UnwindLockedEaFcb = TRUE;

        //
        //  Otherwise we acquire the Fcb as the caller requested.
        //

        } else {

            if ((ExclusiveFcb && !RxAcquireExclusiveFcb( RxContext, Vcb->EaFcb ))
                || (!ExclusiveFcb && !RxAcquireSharedFcb( RxContext, Vcb->EaFcb))) {

                DebugTrace(0, Dbg, "RxGetEaFile:  Can't grab EaFcb\n", 0);

                RxRaiseStatus( RxContext, RxStatus(CANT_WAIT) );
            }

            UnwindLockedEaFcb = TRUE;

            //
            //  If the file now does not exist we need to release the Fcb and
            //  reacquire exclusive if we acquired shared.
            //

            if ((Vcb->VirtualEaFile == NULL) && !ExclusiveFcb) {

                RxReleaseFcb( RxContext, Vcb->EaFcb );
                UnwindLockedEaFcb = FALSE;

                if (!RxAcquireExclusiveFcb( RxContext, Vcb->EaFcb )) {

                    DebugTrace(0, Dbg, "RxGetEaFile:  Can't grab EaFcb\n", 0);

                    RxRaiseStatus( RxContext, RxStatus(CANT_WAIT) );
                }

                UnwindLockedEaFcb = TRUE;
            }
        }

        //
        //  If the file object is now there we only need to get the
        //  dirent for the Ea file.
        //

        if (Vcb->VirtualEaFile != NULL) {

            RxVerifyFcb( RxContext, Vcb->EaFcb );

            RxGetDirentFromFcbOrDcb( RxContext,
                                      Vcb->EaFcb,
                                      EaDirent,
                                      EaBcb );

            try_return( NOTHING );

        } else {

            VBO ByteOffset;

            //
            //  Always mark the ea fcb as good.
            //

            Vcb->EaFcb->FcbCondition = FcbGood;

            //
            //  We try to lookup the dirent for the Ea Fcb.
            //

            EaFileName.Buffer = "EA DATA. SF";
            EaFileName.Length = 11;
            EaFileName.MaximumLength = 12;

            RxLocateSimpleOemDirent( RxContext,
                                      Vcb->EaFcb->ParentDcb,
                                      &EaFileName,
                                      EaDirent,
                                      EaBcb,
                                      &ByteOffset );

            //
            //  If the file exists, we need to create the virtual file
            //  object for it.
            //

            if (*EaDirent != NULL) {

                //
                //  Since we may be modifying the dirent, pin the data now.
                //

                RxPinMappedData( RxContext,
                                  Vcb->EaFcb->ParentDcb,
                                  ByteOffset,
                                  sizeof(DIRENT),
                                  EaBcb );

                //
                //  Update the Fcb with information on the file size
                //  and disk location.  Also increment the open/unclean
                //  counts in the EaFcb and the open count in the
                //  Vcb.
                //

                Vcb->EaFcb->FirstClusterOfFile = (*EaDirent)->FirstClusterOfFile;
                Vcb->EaFcb->DirentOffsetWithinDirectory = ByteOffset;

                //
                //  Find the allocation size.  The purpose here is
                //  really to completely fill in the Mcb for the
                //  file.
                //

                Vcb->EaFcb->Header.AllocationSize.QuadPart = -1;

                RxLookupFileAllocationSize( RxContext, Vcb->EaFcb );

                //
                //  Start by computing the section size for the cache
                //  manager.
                //

                SectionSize.QuadPart = (*EaDirent)->FileSize;
                Vcb->EaFcb->Header.AllocationSize = SectionSize;
                Vcb->EaFcb->Header.FileSize = SectionSize;

                //
                //  Create and initialize the file object for the
                //  Ea virtual file.
                //

                EaStreamFile = RxOpenEaFile( RxContext, Vcb->EaFcb );

                Vcb->VirtualEaFile = EaStreamFile;

            //
            //  Else there was no dirent.  If we were instructed to
            //  create the file object, we will try to create the dirent,
            //  allocate disk space, initialize the Ea file header and
            //  return this information to the user.
            //

            } else if (CreateFile) {

                ULONG BytesPerSector;
                ULONG BytesPerCluster;
                ULONG OffsetTableSize;
                ULONG AllocationSize;
                PEA_FILE_HEADER FileHeader;
                USHORT AllocatedClusters;
                PUSHORT CurrentIndex;
                ULONG Index;
                RXSTATUS Status;

                DebugTrace(0, Dbg, "RxGetEaFile:  Creating local RxContext\n", 0);

                BytesPerSector = Vcb->Bpb.BytesPerSector;
                BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

                AllocationSize = ((BytesPerSector << 1) + BytesPerCluster - 1)
                                 & ~(BytesPerCluster - 1);

                AllocatedClusters = (USHORT) (AllocationSize
                                    >> Vcb->AllocationSupport.LogOfBytesPerCluster);

                OffsetTableSize = AllocationSize - BytesPerSector;

                //
                //  Allocate disk space, the space allocated is 2 sectors
                //  rounded up to the nearest cluster size.
                //

                RxAllocateDiskSpace( RxContext,
                                      Vcb,
                                      0,
                                      &AllocationSize,
                                      &Vcb->EaFcb->Mcb );

                UnwindAllocatedDiskSpace = TRUE;

                //
                //  Allocate and initialize a dirent in the root directory
                //  to describe this new file.
                //

                Vcb->EaFcb->DirentOffsetWithinDirectory =
                    RxCreateNewDirent( RxContext,
                                        Vcb->EaFcb->ParentDcb,
                                        1 );

                RxPrepareWriteDirectoryFile( RxContext,
                                              Vcb->EaFcb->ParentDcb,
                                              Vcb->EaFcb->DirentOffsetWithinDirectory,
                                              sizeof(DIRENT),
                                              EaBcb,
                                              EaDirent,
                                              FALSE,
                                              &Status );

                ASSERT( NT_SUCCESS( Status ));

                UnwindEaDirentCreated = TRUE;

                RxConstructDirent( RxContext,
                                    *EaDirent,
                                    &EaFileName,
                                    FALSE,
                                    FALSE,
                                    NULL,
                                    RDBSS_DIRENT_ATTR_READ_ONLY
                                    | RDBSS_DIRENT_ATTR_HIDDEN
                                    | RDBSS_DIRENT_ATTR_SYSTEM
                                    | RDBSS_DIRENT_ATTR_ARCHIVE,
                                    TRUE );

                (*EaDirent)->FileSize = AllocationSize;

                RxSetDirtyBcb( RxContext, *EaBcb, Vcb );

                //
                //  Initialize the Fcb for this file and initialize the
                //  cache map as well.
                //

                //
                //  Start by computing the section size for the cache
                //  manager.
                //

                SectionSize.QuadPart = (*EaDirent)->FileSize;
                Vcb->EaFcb->Header.AllocationSize = SectionSize;
                Vcb->EaFcb->Header.FileSize = SectionSize;
                UnwindUpdatedSizes = TRUE;

                //
                //  Create and initialize the file object for the
                //  Ea virtual file.
                //

                EaStreamFile = RxOpenEaFile( RxContext, Vcb->EaFcb );

                //
                //  Update the Fcb with information on the file size
                //  and disk location.  Also increment the open/unclean
                //  counts in the EaFcb and the open count in the
                //  Vcb.
                //

                {
                    LBO FirstLboOfFile;

                    FsRtlLookupMcbEntry( &Vcb->EaFcb->Mcb,
                                         0,
                                         &FirstLboOfFile,
                                         NULL,
                                         NULL );

                    (*EaDirent)->FirstClusterOfFile =
                            (RDBSS_ENTRY) RxGetIndexFromLbo( Vcb, FirstLboOfFile );
                }

                RxSetDirtyBcb( RxContext, *EaBcb, Vcb );

                Vcb->EaFcb->FirstClusterOfFile = (*EaDirent)->FirstClusterOfFile;

                //
                //  Initialize the Ea file header and mark the Bcb as dirty.
                //

                RxPinEaRange( RxContext,
                               EaStreamFile,
                               Vcb->EaFcb,
                               &EaFileRange,
                               0,
                               AllocationSize,
                               RxStatus(DATA_ERROR) );

                FileHeader = (PEA_FILE_HEADER) EaFileRange.Data;

                RtlZeroMemory( FileHeader, AllocationSize );
                FileHeader->Signature = EA_FILE_SIGNATURE;

                for (Index = MAX_EA_BASE_INDEX, CurrentIndex = FileHeader->EaBaseTable;
                     Index;
                     Index--, CurrentIndex++) {

                    *CurrentIndex = AllocatedClusters;
                }

                //
                //  Initialize the offset table with the offset set to
                //  after the just allocated clusters.
                //

                for (Index = OffsetTableSize >> 1,
                        CurrentIndex = (PUSHORT) ((PUCHAR) FileHeader + sizeof( EA_FILE_HEADER ));
                     Index;
                     Index--, CurrentIndex++) {

                    *CurrentIndex = UNUSED_EA_HANDLE;
                }

                //
                //  Unpin the file header and offset table.
                //

                RxMarkEaRangeDirty( RxContext, EaStreamFile, &EaFileRange );
                RxUnpinEaRange( RxContext, &EaFileRange );

                CcFlushCache( EaStreamFile->SectionObjectPointer, NULL, 0, NULL );

                //
                //  Return the Ea file object to the user.
                //

                Vcb->VirtualEaFile = EaStreamFile;
            }
        }
    try_exit:  NOTHING;
    } finally {

        DebugUnwind( RxGetEaFile );

        //
        //  If this is abnormal termination and disk space has been
        //  allocated.  We deallocate it now.
        //

        if (AbnormalTermination()) {

            //
            //  Deallocate the Ea file
            //

            if (UnwindAllocatedDiskSpace) {

                RxDeallocateDiskSpace( RxContext,
                                        Vcb,
                                        &Vcb->EaFcb->Mcb );
            }

            //
            //  Delete the dirent for the Ea file, if created.
            //

            if (UnwindEaDirentCreated) {

                if (UnwindUpdatedSizes) {

                    Vcb->EaFcb->Header.AllocationSize = RxLargeZero;
                    Vcb->EaFcb->Header.FileSize = RxLargeZero;
                }

                RxUnpinBcb( RxContext, EaBcb );
                RxDeleteDirent( RxContext, Vcb->EaFcb, NULL, TRUE );
            }

            //
            //  Release the Fcb if held
            //

            if (UnwindLockedEaFcb) {

                RxReleaseFcb( RxContext, Vcb->EaFcb );
            }

            //
            //  Dereference the Ea stream file if created.
            //

            if (EaStreamFile != NULL) {

                ObDereferenceObject( EaStreamFile );
            }
        }

        //
        //  If the Ea file header is locked down.  We unpin it now.
        //

        RxUnpinEaRange( RxContext, &EaFileRange );

        DebugTrace(-1, Dbg, "RxGetEaFile:  Exit\n", 0);
    }

    return;
}


VOID
RxReadEaSet (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN USHORT EaHandle,
    IN POEM_STRING FileName,
    IN BOOLEAN ReturnEntireSet,
    OUT PEA_RANGE EaSetRange
    )

/*++

Routine Description:

    This routine pins the Ea set for the given ea handle within the
    Ea stream file.  The EaHandle, after first comparing against valid
    index values, is used to compute the cluster offset for this
    this Ea set.  The Ea set is then verified as belonging to this
    index and lying within the Ea data file.

    The caller of this function will have verified that the Ea file
    exists and that the Vcb field points to an initialized cache file.
    The caller will already have gained exclusive access to the
    EaFcb.

Arguments:

    Vcb - Supplies the Vcb for the volume.

    EaHandle - Supplies the handle for the Ea's to read.

    FileName - Name of the file whose Ea's are being read.

    ReturnEntireSet - Indicates if the caller needs the entire set
        as opposed to just the header.

    EaSetRange - Pointer to the EaRange structure which will describe the Ea
        on return.

Return Value:

    None

--*/

{
    ULONG BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    ULONG EaOffsetVbo;
    EA_RANGE EaOffsetRange;
    USHORT EaOffsetCluster;

    EA_RANGE EaHeaderRange;
    PEA_FILE_HEADER EaHeader;

    ULONG EaSetVbo;
    PEA_SET_HEADER EaSet;

    ULONG CbList;

    DebugTrace(+1, Dbg, "RxReadEaSet\n", 0);
    DebugTrace( 0, Dbg, "  Vcb      = %8lx\n", Vcb);

    //
    //  Verify that the Ea index has a legal value.  Raise status
    //  RxStatus(NONEXISTENT_EA_ENTRY) if illegal.
    //

    if (EaHandle < MIN_EA_HANDLE
        || EaHandle > MAX_EA_HANDLE) {

        DebugTrace(-1, Dbg, "RxReadEaSet: Illegal handle value\n", 0);
        RxRaiseStatus( RxContext, RxStatus(NONEXISTENT_EA_ENTRY) );
    }

    //
    //  Verify that the virtual Ea file is large enough for us to read
    //  the EaOffet table for this index.
    //

    EaOffsetVbo = Vcb->Bpb.BytesPerSector + ((EaHandle >> 7) << 8);

    //
    //  Zero the Ea range structures.
    //

    RtlZeroMemory( &EaHeaderRange, sizeof( EA_RANGE ));
    RtlZeroMemory( &EaOffsetRange, sizeof( EA_RANGE ));

    //
    //  Use a try statement to clean up on exit.
    //

    try {

        //
        //  Pin down the EA file header.
        //

        RxPinEaRange( RxContext,
                       Vcb->VirtualEaFile,
                       Vcb->EaFcb,
                       &EaHeaderRange,
                       0,
                       sizeof( EA_FILE_HEADER ),
                       RxStatus(NONEXISTENT_EA_ENTRY) );

        EaHeader = (PEA_FILE_HEADER) EaHeaderRange.Data;

        //
        //  Pin down the Ea offset table for the particular index.
        //

        RxPinEaRange( RxContext,
                       Vcb->VirtualEaFile,
                       Vcb->EaFcb,
                       &EaOffsetRange,
                       EaOffsetVbo,
                       sizeof( EA_OFF_TABLE ),
                       RxStatus(NONEXISTENT_EA_ENTRY) );

        //
        //  Check if the specifific handle is currently being used.
        //

        EaOffsetCluster = *((PUSHORT) EaOffsetRange.Data
                            + (EaHandle & (MAX_EA_OFFSET_INDEX - 1)));

        if (EaOffsetCluster == UNUSED_EA_HANDLE) {

            DebugTrace(0, Dbg, "RxReadEaSet: Ea handle is unused\n", 0);
            RxRaiseStatus( RxContext, RxStatus(NONEXISTENT_EA_ENTRY) );
        }

        //
        //  Compute the file offset for the Ea data.
        //

        EaSetVbo = (EaHeader->EaBaseTable[EaHandle >> 7] + EaOffsetCluster)
                   << Vcb->AllocationSupport.LogOfBytesPerCluster;

        //
        //  Unpin the file header and offset table.
        //

        RxUnpinEaRange( RxContext, &EaHeaderRange );
        RxUnpinEaRange( RxContext, &EaOffsetRange );

        //
        //  Pin the ea set.
        //

        RxPinEaRange( RxContext,
                       Vcb->VirtualEaFile,
                       Vcb->EaFcb,
                       EaSetRange,
                       EaSetVbo,
                       BytesPerCluster,
                       RxStatus(DATA_ERROR) );

        //
        //  Verify that the Ea set is valid and belongs to this index.
        //  Raise RxStatus(DATA_ERROR) if there is a data conflict.
        //

        EaSet = (PEA_SET_HEADER) EaSetRange->Data;

        if (EaSet->Signature != EA_SET_SIGNATURE
            || EaSet->OwnEaHandle != EaHandle ) {

            DebugTrace(0, Dbg, "RxReadEaSet: Ea set header is corrupt\n", 0);
            RxRaiseStatus( RxContext, RxStatus(DATA_ERROR) );
        }

        //
        //  At this point we have pinned a single cluster of Ea data.  If
        //  this represents the entire Ea data for the Ea index, we are
        //  done.  Otherwise we need to check on the entire size of
        //  of the Ea set header and whether it is contained in the allocated
        //  size of the Ea virtual file.  At that point we can unpin
        //  the partial Ea set header and repin the entire header.
        //

        CbList = GetcbList( EaSet );

        if (ReturnEntireSet
            && CbList > BytesPerCluster ) {

            //
            //  Round up to the cluster size.
            //

            CbList = (CbList + EA_CBLIST_OFFSET + BytesPerCluster - 1)
                     & ~(BytesPerCluster - 1);

            RxUnpinEaRange( RxContext, EaSetRange );

            RtlZeroMemory( EaSetRange, sizeof( PEA_RANGE ));

            RxPinEaRange( RxContext,
                           Vcb->VirtualEaFile,
                           Vcb->EaFcb,
                           EaSetRange,
                           EaSetVbo,
                           CbList,
                           RxStatus(DATA_ERROR) );
        }

    } finally {

        DebugUnwind( RxReadEaSet );

        //
        //  Unpin the Ea base and offset tables if locked down.
        //

        RxUnpinEaRange( RxContext, &EaHeaderRange );
        RxUnpinEaRange( RxContext, &EaOffsetRange );

        DebugTrace(-1, Dbg, "RxReadEaSet:  Exit\n", 0);
    }

    return;
}


VOID
RxDeleteEaSet (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PBCB EaBcb,
    OUT PDIRENT EaDirent,
    IN USHORT EaHandle,
    IN POEM_STRING FileName
    )

/*++

Routine Description:

    This routines clips the Ea set for a particular index out of the
    Ea file for a volume.  The index is verified as belonging to a valid
    handle.  The clusters are removed and the Ea stream file along with
    the Ea base and offset files are updated.

    The caller of this function will have verified that the Ea file
    exists and that the Vcb field points to an initialized cache file.
    The caller will already have gained exclusive access to the
    EaFcb.

Arguments:

    Vcb - Supplies the Vcb for the volume.

    VirtualEeFile - Pointer to the file object for the virtual Ea file.

    EaFcb - Supplies the pointer to the Fcb for the Ea file.

    EaBcb - Supplies a pointer to the Bcb for the Ea dirent.

    EaDirent - Supplies a pointer to the dirent for the Ea file.

    EaHandle - Supplies the handle for the Ea's to read.

    FileName - Name of the file whose Ea's are being read.

Return Value:

    None.

--*/

{
    ULONG BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;
    ULONG CbList;
    LARGE_INTEGER FileOffset;

    MCB DataMcb;
    BOOLEAN UnwindInitializeDataMcb = FALSE;
    BOOLEAN UnwindSplitData = FALSE;

    MCB TailMcb;
    BOOLEAN UnwindInitializeTailMcb = FALSE;
    BOOLEAN UnwindSplitTail = FALSE;
    BOOLEAN UnwindMergeTail = FALSE;

    BOOLEAN UnwindModifiedEaHeader = FALSE;
    BOOLEAN UnwindPrevFcbValues = FALSE;
    ULONG UnwindPrevFileSize;

    ULONG EaOffsetVbo;
    USHORT EaOffsetIndex;
    EA_RANGE EaOffsetRange;
    USHORT EaOffsetCluster;

    PFILE_OBJECT VirtualEaFile = Vcb->VirtualEaFile;
    PFCB EaFcb = Vcb->EaFcb;

    EA_RANGE EaHeaderRange;
    PEA_FILE_HEADER EaHeader;
    USHORT EaHeaderBaseIndex;

    ULONG EaSetVbo;
    ULONG EaSetLength;
    EA_RANGE EaSetRange;
    PEA_SET_HEADER EaSet;
    USHORT EaSetClusterCount;

    //
    //  Verify that the Ea index has a legal value.  Raise status
    //  RxStatus(INVALID_HANDLE) if illegal.
    //

    if (EaHandle < MIN_EA_HANDLE
        || EaHandle > MAX_EA_HANDLE) {

        DebugTrace(-1, Dbg, "RxDeleteEaSet: Illegal handle value\n", 0);
        RxRaiseStatus( RxContext, RxStatus(NONEXISTENT_EA_ENTRY) );
    }

    //
    //  Verify that the virtual Ea file is large enough for us to read
    //  the EaOffet table for this index.
    //

    EaOffsetVbo = Vcb->Bpb.BytesPerSector + ((EaHandle >> 7) << 8);

    //
    //  Zero the Ea range structures.
    //

    RtlZeroMemory( &EaHeaderRange, sizeof( EA_RANGE ));
    RtlZeroMemory( &EaOffsetRange, sizeof( EA_RANGE ));
    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    //
    //  Use a try to facilitate cleanup.
    //

    try {

        //
        //  Pin down the EA file header.
        //

        RxPinEaRange( RxContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaHeaderRange,
                       0,
                       sizeof( EA_FILE_HEADER ),
                       RxStatus(NONEXISTENT_EA_ENTRY) );

        EaHeader = (PEA_FILE_HEADER) EaHeaderRange.Data;

        //
        //  Pin down the Ea offset table for the particular index.
        //

        RxPinEaRange( RxContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaOffsetRange,
                       EaOffsetVbo,
                       sizeof( EA_OFF_TABLE ),
                       RxStatus(NONEXISTENT_EA_ENTRY) );

        //
        //  Check if the specifific handle is currently being used.
        //

        EaOffsetIndex = EaHandle & (MAX_EA_OFFSET_INDEX - 1);
        EaOffsetCluster = *((PUSHORT) EaOffsetRange.Data + EaOffsetIndex);

        if (EaOffsetCluster == UNUSED_EA_HANDLE) {

            DebugTrace(0, Dbg, "RxReadEaSet: Ea handle is unused\n", 0);
            RxRaiseStatus( RxContext, RxStatus(NONEXISTENT_EA_ENTRY) );
        }

        //
        //  Compute the file offset for the Ea data.
        //

        EaHeaderBaseIndex = EaHandle >> 7;
        EaSetVbo = (EaHeader->EaBaseTable[EaHeaderBaseIndex] + EaOffsetCluster)
                   << Vcb->AllocationSupport.LogOfBytesPerCluster;

        //
        //  Unpin the file header and offset table.
        //

        RxUnpinEaRange( RxContext, &EaHeaderRange );
        RxUnpinEaRange( RxContext, &EaOffsetRange );

        //
        //  Try to pin the requested Ea set.
        //

        RxPinEaRange( RxContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaSetRange,
                       EaSetVbo,
                       BytesPerCluster,
                       RxStatus(DATA_ERROR) );

        EaSet = (PEA_SET_HEADER) EaSetRange.Data;

        if (EaSet->Signature != EA_SET_SIGNATURE
            || EaSet->OwnEaHandle != EaHandle ) {

            DebugTrace(0, Dbg, "RxReadEaSet: Ea set header is corrupt\n", 0);
            RxRaiseStatus( RxContext, RxStatus(DATA_ERROR) );
        }

        //
        //  At this point we have pinned a single cluster of Ea data.  If
        //  this represents the entire Ea data for the Ea index, we know
        //  the number of clusters to remove.  Otherwise we need to check
        //  on the entire size of the Ea set header and whether it is
        //  contained in the allocated size of the Ea virtual file.  At
        //  that point we unpin the partial Ea set header and remember the
        //  starting cluster offset and number of clusters in both cluster
        //  and Vbo formats.
        //
        //  At that point the following variables have the described
        //  values.
        //
        //      EaSetVbo - Vbo to start splice at.
        //      EaSetLength - Number of bytes to splice.
        //      EaSetClusterCount - Number of clusters to splice.
        //

        CbList = GetcbList( EaSet );

        EaSetClusterCount = (USHORT) ((CbList + EA_CBLIST_OFFSET + BytesPerCluster - 1)
                                      >> Vcb->AllocationSupport.LogOfBytesPerCluster);

        EaSetLength = EaSetClusterCount << Vcb->AllocationSupport.LogOfBytesPerCluster;

        if (EaSetLength > BytesPerCluster) {

            if (EaFcb->Header.FileSize.LowPart - EaSetVbo < EaSetLength) {

                DebugTrace(0, Dbg, "RxDeleteEaSet: Full Ea set not contained in file\n", 0);

                RxRaiseStatus( RxContext, RxStatus(DATA_ERROR) );
            }
        }

        RxUnpinEaRange( RxContext, &EaSetRange );

        //
        //  Update the cache manager for this file.  This is done by
        //  truncating to the point where the data was spliced and
        //  reinitializing with the modified size of the file.
        //
        //  NOTE: Even if the all the EA's are removed the Ea file will
        //  always exist and the header area will never shrink.
        //

        FileOffset.LowPart = EaSetVbo;
        FileOffset.HighPart = 0;

        //
        //  Round the cache map down to a system page boundary.
        //

        FileOffset.LowPart &= ~(PAGE_SIZE - 1);

        //
        //  Make sure all the data gets out to the disk.
        //

        {
            IO_STATUS_BLOCK Iosb;
            ULONG PurgeCount = 5;

            while (--PurgeCount) {

                Iosb.Status = RxStatus(SUCCESS);

                CcFlushCache( VirtualEaFile->SectionObjectPointer,
                              NULL,
                              0,
                              &Iosb );

                ASSERT( Iosb.Status == RxStatus(SUCCESS) );

                //
                //  We throw the unwanted pages out of the cache and then
                //  truncate the Ea File for the new size.
                //

                if (CcPurgeCacheSection( VirtualEaFile->SectionObjectPointer,
                                         &FileOffset,
                                         0,
                                         FALSE )) {

                    break;
                }
            }

            if (!PurgeCount) {

                RxRaiseStatus( RxContext, RxStatus(UNABLE_TO_DELETE_SECTION) );
            }
        }

        FileOffset.LowPart = EaFcb->Header.FileSize.LowPart - EaSetLength;

        //
        //  Perform the splice operation on the RDBSS chain.  This is done
        //  by splitting the target clusters out and merging the remaining
        //  clusters around them.  We can ignore the return value from
        //  the merge and splice functions because we are guaranteed
        //  to be able to block.
        //

        {
            FsRtlInitializeMcb( &DataMcb, PagedPool );

            UnwindInitializeDataMcb = TRUE;

            RxSplitAllocation( RxContext,
                                Vcb,
                                &EaFcb->Mcb,
                                EaSetVbo,
                                &DataMcb );

            UnwindSplitData = TRUE;

            if (EaSetLength + EaSetVbo != EaFcb->Header.FileSize.LowPart) {

                FsRtlInitializeMcb( &TailMcb, PagedPool );

                UnwindInitializeTailMcb = TRUE;

                RxSplitAllocation( RxContext,
                                    Vcb,
                                    &DataMcb,
                                    EaSetLength,
                                    &TailMcb );

                UnwindSplitTail = TRUE;

                RxMergeAllocation( RxContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    &TailMcb );

                UnwindMergeTail = TRUE;
            }
        }

        //
        //  Update the Fcb for the Ea file
        //

        UnwindPrevFileSize = EaFcb->Header.FileSize.LowPart;

        (VOID)ExAcquireResourceExclusive( EaFcb->Header.PagingIoResource,
                                          TRUE );

        EaFcb->Header.FileSize.LowPart = EaFcb->Header.FileSize.LowPart - EaSetLength;
        EaFcb->Header.AllocationSize = EaFcb->Header.FileSize;

        ExReleaseResource( EaFcb->Header.PagingIoResource );

        CcSetFileSizes( VirtualEaFile,
                        (PCC_FILE_SIZES)&EaFcb->Header.AllocationSize );

        EaDirent->FileSize = EaFcb->Header.FileSize.LowPart;

        RxSetDirtyBcb( RxContext, EaBcb, Vcb );

        UnwindPrevFcbValues = TRUE;

        //
        //  Update the Ea base and offset tables.  For the Ea base table,
        //  all subsequent index values must be decremented by the number
        //  of clusters removed.
        //
        //  For the entries in the relevant Ea offset table, all entries
        //  after this index must also be decreased by the number of
        //  clusters removed.
        //

        //
        //  Pin down the EA file header.
        //

        RtlZeroMemory( &EaHeaderRange,
                       sizeof( EA_RANGE ));

        RxPinEaRange( RxContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaHeaderRange,
                       0,
                       sizeof( EA_FILE_HEADER ),
                       RxStatus(NONEXISTENT_EA_ENTRY) );

        EaHeader = (PEA_FILE_HEADER) EaHeaderRange.Data;

        //
        //  Pin down the Ea offset table for the particular index.
        //

        RtlZeroMemory( &EaOffsetRange,
                       sizeof( EA_RANGE ));

        RxPinEaRange( RxContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaOffsetRange,
                       EaOffsetVbo,
                       sizeof( EA_OFF_TABLE ),
                       RxStatus(NONEXISTENT_EA_ENTRY) );

        {
            ULONG Count;
            PUSHORT NextEaIndex;

            Count = MAX_EA_BASE_INDEX - EaHeaderBaseIndex - 1;

            NextEaIndex = &EaHeader->EaBaseTable[EaHeaderBaseIndex + 1];

            while (Count--) {

                *(NextEaIndex++) -= EaSetClusterCount;
            }

            RxMarkEaRangeDirty( RxContext, VirtualEaFile, &EaHeaderRange );

            Count = MAX_EA_OFFSET_INDEX - EaOffsetIndex - 1;
            NextEaIndex = (PUSHORT) EaOffsetRange.Data + EaOffsetIndex;

            *(NextEaIndex++) = UNUSED_EA_HANDLE;

            while (Count--) {

                if (*NextEaIndex != UNUSED_EA_HANDLE) {

                    *NextEaIndex -= EaSetClusterCount;
                }

                NextEaIndex++;
            }

            RxMarkEaRangeDirty( RxContext, VirtualEaFile, &EaOffsetRange );
        }

        UnwindModifiedEaHeader = TRUE;

        //
        //  Deallocate the ea set removed
        //

        RxDeallocateDiskSpace( RxContext,
                                Vcb,
                                &DataMcb );

    } finally {

        DebugUnwind( RxDeleteEaSet );

        //
        //  Restore file if abnormal termination.
        //
        //  If we have modified the ea file header we ignore this
        //  error.  Otherwise we walk through the state variables.
        //

        if (AbnormalTermination()
            && !UnwindModifiedEaHeader) {

            //
            //  If we modified the Ea dirent or Fcb, recover the previous
            //  values.
            //

            if (UnwindPrevFcbValues) {

                EaFcb->Header.FileSize.LowPart = UnwindPrevFileSize;
                EaFcb->Header.AllocationSize.LowPart = UnwindPrevFileSize;
                EaDirent->FileSize = UnwindPrevFileSize;

                CcSetFileSizes( VirtualEaFile,
                                (PCC_FILE_SIZES)&EaFcb->Header.AllocationSize );
            }

            //
            //  If we merged the tail with the
            //  ea file header.  We split it out
            //  again.
            //

            if (UnwindMergeTail) {

                RxSplitAllocation( RxContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    EaSetVbo,
                                    &TailMcb );
            }

            //
            //  If we split the tail off we merge the tail back
            //  with the ea data to remove.
            //

            if (UnwindSplitTail) {

                RxMergeAllocation( RxContext,
                                    Vcb,
                                    &DataMcb,
                                    &TailMcb );
            }

            //
            //  If the ea set has been split out, we merge that
            //  cluster string back in the file.  Otherwise we
            //  simply uninitialize the local Mcb.
            //

            if (UnwindSplitData) {

                RxMergeAllocation( RxContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    &DataMcb );
            }
        }

        //
        //  Unpin any Bcb's still active.
        //

        RxUnpinEaRange( RxContext, &EaHeaderRange );
        RxUnpinEaRange( RxContext, &EaOffsetRange );
        RxUnpinEaRange( RxContext, &EaSetRange );

        //
        //  Uninitialize any initialized Mcbs
        //

        if (UnwindInitializeDataMcb) {

            FsRtlUninitializeMcb( &DataMcb );
        }

        if (UnwindInitializeTailMcb) {

            FsRtlUninitializeMcb( &TailMcb );
        }

        DebugTrace(-1, Dbg, "RxDeleteEaSet -> Exit\n", 0);
    }

    return;
}


VOID
RxAddEaSet (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN ULONG EaSetLength,
    IN PBCB EaBcb,
    OUT PDIRENT EaDirent,
    OUT PUSHORT EaHandle,
    OUT PEA_RANGE EaSetRange
    )

/*++

Routine Description:

    This routine will add the necessary clusters to support a new
    Ea set of the given size.  This is done by splicing a chain of
    clusters into the existing Ea file.  An Ea index is assigned to
    this new chain and the Ea base and offset tables are updated to
    include this new handle.  This routine also pins the added
    clusters and returns their address and a Bcb.

    The caller of this function will have verified that the Ea file
    exists and that the Vcb field points to an initialized cache file.
    The caller will already have gained exclusive access to the
    EaFcb.

Arguments:

    Vcb - Supplies the Vcb to fill in.

    EaSetLength - The number of bytes needed to contain the Ea set.  This
        routine will round this up the next cluster size.

    EaBcb - Supplies a pointer to the Bcb for the Ea dirent.

    EaDirent - Supplies a pointer to the dirent for the Ea file.

    EaHandle - Supplies the address to store the ea index generated here.

    EaSetRange - This is the structure that describes new range in the Ea file.

Return Value:

    None.

--*/

{
    ULONG BytesPerSector = Vcb->Bpb.BytesPerSector;
    ULONG BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    EA_RANGE EaHeaderRange;
    USHORT EaHeaderIndex;
    PEA_FILE_HEADER EaHeader;

    EA_RANGE EaOffsetRange;
    ULONG EaNewOffsetVbo;
    USHORT EaOffsetIndex;
    ULONG EaOffsetTableSize;
    PUSHORT EaOffsetTable;

    ULONG EaSetClusterOffset;
    ULONG EaSetVbo;
    USHORT EaSetClusterCount;
    PEA_SET_HEADER EaSet;

    PFILE_OBJECT VirtualEaFile = Vcb->VirtualEaFile;
    PFCB EaFcb = Vcb->EaFcb;

    MCB EaSetMcb;
    BOOLEAN UnwindInitializedEaSetMcb = FALSE;
    BOOLEAN UnwindAllocatedNewAllocation = FALSE;
    BOOLEAN UnwindMergedNewEaSet = FALSE;

    MCB EaOffsetMcb;
    BOOLEAN UnwindInitializedOffsetMcb = FALSE;
    BOOLEAN UnwindSplitNewAllocation = FALSE;
    BOOLEAN UnwindMergedNewOffset = FALSE;

    MCB EaTailMcb;
    BOOLEAN UnwindInitializedTailMcb = FALSE;
    BOOLEAN UnwindSplitTail = FALSE;
    BOOLEAN UnwindMergedTail = FALSE;

    MCB EaInitialEaMcb;
    BOOLEAN UnwindInitializedInitialEaMcb = FALSE;
    BOOLEAN UnwindSplitInitialEa = FALSE;
    BOOLEAN UnwindMergedInitialEa = FALSE;

    USHORT NewEaIndex;
    PUSHORT NextEaOffset;

    ULONG NewAllocation;
    LARGE_INTEGER FileOffset;
    ULONG Count;

    ULONG UnwindPrevFileSize;
    BOOLEAN UnwindPrevFcbValues = FALSE;

    BOOLEAN TailExists = FALSE;
    BOOLEAN AddedOffsetTableCluster = FALSE;
    BOOLEAN UnwindPurgeCacheMap = FALSE;

    DebugTrace(+1, Dbg, "RxAddEaSet\n", 0);
    DebugTrace( 0, Dbg, "  Vcb         = %8lx\n", Vcb);
//    DebugTrace( 0, Dbg, "  EaSetSize = %ul\n", EaSetSize );
    DebugTrace( 0, Dbg, "  EaSetLength = %ul\n", EaSetLength );

    //
    //  Zero the Ea range structures.
    //

    RtlZeroMemory( &EaHeaderRange, sizeof( EA_RANGE ));
    RtlZeroMemory( &EaOffsetRange, sizeof( EA_RANGE ));

    //
    //  Use a try statement to facilitate cleanup.
    //

    try {

        //
        //  Pin down the file header.
        //

        RxPinEaRange( RxContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaHeaderRange,
                       0,
                       sizeof( EA_FILE_HEADER ),
                       RxStatus(DATA_ERROR) );

        EaHeader = (PEA_FILE_HEADER) EaHeaderRange.Data;

        //
        //  Compute the size of the offset table.
        //

        EaNewOffsetVbo = EaHeader->EaBaseTable[0] << Vcb->AllocationSupport.LogOfBytesPerCluster;
        EaOffsetTableSize = EaNewOffsetVbo - BytesPerSector;

        //
        //  Pin down the entire offset table.
        //

        RxPinEaRange( RxContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaOffsetRange,
                       BytesPerSector,
                       EaOffsetTableSize,
                       RxStatus(DATA_ERROR) );

        //
        //  We now look for a valid handle out of the existing offset table.
        //  We start at the last entry and walk backwards.  We stop at the
        //  first unused handle which is preceded by a used handle (or handle
        //  1).
        //
        //  As we walk backwards, we need to remember the file offset of the
        //  cluster which will follow the clusters we add.  We initially
        //  remember the end of the file.  If the end of the offset table
        //  consists of a string of used handles, we remember the offset of
        //  the handle prior to the transition from used to unused handles.
        //

        EaSetClusterOffset = EaFcb->Header.FileSize.LowPart
                             >> Vcb->AllocationSupport.LogOfBytesPerCluster;

        NewEaIndex = (USHORT) ((EaOffsetTableSize >> 1) - 1);

        NextEaOffset = (PUSHORT) EaOffsetRange.Data + NewEaIndex;

        //
        //  Walk through the used handles at the end of the offset table.
        //

        if (*NextEaOffset != UNUSED_EA_HANDLE) {

            while (NewEaIndex != 0) {

                if (*(NextEaOffset - 1) == UNUSED_EA_HANDLE) {

                    //
                    //  If the handle is 1, we take no action.  Otherwise
                    //  we save the cluster offset of the current handle
                    //  knowing we will use a previous handle and insert
                    //  a chain of clusters.
                    //

                    if (NewEaIndex != 1) {

                        EaSetClusterOffset = *NextEaOffset
                                             + EaHeader->EaBaseTable[NewEaIndex >> 7];

                        TailExists = TRUE;
                    }

                    NewEaIndex--;
                    NextEaOffset--;

                    break;
                }

                NewEaIndex--;
                NextEaOffset--;
            }
        }

        //
        //  Walk through looking for the first unused handle in a string
        //  of unused handles.
        //

        while (NewEaIndex) {

            if (*(NextEaOffset - 1) != UNUSED_EA_HANDLE) {

                break;
            }

            NextEaOffset--;
            NewEaIndex--;
        }

        //
        //  If the handle is zero, we do a special test to see if handle 1
        //  is available.  Otherwise we will use the first handle of a new
        //  cluster.  A non-zero handle now indicates that a handle was found
        //  in an existing offset table cluster.
        //

        if (NewEaIndex == 0) {

            if (*(NextEaOffset + 1) == UNUSED_EA_HANDLE) {

                NewEaIndex = 1;

            } else {

                NewEaIndex = (USHORT) EaOffsetTableSize >> 1;
                AddedOffsetTableCluster = TRUE;
            }
        }

        //
        //  If the Ea index is outside the legal range then raise an
        //  exception.
        //

        if (NewEaIndex > MAX_EA_HANDLE) {

            DebugTrace(-1, Dbg,
                       "RxAddEaSet: Illegal handle value for new handle\n", 0);

            RxRaiseStatus( RxContext, RxStatus(INSUFFICIENT_RESOURCES) );
        }

        //
        //  Compute the base and offset indexes.
        //

        EaHeaderIndex = NewEaIndex >> 7;
        EaOffsetIndex = NewEaIndex & (MAX_EA_OFFSET_INDEX - 1);

        //
        //  Compute the byte offset of the new ea data in the file.
        //

        EaSetVbo = EaSetClusterOffset << Vcb->AllocationSupport.LogOfBytesPerCluster;

        //
        //  Allocate all the required disk space together to insure this
        //  operation is atomic.  We don't want to allocate one block
        //  of disk space and then fail on a second allocation.
        //

        EaSetLength = (EaSetLength + BytesPerCluster - 1)
                      & ~(BytesPerCluster - 1);

        NewAllocation = EaSetLength
                        + (AddedOffsetTableCluster ? BytesPerCluster : 0);

        //
        //  Verify that adding these clusters will not grow the Ea file
        //  beyond its legal value.  The maximum number of clusters is
        //  2^16 since the Ea sets are referenced by a 16 bit cluster
        //  offset value.
        //

        if ((ULONG) ((0x0000FFFF << Vcb->AllocationSupport.LogOfBytesPerCluster)
                     - EaFcb->Header.FileSize.LowPart)
            < NewAllocation) {

            DebugTrace(-1, Dbg,
                       "RxAddEaSet: New Ea file size is too large\n", 0);

            RxRaiseStatus( RxContext, RxStatus(INSUFFICIENT_RESOURCES) );
        }

        FsRtlInitializeMcb( &EaSetMcb, PagedPool );

        UnwindInitializedEaSetMcb = TRUE;

        RxAllocateDiskSpace( RxContext,
                              Vcb,
                              0,
                              &NewAllocation,
                              &EaSetMcb );

        UnwindAllocatedNewAllocation = TRUE;

        EaSetClusterCount = (USHORT) (EaSetLength >> Vcb->AllocationSupport.LogOfBytesPerCluster);

        if (AddedOffsetTableCluster) {

            FsRtlInitializeMcb( &EaOffsetMcb, PagedPool );

            UnwindInitializedOffsetMcb = TRUE;

            RxSplitAllocation( RxContext,
                                Vcb,
                                &EaSetMcb,
                                EaSetLength,
                                &EaOffsetMcb );

            UnwindSplitNewAllocation = TRUE;
        }

        RxUnpinEaRange( RxContext, &EaHeaderRange );
        RxUnpinEaRange( RxContext, &EaOffsetRange );

        if (AddedOffsetTableCluster) {

            FileOffset.LowPart = EaNewOffsetVbo;

        } else {

            FileOffset.LowPart = EaSetVbo;
        }

        FileOffset.HighPart = 0;

        //
        //  Round the cache map down to a system page boundary.
        //

        FileOffset.LowPart &= ~(PAGE_SIZE - 1);

        {
            IO_STATUS_BLOCK Iosb;
            ULONG PurgeCount = 5;

            while (--PurgeCount) {

                Iosb.Status = RxStatus(SUCCESS);

                CcFlushCache( VirtualEaFile->SectionObjectPointer,
                              NULL,
                              0,
                              &Iosb );

                ASSERT( Iosb.Status == RxStatus(SUCCESS) );

                //
                //  We throw the unwanted pages out of the cache and then
                //  truncate the Ea File for the new size.
                //
                //

                if (CcPurgeCacheSection( VirtualEaFile->SectionObjectPointer,
                                         &FileOffset,
                                         0,
                                         FALSE )) {

                    break;
                }
            }

            if (!PurgeCount) {

                RxRaiseStatus( RxContext, RxStatus(UNABLE_TO_DELETE_SECTION) );
            }
        }

        UnwindPurgeCacheMap = TRUE;

        FileOffset.LowPart = EaFcb->Header.FileSize.LowPart + NewAllocation;

        //
        //  If there is a tail to the file, then we initialize an Mcb
        //  for the file section and split the tail from the file.
        //

        if (TailExists) {

            FsRtlInitializeMcb( &EaTailMcb, PagedPool );

            UnwindInitializedTailMcb = TRUE;

            RxSplitAllocation( RxContext,
                                Vcb,
                                &EaFcb->Mcb,
                                EaSetVbo,
                                &EaTailMcb );

            UnwindSplitTail = TRUE;
        }

        //
        //  If there is an initial section of ea data, we initialize an
        //  Mcb for that section.
        //

        if (AddedOffsetTableCluster
            && EaSetVbo != EaNewOffsetVbo) {

            FsRtlInitializeMcb( &EaInitialEaMcb, PagedPool );

            UnwindInitializedInitialEaMcb = TRUE;

            RxSplitAllocation( RxContext,
                                Vcb,
                                &EaFcb->Mcb,
                                EaNewOffsetVbo,
                                &EaInitialEaMcb );

            UnwindSplitInitialEa = TRUE;
        }

        //
        //  We have now split the new file allocation into the new
        //  ea set and possibly a new offset table.
        //
        //  We have also split the existing file data into a file
        //  header, an initial section of ea data and the tail of the
        //  file.  These last 2 may not exist.
        //
        //  Each section is described by an Mcb.
        //

        //
        //  Merge the new offset information if it exists.
        //

        if (AddedOffsetTableCluster) {

            RxMergeAllocation( RxContext,
                                Vcb,
                                &EaFcb->Mcb,
                                &EaOffsetMcb );

            FsRtlUninitializeMcb( &EaOffsetMcb );
            FsRtlInitializeMcb( &EaOffsetMcb, PagedPool );

            UnwindMergedNewOffset = TRUE;
        }

        //
        //  Merge the existing initial ea data if it exists.
        //

        if (UnwindInitializedInitialEaMcb) {

            RxMergeAllocation( RxContext,
                                Vcb,
                                &EaFcb->Mcb,
                                &EaInitialEaMcb );

            FsRtlUninitializeMcb( &EaInitialEaMcb );
            FsRtlInitializeMcb( &EaInitialEaMcb, PagedPool );

            UnwindMergedInitialEa = TRUE;
        }

        //
        //  We modify the offset of the new ea set by one cluster if
        //  we added one to the offset table.
        //

        if (AddedOffsetTableCluster) {

            EaSetClusterOffset += 1;
            EaSetVbo += BytesPerCluster;
        }

        //
        //  Merge the new ea set.
        //

        RxMergeAllocation( RxContext,
                            Vcb,
                            &EaFcb->Mcb,
                            &EaSetMcb );

        FsRtlUninitializeMcb( &EaSetMcb );
        FsRtlInitializeMcb( &EaSetMcb, PagedPool );

        UnwindMergedNewEaSet = TRUE;

        //
        //  Merge the tail if it exists.
        //

        if (UnwindInitializedTailMcb) {

            RxMergeAllocation( RxContext,
                                Vcb,
                                &EaFcb->Mcb,
                                &EaTailMcb );

            FsRtlUninitializeMcb( &EaTailMcb );
            FsRtlInitializeMcb( &EaTailMcb, PagedPool );

            UnwindMergedTail = TRUE;
        }

        //
        //  If we added a new cluster for the offset table, we need to
        //  lock the entire cluster down and initialize all the handles to
        //  the unused state except the first one.
        //

        //
        //  Update the Fcb information.
        //

        UnwindPrevFileSize = EaFcb->Header.FileSize.LowPart;

        EaFcb->Header.FileSize.LowPart += NewAllocation;
        EaFcb->Header.AllocationSize = EaFcb->Header.FileSize;
        EaDirent->FileSize = EaFcb->Header.FileSize.LowPart;

        RxSetDirtyBcb( RxContext, EaBcb, Vcb );

        //
        //  Let Mm and Cc know the new file sizes.
        //

        CcSetFileSizes( VirtualEaFile,
                        (PCC_FILE_SIZES)&EaFcb->Header.AllocationSize );

        UnwindPrevFcbValues = TRUE;

        //
        //  Pin down the file header.
        //

        RtlZeroMemory( &EaHeaderRange, sizeof( EA_RANGE ));

        RxPinEaRange( RxContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaHeaderRange,
                       0,
                       sizeof( EA_FILE_HEADER ),
                       RxStatus(DATA_ERROR) );

        EaHeader = (PEA_FILE_HEADER) EaHeaderRange.Data;

        //
        //  Pin down the entire offset table.
        //


        RtlZeroMemory( &EaOffsetRange, sizeof( EA_RANGE ));

        RxPinEaRange( RxContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaOffsetRange,
                       BytesPerSector + ((NewEaIndex >> 7) << 8),
                       sizeof( EA_OFF_TABLE ),
                       RxStatus(DATA_ERROR) );

        EaOffsetTable = (PUSHORT) EaOffsetRange.Data;

        //
        //  Pin the Ea set header for the added clusters and initialize
        //  the fields of interest.  These are the signature field, the
        //  owning handle field, the need Ea field and the cbList field.
        //  Also mark the data as dirty.
        //

        //
        //  Pin the ea set.
        //

        RxPinEaRange( RxContext,
                       VirtualEaFile,
                       EaFcb,
                       EaSetRange,
                       EaSetVbo,
                       EaSetLength,
                       RxStatus(DATA_ERROR) );

        EaSet = (PEA_SET_HEADER) EaSetRange->Data;

        EaSet->Signature = EA_SET_SIGNATURE;
        EaSet->OwnEaHandle = NewEaIndex;

        RxMarkEaRangeDirty( RxContext, VirtualEaFile, EaSetRange );

        //
        //  Update the Ea base and offset tables.  For the Ea base table,
        //  all subsequent index values must be incremented by the number
        //  of clusters added.
        //
        //  For the entries in the relevant Ea offset table, all entries
        //  after this index must also be increased by the number of
        //  clusters added.
        //
        //  If we added another cluster to the offset table, then we increment
        //  all the base table values by 1.
        //

        Count = MAX_EA_BASE_INDEX - EaHeaderIndex - 1;

        NextEaOffset = &EaHeader->EaBaseTable[EaHeaderIndex + 1];

        while (Count--) {

            *(NextEaOffset++) += EaSetClusterCount;
        }

        if (AddedOffsetTableCluster) {

            Count = MAX_EA_BASE_INDEX;

            NextEaOffset = &EaHeader->EaBaseTable[0];

            while (Count--) {

                *(NextEaOffset++) += 1;
            }
        }

        RxMarkEaRangeDirty( RxContext, VirtualEaFile, &EaHeaderRange );

        //
        //  If we added an offset table cluster, we need to initialize
        //  the handles to unused.
        //

        if (AddedOffsetTableCluster) {

            Count = (BytesPerCluster >> 1) - 1;
            NextEaOffset = EaOffsetTable;

            *NextEaOffset++ = 0;

            while (Count--) {

                *NextEaOffset++ = UNUSED_EA_HANDLE;
            }
        }

        //
        //  We need to compute the offset of the added Ea set clusters
        //  from their base.
        //

        NextEaOffset = EaOffsetTable + EaOffsetIndex;

        *NextEaOffset++ = (USHORT) (EaSetClusterOffset
                                    - EaHeader->EaBaseTable[EaHeaderIndex]);

        Count = MAX_EA_OFFSET_INDEX - EaOffsetIndex - 1;

        while (Count--) {

            if (*NextEaOffset != UNUSED_EA_HANDLE) {

                *NextEaOffset += EaSetClusterCount;
            }

            NextEaOffset++;
        }

        RxMarkEaRangeDirty( RxContext, VirtualEaFile, &EaOffsetRange );

        //
        //  Update the callers parameters.
        //

        *EaHandle = NewEaIndex;

        DebugTrace(0, Dbg, "RxAddEaSet: Return values\n", 0);

        DebugTrace(0, Dbg, "RxAddEaSet: New Handle -> %x\n", *EaHandle);

//no longer        DebugTrace(0, Dbg, "RxAddEaSet: EaSetOffset -> %08lx\n", *EaSetOffset);

    } finally {

        DebugUnwind( RxAddEaSet );

        //
        //  Handle cleanup for abnormal termination only if we allocated
        //  disk space for the new ea set.
        //

        if (AbnormalTermination() && UnwindAllocatedNewAllocation) {

            //
            //  If we modified the Ea dirent or Fcb, recover the previous
            //  values.  Even though we are decreasing FileSize here, we
            //  don't need to synchronize to synchronize with paging Io
            //  because there was no dirty data generated in the new allocation.
            //

            if (UnwindPrevFcbValues) {

                EaFcb->Header.FileSize.LowPart = UnwindPrevFileSize;
                EaFcb->Header.AllocationSize.LowPart = UnwindPrevFileSize;
                EaDirent->FileSize = UnwindPrevFileSize;

                CcSetFileSizes( VirtualEaFile,
                                (PCC_FILE_SIZES)&EaFcb->Header.AllocationSize );
            }

            //
            //  If we merged the tail then split it off.
            //

            if (UnwindMergedTail) {

                VBO NewTailPosition;

                NewTailPosition = EaSetVbo + EaSetLength;

                RxSplitAllocation( RxContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    NewTailPosition,
                                    &EaTailMcb );
            }

            //
            //  If we merged the new ea data then split it out.
            //

            if (UnwindMergedNewEaSet) {

                RxSplitAllocation( RxContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    EaSetVbo,
                                    &EaSetMcb );
            }

            //
            //  If we merged the initial ea data then split it out.
            //

            if (UnwindMergedInitialEa) {

                RxSplitAllocation( RxContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    EaNewOffsetVbo + BytesPerCluster,
                                    &EaInitialEaMcb );
            }

            //
            //  If we added a new offset cluster, then split it out.
            //

            if (UnwindMergedNewOffset) {

                RxSplitAllocation( RxContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    EaNewOffsetVbo,
                                    &EaOffsetMcb );
            }

            //
            //  If there is an initial ea section prior to the new section, merge
            //  it with the rest of the file.
            //

            if (UnwindSplitInitialEa) {

                RxMergeAllocation( RxContext, Vcb, &EaFcb->Mcb, &EaInitialEaMcb );
            }

            //
            //  If there is a file tail split off, merge it with the
            //  rest of the file.
            //

            if (UnwindSplitTail) {

                RxMergeAllocation( RxContext, Vcb, &EaFcb->Mcb, &EaTailMcb );
            }

            //
            //  If we modified the cache initialization for the ea file,
            //  then throw away the ea file object.
            //

            if (UnwindPurgeCacheMap) {

                Vcb->VirtualEaFile = NULL;
                ObDereferenceObject( VirtualEaFile );
            }

            //
            //  If we split the allocation, then deallocate the block for
            //  the new offset information.
            //

            if (UnwindSplitNewAllocation) {

                RxDeallocateDiskSpace( RxContext, Vcb, &EaOffsetMcb );
            }

            //
            //  Deallocate the disk space.
            //

            RxDeallocateDiskSpace( RxContext, Vcb, &EaSetMcb );
        }

        //
        //  Unpin the Ea ranges.
        //

        RxUnpinEaRange( RxContext, &EaHeaderRange );
        RxUnpinEaRange( RxContext, &EaOffsetRange );

        //
        //  Uninitialize any local Mcbs
        //

        if (UnwindInitializedEaSetMcb) {

            FsRtlUninitializeMcb( &EaSetMcb );
        }

        if (UnwindInitializedOffsetMcb) {

            FsRtlUninitializeMcb( &EaOffsetMcb );
        }

        if (UnwindInitializedTailMcb) {

            FsRtlUninitializeMcb( &EaTailMcb );
        }

        if (UnwindInitializedInitialEaMcb) {

            FsRtlUninitializeMcb( &EaInitialEaMcb );
        }

        DebugTrace(-1, Dbg, "RxAddEaSet ->  Exit\n", 0);
    }

    return;
}


VOID
RxAppendPackedEa (
    IN PRX_CONTEXT RxContext,
    IN OUT PEA_SET_HEADER *EaSetHeader,
    IN OUT PULONG PackedEasLength,
    IN OUT PULONG AllocationLength,
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN ULONG BytesPerCluster
    )

/*++

Routine Description:

    This routine appends a new packed ea onto an existing packed ea list,
    it also will allocate/dealloate pool as necessary to hold the ea list.

Arguments:

    EaSetHeader - Supplies the address to store the pointer to pool memory
                  which contains the Ea list for a file.

    PackedEasLength - Supplies the length of the actual Ea data.  The
                      new Ea data will be appended at this point.

    AllocationLength - Supplies the allocated length available for Ea
                       data.

    FullEa - Supplies a pointer to the new full ea that is to be appended
             (in packed form) to the packed ea list.

    BytesPerCluster - Number of bytes per cluster on this volume.

    NOTE: The EaSetHeader refers to the entire block of Ea data for a
          file.  This includes the Ea's and their values as well as the
          header information.  The PackedEasLength and AllocationLength
          parameters refer to the name/value pairs only.

Return Value:

    None.

--*/

{
    ULONG PackedEaSize;
    PPACKED_EA ThisPackedEa;
    OEM_STRING EaName;

    DebugTrace(+1, Dbg, "RxAppendPackedEa...\n", 0);

    //
    //  As a quick check see if the computed packed ea size plus the
    //  current packed ea list size will overflow the buffer.  Full Ea and
    //  packed Ea only differ by 4 in their size
    //

    PackedEaSize = SizeOfFullEa( FullEa ) - 4;

    if ( PackedEaSize + *PackedEasLength > *AllocationLength ) {

        //
        //  We will overflow our current work buffer so allocate a larger
        //  one and copy over the current buffer
        //

        PVOID Temp;
        ULONG NewAllocationSize;
        ULONG OldAllocationSize;

        DebugTrace(0, Dbg, "Allocate a new ea list buffer\n", 0);

        //
        //  Compute a new size and allocate space.  Always increase the
        //  allocation in cluster increments.
        //

        NewAllocationSize = (SIZE_OF_EA_SET_HEADER
                             + PackedEaSize
                             + *PackedEasLength
                             + BytesPerCluster - 1)
                            & ~(BytesPerCluster - 1);

        Temp = FsRtlAllocatePool( PagedPool, NewAllocationSize );

        //
        //  Move over the existing ea list, and deallocate the old one
        //

        RtlCopyMemory( Temp,
                       *EaSetHeader,
                       OldAllocationSize = *AllocationLength
                                           + SIZE_OF_EA_SET_HEADER );

        ExFreePool( *EaSetHeader );

        //
        //  Set up so we will use the new packed ea list
        //

        *EaSetHeader = Temp;

        //
        //  Zero out the added memory.
        //

        RtlZeroMemory( &(*EaSetHeader)->PackedEas[*AllocationLength],
                       NewAllocationSize - OldAllocationSize );

        *AllocationLength = NewAllocationSize - SIZE_OF_EA_SET_HEADER;
    }

    //
    //  Determine if we need to increment our need ea changes count
    //

    if ( FlagOn(FullEa->Flags, FILE_NEED_EA )) {

        //
        //  The NeedEaCount field is long aligned so we will write
        //  directly to it.
        //

        (*EaSetHeader)->NeedEaCount++;
    }

    //
    //  Now copy over the ea, full ea's and packed ea are identical except
    //  that full ea also have a next ea offset that we skip over
    //
    //  Before:
    //             UsedSize                     Allocated
    //                |                             |
    //                V                             V
    //      +xxxxxxxx+-----------------------------+
    //
    //  After:
    //                              UsedSize    Allocated
    //                                 |            |
    //                                 V            V
    //      +xxxxxxxx+yyyyyyyyyyyyyyyy+------------+
    //

    ThisPackedEa = (PPACKED_EA) (RtlOffsetToPointer( (*EaSetHeader)->PackedEas,
                                                     *PackedEasLength ));

    RtlCopyMemory( ThisPackedEa,
                   (PUCHAR) FullEa + 4,
                   PackedEaSize );

    //
    //  Now convert the name to uppercase.
    //

    EaName.MaximumLength = EaName.Length = FullEa->EaNameLength;
    EaName.Buffer = ThisPackedEa->EaName;

    RxUpcaseEaName( RxContext, &EaName, &EaName );

    //
    //  Increment the used size in the packed ea list structure
    //

    *PackedEasLength += PackedEaSize;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "RxAppendPackedEa -> VOID\n", 0);

    UNREFERENCED_PARAMETER( RxContext );

    return;
}


VOID
RxDeletePackedEa (
    IN PRX_CONTEXT RxContext,
    IN OUT PEA_SET_HEADER EaSetHeader,
    IN OUT PULONG PackedEasLength,
    IN ULONG Offset
    )

/*++

Routine Description:

    This routine deletes an individual packed ea from the supplied
    packed ea list.

Arguments:

    EaSetHeader - Supplies the address to store the pointer to pool memory
                  which contains the Ea list for a file.

    PackedEasLength - Supplies the length of the actual Ea data.  The
                      new Ea data will be appended at this point.

    Offset - Supplies the offset to the individual ea in the list to delete

    NOTE: The EaSetHeader refers to the entire block of Ea data for a
          file.  This includes the Ea's and their values as well as the
          header information.  The PackedEasLength parameter refer to the
          name/value pairs only.

Return Value:

    None.

--*/

{
    PPACKED_EA PackedEa;
    ULONG PackedEaSize;

    DebugTrace(+1, Dbg, "RxDeletePackedEa, Offset = %08lx\n", Offset);

    //
    //  Get a reference to the packed ea and figure out its size
    //

    PackedEa = (PPACKED_EA) (&EaSetHeader->PackedEas[Offset]);

    SizeOfPackedEa( PackedEa, &PackedEaSize );

    //
    //  Determine if we need to decrement our need ea changes count
    //

    if (FlagOn(PackedEa->Flags, EA_NEED_EA_FLAG)) {

        EaSetHeader->NeedEaCount--;
    }

    //
    //  Shrink the ea list over the deleted ea.  The amount to copy is the
    //  total size of the ea list minus the offset to the end of the ea
    //  we're deleting.
    //
    //  Before:
    //              Offset    Offset+PackedEaSize      UsedSize    Allocated
    //                |                |                  |            |
    //                V                V                  V            V
    //      +xxxxxxxx+yyyyyyyyyyyyyyyy+zzzzzzzzzzzzzzzzzz+------------+
    //
    //  After
    //              Offset            UsedSize                     Allocated
    //                |                  |                             |
    //                V                  V                             V
    //      +xxxxxxxx+zzzzzzzzzzzzzzzzzz+-----------------------------+
    //

    RtlCopyMemory( PackedEa,
                   (PUCHAR) PackedEa + PackedEaSize,
                   *PackedEasLength - (Offset + PackedEaSize) );

    //
    //  And zero out the remaing part of the ea list, to make things
    //  nice and more robust
    //

    RtlZeroMemory( &EaSetHeader->PackedEas[*PackedEasLength - PackedEaSize],
                   PackedEaSize );

    //
    //  Decrement the used size by the amount we just removed
    //

    *PackedEasLength -= PackedEaSize;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "RxDeletePackedEa -> VOID\n", 0);

    UNREFERENCED_PARAMETER( RxContext );

    return;
}


ULONG
RxLocateNextEa (
    IN PRX_CONTEXT RxContext,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    IN ULONG PreviousOffset
    )

/*++

Routine Description:

    This routine locates the offset for the next individual packed ea
    inside of a packed ea list, given the offset to a previous Ea.
    Instead of returing boolean to indicate if we've found the next one
    we let the return offset be so large that it overuns the used size
    of the packed ea list, and that way it's an easy construct to use
    in a for loop.

Arguments:

    FirstPackedEa - Supplies a pointer to the packed ea list structure

    PackedEasLength - Supplies the length of the packed ea list

    PreviousOffset - Supplies the offset to a individual packed ea in the
        list

Return Value:

    ULONG - The offset to the next ea in the list or 0xffffffff of one
        does not exist.

--*/

{
    PPACKED_EA PackedEa;
    ULONG PackedEaSize;
    ULONG Offset;

    DebugTrace(+1, Dbg, "RxLocateNextEa, PreviousOffset = %08lx\n",
               PreviousOffset);

    //
    //  Make sure the previous offset is within the used size range
    //

    if ( PreviousOffset >= PackedEasLength ) {

        DebugTrace(-1, Dbg, "RxLocateNextEa -> 0xffffffff\n", 0);
        return 0xffffffff;
    }

    //
    //  Get a reference to the previous packed ea, and compute its size
    //

    PackedEa = (PPACKED_EA) ((PUCHAR) FirstPackedEa + PreviousOffset );
    SizeOfPackedEa( PackedEa, &PackedEaSize );

    //
    //  Compute to the next ea
    //

    Offset = PreviousOffset + PackedEaSize;

    //
    //  Now, if the new offset is beyond the ea size then we know
    //  that there isn't one so, we return an offset of 0xffffffff.
    //  otherwise we'll leave the new offset alone.
    //

    if ( Offset >= PackedEasLength ) {

        Offset = 0xffffffff;
    }

    DebugTrace(-1, Dbg, "RxLocateNextEa -> %08lx\n", Offset);

    UNREFERENCED_PARAMETER( RxContext );

    return Offset;
}


BOOLEAN
RxLocateEaByName (
    IN PRX_CONTEXT RxContext,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    IN POEM_STRING EaName,
    OUT PULONG Offset
    )

/*++

Routine Description:

    This routine locates the offset for the next individual packed ea
    inside of a packed ea list, given the name of the ea to locate

Arguments:

    FirstPackedEa - Supplies a pointer to the packed ea list structure

    PackedEasLength - Supplies the length of the packed ea list

    EaName - Supplies the name of the ea search for

    Offset - Receives the offset to the located individual ea in the list
        if one exists.

Return Value:

    BOOLEAN - TRUE if the named packed ea exists in the list and FALSE
        otherwise.

--*/

{
    PPACKED_EA PackedEa;
    OEM_STRING Name;

    DebugTrace(+1, Dbg, "RxLocateEaByName, EaName = %wZ\n", EaName);

    //
    //  For each packed ea in the list check its name against the
    //  ea name we're searching for
    //

    for ( *Offset = 0;
          *Offset < PackedEasLength;
          *Offset = RxLocateNextEa( RxContext,
                                     FirstPackedEa,
                                     PackedEasLength,
                                     *Offset )) {

        //
        //  Reference the packed ea and get a string to its name
        //

        PackedEa = (PPACKED_EA) ((PUCHAR) FirstPackedEa + *Offset);

        Name.Buffer = &PackedEa->EaName[0];
        Name.Length = PackedEa->EaNameLength;
        Name.MaximumLength = PackedEa->EaNameLength;

        //
        //  Compare the two strings, if they are equal then we've
        //  found the caller's ea
        //

        if ( RtlCompareString( EaName, &Name, TRUE ) == 0 ) {

            DebugTrace(-1, Dbg, "RxLocateEaByName -> TRUE, *Offset = %08lx\n", *Offset);
            return TRUE;
        }
    }

    //
    //  We've exhausted the ea list without finding a match so return false
    //

    DebugTrace(-1, Dbg, "RxLocateEaByName -> FALSE\n", 0);
    return FALSE;
}


BOOLEAN
RxIsEaNameValid (
    IN PRX_CONTEXT RxContext,
    IN OEM_STRING Name
    )

/*++

Routine Description:

    This routine simple returns whether the specified file names conforms
    to the file system specific rules for legal Ea names.

    For Ea names, the following rules apply:

    A. An Ea name may not contain any of the following characters:

       0x0000 - 0x001F  \ / : * ? " < > | , + = [ ] ;

Arguments:

    Name - Supllies the name to check.

Return Value:

    BOOLEAN - TRUE if the name is legal, FALSE otherwise.

--*/

{
    ULONG Index;

    UCHAR Char;

    //
    //  Empty names are not valid.
    //

    if ( Name.Length == 0 ) { return FALSE; }

    //
    //  At this point we should only have a single name, which can't have
    //  more than 254 characters
    //

    if ( Name.Length > 254 ) { return FALSE; }

    for ( Index = 0; Index < (ULONG)Name.Length; Index += 1 ) {

        Char = Name.Buffer[ Index ];

        //
        //  Skip over and Dbcs chacters
        //

        if ( FsRtlIsLeadDbcsCharacter( Char ) ) {

            ASSERT( Index != (ULONG)(Name.Length - 1) );

            Index += 1;

            continue;
        }

        //
        //  Make sure this character is legal, and if a wild card, that
        //  wild cards are permissible.
        //

        if ( !FsRtlIsAnsiCharacterLegalFat(Char, FALSE) ) {

            return FALSE;
        }
    }

    return TRUE;
}


VOID
RxPinEaRange (
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT VirtualEaFile,
    IN PFCB EaFcb,
    IN OUT PEA_RANGE EaRange,
    IN ULONG StartingVbo,
    IN ULONG Length,
    IN RXSTATUS ErrorStatus
    )

/*++

Routine Description:

    This routine is called to pin a range within the Ea file.  It will follow all the
    rules required by the cache manager so that we don't have overlapping pin operations.
    If the range being pinned spans a section then the desired data will be copied into
    an auxilary buffer.  RxMarkEaRangeDirty will know whether to copy the data back
    into the cache or whether to simply mark the pinned data dirty.

Arguments:

    VirtualEaFile - This is the stream file for the Ea file.

    EaFcb - This is the Fcb for the Ea file.

    EaRange - This is the Ea range structure for this request.

    StartingVbo - This is the starting offset in the Ea file to read from.

    Length - This is the length of the read.

    ErrorStatus - This is the error status to use if we are reading outside
        of the file.

Return Value:

    None.

--*/

{
    LARGE_INTEGER LargeVbo;
    ULONG ByteCount;
    PBCB *NextBcb;
    PVOID Buffer;
    PCHAR DestinationBuffer;
    BOOLEAN FirstPage = TRUE;

    //
    //  Verify that the entire read is contained within the Ea file.
    //

    if (Length == 0
        || StartingVbo >= EaFcb->Header.AllocationSize.LowPart
        || (EaFcb->Header.AllocationSize.LowPart - StartingVbo) < Length) {

        RxRaiseStatus( RxContext, ErrorStatus );
    }

    //
    //  If the read will span a section, the system addresses may not be contiguous.
    //  Allocate a separate buffer in this case.
    //

    if (((StartingVbo & (EA_SECTION_SIZE - 1)) + Length) > EA_SECTION_SIZE) {

        EaRange->Data = FsRtlAllocatePool( PagedPool, Length );
        EaRange->AuxilaryBuffer = TRUE;

        DestinationBuffer = EaRange->Data;
    }

    //
    //  If the read will require more pages than our structure will hold then
    //  allocate an auxilary buffer.  We have to figure the number of pages
    //  being requested so we have to include the page offset of the first page of
    //  the request.
    //

    EaRange->BcbChainLength = (USHORT) (((StartingVbo & (PAGE_SIZE - 1)) + Length + PAGE_SIZE - 1) / PAGE_SIZE);

    if (EaRange->BcbChainLength > EA_BCB_ARRAY_SIZE) {

        EaRange->BcbChain = FsRtlAllocatePool( PagedPool, sizeof( PBCB ) * EaRange->BcbChainLength );
        RtlZeroMemory( EaRange->BcbChain, sizeof( PBCB ) * EaRange->BcbChainLength );

    } else {

        EaRange->BcbChain = (PBCB *) &EaRange->BcbArray;
    }

    //
    //  Store the byte range data in the Ea Range structure.
    //

    EaRange->StartingVbo = StartingVbo;
    EaRange->Length = Length;

    //
    //  Compute the initial pin length.
    //

    ByteCount = PAGE_SIZE - (StartingVbo & (PAGE_SIZE - 1));

    //
    //  For each page in the range; pin the page and update the Bcb count, copy to
    //  the auxiliary buffer.
    //

    NextBcb = EaRange->BcbChain;

    while (Length != 0) {

        //
        //  Pin the page and remember the data start.
        //

        LargeVbo.QuadPart = StartingVbo;

        if (ByteCount > Length) {

            ByteCount = Length;
        }

        if (!CcPinRead( VirtualEaFile,
                        &LargeVbo,
                        ByteCount,
                        BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT),
                        NextBcb,
                        &Buffer )) {

            //
            // Could not read the data without waiting (cache miss).
            //

            RxRaiseStatus( RxContext, RxStatus(CANT_WAIT) );
        }

        //
        //  Increment the Bcb pointer and copy to the auxilary buffer if necessary.
        //

        NextBcb += 1;

        if (EaRange->AuxilaryBuffer == TRUE) {

            RtlCopyMemory( DestinationBuffer,
                           Buffer,
                           ByteCount );

            DestinationBuffer = (PCHAR) Add2Ptr( DestinationBuffer, ByteCount );
        }

        StartingVbo += ByteCount;
        Length -= ByteCount;

        //
        //  If this is the first page then update the Ea Range structure.
        //

        if (FirstPage) {

            FirstPage = FALSE;
            ByteCount = PAGE_SIZE;

            if (EaRange->AuxilaryBuffer == FALSE) {

                EaRange->Data = Buffer;
            }
        }
    }

    return;
}


VOID
RxMarkEaRangeDirty (
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT EaFileObject,
    IN OUT PEA_RANGE EaRange
    )

/*++

Routine Description:

    This routine is called to mark a range of the Ea file as dirty.  If the modified
    data is sitting in an auxilary buffer then we will copy it back into the cache.
    In any case we will go through the list of Bcb's and mark them dirty.

Arguments:

    EaFileObject - This is the file object for the Ea file.

    EaRange - This is the Ea range structure for this request.

Return Value:

    None.

--*/

{
    PBCB *NextBcb;
    ULONG BcbCount;

    //
    //  If there is an auxilary buffer we need to copy the data back into the cache.
    //

    if (EaRange->AuxilaryBuffer == TRUE) {

        LARGE_INTEGER LargeVbo;

        LargeVbo.QuadPart = EaRange->StartingVbo;

        CcCopyWrite( EaFileObject,
                     &LargeVbo,
                     EaRange->Length,
                     TRUE,
                     EaRange->Data );
    }

    //
    //  Now walk through the Bcb chain and mark everything dirty.
    //

    BcbCount = EaRange->BcbChainLength;
    NextBcb = EaRange->BcbChain;

    while (BcbCount--) {

        if (*NextBcb != NULL) {

            CcSetDirtyPinnedData( *NextBcb, NULL );
        }

        NextBcb += 1;
    }

    return;
}


VOID
RxUnpinEaRange (
    IN PRX_CONTEXT RxContext,
    IN OUT PEA_RANGE EaRange
    )

/*++

Routine Description:

    This routine is called to unpin a range in the Ea file.  Any structures allocated
    will be deallocated here.

Arguments:

    EaRange - This is the Ea range structure for this request.

Return Value:

    None.

--*/

{
    PBCB *NextBcb;
    ULONG BcbCount;

    //
    //  If we allocated a auxilary buffer, deallocate it here.
    //

    if (EaRange->AuxilaryBuffer == TRUE) {

        ExFreePool( EaRange->Data );
        EaRange->AuxilaryBuffer = FALSE;
    }

    //
    //  Walk through the Bcb chain and unpin the data.
    //

    if (EaRange->BcbChain != NULL) {

        BcbCount = EaRange->BcbChainLength;
        NextBcb = EaRange->BcbChain;

        while (BcbCount--) {

            if (*NextBcb != NULL) {

                CcUnpinData( *NextBcb );
                *NextBcb = NULL;
            }

            NextBcb += 1;
        }

        //
        //  If we allocated a Bcb chain, deallocate it here.
        //

        if (EaRange->BcbChain != &EaRange->BcbArray[0]) {

            ExFreePool( EaRange->BcbChain );
        }

        EaRange->BcbChain = NULL;
    }

    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\dsmount.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFFER_LENGTH 128

//
//  This program is a hack until we have a proper GUI interface for mounting
//  double space volumes.
//
//  davidgoe [David Goebel]   Oct 11, 1993.
//

VOID
__cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    UCHAR DasdName[7] = "\\\\.\\";
    UCHAR HostDrive[3];
    UCHAR OemBuffer[13] = "DBLSPACE.";
    ULONG SequenceNumber = 0;
    BOOLEAN SetHostDrive = FALSE;

    HANDLE Handle;

    UCHAR TmpBuffer[BUFFER_LENGTH];
    ULONG Length, i;

    //
    //  Extract the parameters and check their validity.
    //

    if ((argc < 2) || (argc > 6) || ((argc & 1) != 0)) {

parameter_error:

        printf("Syntax - %s Drive: [-h HostDrive:] [-s SequenceNumber]\n", argv[0]);
        return;
    }

    argv[1][0] = toupper(argv[1][0]);

    DasdName[4] = argv[1][0];
    DasdName[5] = argv[1][1];
    DasdName[6] = argv[1][2];

    if ((DasdName[4] < 'A') || (DasdName[4] > 'Z') ||
        (DasdName[5] != ':') ||
        (DasdName[6] != 0)) {

        goto parameter_error;
    }

    //  temp, reject floppies.
/*
    if (DasdName[4] < 'C') {

        printf("%s does not currently support floppies.\n", argv[0]);
        return;
    }
 */
    for (i = 2; i < (ULONG)argc; i+=2) {

        if (argv[2][0] != '-') {

            goto parameter_error;

        } else {

            PUCHAR LeftOver;

            if (argv[i][2] != 0) {

                goto parameter_error;
            }

            switch(argv[i][1]) {
            case 'h':
            case 'H':

                argv[i+1][0] = toupper(argv[i+1][0]);
                strncpy(HostDrive, argv[i+1], 3);

                if ((HostDrive[0] < 'A') || (HostDrive[0] > 'Z') ||
                    (HostDrive[1] != ':') ||
                    (HostDrive[2] != 0)) {

                    printf("Illegal argument for 'HostDrive:' of %s.\n\n", argv[i+1]);
                    goto parameter_error;
                }

                SetHostDrive = TRUE;
                break;

            case 's':
            case 'S':

                SequenceNumber = strtol(argv[i+1], &LeftOver, 10);

                if (*LeftOver != 0) {

                    printf("Illegal argument for 'SequenceNumber:' of %s.\n\n", argv[i+1]);
                    goto parameter_error;
                }

                if (SequenceNumber > 254) {

                    printf("Sequnce number must be in the range 0-254.\n");
                    goto parameter_error;
                }
                break;

            default:

                printf("Illegal option %s specifed.\n", argv[i]);
                goto parameter_error;
            }
        }
    }

    //
    //  First check for a conflict on the host drive letter.
    //

    if (SetHostDrive && (QueryDosDevice(HostDrive, &TmpBuffer[0], BUFFER_LENGTH) != 0)) {

        printf("Conflict with host drive.  Drive %s already exists.\n", HostDrive);
        goto parameter_error;
    }

    //
    //  Try to open the drive DASD.
    //

    Handle = CreateFile( DasdName,
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         0 );

    if (Handle == INVALID_HANDLE_VALUE) {

        printf("Open of %s failed with error %d.\n", argv[1], GetLastError());
        printf("You must be administrator to run dsmount.\n");

        return;
    }

    //
    //  Now build the unicode filename and attempt the mount.
    //

    {
        OEM_STRING OemCvfName;
        UNICODE_STRING UnicodeCvfName;

        PFILE_MOUNT_DBLS_BUFFER MountFsctl;
        UCHAR MountBuffer[sizeof(FILE_MOUNT_DBLS_BUFFER) + 12*sizeof(WCHAR)];

        RXSTATUS Status;
        IO_STATUS_BLOCK IoStatus;

        MountFsctl = (PFILE_MOUNT_DBLS_BUFFER)MountBuffer;

        sprintf(&OemBuffer[9], "%03d", SequenceNumber);

        OemCvfName.Length =
        OemCvfName.MaximumLength = 12;
        OemCvfName.Buffer = OemBuffer;

        UnicodeCvfName.MaximumLength = 13*sizeof(WCHAR);
        UnicodeCvfName.Buffer = &MountFsctl->CvfName[0];

        Status = RtlOemStringToUnicodeString( &UnicodeCvfName, &OemCvfName, FALSE );

        if (!NT_SUCCESS(Status)) {

            printf("Unicode conversion failed with error 0x%08lx.\n", Status);
            CloseHandle( Handle);
            return;
        }

        MountFsctl->CvfNameLength = UnicodeCvfName.Length;

        //
        //  Now issue the DevIoCtrl.
        //

        Status = NtFsControlFile( Handle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatus,
                                  FSCTL_MOUNT_DBLS_VOLUME,
                                  MountFsctl,
                                  64,
                                  NULL,
                                  0 );

        if (!NT_SUCCESS(Status) || !NT_SUCCESS(IoStatus.Status)) {

            if (NT_SUCCESS(Status)) {

                Status = IoStatus.Status;
            }

            printf("Mount failed with error 0x%08lx.\n", Status);
            CloseHandle( Handle);
            return;
        }
    }

    CloseHandle( Handle);

    //
    //  First get the original base name.
    //

    Length = QueryDosDevice(argv[1], &TmpBuffer[0], BUFFER_LENGTH);

    //
    //  Now make the host drive link.
    //

    if (SetHostDrive && !DefineDosDevice( DDD_RAW_TARGET_PATH, &HostDrive[0], &TmpBuffer[0] )) {

        printf("Create Host Drive Failed with error: %d\n", GetLastError());
        return;
    }

    //
    //  and finally create the compressed drive link.
    //

    TmpBuffer[Length-2] = '.';

    RtlCopyMemory( &TmpBuffer[Length-1], OemBuffer, 13 );

    if (!DefineDosDevice( DDD_RAW_TARGET_PATH, argv[1], &TmpBuffer[0] )) {

        printf("Create Compressed Drive Failed with error: %d\n", GetLastError());
        return;
    }

    //
    //  Tell the user what we did.
    //

    printf("The compressed volume file %s\\DBLSPACE.%03d was mounted as %s.\n",
           argv[1], SequenceNumber, argv[1]);

    if (SetHostDrive) {

        printf("The host drive %s contains the original uncompressed volume.\n",
               HostDrive);

    } else {

        printf("No host drive was specified, thus none was created.\n");
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\mrcf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Mrcf.h

Abstract:

    This module defines all of the double space compression routines

Author:

    Gary Kimura     [GaryKi]    03-Jun-1993

Revision History:

--*/

#ifndef _MRCF_
#define _MRCF_

//
//  To decompress/compress a block of data the user needs to
//  provide a work space as an extra parameter to all the exported
//  procedures.  That way the routines will not need to use excessive
//  stack space and will still be multithread safe
//

//
//  Variables for reading and writing bits
//

typedef struct _MRCF_BIT_IO {

    USHORT  abitsBB;        //  16-bit buffer being read
    LONG    cbitsBB;        //  Number of bits left in abitsBB

    PUCHAR  pbBB;           //  Pointer to byte stream being read
    ULONG   cbBB;           //  Number of bytes left in pbBB
    ULONG   cbBBInitial;    //  Initial size of pbBB

} MRCF_BIT_IO;
typedef MRCF_BIT_IO *PMRCF_BIT_IO;

//
//  Decompression only needs the bit i/o structure
//

typedef struct _MRCF_DECOMPRESS {

    MRCF_BIT_IO BitIo;

} MRCF_DECOMPRESS;
typedef MRCF_DECOMPRESS *PMRCF_DECOMPRESS;

//
//  Standard compression uses a few more field to contain
//  the lookup table
//

#define cMAXSLOTS   (8)             //  The maximum number of slots used in the algorithm

#define ltUNUSED    (0xE000)        //  Value of unused ltX table entry
#define mruUNUSED   (0xFF)          //  Value of unused MRU table entry
#define bRARE       (0xD5)          //  Rarely occuring character value

typedef struct _MRCF_STANDARD_COMPRESS {

    MRCF_BIT_IO BitIo;

    ULONG   ltX[256][cMAXSLOTS];    //  Source text pointer look-up table
    UCHAR   abChar[256][cMAXSLOTS]; //  Character look-up table
    UCHAR   abMRUX[256];            //  Most Recently Used ltX/abChar entry

} MRCF_STANDARD_COMPRESS;
typedef MRCF_STANDARD_COMPRESS *PMRCF_STANDARD_COMPRESS;

ULONG
MrcfDecompress (
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PUCHAR CompressedBuffer,
    ULONG CompressedLength,
    PMRCF_DECOMPRESS WorkSpace
    );

ULONG
MrcfStandardCompress (
    PUCHAR CompressedBuffer,
    ULONG CompressedLength,
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PMRCF_STANDARD_COMPRESS WorkSpace
    );

#endif // _MRCF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\lfn.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Lfn.h

Abstract:

    This module defines the on-disk structure of long file names on RDBSS.

Author:

    David Goebel    [davidgoe]  16-Dec-1993

Revision History:

--*/

#ifndef _LFN_
#define _LFN_

//
//  This strucure defines the on disk format on long file name dirents.
//

typedef struct _PACKED_LFN_DIRENT {
    UCHAR     Ordinal;    //  offset =  0
    UCHAR     Name1[10];  //  offset =  1 (Really 5 chars, but not WCHAR aligned)
    UCHAR     Attributes; //  offset = 11
    UCHAR     Type;       //  offset = 12
    UCHAR     Checksum;   //  offset = 13
    WCHAR     Name2[6];   //  offset = 14
    RDBSS_ENTRY MustBeZero; //  offset = 26
    WCHAR     Name3[2];   //  offset = 28
} PACKED_LFN_DIRENT;      //  sizeof = 32
typedef PACKED_LFN_DIRENT *PPACKED_LFN_DIRENT;

#define RDBSS_LAST_LONG_ENTRY             0x40 // Ordinal field
#define RDBSS_LONG_NAME_COMP              0x0  // Type field

//
//  A packed lfn dirent is already quadword aligned so simply declare a
//  lfn dirent as a packed lfn dirent.
//

typedef PACKED_LFN_DIRENT LFN_DIRENT;
typedef LFN_DIRENT *PLFN_DIRENT;

//
//  This is the largest size buffer we would ever need to read an Lfn
//

#define MAX_LFN_CHARACTERS              260
#define MAX_LFN_DIRENTS                 20

#define RDBSS_LFN_DIRENTS_NEEDED(NAME) (((NAME)->Length/sizeof(WCHAR) + 12)/13)

#endif // _LFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\obsolete.h ===
//joejoe stuff in here is obsolete and will be removed in time.........
#define REPINNED_BCBS_ARRAY_SIZE         (4)

typedef struct _REPINNED_BCBS {

    //
    //  A pointer to the next structure contains additional repinned bcbs
    //

    struct _REPINNED_BCBS *Next;

    //
    //  A fixed size array of pinned bcbs.  Whenever a new bcb is added to
    //  the repinned bcb structure it is added to this array.  If the
    //  array is already full then another repinned bcb structure is allocated
    //  and pointed to with Next.
    //

    PBCB Bcb[ REPINNED_BCBS_ARRAY_SIZE ];

} REPINNED_BCBS;
typedef REPINNED_BCBS *PREPINNED_BCBS;



//
//  The Vcb (Volume control Block) record corresponds to every volume mounted
//  by the file system.  They are ordered in a queue off of RxData.VcbQueue.
//  This structure must be allocated from non-paged pool
//

typedef enum _VCB_CONDITION {
    VcbGood = 1,
    VcbNotMounted
} VCB_CONDITION;


typedef struct _VCB {

    //
    //  The type and size of this record (must be RDBSS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The links for the device queue off of RxData.VcbQueue
    //

    LIST_ENTRY VcbLinks;

    //
    //  A pointer the device object passed in by the I/O system on a mount
    //  This is the target device object that the file system talks to when it
    //  needs to do any I/O (e.g., the disk stripper device object).
    //
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  A pointer to the VPB for the volume passed in by the I/O system on
    //  a mount.
    //

    PVPB Vpb;

    //
    //  The internal state of the device.  This is a collection of fsd device
    //  state flags.
    //

    ULONG VcbState;
    VCB_CONDITION VcbCondition;

    //
    //  A pointer to the root DCB for this volume
    //

    struct _FCB *RootDcb;

    //
    //  A count of the number of file objects that have opened the volume
    //  for direct access, and their share access state.
    //

    CLONG DirectAccessOpenCount;
    SHARE_ACCESS ShareAccess;

    //
    //  A count of the number of file objects that have any file/directory
    //  opened on this volume, not including direct access.  And also the
    //  count of the number of file objects that have a file opened for
    //  only read access (i.e., they cannot be modifying the disk).
    //

    CLONG OpenFileCount;
    CLONG ReadOnlyCount;

    //
    //  The bios parameter block field contains
    //  an unpacked copy of the bpb for the volume, it is initialized
    //  during mount time and can be read by everyone else after that.
    //

    BIOS_PARAMETER_BLOCK Bpb;

    //
    //  The following structure contains information useful to the
    //  allocation support routines.  Many of them are computed from
    //  elements of the Bpb, but are too involved to recompute every time
    //  they are needed.
    //

    struct {

        ULONG RootDirectoryLbo;     // Lbo of beginning of root directory
        ULONG RootDirectorySize;    // size of root directory in bytes

        ULONG FileAreaLbo;          // Lbo of beginning of file area

        ULONG NumberOfClusters;     // total number of clusters on the volume
        ULONG NumberOfFreeClusters; // number of free clusters on the volume

        UCHAR RxIndexBitSize;      // indicates if 12 or 16 bit rx table

        UCHAR LogOfBytesPerSector;  // Log(Bios->BytesPerSector)
        UCHAR LogOfBytesPerCluster; // Log(Bios->SectorsPerCluster)

    } AllocationSupport;

    //
    //  The following Mcb is used to keep track of dirty sectors in the Rx.
    //  Runs of holes denote clean sectors while runs of LBO == VBO denote
    //  dirty sectors.  The VBOs are that of the volume file, starting at
    //  0.  The granuality of dirt is one sectors, and additions are only
    //  made in sector chunks to prevent problems with several simultaneous
    //  updaters.
    //

    MCB DirtyRxMcb;

    //
    //  The FreeClusterBitMap keeps track of all the clusters in the rx.
    //  A 1 means occupied while a 0 means free.  It allows quick location
    //  of contiguous runs of free clusters.  It is initialized on mount
    //  or verify.
    //

    RTL_BITMAP FreeClusterBitMap;

    //
    //  The following event controls access to the free cluster bit map
    //

    KEVENT FreeClusterBitMapEvent;

    //
    //  A resource variable to control access to the volume specific data
    //  structures
    //

    ERESOURCE Resource;

    //
    //  The following field points to the file object used to do I/O to
    //  the virtual volume file.  The virtual volume file maps sectors
    //  0 through the end of rx and is of a fixed size (determined during
    //  mount)
    //

    PFILE_OBJECT VirtualVolumeFile;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SectionObjectPointers;

    //
    //  The following fields is a hint cluster index used by the file system
    //  when allocating a new cluster.
    //

    ULONG ClusterHint;

    //
    //  This field will point to a double space control block if this Vcb
    //  is a DoubleSpace volume.
    //

    struct _DSCB *Dscb;

    //
    //  The following link connects all DoubleSpace volumes mounted from
    //  Cvfs on this volume.
    //

    LIST_ENTRY ParentDscbLinks;

    //
    //  This field contains the "DeviceObject" that this volume is
    //  currently mounted on.  Note that this field can dynamically
    //  change because of DoubleSpace automount, as opposed to
    //  Vcb->Vpb->RealDevice which is constant.
    //

    PDEVICE_OBJECT CurrentDevice;

    //
    //  This is a pointer to the file object and the Fcb which represent the ea data.
    //

    PFILE_OBJECT VirtualEaFile;
    struct _FCB *EaFcb;

    //
    //  The following field is a pointer to the file object that has the
    //  volume locked. if the VcbState has the locked flag set.
    //

    PFILE_OBJECT FileObjectWithVcbLocked;

    //
    //  The following is the head of a list of notify Irps.
    //

    LIST_ENTRY DirNotifyList;

    //
    //  The following is used to synchronize the dir notify list.
    //

    PNOTIFY_SYNC NotifySync;

    //
    //  The following event is used to synchronize directory stream file
    //  object creation.
    //

    KEVENT DirectoryFileCreationEvent;

    //
    //  This field holds the thread address of the current (or most recent
    //  depending on VcbState) thread doing a verify operation on this volume.
    //

    PKTHREAD VerifyThread;

    //
    //  The following two structures are used for CleanVolume callbacks.
    //

    KDPC CleanVolumeDpc;
    KTIMER CleanVolumeTimer;

    //
    //  This field records the last time RxMarkVolumeDirty was called, and
    //  avoids excessive calls to push the CleanVolume forward in time.
    //

    LARGE_INTEGER LastRxMarkVolumeDirtyCall;

} VCB;
typedef VCB *PVCB;

#define VCB_STATE_FLAG_LOCKED              (0x00000001)
#define VCB_STATE_FLAG_REMOVABLE_MEDIA     (0x00000002)
#define VCB_STATE_FLAG_VOLUME_DIRTY        (0x00000004)
#define VCB_STATE_FLAG_MOUNTED_DIRTY       (0x00000010)
#define VCB_STATE_FLAG_SHUTDOWN            (0x00000040)
#define VCB_STATE_FLAG_CLOSE_IN_PROGRESS   (0x00000080)
#define VCB_STATE_FLAG_DELETED_FCB         (0x00000100)
#define VCB_STATE_FLAG_CREATE_IN_PROGRESS  (0x00000200)
#define VCB_STATE_FLAG_FLOPPY              (0x00000400)
#define VCB_STATE_FLAG_BOOT_OR_PAGING_FILE (0x00000800)
#define VCB_STATE_FLAG_COMPRESSED_VOLUME   (0x00001000)
#define VCB_STATE_FLAG_ASYNC_CLOSE_ACTIVE  (0x00002000)
#define VCB_STATE_FLAG_WRITE_PROTECTED     (0x00004000)


//
//  A double space control block for maintaining the double space environment
//

typedef struct _DSCB {

    //
    //  The type and size of this record (must be RDBSS_NTC_DSCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field is used to read/write (via pin access) the
    //  ancillary cvf structures (i.e., the bitmap and rx extensions).
    //

//cvfoff     PFILE_OBJECT CvfFileObject;

    //
    //  A pointer to the compressed volume control block;
    //

    PVCB Vcb;

    //
    //  A pointer to our parent volume control block;
    //

    PVCB ParentVcb;

    //
    //  The following link connects all DoubleSpace volumes mounted from
    //  Cvfs on our parent's volume.
    //

    LIST_ENTRY ChildDscbLinks;

    //
    //  This field contains the device object that we created to represent
    //  the "real" device holding the double space volume.
    //

    PDEVICE_OBJECT NewDevice;

    //
    //  The following fields contain the unpacked header information for
    //  the cvf, and the exact layout of each component in the cvf.  With
    //  this information we can always determine the size and location of
    //  each cvf component.
    //

//cvfoff     CVF_HEADER CvfHeader;
//cvfoff     CVF_LAYOUT CvfLayout;

    //
    //  The following fields describe the shape and size of the virtual rx
    //  partition
    //

    struct {

//cvfoff         COMPONENT_LOCATION Rx;
//cvfoff         COMPONENT_LOCATION RootDirectory;
//cvfoff         COMPONENT_LOCATION FileArea;

        ULONG BytesPerCluster;

    } VfpLayout;

    //
    //  The following fields keep track of allocation information.
    //

    ULONG SectorsAllocated;
    ULONG SectorsRepresented;

#ifdef DOUBLE_SPACE_WRITE

    //
    //  Have a resource that is used to synchronize access to this structure
    //

    PERESOURCE Resource;

    //
    //  Use a bitmap here to keep track of free sectors
    //

    RTL_BITMAP Bitmap;

#endif // DOUBLE_SPACE_WRITE

} DSCB;
typedef DSCB *PDSCB;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\rx.h ===
/*++

joejoe most of this will just disappear....VBO will remain......



Copyright (c) 1989  Microsoft Corporation

Module Name:

    Rx.h

Abstract:

    This module defines the on-disk structure of the Rx file system.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

--*/

#ifndef _RDBSS_
#define _RDBSS_

//
//  The following nomenclature is used to describe the Rx on-disk
//  structure:
//
//      LBN - is the number of a sector relative to the start of the disk.
//
//      VBN - is the number of a sector relative to the start of a file,
//          directory, or allocation.
//
//      LBO - is a byte offset relative to the start of the disk.
//
//      VBO - is a byte offset relative to the start of a file, directory
//          or allocation.
//

//typedef ULONG LBO;
//typedef LBO *PLBO;

//typedef ULONG VBO;
//typedef LONGLONG RXVBO;
//typedef VBO *PVBO;

#if 0

//
//  The boot sector is the first physical sector (LBN == 0) on the volume.
//  Part of the sector contains a BIOS Parameter Block.  The BIOS in the
//  sector is packed (i.e., unaligned) so we'll supply a unpacking macro
//  to translate a packed BIOS into its unpacked equivalent.  The unpacked
//  BIOS structure is already defined in ntioapi.h so we only need to define
//  the packed BIOS.
//

//
//  Define the Packed and Unpacked BIOS Parameter Block
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {
    UCHAR  BytesPerSector[2];                       // offset = 0x000  0
    UCHAR  SectorsPerCluster[1];                    // offset = 0x002  2
    UCHAR  ReservedSectors[2];                      // offset = 0x003  3
    UCHAR  Rxs[1];                                 // offset = 0x005  5
    UCHAR  RootEntries[2];                          // offset = 0x006  6
    UCHAR  Sectors[2];                              // offset = 0x008  8
    UCHAR  Media[1];                                // offset = 0x00A 10
    UCHAR  SectorsPerRx[2];                        // offset = 0x00B 11
    UCHAR  SectorsPerTrack[2];                      // offset = 0x00D 13
    UCHAR  Heads[2];                                // offset = 0x00F 15
    UCHAR  HiddenSectors[4];                        // offset = 0x011 17
    UCHAR  LargeSectors[4];                         // offset = 0x015 21
} PACKED_BIOS_PARAMETER_BLOCK;                      // sizeof = 0x019 25
typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Rxs;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerRx;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;
} BIOS_PARAMETER_BLOCK, *PBIOS_PARAMETER_BLOCK;

//
//  This macro takes a Packed BIOS and fills in its Unpacked equivalent
//

#define RxUnpackBios(Bios,Pbios) {                                    \
    CopyUchar2(&(Bios)->BytesPerSector,    &(Pbios)->BytesPerSector[0]   ); \
    CopyUchar1(&(Bios)->SectorsPerCluster, &(Pbios)->SectorsPerCluster[0]); \
    CopyUchar2(&(Bios)->ReservedSectors,   &(Pbios)->ReservedSectors[0]  ); \
    CopyUchar1(&(Bios)->Rxs,              &(Pbios)->Rxs[0]             ); \
    CopyUchar2(&(Bios)->RootEntries,       &(Pbios)->RootEntries[0]      ); \
    CopyUchar2(&(Bios)->Sectors,           &(Pbios)->Sectors[0]          ); \
    CopyUchar1(&(Bios)->Media,             &(Pbios)->Media[0]            ); \
    CopyUchar2(&(Bios)->SectorsPerRx,     &(Pbios)->SectorsPerRx[0]    ); \
    CopyUchar2(&(Bios)->SectorsPerTrack,   &(Pbios)->SectorsPerTrack[0]  ); \
    CopyUchar2(&(Bios)->Heads,             &(Pbios)->Heads[0]            ); \
    CopyUchar4(&(Bios)->HiddenSectors,     &(Pbios)->HiddenSectors[0]    ); \
    CopyUchar4(&(Bios)->LargeSectors,      &(Pbios)->LargeSectors[0]     ); \
}

//
//  Define the boot sector
//

typedef struct _PACKED_BOOT_SECTOR {
    UCHAR Jump[3];                                  // offset = 0x000   0
    UCHAR Oem[8];                                   // offset = 0x003   3
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;          // offset = 0x00B  11
    UCHAR PhysicalDriveNumber;                      // offset = 0x024  36
    UCHAR Reserved;                                 // offset = 0x025  37
    UCHAR Signature;                                // offset = 0x026  38
    UCHAR Id[4];                                    // offset = 0x027  39
    UCHAR VolumeLabel[11];                          // offset = 0x02B  43
    UCHAR SystemId[8];                              // offset = 0x036  54
} PACKED_BOOT_SECTOR;                               // sizeof = 0x03E  62

typedef PACKED_BOOT_SECTOR *PPACKED_BOOT_SECTOR;

//
//  Define a Rx Entry type.
//
//  This type is used when representing a rx table entry.  It also used
//  to be used when dealing with a rx table index and a count of entries,
//  but the ensuing type casting nightmare sealed this rxe.  These other
//  two types are represented as ULONGs.
//

typedef USHORT RDBSS_ENTRY;
typedef RDBSS_ENTRY *PRDBSS_ENTRY;

#define ENTRIES_PER_PAGE (PAGE_SIZE / sizeof(RDBSS_ENTRY))

//
//  The following constants the are the valid Rx index values.
//

#define RDBSS_CLUSTER_AVAILABLE            (RDBSS_ENTRY)0x0000
#define RDBSS_CLUSTER_RESERVED             (RDBSS_ENTRY)0xfff0
#define RDBSS_CLUSTER_BAD                  (RDBSS_ENTRY)0xfff7
#define RDBSS_CLUSTER_LAST                 (RDBSS_ENTRY)0xffff

//
//  Rx files have the following time/date structures.  Note that the
//  following structure is a 32 bits long but USHORT aligned.
//

typedef struct _RDBSS_TIME {

    USHORT DoubleSeconds : 5;
    USHORT Minute        : 6;
    USHORT Hour          : 5;

} RDBSS_TIME;
typedef RDBSS_TIME *PRDBSS_TIME;

typedef struct _RDBSS_DATE {

    USHORT Day           : 5;
    USHORT Month         : 4;
    USHORT Year          : 7; // Relative to 1980

} RDBSS_DATE;
typedef RDBSS_DATE *PRDBSS_DATE;

typedef struct _RDBSS_TIME_STAMP {

    RDBSS_TIME Time;
    RDBSS_DATE Date;

} RDBSS_TIME_STAMP;
typedef RDBSS_TIME_STAMP *PRDBSS_TIME_STAMP;

//
//  Rx files have 8 character file names and 3 character extensions
//

typedef UCHAR RDBSS8DOT3[11];
typedef RDBSS8DOT3 *PRDBSS8DOT3;


//
//  The directory entry record exists for every file/directory on the
//  disk except for the root directory.
//

typedef struct _PACKED_DIRENT {
    RDBSS8DOT3       FileName;                         //  offset =  0
    UCHAR          Attributes;                       //  offset = 11
    UCHAR          NtByte;                           //  offset = 12
    UCHAR          CreationMSec;                     //  offset = 13
    RDBSS_TIME_STAMP CreationTime;                     //  offset = 14
    RDBSS_DATE       LastAccessDate;                   //  offset = 18
    USHORT         ExtendedAttributes;               //  offset = 20
    RDBSS_TIME_STAMP LastWriteTime;                    //  offset = 22
    RDBSS_ENTRY      FirstClusterOfFile;               //  offset = 26
    ULONG          FileSize;                         //  offset = 28
} PACKED_DIRENT;                                     //  sizeof = 32
typedef PACKED_DIRENT *PPACKED_DIRENT;

//
//  A packed dirent is already quadword aligned so simply declare a dirent as a
//  packed dirent
//

typedef PACKED_DIRENT DIRENT;
typedef DIRENT *PDIRENT;

//
//  The first byte of a dirent describes the dirent.  There is also a routine
//  to help in deciding how to interpret the dirent.
//

#define RDBSS_DIRENT_NEVER_USED            0x00
#define RDBSS_DIRENT_REALLY_0E5            0x05
#define RDBSS_DIRENT_DIRECTORY_ALIAS       0x2e
#define RDBSS_DIRENT_DELETED               0xe5

//
//  Define the NtByte bits.
//

#define RDBSS_DIRENT_NT_BYTE_DIRTY         0x01
#define RDBSS_DIRENT_NT_BYTE_TEST_SURFACE  0x02
#define RDBSS_DIRENT_NT_BYTE_8_LOWER_CASE  0x08
#define RDBSS_DIRENT_NT_BYTE_3_LOWER_CASE  0x10

//
//  Define the various dirent attributes
//

#define RDBSS_DIRENT_ATTR_READ_ONLY        0x01
#define RDBSS_DIRENT_ATTR_HIDDEN           0x02
#define RDBSS_DIRENT_ATTR_SYSTEM           0x04
#define RDBSS_DIRENT_ATTR_VOLUME_ID        0x08
#define RDBSS_DIRENT_ATTR_DIRECTORY        0x10
#define RDBSS_DIRENT_ATTR_ARCHIVE          0x20
#define RDBSS_DIRENT_ATTR_DEVICE           0x40
#define RDBSS_DIRENT_ATTR_LFN              (RDBSS_DIRENT_ATTR_READ_ONLY | \
                                          RDBSS_DIRENT_ATTR_HIDDEN |    \
                                          RDBSS_DIRENT_ATTR_SYSTEM |    \
                                          RDBSS_DIRENT_ATTR_VOLUME_ID)


//
//  These macros convert a number of fields in the Bpb to bytes from sectors
//
//      ULONG
//      RxBytesPerCluster (
//          IN PBIOS_PARAMETER_BLOCK Bios
//      );
//
//      ULONG
//      RxBytesPerRx (
//          IN PBIOS_PARAMETER_BLOCK Bios
//      );
//
//      ULONG
//      RxReservedBytes (
//          IN PBIOS_PARAMETER_BLOCK Bios
//      );
//

#define RxBytesPerCluster(B) ((ULONG)((B)->BytesPerSector * (B)->SectorsPerCluster))

#define RxBytesPerRx(B) ((ULONG)((B)->BytesPerSector * (B)->SectorsPerRx))

#define RxReservedBytes(B) ((ULONG)((B)->BytesPerSector * (B)->ReservedSectors))

//
//  This macro returns the size of the root directory dirent area in bytes
//
//      ULONG
//      RxRootDirectorySize (
//          IN PBIOS_PARAMETER_BLOCK Bios
//          );
//

#define RxRootDirectorySize(B) ((ULONG)((B)->RootEntries * sizeof(DIRENT)))

//
//  This macro returns the first Lbo (zero based) of the root directory on
//  the device.  This area is after the reserved and rxs.
//
//      LBO
//      RxRootDirectoryLbo (
//          IN PBIOS_PARAMETER_BLOCK Bios
//          );
//

#define RxRootDirectoryLbo(B) (RxReservedBytes(B) + ((B)->Rxs * RxBytesPerRx(B)))

//
//  This macro returns the first Lbo (zero based) of the file area on the
//  the device.  This area is after the reserved, rxs, and root directory.
//
//      LBO
//      RxFirstFileAreaLbo (
//          IN PBIOS_PARAMTER_BLOCK Bios
//          );
//

#define RxFileAreaLbo(B) (RxRootDirectoryLbo(B) + RxRootDirectorySize(B))

//
//  This macro returns the number of clusters on the disk.  This value is
//  computed by taking the total sectors on the disk subtracting up to the
//  first file area sector and then dividing by the sectors per cluster count.
//  Note that I don't use any of the above macros since far too much
//  superfluous sector/byte conversion would take place.
//
//      ULONG
//      RxNumberOfClusters (
//          IN PBIOS_PARAMETER_BLOCK Bios
//          );
//

#define RxNumberOfClusters(B) (                                         \
                                                                         \
    (((B)->Sectors + (B)->LargeSectors                                   \
                                                                         \
        -   ((B)->ReservedSectors +                                      \
             (B)->Rxs * (B)->SectorsPerRx +                            \
             (B)->RootEntries * sizeof(DIRENT) / (B)->BytesPerSector ) ) \
                                                                         \
                                    /                                    \
                                                                         \
                        (B)->SectorsPerCluster)                          \
)


//
//  This macro returns the rx table bit size (i.e., 12 or 16 bits)
//
//      ULONG
//      RxIndexBitSize (
//          IN PBIOS_PARAMETER_BLOCK Bios
//          );
//

#define RxIndexBitSize(B) ((UCHAR)(RxNumberOfClusters(B) < 4087 ? 12 : 16))

//
//  This macro raises RxStatus(FILE_CORRUPT) and marks the Fcb bad if an
//  index value is not within the proper range.
//  Note that the first two index values are invalid (0, 1), so we must
//  add two from the top end to make sure the everything is within range
//
//      VOID
//      RxVerifyIndexIsValid (
//          IN PRX_CONTEXT RxContext,
//          IN PVCB Vcb,
//          IN ULONG Index
//          );
//

#define RxVerifyIndexIsValid(IC,V,I) {                                       \
    if (((I) < 2) || ((I) > ((V)->AllocationSupport.NumberOfClusters + 1))) { \
        RxRaiseStatus(IC,RxStatus(FILE_CORRUPT_ERROR));                         \
    }                                                                         \
}

//
//  These two macros are used to translate between Logical Byte Offsets,
//  and rx entry indexes.  Note the use of variables stored in the Vcb.
//  These two macros are used at a higher level than the other macros
//  above.
//
//  LBO
//  GetLboFromRxIndex (
//      IN RDBSS_ENTRY Rx_Index,
//      IN PVCB Vcb
//      );
//
//  RDBSS_ENTRY
//  GetRxIndexFromLbo (
//      IN LBO Lbo,
//      IN PVCB Vcb
//      );
//

#define RxGetLboFromIndex(VCB,RDBSS_INDEX) (                                       \
        (VCB)->AllocationSupport.FileAreaLbo +                                    \
        ((LBO)((RDBSS_INDEX) - 2) << (VCB)->AllocationSupport.LogOfBytesPerCluster) \
)


#define RxGetIndexFromLbo(VCB,LBO) (                      \
        (((LBO) - (VCB)->AllocationSupport.FileAreaLbo) >> \
        (VCB)->AllocationSupport.LogOfBytesPerCluster) + 2 \
)

//
//  The following macro does the tmp shifting and such to lookup an entry
//
//  VOID
//  RxLookup12BitEntry(
//      IN PVOID Rx,
//      IN RDBSS_ENTRY Index,
//      OUT PRDBSS_ENTRY Entry
//      );
//

#define RxLookup12BitEntry(RDBSS,INDEX,ENTRY) {                               \
                                                                             \
    CopyUchar2((PUCHAR)(ENTRY), (PUCHAR)(RDBSS) + (INDEX) * 3 / 2);            \
                                                                             \
    *ENTRY = ((INDEX) & 1) ? *(ENTRY) >> 4 : (RDBSS_ENTRY)(*(ENTRY) & 0xfff);  \
}

//
//  The following macro does the tmp shifting and such to store an entry
//
//  VOID
//  RxSet12BitEntry(
//      IN PVOID Rx,
//      IN RDBSS_ENTRY Index,
//      IN RDBSS_ENTRY Entry
//      );
//

#define RxSet12BitEntry(RDBSS,INDEX,ENTRY) {                            \
                                                                       \
    RDBSS_ENTRY TmpRxEntry;                                             \
                                                                       \
    CopyUchar2((PUCHAR)&TmpRxEntry, (PUCHAR)(RDBSS) + (INDEX) * 3 / 2); \
                                                                       \
    TmpRxEntry = (RDBSS_ENTRY)                                          \
                (((INDEX) & 1) ? ((ENTRY) << 4) | (TmpRxEntry & 0xf)  \
                               : (ENTRY) | (TmpRxEntry & 0xf000));    \
                                                                       \
    *((UNALIGNED UCHAR2 *)((PUCHAR)(RDBSS) + (INDEX) * 3 / 2)) = *((UNALIGNED UCHAR2 *)(&TmpRxEntry)); \
}

//
//  The following macro compares two RDBSS_TIME_STAMPs
//

#define RxAreTimesEqual(TIME1,TIME2) ((BOOLEAN)                  \
    (RtlCompareMemory((TIME1),(TIME2), sizeof(RDBSS_TIME_STAMP)) == \
     sizeof(RDBSS_TIME_STAMP))                                      \
)


#define EA_FILE_SIGNATURE                (0x4445) // "ED"
#define EA_SET_SIGNATURE                 (0x4145) // "EA"

//
//  If the volume contains any ea data then there is one EA file called
//  "EA DATA. SF" located in the root directory as Hidden, System and
//  ReadOnly.
//

typedef struct _EA_FILE_HEADER {
    USHORT Signature;           // offset = 0
    USHORT FormatType;          // offset = 2
    USHORT LogType;             // offset = 4
    USHORT Cluster1;            // offset = 6
    USHORT NewCValue1;          // offset = 8
    USHORT Cluster2;            // offset = 10
    USHORT NewCValue2;          // offset = 12
    USHORT Cluster3;            // offset = 14
    USHORT NewCValue3;          // offset = 16
    USHORT Handle;              // offset = 18
    USHORT NewHOffset;          // offset = 20
    UCHAR  Reserved[10];        // offset = 22
    USHORT EaBaseTable[240];    // offset = 32
} EA_FILE_HEADER;               // sizeof = 512

typedef EA_FILE_HEADER *PEA_FILE_HEADER;

typedef USHORT EA_OFF_TABLE[128];

typedef EA_OFF_TABLE *PEA_OFF_TABLE;

//
//  Every file with an extended attribute contains in its dirent an index
//  into the EaMapTable.  The map table contains an offset within the ea
//  file (cluster aligned) of the ea data for the file.  The individual
//  ea data for each file is prefaced with an Ea Data Header.
//

typedef struct _EA_SET_HEADER {
    USHORT Signature;           // offset = 0
    USHORT OwnEaHandle;         // offset = 2
    ULONG  NeedEaCount;         // offset = 4
    UCHAR  OwnerFileName[14];   // offset = 8
    UCHAR  Reserved[4];         // offset = 22
    UCHAR  cbList[4];           // offset = 26
    UCHAR  PackedEas[1];        // offset = 30
} EA_SET_HEADER;                // sizeof = 30
typedef EA_SET_HEADER *PEA_SET_HEADER;

#define SIZE_OF_EA_SET_HEADER       30

#define MAXIMUM_EA_SIZE             0x0000ffff

#define GetcbList(EASET) (((EASET)->cbList[0] <<  0) + \
                          ((EASET)->cbList[1] <<  8) + \
                          ((EASET)->cbList[2] << 16) + \
                          ((EASET)->cbList[3] << 24))

#define SetcbList(EASET,CB) {                \
    (EASET)->cbList[0] = (CB >>  0) & 0x0ff; \
    (EASET)->cbList[1] = (CB >>  8) & 0x0ff; \
    (EASET)->cbList[2] = (CB >> 16) & 0x0ff; \
    (EASET)->cbList[3] = (CB >> 24) & 0x0ff; \
}

//
//  Every individual ea in an ea set is declared the following packed ea
//

typedef struct _PACKED_EA {
    UCHAR Flags;
    UCHAR EaNameLength;
    UCHAR EaValueLength[2];
    CHAR  EaName[1];
} PACKED_EA;
typedef PACKED_EA *PPACKED_EA;

//
//  The following two macros are used to get and set the ea value length
//  field of a packed ea
//
//      VOID
//      GetEaValueLength (
//          IN PPACKED_EA Ea,
//          OUT PUSHORT ValueLength
//          );
//
//      VOID
//      SetEaValueLength (
//          IN PPACKED_EA Ea,
//          IN USHORT ValueLength
//          );
//

#define GetEaValueLength(EA,LEN) {               \
    *(LEN) = 0;                                  \
    CopyUchar2( (LEN), (EA)->EaValueLength );    \
}

#define SetEaValueLength(EA,LEN) {               \
    CopyUchar2( &((EA)->EaValueLength), (LEN) ); \
}

//
//  The following macro is used to get the size of a packed ea
//
//      VOID
//      SizeOfPackedEa (
//          IN PPACKED_EA Ea,
//          OUT PUSHORT EaSize
//          );
//

#define SizeOfPackedEa(EA,SIZE) {          \
    ULONG _NL,_DL; _NL = 0; _DL = 0;       \
    CopyUchar1(&_NL, &(EA)->EaNameLength); \
    GetEaValueLength(EA, &_DL);            \
    *(SIZE) = 1 + 1 + 2 + _NL + 1 + _DL;   \
}

#define EA_NEED_EA_FLAG                 0x80
#define MIN_EA_HANDLE                   1
#define MAX_EA_HANDLE                   30719
#define UNUSED_EA_HANDLE                0xffff
#define EA_CBLIST_OFFSET                0x1a
#define MAX_EA_BASE_INDEX               240
#define MAX_EA_OFFSET_INDEX             128

#endif
#endif // _RDBSS_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\filobsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FilObSup.c

Abstract:

    This module implements the Rx File object support routines.

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_FILOBSUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxForceCacheMiss)
//#pragma alloc_text(PAGE, RxPurgeReferencedFileObjects)
#pragma alloc_text(PAGE, RxSetFileObject)
//#pragma alloc_text(PAGE, RxDecodeFileObject)
#endif


VOID
RxSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PVOID VcbOrFcbOrDcb,
    IN PFOBX Fobx OPTIONAL
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object

Arguments:

    FileObject - Supplies a pointer to the file object being modified, and
        can optionally be null.

    TypeOfOpen - Supplies the type of open denoted by the file object.
        This is only used by this procedure for sanity checking.
        //joejoe i disabled this because i'm not using the same open types

    VcbOrFcbOrDcb - Supplies a pointer to either a vcb, fcb, or dcb

    Fobx - Optionally supplies a pointer to a ccb

Return Value:

    None.

--*/

{
    RxDbgTrace(+1, Dbg, ("RxSetFileObject, FileObject = %08lx\n", FileObject ));

    ASSERT((Fobx == NULL) || (NodeType(Fobx) == RDBSS_NTC_FOBX));

/*
    ASSERT(((TypeOfOpen == UnopenedFileObject))

                ||

           ((TypeOfOpen == UserFileOpen) &&
            (NodeType(VcbOrFcbOrDcb) == RDBSS_NTC_FCB) &&
            (Fobx != NULL))

                ||

           ((TypeOfOpen == EaFile) &&
            (NodeType(VcbOrFcbOrDcb) == RDBSS_NTC_FCB) &&
            (Fobx == NULL))

                ||

           ((TypeOfOpen == UserDirectoryOpen) &&
            ((NodeType(VcbOrFcbOrDcb) == RDBSS_NTC_DCB) || (NodeType(VcbOrFcbOrDcb) == RDBSS_NTC_ROOT_DCB)) &&
            (Fobx != NULL))

                ||

           ((TypeOfOpen == UserVolumeOpen) &&
            (NodeType(VcbOrFcbOrDcb) == RDBSS_NTC_VCB) &&
            (Fobx != NULL))

                ||

           ((TypeOfOpen == VirtualVolumeFile) &&
            (NodeType(VcbOrFcbOrDcb) == RDBSS_NTC_VCB) &&
            (Fobx == NULL))

                ||

           ((TypeOfOpen == DirectoryFile) &&
            ((NodeType(VcbOrFcbOrDcb) == RDBSS_NTC_DCB) || (NodeType(VcbOrFcbOrDcb) == RDBSS_NTC_ROOT_DCB)) &&
            (Fobx == NULL)));
*/

    //
    //  If we were given an Fcb, Dcb, or Vcb, we have some processing to do.
    //

    ASSERT((Fobx == NULL) || (NodeType(Fobx) == RDBSS_NTC_FOBX));

    if ( VcbOrFcbOrDcb != NULL ) {

        //
        //  Set the Vpb field in the file object, and if we were given an
        //  Fcb or Dcb move the field over to point to the nonpaged Fcb/Dcb
        //

        if (NodeType(VcbOrFcbOrDcb) == RDBSS_NTC_VCB) {

            NOTHING; //FileObject->Vpb = ((PVCB)VcbOrFcbOrDcb)->Vpb;

        } else {

            //joejoe we don't do vpbs
            //FileObject->Vpb = ((PFCB)VcbOrFcbOrDcb)->Vcb->Vpb;

            //
            //  If this is a temporary file, note it in the FcbState
            //

            if (FlagOn(((PFCB)VcbOrFcbOrDcb)->FcbState, FCB_STATE_TEMPORARY)) {

                SetFlag(FileObject->Flags, FO_TEMPORARY_FILE);
            }
        }
    }

    ASSERT((Fobx == NULL) || (NodeType(Fobx) == RDBSS_NTC_FOBX));

    //
    //  Now set the fscontext fields of the file object
    //

    if (ARGUMENT_PRESENT( FileObject )) {

        FileObject->FsContext  = VcbOrFcbOrDcb;
        FileObject->FsContext2 = Fobx;
    }

    ASSERT((Fobx == NULL) || (NodeType(Fobx) == RDBSS_NTC_FOBX));

    //
    //  And return to our caller
    //

    RxDbgTrace(-1, Dbg, ("RxSetFileObject -> VOID\n", 0));

    return;
}


#if 0
TYPE_OF_OPEN
RxDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVCB *Vcb,
    OUT PFCB *FcbOrDcb,
    OUT PFOBX *Fobx
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by the Rx file system and figures out what really is opened.

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    Vcb - Receives a pointer to the Vcb for the file object.

    FcbOrDcb - Receives a pointer to the Fcb/Dcb for the file object, if
        one exists.

    Fobx - Receives a pointer to the Fobx for the file object, if one exists.

Return Value:

    TYPE_OF_OPEN - returns the type of file denoted by the input file object.

        UserFileOpen - The FO represents a user's opened data file.
            Fobx, FcbOrDcb, and Vcb are set.  FcbOrDcb points to an Fcb.

        UserDirectoryOpen - The FO represents a user's opened directory.
            Fobx, FcbOrDcb, and Vcb are set.  FcbOrDcb points to a Dcb/RootDcb

        UserVolumeOpen - The FO represents a user's opened volume.
            Fobx and Vcb are set. FcbOrDcb is null.

        VirtualVolumeFile - The FO represents the special virtual volume file.
            Vcb is set, and Fobx and FcbOrDcb are null.

        DirectoryFile - The FO represents a special directory file.
            Vcb and FcbOrDcb are set. Fobx is null.  FcbOrDcb points to a
            Dcb/RootDcb.

        EaFile - The FO represents an Ea Io stream file.
            FcbOrDcb, and Vcb are set.  FcbOrDcb points to an Fcb, and Fobx is
            null.

--*/

{
    TYPE_OF_OPEN TypeOfOpen;
    PVOID FsContext;
    PVOID FsContext2;

    RxDbgTrace(+1, Dbg, ("RxDecodeFileObject, FileObject = %08lx\n", FileObject));

    //
    //  Reference the fs context fields of the file object, and zero out
    //  the out pointer parameters.
    //

    FsContext = FileObject->FsContext;
    FsContext2 = FileObject->FsContext2;

    //
    //  Special case the situation where FsContext is null
    //

    if (FsContext == NULL) {

        *Fobx = NULL;
        *FcbOrDcb = NULL;
        *Vcb = NULL;

        TypeOfOpen = UnopenedFileObject;

    } else {

        //
        //  Now we can case on the node type code of the fscontext pointer
        //  and set the appropriate out pointers
        //

        switch (NodeType(FsContext)) {

        case RDBSS_NTC_VCB:

            *Fobx = FsContext2;
            *FcbOrDcb = NULL;
            *Vcb = FsContext;

            TypeOfOpen = ( *Fobx == NULL ? VirtualVolumeFile : UserVolumeOpen );

            break;

        case RDBSS_NTC_ROOT_DCB:
        case RDBSS_NTC_DCB:

            *Fobx = FsContext2;
            *FcbOrDcb = FsContext;
            *Vcb = (*FcbOrDcb)->Vcb;

            TypeOfOpen = ( *Fobx == NULL ? DirectoryFile : UserDirectoryOpen );

            RxDbgTrace(0, Dbg, ("Referencing directory: %wZ\n", &(*FcbOrDcb)->FullFileName));

            break;

        case RDBSS_NTC_FCB:

            *Fobx = FsContext2;
            *FcbOrDcb = FsContext;
            *Vcb = (*FcbOrDcb)->Vcb;

            TypeOfOpen = ( *Fobx == NULL ? EaFile : UserFileOpen );

            RxDbgTrace(0, Dbg, ("Referencing file: %wZ\n", &(*FcbOrDcb)->FullFileName));

            break;

        default:

            RxBugCheck( NodeType(FsContext), 0, 0 );
        }
    }

    //
    //  and return to our caller
    //

    RxDbgTrace(-1, Dbg, ("RxDecodeFileObject -> %08lx\n", TypeOfOpen));

    return TypeOfOpen;
}

VOID
RxPurgeReferencedFileObjects (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN BOOLEAN FlushFirst
    )

/*++

Routine Description:

    This routine non-recursively walks from the given FcbOrDcb and trys
    to force Cc or Mm to close any sections it may be holding on to.

Arguments:

    Fcb - Supplies a pointer to either an fcb or a dcb

    FlushFirst - If given as TRUE, then the files are flushed before they
        are purged.

Return Value:

    None.

--*/

{
    PFCB OriginalFcb = Fcb;
    PFCB NextFcb;

    RxDbgTrace(+1, Dbg, ("RxPurgeReferencedFileObjects, Fcb = %08lx\n", Fcb ));

    ASSERT(FALSE); //this shouldn't happen in the rdr.....it may play with volume opens
    ASSERT( FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT) );

//close    //
//close    //  First, if we have a delayed close, force it closed.
//close    //
//close
//close    RxFspClose(Fcb->Vcb);

    //
    //  Walk the directory tree forcing sections closed.
    //
    //  Note that it very important to get the next node to visit before
    //  acting on the current node.  This is because acting on a node may
    //  make it, and an arbitrary number of direct ancestors, vanish.
    //  Since we never visit ancestors in our enumeration scheme, we can
    //  safely continue the enumeration even when the tree is vanishing
    //  beneath us.  This is way cool.
    //

    while ( Fcb != NULL ) {

        NextFcb = RxGetNextFcb(RxContext, Fcb, OriginalFcb);

        //
        //  Check for the EA file fcb
        //

        if ( !FlagOn(Fcb->DirentRxFlags, RDBSS_DIRENT_ATTR_VOLUME_ID) ) {

            RxForceCacheMiss( RxContext, Fcb, FlushFirst );
        }

        Fcb = NextFcb;
    }

    RxDbgTrace(-1, Dbg, ("RxPurgeReferencedFileObjects (VOID)\n", 0 ));

    return;
}
#endif


VOID
RxForceCacheMiss (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN BOOLEAN FlushFirst
    )

/*++

Routine Description:

    The following routine asks either Cc or Mm to get rid of any cached
    pages on a file.  Note that this will fail if a user has mapped a file.

    If there is a shared cache map, purge the cache section.  Otherwise
    we have to go and ask Mm to blow away the section.

    NOTE: This caller MUST own the Vcb exclusive.

Arguments:

    Fcb - Supplies a pointer to an fcb

    FlushFirst - If given as TRUE, then the files are flushed before they
        are purged.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    BOOLEAN ChildrenAcquired = FALSE;

    //
    //  If we can't wait, bail.
    //

    ASSERT( RxVcbAcquiredExclusive( RxContext, Fcb->Vcb ) ||
            FlagOn( Fcb->Vcb->VcbState, VCB_STATE_FLAG_LOCKED ) );

    if (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)) {

        RxRaiseStatus( RxContext, RxStatus(CANT_WAIT) );
    }

    (VOID)RxAcquireExclusiveFcb( RxContext, Fcb );

    //
    //  If we are purging a directory file object, we must acquire all the
    //  FCBs exclusive so that the parent directory is not being pinned.
    //

    if ((NodeType(Fcb) != RDBSS_NTC_FCB) &&
        !IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue)) {

        PLIST_ENTRY Links;
        PFCB TempFcb;

        ChildrenAcquired = TRUE;

        for (Links = Fcb->Specific.Dcb.ParentDcbQueue.Flink;
             Links != &Fcb->Specific.Dcb.ParentDcbQueue;
             Links = Links->Flink) {

            TempFcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

            (VOID)RxAcquireExclusiveFcb( RxContext, TempFcb );
        }
    }

    //
    //  We use this flag to indicate to a close beneath us that
    //  the Fcb resource should be freed before deleting the Fcb.
    //

    Vcb = Fcb->Vcb;

    SetFlag( Fcb->FcbState, FCB_STATE_FORCE_MISS_IN_PROGRESS );

    ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB );

    try {

        BOOLEAN DataSectionExists;
        BOOLEAN ImageSectionExists;

        PSECTION_OBJECT_POINTERS Section;

        if ( FlushFirst ) {

            (VOID)RxFlushFile( RxContext, Fcb );
        }

        //
        //  The Flush may have made the Fcb go away
        //

        if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB)) {

            Section = &Fcb->NonPaged->SectionObjectPointers;

            DataSectionExists = (BOOLEAN)(Section->DataSectionObject != NULL);
            ImageSectionExists = (BOOLEAN)(Section->ImageSectionObject != NULL);

            //
            //  Note, it is critical to do the Image section first as the
            //  purge of the data section may cause the image section to go
            //  away, but the opposite is not true.
            //

            if (ImageSectionExists) {

                (VOID)MmFlushImageSection( Section, MmFlushForWrite );
            }

            if (DataSectionExists) {

                CcPurgeCacheSection( Section, NULL, 0, FALSE );
            }
        }

    } finally {

        //
        //  If we purging a directory file object, release all the Fcb
        //  resources that we acquired above.  The Dcb cannot have vanished
        //  if there were Fcbs underneath it, and the Fcbs couldn't have gone
        //  away since I own the Vcb.
        //

        if (ChildrenAcquired) {

            PLIST_ENTRY Links;
            PFCB TempFcb;

            for (Links = Fcb->Specific.Dcb.ParentDcbQueue.Flink;
                 Links != &Fcb->Specific.Dcb.ParentDcbQueue;
                 Links = Links->Flink) {

                TempFcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

                RxReleaseFcb( RxContext, TempFcb );
            }
        }

        //
        //  Since we have the Vcb exclusive we know that if any closes
        //  come in it is because the CcPurgeCacheSection caused the
        //  Fcb to go away.  Also in close, the Fcb was released
        //  before being freed.
        //

        if ( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB) ) {

            ClearFlag( Fcb->FcbState, FCB_STATE_FORCE_MISS_IN_PROGRESS );

            RxReleaseFcb( (RXCONTEXT), Fcb );
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\mrcf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Mrcf.c

Abstract:

    This module implements the Compress routines for the Double Space File System

Author:

    Gary Kimura     [GaryKi]    26-May-1993

Revision History:

--*/

#include <ntos.h>
#include <stdio.h>
#include "mrcf.h"


//
//  The debug macros
//

#ifdef MRCFDBG

#define DbgDoit(X)                       {X;}
#define ChPrint(b)                       (isprint(b) ? b : '.')
#define DbgPrint                         printf

#else

#define DbgDoit(X)                       {NOTHING;}

#endif // MRCFDBG


//
//  Compress this much before each EOS
//

#define cbCOMPRESSCHUNK                  (512)

//
//  Maximum back-pointer value, also used to indicate end of compressed stream!
//

#define wBACKPOINTERMAX                  (4415)

//
//  bitsEND_OF_STREAM - bits that mark end of compressed stream (EOS)
//
//       This pattern is used to indicate the end of a "chunk" in a compressed
//       data stream.  The Compress code compresses up to 512 bytes, writes
//       this pattern, and continues.
//
//       NOTE: This diagram is interpreted right to left.
//
//       ?    ---offset----
//
//       ?.111-1111-1111-1.1.11
//
//       \---7F---/ \----FF---/
//
//       This is a 12-bit "match" code with a maximum offset.
//       NOTE: There is no length component!
//
//  Define the EOS and also say how many bits it is.
//

#define bitsEND_OF_STREAM                (0x7FFF)
#define cbitsEND_OF_STREAM               (15)

//
//  MDSIGNATURE - Signature at start of each compressed block
//
//      This 4-byte signature is used as a check to ensure that we
//      are decompressing data we compressed, and also to indicate
//      which compression method was used.
//
//      NOTE: A compressed block consists of one or more "chunks", separated
//            by the bitsEND_OF_STREAM pattern.
//
//            Byte          Word
//        -----------    ---------
//         0  1  2  3      0    1      Meaning
//        -- -- -- --    ---- ----     ----------------
//        44 53 00 01    5344 0100     MaxCompression
//        44 53 00 02    5344 0200     StandardCompression
//
//      NOTE: The *WORD* values are listed to be clear about the
//            byte ordering!
//

typedef struct _MDSIGNATURE {

    //
    //  Must be MD_STAMP
    //

    USHORT sigStamp;

    //
    //  mdsSTANDARD or mdsMAX
    //

    USHORT sigType;

} MDSIGNATURE;
typedef MDSIGNATURE *PMDSIGNATURE;

#define MD_STAMP        0x5344  // Signature stamp at start of compressed blk
#define mdsSTANDARD     0x0200  // StandardCompressed block
#define MASK_VALID_mds  0x0300  // All other bits must be zero


//
//  Local procedure declarations and macros
//

#define min(a,b) (a < b ? a : b)

//
//  PFNFINDMATCH - Lookup function type for XxxxCompression routines
//

typedef ULONG (*PFNFINDMATCH) (
    ULONG UncompressedIndex,
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PULONG MatchedStringIndex,
    PMRCF_STANDARD_COMPRESS WorkSpace
    );

//
//  Local procedure prototypes
//

VOID
MrcfSetBitBuffer (
    PUCHAR pb,
    ULONG cb,
    PMRCF_BIT_IO BitIo
    );

VOID
MrcfFillBitBuffer (
    PMRCF_BIT_IO BitIo
    );

USHORT
MrcfReadBit (
    PMRCF_BIT_IO BitIo
    );

USHORT
MrcfReadNBits (
    LONG cbits,
    PMRCF_BIT_IO BitIo
    );

#ifdef DOUBLE_SPACE_WRITE

ULONG
MrcfDoCompress (
    PUCHAR CompressedBuffer,
    ULONG CompressedLength,
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PFNFINDMATCH FindMatchFunction,
    PMRCF_STANDARD_COMPRESS WorkSpace
    );

ULONG
MrcfCompressChunk (
    PUCHAR UncompressedBuffer,
    ULONG UncompressedIndex,
    ULONG UncompressedLength,
    PFNFINDMATCH FindMatchFunction,
    PMRCF_STANDARD_COMPRESS WorkSpace
    );

ULONG
MrcfFindMatchStandard (
    ULONG UncompressedIndex,
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PULONG MatchedStringIndex,
    PMRCF_STANDARD_COMPRESS WorkSpace
    );

ULONG
MrcfGetMatchLength (
    PUCHAR UncompressedBuffer,
    ULONG MatchIndex,
    ULONG CurrentIndex,
    ULONG UncompressedLength
    );

BOOLEAN
MrcfEncodeByte (
    UCHAR b,
    PMRCF_BIT_IO BitIo
    );

BOOLEAN
MrcfEncodeMatch (
    ULONG off,
    ULONG cb,
    PMRCF_BIT_IO BitIo
    );

BOOLEAN
MrcfWriteBit (
    ULONG bit,
    PMRCF_BIT_IO BitIo
    );

BOOLEAN
MrcfWriteNBits (
    ULONG abits,
    LONG cbits,
    PMRCF_BIT_IO BitIo
    );

ULONG
MrcfFlushBitBuffer (
    PMRCF_BIT_IO BitIo
    );

#endif // DOUBLE_SPACE_WRITE

//**** unconverted routines ****

VOID
MrcfDoInterMaxPairs (
    ULONG ibU,
    PUCHAR pbU,
    ULONG cbMatch,
    PVOID WorkSpace
    );

ULONG
MrcfDoMaxPairLookup (
    ULONG ibU,
    PUCHAR pbU,
    PVOID WorkSpace
    );

ULONG
MrcfFindMatchMax (
    ULONG ibU,
    PUCHAR pbU,
    ULONG cbU,
    PULONG piPrev,
    BOOLEAN fLast,
    PVOID WorkSpace
    );


ULONG
MrcfDecompress (
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PUCHAR CompressedBuffer,
    ULONG CompressedLength,
    PMRCF_DECOMPRESS WorkSpace
    )

/*++

Routine Description:

    This routine decompresses a buffer of StandardCompressed or MaxCompressed
    data.

Arguments:

    UncompressedBuffer - buffer to receive uncompressed data

    UncompressedLength - length of UncompressedBuffer

          NOTE: UncompressedLength must be the EXACT length of the uncompressed
                data, as Decompress uses this information to detect
                when decompression is complete.  If this value is
                incorrect, Decompress may crash!

    CompressedBuffer - buffer containing compressed data

    CompressedLength - length of CompressedBuffer

    WorkSpace - pointer to a private work area for use by this operation

Return Value:

    ULONG - Returns the size of the decompressed data in bytes. Returns 0 if
        there was an error in the decompress.

--*/

{
    ULONG  cbMatch; //  Length of match string
    ULONG  i;       //  Index in UncompressedBuffer to receive decoded data
    ULONG  iMatch;  //  Index in UncompressedBuffer of matched string
    ULONG  k;       //  Number of bits in length string
    ULONG  off;     //  Offset from i in UncompressedBuffer of match string
    USHORT x;       //  Current bit being examined
    ULONG  y;

    //
    //  verify that compressed data starts with proper signature
    //

    if (CompressedLength < sizeof(MDSIGNATURE) ||                            // Must have signature
        ((PMDSIGNATURE)CompressedBuffer)->sigStamp != MD_STAMP ||            // Stamp must be OK
        ((PMDSIGNATURE)CompressedBuffer)->sigType & (~MASK_VALID_mds)) {     // Type must be OK

        return 0;
    }

    //
    //  Skip over the valid signature
    //

    CompressedLength -= sizeof(MDSIGNATURE);
    CompressedBuffer += sizeof(MDSIGNATURE);

    //
    //  Set up for decompress, start filling UncompressedBuffer at front
    //

    i = 0;

    //
    //  Set statics to save parm passing
    //

    MrcfSetBitBuffer(CompressedBuffer,CompressedLength,&WorkSpace->BitIo);

    while (TRUE) {

        DbgDoit( DbgPrint("UncompressedOffset i = %3x ",i) );
        DbgDoit( DbgPrint("CompressedOffset = (%3x.%2x) ", WorkSpace->BitIo.cbBBInitial - WorkSpace->BitIo.cbBB, 16 - WorkSpace->BitIo.cbitsBB) );

        y = MrcfReadNBits(2,&WorkSpace->BitIo);

        //
        //  Check if next 7 bits are a byte
        //  1 if 128..255 (0x80..0xff), 2 if 0..127 (0x00..0x7f)
        //

        if (y == 1 || y == 2) {

            ASSERTMSG("Don't exceed expected length ", i<UncompressedLength);

            UncompressedBuffer[i] = (UCHAR)((y == 1 ? 0x80 : 0) | MrcfReadNBits(7,&WorkSpace->BitIo));

            DbgDoit( DbgPrint("byte: %02x = '%c'\n",(USHORT)UncompressedBuffer[i],ChPrint(UncompressedBuffer[i])) );

            i++;

        } else {

            //
            //  Have match sequence
            //

            DbgDoit( DbgPrint("offset(") );

            //
            // Get the offset
            //

            if (y == 0) {

                //
                //  next 6 bits are offset
                //

                off = MrcfReadNBits(6,&WorkSpace->BitIo);

                DbgDoit( DbgPrint("%x): %x",6,off) );

                ASSERTMSG("offset 0 is invalid ", off != 0);

            } else {

                x = MrcfReadBit(&WorkSpace->BitIo);

                if (x == 0) {

                    //
                    //  next 8 bits are offset-64 (0x40)
                    //

                    off = MrcfReadNBits(8, &WorkSpace->BitIo) + 64;

                    DbgDoit( DbgPrint("%x): %x",8,off) );

                } else {

                    //
                    //  next 12 bits are offset-320 (0x140)
                    //

                    off = MrcfReadNBits(12, &WorkSpace->BitIo) + 320;

                    DbgDoit( DbgPrint("%x): %x",12,off) );

                    if (off == wBACKPOINTERMAX) {

                        //
                        //  EOS marker
                        //

                        DbgDoit( DbgPrint("; EOS\n") );

                        if (i >= UncompressedLength) {

                            //
                            // Done with entire buffer
                            //

                            DbgDoit( DbgPrint("Uncompressed Length = %x\n",i)  );

                            return i;

                        } else {

                            //
                            //  More to do
                            //  Done with a 512-byte chunk
                            //

                            continue;
                        }
                    }
                }
            }

            ASSERTMSG("Don't exceed expected length ", i<UncompressedLength);
            ASSERTMSG("Cannot match before start of uncoded buffer! ", off <= i);

            //
            //  Get the length  - logarithmically encoded
            //

            for (k=0; (x=MrcfReadBit(&WorkSpace->BitIo)) == 0; k++) { NOTHING; }

            ASSERT(k <= 8);

            if (k == 0) {

                //
                //  All matches at least 2 chars long
                //

                cbMatch = 2;

            } else {

                cbMatch = (1 << k) + 1 + MrcfReadNBits(k, &WorkSpace->BitIo);
            }

            DbgDoit( DbgPrint("; length=%x; '",cbMatch)  );

            ASSERTMSG("Don't exceed buffer size ", (i - off + cbMatch - 1) <= UncompressedLength);

            //
            //  Copy the matched string
            //

            iMatch = i - off;

            while ( (cbMatch > 0) && (i<UncompressedLength) ) {

                DbgDoit( DbgPrint("%c",ChPrint(UncompressedBuffer[iMatch])) );

                UncompressedBuffer[i++] = UncompressedBuffer[iMatch++];
                cbMatch--;
            }

            DbgDoit( DbgPrint("'\n") );

            ASSERTMSG("Should have copied it all ", cbMatch == 0);
        }
    }
}


//
//  Internal Support Routine
//

VOID
MrcfSetBitBuffer (
    PUCHAR pb,
    ULONG cb,
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Set statics with coded buffer pointer and length

Arguments:

    pb - pointer to compressed data buffer

    cb - length of compressed data buffer

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    None.

--*/

{
    BitIo->pbBB        = pb;
    BitIo->cbBB        = cb;
    BitIo->cbBBInitial = cb;
    BitIo->cbitsBB     = 0;
    BitIo->abitsBB     = 0;
}


//
//  Internal Support Routine
//

USHORT
MrcfReadBit (
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Get next bit from bit buffer

Arguments:

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    USHORT - Returns next bit (0 or 1)

--*/

{
    USHORT bit;

    //
    //  Check if no bits available
    //

    if ((BitIo->cbitsBB) == 0) {

        MrcfFillBitBuffer(BitIo);
    }

    //
    //  Decrement the bit count
    //  get the bit, remove it, and return the bit
    //

    (BitIo->cbitsBB)--;
    bit = (BitIo->abitsBB) & 1;
    (BitIo->abitsBB) >>= 1;

    return bit;
}


//
//  Internal Support Routine
//

USHORT
MrcfReadNBits (
    LONG cbits,
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Get next N bits from bit buffer

Arguments:

    cbits - count of bits to get

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    USHORT - Returns next cbits bits.

--*/

{
    ULONG abits;        // Bits to return
    LONG cbitsPart;    // Partial count of bits
    ULONG cshift;       // Shift count
    ULONG mask;         // Mask

    //
    //  Largest number of bits we should read at one time is 12 bits for
    //  a 12-bit offset.  The largest length field component that we
    //  read is 8 bits.  If this routine were used for some other purpose,
    //  it can support up to 15 (NOT 16) bit reads, due to how the masking
    //  code works.
    //

    ASSERT(cbits <= 12);

    //
    //  No shift and no bits yet
    //

    cshift = 0;
    abits = 0;

    while (cbits > 0) {

        //
        //  If not bits available get some bits
        //

        if ((BitIo->cbitsBB) == 0) {

            MrcfFillBitBuffer(BitIo);
        }

        //
        //  Number of bits we can read
        //

        cbitsPart = min((BitIo->cbitsBB), cbits);

        //
        //  Mask for bits we want, extract and store them
        //

        mask = (1 << cbitsPart) - 1;
        abits |= ((BitIo->abitsBB) & mask) << cshift;

        //
        //  Remember the next chunk of bits
        //

        cshift = cbitsPart;

        //
        //  Update bit buffer, move remaining bits down and
        //  update count of bits left
        //

        (BitIo->abitsBB) >>= cbitsPart;
        (BitIo->cbitsBB) -= cbitsPart;

        //
        //  Update count of bits left to read
        //

        cbits -= cbitsPart;
    }

    //
    //  Return requested bits
    //

    return (USHORT)abits;
}


//
//  Internal Support Routine
//

VOID
MrcfFillBitBuffer (
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Fill abitsBB from static bit buffer

Arguments:

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    None.

--*/

{
    ASSERT((BitIo->cbitsBB) == 0);

    switch (BitIo->cbBB) {

    case 0:

        ASSERTMSG("no bits left in coded buffer!", FALSE);

        break;

    case 1:

        //
        //  Get last byte and adjust count
        //

        BitIo->cbitsBB = 8;
        BitIo->abitsBB = *(BitIo->pbBB)++;
        BitIo->cbBB--;

        break;

    default:

        //
        //  Get word and adjust count
        //

        BitIo->cbitsBB = 16;
        BitIo->abitsBB = *((USHORT *)(BitIo->pbBB))++;
        BitIo->cbBB -= 2;

        break;
    }
}

#ifdef DOUBLE_SPACE_WRITE


ULONG
MrcfStandardCompress (
    PUCHAR CompressedBuffer,
    ULONG CompressedLength,
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PMRCF_STANDARD_COMPRESS WorkSpace
    )

/*++

Routine Description:

    This routine compresses a buffer using the standard compression algorithm.

Arguments:

    CompressedBuffer - buffer to receive compressed data

    CompressedLength - length of CompressedBuffer

    UncompressedBuffer - buffer containing uncompressed data

    UncompressedLength - length of UncompressedBuffer

    WorkSpace - pointer to a private work area for use by this operation

Return Value:

    ULONG - Returns the size of the compressed data in bytes. Returns 0 if
        the data is not compressible

--*/

{
    ULONG i,j;

    //
    //  Fill lookup tables with initial values
    //

    for (i=0; i<256; i++) {

        for (j = 0; j < cMAXSLOTS; j++) {

            WorkSpace->ltX[i][j] = ltUNUSED;       // Mark offset look-up entries unused
            WorkSpace->abChar[i][j] = bRARE;       // Mark match char entries unused
        }

        WorkSpace->abMRUX[i] = mruUNUSED;          // MRU pointer = unused
    }

    //
    //  Do compression, first set type and then do the compression
    //

    ((PMDSIGNATURE)CompressedBuffer)->sigType = mdsSTANDARD;

    return MrcfDoCompress( CompressedBuffer,
                           CompressedLength,
                           UncompressedBuffer,
                           UncompressedLength,
                           MrcfFindMatchStandard,
                           WorkSpace );
}


//
//  Internal Support Routine
//

ULONG
MrcfDoCompress (
    PUCHAR CompressedBuffer,
    ULONG CompressedLength,
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PFNFINDMATCH FindMatchFunction,
    PMRCF_STANDARD_COMPRESS WorkSpace
    )

/*++

Routine Description:

    This routine compresses a data buffer

Arguments:

    CompressedBuffer   - buffer to receive compressed data

    CompressedLength   - length of CompressedBuffer

    UncompressedBuffer - buffer containing uncompressed data

    UncompressedLength - length of UncompressedBuffer

    FindMatchFunction  - matching function

    WorkSpace - Supplies a pointer to the bit buffer statics

Return Value:

    ULONG - Returns the size of the compressed data in bytes. Returns 0 if
        the data is not compressible

--*/

{
    ULONG cbDone;     // Count of uncompressed bytes processed so far
    ULONG cb;         // Count of bytes processed in a chunk

    ASSERT(CompressedLength >= UncompressedLength);

    //
    //  Treat zero-length request specially as Not compressible
    //

    if (UncompressedLength == 0) { return 0; }

    //
    //  Write signature to compressed data block
    //

    ((PMDSIGNATURE)CompressedBuffer)->sigStamp = MD_STAMP;

    CompressedLength -= sizeof(MDSIGNATURE);
    CompressedBuffer += sizeof(MDSIGNATURE);

    //
    //  Set statics to save parm passing
    //

    MrcfSetBitBuffer(CompressedBuffer, CompressedLength, &WorkSpace->BitIo);

    //
    //  Start with first chunk
    //  and process entire buffer
    //

    cbDone = 0;

    while (cbDone < UncompressedLength) {

        //
        //  Compress a chunk
        //

        cb = MrcfCompressChunk( UncompressedBuffer,
                                cbDone,
                                UncompressedLength,
                                FindMatchFunction,
                                WorkSpace );

        //
        // Check if we could not compress, i.e., Not compressible
        //

        if (cb == 0) { return 0; }

        cbDone += cb;

        if (FALSE) { //**** if (WorkSpace->fMaxCmp) {

            //
            //  MAXCMP check
            //

            if ((cbDone < UncompressedLength) && (WorkSpace->BitIo.cbBB < 586)) { return 0; }

        } else {

            //
            //  RCOMP check
            //

            //**** if (WorkSpace->BitIo.cbBB <= 586) { return 0; }
        }
    }

    ASSERT(cbDone == UncompressedLength);

    //
    // Make sure we saved some space
    //

    cb = sizeof(MDSIGNATURE) + MrcfFlushBitBuffer( &WorkSpace->BitIo );

    if (TRUE) { //**** if (!WorkSpace->fMaxCmp) {

        if (cb+8 >= UncompressedLength) { return 0; }
    }

    if (cb < UncompressedLength) {

        return cb;

    } else {

        return 0;
    }
}


//
//  Internal Support Routine
//

ULONG
MrcfCompressChunk (
    PUCHAR UncompressedBuffer,
    ULONG UncompressedIndex,
    ULONG UncompressedLength,
    PFNFINDMATCH FindMatchFunction,
    PMRCF_STANDARD_COMPRESS WorkSpace
    )

/*++

Routine Description:

    This routine compresses a chunk of uncompressed data

Arguments:

    UncompressedBuffer - buffer containing uncompressed data

    UncompressedIndex  - index in UncompressedBuffer to start compressing (0 => first byte)

    UncompressedLength - length of UncompressedBuffer

    FindMatchFunction  - matching function

    WorkSpace - Supplies a pointer to the bit buffer statics

Return Value:

    ULONG - Returns the non-zero count of uncompressed bytes processed.
            Returns 0 if the data is not compressible

--*/

{
    UCHAR   b1;         // First byte of pair
    UCHAR   b2;         // Second byte of pair
    ULONG   cbChunk;    // Count of bytes in chunk to compress
    ULONG   cbMatch;    // Count of bytes matched
    ULONG   cbUChunk;   // Phony buffer length, for compressing this chunk
    BOOLEAN fLast;      // TRUE if this is the last chunk
    ULONG   i;          // Index in byte stream being compressed
    ULONG   iPrev;      // Previous table entry

    ASSERT(UncompressedLength > 0);
    ASSERT(UncompressedBuffer != 0);
    ASSERT(UncompressedIndex < UncompressedLength);

    //
    // Only compress one chunk
    //

    cbChunk = min((UncompressedLength-UncompressedIndex),cbCOMPRESSCHUNK);

    //
    //  Limit to chunk length
    //

    cbUChunk = UncompressedIndex + cbChunk;

    ASSERT(cbUChunk <= UncompressedLength);

    //
    //  TRUE if last chunk of buffer
    //

    fLast = (cbUChunk == UncompressedLength);

    //
    //  Limit to chunk length
    //

    UncompressedLength = cbUChunk;

    //
    //  Scan each pair of bytes
    //

    //
    //  First byte of input
    //

    b2 = UncompressedBuffer[UncompressedIndex];

    //
    //  Process all bytes in chunk
    //

    for (i=UncompressedIndex+1; i<UncompressedLength; ) {

        //
        //  Set Last byte, Next byte, and find a match
        //

        b1 = b2;
        b2 = UncompressedBuffer[i];

        cbMatch = (*FindMatchFunction)(i,UncompressedBuffer,UncompressedLength,&iPrev,WorkSpace);

        //
        //  Check if we got match
        //

        if (cbMatch >= 2) {

            DbgDoit( DbgPrint("<Match>: '%c%c' at offset %x for length %x\n",
                              ChPrint(UncompressedBuffer[i-1]),ChPrint(UncompressedBuffer[i]),i-1, cbMatch) );

            //
            //  Pass offset and length, and check for failure (i.e., data incompressible)
            //

            if (!MrcfEncodeMatch(i-iPrev,cbMatch,&WorkSpace->BitIo)) {

                return 0;
            }

            //
            //  Now we have to continue with the first pair of bytes
            //  after the string we matched: mmmmmmm12
            //

            //
            //  i is index of 2nd byte after match!
            //

            i += cbMatch;

            //
            //  Check if at least 1 byte still to compress, if so
            //  get 1st byte after match, for loop, otherwise put out EOS
            //

            if (i <= UncompressedLength) {

                b2 = UncompressedBuffer[i-1];

            } else {

                goto WriteEOS;
            }

        } else {

            //
            //  No match found, Store one byte and continue, and check
            //  for failure (i.e., data incompressible)
            //

            if (!MrcfEncodeByte(b1,&WorkSpace->BitIo)) {
                return 0;
            }

            //
            //  Advance to next byte
            //

            i++;
        }
    }

    //
    //  Store last byte, and again check for failure
    //

    if (!MrcfEncodeByte(b2,&WorkSpace->BitIo)) {

        return 0;
    }

WriteEOS:

    //
    //  write out EOS, and check for failure otherwise return how much
    //  data we processed
    //

    if (!MrcfWriteNBits( bitsEND_OF_STREAM,
                         cbitsEND_OF_STREAM,
                         &WorkSpace->BitIo )) {

        return 0;

    } else {

        return cbChunk;
    }
}


//
//  Internal Support Routine
//

ULONG
MrcfFindMatchStandard (
    ULONG UncompressedIndex,
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PULONG MatchedStringIndex,
    PMRCF_STANDARD_COMPRESS WorkSpace
    )

/*++

Routine Description:

    This routine does a standard compression lookup

Arguments:

    UncompressedIndex  - index into UncompressedBuffer[] of *2nd* byte of pair to match

    UncompressedBuffer - buffer containing uncompressed data

    UncompressedLength - length of UncompressedBuffer

    MatchedStringIndex - pointer to int to receive index of start of matched string

    WorkSpace - Supplies a pointer to the bit buffer statics

Return Value:

    ULONG - Returns length of match.  If the return value is >= 2 then
            *MatchedStringIndex = index of matched string (*2nd* byte in pair).
            Otherwise the match length is 0 or 1

--*/

{
    ULONG i;
    ULONG iMRU;
    ULONG iChar;
    ULONG iPrev;

    //
    //  Are there exactly two bytes left?  If so then do not check for match.
    //

    if (UncompressedIndex == (UncompressedLength-1)) { return 0; }

    //
    //  1st char is index to look-up tables
    //

    iChar = UncompressedBuffer[UncompressedIndex-1];

    //
    //  Can't match if 1st MRU ent is unused
    //

    if (WorkSpace->abMRUX[iChar] != mruUNUSED) {

        for (i = 0; i < cMAXSLOTS; i++) {

            if (WorkSpace->abChar[iChar][i] == UncompressedBuffer[UncompressedIndex]) {

                iPrev = WorkSpace->ltX[iChar][i];
                WorkSpace->ltX[iChar][i] = UncompressedIndex;

                if ((UncompressedIndex - iPrev) >= wBACKPOINTERMAX) { return 0; }

                *MatchedStringIndex = iPrev;

                return MrcfGetMatchLength( UncompressedBuffer,
                                           iPrev,
                                           UncompressedIndex,
                                           UncompressedLength );
            }
        }
    }

    //
    //  Cycle MRU index for char
    //  Update char match table
    //  Location of this char pair
    //

    iMRU = (WorkSpace->abMRUX[iChar] += 1) & (cMAXSLOTS - 1);
    WorkSpace->abChar[iChar][iMRU] = UncompressedBuffer[UncompressedIndex];
    WorkSpace->ltX[iChar][iMRU] = UncompressedIndex;

    return 0;
}


//
//  Internal Support Routine
//

ULONG
MrcfGetMatchLength (
    PUCHAR UncompressedBuffer,
    ULONG MatchIndex,
    ULONG CurrentIndex,
    ULONG UncompressedLength
    )

/*++

Routine Description:

    Find length of matching strings

Arguments:

    UncompressedBuffer    - uncompressed data buffer

    MatchIndex - index of 2nd byte in UncompressedBuffer of match  (MatchIndex < CurrentIndex)

    CurrentIndex  - index of 2nd byte in UncompressedBuffer that is being compressed

    UncompressedLength    - length of UncompressedBuffer

Return Value:

    ULONG - Returns length of matching strings (0, or 2 or greater)

--*/

{
    ULONG cb;

    ASSERT(MatchIndex >= 0);
    ASSERT(MatchIndex < CurrentIndex);
    ASSERT(CurrentIndex  < UncompressedLength);

    //
    //  Point back to start of both strings
    //

    MatchIndex--;
    CurrentIndex--;

    //
    //  No bytes matched, yet
    //

    cb = 0;

    //
    //  Scan for end of match, or end of buffer
    //

    while ((CurrentIndex<UncompressedLength) && (UncompressedBuffer[MatchIndex] == UncompressedBuffer[CurrentIndex])) {

        MatchIndex++;
        CurrentIndex++;
        cb++;
    }

    return cb;
}


//
//  Internal Support Routine
//

BOOLEAN
MrcfEncodeByte (
    UCHAR b,
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Write one byte to compressed bit stream

Arguments:

    b - byte to write

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    BOOLEAN - TRUE if the bit stream was updated and FALSE if overran buffer

--*/

{
    ULONG abits;

    DbgDoit( DbgPrint("<MrcfEncodeByte>: byte=%02x '%c'\n",b,ChPrint(b)) );

    abits = ((b & 0x7F) << 2) | ((b < 128) ? 2 : 1);

    //
    //  Write to bitstream
    //

    return MrcfWriteNBits(abits, 9, BitIo);
}


//
//  Internal Support Routine
//

BOOLEAN
MrcfEncodeMatch (
    ULONG off,
    ULONG cb,
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Write a match to compressed bit stream

Arguments:

    off - offset of match (must be greater than 0)

    cb  - length of match (must be at least 2)

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    BOOLEAN - TRUE if the compress stream was updated and FALSE if overran buffer

--*/

{
    ULONG abits;
    ULONG cbits;
    ULONG cbSave;
    ULONG mask;

    ASSERT(off > 0);
    ASSERT(off < wBACKPOINTERMAX);
    ASSERT(cb >= 2);

    DbgDoit( DbgPrint("<MrcfEncodeMatch>: off=%x len=%x\n",off,cb) );

    //
    //  Encode the match bits and offset portion
    //

    if (off < 64) {

        //
        //  Use 6-bit offset encoding
        //

        abits = (off << 2) | 0x0;   //  .00 = <offset>+<6-bit>+<match>

        if (!MrcfWriteNBits(abits,6+2,BitIo)) {

            //
            //  Opps overran the compression buffer
            //

            return FALSE;
        }

    } else if (off < 320) {

        //
        //  Use 8-bit offset encoding
        //

        abits = ((off -  64) << 3) | 0x3; // 0.11 = <offset>+<8-bit>+<match>

        if (!MrcfWriteNBits(abits,8+3,BitIo)) {

            //
            //  Opps overran the compression buffer
            //

            return FALSE;
        }

    } else { // (off >= 320)

        //
        //  Use 12-bit offset encoding
        //

        abits = ((off - 320) << 3) | 0x7; // 1.11 = <offset>+<12-bit>+<match>

        if (!MrcfWriteNBits(abits,12+3,BitIo)) {

            //
            //  Opps overran the compression buffer
            //

            return FALSE;
        }
    }

    //
    //  Encode the length logarithmically
    //

    cb -= 1;
    cbSave = cb;                        // Save to get remainder later
    cbits  = 0;

    while (cb > 1) {

        cbits++;

        //
        //  Put out another 0 for the length, and
        //  watch for buffer overflow
        //

        if (!MrcfWriteBit(0, BitIo)) {

            return FALSE;
        }

        //
        //  Shift count right (avoid sign bit)
        //

        ((USHORT)cb) >>= 1;
    }

    //
    //  Terminate length bit string
    //

    if (!MrcfWriteBit(1, BitIo)) {

        return FALSE;
    }

    if (cbits > 0) {

        //
        //  Mask for bits we want, and get remainder
        //

        mask = (1 << cbits) - 1;
        abits = cbSave & mask;

        if (!MrcfWriteNBits(abits,cbits,BitIo)) {

            return FALSE;
        }
    }

    return TRUE;
}


//
//  Internal Support Routine
//

BOOLEAN
MrcfWriteBit (
    ULONG bit,
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Write a bit to the bit buffer

Arguments:

    bit - bit to write (0 or 1)
    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    BOOLEAN - returns TRUE if the compresed bit stream was updated and
        FALSE if overran buffer.

--*/

{
    ASSERT((bit == 0) || (bit == 1));
    ASSERTMSG("Must be room for at least one bit ", (BitIo->cbitsBB) < 16);

    DbgDoit( DbgPrint("<MrcfWriteBit>: bit=%x\n",bit) );

    //
    //  Write one bit
    //

    (BitIo->abitsBB) |= bit << (BitIo->cbitsBB);
    (BitIo->cbitsBB)++;

    //
    //  Check if abitsBB is full and write compressed data buffer
    //

    if ((BitIo->cbitsBB) >= 16) {

        return (MrcfFlushBitBuffer(BitIo) != 0);

    } else {

        return TRUE;
    }
}


//
//  Internal Support Routine
//

BOOLEAN
MrcfWriteNBits (
    ULONG abits,
    LONG cbits,
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Write N bits to the bit buffer

Arguments:

    abits - bits to write

    cbits - count of bits write

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    BOOLEAN - returns TRUE if the compressed bit stream was updated and
        FALSE if overran buffer

--*/

{
    LONG cbitsPart;
    ULONG mask;

    ASSERT(cbits > 0);
    ASSERT(cbits <= 16);
    ASSERTMSG("Must be room for at least one bit ", (BitIo->cbitsBB) < 16);

    DbgDoit( DbgPrint("<MrcfWriteNBits>: bits=%04x count=%x\n",abits,cbits) );

    while (cbits > 0) {

        //
        //  Number of bits we can write
        //

        cbitsPart = min(16-(BitIo->cbitsBB), cbits);

        mask = (1 << cbitsPart) - 1;

        //
        //  Move part of bits to buffer
        //

        (BitIo->abitsBB) |= (abits & mask) << (BitIo->cbitsBB);

        //
        //  Update count of bits written
        //

        (BitIo->cbitsBB) += cbitsPart;

        //
        //  Check if buffer if full
        //

        if ((BitIo->cbitsBB) >= 16) {

            //
            //  Write compressed data buffer
            //

            if (!MrcfFlushBitBuffer(BitIo)) {

                return FALSE;
            }
        }

        //
        //  Reduce number of bits left to write and move remaining bits over
        //

        cbits -= cbitsPart;
        abits >>= cbitsPart;
    }

    return TRUE;
}


//
//  Internal Support Routine
//

ULONG
MrcfFlushBitBuffer (
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Write remaining bits to compressed data buffer

Arguments:

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

   ULONG - Returns total count of bytes written to the compressed data
        buffer since the last call to MrcfSetBitBuffer().  Returns 0 if
        overran buffer

--*/

{
    ASSERT((BitIo->cbitsBB) >= 0);
    ASSERT((BitIo->cbitsBB) <= 16);

    //
    //  Move bits to the compressed data buffer
    //

    while ((BitIo->cbitsBB) > 0) {

        //
        //  Process low and high half.
        //  Check if output buffer is out of room
        //

        if ((BitIo->cbBB) == 0) { return 0; }

        //
        //  Store a byte, adjust the count, get high half, nd adjust
        //  count of bits remaining
        //

        *(BitIo->pbBB)++ = (UCHAR)((BitIo->abitsBB) & 0xFF);
        (BitIo->cbBB)--;
        (BitIo->abitsBB) >>= 8;
        (BitIo->cbitsBB) -= 8;
    }

    //
    //  Reset bit buffer, "abitsBB >>= 8" guarantees abitsBB is clear
    //

    ASSERT((BitIo->abitsBB) == 0);

    (BitIo->cbitsBB) = 0;

    return (BitIo->cbBBInitial)-(BitIo->cbBB);
}

#endif // DOUBLE_SPACE_WRITE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\namesup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NameSup.c

Abstract:

    This module implements the Rx Name support routines

Author:

    Gary Kimura [GaryKi] & Tom Miller [TomM]    20-Feb-1990

Revision History:

--*/

//    ----------------------joejoe-----------found-------------#include "RxProcs.h"
#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_NAMESUP)

#define Dbg                              (DEBUG_TRACE_NAMESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Rx8dot3ToString)
#pragma alloc_text(PAGE, RxIsNameInExpression)
#pragma alloc_text(PAGE, RxStringTo8dot3)
#pragma alloc_text(PAGE, RxSetFullFileNameInFcb)
#pragma alloc_text(PAGE, RxGetUnicodeNameFromFcb)
#pragma alloc_text(PAGE, RxSelectNames)
#pragma alloc_text(PAGE, RxEvaluateNameCase)
#endif


BOOLEAN
RxIsNameInExpression (
    IN PRX_CONTEXT RxContext,
    IN OEM_STRING Expression,
    IN OEM_STRING Name
    )

/*++

Routine Description:

    This routine compare a name and an expression and tells the caller if
    the name is equal to or not equal to the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

Arguments:

    Expression - Supplies the input expression to check against
                 The caller must have already upcased the Expression.

    Name - Supplies the input name to check for.  The caller must have
           already upcased the name.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    //
    //  Call the appropriate FsRtl routine do to the real work
    //

    return FsRtlIsDbcsInExpression( &Expression,
                                    &Name );

    UNREFERENCED_PARAMETER( RxContext );
}


VOID
RxStringTo8dot3 (
    IN PRX_CONTEXT RxContext,
    IN OEM_STRING InputString,
    OUT PRDBSS8DOT3 Output8dot3
    )

/*++

Routine Description:

    Convert a string into rx 8.3 format.  The string must not contain
    any wildcards.

Arguments:

    InputString - Supplies the input string to convert

    Output8dot3 - Receives the converted string, the memory must be supplied
        by the caller.

Return Value:

    None.

--*/

{
    ULONG i;
    ULONG j;

    DebugTrace(+1, Dbg, "RxStringTo8dot3\n", 0);
    DebugTrace( 0, Dbg, "InputString = %wZ\n", &InputString);

    ASSERT( InputString.Length <= 12 );

    //
    //  Make the output name all blanks
    //

    for (i = 0; i < 11; i += 1) {

        (*Output8dot3)[i] = UCHAR_SP;
    }

    //
    //  Copy over the first part of the file name.  Stop when we get to
    //  the end of the input string or a dot.
    //

    for (i = 0;
         (i < (ULONG)InputString.Length) && (InputString.Buffer[i] != '.');
         i += 1) {

        (*Output8dot3)[i] = InputString.Buffer[i];
    }

    //
    //  Check if we need to process an extension
    //

    if (i < (ULONG)InputString.Length) {

        //
        //  Make sure we have a dot and then skip over it.
        //

        ASSERT( (InputString.Length - i) <= 4 );
        ASSERT( InputString.Buffer[i] == '.' );

        i += 1;

        //
        //  Copy over the extension.  Stop when we get to the
        //  end of the input string.
        //

        for (j = 8; (i < (ULONG)InputString.Length); j += 1, i += 1) {

            (*Output8dot3)[j] = InputString.Buffer[i];
        }
    }

    //
    //  Before we return check if we should translate the first character
    //  from 0xe5 to 0x5.
    //

    if ((*Output8dot3)[0] == 0xe5) {

        (*Output8dot3)[0] = RDBSS_DIRENT_REALLY_0E5;
    }

    DebugTrace(-1, Dbg, "RxStringTo8dot3 -> (VOID)\n", 0);

    UNREFERENCED_PARAMETER( RxContext );

    return;
}


VOID
Rx8dot3ToString (
    IN PRX_CONTEXT RxContext,
    IN PDIRENT Dirent,
    IN BOOLEAN RestoreCase,
    OUT POEM_STRING OutputString
    )

/*++

Routine Description:

    Convert rx 8.3 format into a string.  The 8.3 name must be well formed.

Arguments:

    Dirent - Supplies the input 8.3 name to convert

    RestoreCase - If TRUE, then the magic reserved bits are used to restore
        the original case.

    OutputString - Receives the converted name, the memory must be supplied
        by the caller.

Return Value:

    None

--*/

{
    ULONG i,j;

    DebugTrace(+1, Dbg, "Rx8dot3ToString\n", 0);

    //
    //  Copy over the 8 part of the 8.3 name into the output buffer
    //  and then make sure if the first character needs to be changed
    //  from 0x05 to 0xe5.  Then backup the index to the first non space
    //  character searching backwards
    //

    RtlCopyMemory( &OutputString->Buffer[0], &Dirent->FileName[0], 8 );

    if (OutputString->Buffer[0] == RDBSS_DIRENT_REALLY_0E5) {

        OutputString->Buffer[0] = (CHAR)0xe5;
    }

    for (i = 7; (i >= 0) && (OutputString->Buffer[i] == UCHAR_SP); i -= 1) {

        NOTHING;
    }

    ASSERT( i >= 0 );

    //
    //  Now if we are to restore case, look for A-Z
    //

    if (RxData.ChicagoMode &&
        RestoreCase &&
        FlagOn(Dirent->NtByte, RDBSS_DIRENT_NT_BYTE_8_LOWER_CASE)) {

        for (j = 0; j <= i; j += 1) {

            if ((OutputString->Buffer[j] >= 'A') &&
                (OutputString->Buffer[j] <= 'Z')) {

                OutputString->Buffer[j] += 'a' - 'A';
            }
        }
    }

    //
    //  Now add the dot
    //

    i += 1;
    OutputString->Buffer[i] = '.';

    //
    //  Copy over the extension into the output buffer and backup the
    //  index to the first non space character searching backwards
    //

    i += 1;
    RtlCopyMemory( &OutputString->Buffer[i], &Dirent->FileName[8], 3 );

    j = i;

    for (i += 2; OutputString->Buffer[i] == UCHAR_SP; i -= 1) {

        NOTHING;
    }

    //
    //  Now if the last character is a '.' then we don't have an extension
    //  so backup before the dot.
    //

    if (OutputString->Buffer[i] == '.') {

        i -= 1;
    }

    //
    //  Now if we are to restore case, look for A-Z
    //

    if (RxData.ChicagoMode &&
        RestoreCase &&
        FlagOn(Dirent->NtByte, RDBSS_DIRENT_NT_BYTE_3_LOWER_CASE)) {

        for (; j <= i; j += 1) {

            if ((OutputString->Buffer[j] >= 'A') &&
                (OutputString->Buffer[j] <= 'Z')) {

                OutputString->Buffer[j] += 'a' - 'A';
            }
        }
    }

    //
    //  Set the output string length
    //

    OutputString->Length = (USHORT)(i + 1);

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "Rx8dot3ToString, OutputString = \"%wZ\" -> VOID\n", OutputString);

    UNREFERENCED_PARAMETER( RxContext );

    return;
}

VOID
RxGetUnicodeNameFromFcb (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN OUT PUNICODE_STRING Lfn
    )

/*++

Routine Description:

    This routine will return the unicode name for a given Fcb.  If the
    file has an LFN, it will return this.  Otherwise it will return
    the UNICODE conversion of the Oem name, properly cased.

Arguments:

    Fcb - Supplies the Fcb to query.

    Lfn - Supplies a string that already has enough storage for the
        full unicode name.

Return Value:

    None

--*/

{
    PDIRENT Dirent;
    PBCB DirentBcb = NULL;
    ULONG DirentByteOffset;

    FOBX LocalFobx;

    //
    //  We'll start by locating the dirent for the name.
    //

    ASSERT(FALSE);

//    RxStringTo8dot3( RxContext,
//                      Fcb->ShortName.Name.Oem,
//                      &LocalFobx.OemQueryTemplate.Constant );

    LocalFobx.Flags = 0;
    LocalFobx.UnicodeQueryTemplate.Length = 0;
    LocalFobx.ContainsWildCards = FALSE;

    RxLocateDirent( RxContext,
                     Fcb->ParentDcb,
                     &LocalFobx,
                     Fcb->LfnOffsetWithinDirectory,
                     &Dirent,
                     &DirentBcb,
                     &DirentByteOffset,
                     Lfn );

    try {

        //
        //  If we didn't find the Dirent, something is terribly wrong.
        //

        if ((DirentBcb == NULL) ||
            (DirentByteOffset != Fcb->DirentOffsetWithinDirectory)) {

            RxRaiseStatus( RxContext, RxStatus(FILE_INVALID) );
        }

        //
        //  Check for the easy case.
        //

        if (Lfn->Length == 0) {

            RXSTATUS Status;
            OEM_STRING ShortName;
            UCHAR ShortNameBuffer[12];

            //
            //  There is no LFN, so manufacture a UNICODE name.
            //

            ShortName.Length = 0;
            ShortName.MaximumLength = 12;
            ShortName.Buffer = ShortNameBuffer;

            Rx8dot3ToString( RxContext, Dirent, TRUE, &ShortName );

            //
            //  OK, now convert this string to UNICODE
            //

            Status = RtlOemStringToCountedUnicodeString( Lfn,
                                                         &ShortName,
                                                         FALSE );

            ASSERT( Status == RxStatus(SUCCESS) );
        }

    } finally {

        RxUnpinBcb( RxContext, DirentBcb );
    }
}

VOID
RxSetFullFileNameInFcb (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    If the FullFileName field in the Fcb has not yet been filled in, we
    proceed to do so.

Arguments:

    Fcb - Supplies the file.

Return Value:

    None

--*/

{
    if (Fcb->FullFileName.Buffer == NULL) {

        UNICODE_STRING Lfn;
        PFCB TmpFcb = Fcb;
        PFCB StopFcb;
        PWCHAR TmpBuffer;
        ULONG PathLength = 0;

        //
        //  We will assume we do this infrequently enough, that it's OK to
        //  to a pool allocation here.
        //

        Lfn.Length = 0;
        Lfn.MaximumLength = MAX_LFN_CHARACTERS * sizeof(WCHAR);
        Lfn.Buffer = FsRtlAllocatePool( PagedPool,
                                        MAX_LFN_CHARACTERS * sizeof(WCHAR) );

        try {

            //
            //  First determine how big the name will be.  If we find an
            //  ancestor with a FullFileName, our work is easier.
            //

            while (TmpFcb != Fcb->Vcb->RootDcb) {

                if ((TmpFcb != Fcb) && (TmpFcb->FullFileName.Buffer != NULL)) {

                    PathLength += TmpFcb->FullFileName.Length;

                    Fcb->FullFileName.Buffer = FsRtlAllocatePool( PagedPool, PathLength );

                    RtlCopyMemory( Fcb->FullFileName.Buffer,
                                   TmpFcb->FullFileName.Buffer,
                                   TmpFcb->FullFileName.Length );

                    break;
                }

                PathLength += TmpFcb->FinalNameLength + sizeof(WCHAR);

                TmpFcb = TmpFcb->ParentDcb;
            }

            //
            //  If FullFileName.Buffer is still NULL, allocate it.
            //

            if (Fcb->FullFileName.Buffer == NULL) {

                Fcb->FullFileName.Buffer = FsRtlAllocatePool( PagedPool, PathLength );
            }

            StopFcb = TmpFcb;

            TmpFcb = Fcb;
            TmpBuffer =  Fcb->FullFileName.Buffer + PathLength / sizeof(WCHAR);

            Fcb->FullFileName.Length =
            Fcb->FullFileName.MaximumLength = (USHORT)PathLength;

            while (TmpFcb != StopFcb) {

                RxGetUnicodeNameFromFcb( RxContext,
                                          TmpFcb,
                                          &Lfn );

                TmpBuffer -= Lfn.Length / sizeof(WCHAR);

                RtlCopyMemory( TmpBuffer, Lfn.Buffer, Lfn.Length );

                TmpBuffer -= 1;

                *TmpBuffer = L'\\';

                TmpFcb = TmpFcb->ParentDcb;
            }

        } finally {

            if (AbnormalTermination()) {

                if (Fcb->FullFileName.Buffer) {

                    ExFreePool( Fcb->FullFileName.Buffer );
                    Fcb->FullFileName.Buffer = NULL;
                }
            }

            ExFreePool( Lfn.Buffer );
        }
    }
}

VOID
RxUnicodeToUpcaseOem (
    IN PRX_CONTEXT RxContext,
    IN POEM_STRING OemString,
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine is our standard routine for trying to use stack space
    if possible when calling RtlUpcaseUnicodeStringToCountedOemString().

    If an unmappable character is encountered, we set the destination
    length to 0.

Arguments:

    OemString - Specifies the destination string.  Space is already assumed to
        be allocated.  If there is not enough, then we allocate enough
        space.

    UnicodeString - Specifies the source string.

Return Value:

    None.

--*/

{
    RXSTATUS Status;

    Status = RtlUpcaseUnicodeStringToCountedOemString( OemString,
                                                       UnicodeString,
                                                       FALSE );

    if (Status == RxStatus(BUFFER_OVERFLOW)) {

        OemString->Buffer = NULL;
        OemString->Length = 0;
        OemString->MaximumLength = 0;

        Status = RtlUpcaseUnicodeStringToCountedOemString( OemString,
                                                           UnicodeString,
                                                           TRUE );
    }

    if (!NT_SUCCESS(Status)) {

        if (Status == RxStatus(UNMAPPABLE_CHARACTER)) {

            OemString->Length = 0;

        } else {

            RxNormalizeAndRaiseStatus( RxContext, Status );
        }
    }

    return;
}

VOID
RxSelectNames (
    IN PRX_CONTEXT RxContext,
    IN PDCB Parent,
    IN POEM_STRING OemName,
    IN PUNICODE_STRING UnicodeName,
    IN OUT POEM_STRING ShortName,
    IN OUT BOOLEAN *AllLowerComponent,
    IN OUT BOOLEAN *AllLowerExtension,
    IN OUT BOOLEAN *CreateLfn
    )

/*++

Routine Description:

    This routine takes the original UNICODE string that the user specified,
    and the upcased Oem equivolent.  This routine then decides if the OemName
    is acceptable for dirent, or whether a short name has to be manufactured.

    Two values are returned to the caller.  One tells the caller if the name
    happens to be all lower case < 0x80.  In this special case we don't
    have to create an Lfn.  Also we tell the caller if it must create an LFN.

Arguments:

    OemName -  Supplies the proposed short Oem name.

    ShortName - If this OemName is OK for storeage in a dirent it is copied to
        this string, otherwise this string is filled with a name that is OK.
        If OemName and ShortName are the same string, no copy is done.

    UnicodeName - Provides the original final name.

    AllLowerComponent - Returns whether this compoent was all lower case.

    AllLowerExtension - Returns wheather the extension was all lower case.

    CreateLfn - Tells the call if we must create an LFN for the UnicodeName.

Return Value:

    None.

--*/

{
    BOOLEAN GenerateShortName;

    PAGED_CODE();

    //
    //  First see if we must generate a short name.
    //

    if ((OemName->Length == 0) ||
        !RxIsNameValid( RxContext, *OemName, FALSE, FALSE, FALSE )) {

        WCHAR ShortNameBuffer[12];
        UNICODE_STRING ShortUnicodeName;
        GENERATE_NAME_CONTEXT Context;

        GenerateShortName = TRUE;

        //
        //  Now generate a short name.
        //

        ShortUnicodeName.Length = 0;
        ShortUnicodeName.MaximumLength = 12 * sizeof(WCHAR);
        ShortUnicodeName.Buffer = ShortNameBuffer;

        RtlZeroMemory( &Context, sizeof( GENERATE_NAME_CONTEXT ) );

        while ( TRUE ) {

            PDIRENT Dirent;
            PBCB Bcb = NULL;
            ULONG ByteOffset;
            RXSTATUS Status;

            RtlGenerate8dot3Name( UnicodeName, TRUE, &Context, &ShortUnicodeName );

            //
            //  We have a candidate, make sure it doesn't exist.
            //

            Status = RtlUnicodeStringToCountedOemString( ShortName,
                                                         &ShortUnicodeName,
                                                         FALSE );

            ASSERT( Status == RxStatus(SUCCESS) );

            RxLocateSimpleOemDirent( RxContext,
                                      Parent,
                                      ShortName,
                                      &Dirent,
                                      &Bcb,
                                      &ByteOffset );

            if (Bcb == NULL) {

                break;

            } else {

                RxUnpinBcb( RxContext, Bcb );
            }
        }

    } else {

        //
        //  Only do this copy if the two string are indeed different.
        //

        if (ShortName != OemName) {

            ShortName->Length = OemName->Length;
            RtlCopyMemory( ShortName->Buffer, OemName->Buffer, OemName->Length );
        }

        GenerateShortName = FALSE;
    }

    //
    //  Now see if the caller will have to use unicode string as an LFN
    //

    if (GenerateShortName) {

        *CreateLfn = TRUE;
        *AllLowerComponent = FALSE;
        *AllLowerExtension = FALSE;

    } else {

        RxEvaluateNameCase( RxContext,
                             UnicodeName,
                             AllLowerComponent,
                             AllLowerExtension,
                             CreateLfn );
    }

    return;
}

VOID
RxEvaluateNameCase (
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING UnicodeName,
    IN OUT BOOLEAN *AllLowerComponent,
    IN OUT BOOLEAN *AllLowerExtension,
    IN OUT BOOLEAN *CreateLfn
    )

/*++

Routine Description:

    This routine takes a UNICODE string and sees if it is eligible for
    the special case optimization.

Arguments:

    UnicodeName - Provides the original final name.

    AllLowerComponent - Returns whether this compoent was all lower case.

    AllLowerExtension - Returns wheather the extension was all lower case.

    CreateLfn - Tells the call if we must create an LFN for the UnicodeName.

Return Value:

    None.

--*/

{
    ULONG i;
    UCHAR Uppers = 0;
    UCHAR Lowers = 0;

    BOOLEAN ExtensionPresent = FALSE;

    *CreateLfn = FALSE;

    for (i = 0; i < UnicodeName->Length / sizeof(WCHAR); i++) {

        WCHAR c;

        c = UnicodeName->Buffer[i];

        if ((c >= 'A') && (c <= 'Z')) {

            Uppers += 1;

        } else if ((c >= 'a') && (c <= 'z')) {

            Lowers += 1;

        } else if (c >= 0x0080) {

            break;
        }

        //
        //  If we come to a period, figure out if the extension was
        //  all one case.
        //

        if (c == L'.') {

            *CreateLfn = (Lowers != 0) && (Uppers != 0);

            *AllLowerComponent = !(*CreateLfn) && (Lowers != 0);

            ExtensionPresent = TRUE;

            //
            //  Now reset the uppers and lowers count.
            //

            Uppers = Lowers = 0;
        }
    }

    //
    //  Now check again for creating an LFN.
    //

    *CreateLfn = (*CreateLfn ||
                  (i != UnicodeName->Length / sizeof(WCHAR)) ||
                  ((Lowers != 0) && (Uppers != 0)));

    //
    //  Now we know the final state of CreateLfn, update the two
    //  "AllLower" booleans.
    //

    if (ExtensionPresent) {

        *AllLowerComponent = !(*CreateLfn) && *AllLowerComponent;
        *AllLowerExtension = !(*CreateLfn) && (Lowers != 0);

    } else {

        *AllLowerComponent = !(*CreateLfn) && (Lowers != 0);
        *AllLowerExtension = FALSE;
    }

    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\scavthrd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    scavthrd.c

Abstract:

    This module implements the scavenger thread and its dispatch.

Author:

    Joe Linn  [JoeLinn]  19-aug-1994

Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include "scavthrd.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_SCAVTHRD)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_SCAVTHRD)


//
//      This counter is used to control kicking the scavenger thread.
//
LONG RxTimerCounter;
ULONG RxTimerCounterPeriod = RX_TIMER_COUNTER_PERIOD;

//WORK_QUEUE_ITEM CancelWorkItem;
WORK_QUEUE_ITEM TimerWorkItem;

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE,RxTimer)
#endif

VOID
RxTimer (
    IN PVOID Context
    )

/*++

Routine Description:

    This function implements the NT redirector's scavenger thread.  It performs idle time operations
    such as closing out dormant connections etc. It is run on an executive worker thread from the
    delayed queue as can be seen below.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    RxDbgTrace(0, (DEBUG_TRACE_SHUTDOWN), ("RxTimer\n", 0));               //joejoe shutdown may be a bad choice

    TimerWorkItem.List.Flink = NULL;    // this is used to specifically signal a requeueable state
/*  this is larry's old code
    //
    //  First scan for dormant connections to remove.
    //

    RxScanForDormantConnections(0, NULL);

    //RxScanForDormantSecurityEntries();

    //
    //  Now check the list of open outstanding files and remove any that are
    //  "too old" from the cache.
    //

    RxPurgeDormantCachedFiles();

    //
    //  Request updated throughput, delay and reliability information from the
    //  transport for each connection.
    //

    RxEvaluateTimeouts();


    //
    //  Now "PING" remote servers for longterm requests that have been active
    //  for more than the timeout period.
    //

    RxPingLongtermOperations();

*/
    UNREFERENCED_PARAMETER(Context);
}


VOID
RxIdleTimer (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is the Timer DPC for the scavenger timer. What happens is that it down to the period value
    and then queues an executive work item to the delayed queue.


Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object for the timer
    IN PVOID Context - Ignored in this routine.

Return Value:

    None.

--*/

{
    RxElapsedSecondsSinceStart++;                 //keep running count of the elapsed time

    //
    //  Check to see if it's time ttime to do anything
    //joejoe we should specifically have something to do before we trot off but not now

    if (--RxTimerCounter <= 0) {

        RxTimerCounter = RxTimerCounterPeriod;

// /       //
// /       //  If there are any outstanding commands, check to see if they've
// /       //  timed out.
// /       //

// /       if (RxStatistics.CurrentCommands != 0) {

// /           //
// /           //  Please note that we use the kernel work queue routines directly for
// /           //  this instead of going through the normal redirector work queue
// /           //  routines.  We do this because the redirector work queue routines will
// /           //  only allow a limited number of requests through to the worker threads,
// /           //  and it is critical that this request run (if it didn't, there could be
// /           //  a worker thread that was blocked waiting on the request to be canceled
// /           //  could never happen because the cancelation routine was behind it on
// /           //  the work queue.
// /           //

// /           if (CancelWorkItem.List.Flink == NULL) {
// /               RxQueueWorkItem(&CancelWorkItem, CriticalWorkQueue);
// /           }
// /       }

        //
        //  Queue up a scavenger request to a worker thread if the quy is not already enqueued.
        //

        if (TimerWorkItem.List.Flink == NULL) {
//            RxQueueWorkItem(&TimerWorkItem, DelayedWorkQueue);
            RxQueueWorkItem( &TimerWorkItem, DelayedWorkQueue );

        }

    }

    return;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Context);
}

VOID
RxInitializeScavenger (
    VOID
    )
/*++

Routine Description:

    Initialize workitems, timers, counters to implement the dispatch to the RxTimer routine.


Arguments:

    None.

Return Value:

    None.

--*/

{
    RxInitializeWorkItem( &TimerWorkItem, RxTimer, NULL );
//    RxInitializeWorkItem( &CancelWorkItem, RxCancelOutstandingRequests, NULL );

    //
    //  Set the timer up for the idle timer.
    //

    RxElapsedSecondsSinceStart = 0;
    RxTimerCounter = RxTimerCounterPeriod;
    IoInitializeTimer((PDEVICE_OBJECT)RxFileSystemDeviceObject, RxIdleTimer, NULL);
    IoStartTimer((PDEVICE_OBJECT)RxFileSystemDeviceObject);

    return;
}


VOID
RxUninitializeScavenger (
    VOID
    )
/*++

Routine Description:

    Stops the timer used to dispatch to the RxTimer routine.

Arguments:

    None.

Return Value:

    None.

--*/

{
    IoStopTimer((PDEVICE_OBJECT)RxFileSystemDeviceObject);

    return;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\timesup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    TimeSup.c

Abstract:

    This module implements the Rx Time conversion support routines

Author:

    Gary Kimura     [GaryKi]    19-Feb-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_TIMESUP)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_TIMESUP)


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxNtTimeToRxTime)
#pragma alloc_text(PAGE, RxRxDateToNtTime)
#pragma alloc_text(PAGE, RxRxTimeToNtTime)
#pragma alloc_text(PAGE, RxGetCurrentRxTime)
#endif

BOOLEAN
RxNtTimeToRxTime (
    IN PRX_CONTEXT RxContext,
    IN LARGE_INTEGER NtTime,
    OUT PRDBSS_TIME_STAMP RxTime
    )

/*++

Routine Description:

    This routine converts an NtTime value to its corresponding Rx time value.

Arguments:

    NtTime - Supplies the Nt GMT Time value to convert from

    RxTime - Receives the equivalent Rx time value

Return Value:

    BOOLEAN - TRUE if the Nt time value is within the range of Rx's
        time range, and FALSE otherwise

--*/

{
    TIME_FIELDS TimeFields;

    //
    //  Convert the input to the a time field record.  Always add
    //  almost two seconds to round up to the nearest double second.
    //

    NtTime.QuadPart = NtTime.QuadPart + (LONGLONG)AlmostTwoSeconds;

    RxSystemTimeToLocalTime( &NtTime, &NtTime );

    RtlTimeToTimeFields( &NtTime, &TimeFields );

    //
    //  Check the range of the date found in the time field record
    //

    if ((TimeFields.Year < 1980) || (TimeFields.Year > (1980 + 127))) {

        return FALSE;
    }

    //
    //  The year will fit in Rx so simply copy over the information
    //

    RxTime->Time.DoubleSeconds = (USHORT)(TimeFields.Second / 2);
    RxTime->Time.Minute        = (USHORT)(TimeFields.Minute);
    RxTime->Time.Hour          = (USHORT)(TimeFields.Hour);

    RxTime->Date.Year          = (USHORT)(TimeFields.Year - 1980);
    RxTime->Date.Month         = (USHORT)(TimeFields.Month);
    RxTime->Date.Day           = (USHORT)(TimeFields.Day);

    UNREFERENCED_PARAMETER( RxContext );

    return TRUE;
}


LARGE_INTEGER
RxRxDateToNtTime (
    IN PRX_CONTEXT RxContext,
    IN RDBSS_DATE RxDate
    )

/*++

Routine Description:

    This routine converts a Rx datev value to its corresponding Nt GMT
    Time value.

Arguments:

    RxDate - Supplies the Rx Date to convert from

Return Value:

    LARGE_INTEGER - Receives the corresponding Nt Time value

--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER Time;

    //
    //  Pack the input time/date into a time field record
    //

    TimeFields.Year         = (USHORT)(RxDate.Year + 1980);
    TimeFields.Month        = (USHORT)(RxDate.Month);
    TimeFields.Day          = (USHORT)(RxDate.Day);
    TimeFields.Hour         = (USHORT)0;
    TimeFields.Minute       = (USHORT)0;
    TimeFields.Second       = (USHORT)0;
    TimeFields.Milliseconds = (USHORT)0;

    //
    //  Convert the time field record to Nt LARGE_INTEGER, and set it to zero
    //  if we were given a bogus time.
    //

    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {

        Time.LowPart = 0;
        Time.HighPart = 0;

    } else {

        RxLocalTimeToSystemTime( &Time, &Time );
    }

    return Time;

    UNREFERENCED_PARAMETER( RxContext );
}


LARGE_INTEGER
RxRxTimeToNtTime (
    IN PRX_CONTEXT RxContext,
    IN RDBSS_TIME_STAMP RxTime,
    IN UCHAR TenMilliSeconds
    )

/*++

Routine Description:

    This routine converts a Rx time value pair to its corresponding Nt GMT
    Time value.

Arguments:

    RxTime - Supplies the Rx Time to convert from

    TenMilliSeconds - A 10 Milisecond resolution

Return Value:

    LARGE_INTEGER - Receives the corresponding Nt GMT Time value

--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER Time;

    //
    //  Pack the input time/date into a time field record
    //

    TimeFields.Year         = (USHORT)(RxTime.Date.Year + 1980);
    TimeFields.Month        = (USHORT)(RxTime.Date.Month);
    TimeFields.Day          = (USHORT)(RxTime.Date.Day);
    TimeFields.Hour         = (USHORT)(RxTime.Time.Hour);
    TimeFields.Minute       = (USHORT)(RxTime.Time.Minute);
    TimeFields.Second       = (USHORT)(RxTime.Time.DoubleSeconds * 2);

    if (TenMilliSeconds != 0) {

        TimeFields.Second      += (USHORT)(TenMilliSeconds / 100);
        TimeFields.Milliseconds = (USHORT)(TenMilliSeconds % 100);

    } else {

        TimeFields.Milliseconds = (USHORT)0;
    }

    //
    //  If the second value is greater than 59 then we truncate it to 0.
    //

    if (TimeFields.Second > 59) {

        TimeFields.Second = 0;
    }

    //
    //  Convert the time field record to Nt LARGE_INTEGER, and set it to zero
    //  if we were given a bogus time.
    //

    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {

        Time.LowPart = 0;
        Time.HighPart = 0;

    } else {

        RxLocalTimeToSystemTime( &Time, &Time );
    }

    return Time;

    UNREFERENCED_PARAMETER( RxContext );
}


RDBSS_TIME_STAMP
RxGetCurrentRxTime (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine returns the current system time in Rx time

Arguments:

Return Value:

    RDBSS_TIME_STAMP - Receives the current system time

--*/

{
    LARGE_INTEGER Time;
    TIME_FIELDS TimeFields;
    RDBSS_TIME_STAMP RxTime;

    //
    //  Get the current system time, and map it into a time field record.
    //

    RxQuerySystemTime( &Time );

    RxSystemTimeToLocalTime( &Time, &Time );

    //
    //  Always add almost two seconds to round up to the nearest double second.
    //

    Time.QuadPart = Time.QuadPart + (LONGLONG)AlmostTwoSeconds;

    (VOID)RtlTimeToTimeFields( &Time, &TimeFields );

    //
    //  Now simply copy over the information
    //

    RxTime.Time.DoubleSeconds = (USHORT)(TimeFields.Second / 2);
    RxTime.Time.Minute        = (USHORT)(TimeFields.Minute);
    RxTime.Time.Hour          = (USHORT)(TimeFields.Hour);

    RxTime.Date.Year          = (USHORT)(TimeFields.Year - 1980);
    RxTime.Date.Month         = (USHORT)(TimeFields.Month);
    RxTime.Date.Day           = (USHORT)(TimeFields.Day);

    UNREFERENCED_PARAMETER( RxContext );

    return RxTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\splaysup.c ===
/*++

DANGER   DANGER   DANGER

ALL THE STUFF IN THIS FILE IS OBSOLETE BUT IS BEING TEMPORARILY MAINTAINED
IN CASE WE WANT TO GRAP SOMETHING. ALL THE CODE IS IFDEF'D OUT.





























Copyright (c) 1989  Microsoft Corporation

Module Name:

    PrefxSup.c

Abstract:

    This module implements the Rx Name lookup Suport routines

Author:

    David Goebel     [DavidGoe]    31-Jan-1994

Revision History:

--*/

//    ----------------------joejoe-----------found-------------#include "RxProcs.h"
#include "precomp.h"
#pragma hdrstop


#ifdef RDBSS_OBSOLETE



//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_SPLAYSUP)

//
//  The debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_SPLAYSUP)

//
//  Local procedures and types used only in this package
//

typedef enum _COMPARISON {
    IsLessThan,
    IsGreaterThan,
    IsEqual
} COMPARISON;

COMPARISON
RxCompareNames (
    IN PSTRING NameA,
    IN PSTRING NameB
    );

//
//  Do a macro here to check for a common case.
//

#define CompareNames(NAMEA,NAMEB) (                        \
    *(PUCHAR)(NAMEA)->Buffer != *(PUCHAR)(NAMEB)->Buffer ? \
    *(PUCHAR)(NAMEA)->Buffer < *(PUCHAR)(NAMEB)->Buffer ?  \
    IsLessThan : IsGreaterThan :                           \
    RxCompareNames((PSTRING)(NAMEA), (PSTRING)(NAMEB))    \
)


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInsertName)
#pragma alloc_text(PAGE, RxRemoveNames)
#pragma alloc_text(PAGE, RxFindFcb)
#pragma alloc_text(PAGE, RxCompareNames)
#endif


VOID
RxInsertName (
    IN PRX_CONTEXT RxContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PFILE_NAME_NODE Name
    )

/*++

Routine Description:

    This routine will insert a name in the splay tree pointed to
    by RootNode.

    The name must not already exist in the splay tree.

Arguments:

    RootNode - Supplies a pointer to the table.

    Name - Contains the New name to enter.

Return Value:

    None.

--*/

{
    COMPARISON Comparison;
    PFILE_NAME_NODE Node;

    RtlInitializeSplayLinks(&Name->Links);

    //
    //  If we are the first entry in the tree, just become the root.
    //

    if (*RootNode == NULL) {

        *RootNode = &Name->Links;

        return;
    }

    Node = CONTAINING_RECORD( *RootNode, FILE_NAME_NODE, Links );

    while (TRUE) {

        //
        //  Compare the prefix in the tree with the prefix we want
        //  to insert.  Note that Oem here doesn't mean anything.
        //

        Comparison = CompareNames(&Node->Name.Oem, &Name->Name.Oem);

        //
        //  We should never find the name in the table already.
        //

        if (Comparison == IsEqual) {

            RxBugCheck( 0, 0, 0 );
        }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == IsGreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild(&Node->Links) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                RtlInsertAsLeftChild(&Node->Links, &Name->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild(&Node->Links),
                                          FILE_NAME_NODE,
                                          Links );
            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases a less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild(&Node->Links) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                RtlInsertAsRightChild(&Node->Links, &Name->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild(&Node->Links),
                                          FILE_NAME_NODE,
                                          Links );
            }

        }
    }

    return;
}

VOID
RxRemoveNames (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine will remove the short name and any long names associated
    with the files from their repsective splay tree.

Arguments:

    Name - Supplies the Fcb to process.

Return Value:

    None.

--*/

{
    PDCB Parent;
    PRTL_SPLAY_LINKS NewRoot;

    Parent = Fcb->ParentDcb;

    ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE ));

    if (FlagOn( Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE )) {

        //
        //  Delete the node short name.
        //

        NewRoot = RtlDelete(&Fcb->ShortName.Links);

        Parent->Specific.Dcb.RootOemNode = NewRoot;

        //
        //  Now check for the presence of long name and delete it.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_HAS_OEM_LONG_NAME )) {

            NewRoot = RtlDelete(&Fcb->LongName.Oem.Links);

            Parent->Specific.Dcb.RootOemNode = NewRoot;

            RtlFreeOemString( &Fcb->LongName.Oem.Name.Oem );

            ClearFlag( Fcb->FcbState, FCB_STATE_HAS_OEM_LONG_NAME );
        }

        if (FlagOn( Fcb->FcbState, FCB_STATE_HAS_UNICODE_LONG_NAME )) {

            NewRoot = RtlDelete(&Fcb->LongName.Unicode.Links);

            Parent->Specific.Dcb.RootUnicodeNode = NewRoot;

            RtlFreeUnicodeString( &Fcb->LongName.Unicode.Name.Unicode );

            ClearFlag( Fcb->FcbState, FCB_STATE_HAS_UNICODE_LONG_NAME );
        }

        ClearFlag( Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE );
    }

    return;
}


PFCB
RxFindFcb (
    IN PRX_CONTEXT RxContext,
    IN OUT PRTL_SPLAY_LINKS *RootNode,
    IN PSTRING Name
    )

/*++

Routine Description:

    This routine searches either the Oem or Unicode splay tree looking
    for an Fcb with the specified name.  In the case the Fcb is found,
    rebalance the tree.

Arguments:

    RootNode - Supplies the parent to search.

    Name - If present, search the Oem tree.

    UnicodeName - If present, search the Unicode tree.

Return Value:

    PFCB - The Fcb, or NULL if none was found.

--*/

{
    COMPARISON Comparison;
    PFILE_NAME_NODE Node;
    PRTL_SPLAY_LINKS Links;

    Links = *RootNode;

    while (Links != NULL) {

        Node = CONTAINING_RECORD(Links, FILE_NAME_NODE, Links);

        //
        //  Compare the prefix in the tree with the full name
        //

        Comparison = CompareNames(&Node->Name.Oem, Name);

        //
        //  See if they don't match
        //

        if (Comparison == IsGreaterThan) {

            //
            //  The prefix is greater than the full name
            //  so we go down the left child
            //

            Links = RtlLeftChild(Links);

            //
            //  And continue searching down this tree
            //

        } else if (Comparison == IsLessThan) {

            //
            //  The prefix is less than the full name
            //  so we go down the right child
            //

            Links = RtlRightChild(Links);

            //
            //  And continue searching down this tree
            //

        } else {

            //
            //  We found it.
            //
            //  Splay the tree and save the new root.
            //

            *RootNode = RtlSplay(Links);

            return Node->Fcb;
        }
    }

    //
    //  We didn't find the Fcb.
    //

    return NULL;
}


//
//  Local support routine
//

COMPARISON
RxCompareNames (
    IN PSTRING NameA,
    IN PSTRING NameB
    )

/*++

Routine Description:

    This function compares two names as fast as possible.  Note that since
    this comparison is case sensitive, I neither know nor case if the names
    are UNICODE or OEM.  All that is important is that the result is
    deterministic.

Arguments:

    NameA & NameB - The names to compare.

Return Value:

    COMPARISON - returns

        IsLessThan    if NameA < NameB lexicalgraphically,
        IsGreaterThan if NameA > NameB lexicalgraphically,
        IsEqual       if NameA is equal to NameB

--*/

{
    ULONG i;
    ULONG MinLength;

    PAGED_CODE();

    //
    //  Figure out the minimum of the two lengths
    //

    MinLength = NameA->Length < NameB->Length ? NameA->Length :
                                                NameB->Length;

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equalilty, less than, and greater than
    //

    i = RtlCompareMemory( NameA->Buffer, NameB->Buffer, MinLength );


    if (i < MinLength) {

        return NameA->Buffer[i] < NameB->Buffer[i] ? IsLessThan :
                                                     IsGreaterThan;
    }

    if (NameA->Length < NameB->Length) {

        return IsLessThan;
    }

    if (NameA->Length > NameB->Length) {

        return IsGreaterThan;
    }

    return IsEqual;
}

#endif if //RDBSS_OBSOLETE ...global to remove this code
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\strucsup.c ===
/*++



DANGER   DANGER   DANGER

ALL THE STUFF IN THIS FILE IS OBSOLETE BUT IS BEING TEMPORARILY MAINTAINED
IN CASE WE WANT TO GRAP SOMETHING. THE CODE IS BEING SYSTEMATICALLY IFDEF'D OUT.
































Copyright (c) 1989  Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module implements the Rx in-memory data structure manipulation
    routines

Author:

    Gary Kimura     [GaryKi]    22-Jan-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#define RxFindFcb( __x, __y, __z) ((PFCB)( (RtlAssert("dont call rxfindfcb", __FILE__, __LINE__, NULL),0)))
#define RxInsertName( __x, __y, __z) ((PFCB)( (RtlAssert("dont call rxfindfcb", __FILE__, __LINE__, NULL),0)))
#define RxRemoveNames( __x, __z) ((PFCB)( (RtlAssert("dont call rxfindfcb", __FILE__, __LINE__, NULL),0)))

//
//**** include this file for our quick hacked quota check in NtfsFreePagedPool
//

// #include <pool.h>

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_STRUCSUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUCSUP)

#define FillMemory(BUF,SIZ,MASK) {                          \
    ULONG i;                                                \
    for (i = 0; i < (((SIZ)/4) - 1); i += 2) {              \
        ((PULONG)(BUF))[i] = (MASK);                        \
        ((PULONG)(BUF))[i+1] = (ULONG)PsGetCurrentThread(); \
    }                                                       \
}

#define RX_CONTEXT_HEADER (sizeof( RX_CONTEXT ) * 0x10000 + RDBSS_NTC_RX_CONTEXT)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeVcb)
#pragma alloc_text(PAGE, RxDeleteVcb_Real)
#pragma alloc_text(PAGE, RxCreateRootDcb)
#pragma alloc_text(PAGE, RxCreateFcb)
#pragma alloc_text(PAGE, RxCreateDcb)
#pragma alloc_text(PAGE, RxDeleteFcb_Real)
#pragma alloc_text(PAGE, RxCreateFobx)
#pragma alloc_text(PAGE, RxDeleteFobx_Real)
#pragma alloc_text(PAGE, RxGetNextFcb)
#pragma alloc_text(PAGE, RxConstructNamesInFcb)
#pragma alloc_text(PAGE, RxCheckFreeDirentBitmap)
#endif


VOID
RxInitializeVcb (
    IN PRX_CONTEXT RxContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PDSCB Dscb OPTIONAL
    )

/*++

Routine Description:

    This routine initializes and inserts a new Vcb record into the in-memory
    data structure.  The Vcb record "hangs" off the end of the Volume device
    object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

    TargetDeviceObject - Supplies the address of the target device object to
        associate with the Vcb record.

    Vpb - Supplies the address of the Vpb to associate with the Vcb record.

    Dscb - If present supplies the associated Double Space control block

Return Value:

    None.

--*/

{
    CC_FILE_SIZES FileSizes;
    PDEVICE_OBJECT RealDevice;

    //
    //  The following variables are used for abnormal unwind
    //

    PLIST_ENTRY UnwindEntryList = NULL;
    PERESOURCE UnwindResource = NULL;
    PERESOURCE UnwindVolFileResource = NULL;
    PFILE_OBJECT UnwindFileObject = NULL;
    PFILE_OBJECT UnwindCacheMap = NULL;
    BOOLEAN UnwindWeAllocatedMcb = FALSE;

    DebugTrace(+1, Dbg, "RxInitializeVcb, Vcb = %08lx\n", Vcb);
    ASSERT(FALSE);

    try {

        //
        //  We start by first zeroing out all of the VCB, this will guarantee
        //  that any stale data is wiped clean
        //

        RtlZeroMemory( Vcb, sizeof(VCB) );

        //
        //  Set the proper node type code and node byte size
        //

        Vcb->NodeTypeCode = RDBSS_NTC_VCB;
        Vcb->NodeByteSize = sizeof(VCB);

        //
        //  Insert this Vcb record on the RxData.VcbQueue
        //

        ASSERT( FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT) );

        (VOID)RxAcquireExclusiveGlobal( RxContext );
        InsertTailList( &RxData.VcbQueue, &Vcb->VcbLinks );
        RxReleaseGlobal( RxContext );
        UnwindEntryList = &Vcb->VcbLinks;

        //
        //  Set the Target Device Object, Vpb, and Vcb State fields
        //

        Vcb->TargetDeviceObject = TargetDeviceObject;
        Vcb->Vpb = Vpb;

        //
        //  If this is a DoubleSpace volume note our "special" device.
        //

        Vcb->CurrentDevice = ARGUMENT_PRESENT(Dscb) ?
                             Dscb->NewDevice : Vpb->RealDevice;

        //
        //  Set the removable media and floppy flag based on the real device's
        //  characteristics.
        //

        if (FlagOn(Vpb->RealDevice->Characteristics, FILE_REMOVABLE_MEDIA)) {

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA );
        }

        if (FlagOn(Vpb->RealDevice->Characteristics, FILE_FLOPPY_DISKETTE)) {

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_FLOPPY );
        }

        Vcb->VcbCondition = VcbGood;

        //
        //  Initialize the resource variable for the Vcb
        //

        ExInitializeResource( &Vcb->Resource );
        UnwindResource = &Vcb->Resource;

        //
        //  Initialize the free cluster bitmap event.
        //

        KeInitializeEvent( &Vcb->FreeClusterBitMapEvent,
                           SynchronizationEvent,
                           TRUE );

        //
        //  Now, put the Dscb parameter in the Vcb.  If NULL, this is a normal
        //  mount and non-cached IO will go directly to the target device
        //  object.  If non-NULL, the DSCB structure contains all the
        //  information needed to do the redirected reads and writes.
        //

        InitializeListHead(&Vcb->ParentDscbLinks);

        if (ARGUMENT_PRESENT(Dscb)) {

            Vcb->Dscb = Dscb;
            Dscb->Vcb = Vcb;

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_COMPRESSED_VOLUME );
        }

        //
        //  Create the special file object for the virtual volume file, and set
        //  up its pointers back to the Vcb and the section object pointer
        //

        RealDevice = Vcb->CurrentDevice;

        Vcb->VirtualVolumeFile = UnwindFileObject = IoCreateStreamFileObject( NULL, RealDevice );

        RxSetFileObject( Vcb->VirtualVolumeFile,
                          VirtualVolumeFile,
                          Vcb,
                          NULL );

        Vcb->VirtualVolumeFile->SectionObjectPointer = &Vcb->SectionObjectPointers;

        Vcb->VirtualVolumeFile->ReadAccess = TRUE;
        Vcb->VirtualVolumeFile->WriteAccess = TRUE;
        Vcb->VirtualVolumeFile->DeleteAccess = TRUE;

        //
        //  Initialize the notify structures.
        //

        InitializeListHead( &Vcb->DirNotifyList );

        FsRtlNotifyInitializeSync( &Vcb->NotifySync );

        //
        //  Initialize the Cache Map for the volume file.  The size is
        //  initially set to that of our first read.  It will be extended
        //  when we know how big the Rx is.
        //

        FileSizes.AllocationSize.QuadPart =
        FileSizes.FileSize.QuadPart = sizeof(PACKED_BOOT_SECTOR);
        FileSizes.ValidDataLength = RxMaxLarge;

        CcInitializeCacheMap( Vcb->VirtualVolumeFile,
                              &FileSizes,
                              TRUE,
                              &RxData.CacheManagerNoOpCallbacks,
                              Vcb );
        UnwindCacheMap = Vcb->VirtualVolumeFile;

        //
        //  Initialize the structure that will keep track of dirty rx sectors.
        //  The largest possible Mcb structures are less than 1K, so we use
        //  non paged pool.
        //

        FsRtlInitializeMcb( &Vcb->DirtyRxMcb, PagedPool );

        UnwindWeAllocatedMcb = TRUE;

        //
        //  Set the cluster index hint to the first valid cluster of a rx: 2
        //

        Vcb->ClusterHint = 2;

        //
        //  Initialize the directory stream file object creation event.
        //  This event is also "borrowed" for async non-cached writes.
        //

        KeInitializeEvent( &Vcb->DirectoryFileCreationEvent,
                           SynchronizationEvent,
                           TRUE );

        //
        //  Initialize the clean volume callback Timer and DPC.
        //

        KeInitializeTimer( &Vcb->CleanVolumeTimer );

        KeInitializeDpc( &Vcb->CleanVolumeDpc, RxCleanVolumeDpc, Vcb );

    } finally {

        DebugUnwind( RxInitializeVcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            if (UnwindCacheMap != NULL) { RxSyncUninitializeCacheMap( RxContext, UnwindCacheMap ); }
            if (UnwindFileObject != NULL) { ObDereferenceObject( UnwindFileObject ); }
            if (UnwindVolFileResource != NULL) { RxDeleteResource( UnwindVolFileResource ); }
            if (UnwindResource != NULL) { RxDeleteResource( UnwindResource ); }
            if (UnwindWeAllocatedMcb) { FsRtlUninitializeMcb( &Vcb->DirtyRxMcb ); }
            if (UnwindEntryList != NULL) {
                (VOID)RxAcquireExclusiveGlobal( RxContext );
                RemoveEntryList( UnwindEntryList );
                RxReleaseGlobal( RxContext );
            }
        }

        DebugTrace(-1, Dbg, "RxInitializeVcb -> VOID\n", 0);
    }

    //
    //  and return to our caller
    //

    UNREFERENCED_PARAMETER( RxContext );

    return;
}


VOID
RxDeleteVcb_Real (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine removes the Vcb record from Rx's in-memory data
    structures.  It also will remove all associated underlings
    (i.e., FCB records).

Arguments:

    Vcb - Supplies the Vcb to be removed

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "RxDeleteVcb, Vcb = %08lx\n", Vcb);
    ASSERT(FALSE);

    //
    //  Uninitialize the cache
    //

    RxSyncUninitializeCacheMap( RxContext, Vcb->VirtualVolumeFile );

    //
    //  Dereference the virtual volume file.  This will cause a close
    //  Irp to be processed, so we need to do this before we destory
    //  the Vcb
    //

    RxSetFileObject( Vcb->VirtualVolumeFile, UnopenedFileObject, NULL, NULL );
    ObDereferenceObject( Vcb->VirtualVolumeFile );

    //
    //  Remove this record from the global list of all Vcb records
    //

    (VOID)RxAcquireExclusiveGlobal( RxContext );
    RemoveEntryList( &(Vcb->VcbLinks) );
    RxReleaseGlobal( RxContext );

    //
    //  Make sure the direct access open count is zero, and the open file count
    //  is also zero.
    //

    if ((Vcb->DirectAccessOpenCount != 0) || (Vcb->OpenFileCount != 0)) {

        RxBugCheck( 0, 0, 0 );
    }

    ASSERT( IsListEmpty( &Vcb->ParentDscbLinks ) );

    //
    //  Remove the EaFcb and dereference the Fcb for the Ea file if it
    //  exists.
    //

    if (Vcb->VirtualEaFile != NULL) {

        RxSetFileObject( Vcb->VirtualEaFile, UnopenedFileObject, NULL, NULL );
        RxSyncUninitializeCacheMap( RxContext, Vcb->VirtualEaFile );
        ObDereferenceObject( Vcb->VirtualEaFile );
    }

    if (Vcb->EaFcb != NULL) {

        Vcb->EaFcb->OpenCount = 0;
        RxDeleteFcb( RxContext, Vcb->EaFcb );

        Vcb->EaFcb = NULL;
    }

    //
    //  Remove the Root Dcb
    //

    if (Vcb->RootDcb != NULL) {

        PFILE_OBJECT DirectoryFileObject = Vcb->RootDcb->Specific.Dcb.DirectoryFile;

        if (DirectoryFileObject != NULL) {

            RxSyncUninitializeCacheMap( RxContext, DirectoryFileObject );

            //
            //  Dereference the directory file.  This will cause a close
            //  Irp to be processed, so we need to do this before we destory
            //  the Fcb
            //

            Vcb->RootDcb->Specific.Dcb.DirectoryFile = NULL;
            Vcb->RootDcb->Specific.Dcb.DirectoryFileOpenCount -= 1;
            RxSetFileObject( DirectoryFileObject, UnopenedFileObject, NULL, NULL );
            ObDereferenceObject( DirectoryFileObject );
        }

        RxDeleteFcb( RxContext, Vcb->RootDcb );
    }

    //
    //  Uninitialize the notify sychronization object.
    //

    FsRtlNotifyInitializeSync( &Vcb->NotifySync );

    //
    //  Uninitialize the resource variable for the Vcb
    //

    RxDeleteResource( &Vcb->Resource );

    //
    //  If allocation support has been setup, free it.
    //

    if (Vcb->FreeClusterBitMap.Buffer != NULL) {

        RxTearDownAllocationSupport( RxContext, Vcb );
    }

    //
    //  UnInitialize the Mcb structure that kept track of dirty rx sectors.
    //

    FsRtlUninitializeMcb( &Vcb->DirtyRxMcb );

    //
    //  Cancel the CleanVolume Timer and Dpc
    //

    (VOID)KeCancelTimer( &Vcb->CleanVolumeTimer );

    (VOID)KeRemoveQueueDpc( &Vcb->CleanVolumeDpc );

#ifdef WE_WON_ON_APPEAL
    //
    //  If there is a Dscb, dismount and delete it.
    //

    if (Vcb->Dscb) {

        RxDblsDismount( RxContext, &Vcb->Dscb );
    }
#endif // WE_WON_ON_APPEAL

    //
    //  And zero out the Vcb, this will help ensure that any stale data is
    //  wiped clean
    //

    RtlZeroMemory( Vcb, sizeof(VCB) );

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "RxDeleteVcb -> VOID\n", 0);

    return;
}


PDCB
RxCreateRootDcb (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new root DCB record
    into the in memory data structure.

Arguments:

    Vcb - Supplies the Vcb to associate the new DCB under

Return Value:

    PDCB - returns pointer to the newly allocated root DCB.

--*/

{
    PDCB Dcb;

    //
    //  The following variables are used for abnormal unwind
    //

    PVOID UnwindStorage[5] = { NULL, NULL, NULL, NULL, NULL };
    PERESOURCE UnwindResource = NULL;
    PMCB UnwindMcb = NULL;
    PFILE_OBJECT UnwindFileObject = NULL;

    DebugTrace(+1, Dbg, "RxCreateRootDcb, Vcb = %08lx\n", Vcb);
    ASSERT(FALSE);

    try {

        //
        //  Make sure we don't already have a root dcb for this vcb
        //

        if (Vcb->RootDcb != NULL) {

            DebugDump("Error trying to create multiple root dcbs\n", 0, Vcb);
            RxBugCheck( 0, 0, 0 );
        }

        //
        //  Allocate a new DCB and zero it out, we use Dcb locally so we don't
        //  have to continually reference through the Vcb
        //

        UnwindStorage[0] = Dcb = Vcb->RootDcb = FsRtlAllocatePool(NonPagedPool, sizeof(DCB));

        RtlZeroMemory( Dcb, sizeof(DCB));

        UnwindStorage[1] =
        Dcb->NonPaged = RxAllocateNonPagedFcb();

        RtlZeroMemory( Dcb->NonPaged, sizeof( NON_PAGED_FCB ) );

        //
        //  Set the proper node type code, node byte size, and call backs
        //

        Dcb->Header.NodeTypeCode = (NODE_TYPE_CODE)RDBSS_NTC_ROOT_DCB;
        Dcb->Header.NodeByteSize = sizeof(DCB);

        Dcb->FcbCondition = FcbGood;

        //
        //  The parent Dcb, initial state, open count, dirent location
        //  information, and directory change count fields are already zero so
        //  we can skip setting them
        //

// do this later since the space is now already allocated
//        //
//        //  Initialize the resource variable
//        //
//
//        UnwindStorage[2] =
//        Dcb->Header.Resource = RxAllocateResource();
//
//        UnwindResource = Dcb->Header.Resource;

        //
        //  Initialize the PagingIo Resource
        //

        Dcb->Header.PagingIoResource = FsRtlAllocateResource();

        //
        //  The root Dcb has an empty parent dcb links field
        //

        InitializeListHead( &Dcb->ParentDcbLinks );

        //
        //  Set the Vcb
        //

        Dcb->Vcb = Vcb;

        //
        //  Initialize the Mcb, and setup its mapping.  Note that the root
        //  directory is a fixed size so we can set it everything up now.
        //

        FsRtlInitializeMcb( &Dcb->Mcb, NonPagedPool );
        UnwindMcb = &Dcb->Mcb;

        FsRtlAddMcbEntry( &Dcb->Mcb,
                          0,
                          RxRootDirectoryLbo( &Vcb->Bpb ),
                          RxRootDirectorySize( &Vcb->Bpb ));

        //
        //  set the allocation size to real size of the root directory
        //

        Dcb->Header.FileSize.QuadPart =
        Dcb->Header.AllocationSize.QuadPart = RxRootDirectorySize( &Vcb->Bpb );

        //
        //  initialize the notify queues, and the parent dcb queue.
        //

        InitializeListHead( &Dcb->Specific.Dcb.ParentDcbQueue );

        //
        //  set the full file name.  We actually allocate pool here to spare
        //  a compare and jump.
        //

        Dcb->FullFileName.Buffer = L"\\";
        Dcb->FullFileName.Length = (USHORT)2;
        Dcb->FullFileName.MaximumLength = (USHORT)4;

        Dcb->ShortName.Name.Oem.Buffer = "\\";
        Dcb->ShortName.Name.Oem.Length = (USHORT)1;
        Dcb->ShortName.Name.Oem.MaximumLength = (USHORT)2;

        //
        //  Set our two create dirent aids to represent that we have yet to
        //  enumerate the directory for never used or deleted dirents.
        //

        Dcb->Specific.Dcb.UnusedDirentVbo = 0xffffffff;
        Dcb->Specific.Dcb.DeletedDirentHint = 0xffffffff;

        //
        //  Setup the free dirent bitmap buffer.
        //

        RtlInitializeBitMap( &Dcb->Specific.Dcb.FreeDirentBitmap,
                             NULL,
                             0 );

        RxCheckFreeDirentBitmap( RxContext, Dcb );

    } finally {

        DebugUnwind( RxCreateRootDcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            ULONG i;

            if (UnwindFileObject != NULL) { ObDereferenceObject( UnwindFileObject ); }
            if (UnwindMcb != NULL) { FsRtlUninitializeMcb( UnwindMcb ); }
            if (UnwindResource != NULL) { RxDeleteResource( UnwindResource ); }

            for (i = 0; i < 4; i += 1) {
                if (UnwindStorage[i] != NULL) { ExFreePool( UnwindStorage[i] ); }
            }
        } else {

            Dcb->Header.Resource = &Dcb->NonPaged->HeaderResource;
            ExInitializeResource(Dcb->Header.Resource);
        }

        DebugTrace(-1, Dbg, "RxCreateRootDcb -> %8lx\n", Dcb);
    }

    //
    //  return and tell the caller
    //

    return Dcb;
}


PFCB
RxCreateFcb (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN ULONG LfnOffsetWithinDirectory,
    IN ULONG DirentOffsetWithinDirectory,
    IN PDIRENT Dirent,
    IN PUNICODE_STRING Lfn OPTIONAL,
    IN BOOLEAN IsPagingFile
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Fcb record into
    the in memory data structures.

Arguments:

    Vcb - Supplies the Vcb to associate the new FCB under.

    ParentDcb - Supplies the parent dcb that the new FCB is under.

    LfnOffsetWithinDirectory - Supplies the offset of the LFN.  If there is
        no LFN associated with this file then this value is same as
        DirentOffsetWithinDirectory.

    DirentOffsetWithinDirectory - Supplies the offset, in bytes from the
        start of the directory file where the dirent for the fcb is located

    Dirent - Supplies the dirent for the fcb being created

    Lfn - Supplies a long UNICODE name associated with this file.

    IsPagingFile - Indicates if we are creating an FCB for a paging file
        or some other type of file.

Return Value:

    PFCB - Returns a pointer to the newly allocated FCB

--*/

{
    PFCB Fcb;
    POOL_TYPE PoolType;

    //
    //  The following variables are used for abnormal unwind
    //

    PVOID UnwindStorage[3] = { NULL, NULL, NULL };
    PERESOURCE UnwindResource = NULL;
    PLIST_ENTRY UnwindEntryList = NULL;
    PMCB UnwindMcb = NULL;
    PFILE_LOCK UnwindFileLock = NULL;
    POPLOCK UnwindOplock = NULL;

    DebugTrace(+1, Dbg, "RxCreateFcb\n", 0);
    ASSERT(FALSE);

    try {

        //
        //  Determine the pool type we should be using for the fcb and the
        //  mcb structure
        //

        if (IsPagingFile) {

            PoolType = NonPagedPool;
            Fcb = UnwindStorage[0] = FsRtlAllocatePool( NonPagedPool, sizeof(FCB) );

        } else {

            PoolType = PagedPool;
            Fcb = UnwindStorage[0] = RxAllocateFcb();
        }

        //
        //  Allocate a new FCB, and zero it out
        //

        RtlZeroMemory( Fcb, sizeof(FCB) );

        UnwindStorage[1] =
        Fcb->NonPaged = RxAllocateNonPagedFcb();

        RtlZeroMemory( Fcb->NonPaged, sizeof( NON_PAGED_FCB ) );

        //
        //  Set the proper node type code, node byte size, and call backs
        //

        Fcb->Header.NodeTypeCode = (NODE_TYPE_CODE)RDBSS_NTC_FCB;
        Fcb->Header.NodeByteSize = sizeof(FCB);

        Fcb->FcbCondition = FcbGood;

        //
        //  Check to see if we need to set the Fcb state to indicate that this
        //  is a paging file
        //

        if (IsPagingFile) {

            Fcb->FcbState |= FCB_STATE_PAGING_FILE;
        }

        //
        //  The initial state, open count, and segment objects fields are already
        //  zero so we can skip setting them
        //

// space has already been allocatd in nonpaged part don't do this
//        //
//        //  Initialize the resource variable
//        //
//
//        UnwindStorage[2] =
//        Fcb->Header.Resource = RxAllocateResource();
//
//        UnwindResource = Fcb->Header.Resource;

        //
        //  Initialize the PagingIo Resource
        //

        Fcb->Header.PagingIoResource = FsRtlAllocateResource();

        //
        //  Insert this fcb into our parent dcb's queue
        //

        InsertTailList( &ParentDcb->Specific.Dcb.ParentDcbQueue,
                        &Fcb->ParentDcbLinks );
        UnwindEntryList = &Fcb->ParentDcbLinks;

        //
        //  Point back to our parent dcb
        //

        Fcb->ParentDcb = ParentDcb;

        //
        //  Set the Vcb
        //

        Fcb->Vcb = Vcb;

        //
        //  Set the dirent offset within the directory
        //

        Fcb->LfnOffsetWithinDirectory = LfnOffsetWithinDirectory;
        Fcb->DirentOffsetWithinDirectory = DirentOffsetWithinDirectory;

        //
        //  Set the DirentRxFlags and LastWriteTime
        //

        Fcb->DirentRxFlags = Dirent->Attributes;

        Fcb->LastWriteTime = RxRxTimeToNtTime( RxContext,
                                                 Dirent->LastWriteTime,
                                                 0 );

        //
        //  These fields are only non-zero when in Chicago mode.
        //

        if (RxData.ChicagoMode) {

            LARGE_INTEGER RxSystemJanOne1980;

            //
            //  If either date is possibly zero, get the system
            //  version of 1/1/80.
            //

            if ((((PUSHORT)Dirent)[9] & ((PUSHORT)Dirent)[8]) == 0) {

                ExLocalTimeToSystemTime( &RxJanOne1980,
                                         &RxSystemJanOne1980 );
            }

            //
            //  Only do the really hard work if this field is non-zero.
            //

            if (((PUSHORT)Dirent)[9] != 0) {

                Fcb->LastAccessTime =
                    RxRxDateToNtTime( RxContext,
                                        Dirent->LastAccessDate );

            } else {

                Fcb->LastAccessTime = RxSystemJanOne1980;
            }

            //
            //  Only do the really hard work if this field is non-zero.
            //

            if (((PUSHORT)Dirent)[8] != 0) {

                Fcb->CreationTime =
                    RxRxTimeToNtTime( RxContext,
                                        Dirent->CreationTime,
                                        Dirent->CreationMSec );

            } else {

                Fcb->CreationTime = RxSystemJanOne1980;
            }
        }

        //
        //  Initialize the Mcb
        //

        FsRtlInitializeMcb( &Fcb->Mcb, PoolType );
        UnwindMcb = &Fcb->Mcb;

        //
        //  Set the file size, valid data length, first cluster of file,
        //  and allocation size based on the information stored in the dirent
        //

        Fcb->Header.FileSize.LowPart = Dirent->FileSize;

        Fcb->Header.ValidDataLength.LowPart = Dirent->FileSize;

        Fcb->FirstClusterOfFile = (ULONG)Dirent->FirstClusterOfFile;

        if ( Fcb->FirstClusterOfFile == 0 ) {

            Fcb->Header.AllocationSize = RxLargeZero;

        } else {

            Fcb->Header.AllocationSize.QuadPart = -1;
        }

        //
        //  Initialize the Fcb's file lock record
        //

        FsRtlInitializeFileLock( &Fcb->Specific.Fcb.FileLock, NULL, NULL );
        UnwindFileLock = &Fcb->Specific.Fcb.FileLock;

        //
        //  Initialize the oplock structure.
        //

        FsRtlInitializeOplock( &Fcb->Specific.Fcb.Oplock );
        UnwindOplock = &Fcb->Specific.Fcb.Oplock;

        //
        //  Indicate that Fast I/O is possible
        //

        Fcb->Header.IsFastIoPossible = TRUE;

        //
        //  Set the file names.  This must be the last thing we do.
        //

        RxConstructNamesInFcb( RxContext,
                                Fcb,
                                Dirent,
                                Lfn );

    } finally {

        DebugUnwind( RxCreateFcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            ULONG i;

            if (UnwindOplock != NULL) { FsRtlUninitializeOplock( UnwindOplock ); }
            if (UnwindFileLock != NULL) { FsRtlUninitializeFileLock( UnwindFileLock ); }
            if (UnwindMcb != NULL) { FsRtlUninitializeMcb( UnwindMcb ); }
            if (UnwindEntryList != NULL) { RemoveEntryList( UnwindEntryList ); }
            if (UnwindResource != NULL) { RxDeleteResource( UnwindResource ); }

            for (i = 0; i < 3; i += 1) {
                if (UnwindStorage[i] != NULL) { ExFreePool( UnwindStorage[i] ); }
            }
        } else {

            Fcb->Header.Resource = &Fcb->NonPaged->HeaderResource;
            ExInitializeResource(Fcb->Header.Resource);
        }

        DebugTrace(-1, Dbg, "RxCreateFcb -> %08lx\n", Fcb);
    }

    //
    //  return and tell the caller
    //

    return Fcb;
}


PDCB
RxCreateDcb (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN ULONG LfnOffsetWithinDirectory,
    IN ULONG DirentOffsetWithinDirectory,
    IN PDIRENT Dirent,
    IN PUNICODE_STRING Lfn OPTIONAL
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Dcb record into
    the in memory data structures.

Arguments:

    Vcb - Supplies the Vcb to associate the new DCB under.

    ParentDcb - Supplies the parent dcb that the new DCB is under.

    LfnOffsetWithinDirectory - Supplies the offset of the LFN.  If there is
        no LFN associated with this file then this value is same as
        DirentOffsetWithinDirectory.

    DirentOffsetWithinDirectory - Supplies the offset, in bytes from the
        start of the directory file where the dirent for the fcb is located

    Dirent - Supplies the dirent for the dcb being created

    FileName - Supplies the file name of the file relative to the directory
        it's in (e.g., the file \config.sys is called "CONFIG.SYS" without
        the preceding backslash).

    Lfn - Supplies a long UNICODE name associated with this directory.

Return Value:

    PDCB - Returns a pointer to the newly allocated DCB

--*/

{
    PDCB Dcb;

    //
    //  The following variables are used for abnormal unwind
    //

    PVOID UnwindStorage[4] = { NULL, NULL, NULL, NULL };
    PERESOURCE UnwindResource = NULL;
    PLIST_ENTRY UnwindEntryList = NULL;
    PMCB UnwindMcb = NULL;

    DebugTrace(+1, Dbg, "RxCreateDcb\n", 0);
    ASSERT(FALSE);

    try {

        //
        //  assert that the only time we are called is if wait is true
        //

        ASSERT( FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT) );

        //
        //  Allocate a new DCB, and zero it out
        //

        UnwindStorage[0] = Dcb = RxAllocateFcb();

        RtlZeroMemory( Dcb, sizeof(DCB) );

        UnwindStorage[1] =
        Dcb->NonPaged = RxAllocateNonPagedFcb();

        RtlZeroMemory( Dcb->NonPaged, sizeof( NON_PAGED_FCB ) );

        //
        //  Set the proper node type code, node byte size and call backs
        //

        Dcb->Header.NodeTypeCode = (NODE_TYPE_CODE)RDBSS_NTC_DCB;
        Dcb->Header.NodeByteSize = sizeof(DCB);

        Dcb->FcbCondition = FcbGood;

        //
        //  The initial state, open count, and directory change count fields are
        //  already zero so we can skip setting them
        //

//space allready allocated in nonpaged part
//        //
//        //  Initialize the resource variable
//        //
//
//        UnwindStorage[2] =
//        Dcb->Header.Resource = RxAllocateResource();

        UnwindResource = Dcb->Header.Resource;

        //
        //  Initialize the PagingIo Resource
        //

        Dcb->Header.PagingIoResource = FsRtlAllocateResource();

        //
        //  Insert this Dcb into our parent dcb's queue
        //

        InsertTailList( &ParentDcb->Specific.Dcb.ParentDcbQueue,
                        &Dcb->ParentDcbLinks );
        UnwindEntryList = &Dcb->ParentDcbLinks;

        //
        //  Point back to our parent dcb
        //

        Dcb->ParentDcb = ParentDcb;

        //
        //  Set the Vcb
        //

        Dcb->Vcb = Vcb;

        //
        //  Set the dirent offset within the directory
        //

        Dcb->LfnOffsetWithinDirectory = LfnOffsetWithinDirectory;
        Dcb->DirentOffsetWithinDirectory = DirentOffsetWithinDirectory;

        //
        //  Set the DirentRxFlags and LastWriteTime
        //

        Dcb->DirentRxFlags = Dirent->Attributes;

        Dcb->LastWriteTime = RxRxTimeToNtTime( RxContext,
                                                 Dirent->LastWriteTime,
                                                 0 );

        //
        //  These fields are only non-zero when in Chicago mode.
        //

        if (RxData.ChicagoMode) {

            LARGE_INTEGER RxSystemJanOne1980;

            //
            //  If either date is possibly zero, get the system
            //  version of 1/1/80.
            //

            if ((((PUSHORT)Dirent)[9] & ((PUSHORT)Dirent)[8]) == 0) {

                ExLocalTimeToSystemTime( &RxJanOne1980,
                                         &RxSystemJanOne1980 );
            }

            //
            //  Only do the really hard work if this field is non-zero.
            //

            if (((PUSHORT)Dirent)[9] != 0) {

                Dcb->LastAccessTime =
                    RxRxDateToNtTime( RxContext,
                                        Dirent->LastAccessDate );

            } else {

                Dcb->LastAccessTime = RxSystemJanOne1980;
            }

            //
            //  Only do the really hard work if this field is non-zero.
            //

            if (((PUSHORT)Dirent)[8] != 0) {

                Dcb->CreationTime =
                    RxRxTimeToNtTime( RxContext,
                                        Dirent->CreationTime,
                                        Dirent->CreationMSec );

            } else {

                Dcb->CreationTime = RxSystemJanOne1980;
            }
        }

        //
        //  Initialize the Mcb
        //

        FsRtlInitializeMcb( &Dcb->Mcb, PagedPool );
        UnwindMcb = &Dcb->Mcb;

        //
        //  Set the file size, first cluster of file, and allocation size
        //  based on the information stored in the dirent
        //

        Dcb->FirstClusterOfFile = (ULONG)Dirent->FirstClusterOfFile;

        if ( Dcb->FirstClusterOfFile == 0 ) {

            Dcb->Header.AllocationSize.QuadPart = 0;

        } else {

            Dcb->Header.AllocationSize.QuadPart = -1;
        }

        //  initialize the notify queues, and the parent dcb queue.
        //

        InitializeListHead( &Dcb->Specific.Dcb.ParentDcbQueue );

        //
        //  Setup the free dirent bitmap buffer.  Since we don't know the
        //  size of the directory, leave it zero for now.
        //

        RtlInitializeBitMap( &Dcb->Specific.Dcb.FreeDirentBitmap,
                             NULL,
                             0 );

        //
        //  Set our two create dirent aids to represent that we have yet to
        //  enumerate the directory for never used or deleted dirents.
        //

        Dcb->Specific.Dcb.UnusedDirentVbo = 0xffffffff;
        Dcb->Specific.Dcb.DeletedDirentHint = 0xffffffff;

        //
        //  Postpone initializing the cache map until we need to do a read/write
        //  of the directory file.


        //
        //  set the file names.  This must be the last thing we do.
        //

        RxConstructNamesInFcb( RxContext,
                                Dcb,
                                Dirent,
                                Lfn );

    } finally {

        DebugUnwind( RxCreateDcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            ULONG i;

            if (UnwindMcb != NULL) { FsRtlUninitializeMcb( UnwindMcb ); }
            if (UnwindEntryList != NULL) { RemoveEntryList( UnwindEntryList ); }
            if (UnwindResource != NULL) { RxDeleteResource( UnwindResource ); }

            for (i = 0; i < 4; i += 1) {
                if (UnwindStorage[i] != NULL) { ExFreePool( UnwindStorage[i] ); }
            }
        } else {

            Dcb->Header.Resource = &Dcb->NonPaged->HeaderResource;
            ExInitializeResource(Dcb->Header.Resource);
        }


        DebugTrace(-1, Dbg, "RxCreateDcb -> %08lx\n", Dcb);
    }

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "RxCreateDcb -> %08lx\n", Dcb);

    return Dcb;
}


VOID
RxDeleteFcb_Real (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine deallocates and removes an FCB, DCB, or ROOT DCB record
    from Rx's in-memory data structures.  It also will remove all
    associated underlings (i.e., Notify irps, and child FCB/DCB records).

Arguments:

    Fcb - Supplies the FCB/DCB/ROOT DCB to be removed

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "RxDeleteFcb, Fcb = %08lx\n", Fcb);
    ASSERT(FALSE);

    //
    //  We can only delete this record if the open count is zero.
    //

    if (Fcb->OpenCount != 0) {

        DebugDump("Error deleting Fcb, Still Open\n", 0, Fcb);
        RxBugCheck( 0, 0, 0 );
    }

    //
    //  If this is a DCB then remove every Notify record from the two
    //  notify queues
    //

    if ((Fcb->Header.NodeTypeCode == RDBSS_NTC_DCB) ||
        (Fcb->Header.NodeTypeCode == RDBSS_NTC_ROOT_DCB)) {

        //
        //  If we allocated a free dirent bitmap buffer, free it.
        //

        if ((Fcb->Specific.Dcb.FreeDirentBitmap.Buffer != NULL) &&
            (Fcb->Specific.Dcb.FreeDirentBitmap.Buffer !=
             &Fcb->Specific.Dcb.FreeDirentBitmapBuffer[0])) {

            ExFreePool(Fcb->Specific.Dcb.FreeDirentBitmap.Buffer);
        }

        ASSERT( Fcb->Specific.Dcb.DirectoryFileOpenCount == 0 );
        ASSERT( IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue) );

    } else {

        //
        //  Uninitialize the byte range file locks and opportunistic locks
        //

        FsRtlUninitializeFileLock( &Fcb->Specific.Fcb.FileLock );
        FsRtlUninitializeOplock( &Fcb->Specific.Fcb.Oplock );
    }

    //
    //  Uninitialize the Mcb
    //

    FsRtlUninitializeMcb( &Fcb->Mcb );

    //
    //  If this is not the root dcb then we need to remove ourselves from
    //  our parents Dcb queue
    //

    if (Fcb->Header.NodeTypeCode != RDBSS_NTC_ROOT_DCB) {

        RemoveEntryList( &(Fcb->ParentDcbLinks) );
    }

    //
    //  Remove the entry from the splay table if there is still is one.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE )) {

        RxRemoveNames( RxContext, Fcb );
    }

    //
    //  Free the file name pool if allocated.
    //

    if (Fcb->Header.NodeTypeCode != RDBSS_NTC_ROOT_DCB) {

        ExFreePool( Fcb->ShortName.Name.Oem.Buffer );

        if (Fcb->FullFileName.Buffer) {

            ExFreePool( Fcb->FullFileName.Buffer );
        }
    }

    //
    //  Free up the resource variable.  If we are below RxForceCacheMiss(),
    //  release the resource here.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_FORCE_MISS_IN_PROGRESS) ) {

//        RxReleaseFcb( RxContext, Fcb );
//        DavidGoe 5/26/94 - No reason to release the resource here.
    }

    //
    //  Finally deallocate the Fcb and non-paged fcb records
    //

    //joejoe i put these tests here so that i could use these routines with some fields NULL
    if ( Fcb->Header.Resource != NULL )ExDeleteResource( Fcb->Header.Resource );
    if ( Fcb->NonPaged != NULL )       RxFreeNonPagedFcb( Fcb->NonPaged );
    RxFreeFcb( Fcb );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "RxDeleteFcb -> VOID\n", 0);

    return;
}

PFOBX
RxCreateFobx (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine creates a new FOBX record

Arguments:

Return Value:

    FOBX - returns a pointer to the newly allocate FOBX

--*/

{
    PFOBX Fobx;

    DebugTrace(+1, Dbg, "RxCreateFobx\n", 0);
    ASSERT(FALSE);

    //
    //  Allocate a new FOBX Record
    //

    Fobx = RxAllocateFobx();

    RtlZeroMemory( Fobx, sizeof(FOBX) );

    //
    //  Set the proper node type code and node byte size
    //

    Fobx->NodeTypeCode = RDBSS_NTC_FOBX;
    Fobx->NodeByteSize = sizeof(FOBX);

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "RxCreateFobx -> %08lx\n", Fobx);

    UNREFERENCED_PARAMETER( RxContext );

    return Fobx;
}


VOID
RxDeleteFobx_Real (
    IN PRX_CONTEXT RxContext,
    IN PFOBX Fobx
    )

/*++

Routine Description:

    This routine deallocates and removes the specified FOBX record
    from the Rx in memory data structures

Arguments:

    Fobx - Supplies the FOBX to remove

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "RxDeleteFobx, Fobx = %08lx\n", Fobx);
    ASSERT(FALSE);

    //
    //  If we allocated query template buffers, deallocate them now.
    //

    if (FlagOn(Fobx->Flags, FOBX_FLAG_FREE_UNICODE)) {

        ASSERT( Fobx->UnicodeQueryTemplate.Buffer );
        RtlFreeUnicodeString( &Fobx->UnicodeQueryTemplate );
    }

//    if (FlagOn(Fobx->Flags, FOBX_FLAG_FREE_OEM_BEST_FIT)) {
//
//        ASSERT( Fobx->OemQueryTemplate.Wild.Buffer );
//        RtlFreeOemString( &Fobx->OemQueryTemplate.Wild );
//    }

    //
    //  Deallocate the Fobx record
    //

    RxFreeFobx( Fobx );

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "RxDeleteFobx -> VOID\n", 0);

    UNREFERENCED_PARAMETER( RxContext );

    return;
}


PFCB
RxGetNextFcb (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN PFCB TerminationFcb
    )

/*++

Routine Description:

    This routine is used to itterate through Fcbs in a tree.

    The rule is very simple:

        A) If you have a child, go to it, else
        B) If you have an older sibling, go to it, else
        C) Go to your parent's older sibling.

    If this routine is called with in invalid TerminationFcb it will fail,
    badly.

Arguments:

    Fcb - Supplies the current Fcb

    TerminationFcb - The Fcb at which the enumeration should (non-inclusivly)
        stop.  Assumed to be a directory.

Return Value:

    The next Fcb in the enumeration, or NULL if Fcb was the final one.

--*/

{
    PFCB Sibling;

    ASSERT(FALSE);
    ASSERT( RxVcbAcquiredExclusive( RxContext, Fcb->Vcb ) ||
            FlagOn( Fcb->Vcb->VcbState, VCB_STATE_FLAG_LOCKED ) );

    //
    //  If this was a directory (ie. not a file), get the child.  If
    //  there aren't any children and this is our termination Fcb,
    //  return NULL.
    //

    if ( ((NodeType(Fcb) == RDBSS_NTC_DCB) ||
          (NodeType(Fcb) == RDBSS_NTC_ROOT_DCB)) &&
         !IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue) ) {

        return RxGetFirstChild( Fcb );
    }

    //
    //  Were we only meant to do one itteration?
    //

    if ( Fcb == TerminationFcb ) {

        return NULL;
    }

    Sibling = RxGetNextSibling(Fcb);

    while (TRUE) {

        //
        //  Do we still have an "older" sibling in this directory who is
        //  not the termination Fcb?
        //

        if ( Sibling != NULL ) {

            return (Sibling != TerminationFcb) ? Sibling : NULL;
        }

        //
        //  OK, let's move on to out parent and see if he is the termination
        //  node or has any older siblings.
        //

        if ( Fcb->ParentDcb == TerminationFcb ) {

            return NULL;
        }

        Fcb = Fcb->ParentDcb;

        Sibling = RxGetNextSibling(Fcb);
    }
}


BOOLEAN
RxCheckForDismount (
    IN PRX_CONTEXT RxContext,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine determines if a volume is ready for deletion.  It
    correctly synchronizes with creates en-route to the file system.

Arguments:

    Vcb - Supplies the volue to examine

Return Value:

    BOOLEAN - TRUE if the volume was deleted, FALSE otherwise.

--*/

{
    KIRQL SavedIrql;
    ULONG ResidualReferenceCount;

    //
    //  Compute if the volume is OK to tear down.  There should only be two
    //  residual file objects, one for the volume file and one for the root
    //  directory.  If we are in the midst of a create (of an unmounted
    //  volume that has failed verify) then there will be an additional
    //  reference.
    //

    if ((RxContext->MajorFunction == IRP_MJ_CREATE) &&
        (RxContext->RealDevice == Vcb->CurrentDevice)) {

        ResidualReferenceCount = 3;

    } else {

        ResidualReferenceCount = 2;
    }

    //
    //  Now check for a zero Vpb count on an unmounted volume.  These
    //  volumes will be deleted as they now have no file objects and
    //  there are no creates en route to this volume.
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    if (Vcb->Vpb->ReferenceCount == ResidualReferenceCount) {

        PVPB Vpb = Vcb->Vpb;

#if DBG
        UNICODE_STRING VolumeLabel;

        //
        //  Setup the VolumeLabel string
        //

        VolumeLabel.Length = Vcb->Vpb->VolumeLabelLength;
        VolumeLabel.MaximumLength = MAXIMUM_VOLUME_LABEL_LENGTH;
        VolumeLabel.Buffer = &Vcb->Vpb->VolumeLabel[0];

        KdPrint(("FASTRDBSS: Dismounting Volume %wZ\n", &VolumeLabel));
#endif // DBG

        //
        //  Clear the VPB_MOUNTED bit so that new creates will not come
        //  to this volume.  We must leave the Vpb->DeviceObject field
        //  set until after the DeleteVcb call as two closes will
        //  have to make their back to us.
        //
        //  Note also that if we were called from close, it will take care
        //  of freeing the Vpb if it is not the primary one, otherwise
        //  if we were called from Create->Verify, IopParseDevice will
        //  take care of freeing the Vpb in its Reparse path.
        //

        ClearFlag( Vpb->Flags, VPB_MOUNTED );

        //
        //  If this Vpb was locked, clear this flag now.
        //

        ClearFlag( Vpb->Flags, VPB_LOCKED );

        //
        //  This will prevent anybody else from attempting to mount this
        //  volume.  Also if this volume was mounted on a "wanna-be" real
        //  device object, keep anybody from following the link, and the Io
        //  system from deleting the Vpb.
        //

        if ((Vcb->CurrentDevice != Vpb->RealDevice) &&
            (Vcb->CurrentDevice->Vpb == Vpb)) {

            SetFlag( Vcb->CurrentDevice->Flags, DO_DEVICE_INITIALIZING );
            SetFlag( Vpb->Flags, VPB_PERSISTENT );
        }

        IoReleaseVpbSpinLock( SavedIrql );

        RxDeleteVcb( RxContext, Vcb );

        Vpb->DeviceObject = NULL;

        IoDeleteDevice( (PDEVICE_OBJECT)
                        CONTAINING_RECORD( Vcb,
                                           RDBSS_DEVICE_OBJECT,
                                           Vcb ) );

        return TRUE;

    } else {

        IoReleaseVpbSpinLock( SavedIrql );

        return FALSE;
    }
}


VOID
RxConstructNamesInFcb (
    IN PRX_CONTEXT RxContext,
    PFCB Fcb,
    PDIRENT Dirent,
    PUNICODE_STRING Lfn OPTIONAL
    )

/*++

Routine Description:

    This routine places the short name in the dirent in the first set of
    STRINGs in the Fcb.  If a long file name (Lfn) was specified, then
    we must decide whether we will store its Oem equivolent in the same
    prefix table as the short name, or rather just save the upcased
    version of the UNICODE string in the FCB.

    For looking up Fcbs, the first approach will be faster, so we want to
    do this as much as possible.  Here are the rules that I have thought
    through extensively to determine when it is safe to store only Oem
    version of the UNICODE name.

    - If the UNICODE name contains no extended characters (>0x80), use Oem.

    - Let U be the upcased version of the UNICODE name.
      Let Up(x) be the function that upcases a UNICODE string.
      Let Down(x) be the function that upcases a UNICODE string.
      Let OemToUni(x) be the function that converts an Oem string to Unicode.
      Let UniToOem(x) be the function that converts a Unicode string to Oem.
      Let BestOemFit(x) be the function that creates the Best uppercase Oem
        fit for the UNICODE string x.

      BestOemFit(x) = UniToOem(Up(OemToUni(UniToOem(x))))   <1>

      if (BestOemFit(U) == BestOemFit(Down(U))              <2>

          then I know that there exists no UNICODE string Y such that:

              Up(Y) == Up(U)                                <3>

              AND

              BestOemFit(U) != BestOemFit(Y)                <4>

      Consider string U as a collection of one character strings.  The
      conjecture is clearly true for each sub-string, thus it is true
      for the entire string.

      Equation <1> is what we use to convert an incoming unicode name in
      RxCommonCreate() to Oem.  The double conversion is done to provide
      better visual best fitting for characters in the Ansi code page but
      not in the Oem code page.  A single Nls routine is provided to do
      this conversion efficiently.

      The idea is that with U, I only have to worry about a case varient Y
      matching it in a unicode compare, and I have shown that any case varient
      of U (the set Y defined in equation <3>), when filtered through <1>
      (as in create), will match the Oem string defined in <1>.

      Thus I do not have to worry about another UNICODE string missing in
      the prefix lookup, but matching when comparing LFNs in the directory.

Arguments:

    Fcb - The Fcb we are supposed to fill in.  Note that ParentDcb must
        already be filled in.

    Dirent - The gives up the short name.

    Lfn - If provided, this gives us the long name.

Return Value:

    None

--*/

{
    RXSTATUS Status;
    ULONG i;

    OEM_STRING OemA;
    OEM_STRING OemB;
    POEM_STRING ShortName;
    POEM_STRING LongOemName;
    PUNICODE_STRING LongUniName;

    ShortName = &Fcb->ShortName.Name.Oem;

    try {

        //
        //  First do the short name.
        //

        ShortName->MaximumLength = 16;
        ShortName->Buffer = FsRtlAllocatePool( PagedPool, 16);

        Rx8dot3ToString( RxContext, Dirent, FALSE, ShortName );

        //
        //  If no Lfn was specified, we are done.  In either case, set the
        //  final name length.
        //

        if (!ARGUMENT_PRESENT(Lfn) || (Lfn->Length == 0)) {

            Fcb->FinalNameLength = (USHORT)
                RtlOemStringToCountedUnicodeSize( ShortName );

            try_return( NOTHING );

        } else {

            Fcb->FinalNameLength = Lfn->Length;
        }

        //
        //  First check for no extended characters.
        //

        for (i=0; i < Lfn->Length/sizeof(WCHAR); i++) {

            if (Lfn->Buffer[i] >= 0x80) {

                break;
            }
        }

        if (i == Lfn->Length/sizeof(WCHAR)) {

            //
            //  Cool, I can go with the Oem, upcase it fast by hand.
            //

            LongOemName = &Fcb->LongName.Oem.Name.Oem;


            LongOemName->Buffer = FsRtlAllocatePool( PagedPool,
                                                     Lfn->Length/sizeof(WCHAR) );
            LongOemName->Length =
            LongOemName->MaximumLength = Lfn->Length/sizeof(WCHAR);

            for (i=0; i < Lfn->Length/sizeof(WCHAR); i++) {

                WCHAR c;

                c = Lfn->Buffer[i];

                LongOemName->Buffer[i] = c < 'a' ?
                                         (UCHAR)c :
                                         c <= 'z' ?
                                         c - (UCHAR)('a'-'A') :
                                         (UCHAR) c;
            }

            //
            //  If this name happens to be exactly the same as the short
            //  name, don't add it to the splay table.
            //

            if (RxAreNamesEqual(RxContext, *ShortName, *LongOemName) ||
                (RxFindFcb( RxContext,
                             &Fcb->ParentDcb->Specific.Dcb.RootOemNode,
                             LongOemName) != NULL)) {

                ExFreePool( LongOemName->Buffer );

                LongOemName->Buffer = NULL;
                LongOemName->Length =
                LongOemName->MaximumLength = 0;

            } else {

                SetFlag( Fcb->FcbState, FCB_STATE_HAS_OEM_LONG_NAME );
            }

            try_return( NOTHING );
        }

        //
        //  Now we have the fun part.
        //  I am free to play with the Lfn since nobody above me needs it anymore.
        //

        (VOID)RtlDowncaseUnicodeString( Lfn, Lfn, FALSE );

        Status = RtlUpcaseUnicodeStringToCountedOemString( &OemA, Lfn, TRUE );

        if (!NT_SUCCESS(Status)) {

            RxNormalizeAndRaiseStatus( RxContext, Status );
        }

        (VOID)RtlUpcaseUnicodeString( Lfn, Lfn, FALSE );

        Status = RtlUpcaseUnicodeStringToCountedOemString( &OemB, Lfn, TRUE );

        if (!NT_SUCCESS(Status)) {

            RtlFreeOemString( &OemA );
            RxNormalizeAndRaiseStatus( RxContext, Status );
        }

        if (RxAreNamesEqual( RxContext, OemA, OemB )) {

            //
            //  Cool, I can go with the Oem
            //

            Fcb->LongName.Oem.Name.Oem = OemA;

            RtlFreeOemString( &OemB );

            //
            //  If this name happens to be exactly the same as the short
            //  name, or a similar short name already exists don't add it
            //  to the splay table (note the final condition implies a
            //  currupt disk.
            //

            if (RxAreNamesEqual(RxContext, *ShortName, OemA) ||
                (RxFindFcb( RxContext,
                             &Fcb->ParentDcb->Specific.Dcb.RootOemNode,
                             &OemA) != NULL)) {

                RtlFreeOemString( &OemA );

            } else {

                SetFlag( Fcb->FcbState, FCB_STATE_HAS_OEM_LONG_NAME );
            }

            try_return( NOTHING );
        }

        //
        //  The long name must be left in UNICODE.
        //

        LongUniName = &Fcb->LongName.Unicode.Name.Unicode;

        LongUniName->Length =
        LongUniName->MaximumLength = Lfn->Length;
        LongUniName->Buffer = FsRtlAllocatePool( PagedPool, Lfn->Length );

        RtlCopyMemory( LongUniName->Buffer, Lfn->Buffer, Lfn->Length );

        SetFlag(Fcb->FcbState, FCB_STATE_HAS_UNICODE_LONG_NAME);

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            if (ShortName->Buffer != NULL) {

                ExFreePool( ShortName->Buffer );
            }

        } else {

            //
            //  Creating all the names worked, so add all the names
            //  to the splay tree.
            //

            RxInsertName( RxContext,
                           &Fcb->ParentDcb->Specific.Dcb.RootOemNode,
                           &Fcb->ShortName );

            Fcb->ShortName.Fcb = Fcb;

            if (FlagOn(Fcb->FcbState, FCB_STATE_HAS_OEM_LONG_NAME)) {

                RxInsertName( RxContext,
                               &Fcb->ParentDcb->Specific.Dcb.RootOemNode,
                               &Fcb->LongName.Oem );

                Fcb->LongName.Oem.Fcb = Fcb;
            }

            if (FlagOn(Fcb->FcbState, FCB_STATE_HAS_UNICODE_LONG_NAME)) {

                RxInsertName( RxContext,
                               &Fcb->ParentDcb->Specific.Dcb.RootUnicodeNode,
                               &Fcb->LongName.Unicode );

                Fcb->LongName.Unicode.Fcb = Fcb;
            }

            SetFlag(Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE)
        }
    }

    return;
}


VOID
RxCheckFreeDirentBitmap (
    IN PRX_CONTEXT RxContext,
    IN PDCB Dcb
    )

/*++

Routine Description:

    This routine checks if the size of the free dirent bitmap is
    sufficient to for the current directory size.  It is called
    whenever we grow a directory.

Arguments:

    Dcb -  Supplies the directory in question.

Return Value:

    None

--*/

{
    ULONG OldNumberOfDirents;
    ULONG NewNumberOfDirents;

    //
    //  Setup the Bitmap buffer if it is not big enough already
    //

    OldNumberOfDirents = Dcb->Specific.Dcb.FreeDirentBitmap.SizeOfBitMap;
    NewNumberOfDirents = Dcb->Header.AllocationSize.LowPart / sizeof(DIRENT);

    ASSERT( Dcb->Header.AllocationSize.LowPart != 0xffffffff );

    if (NewNumberOfDirents > OldNumberOfDirents) {

        PULONG OldBitmapBuffer;
        PULONG BitmapBuffer;

        ULONG BytesInBitmapBuffer;
        ULONG BytesInOldBitmapBuffer;

        //
        //  Remember the old bitmap
        //

        OldBitmapBuffer = Dcb->Specific.Dcb.FreeDirentBitmap.Buffer;

        //
        //  Now make a new bitmap bufffer
        //

        BytesInBitmapBuffer = NewNumberOfDirents / 8;

        BytesInOldBitmapBuffer = OldNumberOfDirents / 8;

        if (DCB_UNION_SLACK_SPACE >= BytesInBitmapBuffer) {

            BitmapBuffer = &Dcb->Specific.Dcb.FreeDirentBitmapBuffer[0];

        } else {

            BitmapBuffer = FsRtlAllocatePool( PagedPool,
                                              BytesInBitmapBuffer );
        }

        //
        //  Copy the old buffer to the new buffer, free the old one, and zero
        //  the rest of the new one.  Only do the first two steps though if
        //  we moved out of the initial buffer.
        //

        if ((OldNumberOfDirents != 0) &&
            (BitmapBuffer != &Dcb->Specific.Dcb.FreeDirentBitmapBuffer[0])) {

            RtlCopyMemory( BitmapBuffer,
                           OldBitmapBuffer,
                           BytesInOldBitmapBuffer );

            if (OldBitmapBuffer != &Dcb->Specific.Dcb.FreeDirentBitmapBuffer[0]) {

                ExFreePool( OldBitmapBuffer );
            }
        }

        ASSERT( BytesInBitmapBuffer > BytesInOldBitmapBuffer );

        RtlZeroMemory( (PUCHAR)BitmapBuffer + BytesInOldBitmapBuffer,
                       BytesInBitmapBuffer - BytesInOldBitmapBuffer );

        //
        //  Now initialize the new bitmap.
        //

        RtlInitializeBitMap( &Dcb->Specific.Dcb.FreeDirentBitmap,
                             BitmapBuffer,
                             NewNumberOfDirents );
    }
}


BOOLEAN
RxIsHandleCountZero (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine decides if the handle count on the volume is zero.

Arguments:

    Vcb - The volume in question

Return Value:

    BOOLEAN - TRUE if there are no open handles on the volume, FALSE
              otherwise.

--*/

{
    PFCB Fcb;

    ASSERT(FALSE);
    Fcb = Vcb->RootDcb;

    while (Fcb != NULL) {

        if (Fcb->UncleanCount != 0) {

            return FALSE;
        }

        Fcb = RxGetNextFcb(RxContext, Fcb, Vcb->RootDcb);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\obsolete\verfysup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    VerfySup.c

Abstract:

    This module implements the Rx Verify volume and fcb/dcb support
    routines

Author:

    Gary Kimura     [GaryKi]    01-Jun-1990

Revision History:

--*/

//    ----------------------joejoe-----------found-------------#include "RxProcs.h"
#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_VERFYSUP)

//
//  The Debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_VERFYSUP)

//
//  Local procedure prototypes
//

VOID
RxResetFcb (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

VOID
RxDetermineAndMarkFcbCondition (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

VOID
RxDeferredCleanVolume (
    PVOID Parameter
    );

RXSTATUS
RxMarkDirtyCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCheckDirtyBit)
#pragma alloc_text(PAGE, RxVerifyOperationIsLegal)
#pragma alloc_text(PAGE, RxDeferredCleanVolume)
#pragma alloc_text(PAGE, RxDetermineAndMarkFcbCondition)
#pragma alloc_text(PAGE, RxQuickVerifyVcb)
#pragma alloc_text(PAGE, RxPerformVerify)
#pragma alloc_text(PAGE, RxMarkFcbCondition)
#pragma alloc_text(PAGE, RxMarkVolumeClean)
#pragma alloc_text(PAGE, RxResetFcb)
#pragma alloc_text(PAGE, RxVerifyVcb)
#pragma alloc_text(PAGE, RxVerifyFcb)
#endif


VOID
RxMarkFcbCondition (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN FCB_CONDITION FcbCondition
    )

/*++

Routine Description:

    This routines marks the entire Fcb/Dcb structure from Fcb down with
    FcbCondition.

Arguments:

    Fcb - Supplies the Fcb/Dcb being marked

    FcbCondition - Supplies the setting to use for the Fcb Condition

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "RxMarkFcbCondition, Fcb = %08lx\n", Fcb );

    //
    //  If we are marking this Fcb something other than Good, we will need
    //  to have the Vcb exclusive.

    ASSERT( FcbCondition != FcbNeedsToBeVerified ? TRUE :
            RxVcbAcquiredExclusive(RxContext, Fcb->Vcb) );

    //
    //  If this is a PagingFile it has to be good.
    //

    if (FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE)) {

        Fcb->FcbCondition = FcbGood;
        return;
    }

    //
    //  Update the condition of the Fcb.
    //

    Fcb->FcbCondition = FcbCondition;

    DebugTrace(0, Dbg, "MarkFcb: %wZ\n", &Fcb->FullFileName);

    //
    //  This FastIo flag is based on FcbCondition, so update it now.
    //

    Fcb->Header.IsFastIoPossible = RxIsFastIoPossible( Fcb );

    //
    //  Now if we marked NeedsVerify or Bad a directory then we also need to
    //  go and mark all of our children with the same condition.
    //

    if ( ((FcbCondition == FcbNeedsToBeVerified) ||
          (FcbCondition == FcbBad)) &&
         ((Fcb->Header.NodeTypeCode == RDBSS_NTC_DCB) ||
          (Fcb->Header.NodeTypeCode == RDBSS_NTC_ROOT_DCB)) ) {

        PFCB OriginalFcb = Fcb;

        while ( (Fcb = RxGetNextFcb(RxContext, Fcb, OriginalFcb)) != NULL ) {

            DebugTrace(0, Dbg, "MarkFcb: %wZ\n", &Fcb->FullFileName);

            Fcb->FcbCondition = FcbCondition;

            Fcb->Header.IsFastIoPossible = RxIsFastIoPossible( Fcb );
        }
    }

    DebugTrace(-1, Dbg, "RxMarkFcbCondition -> VOID\n", 0);

    return;
}


VOID
RxVerifyVcb (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routines verifies that the Vcb still denotes a valid Volume
    If the Vcb is bad it raises an error condition.

Arguments:

    Vcb - Supplies the Vcb being verified

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "RxVerifyVcb, Vcb = %08lx\n", Vcb );

    //
    //  If the media is removable and the verify volume flag in the
    //  device object is not set then we want to ping the device
    //  to see if it needs to be verified.
    //
    //  Note that we only force this ping for create operations.
    //  For others we take a sporting chance.  If in the end we
    //  have to physically access the disk, the right thing will happen.
    //

    if ( FlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) &&
         !FlagOn(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME) ) {

        PIRP Irp;
        KEVENT Event;
        IO_STATUS_BLOCK Iosb;
        RXSTATUS Status;

        KeInitializeEvent( &Event, NotificationEvent, FALSE );

        Irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_CHECK_VERIFY,
                                             Vcb->TargetDeviceObject,
                                             NULL,
                                             0,
                                             NULL,
                                             0,
                                             FALSE,
                                             &Event,
                                             &Iosb );

        if ( Irp == NULL ) {

            RxRaiseStatus( RxContext, RxStatus(INSUFFICIENT_RESOURCES) );
        }

        Status = IoCallDriver( Vcb->TargetDeviceObject, Irp );


        if (Status == RxStatus(PENDING)) {
            Status = KeWaitForSingleObject( &Event,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL );

            ASSERT( Status == RxStatus(SUCCESS) );

            //
            //  This may raise an error.
            //

            if ( !NT_SUCCESS(Iosb.Status) ) {

                RxNormalizeAndRaiseStatus( RxContext, Iosb.Status );
            }

        } else {

            //
            //  This may raise an error.
            //

            if ( !NT_SUCCESS(Status) ) {

                RxNormalizeAndRaiseStatus( RxContext, Status );
            }
        }
    }

    //
    //  Now that the verify bit has been appropriately set, check the Vcb.
    //

    RxQuickVerifyVcb( RxContext, Vcb );

    DebugTrace(-1, Dbg, "RxVerifyVcb -> VOID\n", 0);

    return;
}


VOID
RxVerifyFcb (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routines verifies that the Fcb still denotes the same file.
    If the Fcb is bad it raises a error condition.

Arguments:

    Fcb - Supplies the Fcb being verified

Return Value:

    None.

--*/

{
    PFCB CurrentFcb;

    DebugTrace(+1, Dbg, "RxVerifyFcb, Vcb = %08lx\n", Fcb );

    //
    //  If this is the Fcb of a deleted dirent or our parent is deleted,
    //  no-op this call with the hope that the caller will do the right thing.
    //

    if (IsFileDeleted( RxContext, Fcb ) ||
        ((NodeType(Fcb) != RDBSS_NTC_ROOT_DCB) &&
         IsFileDeleted( RxContext, Fcb->ParentDcb ))) {

        return;
    }

    //
    //  If we are not in the process of doing a verify,
    //  first do a quick spot check on the Vcb.
    //

    if ( Fcb->Vcb->VerifyThread != KeGetCurrentThread() ) {

        RxQuickVerifyVcb( RxContext, Fcb->Vcb );
    }

    //
    //  Now based on the condition of the Fcb we'll either return
    //  immediately to the caller, raise a condition, or do some work
    //  to verify the Fcb.
    //

    switch (Fcb->FcbCondition) {

    case FcbGood:

        DebugTrace(0, Dbg, "The Fcb is good\n", 0);
        break;

    case FcbBad:

        RxRaiseStatus( RxContext, RxStatus(FILE_INVALID) );
        break;

    case FcbNeedsToBeVerified:

        //
        //  We loop here checking our ancestors until we hit an Fcb which
        //  is either good or bad.
        //

        CurrentFcb = Fcb;

        while (CurrentFcb->FcbCondition == FcbNeedsToBeVerified) {

            RxDetermineAndMarkFcbCondition(RxContext, CurrentFcb);

            //
            //  If this Fcb didn't make it, or it was the Root Dcb, exit
            //  the loop now, else continue with out parent.
            //

            if ( (CurrentFcb->FcbCondition != FcbGood) ||
                 (NodeType(CurrentFcb) == RDBSS_NTC_ROOT_DCB) ) {

                break;
            }

            CurrentFcb = CurrentFcb->ParentDcb;
        }

        //
        //  Now we can just look at ourselves to see how we did.
        //

        if (Fcb->FcbCondition != FcbGood) {

            RxRaiseStatus( RxContext, RxStatus(FILE_INVALID) );
        }

        break;

    default:

        DebugDump("Invalid FcbCondition\n", 0, Fcb);
        RxBugCheck( Fcb->FcbCondition, 0, 0 );
    }

    DebugTrace(-1, Dbg, "RxVerifyFcb -> VOID\n", 0);

    return;
}

VOID
RxDeferredCleanVolume (
    PVOID Parameter
    )

/*++

Routine Description:

    This is the routine that performs the actual RxMarkVolumeClean call.
    It assures that the target volume still exists as there ia a race
    condition between queueing the ExWorker item and volumes going away.

Arguments:

    Parameter - Points to a clean volume packet that was allocated from pool

Return Value:

    None.

--*/

{
    PCLEAN_AND_DIRTY_VOLUME_PACKET Packet;
    PLIST_ENTRY Links;
    PVCB Vcb;
    RX_CONTEXT RxContext;
    BOOLEAN VcbExists = FALSE;

    DebugTrace(+1, Dbg, "RxDeferredCleanVolume\n", 0);

    Packet = (PCLEAN_AND_DIRTY_VOLUME_PACKET)Parameter;

    Vcb = Packet->Vcb;

    //
    //  Make us appear as a top level FSP request so that we will
    //  receive any errors from the operation.
    //

    IoSetTopLevelIrp( (PIRP)FSRTL_FSP_TOP_LEVEL_IRP );

    //
    //  Dummy up and Irp Context so we can call our worker routines
    //

    RtlZeroMemory( &RxContext, sizeof(RX_CONTEXT));

    SetFlag(RxContext.Flags, RX_CONTEXT_FLAG_WAIT);

    //
    //  Acquire shared access to the global lock and make sure this volume
    //  still exists.
    //

    RxAcquireSharedGlobal( &RxContext );

    for (Links = RxData.VcbQueue.Flink;
         Links != &RxData.VcbQueue;
         Links = Links->Flink) {

        PVCB ExistingVcb;

        ExistingVcb = CONTAINING_RECORD(Links, VCB, VcbLinks);

        if ( Vcb == ExistingVcb ) {

            VcbExists = TRUE;
            break;
        }
    }

    //
    //  If the vcb is good then mark it clean.  Ignore any problems.
    //

    if ( VcbExists &&
         (Vcb->VcbCondition == VcbGood) ) {

        try {

            if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY)) {

                RxMarkVolumeClean( &RxContext, Vcb );
            }

            //
            //  Check for a pathelogical race condition, and fix it.
            //

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY)) {

                RxMarkVolumeDirty( &RxContext, Vcb, FALSE );

            } else {

                //
                //  Unlock the volume if it is removable.
                //

                if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) &&
                    !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE)) {

                    RxToggleMediaEjectDisable( &RxContext, Vcb, FALSE );
                }
            }

        } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                  EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

            NOTHING;
        }
    }

    //
    //  Release the global resource, unpin and repinned Bcbs and return.
    //

    RxReleaseGlobal( &RxContext );

    try {

        RxUnpinRepinnedBcbs( &RxContext );

    } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

        NOTHING;
    }

    IoSetTopLevelIrp( NULL );

    //
    //  and finally free the packet.
    //

    ExFreePool( Packet );

    return;
}


VOID
RxCleanVolumeDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is dispatched 5 seconds after the last disk structure was
    modified in a specific volume, and exqueues an execuative worker thread
    to perform the actual task of marking the volume dirty.

Arguments:

    DefferedContext - Contains the Vcb to process.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    PCLEAN_AND_DIRTY_VOLUME_PACKET Packet;

    Vcb = (PVCB)DeferredContext;

    //
    //  If there is still dirty data (highly unlikely), set the timer for a
    //  second in the future.
    //

    if (CcIsThereDirtyData(Vcb->Vpb)) {

        LARGE_INTEGER TwoSecondsFromNow;

        TwoSecondsFromNow.QuadPart = -2*1000*1000*10;

        KeSetTimer( &Vcb->CleanVolumeTimer,
                    TwoSecondsFromNow,
                    &Vcb->CleanVolumeDpc );

        return;
    }

    //
    //  If we couldn't get pool, oh well....
    //

    Packet = ExAllocatePool(NonPagedPool, sizeof(CLEAN_AND_DIRTY_VOLUME_PACKET));

    if ( Packet ) {

        Packet->Vcb = Vcb;
        Packet->Irp = NULL;

        //
        //  Clear the dirty flag now since we cannot synchronize after this point.
        //

        ClearFlag( Packet->Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY );

        ExInitializeWorkItem( &Packet->Item, &RxDeferredCleanVolume, Packet );

        ExQueueWorkItem( &Packet->Item, CriticalWorkQueue );
    }

    return;
}


VOID
RxMarkVolumeClean (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine marks the indicated rx volume as clean, but only if it is
    a non-removable media.  The volume is marked dirty by setting the first
    reserved byte of the first dirent in the root directory to 0.

Arguments:

    Vcb - Supplies the Vcb being modified

Return Value:

    None.

--*/

{
    PDIRENT Dirent;
    PBCB DirentBcb = NULL;
    RXSTATUS Status;

    DebugTrace(+1, Dbg, "RxMarkVolumeClean, Vcb = %08lx\n", Vcb);

    DebugTrace(0, Dbg, "Mark volume clean\n", 0);

    DirentBcb = NULL;

    //
    //  Make Wait TRUE
    //

    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );

    RxAcquireSharedFcb( RxContext, Vcb->RootDcb );

    try {

        //
        //  Bail if we get an IO error.
        //

        try {

            RxReadDirectoryFile( RxContext,
                                  Vcb->RootDcb,
                                  0,
                                  sizeof(DIRENT),
                                  TRUE,
                                  &DirentBcb,
                                  (PVOID *)&Dirent,
                                  &Status );

            //
            //  Set the volume clean.
            //

            ClearFlag( Dirent->NtByte, RDBSS_DIRENT_NT_BYTE_DIRTY );

            //
            //  Set the Bcb dirty and conditionally flush it.
            //

            CcSetDirtyPinnedData( DirentBcb, NULL );

        } except( RxExceptionFilter( RxContext, GetExceptionInformation() ) ) {

            NOTHING;
        }

        if (DirentBcb) {

            RxUnpinBcb( RxContext, DirentBcb );

            //
            //  Always flush this so that the drive is not unlocked prematurely
            //

            CcFlushCache( &Vcb->RootDcb->NonPaged->SectionObjectPointers,
                          &RxLargeZero,
                          sizeof( DIRENT ),
                          NULL );
        }

    } finally {

        RxReleaseFcb( RxContext, Vcb->RootDcb );
    }

    DebugTrace(-1, Dbg, "RxMarkVolumeClean -> VOID\n", 0);

    return;
}


VOID
RxFspMarkVolumeDirtyWithRecover(
    PVOID Parameter
    )

/*++

Routine Description:

    This is the routine that performs the actual RxMarkVolumeDirty call
    on of paging file Io that encounters a media error.  It is responsible
    for completing the PagingIo Irp as soon as this is done.

    Note:  this routine (and thus RxMarkVolumeDirty() must be resident as
           the paging file might be damaged at this point.

Arguments:

    Parameter - Points to a dirty volume packet that was allocated from pool

Return Value:

    None.

--*/

{
    PCLEAN_AND_DIRTY_VOLUME_PACKET Packet;
    PVCB Vcb;
    RX_CONTEXT RxContext;
    PIRP Irp;
    BOOLEAN VcbExists = FALSE;

    DebugTrace(+1, Dbg, "RxDeferredCleanVolume\n", 0);

    Packet = (PCLEAN_AND_DIRTY_VOLUME_PACKET)Parameter;

    Vcb = Packet->Vcb;
    Irp = Packet->Irp;

    //
    //  Dummy up the RxContext so we can call our worker routines
    //

    RtlZeroMemory( &RxContext, sizeof(RX_CONTEXT));

    SetFlag(RxContext.Flags, RX_CONTEXT_FLAG_WAIT);
    RxContext.CurrentIrp = Irp;

    //
    //  Make us appear as a top level FSP request so that we will
    //  receive any errors from the operation.
    //

    IoSetTopLevelIrp( (PIRP)FSRTL_FSP_TOP_LEVEL_IRP );

    //
    //  Try to write out the dirty bit.  If something goes wrong, we
    //  tried.
    //

    try {

        SetFlag( Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY );

        RxMarkVolumeDirty( &RxContext, Vcb, TRUE );

    } except(RxExceptionFilter( &RxContext, GetExceptionInformation() )) {

        NOTHING;
    }

    IoSetTopLevelIrp( NULL );

    //
    //  Now complete the originating Irp
    //

    IoCompleteRequest( Irp, IO_DISK_INCREMENT );
}


VOID
RxMarkVolumeDirty (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN BOOLEAN PerformSurfaceTest
    )

/*++

Routine Description:

    This routine marks the indicated rx volume as dirty, but only if it is
    a non-removable media.  The volume is marked dirty by setting the first
    reserved byte of the first dirent in the root directory to 1.

Arguments:

    Vcb - Supplies the Vcb being modified

    PerformSurfaceTest - Indicates to autochk that we think the media may be
        defective and that a surface test should be performed.

Return Value:

    None.

--*/

{
    PDIRENT Dirent;
    PBCB DirentBcb;
    KEVENT Event;
    PIRP Irp;
    LARGE_INTEGER ByteOffset;
    RXSTATUS Status;
    BOOLEAN ReleaseFcb = FALSE;

    DebugTrace(+1, Dbg, "RxMarkVolumeDirty, Vcb = %08lx\n", Vcb);

    Irp = NULL;
    DirentBcb = NULL;

    //
    //  Bail if we get an IO error.
    //

    try {

        //
        //  Make Wait TRUE
        //

        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );

        ReleaseFcb = RxAcquireSharedFcb( RxContext, Vcb->RootDcb );

        //
        //  Call Cc directly here so that RxReadDirectoryFile doesn't
        //  have to be resident.
        //

        CcPinRead( Vcb->RootDcb->Specific.Dcb.DirectoryFile,
                   &RxLargeZero,
                   sizeof(DIRENT),
                   TRUE,
                   &DirentBcb,
                   (PVOID *)&Dirent );

        DbgDoit( RxContext->PinCount += 1 )

        //
        //  Set the volume dirty.
        //

        SetFlag( Dirent->NtByte, RDBSS_DIRENT_NT_BYTE_DIRTY );

        //
        //  In addition, if this request received an error that may indicate
        //  media corruption, have autochk perform a surface test.
        //

        if ( PerformSurfaceTest ) {

            SetFlag( Dirent->NtByte, RDBSS_DIRENT_NT_BYTE_TEST_SURFACE );
        }

        //
        //  Initialize the event we're going to use
        //

        KeInitializeEvent( &Event, NotificationEvent, FALSE );

        //
        //  Build the irp for the operation and also set the overrride flag.
        //  Note that we may be at APC level, so do this asyncrhonously and
        //  use an event for synchronization as normal request completion
        //  cannot occur at APC level.
        //

        ByteOffset.QuadPart = Vcb->AllocationSupport.RootDirectoryLbo;

        Irp = IoBuildAsynchronousFsdRequest( IRP_MJ_WRITE,
                                             Vcb->TargetDeviceObject,
                                             (PVOID)Dirent,
                                             1 << Vcb->AllocationSupport.LogOfBytesPerSector,
                                             &ByteOffset,
                                             NULL );

        if ( Irp == NULL ) {

            RxRaiseStatus( RxContext, RxStatus(INSUFFICIENT_RESOURCES) );
        }

        //
        //  Set up the completion routine
        //

        IoSetCompletionRoutine( Irp,
                                RxMarkDirtyCompletionRoutine,
                                &Event,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Call the device to do the write and wait for it to finish.
        //

        (VOID)IoCallDriver( Vcb->TargetDeviceObject, Irp );
        (VOID)KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, (PLARGE_INTEGER)NULL );

        //
        //  Grab the Status.
        //

        Status = Irp->IoStatus.Status;

        //
        //  Raise any error status
        //

        if (!NT_SUCCESS(Status)) {

            RxNormalizeAndRaiseStatus( RxContext, Status );
        }

    } finally {

        //
        //  Clean up the Irp and Mdl
        //

        if (Irp) {

            //
            //  If there is an MDL (or MDLs) associated with this I/O
            //  request, Free it (them) here.  This is accomplished by
            //  walking the MDL list hanging off of the IRP and deallocating
            //  each MDL encountered.
            //

            while (Irp->MdlAddress != NULL) {

                PMDL NextMdl;

                NextMdl = Irp->MdlAddress->Next;

                MmUnlockPages( Irp->MdlAddress );

                IoFreeMdl( Irp->MdlAddress );

                Irp->MdlAddress = NextMdl;
            }

            IoFreeIrp( Irp );
        }

        if (DirentBcb != NULL) {

            RxUnpinBcb( RxContext, DirentBcb );
        }

        if (ReleaseFcb) {

            RxReleaseFcb( RxContext, Vcb->RootDcb );
        }
    }

    DebugTrace(-1, Dbg, "RxMarkVolumeDirty -> VOID\n", 0);

    return;
}


VOID
RxCheckDirtyBit (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine looks at the volume dirty bit, and depending on the state of
    VCB_STATE_FLAG_MOUNTED_DIRTY, the appropriate action is taken.

Arguments:

    Vcb - Supplies the Vcb being queried.

Return Value:

    None.

--*/

{
    BOOLEAN Dirty;

    PDIRENT Dirent;
    PBCB DirtyBitBcb;

    RXSTATUS Status;

    UNICODE_STRING VolumeLabel;

    //
    //  Look in the first dirent
    //

    RxReadDirectoryFile( RxContext,
                          Vcb->RootDcb,
                          0,
                          sizeof(DIRENT),
                          FALSE,
                          &DirtyBitBcb,
                          (PVOID *)&Dirent,
                          &Status );

    ASSERT( NT_SUCCESS( Status ));

    //
    //  Check if the magic bit is set
    //

    Dirty = BooleanFlagOn( Dirent->NtByte, RDBSS_DIRENT_NT_BYTE_DIRTY );

    //
    //  Setup the VolumeLabel string
    //

    VolumeLabel.Length = Vcb->Vpb->VolumeLabelLength;
    VolumeLabel.MaximumLength = MAXIMUM_VOLUME_LABEL_LENGTH;
    VolumeLabel.Buffer = &Vcb->Vpb->VolumeLabel[0];

    if ( Dirty ) {

        KdPrint(("FASTRDBSS: WARNING! Mounting Dirty Volume %wZ\n", &VolumeLabel));

        SetFlag( Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY );

    } else {

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY)) {

            KdPrint(("FASTRDBSS: Volume %wZ has been cleaned.\n", &VolumeLabel));

            ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY );

        } else {

            (VOID)FsRtlBalanceReads( Vcb->TargetDeviceObject );
        }
    }

    RxUnpinBcb( RxContext, DirtyBitBcb );
}


VOID
RxVerifyOperationIsLegal ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This routine determines is the requested operation should be allowed to
    continue.  It either returns to the user if the request is Okay, or
    raises an appropriate status.

Arguments:

    Irp - Supplies the Irp to check

Return Value:

    None.

--*/

{
    RxCaptureRequestPacket;
    RxCaptureParamBlock; RxCaptureFileObject;

    //
    //  If the Irp is not present, then we got here via close.
    //
    //

    if ( capReqPacket == NULL ) {

        return;
    }

    //
    //  If there is not a file object, we cannot continue.
    //

    if ( capFileObject == NULL ) {

        return;
    }

    //
    //  If we are trying to do any other operation than close on a file
    //  object marked for delete, raise RxStatus(DELETE_PENDING).
    //

    if ( ( capFileObject->DeletePending == TRUE ) &&
         ( RxContext->MajorFunction != IRP_MJ_CLEANUP ) &&
         ( RxContext->MajorFunction != IRP_MJ_CLOSE ) ) {

        RxRaiseStatus( RxContext, RxStatus(DELETE_PENDING) );
    }

    //
    //  If we are doing a create, and there is a related file objects, and
    //  it it is marked for delete, raise RxStatus(DELETE_PENDING).
    //

    if ( RxContext->MajorFunction == IRP_MJ_CREATE ) {

        PFILE_OBJECT RelatedFileObject;

        RelatedFileObject = capFileObject->RelatedFileObject;

        if ( (RelatedFileObject != NULL) &&
             FlagOn(((PFCB)RelatedFileObject->FsContext)->FcbState,
                    FCB_STATE_DELETE_ON_CLOSE) )  {

            RxRaiseStatus( RxContext, RxStatus(DELETE_PENDING) );
        }
    }

    //
    //  If the file object has already been cleaned up, and
    //
    //  A) This request is a paging io read or write, or
    //  B) This request is a close operation, or
    //  C) This request is a set or query info call (for Lou)
    //  D) This is an MDL complete
    //
    //  let it pass, otherwise return RxStatus(FILE_CLOSED).
    //

    if ( FlagOn(capFileObject->Flags, FO_CLEANUP_COMPLETE) ) {

        if ( (FlagOn(capReqPacket->Flags, IRP_PAGING_IO)) ||
             (capPARAMS->MajorFunction == IRP_MJ_CLOSE ) ||
             (capPARAMS->MajorFunction == IRP_MJ_SET_INFORMATION) ||
             (capPARAMS->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
             ( ( (capPARAMS->MajorFunction == IRP_MJ_READ) ||
                 (capPARAMS->MajorFunction == IRP_MJ_WRITE) ) &&
               FlagOn(capPARAMS->MinorFunction, IRP_MN_COMPLETE) ) ) {

            NOTHING;

        } else {

            RxRaiseStatus( RxContext, RxStatus(FILE_CLOSED) );
        }
    }

    return;
}



//
//  Internal support routine
//

VOID
RxResetFcb (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called when an Fcb has been marked as needs to be verified.

    It does the following tasks:

        - Reset Mcb mapping information
        - For directories, reset dirent hints
        - Set allocation size to unknown

Arguments:

    Fcb - Supplies the Fcb to reset

Return Value:

    None.

--*/

{
    //
    //  Don't do the two following operations for the Root Dcb.
    //

    if ( NodeType(Fcb) != RDBSS_NTC_ROOT_DCB ) {

        POOL_TYPE PoolType;

        //
        //  If this happens to be a paging file, use non-paged pool for the FCB
        //

        if ( FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) ) {

            PoolType = NonPagedPool;

        } else {

            PoolType = PagedPool;
        }

        //
        //  Reset the mcb mapping.
        //

        FsRtlRemoveMcbEntry( &Fcb->Mcb, 0, 0xFFFFFFFF );

        //
        //  Reset the allocation size to 0 or unknown
        //

        if ( Fcb->FirstClusterOfFile == 0 ) {

            Fcb->Header.AllocationSize = RxLargeZero;

        } else {

            Fcb->Header.AllocationSize.QuadPart = -1;
        }
    }

    //
    //  If this is a directory, reset the hints.
    //

    if ( (NodeType(Fcb) == RDBSS_NTC_DCB) ||
         (NodeType(Fcb) == RDBSS_NTC_ROOT_DCB) ) {

        //
        //  Force a rescan of the directory
        //

        Fcb->Specific.Dcb.UnusedDirentVbo = 0xffffffff;
        Fcb->Specific.Dcb.DeletedDirentHint = 0xffffffff;
    }
}



//
//  Internal support routine
//

VOID
RxDetermineAndMarkFcbCondition (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine checks a specific Fcb to see if it is different from what's
    on the disk.  The following things are checked:

        - File Name
        - File Size (if not directory)
        - First Cluster Of File
        - Dirent Attributes

Arguments:

    Fcb - Supplies the Fcb to examine

Return Value:

    None.

--*/

{
    PDIRENT Dirent;
    PBCB DirentBcb;

    OEM_STRING Name;
    CHAR Buffer[16];

    //
    //  If this is the Root Dcb, special case it.  That is, we know
    //  by definition that it is good since it is fixed in the volume
    //  structure.
    //

    if ( NodeType(Fcb) == RDBSS_NTC_ROOT_DCB ) {

        RxResetFcb( RxContext, Fcb );

        RxMarkFcbCondition( RxContext, Fcb, FcbGood );

        return;
    }

    //  The first thing we need to do to verify ourselves is
    //  locate the dirent on the disk.
    //

    RxGetDirentFromFcbOrDcb( RxContext,
                              Fcb,
                              &Dirent,
                              &DirentBcb );

    //
    //  We located the dirent for ourselves now make sure it
    //  is really ours by comparing the Name and RxFlags.
    //  Then for a file we also check the file size.
    //
    //  Note that we have to unpin the Bcb before calling RxResetFcb
    //  in order to avoid a deadlock in CcUninitializeCacheMap.
    //

    Name.MaximumLength = 16;
    Name.Buffer = &Buffer[0];

    Rx8dot3ToString( RxContext, Dirent, FALSE, &Name );

    if (!RtlEqualString( &Name, &Fcb->ShortName.Name.Oem, TRUE )

            ||

         ( (NodeType(Fcb) == RDBSS_NTC_FCB) &&
           (Fcb->Header.FileSize.LowPart != Dirent->FileSize) )

            ||

         ((ULONG)Dirent->FirstClusterOfFile != Fcb->FirstClusterOfFile)

            ||

          (Dirent->Attributes != Fcb->DirentRxFlags) ) {

        RxMarkFcbCondition( RxContext, Fcb, FcbBad );

        RxUnpinBcb( RxContext, DirentBcb );

    } else {

        //
        //  We passed.  Get the Fcb ready to use again.
        //

        RxUnpinBcb( RxContext, DirentBcb );

        RxResetFcb( RxContext, Fcb );

        RxMarkFcbCondition( RxContext, Fcb, FcbGood );
    }

    return;
}



//
//  Internal support routine
//

VOID
RxQuickVerifyVcb (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routines just checks the verify bit in the real device and the
    Vcb condition and raises an appropriate exception if so warented.
    It is called when verifying both Fcbs and Vcbs.

Arguments:

    Vcb - Supplies the Vcb to check the condition of.

Return Value:

    None.

--*/

{
    RxCaptureRequestPacket;

    //
    //  If the real device needs to be verified we'll set the
    //  DeviceToVerify to be our real device and raise VerifyRequired.
    //

    if (FlagOn(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME)) {

        DebugTrace(0, Dbg, "The Vcb needs to be verified\n", 0);

        IoSetHardErrorOrVerifyDevice( capReqPacket,
                                      Vcb->Vpb->RealDevice );

        RxRaiseStatus( RxContext, RxStatus(VERIFY_REQUIRED) );
    }

    //
    //  Based on the condition of the Vcb we'll either return to our
    //  caller or raise an error condition
    //

    switch (Vcb->VcbCondition) {

    case VcbGood:

        DebugTrace(0, Dbg, "The Vcb is good\n", 0);

        //
        //  Do a check here of an operation that would try to modify a
        //  write protected media.
        //

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED) &&
            ((RxContext->MajorFunction == IRP_MJ_WRITE) ||
             (RxContext->MajorFunction == IRP_MJ_SET_INFORMATION) ||
             (RxContext->MajorFunction == IRP_MJ_SET_EA) ||
             (RxContext->MajorFunction == IRP_MJ_FLUSH_BUFFERS) ||
             (RxContext->MajorFunction == IRP_MJ_SET_VOLUME_INFORMATION))) {

            //
            //  Set the real device for the pop-up info, and set the verify
            //  bit in the device object, so that we will force a verify
            //  in case the user put the correct media back in.
            //


            IoSetHardErrorOrVerifyDevice( capReqPacket,
                                          Vcb->Vpb->RealDevice );

            SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);

            RxRaiseStatus( RxContext, RxStatus(MEDIA_WRITE_PROTECTED) );
        }

        break;

    case VcbNotMounted:

        DebugTrace(0, Dbg, "The Vcb is not mounted\n", 0);

        //
        //  Set the real device for the pop-up info, and set the verify
        //  bit in the device object, so that we will force a verify
        //  in case the user put the correct media back in.
        //

        IoSetHardErrorOrVerifyDevice( capReqPacket,
                                      Vcb->Vpb->RealDevice );

        SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);

        RxRaiseStatus( RxContext, RxStatus(WRONG_VOLUME) );

        break;

    default:

        DebugDump("Invalid VcbCondition\n", 0, Vcb);
        RxBugCheck( Vcb->VcbCondition, 0, 0 );
    }
}

RXSTATUS
RxPerformVerify (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT Device
    )

/*++

Routine Description:

    This routines performs an IoVerifyVolume operation and takes the
    appropriate action.  After the Verify is complete the originating
    Irp is sent off to an Ex Worker Thread.  This routine is called
    from the exception handler.

Arguments:

    Irp - The irp to send off after all is well and done.

    Device - The real device needing verification.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    RXSTATUS Status = RxStatus(SUCCESS);
    RxCaptureParamBlock; RxCaptureFileObject;

    //
    //  Check if this Irp has a status of Verify required and if it does
    //  then call the I/O system to do a verify.
    //
    //  Skip the IoVerifyVolume if this is a mount or verify request
    //  itself.  Trying a recursive mount will cause a deadlock with
    //  the DeviceObject->DeviceLock.
    //

    if ( (RxContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL)

               &&

         ((RxContext->MinorFunction == IRP_MN_MOUNT_VOLUME) ||
          (RxContext->MinorFunction == IRP_MN_VERIFY_VOLUME)) ) {

        return RxFsdPostRequest( RxContext );
    }

    DebugTrace(0, Dbg, "Verify Required, DeviceObject = %08lx\n", Device);

    //
    //  Extract a pointer to the Vcb from the RxDeviceObject.
    //  Note that since we have specifically excluded mount,
    //  requests, we know that IrpSp->DeviceObject is indeed a
    //  volume device object.
    //

    Vcb = &CONTAINING_RECORD( capPARAMS->DeviceObject,
                              RDBSS_DEVICE_OBJECT,
                              DeviceObject )->Vcb;

    //
    //  Check if the volume still thinks it needs to be verified,
    //  if it doesn't then we can skip doing a verify because someone
    //  else beat us to it.
    //

    try {

        if (FlagOn(Device->Flags, DO_VERIFY_VOLUME)) {

            BOOLEAN AllowRawMount;
#ifdef WE_WON_ON_APPEAL
            PLIST_ENTRY Links;
#endif // WE_WON_ON_APPEAL

            //
            //  We will allow Raw to mount this volume if we were doing a
            //  a DASD open.
            //

            if ( (RxContext->MajorFunction == IRP_MJ_CREATE) &&
                 (capFileObject->FileName.Length == 0) &&
                 (capFileObject->RelatedFileObject == NULL) ) {

                AllowRawMount = TRUE;

            } else {

                AllowRawMount = FALSE;
            }

            //
            //  If the IopMount in IoVerifyVolume did something, and
            //  this is an absolute open, force a reparse.
            //

            Status = IoVerifyVolume( Device, AllowRawMount );

            //
            //  If the verify operation completed it will return
            //  either RxStatus(SUCCESS) or STATUS_WRONG_VOLUME, exactly.
            //
            //  If RxVerifyVolume encountered an error during
            //  processing, it will return that error.  If we got
            //  RxStatus(WRONG_VOLUME) from the verfy, and our volume
            //  is now mounted, commute the status to RxStatus(SUCCESS).
            //

            if ( (Status == RxStatus(WRONG_VOLUME)) &&
                 (Vcb->VcbCondition == VcbGood) ) {

                Status = RxStatus(SUCCESS);
            }

            //
            //  Do a quick unprotected check here.  The routine will do
            //  a safe check.  After here we can release the resource.
            //  Note that if the volume really went away, we will be taking
            //  the Reparse path.
            //

            (VOID)RxAcquireExclusiveGlobal( RxContext );

#ifdef WE_WON_ON_APPEAL

            //
            //  It is possible we were called with a double space Vcb.
            //  We need to start with the Parent Vcb at this point.
            //

            if (Vcb->Dscb) {

                Vcb = Vcb->Dscb->ParentVcb;
            }

            //
            //  First run through any mounted DBLS volumes.  Note that we
            //  have to get the next Flink before calling RxCheckForDismount
            //  incase the Vcb goes away.
            //

            (VOID)RxAcquireExclusiveVcb( RxContext, Vcb );

            for (Links = Vcb->ParentDscbLinks.Flink;
                 Links != &Vcb->ParentDscbLinks; ) {

                PVCB ChildVcb;

                ChildVcb = CONTAINING_RECORD( Links, DSCB, ChildDscbLinks )->Vcb;

                Links = Links->Flink;

                ASSERT( ChildVcb->Vpb->RealDevice == Vcb->Vpb->RealDevice );

                if ( (ChildVcb->VcbCondition == VcbNotMounted) &&
                     (ChildVcb->OpenFileCount == 0) ) {

                    (VOID)RxCheckForDismount( RxContext, ChildVcb );
                }
            }

            RxReleaseVcb( RxContext, Vcb );

#endif // WE_WON_ON_APPEAL

            if ( (Vcb->VcbCondition == VcbNotMounted) &&
                 (Vcb->OpenFileCount == 0) ) {

                (VOID)RxCheckForDismount( RxContext, Vcb );
            }

            RxReleaseGlobal( RxContext );

            if ((RxContext->MajorFunction == IRP_MJ_CREATE) &&
                (capFileObject->RelatedFileObject == NULL) &&
                ((Status == RxStatus(SUCCESS)) || (Status == STATUS_WRONG_VOLUME))) {

                Irp->IoStatus.Information = IO_REMOUNT;

                RxCompleteRequest( RxContext, RxStatus(REPARSE) );
                Status = RxStatus(REPARSE);
                Irp = NULL;
            }

            if ( (Irp != NULL) && !NT_SUCCESS(Status) ) {

                //
                //  Fill in the device object if required.
                //

                if ( IoIsErrorUserInduced( Status ) ) {

                    IoSetHardErrorOrVerifyDevice( Irp, Device );
                }

                RxNormalizeAndRaiseStatus( RxContext, Status );
            }

        } else {

            DebugTrace(0, Dbg, "Volume no longer needs verification\n", 0);
        }

        //
        //  If there is still an Irp, send it off to an Ex Worker thread.
        //

        if ( Irp != NULL ) {

            Status = RxFsdPostRequest( RxContext );
        }

    } except(RxExceptionFilter( RxContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the verify or raised
        //  an error ourselves.  So we'll abort the I/O request with
        //  the error status that we get back from the execption code.
        //

        Status = RxProcessException( RxContext, GetExceptionCode() );
    }

    return Status;
}

//
//  Local support routine
//

RXSTATUS
RxMarkDirtyCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Set the event so that our call will wake up.
    //

    KeSetEvent( (PKEVENT)Contxt, 0, FALSE );

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    return RxStatus(MORE_PROCESSING_REQUIRED);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\asynceng.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    MRxProxyAsyncEng.h

Abstract:

    This module defines the types and functions related to the SMB protocol
    selection engine: the component that translates minirdr calldowns into
    SMBs.

Revision History:

--*/

#ifndef _ASYNCENG_H_
#define _ASYNCENG_H_
#include "innerio.h"

IMPORTANT_STRUCTURE(MRXPROXY_ASYNCENGINE_CONTEXT);

#define MRXPROXY_ASYNCENGINE_ARGUMENT_SIGNATURE \
    PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext, \
    PRX_CONTEXT RxContext

#define MRXPROXY_ASYNCENGINE_ARGUMENTS \
    AsyncEngineContext,RxContext

#if DBG
#define OECHKLINKAGE_FLAG_NO_REQPCKT_CHECK 0x00000001

VOID
__MRxProxyAsyncEngOEAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Flags
    );
#define MRxProxyAsyncEngOEAssertConsistentLinkage(a) {\
   __MRxProxyAsyncEngOEAssertConsistentLinkage(a,__FILE__,__LINE__,RxContext,AsyncEngineContext,0);\
   }
#define MRxProxyAsyncEngOEAssertConsistentLinkageFromOE(a) {\
    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);                        \
   __MRxProxyAsyncEngOEAssertConsistentLinkage(a,__FILE__,__LINE__,              \
                                     AsyncEngineContext->RxContext,      \
                                     AsyncEngineContext,0);  \
   }
#define MRxProxyAsyncEngOEAssertConsistentLinkageFromOEwithFlags(a,FLAGS) {\
    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);                        \
   __MRxProxyAsyncEngOEAssertConsistentLinkage(a,__FILE__,__LINE__,              \
                                     AsyncEngineContext->RxContext,      \
                                     AsyncEngineContext,FLAGS);  \
   }
#else
#define MRxProxyAsyncEngOEAssertConsistentLinkage(a) {NOTHING;}
#define MRxProxyAsyncEngOEAssertConsistentLinkageFromOE(a) {NOTHING;}
#define MRxProxyAsyncEngOEAssertConsistentLinkageFromOEwithFlags(a,b) {NOTHING;}
#endif

typedef
NTSTATUS
(*PMRXPROXY_ASYNCENG_CONTINUE_ROUTINE) (
    MRXPROXY_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

//typedef
//NTSTATUS
//(*PMRXPROXY_ASYNCENG_FINISH_ROUTINE) (
//    PMRXPROXY_ASYNCENGINE_CONTEXT
//    );

#define MRXPROXY_ASYNCENG_OE_HISTORY_SIZE 32
typedef struct _ASYNCENG_HISTORY {
    ULONG Next;
    ULONG Submits; //could be shortened....
    struct {
        ULONG Longs[2];
    } Markers[MRXPROXY_ASYNCENG_OE_HISTORY_SIZE];
} ASYNCENG_HISTORY;

#if DBG
VOID MRxProxyAsyncEngUpdateOEHistory(
    PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Tag1,
    ULONG Tag2
    );
#define UPDATE_OE_HISTORY_LONG(a) {MRxProxyAsyncEngUpdateOEHistory(AsyncEngineContext,a,0);}
#define UPDATE_OE_HISTORY_2SHORTS(a,b) {MRxProxyAsyncEngUpdateOEHistory(AsyncEngineContext,a,b);}
#else
#define UPDATE_OE_HISTORY_LONG(a)
#define UPDATE_OE_HISTORY_2SHORTS(a,b)
#endif //if DBG

//these are used by the continuation routines to specify what kind of
//async submit is being done
typedef enum _MRXPROXY_ASYNCENGINE_CONTEXT_TYPE {
    //MRXPROXY_ASYNCENG_AECTXTYPE_CREATE,
    MRXPROXY_ASYNCENG_AECTXTYPE_READ,
    MRXPROXY_ASYNCENG_AECTXTYPE_WRITE,
    MRXPROXY_ASYNCENG_AECTXTYPE_QUERYDIR,
    MRXPROXY_ASYNCENG_AECTXTYPE_LOCKS,
    MRXPROXY_ASYNCENG_AECTXTYPE_FLUSH,
    MRXPROXY_ASYNCENG_AECTXTYPE_CLOSE,
    //MRXPROXY_ASYNCENG_AECTXTYPE_SEARCH,
    MRXPROXY_ASYNCENG_AECTXTYPE_MAXIMUM
} MRXPROXY_ASYNCENGINE_CONTEXT_TYPE;

//these are used by the entry point routines to specify what entrypoint was
//called....this facilitates common continuation routines
typedef enum _MRXPROXY_ASYNCENGINE_CONTEXT_ENTRYPOINTS {
    MRXPROXY_ASYNCENG_CTX_FROM_LOCKS,
    MRXPROXY_ASYNCENG_CTX_FROM_FLUSH,
    MRXPROXY_ASYNCENG_CTX_FROM_CLEANUPFOBX,
    MRXPROXY_ASYNCENG_CTX_FROM_CLOSESRVCALL,
    MRXPROXY_ASYNCENG_CTX_FROM_CREATE,
    MRXPROXY_ASYNCENG_CTX_FROM_RENAME,
    MRXPROXY_ASYNCENG_CTX_FROM_READ,
    MRXPROXY_ASYNCENG_CTX_FROM_WRITE,
    MRXPROXY_ASYNCENG_CTX_FROM_QUERYDIR,
    MRXPROXY_ASYNCENG_CTX_FROM_FAKESETDELETEDISPOSITION,
    MRXPROXY_ASYNCENG_CTX_FROM_MAXIMUM
} MRXPROXY_ASYNCENGINE_CONTEXT_ENTRYPOINTS;

#define MRXPROXY_ASYNCENG_DEFINE_CTX_FLAG(a,c) RX_DEFINE_FLAG(MRXPROXY_ASYNCENG_CTX_FLAG_##a,c,0xffff)

typedef enum {
    MRXPROXY_ASYNCENG_DEFINE_CTX_FLAG(MUST_SUCCEED_ALLOCATED, 0)
    MRXPROXY_ASYNCENG_DEFINE_CTX_FLAG(AWAITING_DISPATCH, 1)
    MRXPROXY_ASYNCENG_DEFINE_CTX_FLAG(ASYNC_OPERATION, 2)
    MRXPROXY_ASYNCENG_DEFINE_CTX_FLAG(POSTED_RESUME, 3)
    //MRXPROXY_ASYNCENG_DEFINE_CTX_FLAG(NETROOT_GOOD, 15)
} RX_CONTEXT_CREATE_FLAGS;

typedef enum _MRXPROXY_ASYNCENG_OE_INNERIO_STATE {
    MRxProxyAsyncEngOEInnerIoStates_Initial = 0,
    MRxProxyAsyncEngOEInnerIoStates_ReadyToSend,
    MRxProxyAsyncEngOEInnerIoStates_OperationOutstanding
} MRXPROXY_ASYNCENG_OE_INNERIO_STATE;

typedef struct _MRXPROXY_ASYNCENGINE_CONTEXT{
    MRX_NORMAL_NODE_HEADER;
    PRX_CONTEXT RxContext;
    PIRP CalldownIrp;
    union {
        IO_STATUS_BLOCK;
        IO_STATUS_BLOCK IoStatusBlock;
    };
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
    MRXPROXY_ASYNCENGINE_CONTEXT_TYPE AECTXType;
    MRXPROXY_ASYNCENGINE_CONTEXT_ENTRYPOINTS EntryPoint;
    ULONG ContinueEntryCount;
    USHORT Flags;
    UCHAR  OpSpecificFlags;
    UCHAR  OpSpecificState;
    PMRXPROXY_ASYNCENG_CONTINUE_ROUTINE Continuation;
    //PMRXPROXY_ASYNCENG_FINISH_ROUTINE FinishRoutine;
    union {
       struct {
           PUCHAR PtrToLockType;   //this must be here because the beginning of the
                                   //lockstart code sets the locklist to zero which will be this
                                   //CODE.IMPROVEMENT.ASHAMED fix this up so that assert locks uses readwrite
           PMRX_SRV_OPEN SrvOpen;
           PRX_LOCK_ENUMERATOR LockEnumerator;
           PVOID ContinuationHandle;
           ULONG NumberOfLocksPlaced;
           LARGE_INTEGER NextLockOffset;
           LARGE_INTEGER NextLockRange;
           BOOLEAN NextLockIsExclusive;
           BOOLEAN LockAreaNonEmpty;
           BOOLEAN EndOfListReached;
       } AssertLocks;
    } ;
//#if DBG      CODE.IMPROVEMENT we should get rid of what we don't really, really need
    ULONG SerialNumber;
    ASYNCENG_HISTORY History;
    PIRP RxContextCapturedRequestPacket;
    PMDL  SaveDataMdlForDebug;
    ULONG SaveLengthForDebug;
    PMDL  SaveIrpMdlForDebug;
//#endif
} MRXPROXY_ASYNCENGINE_CONTEXT, *PMRXPROXY_ASYNCENGINE_CONTEXT;

NTSTATUS
MRxProxySubmitAsyncEngRequest(
    MRXPROXY_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN MRXPROXY_ASYNCENGINE_CONTEXT_TYPE AECTXType
    );

NTSTATUS
MRxProxyResumeAsyncEngineContext(
    IN OUT PRX_CONTEXT RxContext
    );

#define ASSERT_ASYNCENG_CONTEXT(__p) ASSERT(NodeType(__p)==PROXY_NTC_ASYNCENGINE_CONTEXT)


NTSTATUS
__MRxProxyAsyncEngineOuterWrapper (
    IN PRX_CONTEXT RxContext,
    IN MRXPROXY_ASYNCENGINE_CONTEXT_ENTRYPOINTS EntryPoint,
    IN PMRXPROXY_ASYNCENG_CONTINUE_ROUTINE Continuation
#if DBG
   ,IN PSZ RoutineName,
    IN BOOLEAN LoudProcessing,
    IN BOOLEAN StopOnLoud
#endif
    );
#if DBG
#define MRxProxyAsyncEngineOuterWrapper(r,e,c,x1,x2,x3) \
     __MRxProxyAsyncEngineOuterWrapper(r,e,c,x1,x2,x3)
#else
#define MRxProxyAsyncEngineOuterWrapper(r,e,c,x1,x2,x3) \
     __MRxProxyAsyncEngineOuterWrapper(r,e,c)
#endif

PMRXPROXY_ASYNCENGINE_CONTEXT
MRxProxyCreateAsyncEngineContext (
    IN PRX_CONTEXT RxContext,
    IN MRXPROXY_ASYNCENGINE_CONTEXT_ENTRYPOINTS EntryPoint
    );

#define MRxProxyReferenceAsyncEngineContext(AsyncEngineContext) {\
        ULONG result = InterlockedIncrement(&(AsyncEngineContext)->NodeReferenceCount); \
        RxDbgTrace(0, (DEBUG_TRACE_MRXPROXY_ASYNCENG), \
                    ("ReferenceAsyncEngineContext result=%08lx\n", result )); \
        }

BOOLEAN
MRxProxyFinalizeAsyncEngineContext (
    IN OUT PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext
    );

// this macro is used to do the async completion for read/write/locks. Note that the call to lowiocompletion
// will try to complete the irp thereby freeing the user's mdl.
// we use this macro so that there will be only one version of this code. when we combine start routines,
// this will be un macroed
#define MRxProxyAsyncEngAsyncCompletionIfNecessary(AECTX,RXCONTEXT) {                 \
    if (ContinueEntryCount>1) {                                                       \
    	BOOLEAN FinalizationComplete;                                              \
        if (FALSE) {DbgBreakPoint(); }                                             \
    	(RXCONTEXT)->StoredStatus = Status;                                        \
    	RxLowIoCompletion((RXCONTEXT));                                            \
    	FinalizationComplete = MRxProxyFinalizeAsyncEngineContext((AECTX));   \
    	ASSERT(!FinalizationComplete);                                             \
    }}

NTSTATUS
MRxProxyAsyncEngineCalldownIrpCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN OUT PVOID Context
    );
#endif // _ASYNCENG_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\asynceng.c ===
/*++ Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    MRxProxyAsyncEng.c

Abstract:

    This module defines the types and functions related to the SMB protocol
    selection engine: the component that translates minirdr calldowns into
    SMBs.

Author:

    Joe Linn        [JoeLi] -- Implemented Ordinary Exchange

Notes:


--*/

#include "precomp.h"
#pragma hdrstop
#include <dfsfsctl.h>

RXDT_DefineCategory(MRXPROXY_ASYNCENG);
#define Dbg                              (DEBUG_TRACE_MRXPROXY_ASYNCENG)

#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif //ifdef RX_PRIVATE_BUILD

typedef struct _MRXPROXY_ASYNCENG_MUST_SUCCEEED_CONTEXT {
    struct {
        LIST_ENTRY ExchangeListEntry;
        union {
            MRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext;
        };
    };
//    MRXPROXY_ASYNCENG_VESTIGIAL_SMBBUF SmbBuf;
//    struct {
//        union {
//            MDL;
//            MDL Mdl;
//        };
//        ULONG Pages[2];
//    } DataPartialMdl;
} MRXPROXY_ASYNCENG_MUST_SUCCEEED_CONTEXT, *PMRXPROXY_ASYNCENG_MUST_SUCCEEED_CONTEXT;

BOOLEAN MRxProxyEntryPointIsMustSucceedable[MRXPROXY_ASYNCENG_CTX_FROM_MAXIMUM];

typedef enum {
    MRxProxyAsyncEngMustSucceed = 0,
    MRxProxyAsyncEngMustSucceedMaximum
};
RX_MUSTSUCCEED_DESCRIPTOR MRxProxyAsyncEngMustSucceedDescriptor[MRxProxyAsyncEngMustSucceedMaximum];
MRXPROXY_ASYNCENG_MUST_SUCCEEED_CONTEXT MRxProxyAsyncEngMustSucceedAsyncEngineContext[MRxProxyAsyncEngMustSucceedMaximum];

#define MIN(x,y) ((x) < (y) ? (x) : (y))


#if DBG
#define P__ASSERT(exp) {             \
    if (!(exp)) {                    \
        DbgPrint("NOT %s\n",#exp);   \
        errors++;                    \
    }}
VOID
__MRxProxyAsyncEngOEAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Flags
    )
/*++

Routine Description:

   This routine performs a variety of checks to ensure that the linkage between
   the RxContext and the AsyncEngineContext is correct and that various fields
   have correct values. if anything is bad....print stuff out and brkpoint;

Arguments:

     MsgPrefix          an identifying msg
     RxContext           duh
     AsyncEngineContext    .

Return Value:

    none

Notes:

--*/
{
    ULONG errors = 0;

    PMRXPROXY_RX_CONTEXT pMRxProxyContext;

    pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);

    P__ASSERT( AsyncEngineContext->SerialNumber == RxContext->SerialNumber );
    P__ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );
    P__ASSERT( NodeType(AsyncEngineContext)==PROXY_NTC_ASYNCENGINE_CONTEXT );
    P__ASSERT( AsyncEngineContext->RxContext == RxContext );
    P__ASSERT( pMRxProxyContext->AsyncEngineContext == AsyncEngineContext );
    if (!FlagOn(Flags,OECHKLINKAGE_FLAG_NO_REQPCKT_CHECK)) {
        P__ASSERT( AsyncEngineContext->RxContextCapturedRequestPacket == RxContext->CurrentIrp);
    }
    if (errors==0) {
        return;
    }
    DbgPrint("%s INCONSISTENT OE STATE: %d errors at %s line %d\n",
                 MsgPrefix,errors,File,Line);
    DbgBreakPoint();
    return;
}

ULONG MRxProxyAsyncEngShortStatus(ULONG Status)
{
    ULONG ShortStatus;

    ShortStatus = Status & 0xc0003fff;
    ShortStatus = ShortStatus | (ShortStatus >>16);
    return(ShortStatus);
}

VOID MRxProxyAsyncEngUpdateOEHistory(
    PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Tag1,
    ULONG Tag2
    )
{
    ULONG MyIndex,Long0,Long1;

    MyIndex = InterlockedIncrement(&AsyncEngineContext->History.Next);
    MyIndex = (MyIndex-1) & (MRXPROXY_ASYNCENG_OE_HISTORY_SIZE-1);
    Long0 = (Tag1<<16) | (Tag2 & 0xffff);
    Long1 = (MRxProxyAsyncEngShortStatus(AsyncEngineContext->Status)<<16) | AsyncEngineContext->Flags;
    AsyncEngineContext->History.Markers[MyIndex].Longs[0] = Long0;
    AsyncEngineContext->History.Markers[MyIndex].Longs[1] = Long1;
}

#else
#endif

#define UPDATE_OE_HISTORY_WITH_STATUS(a) UPDATE_OE_HISTORY_2SHORTS(a,MRxProxyAsyncEngShortStatus(AsyncEngineContext->Status))

NTSTATUS
MRxProxyResumeAsyncEngineContext(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine resumes processing on an exchange. This is called when work is
   required to finish processing a request that cannot be completed at DPC
   level.  This happens either because the parse routine needs access to
   structures that are not locks OR because the operation if asynchronous and
   there maybe more work to be done.

   The two cases are regularized by delaying the parse if we know that we're
   going to post: this is indicated by the presense of a resume routine.

Arguments:

    RxContext  - the context of the operation. .

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;
    PMRXPROXY_RX_CONTEXT pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);

    PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext =
                        (PMRXPROXY_ASYNCENGINE_CONTEXT)(pMRxProxyContext->AsyncEngineContext);
    RxCaptureFobx;
    BOOLEAN PostedResume;
    //PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    //PMDL SubmitMdl, HeaderFullMdl;

    RxDbgTrace(+1, Dbg, ("MRxProxyResumeAsyncEngineContext entering........OE=%08lx\n",AsyncEngineContext));
    ClearFlag(AsyncEngineContext->Flags,MRXPROXY_ASYNCENG_CTX_FLAG_AWAITING_DISPATCH);
    PostedResume = BooleanFlagOn(AsyncEngineContext->Flags,MRXPROXY_ASYNCENG_CTX_FLAG_POSTED_RESUME);
    ClearFlag(AsyncEngineContext->Flags,MRXPROXY_ASYNCENG_CTX_FLAG_POSTED_RESUME);

    MRxProxyAsyncEngOEAssertConsistentLinkageFromOE("MRxProxyAsyncEngContinueAsyncEngineContext:");

    Status = AsyncEngineContext->Status;
    UPDATE_OE_HISTORY_WITH_STATUS('0c');

#if 0
  __RETRY_FINISH_ROUTINE__:
    if ( AsyncEngineContext->FinishRoutine != NULL ) {
        if ( Status == (STATUS_MORE_PROCESSING_REQUIRED) ){
            AsyncEngineContext->Status = (STATUS_SUCCESS);
        }
        Status = AsyncEngineContext->FinishRoutine( AsyncEngineContext );
        UPDATE_OE_HISTORY_WITH_STATUS('1c');
        AsyncEngineContext->Status = Status;
        AsyncEngineContext->FinishRoutine = NULL;

    } else if ( Status == (STATUS_MORE_PROCESSING_REQUIRED) ) {

        NOTHING;   //it used to call the receive routine here

        // after calling the receive routine again, we may NOW have a finish routine!
        if ( AsyncEngineContext->FinishRoutine != NULL ) {
            goto __RETRY_FINISH_ROUTINE__;
        }
    } else {
        NOTHING;
    }
#endif //0

    if (PostedResume) {

        Status = AsyncEngineContext->Continuation( MRXPROXY_ASYNCENGINE_ARGUMENTS );
        UPDATE_OE_HISTORY_WITH_STATUS('3c');

    }

    //remove my references, if i'm the last guy then do the putaway...
    UPDATE_OE_HISTORY_WITH_STATUS('4c');
    MRxProxyFinalizeAsyncEngineContext(AsyncEngineContext);

    RxDbgTrace(-1, Dbg, ("MRxProxyResumeAsyncEngineContext returning %08lx.\n", Status));
    return(Status);

} // MRxProxyAsyncEngContinueAsyncEngineContext



NTSTATUS
MRxProxySubmitAsyncEngRequest(
    MRXPROXY_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN     MRXPROXY_ASYNCENGINE_CONTEXT_TYPE AECTXType
    )
/*++

Routine Description:

   This routine implements an ordinary exchange as viewed by the protocol
   selection routines.

Arguments:

    AsyncEngineContext  - the exchange to be conducted.
    AECTXType            - async engine context submit Type

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;
    RxCaptureFcb;RxCaptureFobx;

    PMRXPROXY_RX_CONTEXT pMRxProxyAsyncEngineContext = MRxProxyGetMinirdrContext(RxContext);
    //PMRXPROXY_ASYNCENG_CONTINUE_ROUTINE Continuation;
    BOOLEAN AsyncOperation = FlagOn(AsyncEngineContext->Flags,MRXPROXY_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);

    PIRP TopIrp;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(SrvOpen);

    RxDbgTrace(+1, Dbg, ("MRxProxyAsyncEngSubmitRequest entering.......OE=%08lx\n",AsyncEngineContext));

    MRxProxyAsyncEngOEAssertConsistentLinkageFromOE("MRxProxyAsyncEngSubmitRequest:");

    AsyncEngineContext->AECTXType = AECTXType;
    KeInitializeEvent( &RxContext->SyncEvent,
                       NotificationEvent,
                       FALSE );

    MRxProxyReferenceAsyncEngineContext( AsyncEngineContext );  //this one is taken away in Continue
    MRxProxyReferenceAsyncEngineContext( AsyncEngineContext );  //this one is taken away below...
                                                                //i must NOT finalize before InnerIo returns
    IF_DEBUG {
        //if ( ((AsyncEngineContext->AECTXType == MRXPROXY_ASYNCENG_AECTXTYPE_WRITE)
        //                          || (AsyncEngineContext->AECTXType == MRXPROXY_ASYNCENG_AECTXTYPE_READ)
        //                          || (AsyncEngineContext->AECTXType == MRXPROXY_ASYNCENG_AECTXTYPE_LOCKS))
        //     && BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)
        //   ) {
        //    ASSERT(AsyncOperation);
        //}
    }

    MRxProxyAsyncEngOEAssertConsistentLinkage("just before transceive: ");

    UPDATE_OE_HISTORY_2SHORTS('eo',AsyncOperation?'!!':0);
    DbgDoit( InterlockedIncrement(&AsyncEngineContext->History.Submits); )

    IF_DEBUG {
        PIO_STACK_LOCATION IrpSp;
        IrpSp = IoGetNextIrpStackLocation( AsyncEngineContext->CalldownIrp );  //ok4ioget
        RxLog(("SAsyIrpX %lx %lx %lx %lx %lx %lx %lx",
                            RxContext,
                            IrpSp->MajorFunction,
                            IrpSp->Flags,
                            IrpSp->Parameters.Others.Argument1,
                            IrpSp->Parameters.Others.Argument2,
                            IrpSp->Parameters.Others.Argument3,
                            IrpSp->Parameters.Others.Argument4));
    }

    try {
        TopIrp = IoGetTopLevelIrp();
        IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear
        Status = IoCallDriver(
                     proxySrvOpen->UnderlyingDeviceObject,
                     AsyncEngineContext->CalldownIrp
                     );
    } finally {
        IoSetTopLevelIrp(TopIrp); //restore my context for unwind
    }

    RxDbgTrace (0, Dbg, ("  -->Status after transceive %08lx(%08lx)\n",Status,RxContext));

    if (Status != (STATUS_PENDING)) {
        ASSERT(Status == AsyncEngineContext->CalldownIrp->IoStatus.Status);
        Status = STATUS_PENDING;
    }


    MRxProxyFinalizeAsyncEngineContext(AsyncEngineContext);  //okay to finalize now that we're back

    if ( Status == (STATUS_PENDING) ) {
        if ( AsyncOperation ) {
            goto FINALLY;
        }

        UPDATE_OE_HISTORY_WITH_STATUS('1o');
        RxWaitSync( RxContext );
    } else {
        RxDbgTrace (0, Dbg, ("  -->Status after transceive %08lx\n",Status));
        MRxProxyAsyncEngOEAssertConsistentLinkage("nonpending return from transceive: ");
        // if it's an error, remove the references that i placed and get out
        if (NT_ERROR(Status)) {
            MRxProxyFinalizeAsyncEngineContext(AsyncEngineContext);
            goto FINALLY;
        }
    }

    //at last, call the continuation........

    MRxProxyAsyncEngOEAssertConsistentLinkage("just before continueOE: ");
    Status = MRxProxyResumeAsyncEngineContext( RxContext );
    UPDATE_OE_HISTORY_WITH_STATUS('9o');

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxProxyAsyncEngSubmitRequest returning %08lx.\n", Status));
    return(Status);

} // MRxProxyAsyncEngSubmitRequest



//#define MRXSMB_TEST_MUST_SUCCEED
#ifdef MRXSMB_TEST_MUST_SUCCEED
ULONG MRxProxyAllocatedMustSucceedExchange;
ULONG MRxProxyAllocatedMustSucceedSmbBuf;
#define MSFAILPAT ((0x3f)<<2)
#define FAIL_XXX_ALLOCATE() (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED) \
                                    &&((RxContext->SerialNumber&MSFAILPAT)==MSFAILPAT) \
                                    &&((MRxProxyEntryPointIsMustSucceedable[EntryPoint])) )
#define FAIL_EXCHANGE_ALLOCATE() ( FAIL_XXX_ALLOCATE() && (RxContext->SerialNumber&2) )
#define FAIL_SMBBUF_ALLOCATE()   ( FAIL_XXX_ALLOCATE() && (RxContext->SerialNumber&1) )
#define COUNT_MUST_SUCCEED_EXCHANGE_ALLOCATED() {MRxProxyAllocatedMustSucceedExchange++;}
#define COUNT_MUST_SUCCEED_SMBBUF_ALLOCATED() {MRxProxyAllocatedMustSucceedSmbBuf++;}
#define MUST_SUCCEED_ASSERT(x) {ASSERT(x);}
#else
#define FAIL_EXCHANGE_ALLOCATE() (FALSE)
#define FAIL_SMBBUF_ALLOCATE()   (FALSE)
#define COUNT_MUST_SUCCEED_EXCHANGE_ALLOCATED() {NOTHING;}
#define COUNT_MUST_SUCCEED_SMBBUF_ALLOCATED() {NOTHING;}
#define MUST_SUCCEED_ASSERT(x) {NOTHING;}
#endif

PMRXPROXY_ASYNCENGINE_CONTEXT
MRxProxyCreateAsyncEngineContext (
    IN PRX_CONTEXT RxContext,
    IN MRXPROXY_ASYNCENGINE_CONTEXT_ENTRYPOINTS EntryPoint
    )
/*++

Routine Description:

   This routine allocates and initializes an SMB header buffer. Currently,
   we just allocate them from pool except when must_succeed is specified.

Arguments:

    RxContext       - the RDBSS context
    VNetRoot        -
    DispatchVector  -

Return Value:

    A buffer ready to go, OR NULL.

Notes:



--*/
{
    PMRXPROXY_RX_CONTEXT pMRxProxyAsyncEngineContext = MRxProxyGetMinirdrContext(RxContext);
    PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    PMRXPROXY_ASYNCENG_MUST_SUCCEEED_CONTEXT MustSucceedAsyncEngineContext = NULL;
    //NTSTATUS Status;
    RxCaptureFobx;


    RxDbgTrace( +1, Dbg, ("MRxProxyCreateAsyncEngineContext\n") );

    //DbgBreakPoint();

    if (!FAIL_EXCHANGE_ALLOCATE()) {
        AsyncEngineContext = (PMRXPROXY_ASYNCENGINE_CONTEXT)RxAllocatePoolWithTag(
                                   NonPagedPool,
                                   sizeof(MRXPROXY_ASYNCENGINE_CONTEXT),
                                   MRXPROXY_ASYNCENGINECONTEXT_POOLTAG );
    }

    if ( AsyncEngineContext == NULL ) {
        //ASSERT(!"must-succeed");
        if (TRUE
               || !FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED)
               || !MRxProxyEntryPointIsMustSucceedable[EntryPoint]) {
            RxDbgTrace( 0, Dbg, ("  --> Couldn't get the asyncengcontext!\n") );
            return NULL;
        }
    //    MustSucceedAsyncEngineContext = RxAcquireMustSucceedStructure(&MRxProxyAsyncEngMustSucceedDescriptor[MRxProxyAsyncEngMustSucceed]);
    //    COUNT_MUST_SUCCEED_EXCHANGE_ALLOCATED();
    //    AsyncEngineContext = (PMRXPROXY_ASYNCENGINE_CONTEXT)SmbMmAllocateExchange(ORDINARY_EXCHANGE,
    //                                                                         &MustSucceedAsyncEngineContext->ExchangeListEntry);
    //    SetFlag( AsyncEngineContext->Flags, MRXPROXY_ASYNCENG_CTX_FLAG_MUST_SUCCEED_ALLOCATED_OE );
    }

    ZeroAndInitializeNodeType( AsyncEngineContext,
                               PROXY_NTC_ASYNCENGINE_CONTEXT,
                               sizeof(MRXPROXY_ASYNCENGINE_CONTEXT));
    InterlockedIncrement( &AsyncEngineContext->NodeReferenceCount );

    DbgDoit(AsyncEngineContext->SerialNumber = RxContext->SerialNumber);

    //place a reference on the rxcontext until we are finished
    InterlockedIncrement( &RxContext->ReferenceCount );

    AsyncEngineContext->RxContext = RxContext;
    AsyncEngineContext->EntryPoint = EntryPoint;

    DbgDoit(AsyncEngineContext->RxContextCapturedRequestPacket = RxContext->CurrentIrp;);

    pMRxProxyAsyncEngineContext->AsyncEngineContext     = AsyncEngineContext;


    RxDbgTrace( -1, Dbg, ("  --> exiting w!\n") );
    return(AsyncEngineContext);


//UNWIND:
//    //RxDbgTraceUnIndent(-1, Dbg);
//    RxDbgTrace( -1, Dbg, ("  --> exiting w/o!\n") );
//    MUST_SUCCEED_ASSERT(!"Finalizing on the way out");
//    MRxProxyAsyncEngFinalizeAsyncEngineContext( AsyncEngineContext );
//    return(NULL);

}



#if DBG
ULONG MRxProxyFinalizeAECtxTraceLevel = 1200;
#define FINALIZESS_LEVEL MRxProxyFinalizeAECtxTraceLevel
#define FINALIZE_TRACKING_SETUP() \
    struct {                    \
        ULONG marker1;          \
        ULONG finalstate;       \
        ULONG marker2;          \
    } Tracking = {'ereh',0,'ereh'};
#define FINALIZE_TRACKING(x) {\
    Tracking.finalstate |= x; \
    }

#define FINALIZE_TRACE(x) MRxProxyAsyncEngFinalizeAECtxTrace(x,Tracking.finalstate)
VOID
MRxProxyAsyncEngFinalizeAECtxTrace(PSZ text,ULONG finalstate)
{
    RxDbgTraceLV(0, Dbg, FINALIZESS_LEVEL,
                   ("MRxProxyFinalizeAsyncEngineContext  --> %s(%08lx)\n",text,finalstate));
}
#else
#define FINALIZE_TRACKING_SETUP()
#define FINALIZE_TRACKING(x)
#define FINALIZE_TRACE(x)
#endif

BOOLEAN
MRxProxyFinalizeAsyncEngineContext (
    IN OUT PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext
    )
/*++

Routine Description:

    This finalizes an OE.

Arguments:

    AsyncEngineContext - pointer to the OE to be dismantled.

Return Value:

    TRUE if finalization occurs otherwise FALSE.

Notes:



--*/
{
    LONG result;
    PIRP irp;
    ULONG AsyncEngineContextFlags = AsyncEngineContext->Flags;
    ULONG ThisIsMustSucceedAllocated =
              AsyncEngineContextFlags & (MRXPROXY_ASYNCENG_CTX_FLAG_MUST_SUCCEED_ALLOCATED);
    FINALIZE_TRACKING_SETUP()

    MRxProxyAsyncEngOEAssertConsistentLinkageFromOEwithFlags("MRxProxyAsyncEngFinalizeAsyncEngineContext:",OECHKLINKAGE_FLAG_NO_REQPCKT_CHECK);

    RxDbgTraceLV(+1, Dbg, 1000, ("MRxProxyFinalizeAsyncEngineContext\n"));

    result =  InterlockedDecrement(&AsyncEngineContext->NodeReferenceCount);
    if ( result != 0 ) {
        RxDbgTraceLV(-1, Dbg, 1000, ("MRxProxyFinalizeAsyncEngineContext -- returning w/o finalizing (%d)\n",result));
        return FALSE;
    }

    RxLog((">>>OE %lx %lx",
            AsyncEngineContext,
            AsyncEngineContext->Flags));

    FINALIZE_TRACKING( 0x1 );

    if ( (irp =AsyncEngineContext->CalldownIrp) != NULL ) {
        if (irp->MdlAddress) {
            IoFreeMdl(irp->MdlAddress);
        }
        IoFreeIrp( irp );
        FINALIZE_TRACKING( 0x20 );
    }

    if ( AsyncEngineContext->RxContext != NULL ) {
        PMRXPROXY_RX_CONTEXT pMRxProxyAsyncEngineContext = MRxProxyGetMinirdrContext(AsyncEngineContext->RxContext);
        ASSERT( pMRxProxyAsyncEngineContext->AsyncEngineContext == AsyncEngineContext );

        //get rid of the reference on the RxContext....if i'm the last guy this will finalize
        RxDereferenceAndDeleteRxContext( AsyncEngineContext->RxContext );
        FINALIZE_TRACKING( 0x600 );
    } else {
        FINALIZE_TRACKING( 0xf00 );
    }

    FINALIZE_TRACE("ready to discard exchange");
    RxFreePool(AsyncEngineContext);
    FINALIZE_TRACKING( 0x3000 );

    if (ThisIsMustSucceedAllocated) {
        //RxReleaseMustSucceedStructure(&MRxProxyAsyncEngMustSucceedDescriptor[MRxProxyAsyncEngMustSucceed]);
    }


    FINALIZE_TRACKING( 0x40000 );
    RxDbgTraceLV(-1, Dbg, 1000, ("MRxProxyFinalizeAsyncEngineContext  --> exit finalstate=%x\n",Tracking.finalstate));
    return(TRUE);

} // MRxProxyFinalizeAsyncEngineContext


NTSTATUS
MRxProxyAsyncEngineCalldownIrpCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the calldownirp is completed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context

Return Value:

    RXSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PRX_CONTEXT RxContext = Context;
    PMRXPROXY_RX_CONTEXT pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);
    PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext = pMRxProxyContext->AsyncEngineContext;
    BOOLEAN AsyncOperation = FlagOn(AsyncEngineContext->Flags,MRXPROXY_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);

    UPDATE_OE_HISTORY_WITH_STATUS('ff');
    MRxProxyAsyncEngOEAssertConsistentLinkage("MRxProxyCalldownCompletion: ");

    AsyncEngineContext->IoStatusBlock = CalldownIrp->IoStatus;

    if (AsyncOperation) {
        NTSTATUS PostStatus;
        RxDbgTraceLV(0, Dbg, 1000, ("Resume with post-to-async\n"));

        SetFlag(AsyncEngineContext->Flags,MRXPROXY_ASYNCENG_CTX_FLAG_AWAITING_DISPATCH);
        SetFlag(AsyncEngineContext->Flags,MRXPROXY_ASYNCENG_CTX_FLAG_POSTED_RESUME);
        IF_DEBUG {
            //fill the workqueue structure with deadbeef....all the better to diagnose
            //a failed post
            ULONG i;
            for (i=0;i+sizeof(ULONG)-1<sizeof(AsyncEngineContext->WorkQueueItem);i+=sizeof(ULONG)) {
                //*((PULONG)(((PBYTE)&AsyncEngineContext->WorkQueueItem)+i)) = 0xdeadbeef;
                PBYTE BytePtr = ((PBYTE)&AsyncEngineContext->WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }
        PostStatus = RxPostToWorkerThread(&MRxProxyDeviceObject->RxDeviceObject,
                                          CriticalWorkQueue,
                                          &AsyncEngineContext->WorkQueueItem,
                                          MRxProxyResumeAsyncEngineContext,
                                          RxContext);
        ASSERT(PostStatus == STATUS_SUCCESS);
    } else {
        RxDbgTraceLV(0, Dbg, 1000, ("sync resume\n"));
        RxSignalSynchronousWaiter(RxContext);
    }

    return((STATUS_MORE_PROCESSING_REQUIRED));
}

#if DBG
#define DEBUG_ONLY_CODE(x) x
#else
#define DEBUG_ONLY_CODE(x)
#endif
NTSTATUS
__MRxProxyAsyncEngineOuterWrapper (
    IN PRX_CONTEXT RxContext,
    IN MRXPROXY_ASYNCENGINE_CONTEXT_ENTRYPOINTS EntryPoint,
    IN PMRXPROXY_ASYNCENG_CONTINUE_ROUTINE Continuation
#if DBG
   ,IN PSZ RoutineName,
    IN BOOLEAN LoudProcessing,
    IN BOOLEAN StopOnLoud
#endif
    )
/*++

Routine Description:

   This routine is common to guys who use the async context engine. it has the
   responsibility for getting a context, initing, starting, finalizing but the
   internal guts of the procesing is via the continuation routine that is passed in.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;
    PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext;

    PAGED_CODE();

    DEBUG_ONLY_CODE(
        RxDbgTrace(+1, Dbg, ("Wrapped%s %08lx\n", RoutineName, RxContext ))
        );

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    AsyncEngineContext = MRxProxyCreateAsyncEngineContext(
                             RxContext,
                             EntryPoint);

    if (AsyncEngineContext==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the AsyncEngineContext!\n"));
        return((STATUS_INSUFFICIENT_RESOURCES));
    }

    AsyncEngineContext->Continuation = Continuation;
    Status = Continuation(MRXPROXY_ASYNCENGINE_ARGUMENTS);

    if (Status!=(STATUS_PENDING)) {
        BOOLEAN FinalizationComplete;
        DEBUG_ONLY_CODE(
            if (LoudProcessing) {
                if ((Status!=STATUS_SUCCESS) && (RxContext->LoudCompletionString)) {
                    DbgPrint("LoudFailure %08lx on %wZ\n",Status,RxContext->LoudCompletionString);
                    if (StopOnLoud) {
                        DbgBreakPoint();
                    }
                }
            }
            )
        FinalizationComplete = MRxProxyFinalizeAsyncEngineContext(AsyncEngineContext);
        ASSERT(FinalizationComplete);
    } else {
        ASSERT(BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
    }

    DEBUG_ONLY_CODE(
        RxDbgTrace(+1, Dbg, ("Wrapped%s %08lx exit with status=%08lx\n", RoutineName, RxContext, Status ))
        );
    return(Status);

} // MRxProxyQueryDir



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\devfcb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    devfcb.c

Abstract:

    This module implements all the passthru stuff from the wrapper. currently there is only one such
    functions:
         statistics


Revision History:

    Balan Sethu Raman     [SethuR]    16-July-1995

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "fsctlbuf.h"

//
//  The local trace mask for this part of the module
//

#define Dbg (DEBUG_TRACE_DEVFCB)


typedef enum _MRXPROXY_STATE_ {
   MRXPROXY_STARTABLE,
   MRXPROXY_START_IN_PROGRESS,
   MRXPROXY_STARTED
} MRXPROXY_STATE,*PMRXPROXY_STATE;

MRXPROXY_STATE MRxProxyState = MRXPROXY_STARTABLE;

NTSTATUS
MRxProxyTestDevIoctl(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyExternalStart (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxySetupClaimedServerList(
    IN PRX_CONTEXT RxContext
    );

VOID
MRxProxyDereferenceClaimedServers(void);

NTSTATUS
MRxProxyDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles all the device FCB related FSCTL's in the mini rdr

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    RxStatus(SUCCESS) -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    UCHAR MajorFunctionCode  = RxContext->MajorFunction;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG ControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;

    RxDbgTrace(+1, Dbg, ("MRxProxyDevFcb\n"));
    switch (MajorFunctionCode) {
    case IRP_MJ_FILE_SYSTEM_CONTROL: {

        switch (LowIoContext->ParamsFor.FsCtl.MinorFunction) {
        case IRP_MN_USER_FS_REQUEST:
            switch (ControlCode) {

            case FSCTL_PROXY_START:
                ASSERT (!capFobx);
                Status = MRxProxyExternalStart( RxContext );
                break;

            case FSCTL_PROXY_STOP:
                ASSERT (!capFobx);
                MRxProxyDereferenceClaimedServers();
                Status = RxStopMinirdr( RxContext, &RxContext->PostRequest );
                break;

            default:
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;
        default :  //minor function != IRP_MN_USER_FS_REQUEST
            Status = STATUS_INVALID_DEVICE_REQUEST;
        } // end of switch
        } // end of FSCTL case
        break;
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL: {
        switch (ControlCode) {
#if DBG
        case IOCTL_LMMR_TEST:
            Status = MRxProxyTestDevIoctl(RxContext);
            break;
#endif //if DBG

        default :
            Status = STATUS_INVALID_DEVICE_REQUEST;
        } // end of switch
        } //end of IOCTL cases
        break;
    default:
        ASSERT(!"unimplemented major function");
        Status = STATUS_INVALID_DEVICE_REQUEST;

    }

    RxDbgTrace(-1, Dbg, ("MRxProxyDevFcb st,info=%08lx,%08lx\n",
                            Status,RxContext->InformationToReturn));
    return(Status);

}

#if DBG
NTSTATUS
MRxProxyTestDevIoctl(
    IN PRX_CONTEXT RxContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PSZ InputString = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PSZ OutputString = LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    ULONG i;

    //BUGBUG because this is a method neither, the buffers have not been probed. since this is debug
    //only i am foregoing that currently. when we do more here...we'll have to probe.

    RxDbgTrace(0, Dbg,("MRxProxyTestDevIoctl %s, obl = %08lx\n",InputString, OutputBufferLength));
    RxContext->InformationToReturn = (InputBufferLength-1)*(InputBufferLength-1);

    for (i=0;i<InputBufferLength;i++) {
        UCHAR c = InputString[i];
        if (c==0) { break; }
        OutputString[i] = c;
        if ((i&3)==2) {
            OutputString[i] = '@';
        }
    }
    OutputString[i] = 0;

    return(Status);
}
#endif //if DBG


NTSTATUS
MRxProxyExternalStart (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine starts up the proxy minirdr if it hasn't been started already.

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

--*/
{
    NTSTATUS      Status;
    BOOLEAN       InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PAGED_CODE();

    //DbgBreakPoint();

    RxDbgTrace(0, Dbg, ("MRxProxyExternalStart [Start] -> %08lx\n", 0));

    Status = RxStartMinirdr( RxContext, &RxContext->PostRequest );
    if (Status == STATUS_SUCCESS) {
       MRXPROXY_STATE State;

       MRxProxySetupClaimedServerList(RxContext);

       State = (MRXPROXY_STATE)InterlockedCompareExchange(
                                 (PVOID *)&MRxProxyState,
                                 (PVOID)MRXPROXY_STARTED,
                                 (PVOID)MRXPROXY_START_IN_PROGRESS);


       if (State != MRXPROXY_START_IN_PROGRESS) {
          Status = STATUS_REDIRECTOR_STARTED;
       }
    }

    return Status;
}

//CODE.IMPROVEMENT we should get this from the registry........
struct {
    PWCHAR ServerName;
    PSRV_CALL SrvCall;
    ULONG  Flags;
} MRxProxyClaimedServerList[] =
         {
           {MRXPROXY_CLAIMED_SERVERNAME_U,NULL,0},
           NULL
         };

NTSTATUS
MRxProxySetupClaimedServerList(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine claims servers for this module.
Arguments:

    none

Return Value:

    RXSTATUS - could return an error if an allocation fails or something

--*/
{
    ULONG i;

    PAGED_CODE();

    RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE);

    try {
        for (i=0;MRxProxyClaimedServerList[i].ServerName!=NULL;i++) {
            PWCHAR ServerNameText = MRxProxyClaimedServerList[i].ServerName;
            ULONG  Flags = MRxProxyClaimedServerList[i].Flags;
            UNICODE_STRING SrvCallName,UnmatchedName;
            PVOID Container = NULL;
            PSRV_CALL SrvCall;

            RtlInitUnicodeString(&SrvCallName,ServerNameText);
            DbgPrint("CLAIMEDSERVER %wZ %08lx\n",&SrvCallName,Flags);
            Container = RxPrefixTableLookupName( &RxNetNameTable, &SrvCallName, &UnmatchedName );
            if (Container!=NULL) {
                ASSERT ( NodeType(Container) == RDBSS_NTC_SRVCALL);
                SrvCall = (PSRV_CALL)Container;
                //this leaves a reference!
            } else {
                //here we have to create the srvcall
                SrvCall = RxCreateSrvCall(RxContext,&SrvCallName,NULL);
                if (SrvCall == NULL) {
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
                RxReferenceSrvCall(SrvCall);
                //leave this reference
            }

            SrvCall->Flags |= Flags;
            SrvCall->RxDeviceObject = &MRxProxyDeviceObject->RxDeviceObject;
            if (FlagOn(SrvCall->Flags,SRVCALL_FLAG_NO_CONNECTION_ALLOWED)) {
                SrvCall->Condition = Condition_Bad;
            } else {
                SrvCall->Condition = Condition_Good;
            }
            MRxProxyClaimedServerList[i].SrvCall = SrvCall; //remember this for later

        }
    } finally {

        RxReleasePrefixTableLock( &RxNetNameTable );

    }

    return(STATUS_SUCCESS);
}

VOID
MRxProxyDereferenceClaimedServers(
    void
    )
/*++

Routine Description:

    This routine tears down the list of claimed servers.
    it does this by just removing a reference; this will make the servers
    eligible for finalization in finalizenettable.

Arguments:

    none

Return Value:

    none


--*/
{
    ULONG i;
    LOCK_HOLDING_STATE LockHoldingState = LHS_LockNotHeld;

    PAGED_CODE();

    for (i=0;MRxProxyClaimedServerList[i].ServerName!=NULL;i++) {
        PSRV_CALL SrvCall = MRxProxyClaimedServerList[i].SrvCall;

        if (SrvCall != NULL) {
            DbgPrint("Claimed Srvcall deref %wZ\n",&SrvCall->PrefixEntry.Prefix);
            MRxProxyClaimedServerList[i].SrvCall = NULL;
            RxDereferenceSrvCall(SrvCall,LockHoldingState);
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\fsctl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the mini redirector call down routines pertaining to
    file system control(FSCTL) and Io Device Control (IOCTL) operations on file system objects.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <dfsfsctl.h>

//
//  The local debug trace level
//


RXDT_DefineCategory(FSCTRL);
#define Dbg (DEBUG_TRACE_FSCTRL)

NTSTATUS
MRxProxyFsCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an FSCTL operation (remote) on a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The FSCTL's handled by a mini rdr can be classified into one of two categories. In the
    first category are those FSCTL's whose implementation are shared between RDBSS and the
    mini rdr's and in the second category are those FSCTL's which are totally implemented
    by the mini rdr's. To this a third category can be added, i.e., those FSCTL's which
    should never be seen by the mini rdr's. The third category is solely intended as a
    debugging aid.

    The FSCTL's handled by a mini rdr can be classified based on functionality

--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

    RxDbgTrace(+1, Dbg, ("MRxProxyFsCtl...\n", 0));
    RxDbgTrace( 0, Dbg, ("MRxProxyFsCtl = %08lx\n", FsControlCode));

    switch (pLowIoContext->ParamsFor.FsCtl.MinorFunction) {
    case IRP_MN_USER_FS_REQUEST:
        switch (FsControlCode) {
        case FSCTL_PIPE_ASSIGN_EVENT         :
        case FSCTL_PIPE_DISCONNECT           :
        case FSCTL_PIPE_LISTEN               :
        case FSCTL_PIPE_PEEK                 :
        case FSCTL_PIPE_QUERY_EVENT          :
        case FSCTL_PIPE_TRANSCEIVE           :
        case FSCTL_PIPE_WAIT                 :
        case FSCTL_PIPE_IMPERSONATE          :
        case FSCTL_PIPE_SET_CLIENT_PROCESS   :
        case FSCTL_PIPE_QUERY_CLIENT_PROCESS :
        case FSCTL_MAILSLOT_PEEK :
        case FSCTL_DFS_GET_REFERRALS:
        case FSCTL_DFS_REPORT_INCONSISTENCY:
        case FSCTL_LMR_TRANSACT :
        default:
            // Status = MRxProxyFsControl(RxContext);
            // Temporarily stubbed out till the buffer passing strategy has been
            // finalized.
            Status = STATUS_NOT_IMPLEMENTED;
            break;
        }
        break;
    default :
        break;
    }

    RxDbgTrace(-1, Dbg, ("MRxProxyFsCtl -> %08lx\n", Status ));
    return Status;
}

typedef struct _PROXY_NOTIFY_CHANGE_DIRECTORY_CONTEXT_ {
   PRX_CONTEXT                         pRxContext;
   //REQ_NOTIFY_CHANGE                   NotifyRequest;
   //PROXY_TRANSACTION_OPTIONS             Options;
   //PROXY_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
} PROXY_NOTIFY_CHANGE_DIRECTORY_CONTEXT, *PPROXY_NOTIFY_CHANGE_DIRECTORY_CONTEXT;

VOID
MRxProxyNotifyChangeDirectoryCompletion(
   PPROXY_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext)
/*++

Routine Description:

   This routine is invokde when a directory change notification operation is completed

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine will always be called. This is true even if the change directory
    notification is cancelled. In such cases the memory allocated is freed without
    any inteaction with the wrapped. In cases os successful directory change
    notification completion the appropriate completion routine is invoked and the
    RxContext modified to prevent any cancellation from proceeding further.

--*/
{
    NTSTATUS           Status;
    PRX_CONTEXT        pRxContext;
    PMRXPROXY_RX_CONTEXT pMRxProxyContext;
    //PPROXY_EXCHANGE      pExchange = NULL;

    ProxyAcquireGlobalSpinLock();

    pRxContext     = pNotificationContext->pRxContext;

    if (pRxContext != NULL) {
        // This is a case of successful completion of the change directory
        // notification, i.e., the request was not cancelled. In such cases
        // prevent all race conditions by modifying the RxContext under lock
        // to turn back cancellation request.

        pMRxProxyContext = MRxProxyGetMinirdrContext(pRxContext);
        //pExchange      = pMRxProxyContext->pExchange;

        pMRxProxyContext->pCancelContext   = NULL;
        pNotificationContext->pRxContext = NULL;
    }

    ProxyReleaseGlobalSpinLock();

    // Complete the Context if it was not previously cancelled
    if (pRxContext != NULL) {
        //PPROXY_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext;

        //pResumptionContext  = &(pNotificationContext->ResumptionContext);

        //pRxContext->StoredStatus = pResumptionContext->FinalStatusFromServer;

        Status = RxSetMinirdrCancelRoutine(pRxContext,NULL);
        if (Status == STATUS_SUCCESS) {
            RxLowIoCompletion(pRxContext);
        }
    }

#if 0
    // Free the associated exchange.
    if (pExchange != NULL) {
        ProxyCeDereferenceAndDiscardExchange(pExchange);
    }
#endif //0

    // Free the notification context.
    RxFreePool(pNotificationContext);
}

NTSTATUS
MRxProxyNotifyChangeDirectoryCancellation(
   PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine is invokde when a directory change notification operation is cancelled.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    //NTSTATUS Status;

    BOOLEAN ChangeDirectoryNotificationCompleted;

    PMRXPROXY_RX_CONTEXT pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);
    //PPROXY_EXCHANGE      pExchange;

    PPROXY_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext;

    ProxyAcquireGlobalSpinLock();

    pNotificationContext = (PPROXY_NOTIFY_CHANGE_DIRECTORY_CONTEXT)pMRxProxyContext->pCancelContext;
    ChangeDirectoryNotificationCompleted = (pNotificationContext == NULL);

    if (!ChangeDirectoryNotificationCompleted) {
        // This is a case of successful cancellation of the change directory
        // notification. In such cases prevent all race conditions by modifying
        // the RxContext under lock to prevent successful completion

        pNotificationContext->pRxContext = NULL;
        //pExchange                        = pMRxProxyContext->pExchange;

        pMRxProxyContext->pCancelContext   = NULL;
    }

    ProxyReleaseGlobalSpinLock();

    if (ChangeDirectoryNotificationCompleted) {
        // The cancellation is trivial since the request has already been completed
        return STATUS_SUCCESS;
    }
#if 0  //can't do any of this....no exchanges.........
    if (pExchange != NULL) {
        UCHAR  LastCommandInHeader;
        PUCHAR pCommand;

        BYTE  CancelRequestBuffer[sizeof(PROXY_HEADER) + sizeof(REQ_NT_CANCEL)];
        ULONG CancelRequestBufferSize = sizeof(CancelRequestBuffer);

        // Build the Cancel request and send it across to the server.
        Status = ProxyCeBuildProxyHeader(
                     pExchange,
                     CancelRequestBuffer,
                     CancelRequestBufferSize,
                     &CancelRequestBufferSize,
                     &LastCommandInHeader,
                     &pCommand);

        ASSERT(LastCommandInHeader == PROXY_COM_NO_ANDX_COMMAND);

        *pCommand = PROXY_COM_NT_CANCEL;

        if (Status == RX_MAP_STATUS(SUCCESS)) {
            PREQ_NT_CANCEL pCancelRequest = (PREQ_NT_CANCEL)(&CancelRequestBuffer[sizeof(PROXY_HEADER)]);
            PMDL     pCancelProxyMdl;

            ProxyPutUshort(&pCancelRequest->WordCount,0);
            pCancelRequest->ByteCount = 0;
            CancelRequestBufferSize   = sizeof(CancelRequestBuffer);

            pCancelProxyMdl = RxAllocateMdl(CancelRequestBuffer,CancelRequestBufferSize);
            if (pCancelProxyMdl != NULL) {
                RxProbeAndLockPages(pCancelProxyMdl,KernelMode,IoModifyAccess,Status);

                if (Status == STATUS_SUCCESS) {
                    Status = ProxyCeSend(
                                 pExchange,
                                 RXCE_SEND_SYNCHRONOUS,
                                 pCancelProxyMdl,
                                 CancelRequestBufferSize);

                    MmUnlockPages(pCancelProxyMdl);
                }

                IoFreeMdl(pCancelProxyMdl);
            }
        }

        ProxyCeDereferenceAndDiscardExchange(pExchange);
    }
#endif //0

    // Complete the request.
    RxContext->StoredStatus = STATUS_CANCELLED;

    RxLowIoCompletion(RxContext);

    return STATUS_SUCCESS;
}

NTSTATUS
MRxProxyNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs a directory change notification operation

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

THIS STUFF IS WRONG!!!!!
    A directory change notification opertaion is an asychronous operation. It
    consists of sending a PROXY requesting change notification whose response is
    obtained when the desired change is affected on the server.

    Some important points to remember are as follows .....

      1) The PROXY response is not obtained till the desired change is affected on
      the server. Therefore an additional MID needs to be reserved on those
      connections which permit multiple MID's so that a cancel PROXY can be sent to
      the server when a change notification is active.

      2) The Change notification is typical of a long term ( response time
      dictated by factors beyond the servers control). Another example is
      the query FSCTL operation in CAIRO. For all these operations we initiate
      an asychronous transact exchange.

      3) The corresponding LowIo completion routine is invoked asynchronously.

      4) This is an example of an operation for which the MINI RDR has to
      register a context for handling cancellations initiated locally.

--*/
{
   NTSTATUS Status;
   RxCaptureFcb;
   PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;

   //PPROXYCEDB_SERVER_ENTRY pServerEntry;
   //PPROXY_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext;

#if 0
   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;
#endif //0

   RxDbgTrace(+1, Dbg, ("MRxNotifyChangeDirectory...Entry\n", 0));

   //pServerEntry = ProxyCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
   //if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_PROXYS)) {
   //    return STATUS_NOT_SUPPORTED;
   //}

#if 0
   pNotificationContext =
         (PPROXY_NOTIFY_CHANGE_DIRECTORY_CONTEXT)
         RxAllocatePoolWithTag(
            NonPagedPool,
            sizeof(PROXY_NOTIFY_CHANGE_DIRECTORY_CONTEXT),
            MRXPROXY_FSCTL_POOLTAG);

   if (pNotificationContext != NULL) {
      PREQ_NOTIFY_CHANGE                  pNotifyRequest;
      PPROXY_TRANSACTION_OPTIONS            pTransactionOptions;
      PPROXY_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext;
      PMRX_PROXY_SRV_OPEN                   pProxySrvOpen;

      RxCaptureFobx;
      ASSERT (capFobx != NULL);

      Status = MRxProxyDeferredCreate(RxContext);

      if (Status==STATUS_SUCCESS) {

          pProxySrvOpen = MRxProxyGetSrvOpenExtension(capFobx->pSrvOpen);

          ASSERT (!FlagOn(pProxySrvOpen->Flags,PROXY_SRVOPEN_FLAG_NOT_REALLY_OPEN));
          pNotificationContext->pRxContext = RxContext;

          pNotifyRequest      = &(pNotificationContext->NotifyRequest);
          pTransactionOptions = &(pNotificationContext->Options);
          pResumptionContext  = &(pNotificationContext->ResumptionContext);

          pNotifyRequest->CompletionFilter = pLowIoContext->ParamsFor.NotifyChangeDirectory.CompletionFilter;
          pNotifyRequest->Fid              = pProxySrvOpen->Fid;
          pNotifyRequest->WatchTree        = pLowIoContext->ParamsFor.NotifyChangeDirectory.WatchTree;
          pNotifyRequest->Reserved         = 0;

          OutputDataBufferLength  = pLowIoContext->ParamsFor.NotifyChangeDirectory.NotificationBufferLength;
          pOutputDataBuffer       = pLowIoContext->ParamsFor.NotifyChangeDirectory.pNotificationBuffer;

          *pTransactionOptions = RxDefaultTransactionOptions;
          pTransactionOptions->NtTransactFunction = NT_TRANSACT_NOTIFY_CHANGE;
          pTransactionOptions->TimeoutIntervalInMilliSeconds = PROXYCE_TRANSACTION_TIMEOUT_NOT_USED;
          pTransactionOptions->Flags = PROXY_XACT_FLAGS_INDEFINITE_DELAY_IN_RESPONSE;

          ProxyCeInitializeAsynchronousTransactionResumptionContext(
                pResumptionContext,MRxProxyNotifyChangeDirectoryCompletion,pNotificationContext);

          Status = ProxyCeAsynchronousTransact(
                         RxContext,                    // the RXContext for the transaction
                         pTransactionOptions,          // transaction options
                         pNotifyRequest,               // the setup buffer
                         sizeof(REQ_NOTIFY_CHANGE),    // setup buffer length
                         pInputParamBuffer,            // Input Param Buffer
                         InputParamBufferLength,       // Input param buffer length
                         pOutputParamBuffer,           // Output param buffer
                         OutputParamBufferLength,      // output param buffer length
                         pInputDataBuffer,             // Input data buffer
                         InputDataBufferLength,        // Input data buffer length
                         pOutputDataBuffer,            // output data buffer
                         OutputDataBufferLength,       // output data buffer length
                         pResumptionContext            // the resumption context
                         );

          if (Status == STATUS_PENDING) {
             PMRXPROXY_RX_CONTEXT pMRxProxyContext;

             pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);
             pMRxProxyContext->pCancelContext = pNotificationContext;

             // Ensure that the appropriate cancel routine is set because this is a long term
             // operation and the cancelling mechanism needs to be in place.

             Status = RxSetMinirdrCancelRoutine(RxContext,MRxProxyNotifyChangeDirectoryCancellation);
             if (Status == STATUS_SUCCESS) {
                Status = STATUS_PENDING;
             } else if (Status == STATUS_CANCELLED) {
                MRxProxyNotifyChangeDirectoryCancellation(RxContext);
                Status = STATUS_PENDING;
             }
          } else {
             // On exit from this routine the request would have been completed in all
             // the cases. The asynchronous case and synchronous case are folded into
             // one async response by returning STATUS_PENDING.

             Status = STATUS_PENDING;
          }
      }  else {
          NOTHING; //just return the status from the deferred open call
      }
   } else {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }
#endif //0

   Status = STATUS_NOT_SUPPORTED;

   RxDbgTrace(-1, Dbg, ("MRxProxyNotifyChangeDirectory -> %08lx\n", Status ));
   return Status;
}

NTSTATUS
MRxProxyFsControl(PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine handles all the FSCTL's

Arguments:

    RxContext          - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Remoting of FSCTL's is permitted only to NT servers.

--*/
{
   NTSTATUS Status;

   RxCaptureFobx;

   //PMRX_PROXY_SRV_OPEN pProxySrvOpen;

   PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
   ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;


   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxProxyFsControl...Entry FsControlCode(%lx)\n", FsControlCode));

   Status = STATUS_NOT_IMPLEMENTED;
   RxDbgTrace(-1, Dbg, ("MRxProxyFsControl...Exit\n"));
   return Status;
}

#if DBG
NTSTATUS
MRxProxyTestForLowIoIoctl(
    IN PRX_CONTEXT RxContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PSZ Buffer = (PSZ)(LowIoContext->ParamsFor.IoCtl.pInputBuffer);
    ULONG OutputBufferLength = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    UNICODE_STRING u;
    PUNICODE_STRING FileName = &capFcb->AlreadyPrefixedName;
    ULONG ReturnLength;

    ReturnLength = OutputBufferLength;
    if (ReturnLength > FileName->Length) {
        ReturnLength = FileName->Length;
    }

    RxDbgTrace(0, Dbg,
      ("Here in MRxProxyTestForLowIoIoctl %s, obl = %08lx, rl=%08lx\n", Buffer, OutputBufferLength, ReturnLength));

    //return an obvious string to make sure that darryl is copying the results out correctly
    //BUGBUG need to check the lengths i.e. need outputl<=inputl; also need to check that count and buffer
    //    are aligned for wchar

    RtlCopyMemory(Buffer,FileName->Buffer,ReturnLength);
    u.Buffer = (PWCHAR)(Buffer);
    u.Length = u.MaximumLength = (USHORT)ReturnLength;
    RtlUpcaseUnicodeString(&u,&u,FALSE);

    RxContext->InformationToReturn =
    //LowIoContext->ParamsFor.IoCtl.OutputBufferLength =
            ReturnLength;

    return(Status);
}
#endif //if DBG

NTSTATUS
MRxProxyIoCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an IOCTL operation. Currently, no calls are remoted; in fact, the only call accepted
   is for debugging.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG          IoControlCode = pLowIoContext->ParamsFor.IoCtl.IoControlCode;

    RxDbgTrace(+1, Dbg, ("MRxProxyIoCtl...\n", 0));
    RxDbgTrace( 0, Dbg, ("MRxProxyIoCtl = %08lx\n", IoControlCode));

    switch (IoControlCode) {
#if DBG
    case IOCTL_LMMR_TESTLOWIO:
        Status = MRxProxyTestForLowIoIoctl(RxContext);
        break;
#endif //if DBG
    default:
        break;
    }

    RxDbgTrace(-1, Dbg, ("MRxProxyIoCtl -> %08lx\n", Status ));
    return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\ea.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ea.c

Abstract:

    This module implements the mini redirector call down routines pertaining to query/set ea/security.

Author:

    joelinn      [joelinn]      12-jul-95

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
////
////  The Bug check file id for this module
////
//
//#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

NTSTATUS
MRxProxyQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    )
{
    NTSTATUS Status;
    RxCaptureFobx;

    PVOID Buffer = RxContext->Info.Buffer;
    PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
    PUCHAR  UserEaList = RxContext->QueryEa.UserEaList;
    ULONG   UserEaListLength = RxContext->QueryEa.UserEaListLength;
    ULONG   UserEaIndex = RxContext->QueryEa.UserEaIndex;
    BOOLEAN RestartScan = RxContext->QueryEa.RestartScan;
    BOOLEAN ReturnSingleEntry = RxContext->QueryEa.ReturnSingleEntry;
    BOOLEAN IndexSpecified = RxContext->QueryEa.IndexSpecified;

    //PFEALIST ServerEaList = NULL;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxProxyQueryEaInformation\n"));

#if 0
    Status = MRxProxyDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status = MRxProxyLoadEaList( RxContext, UserEaList, UserEaListLength, &ServerEaList );

    if (( !NT_SUCCESS( Status ) )||
        ( ServerEaList == NULL )) {
        goto FINALLY;
    }

    if (IndexSpecified) {

        //CODE.IMPROVEMENT this name is poor....it owes back to the fastfat heritage and is not so meaningful
        //                 for a rdr
        capFobx->OffsetOfNextEaToReturn = UserEaIndex;
        Status = MRxProxyQueryEasFromServer(
                    RxContext,
                    ServerEaList,
                    Buffer,
                    pLengthRemaining,
                    ReturnSingleEntry,
                    (BOOLEAN)(UserEaList != NULL) );

        //
        //  if there are no Ea's on the file, and the user supplied an EA
        //  index, we want to map the error to STATUS_NONEXISTANT_EA_ENTRY.
        //

        if ( Status == STATUS_NO_EAS_ON_FILE ) {
            Status = STATUS_NONEXISTENT_EA_ENTRY;
        }
    } else {

        if ( ( RestartScan == TRUE ) || (UserEaList != NULL) ){

            //
            // Ea Indices start at 1, not 0....
            //

            capFobx->OffsetOfNextEaToReturn = 1;
        }

        Status = MRxProxyQueryEasFromServer(  //it is offensive to have two identical calls but oh, well.....
                    RxContext,
                    ServerEaList,
                    Buffer,
                    pLengthRemaining,
                    ReturnSingleEntry,
                    (BOOLEAN)(UserEaList != NULL) );
    }

FINALLY:

    if ( ServerEaList != NULL) {
        RxFreePool(ServerEaList);
    }
#endif //0

    Status = STATUS_NOT_SUPPORTED;
    RxDbgTrace(-1, Dbg, ("MRxProxyQueryEaInformation st=%08lx\n",Status));
    return Status;

}

NTSTATUS
MRxProxySetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;
    PVOID Buffer = RxContext->Info.Buffer;
    ULONG Length = RxContext->Info.Length;

#if 0
    PFEALIST ServerEaList = NULL;
    ULONG Size;
    PPROXYCEDB_SERVER_ENTRY pServerEntry;
#endif //0

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxySetEaInformation\n"));

#if 0
    pServerEntry = ProxyCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    //get rid of nonEA guys right now
    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_SUPPORTEA)) {
        RxDbgTrace(-1, Dbg, ("EAs w/o EA support!\n"));
        return((STATUS_NOT_SUPPORTED));
    }

    Status = MRxProxyDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    //
    //  Convert Nt format FEALIST to OS/2 format
    //
    Size = MRxProxyNtFullEaSizeToOs2 ( Buffer );
    if ( Size > 0x0000ffff ) {
        Status = STATUS_EA_TOO_LARGE;
        goto FINALLY;
    }

    //CODE.IMPROVEMENT since |os2eas|<=|nteas| we really don't need a maximum buffer
    ServerEaList = RxAllocatePool ( PagedPool, EA_QUERY_SIZE );
    if ( ServerEaList == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    MRxProxyNtFullListToOs2 ( Buffer, ServerEaList );

    //
    //  Set EAs on the file/directory; if the error is EA_ERROR then SetEaList
    //     sets iostatus.information to the offset of the offender
    //

    Status = MRxProxySetEaList( RxContext, ServerEaList);

FINALLY:

    if ( ServerEaList != NULL) {
        RxFreePool(ServerEaList);
    }
#endif //0

    Status = STATUS_NOT_SUPPORTED;
    RxDbgTrace(-1, Dbg, ("MRxProxySetEaInformation st=%08lx\n",Status));
    return Status;

}

NTSTATUS
MRxProxyQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine implements the NtQuerySecurityFile api.


Arguments:



Return Value:

    Status - Result of the operation.


--*/

{
   RxCaptureFobx;
   PVOID Buffer = RxContext->Info.Buffer;
   PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
   //PMRX_PROXY_SRV_OPEN proxySrvOpen;


   NTSTATUS Status;

#if 0
   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;
#endif //0

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxProxyQuerySecurityInformation...\n"));

#if 0
   Status = MRxProxyDeferredCreate(RxContext);
   if (Status!=STATUS_SUCCESS) {
       goto FINALLY;
   }

   Status = STATUS_MORE_PROCESSING_REQUIRED;

   proxySrvOpen = MRxProxyGetSrvOpenExtension(capFobx->pSrvOpen);
   ASSERT (!FlagOn(proxySrvOpen->Flags,PROXY_SRVOPEN_FLAG_NOT_REALLY_OPEN));

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
       PROXY_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
       PROXY_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
       //BOOLEAN printflag;

       TransactionOptions.NtTransactFunction = NT_TRANSACT_QUERY_SECURITY_DESC;
       //TransactionOptions.Flags |= PROXY_XACT_FLAGS_COPY_ON_ERROR;

       QuerySecurityRequest.Fid = proxySrvOpen->Fid;
       QuerySecurityRequest.Reserved = 0;
       QuerySecurityRequest.SecurityInformation = RxContext->QuerySecurity.SecurityInformation;

       QuerySecurityResponse.LengthNeeded = 0xbaadbaad;

       //printflag = RxDbgTraceDisableGlobally();//this is debug code anyway!
       //RxDbgTraceEnableGlobally(FALSE);

       Status = ProxyCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     &TransactionOptions,          // transaction options
                     NULL,                         // the setup buffer
                     0,                            // setup buffer length
                     &QuerySecurityRequest,        // Input Param Buffer
                     sizeof(QuerySecurityRequest), // Input param buffer length
                     &QuerySecurityResponse,       // Output param buffer
                     sizeof(QuerySecurityResponse),// output param buffer length
                     NULL,                         // Input data buffer
                     0,                            // Input data buffer length
                     Buffer,                       // output data buffer
                     *pLengthRemaining,            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        //DbgPrint("QSR.len=%x\n", QuerySecurityResponse.LengthNeeded);


        if (NT_SUCCESS(Status) || (Status == STATUS_BUFFER_TOO_SMALL)) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxContext->InformationToReturn = QuerySecurityResponse.LengthNeeded;;
            RxDbgTrace(0, Dbg, ("MRxProxyQuerySecurityInformation...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == sizeof(RESP_QUERY_SECURITY_DESCRIPTOR));

            if (((LONG)(QuerySecurityResponse.LengthNeeded)) > *pLengthRemaining) {
                Status = STATUS_BUFFER_OVERFLOW;
            }
        }

        //RxDbgTraceEnableGlobally(printflag);
    }


FINALLY:

#endif //0

    Status = STATUS_NOT_SUPPORTED;
    RxDbgTrace(-1, Dbg, ("MRxProxyQuerySecurityInformation...exit, st=%08lx,info=%08lx\n",
                               Status, RxContext->InformationToReturn));
    return Status;


}

NTSTATUS
MRxProxySetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
    RxCaptureFobx;
    //PMRX_PROXY_SRV_OPEN proxySrvOpen;
    NTSTATUS Status;

    RxDbgTrace(+1, Dbg, ("MRxProxySetSecurityInformation...\n"));

#if 0
   Status = MRxProxyDeferredCreate(RxContext);
   if (Status!=STATUS_SUCCESS) {
       goto FINALLY;
   }

   Status = STATUS_MORE_PROCESSING_REQUIRED;

   proxySrvOpen = MRxProxyGetSrvOpenExtension(capFobx->pSrvOpen);

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
       PROXY_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
       PROXY_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
       ULONG SdLength = RtlLengthSecurityDescriptor(RxContext->SetSecurity.SecurityDescriptor);

       TransactionOptions.NtTransactFunction = NT_TRANSACT_SET_SECURITY_DESC;

       SetSecurityRequest.Fid = proxySrvOpen->Fid;
       SetSecurityRequest.Reserved = 0;
       SetSecurityRequest.SecurityInformation = RxContext->SetSecurity.SecurityInformation;


       Status = ProxyCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     &TransactionOptions,          // transaction options
                     NULL,                         // the setup buffer
                     0,                            // setup buffer length
                     &SetSecurityRequest,          // Input Param Buffer
                     sizeof(SetSecurityRequest),   // Input param buffer length
                     NULL,                         // Output param buffer
                     0,                            // output param buffer length
                     RxContext->SetSecurity.SecurityDescriptor,  // Input data buffer
                     SdLength,                     // Input data buffer length
                     NULL,                         // output data buffer
                     0,                            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        //the old rdr doesn't return any info...................
        //RxContext->InformationToReturn = SetSecurityResponse.LengthNeeded;

        if ( NT_SUCCESS(Status) ) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxDbgTrace(0, Dbg, ("MRxProxySetSecurityInformation...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == 0);
            ASSERT(ResumptionContext.SetupBytesReceived == 0);
            ASSERT(ResumptionContext.DataBytesReceived == 0);
        }
    }


FINALLY:

#endif //0

    Status = STATUS_NOT_SUPPORTED;
    RxDbgTrace(-1, Dbg, ("MRxProxySetSecurityInformation...exit, st=%08lx,info=%08lx\n",
                               Status, RxContext->InformationToReturn));
    return Status;


}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the PROXY mini rdr.

Author:

    Balan Sethu Raman [SethuR]    7-Mar-1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include "ntverp.h"
#include "netevent.h"
#include "nvisible.h"

#define RDBSS_DRIVER_LOAD_STRING L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Rdbss"
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );

//
// Global data declarations .   CODE.IMPROVEMENT why are these placed here!!
//

PEPROCESS MRxProxySystemProcess;

FAST_MUTEX   MRxProxySerializationMutex;
KIRQL           MRxProxyGlobalSpinLockSavedIrql;
KSPIN_LOCK      MRxProxyGlobalSpinLock;
BOOLEAN         MRxProxyGlobalSpinLockAcquired;

#ifdef EXPLODE_POOLTAGS
ULONG         MRxProxyExplodePoolTags = 1;
#else
ULONG         MRxProxyExplodePoolTags = 0;
#endif

NTSTATUS
MRxProxyInitializeTables(
          void
    );

NTSTATUS
ProxyCeGetConfigurationInformation (
          void
    );

VOID
MRxProxyUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
MRxProxyGetUlongRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    BOOLEAN LogFailure
    );

//
// Mini Redirector global variables.
//

struct _MINIRDR_DISPATCH  MRxProxyDispatch;

PMRXPROXY_DEVICE_OBJECT MRxProxyDeviceObject;

ULONG MRxProxyBuildNumber = VER_PRODUCTBUILD;
#ifdef RX_PRIVATE_BUILD
ULONG MRxProxyPrivateBuild = 1;
#else
ULONG MRxProxyPrivateBuild = 0;
#endif


//declare the shadow debugtrace controlpoints

RXDT_DefineCategory(CREATE);
RXDT_DefineCategory(CLEANUP);
RXDT_DefineCategory(CLOSE);
RXDT_DefineCategory(READ);
RXDT_DefineCategory(WRITE);
RXDT_DefineCategory(LOCKCTRL);
RXDT_DefineCategory(FLUSH);
RXDT_DefineCategory(PREFIX);
RXDT_DefineCategory(FCBSTRUCTS);
RXDT_DefineCategory(DISPATCH);
RXDT_DefineCategory(EA);
RXDT_DefineCategory(DEVFCB);


typedef enum _MRXPROXY_INIT_STATES {
    MRXPROXYINIT_ALL_INITIALIZATION_COMPLETED,
    MRXPROXYINIT_MINIRDR_REGISTERED,
    MRXPROXYINIT_START
} MRXPROXY_INIT_STATES;

VOID
MRxProxyInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN MRXPROXY_INIT_STATES MRxProxyInitState
    );


NTSTATUS
MRxProxyFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the PROXY mini redirector

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
        operation.

--*/
{
    NTSTATUS       Status;
    //UNICODE_STRING MRxProxyRdbssDriverLoadString;
    MRXPROXY_INIT_STATES MRxProxyInitState = 0;
    UNICODE_STRING ProxyMiniRedirectorName;


#ifdef MONOLITHIC_MINIRDR
    DbgPrint("InitWrapper\n");
    Status =  RxDriverEntry(DriverObject, RegistryPath);
    DbgPrint("BackFromInitWrapper %08lx\n",Status);
    if (Status != STATUS_SUCCESS) {
        DbgPrint("Wrapper failed to initialize. Status = %08lx\n",Status);
        return(Status);
    }
#endif

    MRxProxySystemProcess = RxGetRDBSSProcess();

    MRxProxyInitializeLoudStrings();

    ExInitializeFastMutex(&MRxProxySerializationMutex);
    KeInitializeSpinLock(&MRxProxyGlobalSpinLock );
    MRxProxyGlobalSpinLockAcquired = FALSE;

    try {

        MRxProxyInitState = MRXPROXYINIT_START;

        RtlInitUnicodeString(&ProxyMiniRedirectorName,MRXPROXY_DEVICE_NAME_U);
        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxProxyDriverEntry: DriverObject =%08lx\n", DriverObject ));

        Status = RxRegisterMinirdr((PRDBSS_DEVICE_OBJECT *)(&MRxProxyDeviceObject),
                                    DriverObject,
                                    &MRxProxyDispatch,
                                    FALSE,FALSE,     //don't register with unc and for mailslots
                                    &ProxyMiniRedirectorName,
                                    sizeof(MRXPROXY_DEVICE_OBJECT) - sizeof(RDBSS_DEVICE_OBJECT), //IN  ULONG DeviceExtensionSize,
                                    0 //IN  ULONG DeviceCharacteristics
                                    );
        if (Status!=STATUS_SUCCESS) {
            RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxProxyDriverEntry failed: %08lx\n", Status ));
            try_return(Status);
        }
        MRxProxyInitState = MRXPROXYINIT_MINIRDR_REGISTERED;
        MRxProxyDeviceObject->SectorSize = 512;  //BUGBUG go find out
        RtlInitUnicodeString(&MRxProxyDeviceObject->InnerPrefixForOpens,
                             MRXPROXY_INNERPREFIX_FOR_OPENS
                            );
        RtlInitUnicodeString(&MRxProxyDeviceObject->PrefixForRename,
                              MRXPROXY_INNERPREFIX_FOR_OPENS
                              //MRXPROXY_PREFIX_FOR_RENAME
                            );

        //for all this stuff, there's no undo.....so no extra state

        Status = MRxProxyInitializeTables();
        if (!NT_SUCCESS( Status )) {
            try_return(Status);
        }

        Status = ProxyCeGetConfigurationInformation();
        if (!NT_SUCCESS( Status )) {
            try_return(Status);
        }


  try_exit: NOTHING;
    } finally {
        if (Status != STATUS_SUCCESS) {
            MRxProxyInitUnwind(DriverObject,MRxProxyInitState);
        }
    }
    if (Status != STATUS_SUCCESS) {
        DbgPrint("MRxProxy failed to start with %08lx %08lx\n",Status,MRxProxyInitState);
        return(Status);
    }


    //  Setup Unload Routine
    DriverObject->DriverUnload = MRxProxyUnload;

    //setup the driverdispatch for people who come in here directly....like the browser
    //CODE.IMPROVEMENT we should change this code so that the things that aren't examined
    //    in MRxProxyFsdDispatch are routed directly, i.e. reads and writes
    {ULONG i;
    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)MRxProxyFsdDispatch;
    }}

    //and get out
    return  STATUS_SUCCESS;
}

VOID
MRxProxyInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN MRXPROXY_INIT_STATES MRxProxyInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for unwinding from a bad driver entry or for unloading.

Arguments:

     RxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
    PAGED_CODE();

    switch (MRxProxyInitState) {
    case MRXPROXYINIT_ALL_INITIALIZATION_COMPLETED:
        //Nothing extra to do...this is just so that the constant in RxUnload doesn't change.......
        //lack of break intentional


    case MRXPROXYINIT_MINIRDR_REGISTERED:
        RxUnregisterMinirdr(&MRxProxyDeviceObject->RxDeviceObject);
        //lack of break intentional

    case MRXPROXYINIT_START:
        break;
    }

}


VOID
MRxProxyUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the PROXY mini redirector.

Arguments:

     DriverObject - pointer to the driver object for the MRxProxy

Return Value:

     None

--*/

{
    PAGED_CODE();
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxProxyUnload: DriverObject =%08lx\n", DriverObject) );
    //ASSERT(!"Starting to unload!");
    //RxUnregisterMinirdr(MRxProxyDeviceObject);
    MRxProxyInitUnwind(DriverObject,MRXPROXYINIT_ALL_INITIALIZATION_COMPLETED);

#ifdef MONOLITHIC_MINIRDR
    RxUnload(DriverObject);
#endif

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxProxyUnload exit: DriverObject =%08lx\n", DriverObject) );
}



NTSTATUS
MRxProxyInitializeTables(
          void
    )
/*++

Routine Description:

     This routine sets up the mini redirector dispatch vector and also calls to initialize any other tables needed.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    // Ensure that the PROXY mini redirector context satisfies the size constraints
    ASSERT(sizeof(MRXPROXY_RX_CONTEXT) <= MRX_CONTEXT_SIZE);

    //local minirdr dispatch table init
    ZeroAndInitializeNodeType( &MRxProxyDispatch, RDBSS_NTC_MINIRDR_DISPATCH, sizeof(MINIRDR_DISPATCH));

    // PROXY mini redirector extension sizes and allocation policies.
    // CODE.IMPROVEMENT -- currently we do not allocate the NET_ROOT and SRV_CALL extensions
    // in the wrapper. Except for V_NET_ROOT wherein it is shared across multiple instances in
    // the wrapper all the other data structure management should be left to the wrappers

    MRxProxyDispatch.MRxFlags = (RDBSS_MANAGE_FCB_EXTENSION |
                               RDBSS_MANAGE_SRV_OPEN_EXTENSION |
                               RDBSS_MANAGE_FOBX_EXTENSION);

    MRxProxyDispatch.MRxSrvCallSize  = 0;
    MRxProxyDispatch.MRxNetRootSize  = 0;
    MRxProxyDispatch.MRxVNetRootSize = 0;
    MRxProxyDispatch.MRxFcbSize      = sizeof(MRX_PROXY_FCB);
    MRxProxyDispatch.MRxSrvOpenSize  = sizeof(MRX_PROXY_SRV_OPEN);
    MRxProxyDispatch.MRxFobxSize     = sizeof(MRX_PROXY_FOBX);

//    // Transport update handler
//    MRxProxyDispatch.MRxTransportUpdateHandler = MRxProxyTransportUpdateHandler;

    // Mini redirector cancel routine ..
    MRxProxyDispatch.MRxCancel = NULL;

    // Mini redirector Start/Stop
    MRxProxyDispatch.MRxStart          = MRxProxyStart;
    MRxProxyDispatch.MRxStop           = MRxProxyStop;
    //MRxProxyDispatch.MRxMinirdrControl = MRxProxyMinirdrControl;    //now we have no way to readch this BUGBUG
    MRxProxyDispatch.MRxDevFcbXXXControlFile = MRxProxyDevFcbXXXControlFile;

    // Mini redirector name resolution
    MRxProxyDispatch.MRxCreateSrvCall = MRxProxyCreateSrvCall;
    MRxProxyDispatch.MRxSrvCallWinnerNotify = MRxProxySrvCallWinnerNotify;
    MRxProxyDispatch.MRxCreateVNetRoot = MRxProxyCreateVNetRoot;
    MRxProxyDispatch.MRxUpdateNetRootState = MRxProxyUpdateNetRootState;
    MRxProxyDispatch.MRxExtractNetRootName = MRxProxyExtractNetRootName;
    MRxProxyDispatch.MRxFinalizeSrvCall = MRxProxyFinalizeSrvCall;
    MRxProxyDispatch.MRxFinalizeNetRoot = MRxProxyFinalizeNetRoot;
    MRxProxyDispatch.MRxFinalizeVNetRoot = MRxProxyFinalizeVNetRoot;

    // File System Object Creation/Deletion.
    MRxProxyDispatch.MRxCreate            = MRxProxyCreate;
    MRxProxyDispatch.MRxCollapseOpen      = MRxProxyCollapseOpen;
    MRxProxyDispatch.MRxShouldTryToCollapseThisOpen      = MRxProxyShouldTryToCollapseThisOpen;
    MRxProxyDispatch.MRxExtendForCache    = MRxProxyExtendForCache;
    MRxProxyDispatch.MRxExtendForNonCache = MRxProxyExtendForNonCache;
    MRxProxyDispatch.MRxTruncate          = MRxProxyTruncate;
    MRxProxyDispatch.MRxCleanupFobx       = MRxProxyCleanupFobx;
    MRxProxyDispatch.MRxCloseSrvOpen      = MRxProxyCloseSrvOpen;
    MRxProxyDispatch.MRxFlush             = MRxProxyFlush;
    MRxProxyDispatch.MRxForceClosed       = MRxProxyForcedClose;
    MRxProxyDispatch.MRxDeallocateForFcb  = MRxProxyDeallocateForFcb;
    MRxProxyDispatch.MRxDeallocateForFobx = MRxProxyDeallocateForFobx;
    MRxProxyDispatch.MRxIsLockRealizable  = MRxProxyIsLockRealizable;

    // File System Objects query/Set
    MRxProxyDispatch.MRxQueryDirectory  = MRxProxyQueryDirectory;
    MRxProxyDispatch.MRxQueryVolumeInfo = MRxProxyQueryVolumeInformation;
    MRxProxyDispatch.MRxQueryEaInfo     = MRxProxyQueryEaInformation;
    MRxProxyDispatch.MRxSetEaInfo       = MRxProxySetEaInformation;
    MRxProxyDispatch.MRxQuerySdInfo     = MRxProxyQuerySecurityInformation;
    MRxProxyDispatch.MRxSetSdInfo       = MRxProxySetSecurityInformation;
    MRxProxyDispatch.MRxQueryFileInfo   = MRxProxyQueryFileInformation;
    MRxProxyDispatch.MRxSetFileInfo     = MRxProxySetFileInformation;
    MRxProxyDispatch.MRxSetFileInfoAtCleanup
                                      = MRxProxySetFileInformationAtCleanup;


    // Buffering state change
    MRxProxyDispatch.MRxComputeNewBufferingState = MRxProxyComputeNewBufferingState;

    // File System Object I/O
    MRxProxyDispatch.MRxLowIOSubmit[LOWIO_OP_READ]            = MRxProxyRead;
    MRxProxyDispatch.MRxLowIOSubmit[LOWIO_OP_WRITE]           = MRxProxyWrite;
    MRxProxyDispatch.MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]      = MRxProxyLocks;
    MRxProxyDispatch.MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]   = MRxProxyLocks;
    MRxProxyDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK]          = MRxProxyLocks;
    MRxProxyDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE] = MRxProxyLocks;
    MRxProxyDispatch.MRxLowIOSubmit[LOWIO_OP_FSCTL]           = MRxProxyFsCtl;
    MRxProxyDispatch.MRxLowIOSubmit[LOWIO_OP_IOCTL]           = MRxProxyIoCtl;
    //CODE.IMPROVEMENT  shouldn't flush come thru lowio???
    MRxProxyDispatch.MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY] = MRxProxyNotifyChangeDirectory;

    //no longer a field MRxProxyDispatch.MRxUnlockRoutine   = MRxProxyUnlockRoutine;


    // Miscellanous
    MRxProxyDispatch.MRxCompleteBufferingStateChangeRequest = MRxProxyCompleteBufferingStateChangeRequest;

    return(STATUS_SUCCESS);
}

NTSTATUS
MRxProxyStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

     This routine completes the initialization of the mini redirector fromn the
     RDBSS perspective. Note that this is different from the initialization done
     in DriverEntry. Any initialization that depends on RDBSS should be done as
     part of this routine while the initialization that is independent of RDBSS
     should be done in the DriverEntry routine.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;
    return Status;
}


NTSTATUS
MRxProxyStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine is used to activate the mini redirector from the RDBSS perspective

Arguments:

    RxContext - the context that was used to start the mini redirector

    pContext  - the PROXY mini rdr context passed in at registration time.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    //NTSTATUS Status;

    // Deallocate the configuration strings ....
#if 0
    if (ProxyCeContext.Transports.Buffer != NULL) {

        // the transports buffer is at the end of a larger buffer (by 12 bytes)
        // allocated to read the value from the registry. recover the original buffer
        // pointer in orer to free.

        PKEY_VALUE_PARTIAL_INFORMATION TransportsValueFromRegistry;
        TransportsValueFromRegistry = CONTAINING_RECORD(
                                         ProxyCeContext.Transports.Buffer,
                                         KEY_VALUE_PARTIAL_INFORMATION,
                                         Data[0]
                                      );
        //DbgPrint("b1 %08lx b2 %08lx\n", TransportsValueFromRegistry,ProxyCeContext.Transports.Buffer);
        RxFreePool(TransportsValueFromRegistry);
    }
#endif //0

    return(STATUS_SUCCESS);
}

#if 0
#define PROXYMRX_CONFIG_COMPUTER_NAME \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"

#define COMPUTERNAME L"ComputerName"

#define PROXYMRX_CONFIG_TRANSPORTS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanWorkStation\\Linkage"

#define TRANSPORT_BINDINGS L"Bind"

#define PROXYMRX_MINIRDR_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\MRxProxy\\Parameters"

VOID
MRxProxyReadMiscellaneousRegistryParameters()
{
    NTSTATUS Status;
    //ULONG BytesRead;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ParametersRegistryKeyName;
    HANDLE ParametersHandle;
    ULONG Temp;

    RtlInitUnicodeString(&ParametersRegistryKeyName, PROXYMRX_MINIRDR_PARAMETERS);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &ParametersRegistryKeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );


    Status = ZwOpenKey (&ParametersHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        RxLogFailure(
            MRxProxyDeviceObject,
            NULL,
            EVENT_RDR_CANT_READ_REGISTRY,
            Status);

        return;
    }

    if (0) {
        MRxProxyGetUlongRegistryParameter(ParametersHandle,
                                  L"NoPreciousServerSetup",
                                  (PULONG)&Temp,
                                  FALSE
                                  );
    }


    Status = MRxProxyGetUlongRegistryParameter(ParametersHandle,
                              L"DeferredOpensEnabled",
                              (PULONG)&Temp,
                              FALSE
                              );
    if (NT_SUCCESS(Status)) MRxProxyDeferredOpensEnabled = (BOOLEAN)Temp;


    Status = MRxProxyGetUlongRegistryParameter(ParametersHandle,
                              L"OplocksDisabled",
                              (PULONG)&Temp,
                              FALSE
                              );
    if (NT_SUCCESS(Status)) MRxProxyOplocksDisabled = (BOOLEAN)Temp;

    ZwClose(ParametersHandle);

}
#endif

NTSTATUS
ProxyCeGetConfigurationInformation()
{
   ULONG            Storage[256];
   //UNICODE_STRING   UnicodeString;
   //HANDLE           hRegistryKey;
   //HANDLE           hProxyMrxConfiguration;
   //HANDLE           ParametersHandle;
   NTSTATUS         Status;
   //ULONG            BytesRead;

   //OBJECT_ATTRIBUTES ObjectAttributes;
   PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;
   //KEY_VALUE_PARTIAL_INFORMATION InitialPartialInformationValue;
   //ULONG AllocationLength;

   PAGED_CODE();

   //MRxProxyReadMiscellaneousRegistryParameters();

#if 0
   // Obtain the list of transports associated with PROXY redirector. This is stored
   // as a multivalued string and is used subsequently to weed out the
   // appropriate transports. This is a two step process; first we try to find out
   // how much space we need; then we allocate; then we read in. unfortunately, the kind of
   // structure that we have to use to get the value has a header on it, so we have to offset the
   // returned pointer both here and in the free routine.

   //CODE.IMPROVEMENT we should perhaps get a subroutine going that does all this
   //also, there are no log entries.
   //also, we should be doing partial_infos instead of full

   RtlInitUnicodeString(&ProxyCeContext.Transports, NULL);
   RtlInitUnicodeString(&UnicodeString, PROXYMRX_CONFIG_TRANSPORTS);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);
   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, TRANSPORT_BINDINGS);
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValuePartialInformation,
               &InitialPartialInformationValue,
               sizeof(InitialPartialInformationValue),
               &BytesRead);
   if (Status== STATUS_BUFFER_OVERFLOW) {
       Status = STATUS_SUCCESS;
   }
   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   AllocationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION)
                                  + InitialPartialInformationValue.DataLength;
   if (0) {
       DbgPrint("SizeofBindingInfo=%08lx %08lx\n",
                      AllocationLength,
                      InitialPartialInformationValue.DataLength);
   }

   //RtlInitUnicodeString(&UnicodeString, TRANSPORT_BINDINGS);
   {
   PKEY_VALUE_PARTIAL_INFORMATION TransportsValueFromRegistry;

   (PBYTE)TransportsValueFromRegistry = RxAllocatePoolWithTag(
                                             PagedPool,
                                             AllocationLength,
                                             MRXPROXY_MISC_POOLTAG);
   if (TransportsValueFromRegistry == NULL) {
       return(STATUS_INSUFFICIENT_RESOURCES);
   }

   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValuePartialInformation,
               TransportsValueFromRegistry,
               AllocationLength,
               &BytesRead);

   if (NT_SUCCESS(Status) &&
       (TransportsValueFromRegistry->DataLength > 0) &&
       (TransportsValueFromRegistry->Type == REG_MULTI_SZ)) {
      ProxyCeContext.Transports.MaximumLength =
          ProxyCeContext.Transports.Length = (USHORT)TransportsValueFromRegistry->DataLength;
      ProxyCeContext.Transports.Buffer = (PWCHAR)(&TransportsValueFromRegistry->Data[0]);
      //DbgPrint("b1 %08lx b2 %08lx\n", TransportsValueFromRegistry,ProxyCeContext.Transports.Buffer);
   } else {
      RxLog(("Invalid Transport Binding string... using all transports"));
      RxFreePool(TransportsValueFromRegistry);
   }
   }

   ZwClose(hRegistryKey);
#endif //0

   Status = STATUS_SUCCESS;
   return Status;
}


NTSTATUS
MRxProxyFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD dispatch for the proxymini DRIVER object.

Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The Fsd status for the Irp

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );  //ok4ioget
    UCHAR MajorFunctionCode = IrpSp->MajorFunction;

    ASSERT(DeviceObject==(PDEVICE_OBJECT)MRxProxyDeviceObject);
    if (DeviceObject!=(PDEVICE_OBJECT)MRxProxyDeviceObject) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT );
        return (STATUS_INVALID_DEVICE_REQUEST);
    }
    return RxFsdDispatch((PRDBSS_DEVICE_OBJECT)MRxProxyDeviceObject,Irp);
}

NTSTATUS
MRxProxyDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    )
/*++

Routine Description:

    This routine is called when the wrapper is about to deallocate a FCB.

Arguments:

    pFcb - the Fcb being deallocated.

Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    //DbgPrint("Bob's opportunity to get rid of his fcb storage......\n");
    return(STATUS_SUCCESS);
}

NTSTATUS
MRxProxyDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    )
/*++

Routine Description:

    This routine is called when the wrapper is about to deallocate a FOBX.

Arguments:

    pFobx - the Fobx being deallocated.

Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    PMRX_PROXY_FOBX proxyFobx = MRxProxyGetFileObjectExtension(pFobx);
    PMRX_SRV_OPEN SrvOpen = pFobx->pSrvOpen;
    PMRX_FCB Fcb = SrvOpen->pFcb;

    IF_DEBUG {
        if (proxyFobx && FlagOn(proxyFobx->Enumeration.Flags,PROXYFOBX_ENUMFLAG_LOUD_FINALIZE)) {
            DbgPrint("Finalizobx side buffer %08lx %08lx %08lx %08lx %08lxon %wZ\n",
                     0, 0, //sidebuffer,count
                     proxyFobx,pFobx,&Fcb->AlreadyPrefixedName
                     );
        }
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
MRxProxyGetUlongRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    BOOLEAN LogFailure
    )
/*++

Routine Description:

    This routine is called to read a ULONG param from t he registry.

Arguments:

    ParametersHandle - the handle of the containing registry "folder"
    ParameterName    - name of the parameter to be read
    ParamUlong       - where to store the value, if successful
    LogFailure       - if TRUE and the registry stuff fails, log an error

Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    ULONG Storage[16];
    PKEY_VALUE_PARTIAL_INFORMATION Value;
    ULONG ValueSize;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG BytesRead;

    PAGED_CODE(); //INIT

    Value = (PKEY_VALUE_PARTIAL_INFORMATION)Storage;
    ValueSize = sizeof(Storage);

    RtlInitUnicodeString(&UnicodeString, ParameterName);

    Status = ZwQueryValueKey(ParametersHandle,
                        &UnicodeString,
                        KeyValuePartialInformation,
                        Value,
                        ValueSize,
                        &BytesRead);


    if (NT_SUCCESS(Status)) {
        if (Value->Type == REG_DWORD) {
            PULONG ConfigValue = (PULONG)&Value->Data[0];
            *ParamUlong = *((PULONG)ConfigValue);
            DbgPrint("readRegistryvalue %wZ = %08lx\n",&UnicodeString,*ParamUlong);
            return(STATUS_SUCCESS);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
     }

     if (!LogFailure) { return Status; }

     RxLogFailureWithBuffer(
         MRxProxyDeviceObject,
         NULL,
         EVENT_RDR_CANT_READ_REGISTRY,
         Status,
         ParameterName,
         (USHORT)(wcslen(ParameterName)*sizeof(WCHAR))
         );

     return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\innerio.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    InnerIo.c

Abstract:

    This module implements the read, write, and lockctrl routines for the proxy minirdr
Author:

    Joe Linn      [JoeLinn]      11-Oct-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

#ifdef ALLOC_PRAGMA
#endif

NTSTATUS
MRxProxyBuildAsynchronousRequest(
    IN PRX_CONTEXT RxContext,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request (RxContext->MajorFunction) must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_DIRECTORY_CONTROL
        IRP_MJ_FLUSH_BUFFERS
        //IRP_MJ_SHUTDOWN (not yet implemented)


Arguments:

    CompletionRoutine - the IrpCompletionRoutine

Return Value:

    The function value is a pointer to the IRP representing the specified
    request.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG MajorFunction = RxContext->MajorFunction;
    RxCaptureFcb; RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PMRXPROXY_RX_CONTEXT pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);

    PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext =
                        (PMRXPROXY_ASYNCENGINE_CONTEXT)(pMRxProxyContext->AsyncEngineContext);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(capFobx->pSrvOpen);
    //PMRX_PROXY_FCB proxyFcb = MRxProxyGetFcbExtension(capFcb);

    PDEVICE_OBJECT DeviceObject =  proxySrvOpen->UnderlyingDeviceObject;
    PFILE_OBJECT FileObject = proxySrvOpen->UnderlyingFileObject;

    LARGE_INTEGER ZeroAsLI;
    ULONG MdlLength = 0;

    PAGED_CODE();

    ASSERT (proxySrvOpen->UnderlyingFileObject);

    if (DeviceObject->Flags & DO_BUFFERED_IO) {
        //i cannot handled buffered_io devices....sigh
        return STATUS_INVALID_DEVICE_REQUEST;
    }


    RxDbgTrace(0, Dbg, ("MRxProxyBuildAsynchronousRequest %08lx %08lx len/off=%08lx %08lx\n",
                            RxContext,SrvOpen,
                            LowIoContext->ParamsFor.ReadWrite.ByteCount,
                            (ULONG)LowIoContext->ParamsFor.ReadWrite.ByteOffset));

    RxLog(("BuildAsyncIrp %lx %lx %lx %lx",
                            RxContext,SrvOpen,
                            LowIoContext->ParamsFor.ReadWrite.ByteCount,
                            (ULONG)LowIoContext->ParamsFor.ReadWrite.ByteOffset));

    ZeroAsLI.QuadPart = 0;

//    irp = IoBuildAsynchronousFsdRequest(
//              MajorFunction,
//              DeviceObject,
//              NULL,
//              0,
//              &ZeroAsLI,
//              NULL
//              );
//
//    if (!irp) {
//        return STATUS_INSUFFICIENT_RESOURCES;
//    }

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE ); //why not charge???
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );  //ok4ioget
    irpSp->MajorFunction = (UCHAR) MajorFunction;
    irpSp->FileObject = FileObject;            //ok4->FileObj
    RxLog(("BuildAsyncIrpFo %lx %lx",RxContext,FileObject));

    {   BOOLEAN EnableCalls = CompletionRoutine!=NULL;

        IoSetCompletionRoutine(irp, CompletionRoutine, RxContext,
                                EnableCalls,EnableCalls,EnableCalls);
    }


    if ( (MajorFunction == IRP_MJ_READ) || (MajorFunction == IRP_MJ_WRITE) ) {

        // never paging io
        BOOLEAN PagingIo = FALSE;
        //BOOLEAN PagingIo =
        //    BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_PAGING_IO);

        irp->Flags |= IRP_NOCACHE;


        //
        // Set the parameters according to whether this is a read or a write
        // operation.  Notice that these parameters must be set even if the
        // driver has not specified buffered or direct I/O.
        //

        ASSERT (&irpSp->Parameters.Write.Key == &irpSp->Parameters.Read.Key);
        ASSERT (&irpSp->Parameters.Write.Length == &irpSp->Parameters.Read.Length);
        ASSERT (&irpSp->Parameters.Write.ByteOffset == &irpSp->Parameters.Read.ByteOffset);
        irpSp->Parameters.Read.Key = LowIoContext->ParamsFor.ReadWrite.Key;
        irpSp->Parameters.Read.ByteOffset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
        irp->RequestorMode = KernelMode;

        irp->UserBuffer = RxLowIoGetBufferAddress(RxContext);

        MdlLength = RxContext->CurrentIrp->MdlAddress->ByteCount;

        if (PagingIo) {
            irpSp->Parameters.Read.Length = MdlLength;
        } else {
            irpSp->Parameters.Read.Length = LowIoContext->ParamsFor.ReadWrite.ByteCount;
        }

    } else if (MajorFunction == IRP_MJ_FLUSH_BUFFERS) {

        MdlLength = 0;
        //nothing else to do!!!

    } else {

        FILE_INFORMATION_CLASS FileInformationClass = RxContext->Info.FileInformationClass;
        PVOID   Buffer = RxContext->Info.Buffer;
        PULONG  pLengthRemaining = &RxContext->Info.LengthRemaining;
        BOOLEAN Wait = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);

        ASSERT( MajorFunction == IRP_MJ_DIRECTORY_CONTROL );
        irpSp->MinorFunction = IRP_MN_QUERY_DIRECTORY;
        //CODE.IMPROVEMENT it would be better to actually get the stuff out of the context.info
        irpSp->Parameters.QueryDirectory = RxContext->CurrentIrpSp->Parameters.QueryDirectory;
        ASSERT (
               (irpSp->Parameters.QueryDirectory.FileInformationClass == FileInformationClass)
            && (irpSp->Parameters.QueryDirectory.Length == *pLengthRemaining)
        );
        irpSp->Flags = RxContext->CurrentIrpSp->Flags;
        irp->UserBuffer = Buffer;
        MdlLength = *pLengthRemaining;

        if (Wait) {
            irp->Flags |= IRP_SYNCHRONOUS_API;
        }
    }

    // Build an mdl if necessary....

    if (MdlLength != 0) {
        irp->MdlAddress = IoAllocateMdl(irp->UserBuffer,MdlLength,
                                       FALSE,FALSE,NULL);
        if (!irp->MdlAddress) {
            //whoops.......sorry..........
            IoFreeIrp(irp);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        MmBuildMdlForNonPagedPool(irp->MdlAddress);
    }

    //
    // Finally, return a pointer to the IRP.
    //

    AsyncEngineContext->CalldownIrp = irp;
    RxLog(("BAsyIrpX %lx %lx %lx %lx %lx %lx %lx",
                            RxContext,
                            irpSp->MajorFunction,
                            irpSp->Flags,
                            irpSp->Parameters.Others.Argument1,
                            irpSp->Parameters.Others.Argument2,
                            irpSp->Parameters.Others.Argument3,
                            irpSp->Parameters.Others.Argument4));
    return STATUS_SUCCESS;
}

//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//
//  The local debug trace level
//

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_WRITE)

//everything else in here is ifdef'd out....also CODE.IMPROVEMENT we should change over
//to a common irp building routine in Rx. the code is already in the csc driver
#if 0
NTSTATUS
MRxProxyBuildInnerIoAsyncWrite (
    IN PRX_CONTEXT RxContext,
    IN PBYTE Buffer,
    IN ULONG WriteByteCount,
    IN PLARGE_INTEGER FileOffset,
    IN OUT PIRP *CalldownIrp
    )

/*++

Routine Description:

    This routine fills in the calldown irp for a proxy read

Arguments:

    RxContext,
    PBYTE Buffer - the write buffer
    ULONG Count  - amount of data to written
    PLARGE_INTEGER FileOffset - fileoffset where the write begins
    PIRP *CallDownIrp - where the Irp is to be stored

Return Value:

    NTSTATUS - Returns the status for the write

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(SrvOpen);

    RxDbgTrace(+1, Dbg, ("MRxProxyInnerIoWrite.... ByteCount = %08lx, ByteOffset = %08lx %08lx\n",
                            LowIoContext->ParamsFor.ReadWrite.ByteCount,
                            FileOffset->LowPart, FileOffset->HighPart));

    RxLog(("MRxProxyInnerIoWrite %lx %lx %lx",
                            SrvOpen,
                            LowIoContext->ParamsFor.ReadWrite.ByteCount,
                            FileOffset->LowPart));


    RxDbgTrace ( 0, Dbg, ( "MRxProxyInnerIoWrite....  ->Buffer = %8lx\n", Buffer));

    *CalldownIrp = MRxProxyBuildAsynchronousReadWriteRequest(
                        RxContext,                             // IN PVOID Context
                        MRxProxyAsyncEngineCalldownIrpCompletion        // IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                        );

    if (!*CalldownIrp){
        Status = (STATUS_INSUFFICIENT_RESOURCES);
    }

    RxDbgTrace(-1, Dbg, ("MRxProxyInnerIoWrite.... exit\n"));

    return(Status);
}


//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//
//  The local debug trace level
//

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_LOCKCTRL)


PIRP
MRxBuildLockRequest (
    IN PIRP irp OPTIONAL,
    IN PFILE_OBJECT fileObject,
    IN PETHREAD UsersThread,
    IN UCHAR MinorCode,
    IN RXVBO ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN UCHAR Flags,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This function builds an I/O request packet for a lock request.

Arguments:

    Irp - Supplies a pointer to an IRP; allocates one if one is not provided.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The proxy minirdr accomplishes this by holding a pointer
        (a REFERENCED ptr) to the fileobject in its srvopen while the fileobject is
        open.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    StartingBlock - the block number of the beginning of the locked
        range.

    ByteOffset - the offset within block of the beginning of the locked
        range.

    Length - the length of the locked range.

    Key - the key value to be associated with the lock.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    if (irp) {
        ASSERT( irp->StackCount >= deviceObject->StackSize );
    } else {
        irp = IoAllocateIrp( deviceObject->StackSize, TRUE );  //joejoe should i charge quota??
    }

    if (!irp) {

        //
        // An IRP could not be allocated.

        return NULL;
    }

    // we have to make sure that the thread that takes the lock is the same as the one that reads
    irp->Tail.Overlay.Thread = UsersThread;
    irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    {   BOOLEAN EnableCalls = CompletionRoutine!=NULL;

        IoSetCompletionRoutine(irp, CompletionRoutine, Context,
                                EnableCalls,EnableCalls,EnableCalls);
    }



    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = MinorCode;
    irpSp->FileObject = fileObject;   //ok4->FileObj
    irpSp->DeviceObject = deviceObject;

    irpSp->Flags = Flags;

    irpSp->Parameters.LockControl.Length = Length;
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset.QuadPart = ByteOffset;

    return irp;

}

NTSTATUS
MRxProxyCalldownLockCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine for calldown lock requests. we just call the lowio completion
    and exit

Arguments:

    DeviceObject - Pointer to target device object for the request.

    CalldownIrp - Pointer to I/O request packet used to call down to the underlying filesystem

    Context - Irpcontext of the original request to the rdbss

Return Value:

    NTSTATUS - (STATUS_MORE_PROCESSING_REQUIRED) is returned.


--*/

{
    PRX_CONTEXT RxContext = Context;

    RxDbgTrace ( 0, Dbg, ("MRxProxyCalldownLockCompletion           = %08lx\n", 0));
    //DbgBreakPoint();
    if (CalldownIrp->PendingReturned){
        RxContext->CurrentIrp->IoStatus = CalldownIrp->IoStatus;
        RxContext->StoredStatus = CalldownIrp->IoStatus.Status;
    }
    RxLowIoCompletion(RxContext);

    IoFreeIrp(CalldownIrp);
    return((STATUS_MORE_PROCESSING_REQUIRED));
}


NTSTATUS
MRxProxyLocks (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine implements proxy read call. we fill in the info and stuff here BUT we
    do not complete the Irp.

Arguments:

Return Value:

    NTSTATUS - Returns the status for the read

--*/

{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    PIRP CalldownIrp;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    PMRX_LOCAL_SRV_OPEN proxySrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;

    BOOLEAN Wait = FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT)!=0;
    PLARGE_INTEGER LengthAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length;
    PLARGE_INTEGER OffsetAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.ByteOffset;

    char *whichop;

    switch (LowIoContext->Operation) {
    case LOWIO_OP_SHAREDLOCK:     whichop = "SHAREDLOCK"; break;
    case LOWIO_OP_EXCLUSIVELOCK:  whichop = "EXCLUSIVELOCK"; break;
    case LOWIO_OP_UNLOCK:         whichop = "UNLOCK"; break;
    case LOWIO_OP_UNLOCKALL:      whichop = "UNLOCKALL"; break;
    case LOWIO_OP_UNLOCKALLBYKEY:  whichop = "UNLOCKALLBYKEY"; break;
    }

    RxDbgTrace (+1, Dbg, ("MRxExclusiveLock...%s, Flags = %08lx, Key = %08lx\n", whichop,
              LowIoContext->ParamsFor.Locks.Flags,
              LowIoContext->ParamsFor.Locks.Key));
    RxDbgTrace( 0, Dbg, ("  ->Length     = %08lx %08lx\n",
              LengthAsLI->LowPart,
              LengthAsLI->HighPart));
    RxDbgTrace( 0, Dbg, ("  ->ByteOffset    = %08lx %08lx\n",
              OffsetAsLI->LowPart,
              OffsetAsLI->HighPart));
    RxLog(('kLz',3,SrvOpen, LengthAsLI->LowPart, OffsetAsLI->LowPart));

    ASSERT (proxySrvOpen->UnderlyingFileObject);

    CalldownIrp =  MRxBuildLockRequest (
                        NULL                                    ,//IN PIRP irp OPTIONAL,
                        proxySrvOpen->UnderlyingFileObject      ,//IN PFILE_OBJECT fileObject,
                        capReqPacket->Tail.Overlay.Thread                ,//IN PTHREAD UsersThread,
                        capPARAMS->MinorFunction                    ,//IN UCHAR MinorCode,
                        LowIoContext->ParamsFor.Locks.ByteOffset,//IN RXVBO ByteOffset,
                        LengthAsLI                              ,//IN PLARGE_INTEGER Length,
                        LowIoContext->ParamsFor.Locks.Key       ,//IN ULONG Key,
                        (UCHAR)LowIoContext->ParamsFor.Locks.Flags     ,//IN UCHAR Flags,
                        MRxProxyCalldownLockCompletion          ,//IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                        RxContext                               //IN PVOID Context OPTIONAL
                        );


    if (!CalldownIrp){
        Status = RxContext->StoredStatus = (STATUS_INSUFFICIENT_RESOURCES);
        return(Status);
    }

    Status = RxContext->StoredStatus =
           IoCallDriver(
                 proxySrvOpen->UnderlyingDeviceObject,
                 CalldownIrp
                 );

    if (Status != (STATUS_PENDING)) {
        //copy up the status
        capReqPacket->IoStatus = CalldownIrp->IoStatus;
    }

    RxDbgTrace ( 0, Dbg, (" ---->Initial Status           = %08lx\n", Status));
    RxDbgTrace(-1, Dbg, (" ------> Initial Block status/Info    = %08lx %08lx\n",
                                    capReqPacket->IoStatus.Status, capReqPacket->IoStatus.Information));

    return(Status);
}


NTSTATUS
MRxProxyAssertLockCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine for calldown ios like querydirectory. the rub is that we
    turned synchronous opens into async opens. what we do here is set an event (in the case of a pended
    packet for a sync that we turned async) OR copyup the status;complete;free in the case of a call
    that was always async.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    CalldownIrp - Pointer to I/O request packet used to call down to the underlying filesystem

    Context - Irpcontext of the original request to the rdbss

Return Value:

    NTSTATUS - If (STATUS_MORE_PROCESSING_REQUIRED) is returned.


--*/

{
    PKEVENT Event = Context;

    RxDbgTrace ( 0, Dbg, ("  MRxProxyAssertLockCompletion           = %08lx\n", 0));

    if (CalldownIrp->PendingReturned){
        KeSetEvent( Event, 0, FALSE );
    }

    return((STATUS_MORE_PROCESSING_REQUIRED));
}


NTSTATUS
MRxProxyAssertBufferedFileLocks (
    IN PSRV_OPEN SrvOpen
    )

/*++

Routine Description:

    This routine is called to assert all buffered file locks on a srvopen.


Arguments:

    SrvOpen - Supplies the file whose locks are to be asserted.


Return Value:

    NTSTATUS - Status of operation.


--*/

{
    NTSTATUS Status;
    PFILE_LOCK_INFO FileLock;
    PFCB Fcb = SrvOpen->Fcb;

    PIRP CalldownIrp = NULL;

    PMRX_LOCAL_SRV_OPEN proxySrvOpen = (PMRX_LOCAL_SRV_OPEN)SrvOpen;

    UCHAR Flags;
    BOOLEAN Wait = TRUE;

    PKEVENT Event;

    PAGED_CODE();

    RxDbgTrace (+1, Dbg, ("MRxProxyAssertBufferedFileLocks SrvOpen = %08lx", SrvOpen));
    ASSERT (proxySrvOpen->UnderlyingFileObject);

    Event = RxAllocatePoolWithTag( NonPagedPool, sizeof(KEVENT), 'LAxR' );
    if (!CalldownIrp){
        Status = (STATUS_INSUFFICIENT_RESOURCES);
        return(Status);
    }

    try {
        for (FileLock = FsRtlGetNextFileLock(&Fcb->Specific.Fcb.FileLock, TRUE);
                  FileLock != NULL;
                        FileLock = FsRtlGetNextFileLock(&Fcb->Specific.Fcb.FileLock, FALSE)) {

            RxDbgTrace (0, Dbg, ("MRxProxyAssertBufferedFileLocks Exclusive = %08lx, Key = %08lx\n",
                      FileLock->ExclusiveLock,
                      FileLock->Key));
            RxDbgTrace( 0, Dbg, ("  ->Length     = %08lx %08lx\n",
                      FileLock->Length.LowPart,
                      FileLock->Length.HighPart));
            RxDbgTrace( 0, Dbg, ("  ->ByteOffset    = %08lx %08lx\n",
                      FileLock->StartingByte.LowPart,
                      FileLock->StartingByte.HighPart));

            if (FileLock->ExclusiveLock) {
                Flags = SL_EXCLUSIVE_LOCK | SL_FAIL_IMMEDIATELY;
            } else {
                Flags = SL_FAIL_IMMEDIATELY;
            }

            //joejoe we should reuse the irp.........
            CalldownIrp =  MRxBuildLockRequest (
                                NULL                                ,//IN PIRP irp OPTIONAL,
                                proxySrvOpen->UnderlyingFileObject  ,//IN PFILE_OBJECT fileObject,
                                proxySrvOpen->OriginalThread        ,//IN PTHREAD UsersThread,
                                IRP_MN_LOCK                         ,//IN UCHAR MinorCode,
                                FileLock->StartingByte.QuadPart     ,//IN RXVBO ByteOffset,
                                &FileLock->Length                   ,//IN PLARGE_INTEGER Length,
                                FileLock->Key                       ,//IN ULONG Key,
                                Flags                               ,//IN UCHAR Flags,
                                MRxProxyAssertLockCompletion        ,//IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                                &Event                                //IN PVOID Context OPTIONAL
                                );

            if (!CalldownIrp){
                Status = (STATUS_INSUFFICIENT_RESOURCES);
                try_return(Status);
            }

            CalldownIrp->Flags |= IRP_SYNCHRONOUS_API;

            KeInitializeEvent( Event, SynchronizationEvent, FALSE );

            Status = IoCallDriver(
                         proxySrvOpen->UnderlyingDeviceObject,
                         CalldownIrp
                         );

            if (Status == (STATUS_PENDING)) {
                KeWaitForSingleObject(Event, UserRequest, KernelMode, FALSE, NULL);
                Status = CalldownIrp->IoStatus.Status;
            }

            RxDbgTrace ( 0, Dbg, (" ---->PerLock Status           = %08lx\n", Status));

        }

   try_exit:
        NOTHING;

    } finally {

        ExFreePool(Event);
        if (CalldownIrp) {
            IoFreeIrp(CalldownIrp);
        }
    }

    RxDbgTrace (-1, Dbg, ("--------->Final Status           = %08lx\n", Status));
    return Status;

}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\nvisible.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NVisible.h

Abstract:

    This module declares a number of flag variables that are essentially private
    to various modules but which are exposed so that they can be initialized from
    the registry and/or modified by fsctls. This should not be in precomp.h.

Revision History:

--*/

#ifndef _INVISIBLE_INCLUDED_
#define _INVISIBLE_INCLUDED_

extern ULONG MRxSmbNegotiateMask;  //controls which protocols are not negotiated

extern BOOLEAN MRxSmbDeferredOpensEnabled;
extern BOOLEAN MRxSmbOplocksDisabled;

#endif // _INVISIBLE_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\locks.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    locks.c

Abstract:

    This module implements the mini redirector call down routines pertaining to locks
    of file system objects.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

NTSTATUS
MRxProxyLocks(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for filelocks

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxyLocks\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    Status = STATUS_NOT_IMPLEMENTED;


    RxDbgTrace(-1, Dbg, ("MRxProxyLocks  exit with status=%08lx\n", Status ));
    return(Status);

}

#if 0
NTSTATUS
MRxProxyUnlockRoutine (
    IN PRX_CONTEXT RxContext,
    IN PFILE_LOCK_INFO LockInfo
    )
/*++

Routine Description:

    This routine is called from the RDBSS whenever the fsrtl lock package calls the rdbss unlock routine.
    CODE.IMPROVEMENT what should really happen is that this should only be called for unlockall and unlockbykey;
    the other cases should be handled in the rdbss.

Arguments:

    Context - the RxContext associated with this request
    LockInfo - gives information about the particular range being unlocked

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    switch (LowIoContext->Operation) {
    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
    case LOWIO_OP_UNLOCK:
       return STATUS_SUCCESS;
    case LOWIO_OP_UNLOCKALL:
    case LOWIO_OP_UNLOCKALLBYKEY:
    default:
       return STATUS_NOT_IMPLEMENTED;
    }
}
#endif


NTSTATUS
MRxProxyCompleteBufferingStateChangeRequest(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    )
/*++

Routine Description:

    This routine is called to assert the locks that the wrapper has buffered. currently, it is synchronous!


Arguments:

    RxContext - the open instance
    SrvOpen   - tells which fcb is to be used. CODE.IMPROVEMENT this param is redundant if the rxcontext is filled out completely

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PMRX_FCB Fcb = SrvOpen->pFcb;

    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxyCompleteBufferingStateChangeRequest\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RxDbgTrace(0,Dbg,("-->Context %lx\n",pContext));

    Status = STATUS_SUCCESS;

    RxDbgTrace(-1, Dbg, ("MRxProxyAssertBufferedFileLocks  exit with status=%08lx\n", Status ));
    return(Status);
}



NTSTATUS
MRxProxyIsLockRealizable (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    )
{

    PAGED_CODE();
    return(STATUS_SUCCESS);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\mrxglbl.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mrxglbl.h

Abstract:

    The global include file for PROXY mini redirector

Author:

    Balan Sethu Raman (SethuR) - Created  2-March-95

Revision History:

--*/

#ifndef _MRXGLBL_H_
#define _MRXGLBL_H_

#define ProxyCeLog(x) \
        RxLog(x)

#define RxNetNameTable (*(*___MINIRDR_IMPORTS_NAME).pRxNetNameTable)

//we turn away async operations that are not wait by posting. if we can wait
//then we turn off the sync flag so that things will just act synchronous
#define TURN_BACK_ASYNCHRONOUS_OPERATIONS() {                              \
    if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {        \
        if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT)) {               \
            ClearFlag(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)    \
        } else {                                                           \
            RxContext->PostRequest = TRUE;                                 \
            return STATUS_PENDING;                                     \
        }                                                                  \
    }                                                                      \
  }

extern RX_SPIN_LOCK MRxProxyGlobalSpinLock;
extern KIRQL      MRxProxyGlobalSpinLockSavedIrql;
extern BOOLEAN    MRxProxyGlobalSpinLockAcquired;
#define ProxyAcquireGlobalSpinLock() \
                KeAcquireSpinLock(&MRxProxyGlobalSpinLock,&MRxProxyGlobalSpinLockSavedIrql);   \
                MRxProxyGlobalSpinLockAcquired = TRUE

#define ProxyReleaseGlobalSpinLock()   \
                MRxProxyGlobalSpinLockAcquired = FALSE;                                  \
                KeReleaseSpinLock(&MRxProxyGlobalSpinLock,MRxProxyGlobalSpinLockSavedIrql)

#define ProxyGlobalSpinLockAcquired()   \
                (MRxProxyGlobalSpinLockAcquired == TRUE)


//extern
//NTSTATUS
//GetProxyResponseNtStatus(PPROXY_HEADER pProxyHeader);


#endif _MRXGLBL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\innerio.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    MRxProxyAsyncEng.h

Abstract:

    This module defines the types and functions related to the SMB protocol
    selection engine: the component that translates minirdr calldowns into
    SMBs.

Revision History:

--*/

#ifndef _INNERIO_H_
#define _INNERIO_H_

NTSTATUS
MRxProxyBuildAsynchronousRequest(
    IN PRX_CONTEXT RxContext,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL
    );

#endif // _INNERIO_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\fileinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the mini redirector call down routines pertaining to retrieval/
    update of file/directory/volume information.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

RXDT_DefineCategory(VOLINFO);
#undef Dbg
#define Dbg        (DEBUG_TRACE_VOLINFO)

NTSTATUS
MRxProxyQueryVolumeInformation(
      IN OUT PRX_CONTEXT          RxContext
      )
/*++

Routine Description:

   This routine queries the volume information

Arguments:

    pRxContext         - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_PROXY_SRV_OPEN proxySrvOpen;

    FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;
    PVOID                pBuffer = RxContext->Info.Buffer;
    PLONG                pLengthRemaining  = &RxContext->Info.LengthRemaining;

    PFILE_OBJECT FileObject;
    ULONG PassedInLength,ReturnedLength;

    PAGED_CODE();

    if (capFobx == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

    proxySrvOpen = MRxProxyGetSrvOpenExtension(capFobx->pSrvOpen);
    FileObject = proxySrvOpen->UnderlyingFileObject;
    ASSERT (FileObject);
    PassedInLength = *pLengthRemaining;
    Status = MRxProxySyncXxxInformation(
                        RxContext,            //IN OUT PRX_CONTEXT RxContext,
                        IRP_MJ_QUERY_VOLUME_INFORMATION,  //IN UCHAR MajorFunction,
                        FileObject,           //IN PFILE_OBJECT FileObject,
                        FsInformationClass,   //IN ULONG InformationClass,
                        PassedInLength,       //IN ULONG Length,
                        pBuffer,              //OUT PVOID Information,
                        &ReturnedLength       //OUT PULONG ReturnedLength OPTIONAL
                        );


    if (!NT_ERROR(Status)) {
        *pLengthRemaining -= ReturnedLength;
    }

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxProxyQueryVolumeInformation: Failed .. returning %lx\n",Status));
    }

    return Status;
}

NTSTATUS
MRxProxySetVolumeInformation(
      IN OUT PRX_CONTEXT              pRxContext
      )
/*++

Routine Description:

   This routine sets the volume information

Arguments:

    pRxContext - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    BufferLength       - the buffer length

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    //FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;
    //PVOID                pBuffer = RxContext->Info.Buffer;
    //LONG                 BufferLength = RxContext->Info.Length;
    return STATUS_NOT_IMPLEMENTED;
}

RXDT_DefineCategory(FILEINFO);
#undef Dbg
#define Dbg        (DEBUG_TRACE_FILEINFO)


NTSTATUS
MRxProxyQueryFileInformation(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a query file info.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID              pBuffer;
    PULONG             pLengthRemaining;

    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(capFobx->pSrvOpen);
    //PMRX_PROXY_FCB proxyFcb = MRxProxyGetFcbExtension(capFcb);


    PFILE_OBJECT FileObject;
    ULONG PassedInLength,ReturnedLength;

    PUNICODE_STRING RemainingName = &(capFcb->AlreadyPrefixedName);
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg, ("MRxProxyQueryFileInformation: class=%08lx\n",FileInformationClass));

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

    FileObject = proxySrvOpen->UnderlyingFileObject;
    ASSERT (FileObject);
    PassedInLength = *pLengthRemaining;
    Status = MRxProxySyncXxxInformation(
                        RxContext,            //IN OUT PRX_CONTEXT RxContext,
                        IRP_MJ_QUERY_INFORMATION,  //IN UCHAR MajorFunction,
                        FileObject,           //IN PFILE_OBJECT FileObject,
                        FileInformationClass, //IN ULONG InformationClass,
                        PassedInLength,       //IN ULONG Length,
                        pBuffer,              //OUT PVOID Information,
                        &ReturnedLength       //OUT PULONG ReturnedLength OPTIONAL
                        );

    if (!NT_ERROR(Status)) {
        *pLengthRemaining -= ReturnedLength;
    }

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxProxyQueryFile: Failed .. returning %lx\n",Status));
    }
    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}


typedef enum _INTERESTING_SFI_FOLLOWONS {
    SFI_FOLLOWON_NOTHING,
    SFI_FOLLOWON_DISPOSITION_SENT
} INTERESTING_SFI_FOLLOWONS;

#if DBG
VOID
MRxProxyDumpRenameInfo (
    PSZ Msg,
    PFILE_RENAME_INFORMATION RenameInfo,
    ULONG BufferLength
    )
{
    UNICODE_STRING sss;

    sss.Buffer = &RenameInfo->FileName[0];
    sss.Length = ((USHORT)(RenameInfo->FileNameLength));
    RxDbgTrace(0, Dbg, ("MRxProxyDumpRenameInfo: %s %08lx %wZ\n",Msg,BufferLength,&sss));

}
#else
#define MRxProxyDumpRenameInfo(a,b,c);
#endif


NTSTATUS
MRxProxySetFileInformation(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a set file info.
   it works by just remoting the call basically without further ado.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID                  pBuffer;
    ULONG                  BufferLength;
    //PMRX_PROXY_FOBX proxyFobx = MRxProxyGetFileObjectExtension(capFobx);
    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(capFobx->pSrvOpen);
    //PMRX_PROXY_FCB proxyFcb = MRxProxyGetFcbExtension(capFcb);
    PFILE_OBJECT UnderlyingFileObject = proxySrvOpen->UnderlyingFileObject;

    PAGED_CODE();

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();


    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    BufferLength = RxContext->Info.Length;
    RxDbgTrace(+1, Dbg, ("MRxProxySetFile: Class %08lx size %08lx\n",FileInformationClass,BufferLength));

    if (FileInformationClass==FileRenameInformation) {
        PFILE_RENAME_INFORMATION RenameInfo = (PFILE_RENAME_INFORMATION)pBuffer;
        if (RenameInfo->FileName[0] == L'\\') {
            //here, we have to carefully copy the the rename prefix
            PWCHAR w;
            PMRXPROXY_DEVICE_OBJECT MRxProxyDeviceObject = (PMRXPROXY_DEVICE_OBJECT)(RxContext->RxDeviceObject);
            PUNICODE_STRING RenamePrefix = &MRxProxyDeviceObject->PrefixForRename;
            ULONG prefixlength;

            MRxProxyDumpRenameInfo("Before:",RenameInfo,BufferLength);

            prefixlength = (RenamePrefix->Length)/sizeof(WCHAR);
            w = (&(RenameInfo->FileName[0])) + ((RenameInfo->FileNameLength)/sizeof(WCHAR));
            for (;;) {
                w--;
                //DbgPrint ("yaya %c\n",*w);
                *(w+prefixlength) = *w;
                if ( w == (&(RenameInfo->FileName[0])) ) {
                    break;
                }
            }
            RtlCopyMemory(&(RenameInfo->FileName[0]),RenamePrefix->Buffer,RenamePrefix->Length);
            RenameInfo->FileNameLength += RenamePrefix->Length;
            BufferLength += RenamePrefix->Length;

            MRxProxyDumpRenameInfo(" After:",RenameInfo,BufferLength);
            //DbgBreakPoint();
        }
    }

    if(BufferLength==0){
        //zero length means that this is the special calldown from the cachemanager...for now just boost
        //joejoe this should be fixed soon
        BufferLength = sizeof(FILE_END_OF_FILE_INFORMATION);
    }

    RxDbgTrace( 0, Dbg, (" ---->UserBuffer           = %08lx\n", pBuffer));
    ASSERT (UnderlyingFileObject);

    //this could be a setfileinfo that comes in from the lazywriter
    //after the underlying file has already been cleaned up
    //BUGBUG not too sure about this...........
    if (UnderlyingFileObject == NULL) {
        Status = STATUS_FILE_CLOSED;
        RxDbgTrace(-1, Dbg, (" ---->AlreadyClosed!!! Status = %08lx\n", Status));
        return(Status);
    }

    Status = MRxProxySyncXxxInformation(
                        RxContext,            //IN OUT PRX_CONTEXT RxContext,
                        IRP_MJ_SET_INFORMATION,  //IN UCHAR MajorFunction,
                        UnderlyingFileObject, //IN PFILE_OBJECT FileObject,
                        FileInformationClass, //IN ULONG InformationClass,
                        BufferLength,         //IN ULONG Length,
                        pBuffer,              //OUT PVOID Information,
                        NULL                  //OUT PULONG ReturnedLength OPTIONAL
                        );

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxProxySetFile: Failed .. returning %lx\n",Status));
    }
    RxDbgTraceUnIndent(-1,Dbg);
    return Status;

}

NTSTATUS
MRxProxySetFileInformationAtCleanup(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine sets the file information on cleanup. rdrs just swallow this operation (i.e.
   it doesn't generate it). we cannot do the same because we are local..........

   This routine implements the set file info call called on cleanup or flush. We dont actually set the times
   but we do the endoffile info.

Arguments:

    pRxContext           - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    FILE_INFORMATION_CLASS FileInformationClass;

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

    FileInformationClass = RxContext->Info.FileInformationClass;
    if (FileInformationClass == FileBasicInformation) {
        return(STATUS_SUCCESS);
    }
    RxDbgTrace(+1, Dbg, ("MRxLocalSetFileInfoAtCleanup...\n"));
    Status = MRxProxySetFileInformation(RxContext);
    RxDbgTrace(-1, Dbg, ("MRxLocalSetFileInfoAtCleanup...status =%08lx\n", Status));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\proxymrx.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    proxymrx.h

Abstract:

    The global include file for PROXY mini redirector

Author:

    Balan Sethu Raman (SethuR) - Created  2-March-95

Revision History:

--*/

#ifndef _PROXYMRX_H_
#define _PROXYMRX_H_


#include "align.h"

#include "status.h"

#include "mrxglbl.h"    // global data declarations/defines etc.
#include "pxypoolt.h"   // Pool tag definitions
#include "asynceng.h"

#pragma warning(error:4101)   // Unreferenced local variable

//mini's does use these
#undef RxCaptureRequestPacket
#undef RxCaptureParamBlock

#ifdef RX_PRIVATE_BUILD
#if 1
#ifdef RDBSSTRACE
extern ULONG MRxProxyDbgPrintF;
#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) { if(MRxProxyDbgPrintF){DbgPrint __d__;}}
#undef RxDbgTraceLV
#define RxDbgTraceLV(a,b,c,__d__) { if(MRxProxyDbgPrintF){DbgPrint __d__;}}
#undef RxDbgTraceUnIndent
#define RxDbgTraceUnIndent(a,b) {NOTHING;}
#endif //#ifdef RDBSSTRACE
#endif //if 1
#endif //ifdef RX_PRIVATE_BUILD



extern ULONG MRxProxyLoudStringTableSize;
extern UNICODE_STRING MRxProxyLoudStrings[50];

VOID
MRxProxySetLoud(
    IN PBYTE Msg,
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING s
    );

VOID
MRxProxyInitializeLoudStrings(
    void
    );
//

typedef struct _MRXPROXY_DEVICE_OBJECT {
    union {
        RDBSS_DEVICE_OBJECT;
        RDBSS_DEVICE_OBJECT RxDeviceObject;
    };
    UNICODE_STRING InnerPrefixForOpens;
    UNICODE_STRING PrefixForRename;
} MRXPROXY_DEVICE_OBJECT, *PMRXPROXY_DEVICE_OBJECT;

//TEMPORARY
#define MRXPROXY_PREFIX_FOR_RENAME     L"\\CC$$WRAP"
#define MRXPROXY_INNERPREFIX_FOR_OPENS L"\\??\\C:\\CC$$WRAP"

extern PMRXPROXY_DEVICE_OBJECT MRxProxyDeviceObject;

//
//  a pointer to the process that the rdbss posts to.....this is a nondisappearing process!
extern PEPROCESS MRxProxySystemProcess;

//
// a serialization mutex used for various things........

extern FAST_MUTEX MRxProxySerializationMutex;


//
// A pointer to an instance of MRX_PROXY_FCB is stored in the context field of
// MRX_FCBs handled by the PROXY mini rdr.

typedef struct _MRX_PROXY_FCB_ {
    //M for Minirdr  CODE.IMPROVEMENT should this be moved into the FCB itself?
    ULONG MFlags;
    ULONG WriteOnlySrvOpenCount;
} MRX_PROXY_FCB, *PMRX_PROXY_FCB;

#define MRxProxyGetFcbExtension(pFcb)      \
        (((pFcb) == NULL) ? NULL : (PMRX_PROXY_FCB)((pFcb)->Context))

#define PROXY_FCB_FLAG_SENT_DISPOSITION_INFO     0x00000001

typedef struct _PROXYPSE_FILEINFO_BUNDLE {
    FILE_BASIC_INFORMATION Basic;
    FILE_STANDARD_INFORMATION Standard;
} PROXYPSE_FILEINFO_BUNDLE, *PPROXYPSE_FILEINFO_BUNDLE;

typedef struct _MRXPROXY_CREATE_PARAMETERS {
    //this is done this way for when this expands...as it's likely too
    //CODE.IMPROVEMENT for example, we should put the mapped stuff in here
    ULONG Pid;
    UCHAR SecurityFlags;
} MRXPROXY_CREATE_PARAMETERS, *PMRXPROXY_CREATE_PARAMETERS;

typedef struct _MRX_PROXY_DEFERRED_OPEN_CONTEXT {
    NT_CREATE_PARAMETERS NtCreateParameters; // a copy of the createparameters
    ULONG RxContextFlags;
    MRXPROXY_CREATE_PARAMETERS ProxyCp;
    USHORT RxContextCreateFlags;
} MRX_PROXY_DEFERRED_OPEN_CONTEXT, *PMRX_PROXY_DEFERRED_OPEN_CONTEXT;

//
// A pointer to an instance of MRX_PROXY_SRV_OPEN is stored in the context fields
// of MRX_SRV_OPEN handled by the PROXY mini rdr. This encapsulates the FID used
// to identify open files/directories in the PROXY protocol.

typedef struct _MRX_PROXY_SRV_OPEN {
    ULONG       Flags;
    HANDLE UnderlyingHandle;
    PFILE_OBJECT UnderlyingFileObject;
    PDEVICE_OBJECT UnderlyingDeviceObject;
    ULONG NumberOfQueryDirectories;
#if 0
SMBMINI stuff
   ULONG       Version;

   PMRX_PROXY_DEFERRED_OPEN_CONTEXT DeferredOpenContext;

   // the following fields are used for to save the results of a GetFileAttributes
   // and to validate whether the fields should be reused or not

   ULONG                  RxContextSerialNumber;
   LARGE_INTEGER          TimeStampInTicks;
   PROXYPSE_FILEINFO_BUNDLE FileInfo;
#endif //0
    //PETHREAD OriginalThread;  //this is used to assert filelocks on oplockbreak
    //PEPROCESS OriginalProcess; //this is just used in asserts...joejoe should be DBG
    //localmini MINIRDR_OPLOCK_STATE OplockState;
    //localmini PMINIRDR_OPLOCK_COMPLETION_CONTEXT Mocc;
} MRX_PROXY_SRV_OPEN, *PMRX_PROXY_SRV_OPEN;

#define MRxProxyGetSrvOpenExtension(pSrvOpen)  \
        (((pSrvOpen) == NULL) ? NULL : (PMRX_PROXY_SRV_OPEN)((pSrvOpen)->Context))

#define PROXY_SRVOPEN_FLAG_NOT_REALLY_OPEN     0x00000001
#define PROXY_SRVOPEN_FLAG_CANT_GETATTRIBS     0x00000004
#define PROXY_SRVOPEN_FLAG_DEFERRED_OPEN       0x00000008
#define PROXY_SRVOPEN_FLAG_WRITE_ONLY_HANDLE   0x00000008

typedef USHORT PROXY_SEARCH_HANDLE;

typedef struct _MRX_PROXY_DIRECTORY_RESUME_INFO {
   //REQ_FIND_NEXT2 FindNext2_Request;
   //now we have to include space for a resume name........
   WCHAR NameSpace[MAXIMUM_FILENAME_LENGTH+1]; //trailing null
   USHORT ParametersLength;
} MRX_PROXY_DIRECTORY_RESUME_INFO, *PMRX_PROXY_DIRECTORY_RESUME_INFO;

// A pointer to an instance of MRX_PROXY_FOBX is stored in the context field
// of MRX_FOBXs handled by the PROXY mini rdr. Depending upon the file type
// i.e., file or directory the appropriate context information is stored.

typedef struct _MRX_PROXY_FOBX_ {
   union {
       struct {
           struct {
               PROXY_SEARCH_HANDLE SearchHandle;
               ULONG Version;
               union {
                   //the close code will try to free this!
                   //PMRX_PROXY_DIRECTORY_RESUME_INFO ResumeInfo;
                   //PPROXY_RESUME_KEY CoreResumeKey;
                   ULONG Dummy;
               };
               struct {
                   //unaligned direntry sidebuffering params
                   PBYTE UnalignedDirEntrySideBuffer;    //close will try to free this too
                   ULONG SerialNumber;
                   BOOLEAN EndOfSearchReached;
                   BOOLEAN IsUnicode;
                   BOOLEAN IsNonNtT2Find;
                   ULONG   FilesReturned;
                   ULONG EntryOffset;
                   ULONG TotalDataBytesReturned;
                   //ULONG ReturnedEntryOffset;
               };
           };
           NTSTATUS ErrorStatus;
           USHORT Flags;
           USHORT FileNameOffset;
           USHORT FileNameLengthOffset;
           BOOLEAN WildCardsFound;
       } Enumeration;
   };
   union {
       struct {
           //dont do this yet
           //ULONG MaximumReadBufferLength;
           //ULONG MaximumWriteBufferLength;
           USHORT Flags;
       } File;
   };
} MRX_PROXY_FOBX, *PMRX_PROXY_FOBX;

#define MRxProxyGetFileObjectExtension(pFobx)  \
        (((pFobx) == NULL) ? NULL : (PMRX_PROXY_FOBX)((pFobx)->Context))

#define PROXYFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST    0x0001
#define PROXYFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN      0x0002
#define PROXYFOBX_ENUMFLAG_FAST_RESUME             0x0004
#define PROXYFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS 0x0008
#define PROXYFOBX_ENUMFLAG_LOUD_FINALIZE           0x0010

typedef
NTSTATUS
(NTAPI *PMRXPROXY_CANCEL_ROUTINE) (
      PRX_CONTEXT pRxContext);

// The RX_CONTEXT instance has four fields ( ULONG's ) provided by the wrapper
// which can be used by the mini rdr to store its context. This is used by
// the PROXY mini rdr to identify the parameters for request cancellation

typedef struct _MRXPROXY_RX_CONTEXT {
    PMRXPROXY_CANCEL_ROUTINE      pCancelRoutine;
    PVOID                         pCancelContext;
    union {
        struct {
            PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext;
            PVOID                         SPARE;
        };
        struct {
            PVOID     PostedOpContext;
            NTSTATUS  PostedOpStatus;
        };
        IO_STATUS_BLOCK SyncCallDownIoStatus;
    };
} MRXPROXY_RX_CONTEXT, *PMRXPROXY_RX_CONTEXT;


#define MRxProxyGetMinirdrContext(pRxContext)     \
        ((PMRXPROXY_RX_CONTEXT)(&(pRxContext)->MRxContext[0]))

#define MRxProxyMakeSrvOpenKey(Tid,Fid) \
        (PVOID)(((ULONG)(Tid) << 16) | (ULONG)(Fid))

//
// forward declarations for all dispatch vector methods.
//

NTSTATUS
MRxProxyStart (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
MRxProxyStop (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
MRxProxyMinirdrControl (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PVOID pContext,
    IN OUT PUCHAR SharedBuffer,
    IN     ULONG InputBufferLength,
    IN     ULONG OutputBufferLength,
    OUT PULONG CopyBackLength
    );

NTSTATUS
MRxProxyDevFcb (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyCreate (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyCollapseOpen (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyShouldTryToCollapseThisOpen (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyRead (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyWrite (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyLocks(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyFlush(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyFsCtl(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyIoCtl(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyNotifyChangeDirectory(
    IN OUT PRX_CONTEXT RxContext
    );

#if 0
NTSTATUS
MRxProxyUnlockRoutine (
    IN OUT PRX_CONTEXT RxContext,
    IN     PFILE_LOCK_INFO LockInfo
    );
#endif

NTSTATUS
MRxProxyComputeNewBufferingState(
    IN OUT PMRX_SRV_OPEN pSrvOpen,
    IN     PVOID         pMRxContext,
       OUT ULONG         *pNewBufferingState);

NTSTATUS
MRxProxyFlush (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyCloseWithDelete (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyZeroExtend (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyTruncate (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyCleanupFobx (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyCloseSrvOpen (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyClosedSrvOpenTimeOut (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyQueryDirectory (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxySetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxProxyQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxySetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxProxyQueryVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxySetVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyLowIOSubmit (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxProxyCreateVNetRoot(
    IN OUT PMRX_V_NET_ROOT            pVirtualNetRoot,
    IN OUT PMRX_CREATENETROOT_CONTEXT pContext
    );

NTSTATUS
MRxProxyFinalizeVNetRoot(
    IN OUT PMRX_V_NET_ROOT pVirtualNetRoot,
    IN     PBOOLEAN    ForceDisconnect);

NTSTATUS
MRxProxyFinalizeNetRoot(
    IN OUT PMRX_NET_ROOT pNetRoot,
    IN     PBOOLEAN      ForceDisconnect);

NTSTATUS
MRxProxyUpdateNetRootState(
    IN  PMRX_NET_ROOT pNetRoot);

VOID
MRxProxyExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

NTSTATUS
MRxProxyCreateSrvCall(
      PMRX_SRV_CALL                      pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext);

NTSTATUS
MRxProxyFinalizeSrvCall(
      PMRX_SRV_CALL    pSrvCall,
      BOOLEAN    Force);

NTSTATUS
MRxProxySrvCallWinnerNotify(
      IN OUT PMRX_SRV_CALL      pSrvCall,
      IN     BOOLEAN        ThisMinirdrIsTheWinner,
      IN OUT PVOID          pSrvCallContext);

NTSTATUS
MRxProxyQueryFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

NTSTATUS
MRxProxyQueryNamedPipeInformation (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID              Buffer,
    IN OUT PULONG             pLengthRemaining
    );

NTSTATUS
MRxProxySetFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

NTSTATUS
MRxProxySetNamedPipeInformation (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN     PVOID              pBuffer,
    IN     ULONG              BufferLength
    );

NTSTATUS
MRxProxySetFileInformationAtCleanup(
      IN OUT PRX_CONTEXT            RxContext
      );

NTSTATUS
MRxProxyDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
MRxProxyDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    );

NTSTATUS
MRxProxyIsLockRealizable (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    );

NTSTATUS
MRxProxyForcedClose (
    IN OUT PMRX_SRV_OPEN SrvOpen
    );

NTSTATUS
MRxProxyExtendForCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

NTSTATUS
MRxProxyExtendForNonCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

NTSTATUS
MRxProxyCompleteBufferingStateChangeRequest (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    );

#if 0
NTSTATUS
MRxProxyTransportUpdateHandler(
    PRXCE_TRANSPORT_NOTIFICATION pTransportNotification
    );
#endif

//other misc prototypes

//CODE.IMPROVEMENT.NTIFS this should be in ntifs.h
NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );


NTSTATUS
MRxProxySyncXxxInformation(
    IN OUT PRX_CONTEXT RxContext,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength OPTIONAL
    );

#endif   // _PROXYMRX_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\netroot.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    netroot.c

Abstract:

    This module implements the routines for creating the PROXY net root.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId  (RDBSS_BUG_CHECK_PROXY_NETROOT)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

//
// Forward declarations ...
//

NTSTATUS
MRxProxyUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot)
/*++

Routine Description:

   This routine update the mini redirector state associated with a net root.

Arguments:

    pNetRoot - the net root instance.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
   if (pNetRoot->Context == NULL) {
      pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
   } else {
      pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;
   }

   return STATUS_SUCCESS;
}


NTSTATUS
MRxProxyCreateVNetRoot(
    IN OUT PMRX_V_NET_ROOT        pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

   This routine patches the RDBSS created net root instance with the information required
   by the mini redirector.

Arguments:

    pVNetRoot - the virtual net root instance.

    pCreateNetRootContext - the net root context for calling back

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    //NTSTATUS  Status;
    PRX_CONTEXT pRxContext = pCreateNetRootContext->RxContext;
    PMRXPROXY_DEVICE_OBJECT MRxProxyDeviceObject = (PMRXPROXY_DEVICE_OBJECT)(pRxContext->RxDeviceObject);

    PMRX_SRV_CALL pSrvCall;
    PMRX_NET_ROOT pNetRoot;

    RxDbgTrace( 0, Dbg, ("MRxProxyCreateVNetRoot %lx\n",pVNetRoot));
    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;

    ASSERT((NodeType(pNetRoot) == RDBSS_NTC_NETROOT) &&
           (NodeType(pSrvCall) == RDBSS_NTC_SRVCALL));


    pNetRoot->InnerNamePrefix = MRxProxyDeviceObject->InnerPrefixForOpens;
    pNetRoot->DiskParameters.RenameInfoOverallocationSize = MRxProxyDeviceObject->PrefixForRename.Length;
    pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
    pCreateNetRootContext->NetRootStatus = STATUS_SUCCESS;

    // Callback the RDBSS for resumption.
    pCreateNetRootContext->Callback(pCreateNetRootContext);

    // Map the error code to STATUS_PENDING since this triggers the synchronization
    // mechanism in the RDBSS.
    return STATUS_PENDING;

}

NTSTATUS
MRxProxyFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    RxDbgTrace( 0, Dbg, ("MRxProxyFinalizeVNetRoot %lx\n",pVNetRoot));

    //return STATUS_SUCCESS;
    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
MRxProxyFinalizeNetRoot(
    IN PMRX_NET_ROOT   pNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVirtualNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RxDbgTrace( 0, Dbg, ("MRxProxyFinalizeNetRoot %lx\n",pNetRoot));

    //return STATUS_SUCCESS;
    return STATUS_NOT_IMPLEMENTED;
}

VOID
ProxyCeReconnectCallback(
   PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext)
/*++

Routine Description:

   This routine signals the completion of a reconnect attempt

Arguments:

    pCreateNetRootContext - the net root context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   KeSetEvent(&pCreateNetRootContext->FinishEvent, IO_NETWORK_INCREMENT, FALSE );
}

NTSTATUS
ProxyCeReconnect(
    IN PMRX_V_NET_ROOT            pVNetRoot)
/*++

Routine Description:

   This routine reconnects, i.e, establishes a new session and tree connect to a previously
   connected serverb share

Arguments:

    pVNetRoot - the virtual net root instance.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   NTSTATUS Status;

   PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext;

   pCreateNetRootContext = (PMRX_CREATENETROOT_CONTEXT)
                           RxAllocatePoolWithTag(
                               NonPagedPool,
                               sizeof(MRX_CREATENETROOT_CONTEXT),
                               MRXPROXY_NETROOT_POOLTAG);

   if (pCreateNetRootContext != NULL) {
      pCreateNetRootContext->NetRootStatus  = STATUS_SUCCESS;
      pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
      pCreateNetRootContext->Callback       = ProxyCeReconnectCallback;
      pCreateNetRootContext->RxContext      = NULL;
      KeInitializeEvent( &pCreateNetRootContext->FinishEvent, SynchronizationEvent, FALSE );


      // Since this is a reconnect instance the net root initialization is not required
#if 0
      Status = ProxyCeEstablishConnection(
                   pVNetRoot,
                   pCreateNetRootContext,
                   FALSE);
#endif
      Status = STATUS_SUCCESS;

      if (Status == STATUS_PENDING) {
         // Wait for the construction to be completed.
         KeWaitForSingleObject(&pCreateNetRootContext->FinishEvent, Executive, KernelMode, FALSE, NULL);
         Status = pCreateNetRootContext->VirtualNetRootStatus;
      }

      RxFreePool(pCreateNetRootContext);
   } else {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   return Status;
}


NTSTATUS
ProxyCeEstablishConnection(
    IN OUT PMRX_V_NET_ROOT        pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext,
    IN BOOLEAN                    fInitializeNetRoot
    )
/*++

Routine Description:

   This routine triggers off the connection attempt for initial establishment of a
   connection as well as subsequent reconnect attempts.

Arguments:

    pVNetRoot - the virtual net root instance.

    pCreateNetRootContext - the net root context for calling back

Return Value:

    RXSTATUS - The return status for the operation

Notes:
    CODE.IMPROVEMENT --  The net root create context must supply the open mode in order
    to enable the mini redirector to implement a wide variety of reconnect strategies.

--*/
{
   NTSTATUS                Status;
#if 0
   PPROXYCEDB_SERVER_ENTRY     pServerEntry;
   PPROXYCEDB_SESSION_ENTRY    pSessionEntry;
   PPROXYCEDB_NET_ROOT_ENTRY   pNetRootEntry;
   PPROXYCE_V_NET_ROOT_CONTEXT pVNetRootContext;

   pVNetRootContext = ProxyCeGetAssociatedVNetRootContext(pVNetRoot);
   if (pVNetRootContext == NULL) {
       Status = STATUS_BAD_NETWORK_PATH;
   } else {
       pServerEntry  = pVNetRootContext->pServerEntry;
       pSessionEntry = pVNetRootContext->pSessionEntry;
       pNetRootEntry = pVNetRootContext->pNetRootEntry;
       Status = STATUS_SUCCESS;
   }

   if (Status != STATUS_SUCCESS) {
      return Status;
   }

   if ((pServerEntry->Server.DialectFlags & DF_EXTENDED_SECURITY) &&
       (pSessionEntry->Header.State != PROXYCEDB_ACTIVE)) {
      PPROXY_EXCHANGE pSessionSetupExchange;

      pSessionSetupExchange = ProxyMmAllocateExchange(EXTENDED_SESSION_SETUP_EXCHANGE,NULL);
      if (pSessionSetupExchange != NULL) {
         Status = ProxyCeInitializeExtendedSessionSetupExchange(
                              &pSessionSetupExchange,
                              pVNetRoot);

         if (Status == STATUS_SUCCESS) {
             PROXYCE_RESUMPTION_CONTEXT ExchangeResumptionContext;
            // Attempt to reconnect( In this case it amounts to establishing the
            // connection/session)
            pSessionSetupExchange->ProxyCeFlags |= PROXYCE_EXCHANGE_ATTEMPT_RECONNECTS;

            ProxyCeInitializeResumptionContext(&ExchangeResumptionContext);

            ((PPROXY_EXTENDED_SESSION_SETUP_EXCHANGE)pSessionSetupExchange)->pResumptionContext
              = &ExchangeResumptionContext;

            Status = ProxyCeInitiateExchange(pSessionSetupExchange);

            if (Status == STATUS_PENDING) {
               ProxyCeSuspend(
                   &ExchangeResumptionContext);

               Status = ExchangeResumptionContext.Status;
            } else {
                ProxyCeDiscardExtendedSessionSetupExchange(
                    (PPROXY_EXTENDED_SESSION_SETUP_EXCHANGE)pSessionSetupExchange);
            }
         } else {
             ProxyMmFreeExchange(pSessionSetupExchange);
         }
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   }

   if (Status == STATUS_SUCCESS) {
       //
       // The following code initializes the NetRootEntry, VNetRootContext and
       // the session entry under certain cases.
       //
       // The session entry to a doenlevel server needs to be initialized. This
       // is not handled by the previous code since the session  entry and the
       // net root entry initialization can be combined into one exchange.
       //
       // The net root entry has not been initialized, i.e., this corresponds to
       // the construction of the first PROXYCE_V_NET_ROOT_CONTEXT instance for a
       // given NetRootEntry.
       //
       // Subsequent PROXYCE_V_NET_ROOT context constructions. In these cases the
       // construction of each context must obtain a new TID
       //

       BOOLEAN fNetRootExchangeRequired;

       fNetRootExchangeRequired = (
                                    ((pSessionEntry->Header.State != PROXYCEDB_ACTIVE) &&
                                    !(pServerEntry->Server.DialectFlags & DF_EXTENDED_SECURITY))
                                    ||
                                    !BooleanFlagOn(
                                        pVNetRootContext->Flags,
                                        PROXYCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID)
                                  );

        if (fNetRootExchangeRequired) {
            // This is a tree connect open which needs to be triggered immediately.
            PPROXY_EXCHANGE                  pProxyExchange;
            PPROXY_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

            pProxyExchange = ProxyMmAllocateExchange(CONSTRUCT_NETROOT_EXCHANGE,NULL);
            if (pProxyExchange != NULL) {
               Status = ProxyCeInitializeExchange(
                              &pProxyExchange,
                              pVNetRoot,
                              CONSTRUCT_NETROOT_EXCHANGE,
                              &ConstructNetRootExchangeDispatch);

               if (Status == RX_MAP_STATUS(SUCCESS)) {
                  pNetRootExchange = (PPROXY_CONSTRUCT_NETROOT_EXCHANGE)pProxyExchange;

                  // Attempt to reconnect( In this case it amounts to establishing the
                  // connection/session)
                  pNetRootExchange->ProxyCeFlags |= PROXYCE_EXCHANGE_ATTEMPT_RECONNECTS;
                  // Initialize the continuation for resumption upon completion of the
                  // tree connetcion.
                  pNetRootExchange->NetRootCallback       = pCreateNetRootContext->Callback;
                  pNetRootExchange->pCreateNetRootContext = pCreateNetRootContext;

                  pNetRootExchange->fInitializeNetRoot =  fInitializeNetRoot;

                  // Initiate the exchange.
                  Status = ProxyCeInitiateExchange(pProxyExchange);

                  if (Status != STATUS_PENDING) {
                     ProxyCeDiscardExchange(pProxyExchange);
                  }
               }
            } else {
               Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
   }
#endif

   Status = STATUS_SUCCESS;
   return Status;
}

VOID
MRxProxyExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    )
/*++

Routine Description:

    This routine parses the input name into srv, netroot, and the
    rest.

Arguments:


--*/
{
    UNICODE_STRING xRestOfName;

    ULONG length = FilePathName->Length;
    PWCH w = FilePathName->Buffer;
    PWCH wlimit = (PWCH)(((PCHAR)w)+length);
    PWCH wlow;

    w += (SrvCall->pSrvCallName->Length/sizeof(WCHAR));
    NetRootName->Buffer = wlow = w;
    for (;;) {
        if (w>=wlimit) break;
        if ( (*w == OBJ_NAME_PATH_SEPARATOR) && (w!=wlow) ){
#if ZZZ_MODE
            if (*(w-1) == L'z') {
                w++;
                continue;
            }
#endif //if ZZZ_MODE
            break;
        }
        w++;
    }
    NetRootName->Length = NetRootName->MaximumLength
                = (PCHAR)w - (PCHAR)wlow;

    if (!RestOfName) RestOfName = &xRestOfName;
    RestOfName->Buffer = w;
    RestOfName->Length = RestOfName->MaximumLength
                       = (PCHAR)wlimit - (PCHAR)w;

    RxDbgTrace( 0,Dbg,("  MRxProxyExtractNetRootName FilePath=%wZ\n",FilePathName));
    RxDbgTrace(0,Dbg,("         Srv=%wZ,Root=%wZ,Rest=%wZ\n",
                        SrvCall->pSrvCallName,NetRootName,RestOfName));

    return;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\querydir.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    querydir.c

Abstract:

    This module implements the mini redirector call down routines pertaining to query directory.

Author:

    joelinn      [joelinn]      01-02-97

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIRCTRL)

//
// External declartions
//
NTSTATUS
MRxProxyQueryDirOrFlushContinuation(
    MRXPROXY_ASYNCENGINE_ARGUMENT_SIGNATURE
      );


RXDT_DefineCategory(DIRCTRL);
#define Dbg        (DEBUG_TRACE_DIRCTRL)

ULONG MRxProxyStopOnLoudCompletion = TRUE;
NTSTATUS
MRxProxyQueryDirectory(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network querydir requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxyQueryDir %08lx\n", RxContext ));
    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    MRxProxySetLoud("QueryDir ",RxContext,&(capFobx->UnicodeQueryTemplate));

    Status = MRxProxyAsyncEngineOuterWrapper(
                 RxContext,
                 MRXPROXY_ASYNCENG_CTX_FROM_QUERYDIR,
                 MRxProxyQueryDirOrFlushContinuation,
                 "MRxProxyQueryDir",
                 TRUE, //loudprocessing
                 (BOOLEAN)MRxProxyStopOnLoudCompletion
                 );

    RxDbgTrace(-1, Dbg, ("MRxProxyQueryDir %08lx exit with status=%08lx\n", RxContext, Status ));
    return(Status);

} // MRxProxyQueryDir

NTSTATUS
MRxProxyFlush(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles flush requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxyFlush %08lx\n", RxContext ));
    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    //MRxProxySetLoud("QueryDir ",RxContext,&(capFobx->UnicodeQueryTemplate));

    Status = MRxProxyAsyncEngineOuterWrapper(
                 RxContext,
                 MRXPROXY_ASYNCENG_CTX_FROM_FLUSH,
                 MRxProxyQueryDirOrFlushContinuation,
                 "MRxProxyFlush",
                 TRUE, //loudprocessing
                 (BOOLEAN)MRxProxyStopOnLoudCompletion
                 );

    RxDbgTrace(-1, Dbg, ("MRxProxyFlush %08lx exit with status=%08lx\n", RxContext, Status ));
    return(Status);

} // MRxProxyFlush




NTSTATUS
MRxProxyQueryDirOrFlushContinuation(
    MRXPROXY_ASYNCENGINE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for query directiry.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status; //this is initialized to proxybufstatus on a reenter
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG ContinueEntryCount;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    BOOLEAN  SynchronousIo =
               !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxyQueryDirOrFlushContinuation\n", 0 ));

    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);

    AsyncEngineContext->ContinueEntryCount++;
    ContinueEntryCount = AsyncEngineContext->ContinueEntryCount;

    IF_DEBUG {
        if (AsyncEngineContext->EntryPoint == MRXPROXY_ASYNCENG_CTX_FROM_QUERYDIR) {
            if (RxContext->LoudCompletionString) {
                PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(capFobx->pSrvOpen);
                ULONG t = InterlockedIncrement(&proxySrvOpen->NumberOfQueryDirectories);
                ASSERT(t==1);
            }
        }
    }

    for (;;) {

        //
        // Case on the current state
        //

        switch (AsyncEngineContext->OpSpecificState) {

        case MRxProxyAsyncEngOEInnerIoStates_Initial:
            AsyncEngineContext->OpSpecificState = MRxProxyAsyncEngOEInnerIoStates_ReadyToSend;

            //
            // If not a synchronous querydir, then continue here when resumed
            //
            //CODE.IMPROVEMENT  why don't we just use the flag in the rxcontext??
            if (!SynchronousIo) {
                SetFlag(AsyncEngineContext->Flags,MRXPROXY_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);
            }
            ASSERT( AsyncEngineContext->Continuation == MRxProxyQueryDirOrFlushContinuation);

            //lack of break is intentional

        case MRxProxyAsyncEngOEInnerIoStates_ReadyToSend:
            AsyncEngineContext->OpSpecificState = MRxProxyAsyncEngOEInnerIoStates_OperationOutstanding;

            Status = MRxProxyBuildAsynchronousRequest(
                         RxContext,                                // IN PVOID Context
                         MRxProxyAsyncEngineCalldownIrpCompletion  // IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                        );

            if (Status != STATUS_SUCCESS) {
                goto FINALLY;
            }

            Status = MRxProxySubmitAsyncEngRequest(
                         MRXPROXY_ASYNCENGINE_ARGUMENTS,
                         (AsyncEngineContext->EntryPoint == MRXPROXY_ASYNCENG_CTX_FROM_QUERYDIR)
                             ?MRXPROXY_ASYNCENG_AECTXTYPE_QUERYDIR
                             :MRXPROXY_ASYNCENG_AECTXTYPE_FLUSH
                         );

            //
            // If the status is PENDING, then we're done for now. We must
            // wait until we're re-entered when the receive happens.
            //

            if (Status==(STATUS_PENDING)) {
                ASSERT(FALSE); //shouldn't be coming thru here now........
                ASSERT(!SynchronousIo);
                goto FINALLY;
            }

            if ((Status!=STATUS_SUCCESS) && (RxContext->LoudCompletionString)) {
                DbgPrint("LoudFailure %08lx on %wZ\n",Status,RxContext->LoudCompletionString);
                if (MRxProxyStopOnLoudCompletion) {
                    DbgBreakPoint();
                }
            }
            AsyncEngineContext->Status = Status;
            //lack of break is intentional

        case MRxProxyAsyncEngOEInnerIoStates_OperationOutstanding:
            AsyncEngineContext->OpSpecificState = MRxProxyAsyncEngOEInnerIoStates_ReadyToSend;
            Status = AsyncEngineContext->Status;
            //RxContext->InformationToReturn += AsyncEngineContext->Information;
            if (!NT_ERROR(Status)) {
                RxContext->Info.LengthRemaining -= AsyncEngineContext->CalldownIrp->IoStatus.Information;
            }
            goto FINALLY;

            break;
        }
    }

FINALLY:
    //CODE.IMPROVEMENT QueryDirOrFlush_start and write_start and locks_start should be combined.....we use this
    //macro until then to keep the async stuff identical
    if ( Status != (STATUS_PENDING) ) {
        MRxProxyAsyncEngAsyncCompletionIfNecessary(AsyncEngineContext,RxContext);
    }

    RxDbgTrace(-1, Dbg, ("MRxProxyQueryDirOrFlushContinuation exit w %08lx\n", Status ));
    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\pxypoolt.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    pxypoolt.h

Abstract:

    The pool tag definitions for PROXY mini redirector

Author:

    Balan Sethu Raman (SethuR) - Created  2-March-95

Revision History:

   This file contains all the pool tag definitions related to the PROXY mini redirector.
   The mechanism is intended to balance the number of pool tags to be used with the
   total number of tags available in the system.

   By specifying special flags the total number of tags consumed by the mini redirector
   can be controlled. For most builds the tags should be aliased such that about
   3 tags are consumed by the mini redirector. In special builds the aliasing of tags
   will be suppressed, thereby consuming more tags to track down memory leaks easily.

   The following are the five major tags ....

      1) PxUs -- the Proxy Mini upper structures.

      2) PxRw -- the Proxy mini redirector read/write paths

      3) PxMs -- the miscellanous category.

--*/

#ifndef _PROXYPOOLT_H_
#define _PROXYPOOLT_H_

#define MRXPROXY_US_POOLTAG        ('SUxP')
#define MRXPROXY_RW_POOLTAG        ('wRxP')
#define MRXPROXY_MISC_POOLTAG      ('sMxP')

extern ULONG MRxProxyExplodePoolTags;

#define MRXPROXY_DEFINE_POOLTAG(ExplodedPoolTag,DefaultPoolTag)  \
        ((MRxProxyExplodePoolTags == 0) ? (DefaultPoolTag) : (ExplodedPoolTag))

#define MRXPROXY_FSCTL_POOLTAG     MRXPROXY_DEFINE_POOLTAG('cFxP',MRXPROXY_MISC_POOLTAG)
#define MRXPROXY_DIRCTL_POOLTAG    MRXPROXY_DEFINE_POOLTAG('cDxP',MRXPROXY_MISC_POOLTAG)
#define MRXPROXY_DEFROPEN_POOLTAG  MRXPROXY_DEFINE_POOLTAG('ODxP',MRXPROXY_MISC_POOLTAG)

#define MRXPROXY_ASYNCENGINECONTEXT_POOLTAG MRXPROXY_DEFINE_POOLTAG('EAxP',MRXPROXY_MISC_POOLTAG)

#define MRXPROXY_VNETROOT_POOLTAG  MRXPROXY_DEFINE_POOLTAG('rVxP',MRXPROXY_US_POOLTAG)
#define MRXPROXY_SERVER_POOLTAG    MRXPROXY_DEFINE_POOLTAG('rSxP',MRXPROXY_US_POOLTAG)
#define MRXPROXY_NETROOT_POOLTAG   MRXPROXY_DEFINE_POOLTAG('rNxP',MRXPROXY_US_POOLTAG)



// NodeType Codes
#if 0

#define PROXY_EXCHANGE_CATEGORY             (0xed)
#define PROXY_CONNECTION_ENGINE_DB_CATEGORY (0xea)
#define PROXY_SERVER_TRANSPORT_CATEGORY     (0xeb)

#define PROXY_EXCHANGE_NTC(x) \
        ((PROXY_EXCHANGE_CATEGORY << 8) | (x))

#define PROXY_CONNECTION_ENGINE_NTC(x)    \
        ((PROXY_CONNECTION_ENGINE_DB_CATEGORY << 8) | (x))
#endif

#define PROXY_NTC_ASYNCENGINE_CONTEXT  ((USHORT)0xedd0)
#endif _PROXYPOOLT_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\read.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the mini redirector call down routines pertaining to read
    of file system objects.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

//
// External declartions
//
NTSTATUS
MRxProxyReadContinuation(
    MRXPROXY_ASYNCENGINE_ARGUMENT_SIGNATURE
      );


NTSTATUS
MRxProxyRead(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    //RxCaptureFcb; RxCaptureFobx;
    //PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxyRead\n", 0 ));
    //in outerwrapper ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    Status = MRxProxyAsyncEngineOuterWrapper(
                 RxContext,
                 MRXPROXY_ASYNCENG_CTX_FROM_READ,
                 MRxProxyReadContinuation,
                 "MRxProxyRead",
                 FALSE, //loudprocessing
                 FALSE
                 );

    RxDbgTrace(-1, Dbg, ("MRxProxyRead  exit with status=%08lx\n", Status ));
    return(Status);

} // MRxProxyRead



NTSTATUS
MRxProxyReadContinuation(
    MRXPROXY_ASYNCENGINE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for read.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status; //this is initialized to proxybufstatus on a reenter
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG ContinueEntryCount;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    BOOLEAN  SynchronousIo =
               !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();    RxDbgTrace(+1, Dbg, ("MRxProxyReadContinuation\n", 0 ));

    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);

    AsyncEngineContext->ContinueEntryCount++;
    ContinueEntryCount = AsyncEngineContext->ContinueEntryCount;


    for (;;) {

        //
        // Case on the current state
        //

        switch (AsyncEngineContext->OpSpecificState) {

        case MRxProxyAsyncEngOEInnerIoStates_Initial:
            AsyncEngineContext->OpSpecificState = MRxProxyAsyncEngOEInnerIoStates_ReadyToSend;

            //
            // If not a synchronous read, then continue here when resumed
            //
            //CODE.IMPROVEMENT  don't use presense of continuation as the async marker...use a flag
            if (!SynchronousIo) {
                SetFlag(AsyncEngineContext->Flags,MRXPROXY_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);
                AsyncEngineContext->Continuation = MRxProxyReadContinuation;
            }

            //lack of break is intentional

        case MRxProxyAsyncEngOEInnerIoStates_ReadyToSend:
            AsyncEngineContext->OpSpecificState = MRxProxyAsyncEngOEInnerIoStates_OperationOutstanding;

            if (FALSE && FlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_PAGING_IO)) {
                RxLog(("PagingRead: rx/off/len %lx/%lx/%lx",
                               RxContext,
                               (ULONG)(LowIoContext->ParamsFor.ReadWrite.ByteOffset),
                               LowIoContext->ParamsFor.ReadWrite.ByteCount
                     ));
            }

            Status = MRxProxyBuildAsynchronousRequest(
                         RxContext,                                // IN PVOID Context
                         MRxProxyAsyncEngineCalldownIrpCompletion  // IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                        );

            if (Status != STATUS_SUCCESS) {
                goto FINALLY;
            }

            Status = MRxProxySubmitAsyncEngRequest(
                         MRXPROXY_ASYNCENGINE_ARGUMENTS,
                         MRXPROXY_ASYNCENG_AECTXTYPE_READ
                         );

            //
            // If the status is PENDING, then we're done for now. We must
            // wait until we're re-entered when the receive happens.
            //

            if (Status==(STATUS_PENDING)) {
                ASSERT(!SynchronousIo);
                goto FINALLY;
            }

            AsyncEngineContext->Status = Status;
            //lack of break is intentional

        case MRxProxyAsyncEngOEInnerIoStates_OperationOutstanding:
            AsyncEngineContext->OpSpecificState = MRxProxyAsyncEngOEInnerIoStates_ReadyToSend;
            Status = AsyncEngineContext->Status;
            RxContext->InformationToReturn += AsyncEngineContext->Information;
            goto FINALLY;

            break;
        }
    }

FINALLY:
    //CODE.IMPROVEMENT read_start and write_start and locks_start should be combined.....we use this
    //macro until then to keep the async stuff identical
    if ( Status != (STATUS_PENDING) ) {
        MRxProxyAsyncEngAsyncCompletionIfNecessary(AsyncEngineContext,RxContext);
    }

    RxDbgTrace(-1, Dbg, ("MRxProxyReadContinuation exit w %08lx\n", Status ));
    return Status;
} // ProxyPseExchangeStart_Read


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\openclos.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module implements the mini redirector call down routines pertaining to opening/
    closing of file/directories.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

////
////  The Bug check file id for this module
////
//
//#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

#ifdef RX_PRIVATE_BUILD
ULONG MRxProxyDbgPrintF = 1; //0; //1;
#endif //ifdef RX_PRIVATE_BUILD

#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif //ifdef RX_PRIVATE_BUILD

NTSTATUS
MRxProxySyncIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the calldownirp is completed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context

Return Value:

    RXSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PRX_CONTEXT RxContext = (PRX_CONTEXT)Context;
    PMRXPROXY_RX_CONTEXT pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);

    if (CalldownIrp->PendingReturned){
        //pMRxProxyContext->SyncCallDownIoStatus = CalldownIrp->IoStatus;
        RxSignalSynchronousWaiter(RxContext);
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}


//not on the stack...just in case
ULONG DummyReturnedLengthForXxxInfo;

NTSTATUS
MRxProxySyncXxxInformation(
    IN OUT PRX_CONTEXT RxContext,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength OPTIONAL
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file
    or volume.  The information returned is determined by the class that
    is specified, and it is placed into the caller's output buffer.

Arguments:

    FsInformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

    FileInformation - Boolean that indicates whether the information requested
        is for a file or a volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS Status;
    PIRP irp,TopIrp;
    PIO_STACK_LOCATION irpSp;

    PDEVICE_OBJECT DeviceObject;

    //ULONG SetFileInfoInfo;

    PAGED_CODE();

    if (ReturnedLength==NULL) {
        ReturnedLength = &DummyReturnedLengthForXxxInfo;
    }


    ASSERT (FileObject);
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    ASSERT (DeviceObject);

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, TRUE );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = MajorFunction;
    irpSp->FileObject = FileObject;
    IoSetCompletionRoutine(irp,
                           MRxProxySyncIrpCompletionRoutine,
                           RxContext,
                           TRUE,TRUE,TRUE); //call no matter what....


    irp->AssociatedIrp.SystemBuffer = Information;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    IF_DEBUG {
        ASSERT( (irpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION)
                    || (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION)
                    || (irpSp->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION) );

        if (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION) {
            //IF_LOUD_DOWNCALLS(MiniFileObject) {
            //    SetFileInfoInfo =  ((PFILE_END_OF_FILE_INFORMATION)Information)->EndOfFile.LowPart;
            //}
        }

        ASSERT(&irpSp->Parameters.QueryFile.Length == &irpSp->Parameters.SetFile.Length);
        ASSERT(&irpSp->Parameters.QueryFile.Length == &irpSp->Parameters.QueryVolume.Length);


        ASSERT(&irpSp->Parameters.QueryFile.FileInformationClass
                                          == &irpSp->Parameters.SetFile.FileInformationClass);
        ASSERT(&irpSp->Parameters.QueryFile.FileInformationClass
                                          == &irpSp->Parameters.QueryVolume.FsInformationClass);

    }

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    KeInitializeEvent( &RxContext->SyncEvent,
                       NotificationEvent,
                       FALSE );

    //LoudCallsDbgPrint("Ready to",
    //                        MiniFileObject,
    //                        irpSp->MajorFunction,
    //                        irpSp->Parameters.QueryFile.FileInformationClass,
    //                        irpSp->Parameters.QueryFile.Length,
    //                        SetFileInfoInfo,0,0
    //                        );

    try {
        TopIrp = IoGetTopLevelIrp();
        IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear
        Status = IoCallDriver(DeviceObject,irp);
    } finally {
        IoSetTopLevelIrp(TopIrp); //restore my context for unwind
    }


    //RxDbgTrace (0, Dbg, ("  -->Status after iocalldriver %08lx(%08lx)\n",RxContext,Status));

    if (Status == (STATUS_PENDING)) {
        RxWaitSync(RxContext);
        Status = irp->IoStatus.Status;
    }

    //LoudCallsDbgPrint("Back from",
    //                        MiniFileObject,
    //                        irpSp->MajorFunction,
    //                        irpSp->Parameters.QueryFile.FileInformationClass,
    //                        irpSp->Parameters.QueryFile.Length,
    //                        SetFileInfoInfo,
    //                        Status,irp->IoStatus.Information
    //                        );

    if (Status==STATUS_SUCCESS) {
        *ReturnedLength = irp->IoStatus.Information;
        RxDbgTrace( 0, Dbg, ("MRxProxySyncXxxInformation(%x)Info<%x> %x bytes@%x returns %08lx/%08lx\n",
                    RxContext,MajorFunction,
                    Status,*ReturnedLength));
    }

    IoFreeIrp(irp);
    return(Status);

}

NTSTATUS
MRxProxyShouldTryToCollapseThisOpen (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the mini knows of a good reason not
   to try collapsing on this open. Presently, the only reason would
   be if this were a copychunk open.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation
        SUCCESS --> okay to try collapse
        other (MORE_PROCESSING_REQUIRED) --> dont collapse

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    return Status;
}


VOID
MRxProxyMungeBufferingIfWriteOnlyHandles (
    ULONG WriteOnlySrvOpenCount,
    PMRX_SRV_OPEN SrvOpen
    )
/*++

Routine Description:

   This routine modifies the buffering flags on a srvopen so that
   no cacheing will be allowed if there are any write-only handles
   to the file.  CODE.IMPROVEMENT this should be inlined.

Arguments:

    WriteOnlySrvOpenCount - the number of writeonly srvopens
    SrvOpen - the srvopen whose buffring flags are to be munged

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    BOOLEAN IsLoopBack = FALSE;
    PMRX_SRV_CALL pSrvCall;
    //PSMBCEDB_SERVER_ENTRY pServerEntry;

    pSrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;

#if 0
    pServerEntry = SmbCeReferenceAssociatedServerEntry(pSrvCall);
    ASSERT(pServerEntry != NULL);
    IsLoopBack = pServerEntry->Server.IsLoopBack;
    SmbCeDereferenceServerEntry(pServerEntry);
#endif

    if (!IsLoopBack && (WriteOnlySrvOpenCount==0)) {
        return;
    }
    SrvOpen->BufferingFlags &=
       ~( FCB_STATE_WRITECACHEING_ENABLED  |
          FCB_STATE_FILESIZECACHEING_ENABLED |
          FCB_STATE_FILETIMECACHEING_ENABLED |
          FCB_STATE_LOCK_BUFFERING_ENABLED |
          FCB_STATE_READCACHEING_ENABLED |
          FCB_STATE_COLLAPSING_ENABLED
        );
}

ULONG MRxProxyLoudStringTableSize = 0;
UNICODE_STRING MRxProxyLoudStrings[50];

VOID
MRxProxySetLoud(
    IN PBYTE Msg,
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING s
    )
{
    ULONG i;
    UNICODE_STRING temp;
    for (i=0;i<MRxProxyLoudStringTableSize;i++) {
        PUNICODE_STRING t = &(MRxProxyLoudStrings[i]);
        ((PBYTE)temp.Buffer) = ((PBYTE)s->Buffer) + s->Length - t->Length;
        temp.Length = t->Length;
        //DbgPrint("%s %lx Comparing %wZ with %wZ from %wZ\n",Msg,t->Length,&temp,t,s);
        if (RtlEqualUnicodeString(&temp,t,TRUE)) {
            DbgPrint("%s Found %wZ from %wZ\n",Msg,t,s);
            RxContext->LoudCompletionString = t;
            break;
        }
    }
}

VOID
MRxProxyInitializeLoudStrings(
    void
    )
{
    RtlInitUnicodeString(&MRxProxyLoudStrings[0],L"xsync.exe");
    //RtlInitUnicodeString(&MRxProxyLoudStrings[1],L"calc.exe");
    //RtlInitUnicodeString(&MRxProxyLoudStrings[2],L"ecco.exe");
    MRxProxyLoudStringTableSize = 1;
}



#define MustBeDirectory(co) ((co) & FILE_DIRECTORY_FILE)
#define MustBeFile(co)      ((co) & FILE_NON_DIRECTORY_FILE)

// define structures for posting of open and close calls so that they end up in the
// system process.

typedef
NTSTATUS
(*PMRX_PROXY_POSTABLE_OPERATION) (
    IN OUT PRX_CONTEXT RxContext
    );

#if 0
typedef struct _MRX_PROXY_COMMON_POSTED_OPERATION_CONTEXT_LOWER {
    PRX_CONTEXT RxContext;
    union {
        NTSTATUS PostReturnStatus;
        RX_WORK_QUEUE_ITEM  WorkQueueItem;
    };
    KEVENT PostEvent;
} MRX_PROXY_COMMON_POSTED_OPERATION_CONTEXT_LOWER;

typedef struct _MRX_PROXY_COMMON_POSTED_OPERATION_CONTEXT {
    union {
        MRX_PROXY_COMMON_POSTED_OPERATION_CONTEXT_LOWER;
        MRX_PROXY_COMMON_POSTED_OPERATION_CONTEXT_LOWER PostedOpContext;
    };
} MRX_PROXY_COMMON_POSTED_OPERATION_CONTEXT, *PMRX_PROXY_COMMON_POSTED_OPERATION_CONTEXT;;

typedef struct _MRX_PROXY_COMMON_POSTED_OPERATION_CONTEXT {
    MRX_PROXY_COMMON_POSTED_OPERATION_CONTEXT;
} MRX_PROXY_POSTED_CREATE_CONTEXT, *PMRX_PROXY_POSTED_CREATE_CONTEXT;

typedef struct _MRX_PROXY_POSTED_CLOSE_CONTEXT {
    MRX_PROXY_COMMON_POSTED_OPERATION_CONTEXT;
} MRX_PROXY_POSTED_CLOSE_CONTEXT, *PMRX_PROXY_POSTED_CLOSE_CONTEXT;
#endif


NTSTATUS
MRxProxyPostOperation (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PVOID PostedOpContext,
    IN     PMRX_PROXY_POSTABLE_OPERATION Operation
    )
{
    NTSTATUS Status,PostStatus;
    PMRXPROXY_RX_CONTEXT pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);

    KeInitializeEvent( &RxContext->SyncEvent,
                       NotificationEvent,
                       FALSE );
    pMRxProxyContext->PostedOpContext = PostedOpContext;

    IF_DEBUG {
        //fill the workqueue structure with deadbeef....all the better to diagnose
        //a failed post
        ULONG i;
        for (i=0;i+sizeof(ULONG)-1<sizeof(RxContext->WorkQueueItem);i+=sizeof(ULONG)) {
            PBYTE BytePtr = ((PBYTE)&RxContext->WorkQueueItem)+i;
            PULONG UlongPtr = (PULONG)BytePtr;
            *UlongPtr = 0xdeadbeef;
        }
    }

    PostStatus = RxPostToWorkerThread(
                     &MRxProxyDeviceObject->RxDeviceObject,
                     DelayedWorkQueue,
                     &RxContext->WorkQueueItem,
                     Operation,
                     RxContext);

    ASSERT(PostStatus == STATUS_SUCCESS);

    RxWaitSync(RxContext);
    Status = pMRxProxyContext->PostedOpStatus;
    return(Status);
}

NTSTATUS
MRxProxyPostedCreate (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine opens a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PMRXPROXY_RX_CONTEXT pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);

    RxCaptureFcb;
    PMRX_PROXY_FCB proxyFcb = MRxProxyGetFcbExtension(capFcb);

    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(SrvOpen);
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PUNICODE_STRING RemainingName = &(capFcb->AlreadyPrefixedName);

    PNT_CREATE_PARAMETERS CreateParameters = &RxContext->Create.NtCreateParameters;
    ULONG Disposition = CreateParameters->Disposition;
    ACCESS_MASK DesiredAccess = CreateParameters->DesiredAccess  & 0x1FF;

    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE handle;
    ULONG FilteredCreateOptions;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxProxyPostedCreate %08lx\n", RxContext ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RxDbgTrace( 0, Dbg, ("     Attempt to open %wZ\n", &(capFcb->AlreadyPrefixedName) ));

    MRxProxySetLoud("Create ",RxContext,&(capFcb->AlreadyPrefixedName));

#if 0
    // we cannot have a file cached on a write only handle. so we have to behave a little
    // differently if this is a write-only open. remember this in the proxysrvopen

    if (  ((DesiredAccess & (FILE_EXECUTE  | FILE_READ_DATA)) == 0) &&
          ((DesiredAccess & (FILE_WRITE_DATA | FILE_APPEND_DATA)) != 0)
       ) {

        //SetFlag(proxySrvOpen->Flags,PROXY_SRVOPEN_FLAG_WRITE_ONLY_HANDLE);
        //SrvOpen->Flags |= SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING;
        DesiredAccess |= FILE_READ_DATA;
    }
#endif
    // we cannot have a file cached on a write only handle. so if write_data is
    // specified then so is read data

    if (  ((DesiredAccess & (FILE_EXECUTE  | FILE_READ_DATA)) == 0) &&
          ((DesiredAccess & (FILE_WRITE_DATA | FILE_APPEND_DATA)) != 0)
       ) {

        //SetFlag(proxySrvOpen->Flags,PROXY_SRVOPEN_FLAG_WRITE_ONLY_HANDLE);
        //SrvOpen->Flags |= SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING;
        DesiredAccess |= FILE_READ_DATA;
    }

    if ( ( DesiredAccess
                      &~ (FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE) )
                  == 0 ){
        SetFlag(SrvOpen->Flags,SRVOPEN_FLAG_NO_BUFFERING_STATE_CHANGE);
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        RemainingName,
        OBJ_CASE_INSENSITIVE,  // !!! can we do this? probably need a flag BUGBUG
        0,
        NULL                   // !!! Security     BUGBUG
        );

    FilteredCreateOptions = CreateParameters->CreateOptions;
    if (!MustBeDirectory(FilteredCreateOptions)) {
        FilteredCreateOptions &= ~(FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT); //always async
    }
    FilteredCreateOptions |= FILE_NO_INTERMEDIATE_BUFFERING;
    RxDbgTrace( 0, Dbg, (" ---->FilteredCreateOptions           = %08lx\n", FilteredCreateOptions));
    RxLog(("-->FilteredOptions/oc %lx %lx",FilteredCreateOptions,capFcb->OpenCount));

    Status = IoCreateFile(
                 &handle,
                 DesiredAccess,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 &CreateParameters->AllocationSize,
                 CreateParameters->FileAttributes,
                 CreateParameters->ShareAccess,
                 CreateParameters->Disposition,
                 FilteredCreateOptions,
                 RxContext->Create.EaBuffer,
                 RxContext->Create.EaLength,
                 CreateFileTypeNone,
                 NULL,               // extra parameters
                 IO_NO_PARAMETER_CHECKING
                 );

    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle( handle,
                                            0L,
                                            NULL,
                                            KernelMode,
                                            (PVOID *) &proxySrvOpen->UnderlyingFileObject,
                                            NULL );
        if (Status == STATUS_SUCCESS) {
            proxySrvOpen->UnderlyingHandle = handle;
            proxySrvOpen->UnderlyingDeviceObject = IoGetRelatedDeviceObject( proxySrvOpen->UnderlyingFileObject );
        } else {
            ZwClose(handle);
        }
    }


    RxDbgTrace( 0, Dbg, ("Status of underlying open %08lx\n", Status ));
    RxLog(("--->UnderlyingOpen %lx",Status));
//    DbgBreakPoint();


    RxDbgTrace(-1, Dbg, ("MRxProxyPostedCreate %08lx exit with status=%08lx\n", RxContext, Status ));
    if (NT_SUCCESS(Status)) {
        RxContext->Create.ReturnedCreateInformation = IoStatusBlock.Information;
    }
    pMRxProxyContext->PostedOpStatus = Status;
    RxSignalSynchronousWaiter(RxContext);
    return(STATUS_SUCCESS);
}

NTSTATUS
MRxProxyPostedCloseHandle (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:


Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    //NTSTATUS Status;
    PMRXPROXY_RX_CONTEXT pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);

    //RxCaptureFcb;
    //PMRX_PROXY_FCB proxyFcb = MRxProxyGetFcbExtension(capFcb);

    PMRX_SRV_OPEN SrvOpen = (PMRX_SRV_OPEN)(pMRxProxyContext->PostedOpContext);
    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(SrvOpen);
    //HANDLE handle;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxProxyPostedCloseHandle %08lx %08lx\n", RxContext, SrvOpen ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    ZwClose(proxySrvOpen->UnderlyingHandle);

    RxDbgTrace(-1, Dbg, ("MRxProxyPostedCloseHandle %08lx exit\n", RxContext ));
    pMRxProxyContext->PostedOpStatus = STATUS_SUCCESS;
    RxSignalSynchronousWaiter(RxContext);
    return(STATUS_SUCCESS);
}


NTSTATUS
MRxProxyCreate (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine opens a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    PMRX_PROXY_FCB proxyFcb = MRxProxyGetFcbExtension(capFcb);

    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(SrvOpen);

    BOOLEAN MustRegainExclusiveResource = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxyCreate %08lx\n", RxContext ));

    //do this BEFORE you drop the resource
    SetFlag(SrvOpen->Flags,SRVOPEN_FLAG_COLLAPSING_DISABLED);

    Status = MRxProxyPostOperation ( RxContext,
                                     NULL,
                                     MRxProxyPostedCreate );

    //this Boolean should be passed......
    if (MustRegainExclusiveResource) {        //this is required if we do oplock breaks
        RxAcquireExclusiveFcb( RxContext, capFcb );
    }

    if (NT_SUCCESS(Status)) {

        RX_FILE_TYPE StorageType;
        FILE_BASIC_INFORMATION BasicInformation;
        FILE_STANDARD_INFORMATION StandardInformation;
        NTSTATUS InfoStatus;
        FCB_INIT_PACKET InitPacket;

        ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
        StorageType = RxInferFileType(RxContext);
        RxDbgTrace( 0, Dbg, ("Storagetype %08lx\n", StorageType ));

        // if we have never obtained the characteristics, we have to get them.

        if ((capFcb->OpenCount == 0)
            || !FlagOn(capFcb->FcbState,FCB_STATE_TIME_AND_SIZE_ALREADY_SET) ) {

            InfoStatus = MRxProxySyncXxxInformation(
                                RxContext,                  //IN OUT PRX_CONTEXT RxContext,
                                IRP_MJ_QUERY_INFORMATION,   //IN UCHAR MajorFunction,
                                proxySrvOpen->UnderlyingFileObject,//IN PFILE_OBJECT FileObject,
                                FileBasicInformation,       //IN ULONG InformationClass,
                                sizeof(BasicInformation),   //IN ULONG Length,
                                &BasicInformation,          //OUT PVOID Information,
                                NULL);                      //OUT PULONG ReturnedLength OPTIONAL

            ASSERT (NT_SUCCESS(InfoStatus));   //BUGBUG what if not@!

            InfoStatus = MRxProxySyncXxxInformation(
                                RxContext,                  //IN OUT PRX_CONTEXT RxContext,
                                IRP_MJ_QUERY_INFORMATION,   //IN UCHAR MajorFunction,
                                proxySrvOpen->UnderlyingFileObject,//IN PFILE_OBJECT FileObject,
                                FileStandardInformation,    //IN ULONG InformationClass,
                                sizeof(StandardInformation),//IN ULONG Length,
                                &StandardInformation,       //OUT PVOID Information,
                                NULL);                      //OUT PULONG ReturnedLength OPTIONAL
            ASSERT (NT_SUCCESS(InfoStatus));

            if (StorageType == 0) {
                StorageType = StandardInformation.Directory?(FileTypeDirectory)
                                                           :(FileTypeFile);
                RxDbgTrace( 0, Dbg, ("ChangedStoragetype %08lx\n", StorageType ));
            }
            RxDbgTrace( 0, Dbg, ("FileSize %08lx\n", StandardInformation.EndOfFile.LowPart ));

            RxFinishFcbInitialization(
                                capFcb,
                                RDBSS_STORAGE_NTC(StorageType),
                                RxFormInitPacket(
                                    InitPacket, //note no &
                                    &BasicInformation.FileAttributes,
                                    &StandardInformation.NumberOfLinks,
                                    &BasicInformation.CreationTime,
                                    &BasicInformation.LastAccessTime,
                                    &BasicInformation.LastWriteTime,
                                    &BasicInformation.ChangeTime,
                                    &StandardInformation.AllocationSize,
                                    &StandardInformation.EndOfFile,
                                    &StandardInformation.EndOfFile)
                                 );

            //if (!MRxLocalNoOplocks) MRxLocalRequestOplock(SrvOpen,MRxOplockRequestType,MRxRequestLevelII);
            //RxDbgTrace( 0, Dbg, ("MRxLocalCreate      oplockstate =%08lx\n", localSrvOpen->OplockState ));
            //SrvOpen->BufferingFlags = MRxLocalTranslateStateToBufferMode[localSrvOpen->OplockState];

            SrvOpen->BufferingFlags |= FCB_STATE_COLLAPSING_ENABLED; //this can be turned off in the write path

        }
    }


    if (Status == STATUS_SUCCESS) {
        RxContext->pFobx = RxCreateNetFobx( RxContext, SrvOpen);
        if (!RxContext->pFobx) {
            NTSTATUS PostedCloseStatus;
            PostedCloseStatus = MRxProxyPostOperation(
                                       RxContext,
                                       ((PVOID)SrvOpen),
                                       MRxProxyPostedCloseHandle );
            ObDereferenceObject(proxySrvOpen->UnderlyingFileObject);
        }
    }

    //note.........collapsing IS enabled on fcb but not on any srvopen........
    SrvOpen->BufferingFlags |= (FCB_STATE_WRITECACHEING_ENABLED  |
                               FCB_STATE_FILESIZECACHEING_ENABLED |
                               FCB_STATE_FILETIMECACHEING_ENABLED |
                               FCB_STATE_WRITEBUFFERING_ENABLED |
                               FCB_STATE_LOCK_BUFFERING_ENABLED |
                               FCB_STATE_READBUFFERING_ENABLED  |
                               FCB_STATE_READCACHEING_ENABLED );

    ASSERT(Status != (STATUS_PENDING));
    ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

    RxDbgTrace(-1, Dbg, ("MRxProxyCreate %08lx exit with status=%08lx\n", RxContext, Status ));
    return(Status);
}

NTSTATUS
MRxProxyCollapseOpen(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine collapses a open locally

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;

    //RX_BLOCK_CONDITION FinalSrvOpenCondition;

    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

    ASSERT(FALSE);

    RxContext->pFobx = (PMRX_FOBX)RxCreateNetFobx( RxContext, SrvOpen);

    if (RxContext->pFobx != NULL) {
       ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
       RxContext->pFobx->OffsetOfNextEaToReturn = 1;
       Status = STATUS_SUCCESS;
    } else {
       Status = (STATUS_INSUFFICIENT_RESOURCES);
       //DbgBreakPoint();
    }

    return Status;
}

NTSTATUS
MRxProxyComputeNewBufferingState(
   IN OUT PMRX_SRV_OPEN   pMRxSrvOpen,
   IN     PVOID           pMRxContext,
      OUT PULONG          pNewBufferingState)
/*++

Routine Description:

   This routine maps the PROXY specific oplock levels into the appropriate RDBSS
   buffering state flags

Arguments:

   pMRxSrvOpen - the MRX SRV_OPEN extension

   pMRxContext - the context passed to RDBSS at Oplock indication time

   pNewBufferingState - the place holder for the new buffering state

Return Value:


Notes:

--*/
{
    //ULONG OplockLevel;
    ULONG NewBufferingState;

    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(pMRxSrvOpen);
    PMRX_PROXY_FCB      proxyFcb     = MRxProxyGetFcbExtension(pMRxSrvOpen->pFcb);

    ASSERT(pNewBufferingState != NULL);

#if 0
    OplockLevel = (ULONG)pMRxContext;

    if (OplockLevel == PROXY_OPLOCK_LEVEL_II) {
        NewBufferingState = (FCB_STATE_READBUFFERING_ENABLED  |
                               FCB_STATE_READCACHEING_ENABLED);
    } else {
        NewBufferingState = 0;
    }
#endif //0

    NewBufferingState = 0;

    pMRxSrvOpen->BufferingFlags = NewBufferingState;

    MRxProxyMungeBufferingIfWriteOnlyHandles(
          proxyFcb->WriteOnlySrvOpenCount,
          pMRxSrvOpen);

    *pNewBufferingState = pMRxSrvOpen->BufferingFlags;

    return STATUS_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------


NTSTATUS
MRxProxyZeroExtend(
      IN PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine extends the data stream of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
MRxProxyTruncate(
      IN PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine truncates the contents of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   ASSERT(!"Found a truncate");
   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
MRxProxyCleanupFobx(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine cleansup a file system object...normally a noop. unless it's a pipe in which case
   we do the close at cleanup time and mark the file as being not open.

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;
    PUNICODE_STRING RemainingName = &(capFcb->AlreadyPrefixedName);

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(SrvOpen);
    //PMRX_PROXY_FCB  proxyFcb  = MRxProxyGetFcbExtension(capFcb);
    //PMRX_PROXY_FOBX proxyFobx = MRxProxyGetFileObjectExtension(capFobx);

    PAGED_CODE();

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT ( NodeTypeIsFcb(capFcb) );
    ASSERT (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT));
    ASSERT (proxySrvOpen->UnderlyingFileObject);


    //if (FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) {
    //   RxDbgTrace(-1, Dbg, ("File orphaned\n"));
    //   return (STATUS_SUCCESS);
    //}


    //
    // if more fobxs are using this srvopen then just get out.
    // otherwise close the handle to trigger the underlying cleanup

    if (SrvOpen->UncleanFobxCount > 1) {  return Status; }

    RxDbgTrace(+1, Dbg, ("MRxProxyCleanup %wZ\n", RemainingName ));
    RxLog(("ProxyCleanup %lx",SrvOpen));

    //because we only have one handle onthe file....we do nothing for each
    //individual handle being closed. in this way we avoid doing paging ios!
    //we close the handle when the final close for the fcb comes down.


    RxDbgTrace(-1, Dbg, ("MRxProxyCleanup  exit with status=%08lx\n", Status ));

    return(Status);

}

NTSTATUS
MRxProxyForcedClose(
      IN PMRX_SRV_OPEN pSrvOpen)
/*++

Routine Description:

   This routine closes a file system object

Arguments:

    pSrvOpen - the instance to be closed

Return Value:

    RXSTATUS - The return status for the operation

Notes:



--*/
{
   return STATUS_NOT_IMPLEMENTED;
}

//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//------------close close close close close close close  --------------------------------
//------------close close close close close close close  --------------------------------
//------------close close close close close close close  --------------------------------
//------------close close close close close close close  --------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//
//  The local debug trace level
//

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_CLOSE)

NTSTATUS
MRxProxyCloseSrvOpen(
      IN     PRX_CONTEXT   RxContext
      )
/*++

Routine Description:

   This routine closes a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PUNICODE_STRING RemainingName = &(capFcb->AlreadyPrefixedName);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PMRX_SRV_OPEN       SrvOpen    = capFobx->pSrvOpen;
    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(SrvOpen);
    //PMRX_PROXY_FCB proxyFcb = MRxProxyGetFcbExtension(capFcb);
    //PMRX_PROXY_FOBX     proxyFobx    = MRxProxyGetFileObjectExtension(capFobx);

    //IO_STATUS_BLOCK Iosb;
    //PMINIRDR_OPLOCK_COMPLETION_CONTEXT cc = localSrvOpen->Mocc;
    //KIRQL oldIrql;
    //BOOLEAN OplockBreakPending;

    PAGED_CODE();

    ASSERT ( NodeTypeIsFcb(capFcb) );
    ASSERT ( SrvOpen->OpenCount == 0 );
    ASSERT (proxySrvOpen->UnderlyingFileObject);

    //if (capFcb->OpenCount > 0) { return STATUS_SUCCESS;}

    RxDbgTrace(+1, Dbg, ("MRxProxyClose   %wZ\n", RemainingName ));
    RxLog(("ProxyClose fobx=%lx",capFobx));

    //if (proxySrvOpen->DeferredOpenContext != NULL) {
    //    RxFreePool(proxySrvOpen->DeferredOpenContext);
    //}
    //if ((FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED))) {
    //   RxDbgTrace(-1, Dbg, ("File orphan\n"));
    //   return (STATUS_SUCCESS);
    //}

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

#if 0
IF WE REENABLE THIS, DONT USE IOSETINFO...USE MRxProxySyncXxxInformation INSTEAD
    // first we set the real filesize.....our pagingIos may have extended it
    // to a page boundary.........

    if ( NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE ) {
        FILE_END_OF_FILE_INFORMATION EndOfFileInformation;

        EndOfFileInformation.EndOfFile = capFcb->Header.FileSize;
        Status = IxxoSetInformation(
                    proxySrvOpen->UnderlyingFileObject,  //IN PFILE_OBJECT FileObject,
                    FileEndOfFileInformation,        //IN FILE_INFORMATION_CLASS FileInformationClass,
                    sizeof(EndOfFileInformation),    //IN ULONG Length,
                    &EndOfFileInformation            //IN PVOID FileInformation
                    );
    }

    //if bad status....keep going anyway........
#endif

    // next, we close our handle..........

    Status = MRxProxyPostOperation(
                  RxContext,
                  ((PVOID)SrvOpen),
                  MRxProxyPostedCloseHandle );

    // then, we remove our reference..........

    if (proxySrvOpen->UnderlyingFileObject) {

        RxDbgTrace( 0, Dbg, ("ProxyClose Attempt to close %wZ\n", &(capFcb->AlreadyPrefixedName) ));

        //if (cc) {
        //    ASSERTMSG("Joejoe the right way to do this would be to CANCEL!!!!!!!!",FALSE);
        //    //since this is a force closed, we get rid of a pending break
        //    KeAcquireSpinLock( &MrxLocalOplockSpinLock, &oldIrql );
        //    OplockBreakPending = cc->OplockBreakPending;
        //    if (!OplockBreakPending) {
        //        cc->SrvOpen = NULL;
        //    }
        //    KeReleaseSpinLock( &MrxLocalOplockSpinLock, oldIrql );
        //    if (!OplockBreakPending) {
        //        //gotta lose the spinlock befoer the call
        //        RxDereferenceSrvOpen(SrvOpen); //elim ref!
        //    }
        //} else {
        //    ASSERT (localSrvOpen->OplockState == OplockStateNone);
        //}

        RxLog(("MRxProxyClose %lx %lx",capFcb,capFobx));
        //DbgPrint("MRxProxyClose %lx %lx\n",capFcb,capFobx);

        ObDereferenceObject(proxySrvOpen->UnderlyingFileObject);

        proxySrvOpen->UnderlyingFileObject = NULL;

    }

    Status = STATUS_SUCCESS;

    RxDbgTrace(-1, Dbg, ("MRxProxyClose  exit with status=%08lx\n", Status ));

    return(Status);

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\precomp.h ===
// a minirdr must declare his name and his imports ptr

#define MINIRDR__NAME MRxProxy
#define ___MINIRDR_IMPORTS_NAME (MRxProxyDeviceObject->RdbssExports)

#include "rx.h"         // get the minirdr environment

#include "ntddnfs2.h"   // NT network file system driver include file
#include "netevent.h"

#include "proxymrx.h"     // the global include for this mini


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

RDR2=$(BASEDIR)\private\ntos\rdr2
!INCLUDE $(RDR2)\rdbss\master.src

MAJORCOMP=ntos
MINORCOMP=reflctor

TARGETNAME=reflctor
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

SYNCHRONIZE_DRAIN=1

INCLUDES=$(INCLUDES);$(BASEDIR)\private\ntos\rdr2\inc;
INCLUDES=$(INCLUDES);$(BASEDIR)\private\ntos\rdr2\rdbss\inc;
INCLUDES=$(INCLUDES);$(BASEDIR)\private\ntos\inc;
INCLUDES=$(INCLUDES);..;

TARGETLIBS=\
           $(RDR2)\rdbss\daytona\$(O)\rdbss.lib  \
           $(DDK_LIB_PATH)\ksecdd.lib

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES= $(C_DEFINES) -DEXPLODE_POOLTAGS
!IF $(MONOLITHIC_MINIRDR)
C_DEFINES=$(C_DEFINES) -DMONOLITHIC_MINIRDR
!ENDIF

MOST_SOURCES=     \
    ..\asynceng.c \
    ..\devfcb.c   \
    ..\ea.c       \
    ..\fileinfo.c \
    ..\fsctl.c    \
    ..\init.c     \
    ..\innerio.c  \
    ..\locks.c    \
    ..\netroot.c  \
    ..\openclos.c \
    ..\querydir.c \
    ..\read.c     \
    ..\srvcall.c  \
    ..\stubs.c    \
    ..\write.c    \


PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
DLLDEF=$(O)\reflctor.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\nulldir\ntrxdef.h ===
#include "..\..\inc\ntrxdef.h"
extern ULONG joelinnprivate;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\stubs.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements the mini redirector call down routines that are essentially
    just noops but which have to be implemented because the wrapper calls them without
    checking. In most cases, CODE.IMPROVEMENT the wrapper should either provide a stub
    to be used or check before calling.


Author:

    Joe Linn      [joelinn]      3-December-96

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbgg                              (0)


#if 0
NTSTATUS
MRxProxyTransportUpdateHandler(
    PRXCE_TRANSPORT_NOTIFICATION pTransportNotification)
/*++

Routine Description:

    This routine is the callback handler that is invoked by the RxCe when transports
    are either enabled or disabled. Since we do not use transports, we just return success.

Arguments:

    pTransportNotification - information pertaining to the transport

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:


--*/
{
    return STATUS_SUCCESS;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\srvcall.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    srvcall.c

Abstract:

    This module implements the routines for handling the creation/manipulation of
    server entries in the connection engine database. It also contains the routines
    for parsing the negotiate response from  the server.

Author:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

--*/

#include "precomp.h"
#pragma hdrstop


RXDT_DefineCategory(SRVCALL);
#define Dbg        (DEBUG_TRACE_SRVCALL)


NTSTATUS
MRxProxyCreateSrvCall(
    PMRX_SRV_CALL                  pSrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine just rejects any MRxCreateSrvCalls that come down.

Arguments:

    RxContext        - Supplies the context of the original create/ioctl

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = pCallbackContext;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(pCallbackContext->SrvCalldownStructure);

    ASSERT( pSrvCall );
    ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

    SCCBC->Status = (STATUS_BAD_NETWORK_PATH);
    SrvCalldownStructure->CallBack(SCCBC);

    return STATUS_PENDING;
}

NTSTATUS
MRxProxyFinalizeSrvCall(
    PMRX_SRV_CALL pSrvCall,
    BOOLEAN       Force)
/*++

Routine Description:

   This routine destroys a given server call instance

Arguments:

    pSrvCall  - the server call instance to be disconnected.

    Force     - TRUE if a disconnection is to be enforced immediately.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS              Status = STATUS_SUCCESS;
#if 0
    PPROXYCEDB_SERVER_ENTRY pServerEntry;

    pServerEntry = ProxyCeGetAssociatedServerEntry(pSrvCall);

    if (pServerEntry != NULL) {
        ProxyCeAcquireResource();

        ASSERT(pServerEntry->pRdbssSrvCall == pSrvCall);

        pServerEntry->pRdbssSrvCall = NULL;
        ProxyCeDereferenceServerEntry(pServerEntry);

        ProxyCeReleaseResource();
    }
#endif //0
    pSrvCall->Context = NULL;

    return Status;
}

NTSTATUS
MRxProxySrvCallWinnerNotify(
    IN PMRX_SRV_CALL  pSrvCall,
    IN BOOLEAN        ThisMinirdrIsTheWinner,
    IN OUT PVOID      pSrvCallContext)
/*++

Routine Description:

   This routine finalizes the mini rdr context associated with an RDBSS Server call instance

Arguments:

    pSrvCall               - the Server Call

    ThisMinirdrIsTheWinner - TRUE if this mini rdr is the choosen one.

    pSrvCallContext  - the server call context created by the mini redirector.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The two phase construction protocol for Server calls is required because of parallel
    initiation of a number of mini redirectors. The RDBSS finalizes the particular mini
    redirector to be used in communicating with a given server based on quality of
    service criterion.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    //PPROXYCEDB_SERVER_ENTRY pServerEntry;

    //pServerEntry = (PPROXYCEDB_SERVER_ENTRY)pSrvCallContext;

#if 0
    if (!ThisMinirdrIsTheWinner) {
        // Some other mini rdr has been choosen to connect to the server. Destroy
        // the data structures created for this mini redirector.

        ProxyCeUpdateServerEntryState(pServerEntry,PROXYCEDB_MARKED_FOR_DELETION);
        ProxyCeDereferenceServerEntry(pServerEntry);
    } else {
        pSrvCall->Context  = pServerEntry;
        pSrvCall->Flags   |= SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS | SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES;

        //check for loopback.....BUGBUG.ALA.RDR1
        //since servers now respond to multiple names.....this doesn't really cut it....
        {
            UNICODE_STRING ServerName;
            BOOLEAN CaseInsensitive = TRUE;
            ASSERT (pServerEntry->pRdbssSrvCall == pSrvCall);
            //DbgPrint("ServerName is %wZ\n", pSrvCall->pSrvCallName);
            //DbgPrint("ComputerName is %wZ\n", &ProxyCeContext.ComputerName);
            ServerName = *pSrvCall->pSrvCallName;
            ServerName.Buffer++; ServerName.Length -= sizeof(WCHAR);
            if (RtlEqualUnicodeString(&ServerName,&ProxyCeContext.ComputerName,CaseInsensitive)) {
                //DbgPrint("LOOPBACK!!!!!\n");
                pServerEntry->Server.IsLoopBack = TRUE;
            }
        }
    }
#endif //0
    return STATUS_SUCCESS;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\proxy.mrx\write.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the mini redirector call down routines pertaining
    to write of file system objects.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)


//
// External declartions
//
NTSTATUS
MRxProxyWriteContinuation(
    MRXPROXY_ASYNCENGINE_ARGUMENT_SIGNATURE
      );


NTSTATUS
MRxProxyWrite(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    //RxCaptureFcb; RxCaptureFobx;
    //PMRXPROXY_ASYNCENGINE_CONTEXT AsyncEngineContext;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxyWrite\n", 0 ));
    //in outerwrapper ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    Status = MRxProxyAsyncEngineOuterWrapper(
                 RxContext,
                 MRXPROXY_ASYNCENG_CTX_FROM_WRITE,
                 MRxProxyWriteContinuation,
                 "MRxProxyWrite",
                 FALSE, //loudprocessing
                 FALSE
                 );

    RxDbgTrace(-1, Dbg, ("MRxProxyWrite  exit with status=%08lx\n", Status ));
    return(Status);

} // MRxProxyWrite



NTSTATUS
MRxProxyWriteContinuation(
    MRXPROXY_ASYNCENGINE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for read.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status; //this is initialized to proxybufstatus on a reenter
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG ContinueEntryCount;

    RxCaptureFcb; RxCaptureFobx;
    //PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    //PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(SrvOpen);
    PMRX_PROXY_FCB proxyFcb = MRxProxyGetFcbExtension(capFcb);

    BOOLEAN  SynchronousIo =
               !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);
    BOOLEAN  PagingIo =
               BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_PAGING_IO);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxyWriteContinuation\n", 0 ));

    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);

    AsyncEngineContext->ContinueEntryCount++;
    ContinueEntryCount = AsyncEngineContext->ContinueEntryCount;


    for (;;) {
        //
        // Case on the current state
        //

        switch (AsyncEngineContext->OpSpecificState) {

        case MRxProxyAsyncEngOEInnerIoStates_Initial:
            AsyncEngineContext->OpSpecificState = MRxProxyAsyncEngOEInnerIoStates_ReadyToSend;

            //
            // If not a synchronous write, then continue here when resumed
            //
            // CODE.IMPROVEMENT  don't use presense of continuation as the async marker...use a flag
            if (!SynchronousIo) {
                SetFlag(AsyncEngineContext->Flags,MRXPROXY_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);
                AsyncEngineContext->Continuation = MRxProxyWriteContinuation;
            }


            //lack of break is intentional

        case MRxProxyAsyncEngOEInnerIoStates_ReadyToSend:
            AsyncEngineContext->OpSpecificState = MRxProxyAsyncEngOEInnerIoStates_OperationOutstanding;

            if (PagingIo) {
                if (TRUE) {
                    RxLog(("PageWrite: rx/offset/len %lx/%lx/%lx",
                               RxContext,
                               (ULONG)(LowIoContext->ParamsFor.ReadWrite.ByteOffset),
                               LowIoContext->ParamsFor.ReadWrite.ByteCount
                         ));
                }
            }

            Status = MRxProxyBuildAsynchronousRequest(
                         RxContext,                                // IN PVOID Context
                         MRxProxyAsyncEngineCalldownIrpCompletion  // IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
                        );

            if (Status != STATUS_SUCCESS) {
                goto FINALLY;
            }

            Status = MRxProxySubmitAsyncEngRequest(
                         MRXPROXY_ASYNCENGINE_ARGUMENTS,
                         MRXPROXY_ASYNCENG_AECTXTYPE_WRITE
                         );

            //
            // If the status is PENDING, then we're done for now. We must
            // wait until we're re-entered when the receive happens.
            //

            if (Status==(STATUS_PENDING)) {
                ASSERT(!SynchronousIo);
                goto FINALLY;
            }

            AsyncEngineContext->Status = Status;
            //lack of break is intentional

        case MRxProxyAsyncEngOEInnerIoStates_OperationOutstanding:

            AsyncEngineContext->OpSpecificState = MRxProxyAsyncEngOEInnerIoStates_ReadyToSend;
            Status = AsyncEngineContext->Status;
            RxContext->InformationToReturn += AsyncEngineContext->Information;
            goto FINALLY;

            break;
        }
    }

FINALLY:
    //CODE.IMPROVEMENT read_start and write_start and locks_start should be combined.....we use this
    //macro until then to keep the async stuff identical
    if ( Status != (STATUS_PENDING) ) {
        MRxProxyAsyncEngAsyncCompletionIfNecessary(AsyncEngineContext,RxContext);
    }

    RxDbgTrace(-1, Dbg, ("MRxProxyWriteContinuation exit w %08lx\n", Status ));
    return Status;
} // ProxyPseExchangeStart_Write

NTSTATUS
MRxProxyExtendForCache(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

    This routine extends the file allocation so that the we can do a copywrite. the fcb lock
    is exclusive here; we will take the opportunity to find out the actual allocation so that
    we'll get the fast path.  another minirdr might want to guess instead since it might be actual net ios
    otherwise.


Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - Returns the status for the set file allocation...could be an error if disk full

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //PMRXPROXY_RX_CONTEXT pMRxProxyContext = MRxProxyGetMinirdrContext(RxContext);

    RxCaptureFcb; RxCaptureFobx;
    //PMRX_PROXY_FOBX proxyFobx = MRxProxyGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_PROXY_SRV_OPEN proxySrvOpen = MRxProxyGetSrvOpenExtension(SrvOpen);
    //PMRX_PROXY_FCB proxyFcb = MRxProxyGetFcbExtension(capFcb);
    PFILE_OBJECT UnderlyingFileObject = proxySrvOpen->UnderlyingFileObject;

    PFILE_ALLOCATION_INFORMATION Buffer;
    FILE_ALLOCATION_INFORMATION FileAllocationInformationBuffer;
    ULONG Length = sizeof(FILE_ALLOCATION_INFORMATION);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxProxyExtendForNonCache %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart
               ));

    Buffer = &FileAllocationInformationBuffer;
    ASSERT (UnderlyingFileObject);

    //don't need this!!!
    //if (capFcb->Header.AllocationSize.QuadPart >= *pNewFileSize) {
    //    Status = RxStatus(SUCCESS);
    //    RxDbgTrace(-1, Dbg, (" PlentyAllocation               = %08lx\n", Status));
    //    return(Status);
    //}

    //pNewAllocationSize->QuadPart = pNewFileSize->QuadPart;
    { LONGLONG CurrentExtend = pNewFileSize->QuadPart - capFcb->Header.AllocationSize.QuadPart;
    Buffer->AllocationSize.QuadPart = capFcb->Header.AllocationSize.QuadPart
                                        + 32 * CurrentExtend;
    }
    RxDbgTrace( 0, Dbg, ("    Extending to %08lx from %08lx!\n",
                          Buffer->AllocationSize.LowPart,
                          capFcb->Header.AllocationSize.LowPart));
    Status = MRxProxySyncXxxInformation(
                RxContext,                  //IN OUT PRX_CONTEXT RxContext,
                IRP_MJ_SET_INFORMATION,     //IN UCHAR MajorFunction,
                UnderlyingFileObject,       //IN PFILE_OBJECT FileObject,
                FileAllocationInformation,  //IN ULONG InformationClass,
                Length,                     //IN ULONG Length,
                Buffer,                     //OUT PVOID Information,
                NULL                        //OUT PULONG ReturnedLength OPTIONAL
                );

    //CODE.IMPROVEMENT here we should now read it back and see what we actually got;
    // for smallio we will be seeing subcluster extension when, in fact, we get a
    // cluster at a time. we could just round it up.

    if (Status == STATUS_SUCCESS) {
        *pNewAllocationSize = Buffer->AllocationSize;
        RxDbgTrace(-1, Dbg, (" ---->Status (extend1)      = %08lx\n", Status));
        return(Status);
    }

    RxDbgTrace( 0, Dbg, ("    EXTEND1 FAILED!!!!!!%c\n", '!'));

    //try for exactly what we need

    Buffer->AllocationSize.QuadPart = pNewFileSize->QuadPart;
    Status = MRxProxySyncXxxInformation(
                RxContext,                  //IN OUT PRX_CONTEXT RxContext,
                IRP_MJ_SET_INFORMATION,     //IN UCHAR MajorFunction,
                UnderlyingFileObject,       //IN PFILE_OBJECT FileObject,
                FileAllocationInformation,  //IN ULONG InformationClass,
                Length,                     //IN ULONG Length,
                Buffer,                     //OUT PVOID Information,
                NULL                        //OUT PULONG ReturnedLength OPTIONAL
                );

    if (Status == STATUS_SUCCESS) {
        *pNewAllocationSize = Buffer->AllocationSize;
        RxDbgTrace(-1, Dbg, (" ---->Status  (extend2)             = %08lx\n", Status));
        return(Status);
    }

    RxDbgTrace( 0, Dbg, ("    EXTEND2 FAILED!!!!!!%c\n", '!'));

    RxDbgTrace(-1, Dbg, (" ---->Status   (notextended)   = %08lx\n", Status));

    return(Status);

}

NTSTATUS
MRxProxyExtendForNonCache(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles requests to extend the file for noncached IO. we just let the write extend the file
   so we don't do anything here.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;

    RxDbgTrace(+1, Dbg, ("MRxProxyExtendForNonCache %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart
               ));
    pNewAllocationSize->QuadPart = pNewFileSize->QuadPart;
    RxDbgTrace(-1, Dbg, ("MRxProxyExtendForCache  exit with status=%08lx %08lx %08lx\n",
                          Status, pNewFileSize->LowPart, pNewAllocationSize->LowPart));
    return(Status);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\3connect.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    3connect.c

Abstract:

    This module implements the tree connect SMB related routines. It also implements the
    three flavours of this routine ( user level and share level non NT server tree connect
    SMB construction and the tree connect SMB construction for SMB servers)

Author:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

--*/

#include "precomp.h"
#pragma hdrstop

#include "ntlsapi.h"

//
// The order of these names should match the order in which the enumerated type
// NET_ROOT_TYPE is defined. This facilitates easy access of share type names
//

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BuildCanonicalNetRootInformation)
#pragma alloc_text(PAGE, CoreBuildTreeConnectSmb)
#pragma alloc_text(PAGE, LmBuildTreeConnectSmb)
#pragma alloc_text(PAGE, NtBuildTreeConnectSmb)
#endif

PCHAR s_NetRootTypeName[] = {
                              SHARE_TYPE_NAME_DISK,
                              SHARE_TYPE_NAME_PIPE,
                              SHARE_TYPE_NAME_COMM,
                              SHARE_TYPE_NAME_PRINT,
                              SHARE_TYPE_NAME_WILD
                            };

extern NTSTATUS
BuildTreeConnectSecurityInformation(
    PSMB_EXCHANGE  pExchange,
    PBYTE          pBuffer,
    PBYTE          pPasswordLength,
    PULONG         pSmbBufferSize);

NTSTATUS
BuildCanonicalNetRootInformation(
    PUNICODE_STRING     pServerName,
    PUNICODE_STRING     pNetRootName,
    NET_ROOT_TYPE       NetRootType,
    BOOLEAN             fUnicode,
    BOOLEAN             fPostPendServiceString,
    PBYTE               *pBufferPointer,
    PULONG              pBufferSize)
/*++

Routine Description:

   This routine builds the desired net root information for a tree connect SMB

Arguments:

    pServerName    - the server name

    pNetRootName   - the net root name

    NetRootType    - the net root type ( print,pipe,disk etc.,)

    fUnicode       - TRUE if it is to be built in UNICODE

    pBufferPointer - the SMB buffer

    pBufferSize    - the size on input. modified to the remaining size on output

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine relies upon the names being in certain formats to ensure that a
    valid UNC name can be formulated.
    1) The RDBSS netroot names start with a \ and also include the server name as
    part of the net root name. This is mandated by the prefix table search requirements
    in RDBSS.

--*/
{
   NTSTATUS Status;

   PAGED_CODE();

   if (fUnicode) {
      // Align the buffer and adjust the size accordingly.
      PBYTE    pBuffer = *pBufferPointer;
      RxDbgTrace( 0, (DEBUG_TRACE_CREATE),
                     ("BuildCanonicalNetRootInformation -- tcstring as unicode %wZ\n", pNetRootName));
      pBuffer = ALIGN_SMB_WSTR(pBuffer);
      *pBufferSize -= (ULONG)(pBuffer - *pBufferPointer);
      *pBufferPointer = pBuffer;

      *((PWCHAR)*pBufferPointer) = L'\\';
      *pBufferPointer = *pBufferPointer + sizeof(WCHAR);
      *pBufferSize -= sizeof(WCHAR);
#if ZZZ_MODE
      {   UNICODE_STRING XlatedNetRootName;
          ULONG i,NumWhacksEncountered;
          WCHAR NameBuffer[64]; //this is debug stuff.....64 chars is plenty
          if (pNetRootName->Length <= sizeof(NameBuffer)) {
              XlatedNetRootName.Buffer = &NameBuffer[0];
              XlatedNetRootName.Length = pNetRootName->Length;
              RtlCopyMemory(XlatedNetRootName.Buffer,pNetRootName->Buffer,XlatedNetRootName.Length);
              for (i=NumWhacksEncountered=0;i<(XlatedNetRootName.Length/sizeof(WCHAR));i++) {
                  WCHAR c = XlatedNetRootName.Buffer[i];
                  if (c==L'\\') {
                      NumWhacksEncountered++;
                      if (NumWhacksEncountered>2) {
                          XlatedNetRootName.Buffer[i] = L'z';
                      }
                  }
              }
              RxDbgTrace( 0, (DEBUG_TRACE_CREATE),
                     ("BuildCanonicalNetRootInformationZZZMode -- xltcstring as unicode %wZ\n", &XlatedNetRootName));
              Status = SmbPutUnicodeStringAndUpcase(pBufferPointer,&XlatedNetRootName,pBufferSize);
          } else {
              Status = STATUS_INSUFFICIENT_RESOURCES;
          }
      }
#else
      Status = SmbPutUnicodeStringAndUpcase(pBufferPointer,pNetRootName,pBufferSize);
#endif //#if ZZZ_MODE
   } else {
      RxDbgTrace( 0, (DEBUG_TRACE_CREATE), ("BuildCanonicalNetRootInformation -- tcstring as ascii\n"));
      *((PCHAR)*pBufferPointer) = '\\';
      *pBufferPointer += sizeof(CHAR);
      *pBufferSize -= sizeof(CHAR);
      Status = SmbPutUnicodeStringAsOemStringAndUpcase(pBufferPointer,pNetRootName,pBufferSize);
   }

   if (NT_SUCCESS(Status) && fPostPendServiceString) {
      // Put the desired service name in ASCII ( always )
      ULONG Length = strlen(s_NetRootTypeName[NetRootType]) + 1;
      if (*pBufferSize >= Length) {
         RtlCopyMemory(*pBufferPointer,s_NetRootTypeName[NetRootType],Length);
         *pBufferSize -= Length;
      } else {
         Status = STATUS_BUFFER_OVERFLOW;
      }
   }

   return Status;
}


NTSTATUS
CoreBuildTreeConnectSmb(
    PSMB_EXCHANGE     pExchange,
    PGENERIC_ANDX     pAndXSmb,
    PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange          -  the exchange instance

    pAndXSmb           - the tree connect to be filled in...it's not really a andX

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    USHORT   PasswordLength;

    PMRX_NET_ROOT NetRoot;

    UNICODE_STRING ServerName;
    UNICODE_STRING NetRootName;

    PSMBCE_SERVER  pServer;

    PREQ_TREE_CONNECT      pTreeConnect = (PREQ_TREE_CONNECT)pAndXSmb;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;

    BOOLEAN   AppendServiceString;
    PBYTE pBuffer;
    PCHAR ServiceName;// = s_NetRootTypeName[NET_ROOT_WILD];
    ULONG Length;// = strlen(ServiceName) + 1;

    PAGED_CODE();

    NetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
        ("CoreBuildTreeConnectSmb buffer,remptr %08lx %08lx, nrt=%08lx\n",
         pAndXSmb,
         pAndXSmbBufferSize,
         NetRoot->Type));

    pServer = SmbCeGetExchangeServer(pExchange);
    SmbCeGetServerName(NetRoot->pSrvCall,&ServerName);
    SmbCeGetNetRootName(NetRoot,&NetRootName);
    ServiceName = s_NetRootTypeName[NetRoot->Type];
    Length = strlen(ServiceName) + 1;

    pTreeConnect->WordCount = 0;
    AppendServiceString     = FALSE;
    pBuffer = (PBYTE)pTreeConnect + FIELD_OFFSET(REQ_TREE_CONNECT,Buffer);
    *pBuffer = 0x04;
    pBuffer++;
    *pAndXSmbBufferSize -= (FIELD_OFFSET(REQ_TREE_CONNECT,Buffer)+1);

    // put in the netname

    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb before bcnri buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    Status = BuildCanonicalNetRootInformation(
                 &ServerName,
                 &NetRootName,
                 pExchange->SmbCeContext.pVNetRoot->pNetRoot->Type,
                 (BOOLEAN)(pServer->Dialect >= NTLANMAN_DIALECT),
                 AppendServiceString,
                 &pBuffer,
                 pAndXSmbBufferSize);

    if (!NT_SUCCESS(Status))
        return Status;

    // put in the password
    pBuffer = (PBYTE)pTreeConnect + OriginalBufferSize - *pAndXSmbBufferSize;
    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb88 buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));

    *pBuffer = 0x04;
    pBuffer++;
    *pAndXSmbBufferSize -= 1;

    if (pServer->SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
        // The password information needs to be sent as part of the tree connect
        // SMB for share level servers.

        //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb before btcsi buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
        Status = BuildTreeConnectSecurityInformation(
                     pExchange,
                     pBuffer,
                     (PBYTE)&PasswordLength,
                     pAndXSmbBufferSize);
    }

    // string in the service string based on the netroot type

    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb beforesscopy buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    pBuffer = (PBYTE)pTreeConnect + OriginalBufferSize - *pAndXSmbBufferSize;
    *pBuffer = 0x04;
    pBuffer++;
    *pAndXSmbBufferSize -= 1;
    if (*pAndXSmbBufferSize >= Length) {
        RtlCopyMemory(pBuffer,ServiceName,Length);
        *pAndXSmbBufferSize -= Length;
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }

    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb beforesscopy buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    SmbPutUshort(
        &pTreeConnect->ByteCount,
        (USHORT)(OriginalBufferSize
                 - *pAndXSmbBufferSize
                 - FIELD_OFFSET(REQ_TREE_CONNECT,Buffer)
                )
        );

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb end buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    return Status;
}


NTSTATUS
LmBuildTreeConnectSmb(
    PSMB_EXCHANGE     pExchange,
    PGENERIC_ANDX     pAndXSmb,
    PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange          -  the exchange instance

    pAndXSmb           - the tree connect to be filled in...it's not really a andX

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    USHORT   PasswordLength;

    PMRX_NET_ROOT NetRoot;

    UNICODE_STRING ServerName;
    UNICODE_STRING NetRootName;

    PSMBCE_SERVER  pServer;

    PREQ_TREE_CONNECT_ANDX pTreeConnectAndX = (PREQ_TREE_CONNECT_ANDX)pAndXSmb;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;

    BOOLEAN   AppendServiceString;
    PBYTE pBuffer;
    PCHAR ServiceName;
    ULONG Length;

    PAGED_CODE();

    NetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
        ("LmBuildTreeConnectSmb buffer,remptr %08lx %08lx, nrt=%08lx\n",
          pAndXSmb,
          pAndXSmbBufferSize,
          NetRoot->Type));

    pServer = SmbCeGetExchangeServer(pExchange);
    SmbCeGetServerName(NetRoot->pSrvCall,&ServerName);
    SmbCeGetNetRootName(NetRoot,&NetRootName);
    ServiceName = s_NetRootTypeName[NetRoot->Type];
    Length = strlen(ServiceName) + 1;

    AppendServiceString         = TRUE;
    pTreeConnectAndX->WordCount = 4;
    SmbPutUshort(&pTreeConnectAndX->AndXReserved,0);
    SmbPutUshort(
        &pTreeConnectAndX->Flags,0);
    pBuffer = (PBYTE)pTreeConnectAndX + FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);
    *pAndXSmbBufferSize -= (FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer)+1);

    if (pServer->SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
        // The password information needs to be sent as part of the tree connect
        // SMB for share level servers.

        //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("LmBuildTreeConnectSmb before btcsi buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
        Status = BuildTreeConnectSecurityInformation(
                     pExchange,
                     pBuffer,
                     (PBYTE)&PasswordLength,
                     pAndXSmbBufferSize);

        if (Status == RX_MAP_STATUS(SUCCESS)) {
            pBuffer += PasswordLength;
            SmbPutUshort(&pTreeConnectAndX->PasswordLength,PasswordLength);
        }
    } else {
        pBuffer = (PBYTE)pTreeConnectAndX + FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);
        *pAndXSmbBufferSize -= FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);

        // No password is required for user level security servers as part of tree
        // connect
        SmbPutUshort(&pTreeConnectAndX->PasswordLength,0x1);
        *((PCHAR)pBuffer) = '\0';
        pBuffer    += sizeof(CHAR);
        *pAndXSmbBufferSize -= sizeof(CHAR);
        Status = STATUS_SUCCESS;
    }

    if (Status == STATUS_SUCCESS) {
        Status = BuildCanonicalNetRootInformation(
                     &ServerName,
                     &NetRootName,
                     pExchange->SmbCeContext.pVNetRoot->pNetRoot->Type,
                     (BOOLEAN)(pServer->Dialect >= NTLANMAN_DIALECT),
                     AppendServiceString,
                     &pBuffer,
                     pAndXSmbBufferSize);

      //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("LmBuildTreeConnectSmb beforesscopy buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));

        if (Status == RX_MAP_STATUS(SUCCESS)) {
            SmbPutUshort(
                &pTreeConnectAndX->ByteCount,
                (USHORT)(OriginalBufferSize
                         - *pAndXSmbBufferSize
                         - FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer)
                        )
                );
        }

        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
            ("LmBuildTreeConnectSmb end buffer,rem %08lx %08lx\n",
             pBuffer,
             *pAndXSmbBufferSize));
    }

    return Status;
}

NTSTATUS
NtBuildTreeConnectSmb(
    PSMB_EXCHANGE     pExchange,
    PGENERIC_ANDX     pAndXSmb,
    PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange  - the exchange instance

    pAndXSmb - the session setup to be filled in

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS); //bob: note cool macro syntax..........

    UNICODE_STRING ServerName;
    UNICODE_STRING NetRootName;

    PSMBCE_SERVER  pServer;

    PREQ_TREE_CONNECT_ANDX pTreeConnect = (PREQ_TREE_CONNECT_ANDX)pAndXSmb;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;
    PBYTE pBuffer;
    ULONG BufferSize;

    PAGED_CODE();

    BufferSize = OriginalBufferSize;

    pServer = SmbCeGetExchangeServer(pExchange);

    SmbCeGetServerName(pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall,&ServerName);
    SmbCeGetNetRootName(pExchange->SmbCeContext.pVNetRoot->pNetRoot,&NetRootName);

    pTreeConnect->AndXCommand = 0xff;   // No ANDX
    pTreeConnect->AndXReserved = 0x00;  // Reserved (MBZ)

    SmbPutUshort(&pTreeConnect->AndXOffset, 0x0000); // No AndX as of yet.

    pTreeConnect->WordCount = 4;

    SmbPutUshort(
        &pTreeConnect->Flags,
        TREE_CONNECT_ANDX_EXTENDED_RESPONSE);      //do not specify disconnect

    pBuffer = (PBYTE)pTreeConnect + FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);
    BufferSize -=  FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);

    if(pServer->SecurityMode == SECURITY_MODE_USER_LEVEL){
        // No password information is required as part of tree connect for user level
        // security servers. Therefore send a null string as the password.
        SmbPutUshort(&pTreeConnect->PasswordLength,0x1);

        *((PCHAR)pBuffer) = '\0';
        pBuffer    += sizeof(CHAR);
        BufferSize -= sizeof(CHAR);
    } else {
        USHORT PasswordLength;
        //plug in the password for this server.....qweee
        Status = BuildTreeConnectSecurityInformation(
                     pExchange,
                     pBuffer,
                     (PBYTE)&PasswordLength,
                     &BufferSize);

        if (Status == RX_MAP_STATUS(SUCCESS)) {
            pBuffer += PasswordLength;
            SmbPutUshort(&pTreeConnect->PasswordLength,PasswordLength);
        }
    }

    if (NT_SUCCESS(Status)) {
        Status = BuildCanonicalNetRootInformation(
                     &ServerName,
                     &NetRootName,
                     NET_ROOT_WILD, //let the server tell us!  pNetRoot->Type,
                     BooleanFlagOn(pServer->DialectFlags,DF_UNICODE),
                     TRUE, //postpend the service string
                     &pBuffer,
                     &BufferSize);
    }

    if (NT_SUCCESS(Status)) {
        SmbPutUshort(
            &pTreeConnect->ByteCount,
            (USHORT)(OriginalBufferSize -
             FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer) -
             BufferSize));
    }

    // update the buffer size to reflect the amount consumed.
    *pAndXSmbBufferSize = BufferSize;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\bulk.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    bulk.c

Abstract:

    This module implements the mini redirector call down routines pertaining
    to bulk reads of file system objects.

Author:

    Rod Gamache    [rodga]      19-June-1995


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define Dbg         (DEBUG_TRACE_READ)

#define MIN(a,b) ( (a) < (b) ? (a) : (b) )

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, ProcessReadBulkCompressed)
#pragma alloc_text(PAGE, MRxSmbBuildReadBulk)
#pragma alloc_text(PAGE, MRxSmbReadBulkContinuation)
#endif

VOID
ProcessReadBulkCompressed (
    IN  PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    OUT PMDL        *pDataBufferPointer,
    IN  ULONG             Remain
    )
/*++

Routine Description:

    This routine processes a read bulk compressed message.

Inputs:

    OrdinaryExchange - The exchange instance.

    pDataBufferPointer - Pointer to an RX_MEM_DESC (MDL) to receive data into.

    Remain - bytes remaining to send (compressed or uncompressed).

Returns:

    NONE.

Notes:

    If the data all fits in the SMB buffer and it's a primary response, then
    use the HeaderMdl to receive the data, since it points at the SMB buffer.

    If the data doesn't all fit, but what's left fits in the SMB buffer, then
    use the HeaderMdl again.

    Lastly, we will build a partial mdl mapping the user buffer, and chain
    on the PartialHeaderMdl for the remainder.

--*/
{
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    ULONG CopyBufferLength = rw->CompressedByteCount;
    ULONG startOffset;
    ULONG partialLength;
    ULONG lengthNeeded;
    PMDL userMdl;
    PMDL curMdl;
    PMDL HeaderMdl;
    PMDL SubmitMdl;
    PCHAR startVa;

    //
    // We should appear later in FinishReadBulk (BULK.C) to actually
    // do the decompression.
    //

    //
    // Use all of the header mdl (including data buffer) for the
    // compressed data receive.
    //

    PAGED_CODE();

    HeaderMdl = StufferState->HeaderMdl;
    ASSERT( MmGetMdlByteCount( HeaderMdl ) >= 0x1000 );
    //CODE.IMPROVEMENT for 4KB (0x1000) above!

    //
    // We cannot use the HeaderPartialMdl, since it may still be in use
    // by the last transmit.
    //

    SubmitMdl = rw->CompressedTailMdl;

    //
    // Get the user's buffer mdl. We'll use the back part of this mdl (if
    // needed) for part of the receive data.
    //

    userMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;
    ASSERT( userMdl != NULL );

    partialLength = MmGetMdlByteCount( userMdl );

    ASSERT( LowIoContext->ParamsFor.ReadWrite.ByteCount <= partialLength );

    //
    // If all of the data fits in the Header Mdl (which we put last) and
    // this is the first message then use the Header Mdl.
    //

    if ( ( OrdinaryExchange->SmbBufSize >= (CopyBufferLength + Remain) ) &&
         ( rw->Flags & READ_BULK_COMPRESSED_DATA_INFO ) ) {

        //
        // The data will all fit in the Header Mdl.
        //

        IoBuildPartialMdl(
            HeaderMdl,
            SubmitMdl,
            MmGetMdlVirtualAddress( HeaderMdl ),
            CopyBufferLength );

        rw->BulkOffset = 0;

        //
        // If there is data remaining (we expect a secondary message),
        // then prepare for that case.
        //

        if ( Remain ) {
            rw->PartialBytes = partialLength + CopyBufferLength;
        }

        *pDataBufferPointer = SubmitMdl;

    } else {

        //
        // Build a partial mdl from the HeaderMdl. We'll need all of this
        // mdl for receiving the data.
        //

        IoBuildPartialMdl(
            HeaderMdl,
            SubmitMdl,
            MmGetMdlVirtualAddress( HeaderMdl ),
            OrdinaryExchange->SmbBufSize );

        //
        // Generate a partial mdl based on the user's buffer mdl. We'll use
        // the back part of this mdl (if needed) for part of the receive data.
        //

        //
        // In order to know where to start receiving data, we need to know if
        // this is a secondary response. If this is the primary response, then
        // just calculate the correct position in the user buffer to receive
        // the data. Otherwise, for secondary responses, we need to continue
        // where we left off from the primary response.
        //

        if ( rw->Flags & READ_BULK_COMPRESSED_DATA_INFO ) {

            //
            // This is a primary response.
            //

            //
            // Calculate starting offset from start of user buffer.
            //

            startOffset = partialLength +
                          OrdinaryExchange->SmbBufSize -
                          rw->ThisBufferOffset -
                          (CopyBufferLength + Remain);

            ASSERT( startOffset <= partialLength );

            //
            // Save the offset to start of CDI, and displacement for next
            // read. The start offset cannot be zero! If it is, then where
            // could we decompress into!
            //

            ASSERT( startOffset != 0 );
            rw->BulkOffset = startOffset;
            rw->PartialBytes = CopyBufferLength;

        } else {
            //
            // This is a secondary response.
            //

            ASSERT( rw->BulkOffset != 0 );

            //
            // Calculate next read address, and bump displacement.
            //

            startOffset = rw->BulkOffset + rw->PartialBytes;
            rw->PartialBytes += CopyBufferLength;

            //
            // If we have crossed over the user mdl and are now using the
            // exchange buffer, then we just need to figure out how much
            // of the exchange buffer we need to use. This will only happen
            // if the last fragment is around 4KB, but the original request
            // was bigger than 64KB (ie what we can fit in a single fragment).
            // So this should not happen very often.
            //

            if ( startOffset > partialLength ) {
                startOffset -= partialLength;

                partialLength = MmGetMdlByteCount( SubmitMdl );

                //
                // Calculate length needed from exchange buffer.
                //

                lengthNeeded = partialLength - startOffset;

                *pDataBufferPointer = SubmitMdl;

                //
                // Build the partial mdl.
                //

                startVa = (PCHAR)MmGetMdlVirtualAddress( SubmitMdl ) + startOffset;

                IoBuildPartialMdl(
                    HeaderMdl,
                    SubmitMdl,
                    startVa,
                    lengthNeeded );

                SubmitMdl->Next = NULL;

                return;
            }
        }

        //
        // Calculate length needed from user portion of Mdl.
        //

        lengthNeeded = partialLength - (startOffset + rw->ThisBufferOffset);
        lengthNeeded = MIN( lengthNeeded, CopyBufferLength);

        //
        // Get the temp mdl
        //

        curMdl = (PMDL)((PCHAR)rw->BulkBuffer + COMPRESSED_DATA_INFO_SIZE);

        *pDataBufferPointer = curMdl;

        //
        // Build the partial mdl chain.
        //

        startVa = (PCHAR)MmGetMdlVirtualAddress( userMdl ) +
                  startOffset +
                  rw->ThisBufferOffset;

        IoBuildPartialMdl(
            userMdl,
            curMdl,
            startVa,
            lengthNeeded );

        //
        // Link the submit mdl into the partial we just built.
        //

        curMdl->Next = SubmitMdl;

    }

    SubmitMdl->Next = NULL;

} // ProcessReadBulkCompressed

NTSTATUS
MRxSmbBuildReadBulk (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PLARGE_INTEGER ByteOffsetAsLI,
    ULONG ByteCount,
    ULONG MaxMessageSize,
    BOOLEAN Compressed
    )
/*++

Routine Description:

   This routine builds a ReadBulk SMB. We don't have to worry about login id
   and such since that is done by the connection engine....pretty neat huh?
   All we have to do is to format up the bits.

   DOWNLEVEL This routine only works with the ntreadandX.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   NTSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something in the arguments can't be handled.

Notes:


--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    ULONG OffsetLow,OffsetHigh;
    UCHAR RequestCompressed;


    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildReadBulk\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RequestCompressed = ( Compressed ? CompressionTechnologyOne :
                                       CompressionTechnologyNone );

    OffsetLow = ByteOffsetAsLI->LowPart;
    OffsetHigh = ByteOffsetAsLI->HighPart;

    COVERED_CALL(
        MRxSmbStartSMBCommand (
            StufferState,
            SetInitialSMB_Never,
            SMB_COM_READ_BULK,
            SMB_REQUEST_SIZE(READ_BULK),
            NO_EXTRA_DATA,
            NO_SPECIAL_ALIGNMENT,
            RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
            0,0,0,0 STUFFERTRACE(Dbg,'FC')) );

    RxDbgTrace(0, Dbg,("Bulk Read status = %lu\n",Status));
    MRxSmbDumpStufferState (1000,"SMB w/ READ_BULK before stuffing",StufferState);

    if ( FlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_PAGING_IO)) {
        SmbPutAlignedUshort(
            &NtSmbHeader->Flags2,
            SmbGetAlignedUshort(&NtSmbHeader->Flags2)|SMB_FLAGS2_PAGING_IO );
    }

    MRxSmbStuffSMB (StufferState,
         "0wwDddddB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 12
              smbSrvOpen->Fid,      //  w         USHORT Fid;                         // File Id
              RequestCompressed,    //  w         USHORT CompressionTechnology;       // CompressionTechnology
              SMB_OFFSET_CHECK(READ_BULK, Offset)
              OffsetLow, OffsetHigh, //  Dd       LARGE_INTEGER Offset;               // Offsetin file to begin read
              ByteCount,            //  d         ULONG MaxCount;                     // Max number of bytes to return
              0,                    //  d         ULONG MinCount;
      // Min number of bytes to return
              MaxMessageSize,       //  d         ULONG MessageSize;
      // Max number of bytes to send per message
                                    //  B         USHORT ByteCount;                   // Count of data bytes = 0
              SMB_WCT_CHECK(12) 0
                                    //            UCHAR Buffer[1];                    // empty
             );
    MRxSmbDumpStufferState (700,"SMB w/ READ_BULK after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return Status;

}  // MRxSmbBuildReadBulk


NTSTATUS
MRxSmbReadBulkContinuation(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange)
/*++

Routine Description:

    This routine decompresses the read data if needed.

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbReadBulkContinuation\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbReadBulkContinuation:");

    ASSERT( CompressionTechnologyNone == 0 );

    if ( (OrdinaryExchange->Status == RX_MAP_STATUS(SUCCESS)) &&
         (rw->CompressionTechnology) ) {
        //
        // The data is compressed.
        //
        //CODE.IMPROVEMENT we should get the Mdls directly from the OE instead the StffState
        PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
        PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
        ULONG lengthNeeded;
        ULONG partialLength;
        PMDL mdl;
        PUCHAR cdiBuffer;
        PUCHAR startVa1, startVa2;
        ULONG length1, length2;

        //
        // Clean up any mappings for the TailMdl
        //

        MmPrepareMdlForReuse( rw->CompressedTailMdl );

        //
        // First, we must copy the CompressionDataInfo to a safe place!
        //

        lengthNeeded = rw->DataOffset;
        ASSERT( lengthNeeded <= COMPRESSED_DATA_INFO_SIZE );
        ASSERT( lengthNeeded >= 0xC );

        cdiBuffer = rw->BulkBuffer;

        //
        //  The Mdl chain should consist of two pieces - one describing
        //  the uncompressed buffer (in-place decompress), and one
        //  describing the tail (at least a compression unit).  Get
        //  their addresses and lengths now.
        //
        // If we used the Header Mdl to receive all of the data, then there
        // is not second mdl.
        //

        if ( rw->BulkOffset == 0 ) {
            //
            // The mdl used was the CompressedTailMdl.
            //
            mdl = rw->CompressedTailMdl;
            startVa1 = (PCHAR)MmGetSystemAddressForMdlSafe(mdl,LowPagePriority);
            length1 = MmGetMdlByteCount( mdl );
            startVa2 = NULL;
            length2 = 0;
        } else {
            //
            // The first mdl is the user's buffer mdl.
            // The second mdl is the header mdl (all of it!).
            // The BulkOffset is from the start of the user's buffer mdl.
            //
            mdl = LowIoContext->ParamsFor.ReadWrite.Buffer;
            startVa1 = (PCHAR)rw->UserBufferBase + rw->BulkOffset + rw->ThisBufferOffset;
            length1 = MmGetMdlByteCount( mdl ) - (rw->BulkOffset + rw->ThisBufferOffset);
            startVa2 = (PCHAR)MmGetSystemAddressForMdlSafe(StufferState->HeaderMdl,LowPagePriority);
            length2 = MmGetMdlByteCount( StufferState->HeaderMdl );
        }

        //
        // The CompressionDataInfo could span multiple mdl's!
        //

        do {

            ASSERT( mdl != NULL );

            partialLength = MIN( length1, lengthNeeded );

            RtlCopyMemory( cdiBuffer, startVa1, partialLength );

            cdiBuffer += partialLength;
            startVa1 += partialLength;

            mdl = mdl->Next;
            lengthNeeded -= partialLength;
            length1 -= partialLength;

            if (length1 == 0) {
                startVa1 = startVa2;
                length1 = length2;
                startVa2 = NULL;
                length2 = 0;
            }

        } while ( lengthNeeded != 0 );


        Status = RtlDecompressChunks(
                     (PCHAR)rw->UserBufferBase + rw->ThisBufferOffset,
                     LowIoContext->ParamsFor.ReadWrite.ByteCount,
                     startVa1,
                     length1,
                     startVa2,
                     length2,
                     (PCOMPRESSED_DATA_INFO)rw->BulkBuffer );

        if (Status == STATUS_SUCCESS) {
            rw->BytesReturned = LowIoContext->ParamsFor.ReadWrite.ByteCount;
            rw->RemainingByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
        }

    }

    if ( rw->CompressedRequest ) {
        ASSERT( rw->BulkBuffer != NULL );
        RxFreePool( rw->BulkBuffer );
        IF_DEBUG rw->BulkBuffer = NULL;
    }


    RxDbgTrace(-1, Dbg, ("MRxSmbReadBulkContinuation   returning %08lx\n", Status ));
    return Status;

} // MRxSmbReadBulkContinuation

UCHAR
MRxSmbBulkReadHandler_NoCopy (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
#if DBG
    IN  UCHAR       ThisIsAReenter,
#endif
    IN  PRESP_READ_ANDX       Response
      )
/*++

Routine Description:

    This routine causes the bytes from the message to be transferred to the user's
    buffer. In order to do this, it takes enough bytes from the indication and
    then crafts up an MDL to cause the transport to do the copy.

Arguments:

    please refer to smbpse.c...the only place from which this may be called

Return Value:

    UCHAR - a value representing the action that OE receive routine will perform.
    options are discard (in case of an error), and normal

--*/
{
    NTSTATUS SmbStatus;

    ULONG ByteCount;
    ULONG Remain;
    ULONG CopyBufferLength;

    PGENERIC_ANDX CommandState;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PMDL OriginalDataMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;
    PCHAR startVa;

    PBYTE Buffer;
    ULONG BytesReturned,DataOffset;
    PMDL ReadMdl;

    PRESP_READ_BULK ReadBulkResponse;

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishReadNoCopy\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishReadNoCopy:");

    SmbStatus = OrdinaryExchange->SmbStatus;
    ReadBulkResponse = (PRESP_READ_BULK)(pSmbHeader + 1 );
    CommandState = &OrdinaryExchange->ParseResumeState;

    ASSERT( (OrdinaryExchange->OEType == SMBPSE_OETYPE_READ) );

    LowIoContext = &RxContext->LowIoContext;
    ASSERT( LowIoContext->ParamsFor.ReadWrite.Buffer != NULL );
    ASSERT( LowIoContext->ParamsFor.ReadWrite.ByteCount != 0 );

    //
    // Make sure we can at least read the smb header!
    //
    ASSERT( BytesIndicated >= sizeof(SMB_HEADER) +
            FIELD_OFFSET(RESP_READ_BULK, Buffer) );

    ReadBulkResponse = (PRESP_READ_BULK)(pSmbHeader + 1 );

    //
    // Get the count of bytes 'covered' by this message. This is the
    // number of bytes the user expects to see.
    //

    ByteCount = SmbGetUlong( &ReadBulkResponse->Count );
    Remain = SmbGetUlong( &ReadBulkResponse->Remaining );

    rw->Flags = ReadBulkResponse->Flags;
    rw->CompressionTechnology = ReadBulkResponse->CompressionTechnology;

    //
    // Now get the actual number of data bytes in this message.
    // Remember, the data may be compressed, so this total could
    // be less than the 'Count' field above.
    //

    CopyBufferLength = SmbGetUlong( &ReadBulkResponse->DataCount );

    //
    // If CompressionTechnology is not zero then the data is compressed
    // otherwise the data is uncompressed.
    //

    if ( rw->CompressionTechnology == CompressionTechnologyNone ) {
        //
        // The data is not compressed!
        //

        ASSERT( rw->Flags == 0 );   // no flags should be on

        //
        // Set up to get the data into the user's buffer.
        // CODE.IMPROVEMENT -we need to be able to cancel this big read!
        //
        // If ThisBufferOffset is non-zero or BytesReturned is non-zero,
        // then we have to partial the data back into the user's buffer.
        // Also if the data lengths don't match - is this needed?
        // Otherwise, can can take the whole user's buffer.
        //

        if ( rw->ThisBufferOffset || rw->BytesReturned ||
             CopyBufferLength != LowIoContext->ParamsFor.ReadWrite.ByteCount ) {

            //
            // We should NOT get any mdl chains!
            //

            ASSERT( LowIoContext->ParamsFor.ReadWrite.Buffer->Next == NULL );

            //
            // CopyBufferLength will be zero if we tried to read beyond
            // end of file!
            //

            if ( CopyBufferLength != 0 ) {
                //
                // Partial the data into the user's buffer.
                //

                startVa = MmGetMdlVirtualAddress(
                              LowIoContext->ParamsFor.ReadWrite.Buffer);

                startVa += rw->ThisBufferOffset + rw->BulkOffset;
                rw->BulkOffset += CopyBufferLength;

                ASSERT( OrdinaryExchange->DataPartialMdl != NULL );
                *pDataBufferPointer = OrdinaryExchange->DataPartialMdl;

                MmPrepareMdlForReuse( OrdinaryExchange->DataPartialMdl );

                ASSERT( CopyBufferLength <= MAXIMUM_PARTIAL_BUFFER_SIZE);
                ASSERT( CopyBufferLength <= ByteCount );

                IoBuildPartialMdl(
                    LowIoContext->ParamsFor.ReadWrite.Buffer,
                    OrdinaryExchange->DataPartialMdl,
                    startVa,
                    CopyBufferLength);
            }
        } else {

            //
            // We can take the whole buffer.
            //

            *pDataBufferPointer = LowIoContext->ParamsFor.ReadWrite.Buffer;
        }

        //
        // Take bytes up to the start of the actual data.
        //

        *pBytesTaken = sizeof(SMB_HEADER) +
                    FIELD_OFFSET(RESP_READ_BULK, Buffer) +
                    (ULONG)SmbGetUshort(&ReadBulkResponse->DataOffset);
        ASSERT( BytesAvailable >= *pBytesTaken );

    } else {

        //
        // The data is compressed. We need to do more work to get the
        // data into the correct position within the buffer.
        //

        //
        // If this is a primary response, then save DataOffset.
        //

        if ( rw->Flags & READ_BULK_COMPRESSED_DATA_INFO ) {
            rw->DataOffset = SmbGetUshort( &ReadBulkResponse->DataOffset );
            ASSERT( *((PCHAR)ReadBulkResponse + FIELD_OFFSET(RESP_READ_BULK, Buffer) ) == COMPRESSION_FORMAT_LZNT1 );
        }

        rw->CompressedByteCount = CopyBufferLength;

        ProcessReadBulkCompressed(
            OrdinaryExchange,
            pDataBufferPointer,
            Remain );

        //
        // Take bytes up to the start of the actual data.
        //

        *pBytesTaken = sizeof(SMB_HEADER) +
                      FIELD_OFFSET(RESP_READ_BULK, Buffer);

        ASSERT( BytesAvailable >= *pBytesTaken );
    }

    // Setup to execute the finish routine when done. We'll do the
    // decompression at that time (if needed).

    OrdinaryExchange->ContinuationRoutine = MRxSmbReadBulkContinuation;

    //
    // Reduce the number of bytes expected. If we expect more, then
    // put down another receive.
    //

    rw->BytesReturned += CopyBufferLength;
    rw->ThisByteCount = Remain;

    if (Remain != 0) {
        if ( rw->ThisByteCount ) {
            OrdinaryExchange->Status = SmbCeReceive((PSMB_EXCHANGE)OrdinaryExchange );
        }
    }
    //
    // Tell the VC handler that we need the following bytes read
    // and copied to the user's buffer.
    //

    *pDataSize = CopyBufferLength;

    OrdinaryExchange->OpSpecificFlags |= OE_RW_FLAG_SUCCESS_IN_COPYHANDLER;
    if ( CopyBufferLength != 0 ) {
        OrdinaryExchange->ParseResumeState = *CommandState;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishReadNoCopy   mdlcopy fork \n" ));
    return SMBPSE_NOCOPYACTION_MDLFINISH;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\bulkw.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    bulkw.c  - this file needs to get folded into write.c

Abstract:

    This module implements the mini redirector call down routines pertaining to write
    of file system objects.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

Notes:

    The WRITE_BULK is an example of a potential multi SMB exchange that uses the
    associated exchange infra structure in the connection engine in conjunction with
    the continuation capability in the ORDINARY_EXCHANGE.

    The WRITE_BULK processing involves the following steps ...

        1) send a SMB_WRITE_BULK request to the server.

        2) process the SMB_WRITE_BULK response from the server and if successful
        spin up SMB_WRITE_BULK_DATA requests to write the data to the server. There
        are no responses from the server for the various SMB_WRITE_BULK_DATA requests.

        3) On completion of the SMB_WRITE_BULK_DATA requests wait for the final
        SMB_WRITE_BULK response from the server.

    This sequence of SMB exchanges is implemented in the following manner ...

    1) An instance of ORDINARY_EXCHANGE is created and submitted to the connection
    engine spin up the initial request.

    2) If the response indicated success the continuation routine in the ORDINARY_EXCHANGE
    is set to MRxSmbWriteBulkContinuation.

    3) On finalization by the connection engine the processing is resumed in
    MRxSmbWriteBulkDataContinuation. Here the ORDINARY_EXCHANGE instance is reset,
    the preparation made for receiving the final response. The SMB_WRITE_BULK_DATA
    requests are spun up as associated exchanges. Currently the SMB_WRITE_BULK_DATA
    requests are spun up in batches of atmost MAXIMUM_CONCURRENT_WRITE_BULK_DATA_REQUESTS

    On completion ofone batch of requests the next batch is spun up. This is one place
    where the logic needs to be fine tuned based upon observed performance. The
    approaches can range from spinning one request at a time to the current implementation.
    A variation would be to spin them up in batches but have each completion trigger of
    further processing. This would involve changes in when the associated exchange
    completion handler routine in the connection engine is activated.

    One final note --- the ContinuationRoutine is changed on the fly by the bulk data
    processing to ensure that the same ordinary exchange continuation infra structure
    is used to deal with the end case.

--*/

#include "precomp.h"
#pragma hdrstop

#include "bulkw.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))

#define MIN_CHUNK_SIZE (0x1000)

#define MAXIMUM_CONCURRENT_WRITE_BULK_DATA_REQUESTS (5)

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, ProcessWriteBulkCompressed)
#pragma alloc_text(PAGE, MRxSmbBuildWriteBulk)
#pragma alloc_text(PAGE, MRxSmbFinishWriteBulkData)
#pragma alloc_text(PAGE, MRxSmbWriteBulkContinuation)
#pragma alloc_text(PAGE, MRxSmbBuildWriteBulkData)
#pragma alloc_text(PAGE, MRxSmbInitializeWriteBulkDataExchange)
#pragma alloc_text(PAGE, MRxSmbWriteBulkDataExchangeStart)
#pragma alloc_text(PAGE, MRxSmbWriteBulkDataExchangeFinalize)
#endif

extern SMB_EXCHANGE_DISPATCH_VECTOR  SmbPseDispatch_Write;


//
// Forward declarations
//

NTSTATUS
MRxSmbBuildWriteBulkData (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PLARGE_INTEGER ByteOffsetAsLI,
    IN     UCHAR Sequence,
    IN     ULONG ByteCount,
    IN     ULONG Remaining
    );


NTSTATUS
MRxSmbInitializeWriteBulkDataExchange(
    PSMB_WRITE_BULK_DATA_EXCHANGE   *pWriteBulkDataExchangePointer,
    PSMB_PSE_ORDINARY_EXCHANGE      pWriteExchange,
    PSMB_HEADER                     pSmbHeader,
    PREQ_WRITE_BULK_DATA            pWriteBulkDataRequest,
    PMDL                            pDataMdl,
    ULONG                           DataSizeInBytes,
    ULONG                           DataOffsetInBytes,
    ULONG                           RemainingDataInBytes);


NTSTATUS
MRxSmbWriteBulkDataExchangeFinalize(
   IN OUT struct _SMB_EXCHANGE *pExchange,
   OUT    BOOLEAN              *pPostRequest);

VOID
ProcessWriteBulkCompressed (
    IN PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    )
/*++

Routine Description:

    This routine attempts to perform a write bulk operation.

Arguments:

    OrdinaryExchange - pointer to the current ordinary exchange request.

Return Value:

    NONE.

Notes:

    rw->CompressedRequest - TRUE we have succeeded in making the buffer
                            compressed.  FALSE otherwise.

    This is the initial routine that is called to do the necessary preprocessing
    of the only kind of compressed write requests that are handled on the client side

    These are write requests that are page aligned for an integral number of pages
    to a compressed server.

--*/
{
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    NTSTATUS status;
    PVOID workSpaceBuffer;
    ULONG workSpaceBufferSize;
    ULONG workSpaceFragmentSize;
    ULONG compressedInfoLength;
    PCOMPRESSED_DATA_INFO compressedDataInfo;
    ULONG i;
    PMDL mdl;
    ULONG headerLength;

//RNGFIX
//
// We can also use the call to RxGetCompressionWorkSpaceSize as a test to see
// if the current system knows how to handle the CompressionFormat/Engine on a
// read request.
//
// We also need a workspace buffer. We can get the size of this buffer from
// the call to RxGetCompressionWorkspace. We can have 1 statically allocated
// workspace buffer (per File! if we find we don't have one, then return
// a failure and do uncompressed writes!) This is recommended per file, since
// the size of the workspace is dependent on the compression type, which can
// vary on a per file basis.
//
// We must then pass the CDI ptr to the build write bulk request routine.
//
// We can then start writing the compressed data to the server in the finish
// routine.
//
//RNGFIX - remember to deallocate this buffer on the cleanup side!

    PAGED_CODE();

    rw->CompressedRequest = FALSE;
    rw->DataOffset = 0;
    rw->CompressedByteCount = 0;

    //
    // Calculate length of the needed CDI.
    //

    compressedInfoLength = (sizeof(COMPRESSED_DATA_INFO) + 7 +
              (((rw->ThisByteCount + MIN_CHUNK_SIZE - 1) / MIN_CHUNK_SIZE) * 4))
              &~7;
    ASSERT( compressedInfoLength <= 65535 );

    //
    // Allocate the buffer to compress into. We could get tricky here and
    // allocate a portion of the buffer, like 15/16ths if the compression unit
    // shift (this would be for 16 sectors per compression unit). We will
    // allocate the CDI along with this.
    //

    compressedDataInfo = (PCOMPRESSED_DATA_INFO)RxAllocatePoolWithTag(
                                                   NonPagedPool,
                                                   rw->ThisByteCount + compressedInfoLength,
                                                   MRXSMB_RW_POOLTAG);

    //
    // If we fail, just return an error.
    //
    if ( compressedDataInfo == NULL ) {
        return;
    }

    //
    // Save buffer address (not we skip past the CDI). We need to back
    // up the buffer address on the free later.
    //

    rw->BulkBuffer = (PCHAR)compressedDataInfo + compressedInfoLength;
    rw->DataOffset = (USHORT)compressedInfoLength;

    //
    // Fill in the CDI. RNGFIX - we need to get this data from the open!
    // CODE.IMPROVEMENT
    //

    compressedDataInfo->CompressionFormatAndEngine = COMPRESSION_FORMAT_LZNT1;
    compressedDataInfo->ChunkShift = 0xC;
    compressedDataInfo->CompressionUnitShift = 0xD;
    compressedDataInfo->ClusterShift = 0x9;

    //
    // Allocate the workspace buffer. We will allocate this separately, since
    // it is only needed for the duration of the compression operation. We'll
    // free it when we're done. We could just do this once when the file is
    // is opened. We know all of the info at that time, including the fact that
    // it is compressed. However, we'd be holding onto pool for much longer.
    //

    //RNGFIX - COMRPRESSION_FORMAT_LZNT1 should be from OpenFile!
    //CODE.IMPROVEMENT
    status = RtlGetCompressionWorkSpaceSize(
                 COMPRESSION_FORMAT_LZNT1,
                 &workSpaceBufferSize,
                 &workSpaceFragmentSize );

    workSpaceBuffer = RxAllocatePoolWithTag(
                           NonPagedPool,
                           workSpaceBufferSize,
                           MRXSMB_RW_POOLTAG);

    if ( workSpaceBuffer == NULL ) {
        RxFreePool( compressedDataInfo );
        rw->BulkBuffer = NULL;
        return;
    }

    status = RtlCompressChunks(
                 rw->UserBufferBase + rw->ThisBufferOffset,
                 rw->ThisByteCount,
                 rw->BulkBuffer,
                 rw->ThisByteCount,
                 compressedDataInfo,
                 compressedInfoLength,
                 workSpaceBuffer );

    RxFreePool( workSpaceBuffer );

    if ( status != RX_MAP_STATUS(SUCCESS) ) {
        RxFreePool( compressedDataInfo );
        return;
    }

    rw->CompressedRequest = TRUE;

    //
    // Calculate length of compressed data.
    //

    ASSERT( compressedDataInfo->NumberOfChunks < 256 );

    rw->CompressedByteCount = 0;
    for ( i = 0; i < compressedDataInfo->NumberOfChunks; i++ ) {
        rw->CompressedByteCount += compressedDataInfo->CompressedChunkSizes[i];
    }

    //
    // Build an mdl from the receive buffer - just after the SMB header
    //

    // Use the larger of the two headers we'll have to send.

    headerLength = MAX( FIELD_OFFSET(REQ_WRITE_BULK_DATA, Buffer),
                        FIELD_OFFSET(REQ_WRITE_BULK, Buffer) );

    mdl = (PMDL)(((ULONG)StufferState->BufferBase + sizeof(SMB_HEADER)
            + 10 + headerLength) & ~7);

    //
    // We will use the same mdl for both sending the CDI and the actual
    // compressed data. This mdl is part of the receive buffer - just after
    // the header.
    //

    // ASSERT( rw->CompressedByteCount >= compressedInfoLength );
    MmInitializeMdl( mdl, (PCHAR)rw->BulkBuffer - compressedInfoLength, compressedInfoLength );

    MmBuildMdlForNonPagedPool( mdl );

    return;

} // ProcessWriteBulkCompressed

NTSTATUS
MRxSmbBuildWriteBulk (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PLARGE_INTEGER ByteOffsetAsLI,
    IN     ULONG ByteCount,
    IN     ULONG MaxMessageSize,
    IN     PVOID CompressedDataInfo,
    IN     ULONG CompressedInfoSize,
    IN     ULONG CompressedBufferSize,
    IN     PMDL CompressedInfoMdl
    )
/*++

Routine Description:

   This builds a WriteBulk SMB. We don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? All we have
   to do is format up the bits.


Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

   ByteOffsetAsLI - the byte offset in the file where we want to write

   ByteCount - the length of the data to be written

   MaxMessageSize - the maximum message size that we can send

   CompressedDataInfo - pointer to the COMPRESSED_DATA_INFO structure

   CompressedInfoSize - size of the COMPRESSED_DATA_INFO structure (or zero)

   CompressedBufferSize - size of the Compressed Data

   CompressedInfoMdl - pointer to the compressed data info mdl

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PNT_SMB_HEADER SmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    ULONG OffsetLow,OffsetHigh;
    UCHAR WriteMode = 0;
    UCHAR CompressionTechnology;


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbBuildWriteBulk\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    OffsetLow = ByteOffsetAsLI->LowPart;
    OffsetHigh = ByteOffsetAsLI->HighPart;

    COVERED_CALL(MRxSmbStartSMBCommand( StufferState, SetInitialSMB_Never,
                                          SMB_COM_WRITE_BULK, SMB_REQUEST_SIZE(WRITE_BULK),
                                          NO_EXTRA_DATA,
                                          NO_SPECIAL_ALIGNMENT,
                                          RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                          0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("First write bulk status = %lu\n",Status));
    // MRxSmbDumpStufferState (1000,"SMB w/WRITE BULK before stuffing",StufferState);

    if (FlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_PAGING_IO)) {
        SmbPutAlignedUshort(
            &SmbHeader->Flags2,
            SmbGetAlignedUshort(&SmbHeader->Flags2)|SMB_FLAGS2_PAGING_IO);
    }

    ASSERT( SMB_WMODE_WRITE_THROUGH == 1 );
    if ( FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WRITE_THROUGH) ) {
        WriteMode |= SMB_WMODE_WRITE_THROUGH;
    }

    if ( CompressedInfoSize ) {
        CompressionTechnology = CompressionTechnologyOne;
    } else {
        CompressionTechnology = CompressionTechnologyNone;
    }

    MRxSmbStuffSMB (StufferState,
         "0yywDddddB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 12
               WriteMode,           //  y         UCHAR Flags;                        // Flags byte
               CompressionTechnology, // y        UCHAR CompressionTechnology
      // CompressionTechnology
               smbSrvOpen->Fid,     //  w         _USHORT( Fid );                     // File handle
               SMB_OFFSET_CHECK(WRITE_BULK, Offset)
               OffsetLow, OffsetHigh, //  Dd      LARGE_INTEGER Offset;               // Offset in file to begin write
               ByteCount,           //  d         _ULONG( TotalCount );               // Total amount of data in this request (ie bytes covered)
               CompressedBufferSize, // d         _ULONG( DataCount );                // Count of data bytes in this message, replaces ByteCount
               MaxMessageSize,      //  d         _ULONG( MessageSize );
      // Maximum bytes we can send per message
                                    //  B         _USHORT( ByteCount );               // Count of data bytes = 0, not used
              SMB_WCT_CHECK(12) CompressedInfoSize
                                    //            UCHAR Buffer[1];
             );

    SmbPutUshort( StufferState->CurrentBcc, (USHORT)CompressedInfoSize );

    if ( CompressedInfoSize ) {
        MRxSmbStuffAppendRawData( StufferState, CompressedInfoMdl );
    }

    //MRxSmbDumpStufferState (700,"SMB w/WRITE BULK after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return Status;

} // MRxSmbBuildWriteBulk

NTSTATUS
MRxSmbFinishWriteBulkData (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
    )
/*++

Routine Description:

    This routine completes the write bulk request processing. This routine must always
    return STATUS_PENDING to follow the correct processing in the ordinary exchange
    logic for synchronous operations. This is because this continuation routine will
    be invoked in other thread contexts

    This routine is used to wrap up synchronous bulk operations

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    PAGED_CODE();

    ASSERT(!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
    RxDbgTrace(0,Dbg,("Invoking Bulk Write wrap up for ....%lx\n",OrdinaryExchange));

    RxSignalSynchronousWaiter(RxContext);

    return STATUS_PENDING;
}

NTSTATUS
MRxSmbWriteBulkContinuation(
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
    )
/*++

Routine Description:

    This routine continues the Write bulk data request processing on receipt of
    a valid SMB_WRITE_BULK response from the server.

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PSMB_EXCHANGE pExchange = &OrdinaryExchange->Exchange;
    PMDL HeaderMdl = StufferState->HeaderMdl;
    PMDL SubmitMdl = StufferState->HeaderPartialMdl;
    ULONG MessageSize;
    ULONG SendBufferLength;
    ULONG RemainingByteCount,ThisBufferOffset;
    ULONG PartialBytes;
    LARGE_INTEGER ByteOffsetAsLI;
    PMDL DataMdl;
    PMDL SourceMdl;
    PREQ_WRITE_BULK_DATA WriteBulkHeader;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    PSMB_HEADER          pWriteBulkDataRequestSmbHeader;
    ULONG headerLength;
    ULONG ActiveWriteBulkDataRequests = 0;

    PAGED_CODE();

    headerLength = MAX( FIELD_OFFSET(REQ_WRITE_BULK_DATA, Buffer),
                        FIELD_OFFSET(REQ_WRITE_BULK, Buffer) );

    RxDbgTrace(+1, Dbg, ("MRxSmbWriteBulkContinuation\n"));
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    RxDbgTrace(0, Dbg, ("-->BytesReturned=%08lx\n", rw->BytesReturned));

    ASSERT( !RxShouldPostCompletion());

    //
    // Pick up our maximum message size
    //

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    MessageSize = MIN( rw->MaximumSendSize,
                       pServerEntry->pTransport->MaximumSendSize);
    ASSERT( MessageSize != 0 );
    ASSERT( rw->ThisByteCount != 0);

    ByteOffsetAsLI.QuadPart = rw->ByteOffsetAsLI.QuadPart;

    if (!FlagOn(rw->Flags,OE_RW_FLAG_WRITE_BULK_DATA_INITIALIZATION_DONE)) {
        SetFlag(rw->Flags,OE_RW_FLAG_WRITE_BULK_DATA_INITIALIZATION_DONE);

        SmbCeResetExchange((PSMB_EXCHANGE)OrdinaryExchange);

        ClearFlag(
            OrdinaryExchange->Flags,
            (SMBPSE_OE_FLAG_HEADER_ALREADY_PARSED |
             SMBPSE_OE_FLAG_OE_ALREADY_RESUMED) );

        SmbCeIncrementPendingLocalOperations((PSMB_EXCHANGE)OrdinaryExchange);

        if (OrdinaryExchange->Status == STATUS_SUCCESS) {
            SmbCeReceive((PSMB_EXCHANGE)OrdinaryExchange);

            //
            // Okay... we're now going to transform the exchange packet into one
            // that we can use for the WRITE_BULK_DATA request.
            //

            MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));

            //
            // Build a generic WriteBulkData request.  We'll fill in the specifics
            // as we re-use this buffer.
            //

            pWriteBulkDataRequestSmbHeader = (PSMB_HEADER)StufferState->BufferBase;
            WriteBulkHeader = (PREQ_WRITE_BULK_DATA)((PCHAR)StufferState->BufferBase +
                                sizeof(SMB_HEADER));

            MRxSmbBuildWriteBulkData(
                StufferState,
                &ByteOffsetAsLI,
                rw->Sequence,
                0,
                0);

            //
            // If we have compressed data, pick up the corresponding byte count and
            // Mdl for the data.  If we partial, we'll need to pick up another Mdl too.
            //

            ASSERT( CompressionTechnologyNone == 0 );
            if ( rw->CompressedRequest &&
                 rw->CompressionTechnology ) {
                // Eventhough we have sent compressed the entire buffer and sent the
                // compression meta data to the server it might choose to accept
                // less data. In such cases the client should be prepared to scale back
                // the data that needs to be sent. The server side will ensure that
                // the data that is accepted will correspond to an integral number of
                // chunks. This will ensure that the subsequent requests have a chance
                // of being compressed. If this is not true we have no way of restarting.
                // Based upon the compressed length that has been accepted we need to
                // determine the number of chunks. This can be translated to the
                // equivalent number of uncompressed bytes which will establish the
                // resumption point.
                //
                // Use the space in the receive buffer - after the header mdl - for
                // the data mdl.
                //

                if (rw->ThisByteCount < rw->CompressedByteCount) {
                    // This is the case where the server was not able to accept all
                    // of our compressed data in one shot.

                    ULONG NumberOfChunks = 0;
                    ULONG CumulativeChunkSize = 0;
                    PCOMPRESSED_DATA_INFO pCompressedDataInfo;

                    pCompressedDataInfo = (PCOMPRESSED_DATA_INFO)
                                          ((PCHAR)rw->BulkBuffer - rw->DataOffset);

                    for (;;) {
                        ULONG TempSize;

                        TempSize = CumulativeChunkSize +
                                   pCompressedDataInfo->CompressedChunkSizes[NumberOfChunks];

                        if (TempSize <= rw->ThisByteCount) {
                            NumberOfChunks++;
                            CumulativeChunkSize = TempSize;
                        } else {
                            break;
                        }
                    }

                    ASSERT(CumulativeChunkSize == rw->ThisByteCount);
                    pCompressedDataInfo->NumberOfChunks = (USHORT)NumberOfChunks;

                    rw->CompressedByteCount = CumulativeChunkSize;
                }

                RemainingByteCount = rw->CompressedByteCount;

                SourceMdl = (PMDL)(((ULONG)StufferState->BufferBase +
                           sizeof(SMB_HEADER) + 10 + headerLength) & ~7);

                //
                // Build an mdl for describing the compressed data.
                //

                MmInitializeMdl( SourceMdl, rw->BulkBuffer, rw->CompressedByteCount );
                MmBuildMdlForNonPagedPool( SourceMdl );

                ThisBufferOffset = 0;
            } else {

                // Pick up the rest of the data, and no need to partial.

                RemainingByteCount = rw->ThisByteCount;
                SourceMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;
                ThisBufferOffset = rw->ThisBufferOffset;
            }

            rw->PartialBytes = 0;
            rw->BytesReturned = 0;

            if (!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                KeInitializeEvent(
                    &RxContext->SyncEvent,
                    NotificationEvent,
                    FALSE );
            }
        } else {
            Status = OrdinaryExchange->Status;
            RemainingByteCount = 0;
        }
    } else {
        pWriteBulkDataRequestSmbHeader = (PSMB_HEADER)StufferState->BufferBase;
        WriteBulkHeader = (PREQ_WRITE_BULK_DATA)((PCHAR)StufferState->BufferBase +
                            sizeof(SMB_HEADER));

        ByteOffsetAsLI.QuadPart += rw->PartialBytes;
        ThisBufferOffset = rw->PartialBytes;

        if ( rw->CompressedRequest &&
             rw->CompressionTechnology ) {
            RemainingByteCount = rw->CompressedByteCount - rw->PartialBytes;

            SourceMdl = (PMDL)(((ULONG)StufferState->BufferBase +
                       sizeof(SMB_HEADER) + 10 + headerLength) & ~7);
        } else {
            RemainingByteCount = rw->ThisByteCount - rw->PartialBytes;

            SourceMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;
        }

        if ((OrdinaryExchange->Status != STATUS_SUCCESS) &&
            (OrdinaryExchange->Status != STATUS_MORE_PROCESSING_REQUIRED)) {
            RemainingByteCount = 0;
            Status = OrdinaryExchange->Status;
        }

        RxDbgTrace(
            0,
            Dbg,
            ("ABWR: OE %lx TBC %lx RBC %lx TBO %lx\n",
             OrdinaryExchange,
             rw->ThisByteCount,
             rw->RemainingByteCount,
             ThisBufferOffset));
    }

    while (RemainingByteCount > 0) {
        BOOLEAN AssociatedExchangeCompletionHandlerActivated = FALSE;
        PSMB_WRITE_BULK_DATA_EXCHANGE pWriteBulkDataExchange;

        //
        // Check if we need to build a partial mdl...
        //

        SendBufferLength = MIN( MessageSize, RemainingByteCount );

        // Get our offset and length in prepartion to build and
        // send the message.
        //
        // We manually setup the fields that change in the WriteBulkData
        // message, rather than build a new header each time to save
        // time and effort. This will happen once per message that we
        // send.
        //

        RemainingByteCount -= SendBufferLength;

        SmbPutUlong( &WriteBulkHeader->Offset.LowPart, ByteOffsetAsLI.LowPart );
        SmbPutUlong( &WriteBulkHeader->Offset.HighPart, ByteOffsetAsLI.HighPart );
        SmbPutUlong( &WriteBulkHeader->DataCount, SendBufferLength );
        SmbPutUlong( &WriteBulkHeader->Remaining, RemainingByteCount );

        Status = MRxSmbInitializeWriteBulkDataExchange(
                     &pWriteBulkDataExchange,
                     OrdinaryExchange,
                     pWriteBulkDataRequestSmbHeader,
                     WriteBulkHeader,
                     SourceMdl,
                     SendBufferLength,
                     ThisBufferOffset,
                     RemainingByteCount);

        // Advance offset and reduce the number of bytes written.

        ByteOffsetAsLI.QuadPart += SendBufferLength;
        ThisBufferOffset += SendBufferLength;
        rw->PartialBytes += SendBufferLength;

        if (Status == STATUS_SUCCESS) {
            ActiveWriteBulkDataRequests++;
            AssociatedExchangeCompletionHandlerActivated =
                ((ActiveWriteBulkDataRequests == MAXIMUM_CONCURRENT_WRITE_BULK_DATA_REQUESTS) ||
                 (RemainingByteCount == 0));

            if (AssociatedExchangeCompletionHandlerActivated &&
                (RemainingByteCount == 0)) {

                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationCompleted;

                if (!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                    OrdinaryExchange->ContinuationRoutine = MRxSmbFinishWriteBulkData;
                }
            }

            Status = SmbCeInitiateAssociatedExchange(
                         (PSMB_EXCHANGE)pWriteBulkDataExchange,
                         AssociatedExchangeCompletionHandlerActivated);
        }

        if (!NT_SUCCESS(Status)) {
            RxDbgTrace( 0, Dbg, ("SmbPseExchangeReceive_default: SmbCeSend returned %lx\n",Status));
            goto FINALLY;
        }

        if (AssociatedExchangeCompletionHandlerActivated) {
            if (!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                RxWaitSync( RxContext );
                Status = STATUS_SUCCESS;

                if (RemainingByteCount == 0) {
                    break;
                } else {
                    // Reinitialize the event
                    KeInitializeEvent(
                        &RxContext->SyncEvent,
                        NotificationEvent,
                        FALSE );
                    ActiveWriteBulkDataRequests = 0;
                }
            } else {
                // Map the status to delay cleanup operations.
                Status = STATUS_PENDING;
                break;
            }
        }
    }

FINALLY:

    if (Status != STATUS_PENDING) {
        OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationCompleted;

        if (Status == STATUS_SUCCESS) {
            if(rw->CompressedRequest &&
               rw->CompressionTechnology) {
                PCOMPRESSED_DATA_INFO pCompressedDataInfo;

                pCompressedDataInfo = (PCOMPRESSED_DATA_INFO)
                                      ((PCHAR)rw->BulkBuffer - rw->DataOffset);

                rw->BytesReturned = pCompressedDataInfo->NumberOfChunks * MIN_CHUNK_SIZE;
            } else {
                rw->BytesReturned = rw->ThisByteCount;
            }
        } else {
            rw->BytesReturned = 0;
        }

        if (rw->CompressedRequest &&
            rw->BulkBuffer != NULL) {
            // Free buffer from start of CDI
            RxFreePool( (PCHAR)rw->BulkBuffer - rw->DataOffset );
            rw->BulkBuffer = NULL;
        }

        if ( rw->CompressedRequest &&
             rw->CompressionTechnology ) {
            SourceMdl = (PMDL)(((ULONG)StufferState->BufferBase +
                       sizeof(SMB_HEADER) + 10 + headerLength) & ~7);

            MmPrepareMdlForReuse(SourceMdl);
        }

        if (!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
            KeInitializeEvent(
                &RxContext->SyncEvent,
                NotificationEvent,
                FALSE );
        }

        OrdinaryExchange->ContinuationRoutine = NULL;

        RxDbgTrace(
            0,
            Dbg,
            ("OE %lx TBC %lx RBC %lx BR %lx TBO %lx\n",
             OrdinaryExchange,rw->ThisByteCount,
             rw->RemainingByteCount,
             rw->BytesReturned,
             rw->ThisBufferOffset));


        SmbCeDecrementPendingLocalOperationsAndFinalize((PSMB_EXCHANGE)OrdinaryExchange);

        if (!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
            RxWaitSync( RxContext );
        } else {
            RxDbgTrace(
                0,
                Dbg,
                ("ABWC: OE: %lx Status %lx\n",
                 OrdinaryExchange,
                 Status));
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbWriteBulkContinuation returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbBuildWriteBulkData (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PLARGE_INTEGER ByteOffsetAsLI,
    IN     UCHAR Sequence,
    IN     ULONG ByteCount,
    IN     ULONG Remaining
    )

/*++

Routine Description:

   This builds a WriteBulk SMB. We don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? All we have
   to do is format up the bits.


Arguments:

    StufferState - the state of the smbbuffer from the stuffer's point of view
    ByteOffsetAsLI - the byte offset in the file where we want to read
    Sequence - this WriteBulkData exchange sequence
    ByteCount - the length of the data to be written


Return Value:

   NTSTATUS
      STATUS_SUCCESS
      STATUS_NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PNT_SMB_HEADER SmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    ULONG OffsetLow,OffsetHigh;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbBuildWriteBulk\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    OffsetLow = ByteOffsetAsLI->LowPart;
    OffsetHigh = ByteOffsetAsLI->HighPart;

    StufferState->CurrentPosition = (PCHAR)(SmbHeader + 1);
    SmbHeader->Command = SMB_COM_WRITE_BULK_DATA;

    COVERED_CALL(MRxSmbStartSMBCommand( StufferState, SetInitialSMB_Never,
                                          SMB_COM_WRITE_BULK_DATA,
                                          SMB_REQUEST_SIZE(WRITE_BULK),
                                          NO_EXTRA_DATA,
                                          NO_SPECIAL_ALIGNMENT,
                                          RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                          0,0,0,0 STUFFERTRACE(Dbg,'FC'));
                 );

    RxDbgTrace(0, Dbg,("First write bulk data status = %lu\n",Status));
    MRxSmbDumpStufferState (1000,"SMB w/WRITE BULK DATA before stuffing",StufferState);

    if ( FlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_PAGING_IO)) {
        SmbPutAlignedUshort(
            &SmbHeader->Flags2,
            SmbGetAlignedUshort(&SmbHeader->Flags2)|SMB_FLAGS2_PAGING_IO);
    }

    MRxSmbStuffSMB (StufferState,
         "0yywdDddB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 10
               Sequence,            //  y         UCHAR Sequence;                     // Exchange sequence handle
                      0,            //  y         UCHAR Reserved;
               smbSrvOpen->Fid,     //  w         _USHORT( Fid );                     // File handle
               ByteCount,           //  d         _ULONG( DataCount );                // Count of bytes, replaces ByteCount
               SMB_OFFSET_CHECK(WRITE_BULK_DATA, Offset)
               OffsetLow, OffsetHigh, //  Dd      LARGE_INTEGER Offset;               // Offset in file to begin write
               Remaining,           //  d         _ULONG( Remaining );                // Bytes remaining to be written
                                    //  B         _USHORT( ByteCount );               // Count of data bytes = 0, not used
              SMB_WCT_CHECK(10) 0
                                    //            UCHAR Buffer[1];
             );

    MRxSmbDumpStufferState (700,"SMB w/WRITE BULK DATA after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return(Status);

} // MRxSmbBuildWriteBulkData

extern SMB_EXCHANGE_DISPATCH_VECTOR WriteBulkDataExchangeDispatchVector;

NTSTATUS
MRxSmbInitializeWriteBulkDataExchange(
    PSMB_WRITE_BULK_DATA_EXCHANGE   *pWriteBulkDataExchangePointer,
    PSMB_PSE_ORDINARY_EXCHANGE      pWriteExchange,
    PSMB_HEADER                     pSmbHeader,
    PREQ_WRITE_BULK_DATA            pWriteBulkDataRequest,
    PMDL                            pDataMdl,
    ULONG                           DataSizeInBytes,
    ULONG                           DataOffsetInBytes,
    ULONG                           RemainingDataInBytes)
{
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG HeaderMdlSize;
    ULONG DataMdlSize;
    ULONG WriteBulkDataExchangeSize;

    PSMB_WRITE_BULK_DATA_EXCHANGE pWriteBulkDataExchange;

    PAGED_CODE();

    HeaderMdlSize = MmSizeOfMdl(
                        0,
      sizeof(SMB_HEADER) + TRANSPORT_HEADER_SIZE + FIELD_OFFSET(REQ_WRITE_BULK_DATA,Buffer));

    DataMdlSize = MmSizeOfMdl(
                      0,
                      DataSizeInBytes);


    WriteB