     to keep the same page.

********************************************************************/
BOOL CALLBACK HowToConnectOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
  ASSERT(puNextPage);

  // read radio button state
  if( IsDlgButtonChecked(hDlg, IDC_CONNECT_BY_LAN) )
  {
      gpUserInfo->uiConnectionType = CONNECT_LAN;
  }
  else if( IsDlgButtonChecked(hDlg, IDC_CONNECT_BY_PHONE) )
  {
      gpUserInfo->uiConnectionType = CONNECT_RAS;
  }
  else if( IsDlgButtonChecked(hDlg, IDC_CONNECT_MANUAL) )
  {
      ASSERT( gpWizardState->dwRunFlags & RSW_APPRENTICE );
      gpUserInfo->uiConnectionType = CONNECT_MANUAL;
  }

  if (!fForward)
  {
    if ( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
    {
      // Hack to make back work...
      gpWizardState->uPagesCompleted = 1;
      gfUserBackedOut = TRUE;
      gfQuitWizard = TRUE;
    }

  }
  else
  {
    if ( (gpWizardState->dwRunFlags & RSW_APPRENTICE) && !g_fIsICW)
    {
        if ( !(CONNECT_RAS == gpUserInfo->uiConnectionType) )
        {
            // 12/20/96 jmazner Normandy #12945
            // don't go through proxy options.

            // we're about to jump back to the external wizard, and we don't want
            // this page to show up in our history list
            *pfKeepHistory = FALSE;

            *puNextPage = g_uExternUINext;

            //Notify the main Wizard that this was the last page
            ASSERT( g_pExternalIICWExtension )
            if (g_fIsExternalWizard97)
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_HOWTOCONNECT97);
            else
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_HOWTOCONNECT);
            
            g_fConnectionInfoValid = TRUE;


        }
        else
        {
            //
            // 12/20/96 jmazner Normandy #12948
            // Install a modem if neccesary
            //
            // 5/15/97 jmazner Olympus
            //DWORD dwfInstallOptions = INETCFG_INSTALLMODEM;
            DWORD dwfInstallOptions = (INETCFG_INSTALLRNA | INETCFG_INSTALLMODEM | INETCFG_INSTALLTCP);
            EnableWindow(GetParent(hDlg), FALSE);

            //
            // save state of fNeedReboot, becasuse
            // we might be calling InetCofigureSystem() 
            // again, and the ReBoot flag might get reset
            //  MKarki - Fix for Bug #404
            //
            BOOL bSaveState = gpWizardState->fNeedReboot;
            
            HRESULT hr = InetConfigSystem(GetParent(hDlg),dwfInstallOptions,&gpWizardState->fNeedReboot);

            //
            // we should choose to reboot -MKarki Bug #404
            //
            gpWizardState->fNeedReboot = 
                    bSaveState || gpWizardState->fNeedReboot;

            EnableWindow(GetParent(hDlg), TRUE);
            SetForegroundWindow(GetParent(hDlg));

            if (hr == ERROR_CANCELLED) 
            {
                // Stay on this page if the user cancelled
                gpWizardState->fNeedReboot = FALSE;
                return FALSE;
            }
            else if (hr != ERROR_SUCCESS)
            {
                MsgBox(GetParent(hDlg),IDS_CONFIGAPIFAILED,MB_ICONEXCLAMATION,MB_OK);
                gpWizardState->fNeedReboot = FALSE;
                gfQuitWizard = TRUE;
                return FALSE;
            } 
            else if (gpWizardState->fNeedReboot)
            {
                //
                // 5/27/97 jmazner Olympus #1134 and IE #32717
                // As per email from GeorgeH and GeoffR, force user to either
                // cancel or quit at this point.
                //
                if (IDYES == MsgBox(GetParent(hDlg),IDS_WANTTOREBOOT,MB_ICONQUESTION, MB_YESNO | MB_DEFBUTTON2))
                {
                    gpWizardState->fNeedReboot = TRUE;
                }
                else
                {
                    gpWizardState->fNeedReboot = FALSE;
                }
                gfQuitWizard = TRUE;
                return TRUE;
            }

            //
            // 7/16/97 jmazner Olympus #9571
            // if the configSystem call installed a modem for the first time on
            // the user's machine, then the TAPI information we initially read
            // in was bogus because the user had never filled it in.
            // Therefore re initialize the fields to make sure we have accurate info
            //
            InitRasEntry( gpRasEntry );

            
            *puNextPage = GetModemPage(hDlg);
        }
    }
    else
    {
        //Normandy# 4575 install TCP/IP on LAN path
        //Normandy# 8620 Do not install TCP/IP on LAN path
        DWORD dwfInstallOptions = 0;

        if (CONNECT_RAS == gpUserInfo->uiConnectionType)
            dwfInstallOptions |= (INETCFG_INSTALLRNA | INETCFG_INSTALLMODEM | INETCFG_INSTALLTCP);
        else if (CONNECT_LAN == gpUserInfo->uiConnectionType)
            dwfInstallOptions |= INETCFG_INSTALLTCP;
        
        //
        // Install and configure TCP/IP and RNA
        //

        //
        // save state of fNeedReboot, becasuse
        // we might be calling InetCofigureSystem() 
        // again, and the ReBoot flag might get reset
        //  MKarki - Fix for Bug #404
        //
        BOOL bSaveState = gpWizardState->fNeedReboot;

        HRESULT hr = InetConfigSystem(GetParent(hDlg),dwfInstallOptions,&gpWizardState->fNeedReboot);

        //
        // we should choose to reboot -MKarki Bug #404
        //
        gpWizardState->fNeedReboot = 
                bSaveState || gpWizardState->fNeedReboot;

        SetForegroundWindow(GetParent(hDlg));

        if (hr == ERROR_CANCELLED) {
            // Stay on this page if the user cancelled
            gpWizardState->fNeedReboot = FALSE;
            if (g_fIsICW)
            {
                g_pExternalIICWExtension->ExternalCancel( CANCEL_PROMPT );
            }
            return FALSE;
        } else if (hr != ERROR_SUCCESS) {
            MsgBox(GetParent(hDlg),IDS_CONFIGAPIFAILED,MB_ICONEXCLAMATION,MB_OK);
            gpWizardState->fNeedReboot = FALSE;
            //gfQuitWizard = TRUE;
            // 2/27/97  jmazner Olympus #299
            // don't quit, give the user a chance to choose LAN
            gpUserInfo->uiConnectionType = CONNECT_LAN;
            CheckDlgButton(hDlg,IDC_CONNECT_BY_PHONE,FALSE);
            CheckDlgButton(hDlg,IDC_CONNECT_BY_LAN,TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_CONNECT_BY_PHONE),FALSE);


            return FALSE;
        } else if (ERROR_SUCCESS == hr && gpWizardState->fNeedReboot && IsNT()) {

            //
            // we will let the EXE that called us POP up the dialog
            // box, asking users to reboot or not
            // MKarki (2/5/97) - Fix for Bug #3111
            //
            g_bReboot = TRUE;
            gfQuitWizard = TRUE;
            if (!g_fIsICW)
            {
                PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                SetPropSheetResult(hDlg,-1);
            }
            return (FALSE);
        }

        g_bRebootAtExit = gpWizardState->fNeedReboot;

        //
        // 7/16/97 jmazner Olympus #9571
        // if the configSystem call installed a modem for the first time on
        // the user's machine, then the TAPI information we initially read
        // in was bogus because the user had never filled it in.
        // Therefore re initialize the fields to make sure we have accurate info
        //
        InitRasEntry( gpRasEntry );



        if (dwfInstallOptions & INETCFG_INSTALLRNA)
        {
            if (ERROR_SUCCESS != InetStartServices())
            {


                // 
                // condition when
                // 1) user deliberately removes some file
                // 2) Did not reboot after installing RAS
                // MKarki - (5/7/97) - Fix for Bug #4004 
                //
                MsgBox(
                    GetParent(hDlg),
                    IDS_SERVICEDISABLED,
                    MB_ICONEXCLAMATION,MB_OK
                    );
                
                /*********
                //
                // Bug #12544 - VetriV
                // Check if user wants to exit ICW
                //
                if( (MsgBox(GetParent(hDlg), IDS_QUERYCANCEL, 
                                MB_APPLMODAL | MB_ICONQUESTION 
                                | MB_SETFOREGROUND | MB_DEFBUTTON2, 
                                MB_YESNO) == IDNO))
                {
                    goto StartService;
                }
                else
                {
                    gpWizardState->fNeedReboot = FALSE;
                    gfQuitWizard = TRUE;
                ****/

                // 2/27/97  jmazner Olympus #299
                // don't quit, give the user a chance to choose LAN
                gpUserInfo->uiConnectionType = CONNECT_LAN;
                CheckDlgButton(hDlg,IDC_CONNECT_BY_PHONE,FALSE);
                CheckDlgButton(hDlg,IDC_CONNECT_BY_LAN,TRUE);
                EnableWindow(GetDlgItem(hDlg,IDC_CONNECT_BY_PHONE),FALSE);
                return FALSE;
            }
        }

        // jmazner 11/11/96 Normandy #11320
        // Note: we are explicitly deferring the reboot until after the wizard
        //       has completed.
        //if( gpWizardState->fNeedReboot )
        //{
        //  gfQuitWizard = TRUE;
        //  return TRUE;
        //}

        if (CONNECT_LAN == gpUserInfo->uiConnectionType)
        {
            // Skip the use proxy page
            *puNextPage = ORD_PAGE_SETUP_PROXY; 
        }
        else
        {
            // get the next page based on number of modems.
            *puNextPage = GetModemPage(hDlg);
        }
    }
  }

  return TRUE;
}


/*******************************************************************

  NAME:    ChooseModemInitProc

  SYNOPSIS:  Called when "Choose Modem" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ChooseModemInitProc(HWND hDlg,BOOL fFirstInit)
{
    ProcessDBCS(hDlg, IDC_MODEM);

    gpWizardState->uCurrentPage = ORD_PAGE_CHOOSEMODEM;

    // fill the combobox with available modems
    DWORD dwRet = InitModemList(GetDlgItem(hDlg,IDC_MODEM));
    if (ERROR_SUCCESS != dwRet)
    {
        DisplayErrorMessage(hDlg,IDS_ERREnumModem,dwRet,
          ERRCLS_STANDARD,MB_ICONEXCLAMATION);

        // set flag to indicate that wizard should exit now
        gfQuitWizard = TRUE;

        return FALSE;
    }
    if (-1 == ComboBox_SetCurSel(GetDlgItem(hDlg,IDC_MODEM), nCurrentModemSel))
        ComboBox_SetCurSel(GetDlgItem(hDlg,IDC_MODEM), 0);

    return TRUE;
}

/*******************************************************************

  NAME:    ChooseModemCmdProc

  SYNOPSIS:  Called when modem selected on page

  ENTRY:    hDlg - dialog window
        
********************************************************************/
BOOL CALLBACK ChooseModemCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{   
  return TRUE;
}

/*******************************************************************

  NAME:    ChooseModemOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from "Choose Modem"
        page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ChooseModemOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    if (fForward) 
    {
        // get modem name out of combo box
        ComboBox_GetText(GetDlgItem(hDlg,IDC_MODEM),
          gpRasEntry->szDeviceName,sizeof(gpRasEntry->szDeviceName));
        ASSERT(lstrlen(gpRasEntry->szDeviceName));

        // set next page to go to

        // jmazner 11/11/96 Normandy #8293
        //*puNextPage = ORD_PAGE_CONNECTION;


        // 10/05/98 Vincent Yung
        // Connectoid page is removed.
        /*
        ENUM_CONNECTOID EnumConnectoid;    // class object for enum
        // 3/21/97 jmazner Olympus #1948
        if( EnumConnectoid.NumEntries() )
        {
            *puNextPage = ORD_PAGE_CONNECTION;
        }
        else
        {
            // 5/8/97 jmazner Olympus #4108
            // move connectionName to the end
            //*puNextPage = ORD_PAGE_CONNECTIONNAME;
            *puNextPage = ORD_PAGE_PHONENUMBER;
        }*/


        *puNextPage = ORD_PAGE_PHONENUMBER;
    }

    // Store modem selection 
    nCurrentModemSel = ComboBox_GetCurSel(GetDlgItem(hDlg,IDC_MODEM));
    // clear the modem list
    ComboBox_ResetContent(GetDlgItem(hDlg,IDC_MODEM));

    return TRUE;
}


/*******************************************************************

  NAME:    EnableWizard

  SYNOPSIS:  Enables or disables the wizard buttons and the wizard
        page itself (so it can't receive focus)

********************************************************************/
VOID EnableWizard(HWND hDlg,BOOL fEnable)
{
  HWND hwndWiz = GetParent(hDlg);

  // disable/enable back, next, cancel and help buttons
  EnableWindow(GetDlgItem(hwndWiz,IDD_BACK),fEnable);
  EnableWindow(GetDlgItem(hwndWiz,IDD_NEXT),fEnable);
  EnableWindow(GetDlgItem(hwndWiz,IDCANCEL),fEnable);
  EnableWindow(GetDlgItem(hwndWiz,IDHELP),fEnable);

  // disable/enable wizard page
  EnableWindow(hwndWiz,fEnable);

  UpdateWindow(hwndWiz);
}



//*******************************************************************
//
//  FUNCTION:   GetModemPage
//
//  PURPOSE:    This is only called from a few places.  This same logic
//              would have otherwise had to be included several times, this
//              centralizes the logic.  The possible pages returned are the
//              "Need Modem" page, the "Choose Modem" page, and "Has ISP".
//
//  PARAMETERS: Parent window.
//
//  RETURNS:    returns the ordinal of the page to display next after
//              initial questions are asked.
//
//  HISTORY:
//  96/03/07  markdu  Created.
//  96/11/11  jmazner  updated to skip new/existing connectoid page
//                     if no connectoids exist.
//
//*******************************************************************

UINT GetModemPage(HWND hDlg)
{

/*** no reason to handle NT seperately -- jmazner
  if (TRUE == IsNT())
  {
      //TODO: Add call to NT enum modems
      return ORD_PAGE_CONNECTION;
  }
***/

  // Enumerate the modems
  DWORD dwRet = EnumerateModems(hDlg, &gpEnumModem);
  if (ERROR_SUCCESS != dwRet)
  {
    // set flag to indicate that wizard should exit now
    gfQuitWizard = TRUE;

    return FALSE;
  }

  if (IsMoreThanOneModemInstalled(gpEnumModem))
  {
    // Multiple modems installed.
    TCHAR szDeviceName[RAS_MaxDeviceName + 1] = TEXT("\0");
    TCHAR szDeviceType[RAS_MaxDeviceType + 1] = TEXT("\0"); // modems are installed

    // If we want to skip the choose modem dlg.
    // retrieve the device info from registry.
    if (g_bSkipMultiModem &&
        GetDeviceSelectedByUser(DEVICENAMEKEY, szDeviceName, sizeof(szDeviceName)) && 
        GetDeviceSelectedByUser(DEVICETYPEKEY, szDeviceType, sizeof(szDeviceType)) )
    {
        lstrcpy(gpRasEntry->szDeviceName, szDeviceName);
        lstrcpy(gpRasEntry->szDeviceType, szDeviceType);
        return ORD_PAGE_PHONENUMBER;
    }
    else
    {
        return ORD_PAGE_CHOOSEMODEM;
    }
  }
  else
  {
    // One modem installed.
    // Note:  this option will also be selected if modems could
    // not be enumerated due to an error.
    // connecting over modem and all drivers/files are in place, go
    // to "existing ISP" page
    // return ORD_PAGE_CONNECTION;

    ENUM_CONNECTOID EnumConnectoid;    // class object for enum

    if( EnumConnectoid.NumEntries() )
    {
        return ORD_PAGE_CONNECTION;
    }
    else
    {
        // 5/8/97 jmazner Olympus #4108
        // move connectionName to the end
        //return ORD_PAGE_CONNECTIONNAME;

        return ORD_PAGE_PHONENUMBER;
    }

  }

}


//*******************************************************************
//
//  FUNCTION:   EnumerateModems
//
//  PURPOSE:    This function assumes that RNA is installed,
//              then it uses RNA to enumerate the devices.
//              If an enum object exists, it is replaced.
//
//  PARAMETERS: Pointer to current enum object, if one exists.
//              In any case, must be a valid pointer.
//              Parent window handle for displaying error message.
//
//  RETURNS:    HRESULT code (ERROR_SUCCESS if no error occurred).
//
//  HISTORY:
//  96/03/07  markdu  Created.
//
//*******************************************************************

HRESULT EnumerateModems(HWND hwndParent, ENUM_MODEM** ppEnumModem)
{
  DWORD dwRet;

  // Should only get here if we want to connect by modem/ISDN
  ASSERT(CONNECT_RAS == gpUserInfo->uiConnectionType)

  // Load RNA if not already loaded
  dwRet = EnsureRNALoaded();
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  ENUM_MODEM* pEnumModem = *ppEnumModem;

  // Enumerate the modems.
  if (pEnumModem)
  {
    // Re-enumerate the modems to be sure we have the most recent changes  
    dwRet = pEnumModem->ReInit();
  }
  else
  {
    // The object does not exist, so create it.
    pEnumModem = new ENUM_MODEM;
    if (pEnumModem)
    {
      dwRet = pEnumModem->GetError();
    }
    else
    {
      dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
  }

  // Check for errors
  if (ERROR_SUCCESS != dwRet)
  {
    DisplayErrorMessage(hwndParent,IDS_ERREnumModem,dwRet,
      ERRCLS_STANDARD,MB_ICONEXCLAMATION);

    // Clean up
    if (pEnumModem)
    {
      delete pEnumModem;
    }
    pEnumModem = NULL;
  }

  *ppEnumModem = pEnumModem;
  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   IsModemInstalled
//
//  PURPOSE:    This function validates the ENUM_MODEM object, then
//              gets the modem count.
//
//  PARAMETERS: Modem enum object to use for check.
//
//  RETURNS:    This function returns TRUE if there is at least one
//              modem installed.
//
//  HISTORY:
//  96/03/07  markdu  Created.
//
//*******************************************************************

BOOL IsModemInstalled(ENUM_MODEM* pEnumModem)
{
  if (TRUE == IsNT())
  {
      BOOL bNeedModem = FALSE;
      DWORD dwRet;

        if (NULL == lpIcfgNeedModem)
            return FALSE;
        
        dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
        if (ERROR_SUCCESS == dwRet)
            return !bNeedModem;
        else
            return FALSE;
          
  }
  else
  {
    if (pEnumModem && pEnumModem->GetNumDevices() > 0)
    {
        return TRUE;
    }

    return FALSE;
  }
}
    

//*******************************************************************
//
//  FUNCTION:   IsMoreThanOneModemInstalled
//
//  PURPOSE:    This function validates the ENUM_MODEM object, then
//              gets the modem count.
//
//  PARAMETERS: Modem enum object to use for check.
//
//  RETURNS:    This function returns TRUE if there is more than one
//              modem installed.
//
//  HISTORY:
//  96/03/07  markdu  Created.
//
//*******************************************************************

BOOL IsMoreThanOneModemInstalled(ENUM_MODEM* pEnumModem)
{
  if (IsNT4SP3Lower())
  {
      // TODO: DO NT thing here
      return FALSE;
  }

  if (pEnumModem && pEnumModem->GetNumDevices() > 1)
  {
    return TRUE;
  }

  return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Function:   FGetSystemShutdownPrivledge
//
//  Synopsis:   For windows NT the process must explicitly ask for permission
//              to reboot the system.
//
//  Arguements: none
//
//  Return:     TRUE - privledges granted
//              FALSE - DENIED
//
//  History:    8/14/96 ChrisK  Created
//
//  Note:       BUGBUG for Win95 we are going to have to softlink to these
//              entry points.  Otherwise the app won't even load.
//              Also, this code was originally lifted out of MSDN July96
//              "Shutting down the system"
//-----------------------------------------------------------------------------
BOOL FGetSystemShutdownPrivledge()
{
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;
 
    BOOL bRC = FALSE;

    if (IsNT())
    {
        // 
        // Get the current process token handle 
        // so we can get shutdown privilege. 
        //

        if (!OpenProcessToken(GetCurrentProcess(), 
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
                goto FGetSystemShutdownPrivledgeExit;

        //
        // Get the LUID for shutdown privilege.
        //

        ZeroMemory(&tkp,sizeof(tkp));
        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
                &tkp.Privileges[0].Luid); 

        tkp.PrivilegeCount = 1;  /* one privilege to set    */ 
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

        //
        // Get shutdown privilege for this process.
        //

        AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
            (PTOKEN_PRIVILEGES) NULL, 0); 

        if (ERROR_SUCCESS == GetLastError())
            bRC = TRUE;
    }
    else
    {
        bRC = TRUE;
    }

FGetSystemShutdownPrivledgeExit:
    if (hToken) CloseHandle(hToken);
    return bRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\pagefcns.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  PAGEFCNS.H - Prototypes for wizard page handler functions
//

//  HISTORY:
//  
//  12/22/94  jeremys  Created.
//  96/03/23  markdu  Removed GatewayAddr__Proc functions
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#ifndef _PAGEFCNS_H_
#define _PAGEFCNS_H_

// Functions in INTROUI.C

BOOL CALLBACK HowToConnectInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK HowToConnectOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

BOOL CALLBACK ChooseModemInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ChooseModemCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);
BOOL CALLBACK ChooseModemOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

// functions in ISPUPGUI.C
BOOL CALLBACK ConnectionInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ConnectionOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);
BOOL CALLBACK ConnectionCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);
BOOL CALLBACK ModifyConnectionInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ModifyConnectionOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);
BOOL CALLBACK ConnectionNameInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ConnectionNameOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

BOOL CALLBACK PhoneNumberInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK PhoneNumberOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);
BOOL CALLBACK PhoneNumberCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK NameAndPasswordInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK NameAndPasswordOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

BOOL CALLBACK AdvancedInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK AdvancedOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

BOOL CALLBACK ConnectionProtocolInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ConnectionProtocolOKProc(HWND hDlg);

BOOL CALLBACK LoginScriptInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK LoginScriptOKProc(HWND hDlg);
BOOL CALLBACK LoginScriptCmdProc(HWND hDlg,UINT uCtrlID);

// functions in TCPUI.C
BOOL CALLBACK IPAddressInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK IPAddressOKProc(HWND hDlg);
BOOL CALLBACK IPAddressCmdProc(HWND hDlg,UINT uCtrlID);

BOOL CALLBACK DNSAddressInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK DNSAddressOKProc(HWND hDlg);
BOOL CALLBACK DNSAddressCmdProc(HWND hDlg,UINT uCtrlID);

// functions in MAILUI.C
BOOL CALLBACK UseProxyInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK UseProxyOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);
BOOL CALLBACK UseProxyCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK ProxyServersInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ProxyServersOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);
BOOL CALLBACK ProxyServersCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK SetupProxyInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK SetupProxyOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK SetupProxyCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK ProxyExceptionsInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ProxyExceptionsOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

// functions in ENDUI.C
BOOL CALLBACK ConnectedOKInitProc(HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ConnectedOKOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory);

#endif // _PAGEFCNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\mailui.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  MAILUI.C - Functions for mail/newsgroup configuration UI
//      
//

//  HISTORY:
//  
//  1/9/95    jeremys  Created.
//  96/03/25  markdu  If a fatal error occurs, set gfQuitWizard.
//  96/03/26  markdu  Store values from UI even when back is pressed.
//  96/04/06  markdu  Moved CommitConfigurationChanges call to last page.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"

// Local types for parsing proxy settings
typedef enum {
    INTERNET_SCHEME_DEFAULT,
    INTERNET_SCHEME_FTP,
    INTERNET_SCHEME_GOPHER,
    INTERNET_SCHEME_HTTP,
    INTERNET_SCHEME_HTTPS,
    INTERNET_SCHEME_SOCKS,
    INTERNET_SCHEME_UNKNOWN
} INTERNET_SCHEME;

typedef enum {
    STATE_START,
    STATE_PROTOCOL,
    STATE_SCHEME,
    STATE_SERVER,
    STATE_PORT,
    STATE_END,
    STATE_ERROR
} PARSER_STATE;

typedef struct {
    LPTSTR SchemeName;
    DWORD SchemeLength;
    INTERNET_SCHEME SchemeType;
    DWORD dwControlId;
    DWORD dwPortControlId;
} URL_SCHEME;

const URL_SCHEME UrlSchemeList[] = {
    TEXT("http"),   4,  INTERNET_SCHEME_HTTP,   IDC_PROXYHTTP,  IDC_PORTHTTP,
    TEXT("https"),  5,  INTERNET_SCHEME_HTTPS,  IDC_PROXYSECURE,IDC_PORTSECURE,
    TEXT("ftp"),    3,  INTERNET_SCHEME_FTP,    IDC_PROXYFTP,   IDC_PORTFTP,
    TEXT("gopher"), 6,  INTERNET_SCHEME_GOPHER, IDC_PROXYGOPHER,IDC_PORTGOPHER,
    TEXT("socks"),  5,  INTERNET_SCHEME_SOCKS,  IDC_PROXYSOCKS, IDC_PORTSOCKS,
    NULL,           0,  INTERNET_SCHEME_DEFAULT,0,0
};

typedef struct tagNEWPROFILEDLGINFO
{
  HWND hwndCombo;    // hwnd of combo box on parent dialog
  TCHAR szNewProfileName[cchProfileNameMax+1];  // return buffer for chosen name
} NEWPROFILEDLGINFO;

const TCHAR cszLocalString[] = TEXT("<local>");

#define GET_TERMINATOR(string) \
    while(*string != '\0') string++

#define ERROR_SERVER_NAME 4440
#define ERROR_PORT_NUM    4441
#define INTERNET_MAX_PORT_LENGTH    sizeof(TEXT("123456789"))

VOID EnableProxyControls(HWND hDlg);
VOID ReplicatePROXYHTTP(HWND hDlg, BOOL bSaveOrig);
VOID ReplicatePORTHTTP(HWND hDlg, BOOL bSaveOrig);
BOOL ParseProxyInfo(HWND hDlg, LPTSTR lpszProxy);
BOOL ParseEditCtlForPort(
    IN OUT LPTSTR   lpszProxyName,
    IN HWND    hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId
    );
DWORD FormatOutProxyEditCtl(
    IN HWND    hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId,
    OUT LPTSTR      lpszOutputStr,
    IN OUT LPDWORD lpdwOutputStrSize,
    IN DWORD       dwOutputStrLength,
    IN BOOL    fDefaultProxy
    );
BOOL RemoveLocalFromExceptionList(LPTSTR lpszExceptionList);
INT_PTR CALLBACK NewProfileDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL NewProfileDlgInit(HWND hDlg,NEWPROFILEDLGINFO * pNewProfileDlgInfo);
BOOL NewProfileDlgOK(HWND hDlg,NEWPROFILEDLGINFO * pNewProfileDlgInfo);
BOOL DoNewProfileDlg(HWND hDlg);

TCHAR gszHttpProxy   [MAX_URL_STRING+1]               = TEXT("\0");
TCHAR gszHttpPort    [INTERNET_MAX_PORT_LENGTH+1]     = TEXT("\0");
TCHAR gszSecureProxy [MAX_URL_STRING+1]               = TEXT("\0");
TCHAR gszSecurePort  [INTERNET_MAX_PORT_LENGTH+1]     = TEXT("\0");
TCHAR gszFtpProxy    [MAX_URL_STRING+1]               = TEXT("\0");
TCHAR gszFtpPort     [INTERNET_MAX_PORT_LENGTH+1]     = TEXT("\0");
TCHAR gszGopherProxy [MAX_URL_STRING+1]               = TEXT("\0");
TCHAR gszGopherPort  [INTERNET_MAX_PORT_LENGTH+1]     = TEXT("\0");

/*******************************************************************

  NAME:    UseProxyInitProc

  SYNOPSIS:  Called when Use Proxy page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK UseProxyInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (fFirstInit)
    {
        //
        // 6/6/97 jmazner Olympus #5413
        // tweak positioning to hack around win95 J display bug
        //
        Win95JMoveDlgItem( hDlg, GetDlgItem(hDlg,IDC_NOTE), 15 );

        CheckDlgButton(hDlg,IDC_USEPROXY,gpUserInfo->fProxyEnable);
        CheckDlgButton(hDlg,IDC_NOUSEPROXY,!gpUserInfo->fProxyEnable);
    }

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_USEPROXY;

    return TRUE;
}
        
/*******************************************************************

  NAME:    UseProxyOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from Use Proxy page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK UseProxyOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    ASSERT(puNextPage);

    gpUserInfo->fProxyEnable = IsDlgButtonChecked(hDlg,IDC_USEPROXY);

    if (fForward)
    {
        if (gpUserInfo->fProxyEnable)
            *puNextPage = ORD_PAGE_SETUP_PROXY;//ORD_PAGE_PROXYSERVERS;
        else
        {
              if( LoadAcctMgrUI(GetParent(hDlg), 
                                g_fIsWizard97 ? IDD_PAGE_USEPROXY97 : IDD_PAGE_USEPROXY, 
                                g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK,
                                g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
              {
                  if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
                  {
                      // we're about to jump into the external apprentice, and we don't want
                      // this page to show up in our history list
                      *pfKeepHistory = FALSE;

                      *puNextPage = g_uAcctMgrUIFirst;
                  }
                  else
                  {
                      DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                                g_uAcctMgrUIFirst);
                      *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
                  }
              }
              else
              {
                  DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
                  *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

              }
        }

    }

    return TRUE;
}

/*******************************************************************

  NAME:    UseProxyCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK UseProxyCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{
     switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
    {
        case BN_DBLCLK:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_USEPROXY: 
                case IDC_NOUSEPROXY:
                {
		            // somebody double-clicked a radio button
		            // auto-advance to the next page
		            PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                    break;
                }
            }
		    break;
        }
    }
    return TRUE;
}

/*******************************************************************

  NAME:    ProxyServersInitProc

  SYNOPSIS:  Called when proxy servers page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ProxyServersInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (fFirstInit)
    {
        //
        // 6/6/97 jmazner Olympus #5413
        // tweak positioning to hack around win95 J display bug
        //

        // 15/09/98 vyung
        // Test team find that this introduces a tab order bug
        // The Win95 J bug is not repro, so this is removed
        // Win95JMoveDlgItem( hDlg, GetDlgItem(hDlg,IDC_NOTE), 15 );
        // Win95JMoveDlgItem( hDlg, GetDlgItem(hDlg,IDC_PROXYSAME), 160 );

        // limit text fields appropriately
        // 31/10/98 vyung 
        // IE CPL removes the text limit on the edit boxes, do so here.
        //
        /*
        SendDlgItemMessage(hDlg,IDC_PROXYHTTP,EM_LIMITTEXT,MAX_URL_STRING,0L);
        SendDlgItemMessage(hDlg,IDC_PROXYSECURE,EM_LIMITTEXT,MAX_URL_STRING,0L);
        SendDlgItemMessage(hDlg,IDC_PROXYFTP,EM_LIMITTEXT,MAX_URL_STRING,0L);
        SendDlgItemMessage(hDlg,IDC_PROXYGOPHER,EM_LIMITTEXT,MAX_URL_STRING,0L);
        SendDlgItemMessage(hDlg,IDC_PROXYSOCKS,EM_LIMITTEXT,MAX_URL_STRING,0L);

        SendDlgItemMessage(hDlg,IDC_PORTHTTP,EM_LIMITTEXT,INTERNET_MAX_PORT_LENGTH,0L);
        SendDlgItemMessage(hDlg,IDC_PORTSECURE,EM_LIMITTEXT,INTERNET_MAX_PORT_LENGTH,0L);
        SendDlgItemMessage(hDlg,IDC_PORTFTP,EM_LIMITTEXT,INTERNET_MAX_PORT_LENGTH,0L);
        SendDlgItemMessage(hDlg,IDC_PORTGOPHER,EM_LIMITTEXT,INTERNET_MAX_PORT_LENGTH,0L);
        SendDlgItemMessage(hDlg,IDC_PORTSOCKS,EM_LIMITTEXT,INTERNET_MAX_PORT_LENGTH,0L);
        */
        ParseProxyInfo(hDlg,gpUserInfo->szProxyServer);
    }

    EnableProxyControls(hDlg);

    return TRUE;
}

/*******************************************************************

  NAME:    ProxyServersOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from proxy server page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ProxyServersOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    ASSERT(puNextPage);

    DWORD dwProxyServerLen;
    DWORD dwErr;

    TCHAR  szNewProxyString[MAX_REG_LEN+1];

    if (fForward)
    {
        // jmazner 11/9/96 Normandy #6937
        // clear out previous contents of gpUserInfo->szProxyServer
        // before we start filling in the new contents
        //
        // 7/10/97 jmazner Olympus #9365
        // we want to preserve the orginial proxy string, so use a copy for
        // the call to FormatOytProxyEditCtl
        //

        ZeroMemory(szNewProxyString,sizeof(szNewProxyString));

        if (IsDlgButtonChecked(hDlg, IDC_PROXYSAME))
        {
            dwProxyServerLen = 0;
            dwErr = FormatOutProxyEditCtl(hDlg,IDC_PROXYHTTP,IDC_PORTHTTP,
                szNewProxyString,
                &dwProxyServerLen,
                sizeof(szNewProxyString),
                TRUE);
            if (ERROR_SUCCESS != dwErr)
            {
                if (ERROR_PORT_NUM == dwErr)
                    DisplayFieldErrorMsg(hDlg,IDC_PORTHTTP,IDS_INVALID_PORTNUM);
                else 
                    DisplayFieldErrorMsg(hDlg,IDC_PROXYHTTP,IDS_ERRProxyRequired);
                return FALSE;
            }
        }
        else
        {
            dwProxyServerLen = 0;
            int i = 0;
            while (UrlSchemeList[i].SchemeLength)
            {
                dwErr = FormatOutProxyEditCtl(hDlg,
                    UrlSchemeList[i].dwControlId,
                    UrlSchemeList[i].dwPortControlId,
                    szNewProxyString,
                    &dwProxyServerLen,
                    sizeof(szNewProxyString),
                    FALSE);

                switch( dwErr )
                {
                    case ERROR_SUCCESS:
                    case ERROR_SERVER_NAME:
                        break;
                    case ERROR_PORT_NUM:
                        DisplayFieldErrorMsg(hDlg,UrlSchemeList[i].dwPortControlId,IDS_INVALID_PORTNUM);
                        return FALSE;
                    case ERROR_NOT_ENOUGH_MEMORY:
                        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
                        return FALSE;
                }
                i++;
            }

            //
            // 6/2/97   jmazner Olympus #4411
            // Allow some proxy servers to be null.  Only warn if no server
            // names were entered.
            //
            if( 0 == lstrlen(szNewProxyString) )
            {
                DisplayFieldErrorMsg(hDlg,IDC_PROXYHTTP,IDS_ERRProxyRequired);
                return FALSE;
            }
        }

        //
        // if we made it this far, then the new proxy settings are valid, so
        // now copy them back into the main data structure.
        //
        lstrcpyn(gpUserInfo->szProxyServer, szNewProxyString, sizeof(gpUserInfo->szProxyServer));

        *puNextPage = ORD_PAGE_PROXYEXCEPTIONS;
    }

    return TRUE;
}

/*******************************************************************

  NAME:    ProxyServersCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK ProxyServersCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{   
  switch (GET_WM_COMMAND_ID(wParam, lParam))
  {
    case IDC_PROXYSAME:
      // checkbox state changed, enable controls appropriately
      EnableProxyControls(hDlg);
      break;
    case IDC_PROXYHTTP:
    case IDC_PORTHTTP:

      if ( GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS )
      {
          // if heckbox state enabled, populate info but don't save it
          if (IsDlgButtonChecked(hDlg,IDC_PROXYSAME))
          {
              ReplicatePROXYHTTP(hDlg, FALSE);
              ReplicatePORTHTTP(hDlg, FALSE);
          }
      }

      break;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    SetupProxyInitProc

  SYNOPSIS:  Called when proxy servers page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK SetupProxyInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (fFirstInit)
    {
        TCHAR szTemp[MAX_RES_LEN*2];
        LoadString(ghInstance, IDS_SETUP_PROXY_INTRO, szTemp, MAX_RES_LEN*2);
        SetWindowText(GetDlgItem(hDlg, IDC_AUTODISCOVERY_TEXT), szTemp);
        // Set the auto discovery check box
        if (gpUserInfo->bAutoDiscovery)
            CheckDlgButton(hDlg,IDC_AUTODISCOVER, BST_CHECKED);

        // Set the autoconfig URL text box
        SetWindowText(GetDlgItem(hDlg, IDC_CONFIG_ADDR),
                      gpUserInfo->szAutoConfigURL);

        // Set the Auto config URL checkbox
        CheckDlgButton(hDlg,IDC_CONFIGSCRIPT, gpUserInfo->bAutoConfigScript ? BST_CHECKED : BST_UNCHECKED);
        EnableWindow(GetDlgItem(hDlg, IDC_CONFIGADDR_TX), gpUserInfo->bAutoConfigScript);
        EnableWindow(GetDlgItem(hDlg, IDC_CONFIG_ADDR), gpUserInfo->bAutoConfigScript);
        
        // Set the manual checkbox
        CheckDlgButton(hDlg,IDC_MANUAL_PROXY,gpUserInfo->fProxyEnable);
    }
    gpWizardState->uCurrentPage = ORD_PAGE_SETUP_PROXY;
    return TRUE;
}


/*******************************************************************

  NAME:     SetupProxyOKProc

  SYNOPSIS: Called when Next or Back btns pressed from proxy server page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK SetupProxyOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    ASSERT(puNextPage);
    if (fForward && gpUserInfo)
    {
        // modify setting, later write to registry
        gpUserInfo->bAutoDiscovery = IsDlgButtonChecked(hDlg, IDC_AUTODISCOVER);

        gpUserInfo->bAutoConfigScript = IsDlgButtonChecked(hDlg, IDC_CONFIGSCRIPT);
        if (gpUserInfo->bAutoConfigScript)
        {
            GetWindowText(GetDlgItem(hDlg, IDC_CONFIG_ADDR),
                          gpUserInfo->szAutoConfigURL,
                          MAX_REG_LEN+1);
        }

        gpUserInfo->fProxyEnable = IsDlgButtonChecked(hDlg, IDC_MANUAL_PROXY);
        if (gpUserInfo->fProxyEnable)
        {
            *puNextPage = ORD_PAGE_PROXYSERVERS;
        }
        else 
        {

            if( LoadAcctMgrUI(GetParent(hDlg), 
                                 g_fIsWizard97 ? IDD_PAGE_SETUP_PROXY97 : IDD_PAGE_SETUP_PROXY, 
                                 g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK, 
                                 g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
            {
              if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
              {
                  // we're about to jump into the external apprentice, and we don't want
                  // this page to show up in our history list
                  *pfKeepHistory = FALSE;

                  *puNextPage = g_uAcctMgrUIFirst;
              }
              else
              {
                  DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                            g_uAcctMgrUIFirst);
                  *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
              }
            }
            else
            {
              DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
              *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

            }

        }
    }
    return TRUE;
}

/*******************************************************************

  NAME:    SetupProxyCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK SetupProxyCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{   
  switch (GET_WM_COMMAND_ID(wParam, lParam))
  {
    case IDC_CONFIGSCRIPT:
        {
            BOOL bChecked = IsDlgButtonChecked(hDlg, IDC_CONFIGSCRIPT);
            EnableWindow(GetDlgItem(hDlg, IDC_CONFIGADDR_TX), bChecked);
            EnableWindow(GetDlgItem(hDlg, IDC_CONFIG_ADDR), bChecked);
        }
        break;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    EnableProxyControls

  SYNOPSIS:  Enables edit controls on Proxy Server page depending on
        whether or not 'use proxy...' checkbox is checked.

********************************************************************/
VOID EnableProxyControls(HWND hDlg)
{
  static BOOL fDifferentProxies = TRUE;
  BOOL fChanged = TRUE;

  fChanged = ( fDifferentProxies != !IsDlgButtonChecked(hDlg,IDC_PROXYSAME) );
  fDifferentProxies = !IsDlgButtonChecked(hDlg,IDC_PROXYSAME);

  EnableDlgItem(hDlg,IDC_TX_PROXYSECURE,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PROXYSECURE,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PORTSECURE,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_TX_PROXYFTP,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PROXYFTP,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PORTFTP,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_TX_PROXYGOPHER,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PROXYGOPHER,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PORTGOPHER,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_TX_PROXYSOCKS,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PROXYSOCKS,fDifferentProxies);
  EnableDlgItem(hDlg,IDC_PORTSOCKS,fDifferentProxies);

  if( fChanged )
  {
      if( !fDifferentProxies )
      {
          //
          // 7/10/97 jmazner Olympus #9365
          // behave more like IE's proxy property sheet, copy the http
          // settings to all other fields except SOCKS, which should be empty.
          //
          ReplicatePROXYHTTP(hDlg, TRUE);
          ReplicatePORTHTTP(hDlg, TRUE);
      }
      else
      {
          //
          // reload the current settings for all protocols.  First, however,
          // make a copy of any changes the user has made to http, then write
          // that back in after reloading the defaults.
          //
          TCHAR szHttpProxy[MAX_URL_STRING+1];
          TCHAR szHttpPort[INTERNET_MAX_PORT_LENGTH+1];
          GetDlgItemText(hDlg, IDC_PROXYHTTP, szHttpProxy, MAX_URL_STRING);
          GetDlgItemText(hDlg, IDC_PORTHTTP, szHttpPort, INTERNET_MAX_PORT_LENGTH);

          //
          // ParseProxyInfo will only update the PORT field if port info is
          // currently stored in the string.  So clear out the PORT fields
          // ahead of time and let ParseProxyInfo fill them in as needed.
          //
          SetDlgItemText( hDlg, IDC_PORTSECURE, gszSecurePort );
          SetDlgItemText( hDlg, IDC_PORTFTP, gszFtpPort );
          SetDlgItemText( hDlg, IDC_PORTGOPHER, gszGopherPort );

          // 09/10/98 The behaviour of IE has changed.  IE's proxy property
          // sheet will blank all fields.
          SetDlgItemText( hDlg, IDC_PROXYSECURE, gszSecureProxy );
          SetDlgItemText( hDlg, IDC_PROXYFTP, gszFtpProxy );
          SetDlgItemText( hDlg, IDC_PROXYGOPHER, gszGopherProxy );

          ParseProxyInfo(hDlg,gpUserInfo->szProxyServer);

          SetDlgItemText( hDlg, IDC_PROXYHTTP, szHttpProxy );
          SetDlgItemText( hDlg, IDC_PORTHTTP, szHttpPort );

          //
          // ParseProxyInfo may also check the PROXYSAME, so disable it here
          // for good measure.
          //
          CheckDlgButton( hDlg, IDC_PROXYSAME, FALSE );
      }
  }

}

//+----------------------------------------------------------------------------
//
//  Function:   ReplicatePROXYHTTP
//
//  Synopsis:   copies the value in the IDC_PROXYHTTP edit box to the all other
//              proxy name fields except for IDC_SOCKS
//
//  Arguments:  hDlg -- handle to dialog window which owns the controls
//              bSaveOrig -- save original info 
//
//  Returns:    none
//
//  History:    7/10/97 jmazner created for Olympus #9365
//
//-----------------------------------------------------------------------------
void ReplicatePROXYHTTP( HWND hDlg, BOOL bSaveOrig)
{
    TCHAR szHttpProxy[MAX_URL_STRING];

    GetDlgItemText(hDlg, IDC_PROXYHTTP, szHttpProxy, MAX_URL_STRING);

    if (bSaveOrig)
    {
        GetDlgItemText(hDlg, IDC_PROXYSECURE, gszSecureProxy, MAX_URL_STRING);
        GetDlgItemText(hDlg, IDC_PROXYFTP, gszFtpProxy, MAX_URL_STRING);
        GetDlgItemText(hDlg, IDC_PROXYGOPHER, gszGopherProxy, MAX_URL_STRING);
    }

    SetDlgItemText( hDlg, IDC_PROXYSECURE, szHttpProxy );
    SetDlgItemText( hDlg, IDC_PROXYFTP, szHttpProxy );
    SetDlgItemText( hDlg, IDC_PROXYGOPHER, szHttpProxy );
    SetDlgItemText( hDlg, IDC_PROXYSOCKS, TEXT("\0") );
}

//+----------------------------------------------------------------------------
//
//  Function:   ReplicatePORTHTTP
//
//  Synopsis:   copies the value in the IDC_PORTHTTP edit box to the all other
//              proxy port fields except for IDC_SOCKS
//
//  Arguments:  hDlg -- handle to dialog window which owns the controls
//              bSaveOrig -- save original info 
//
//  Returns:    none
//
//  History:    7/10/97 jmazner created for Olympus #9365
//
//-----------------------------------------------------------------------------
void ReplicatePORTHTTP( HWND hDlg, BOOL bSaveOrig)
{
    TCHAR szHttpPort[INTERNET_MAX_PORT_LENGTH+1];

    GetDlgItemText(hDlg, IDC_PORTHTTP, szHttpPort, INTERNET_MAX_PORT_LENGTH);

    if (bSaveOrig)
    {
        GetDlgItemText(hDlg, IDC_PORTSECURE, gszSecurePort, MAX_URL_STRING);
        GetDlgItemText(hDlg, IDC_PORTFTP, gszFtpPort, MAX_URL_STRING);
        GetDlgItemText(hDlg, IDC_PORTGOPHER, gszGopherPort, MAX_URL_STRING);
    }

    SetDlgItemText( hDlg, IDC_PORTSECURE, szHttpPort );
    SetDlgItemText( hDlg, IDC_PORTFTP, szHttpPort );
    SetDlgItemText( hDlg, IDC_PORTGOPHER, szHttpPort );
    SetDlgItemText( hDlg, IDC_PORTSOCKS, TEXT("\0") );
}



/*******************************************************************

  NAME:    ProxyExceptionsInitProc

  SYNOPSIS:  Called when Proxy Exceptions page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ProxyExceptionsInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (fFirstInit)
    {
        SendDlgItemMessage(hDlg,IDC_BYPASSPROXY,EM_LIMITTEXT,
          sizeof(gpUserInfo->szProxyOverride) - sizeof(cszLocalString),0L);

        BOOL fBypassLocal = RemoveLocalFromExceptionList(gpUserInfo->szProxyOverride);

        SetDlgItemText(hDlg,IDC_BYPASSPROXY,gpUserInfo->szProxyOverride);

        CheckDlgButton(hDlg,IDC_BYPASSLOCAL,fBypassLocal);
    }

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_PROXYEXCEPTIONS;

    return TRUE;
}
        
/*******************************************************************

  NAME:    ProxyExceptionsOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from Proxy
                Exceptions page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ProxyExceptionsOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    ASSERT(puNextPage);

    // get proxy server override from UI
    GetDlgItemText(hDlg,IDC_BYPASSPROXY,gpUserInfo->szProxyOverride,
                    sizeof(gpUserInfo->szProxyOverride));

    if (IsDlgButtonChecked(hDlg, IDC_BYPASSLOCAL))
    {
        //
        // Add ; on the end if its NOT the first entry.
        //

        if ( gpUserInfo->szProxyOverride[0] != '\0' )
        {
            lstrcat(gpUserInfo->szProxyOverride, TEXT(";"));
        }


        //
        // Now Add <local> to end of string.
        //

        lstrcat(gpUserInfo->szProxyOverride,  cszLocalString);
    }

    if (fForward)
    {
      if(( gpWizardState->dwRunFlags & RSW_APPRENTICE ) && !g_fIsICW)
      {
          // we're about to jump back to the external wizard, and we don't want
          // this page to show up in our history list
          *pfKeepHistory = FALSE;

          *puNextPage = g_uExternUINext;

        //Notify the main Wizard that this was the last page
        ASSERT( g_pExternalIICWExtension )
        if (g_fIsExternalWizard97)
            g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_PROXYEXCEPTIONS97);
        else
            g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_PROXYEXCEPTIONS);

        g_fConnectionInfoValid = TRUE;

      }
      else if( LoadAcctMgrUI(GetParent(hDlg), 
                             g_fIsWizard97 ? IDD_PAGE_PROXYEXCEPTIONS97 : IDD_PAGE_PROXYEXCEPTIONS, 
                             g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK, 
                             g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
      {
          if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
          {
              // we're about to jump into the external apprentice, and we don't want
              // this page to show up in our history list
              *pfKeepHistory = FALSE;

              *puNextPage = g_uAcctMgrUIFirst;
          }
          else
          {
              DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                        g_uAcctMgrUIFirst);
              *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
          }
      }
      else
      {
          DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
          *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

      }
    }

    return TRUE;
}


BOOL DoNewProfileDlg(HWND hDlg)
{
  // fill out structure to pass to dialog
  NEWPROFILEDLGINFO NewProfileDlgInfo;

  NewProfileDlgInfo.hwndCombo = GetDlgItem(hDlg,IDC_PROFILE_LIST);

  // create dialog to prompt for profile name
  BOOL fRet=(BOOL)DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_NEWPROFILENAME),hDlg,
    NewProfileDlgProc,(LPARAM) &NewProfileDlgInfo);

  // if profile name chosen, add it to combo box
  if (fRet) {
    int iSel=ComboBox_AddString(NewProfileDlgInfo.hwndCombo,
      NewProfileDlgInfo.szNewProfileName);
    ASSERT(iSel >= 0);
    ComboBox_SetCurSel(NewProfileDlgInfo.hwndCombo,iSel);
  }

  return fRet;
}


/*******************************************************************
  NAME:    NewProfileDlgProc
  SYNOPSIS:  Dialog proc for choosing name for new profile
********************************************************************/
INT_PTR CALLBACK NewProfileDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  switch (uMsg) {

    case WM_INITDIALOG:
      // lParam contains pointer to NEWPROFILEDLGINFO struct, set it
      // in window data
      ASSERT(lParam);
      SetWindowLongPtr(hDlg,DWLP_USER,lParam);
      return NewProfileDlgInit(hDlg,(NEWPROFILEDLGINFO *) lParam);
            break;

    case WM_COMMAND:
      switch (LOWORD(wParam)) {
              case IDOK:
                  {
            NEWPROFILEDLGINFO * pNewProfileDlgInfo =
              (NEWPROFILEDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
            ASSERT(pNewProfileDlgInfo);
            BOOL fRet=NewProfileDlgOK(hDlg,pNewProfileDlgInfo);
            if (fRet) {
              EndDialog(hDlg,TRUE);
            }
                    }
                    break;

        case IDCANCEL:
                    EndDialog(hDlg,FALSE);
          break;                  

            }
          break;
    }

    return FALSE;
}

#define MAX_DEFAULT_PROFILE_INDEX  50
BOOL NewProfileDlgInit(HWND hDlg,NEWPROFILEDLGINFO * pNewProfileDlgInfo)
{
  BOOL fHaveDefaultName = TRUE;
  ASSERT(pNewProfileDlgInfo);

  // limit edit field
  Edit_LimitText(GetDlgItem(hDlg,IDC_PROFILENAME),cchProfileNameMax);

  TCHAR szDefaultName[SMALL_BUF_LEN+1];
  LoadSz(IDS_PROFILENAME,szDefaultName,sizeof(szDefaultName));

  // see if the default name already exists in the combo box of profiles
  if (ComboBox_FindStringExact(pNewProfileDlgInfo->hwndCombo,0,szDefaultName)
    >= 0) {
    fHaveDefaultName = FALSE;
    // yep, it exists, try making a default name that doesn't exist
    int iIndex = 2;  // start with "<default name> #2"
    TCHAR szBuf[SMALL_BUF_LEN+1];
    LoadSz(IDS_PROFILENAME1,szBuf,sizeof(szBuf));

    while (iIndex <  MAX_DEFAULT_PROFILE_INDEX) {
      // build a name a la "<default name> #<#>"
      wsprintf(szDefaultName,szBuf,iIndex);
      // is it in combo box already?
      if (ComboBox_FindStringExact(pNewProfileDlgInfo->hwndCombo,0,szDefaultName)
        < 0) {
        fHaveDefaultName = TRUE;
        break;
      }

      iIndex ++;
    }
  }

  if (fHaveDefaultName) {
    SetDlgItemText(hDlg,IDC_PROFILENAME,szDefaultName);
    Edit_SetSel(GetDlgItem(hDlg,IDC_PROFILENAME),0,-1);
  }

  SetFocus(GetDlgItem(hDlg,IDC_PROFILENAME));

  return TRUE;
}

BOOL NewProfileDlgOK(HWND hDlg,NEWPROFILEDLGINFO * pNewProfileDlgInfo)
{
  ASSERT(pNewProfileDlgInfo);

  // get new profile name out of edit control
  GetDlgItemText(hDlg,IDC_PROFILENAME,pNewProfileDlgInfo->szNewProfileName,
    sizeof(pNewProfileDlgInfo->szNewProfileName));

  // name needs to be non-empty
  if (!lstrlen(pNewProfileDlgInfo->szNewProfileName)) {
    MsgBox(hDlg,IDS_NEED_PROFILENAME,MB_ICONINFORMATION,MB_OK);
    SetFocus(GetDlgItem(hDlg,IDC_PROFILENAME));
    return FALSE;
  }

  // name needs to be unique
  if (ComboBox_FindStringExact(pNewProfileDlgInfo->hwndCombo,
    0,pNewProfileDlgInfo->szNewProfileName) >= 0) {
    MsgBox(hDlg,IDS_DUPLICATE_PROFILENAME,MB_ICONINFORMATION,MB_OK);
    SetFocus(GetDlgItem(hDlg,IDC_PROFILENAME));
    Edit_SetSel(GetDlgItem(hDlg,IDC_PROFILENAME),0,-1);
    return FALSE;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    NewProfileDlgProc

  Maps a scheme name/length to a scheme name type

  Arguments:

    lpszSchemeName  - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)
 
  Return Value:

    INTERNET_SCHEME

********************************************************************/
INTERNET_SCHEME MapUrlSchemeName(LPTSTR lpszSchemeName, DWORD dwSchemeNameLength)
{
    if (dwSchemeNameLength == (DWORD)-1)
    {
        dwSchemeNameLength = (DWORD)lstrlen(lpszSchemeName);
    }

    int i = 0;
    do
    {
        if (UrlSchemeList[i].SchemeLength == dwSchemeNameLength)
        {
            TCHAR chBackup = lpszSchemeName[dwSchemeNameLength];
            lpszSchemeName[dwSchemeNameLength] = '\0';

            if(lstrcmpi(UrlSchemeList[i].SchemeName,lpszSchemeName) == 0)
            {
                lpszSchemeName[dwSchemeNameLength] = chBackup;
                return UrlSchemeList[i].SchemeType;
            }

            lpszSchemeName[dwSchemeNameLength] = chBackup;
        }
        i++;
    } while (UrlSchemeList[i].SchemeLength);

    return INTERNET_SCHEME_UNKNOWN;
}

/*******************************************************************

  NAME:    MapUrlSchemeTypeToCtlId

Routine Description:

    Maps a scheme to a dlg child control id.

Arguments:

    Scheme    - Scheme to Map

    fIdForPortCtl - If TRUE, means we really want the ID for a the PORT control
            not the ADDRESS control.

Return Value:

    DWORD

********************************************************************/
DWORD MapUrlSchemeTypeToCtlId(INTERNET_SCHEME SchemeType, BOOL fIdForPortCtl)
{
    int i = 0;
    while (UrlSchemeList[i].SchemeLength)
    {
        if (SchemeType == UrlSchemeList[i].SchemeType)
        {
            return (fIdForPortCtl ? UrlSchemeList[i].dwPortControlId :
                                    UrlSchemeList[i].dwControlId );
        }
        i++;
    }
    return 0;
}

/*******************************************************************

  NAME:    MapCtlIdUrlSchemeName


Routine Description:

    Maps a dlg child control id to String represnting
    the name of the scheme.

Arguments:

    dwEditCtlId   - Edit Control to Map Out.

    lpszSchemeOut - Scheme to Map Out.
            WARNING: ASSUMED to be size of largest scheme type.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

********************************************************************/
BOOL MapCtlIdUrlSchemeName(DWORD dwEditCtlId, LPTSTR lpszSchemeOut)
{
    ASSERT(lpszSchemeOut);

    int i = 0;
    while (UrlSchemeList[i].SchemeLength)
    {
        if (dwEditCtlId == UrlSchemeList[i].dwControlId )
        {
            lstrcpy(lpszSchemeOut, UrlSchemeList[i].SchemeName);
            return TRUE;
        }
        i++;
    }
    return FALSE;
}

/*******************************************************************

  NAME:    MapAddrCtlIdToPortCtlId

Routine Description:

    Maps a dlg child control id for addresses to
    a dlg control id for ports.

Arguments:

    dwEditCtlId   - Edit Control to Map Out.

Return Value:

    DWORD
    Success - Correctly mapped ID.

    Failure - 0.

********************************************************************/
DWORD MapAddrCtlIdToPortCtlId(DWORD dwEditCtlId)
{
    int i = 0;
    while (UrlSchemeList[i].SchemeLength)
    {
        if (dwEditCtlId == UrlSchemeList[i].dwControlId )
        {
            return UrlSchemeList[i].dwPortControlId ;
        }
        i++;
    }
    return FALSE;
}


/*******************************************************************

  NAME:    ParseProxyInfo

  Parses proxy server string and sets dialog fields appropriately

  Arguments:

    hDlg - Handle to dialog

    lpszProxy - Proxy server string

    lpszSchemeName  - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)
 
  Return Value:

    INTERNET_SCHEME

********************************************************************/

BOOL ParseProxyInfo(HWND hDlg, LPTSTR lpszProxy)
{
    DWORD error = FALSE;
    DWORD entryLength = 0;
    LPTSTR protocolName = lpszProxy;
    DWORD protocolLength = 0;
    LPTSTR schemeName = NULL;
    DWORD schemeLength = 0;
    LPTSTR serverName = NULL;
    DWORD serverLength = 0;
    PARSER_STATE state = STATE_PROTOCOL;
    DWORD nSlashes = 0;
    UINT port = 0;
    BOOL done = FALSE;
    LPTSTR lpszList = lpszProxy;


    do
    {
        TCHAR ch = *lpszList++;

        if ((1 == nSlashes) && (ch != '/'))
        {
            state = STATE_ERROR;
            break;  // do ... while
        }

        switch (ch)
        {
        case '=':
            if ((state == STATE_PROTOCOL) && (entryLength != 0))
            {
                protocolLength = entryLength;
                entryLength = 0;
                state = STATE_SCHEME;
                schemeName = lpszList;
            }
            else
            {
                //
                // '=' can't legally appear anywhere else
                //
                state = STATE_ERROR;
            }
            break;

        case ':':
            switch (state)
            {
            case STATE_PROTOCOL:
                if (*lpszList == '/')
                {
                    schemeName = protocolName;
                    protocolName = NULL;
                    schemeLength = entryLength;
                    protocolLength = 0;
                    state = STATE_SCHEME;
                }
                else if (*lpszList != '\0')
                {
                    serverName = protocolName;
                    protocolName = NULL;
                    serverLength = entryLength;
                    protocolLength = 0;
                    state = STATE_PORT;
                }
                else
                {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SCHEME:
                if (*lpszList == '/')
                {
                    schemeLength = entryLength;
                }
                else if (*lpszList != '\0')
                {
                    serverName = schemeName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                }
                else
                {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0))
            {
                if (++nSlashes == 2)
                {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            }
            else
            {
                state = STATE_ERROR;
            }
            break;

        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
            if (!((state == STATE_PROTOCOL) && (entryLength == 0)))
            {
                //
                // can't have embedded whitespace
                //

                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT)
            {
                ++entryLength;
            }
            else if (isdigit(ch))
            {
                // calculate in DWORD to prevent overflow
                DWORD dwPort = port * 10 + (ch - '0');

                if (dwPort <= 65535)
                    port = (UINT)dwPort;
                else
                    state = STATE_ERROR;
            }
            else
            {                   
                //
                // STATE_PORT && non-digit character - error
                //
                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

        //
        // fall through
        //
        case ' ':
        case '\t':
        case '\n':
        case '\r':
        case ';':
        case ',':
            if (serverLength == 0)
            {
                serverLength = entryLength;
            }
            if (serverLength != 0)
            {
                if (serverName == NULL)
                {
                    serverName = (schemeName != NULL)
                                    ? schemeName : protocolName;
                }

                ASSERT(serverName != NULL);

                INTERNET_SCHEME protocol;

                if (protocolLength != 0)
                {
                    protocol = MapUrlSchemeName(protocolName, protocolLength);
                }
                else
                {
                    protocol = INTERNET_SCHEME_DEFAULT;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0)
                {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                }
                else
                {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((protocol != INTERNET_SCHEME_UNKNOWN)
                    && (scheme != INTERNET_SCHEME_UNKNOWN))
                {
                    DWORD dwCtlId = 0;
                    DWORD dwPortCtlId = 0;
                    TCHAR chBackup;

                    error = ERROR_SUCCESS;
                    //
                    // we can only currently handle CERN proxies (unsecure or
                    // secure) so kick out anything that wants to go via a different
                    // proxy scheme
                    //

                    if (protocol == INTERNET_SCHEME_DEFAULT)
                    {
                        CheckDlgButton( hDlg, IDC_PROXYSAME, TRUE );
                        dwCtlId     = IDC_PROXYHTTP;
                        dwPortCtlId = IDC_PORTHTTP;
                    }
                    else
                    {
                        dwCtlId     = MapUrlSchemeTypeToCtlId(protocol,FALSE);
                        dwPortCtlId = MapUrlSchemeTypeToCtlId(protocol,TRUE);
                    }

                    //
                    // Set the Field Entry.
                    //

                    LPTSTR lpszProxyNameText;

                    if (scheme != INTERNET_SCHEME_DEFAULT)
                    {
                        ASSERT(schemeLength != 0);
                        lpszProxyNameText = schemeName;
                    }
                    else
                        lpszProxyNameText = serverName;

                    chBackup = serverName[serverLength];
                    serverName[serverLength] = '\0';

                    SetDlgItemText( hDlg, dwCtlId, lpszProxyNameText );
                    if ( port )
                        SetDlgItemInt( hDlg, dwPortCtlId, port, FALSE );

                    serverName[serverLength] = chBackup;

                }

                else
                {                      
                    //
                    // bad/unrecognised protocol or scheme. Treat it as error
                    // for now
                    //
                    error = !ERROR_SUCCESS;
                }
            }

            entryLength = 0;
            protocolName = lpszList;
            protocolLength = 0;
            schemeName = NULL;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            if (error == ERROR_SUCCESS)
            {
                state = STATE_PROTOCOL;
            }
            else
            {
                state = STATE_ERROR;
            }
        break;
        }

        if (state == STATE_ERROR)
        {
        break;
        }

    } while (!done);

    if (state == STATE_ERROR)
    {
        error = ERROR_INVALID_PARAMETER;
    }

    if ( error == ERROR_SUCCESS )
        error = TRUE;
    else
        error = FALSE;

    return error;
}

/*******************************************************************

  NAME:    ParseEditCtlForPort

Routine Description:

    Parses a Port Number off then end of a Proxy Server URL that is
    located either in the Proxy Name Edit Box, or passed in as
    a string pointer.

Arguments:

    lpszProxyName - (OPTIONAL) string pointer with Proxy Name to parse, and
            set into the Proxy Name edit ctl field.

    hDlg      - HWIN of the dialog to play with.

    dwProxyNameCtlId -  Res Ctl Id to play with.

    dwProxyPortCtlId -  Res Ctl Id of Port Number Edit Box.

Return Value:

    BOOL
    Success TRUE -

    Failure FALSE

********************************************************************/
BOOL ParseEditCtlForPort(
    IN OUT LPTSTR   lpszProxyName,
    IN HWND    hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId
    )
{
    TCHAR  szProxyUrl[MAX_URL_STRING+1];
    LPTSTR lpszPort;
    LPTSTR lpszProxyUrl;

    ASSERT(IsWindow(hDlg));

    if ( dwProxyPortCtlId == 0 )
    {
    dwProxyPortCtlId = MapAddrCtlIdToPortCtlId(dwProxyNameCtlId);
    ASSERT(dwProxyPortCtlId);
    }

    //
    // Get the Proxy String from the Edit Control
    //  (OR) from the Registry [passed in]
    //

    if ( lpszProxyName )
    lpszProxyUrl = lpszProxyName;
    else
    {
    //
    // Need to Grab it out of the edit control.
    //
        GetDlgItemText(hDlg,
            dwProxyNameCtlId,
            szProxyUrl,
            sizeof(szProxyUrl));

    lpszProxyUrl = szProxyUrl;
    }

    //
    // Now find the port.
    //

    lpszPort = lpszProxyUrl;

    GET_TERMINATOR(lpszPort);

    lpszPort--;

    //
    // Walk backwards from the end of url looking
    //  for a port number sitting on the end like this
    //  http://proxy:1234
    //

    while ( (lpszPort > lpszProxyUrl) &&
        (*lpszPort != ':')         &&
        (isdigit(*lpszPort))  )
    {
    lpszPort--;
    }

    //
    // If we found a match for our rules
    //  then set the port, otherwise
    //  we assume the user knows what he's
    //  doing.
    //

    if ( *lpszPort == ':'   &&   isdigit(*(lpszPort+1)) )
    {
    *lpszPort = '\0';

    SetDlgItemText(hDlg, dwProxyPortCtlId, (lpszPort+1));
    }

    SetDlgItemText(hDlg, dwProxyNameCtlId, lpszProxyUrl);
    return TRUE;
}

/*******************************************************************

  NAME:    FormatOutProxyEditCtl

Routine Description:

    Combines Proxy URL components into a string that can be saved
    in the registry.  Can be called multiple times to build
    a list of proxy servers, or once to special case a "default"
    proxy.

Arguments:

    hDlg      - HWIN of the dialog to play with.

    dwProxyNameCtlId -  Res Ctl Id to play with.

    dwProxyPortCtlId -  Res Ctl Id of Port Number Edit Box.

    lpszOutputStr    -  The start of the output string to send
            the product of this function.

    lpdwOutputStrSize - The amount of used space in lpszOutputStr
            that is already used.  New output should
            start from (lpszOutputStr + *lpdwOutputStrSize)

    fDefaultProxy     - Default Proxy, don't add scheme= in front of the proxy
            just use plop one proxy into the registry.


Return Value:

    DWORD
    Success ERROR_SUCCESS

    Failure ERROR message

********************************************************************/
DWORD FormatOutProxyEditCtl(
    IN HWND    hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId,
    OUT LPTSTR      lpszOutputStr,
    IN OUT LPDWORD lpdwOutputStrSize,
    IN DWORD       dwOutputStrLength,
    IN BOOL    fDefaultProxy
    )
{
    LPTSTR lpszOutput;
    LPTSTR lpszEndOfOutputStr;

    ASSERT(IsWindow(hDlg));
    ASSERT(lpdwOutputStrSize);

    lpszOutput = lpszOutputStr + *lpdwOutputStrSize;
    lpszEndOfOutputStr = lpszOutputStr + dwOutputStrLength;

    ASSERT( lpszEndOfOutputStr > lpszOutput );

    if ( lpszEndOfOutputStr <= lpszOutput )
        return ERROR_NOT_ENOUGH_MEMORY; // bail out, ran out of space

    //
    // Plop ';' if we're not the first in this string buffer.
    //

    if (*lpdwOutputStrSize != 0  )
    {
        *lpszOutput = ';';

        lpszOutput++;

        if ( lpszEndOfOutputStr <= lpszOutput )
            return ERROR_NOT_ENOUGH_MEMORY; // bail out, ran out of space
    }

    //
    // Put the schemetype= into the string
    //  ex:  http=
    //

    if ( ! fDefaultProxy )
    {
        if ( lpszEndOfOutputStr <= (MAX_SCHEME_NAME_LENGTH + lpszOutput + 1) )
            return ERROR_NOT_ENOUGH_MEMORY; // bail out, ran out of space

        if (!MapCtlIdUrlSchemeName(dwProxyNameCtlId,lpszOutput))
            return ERROR_NOT_ENOUGH_MEMORY;

        lpszOutput += lstrlen(lpszOutput);

        *lpszOutput = '=';
        lpszOutput++;
    }

    //
    // Need to Grab ProxyUrl out of the edit control.
    //

    GetDlgItemText(hDlg, dwProxyNameCtlId, lpszOutput, (int)(lpszEndOfOutputStr - lpszOutput));

    if ( '\0' == *lpszOutput ) 
    {
        // Cancel out anything we may have added before returning
        *(lpszOutputStr + *lpdwOutputStrSize) = '\0';
        return ERROR_SERVER_NAME;
    }

    //
    // Now seperate out the port so we can save them seperately.
    //   But go past the Proxy Url while we're at it.
    //      ex: http=http://netscape-proxy
    //

    if (!ParseEditCtlForPort(lpszOutput, hDlg, dwProxyNameCtlId, dwProxyPortCtlId))
        return ERROR_PORT_NUM;

    lpszOutput += lstrlen(lpszOutput);

    //
    // Now, add in a ':" for the port number, if we don't
    //  have a port we'll remove it.
    //
    *lpszOutput = ':';

    lpszOutput++;

    if ( lpszEndOfOutputStr <= lpszOutput )
        return ERROR_NOT_ENOUGH_MEMORY; // bail out, ran out of space

    //
    // Grab Proxy Port if its around.
    //  Back out the ':' if its not.
    //

    GetDlgItemText(hDlg, dwProxyPortCtlId,lpszOutput, (int)(lpszEndOfOutputStr - lpszOutput));

    // jmazner 11/9/96 Normandy #6937
    // Don't accept non-numerical port numbers, since the Internet control panel
    // will not display them.

    int i;
    for( i=0; lpszOutput[i] != NULL; i++ )
    {
        if( !isdigit(lpszOutput[i]) )
        {
            //DisplayFieldErrorMsg(hDlg,dwProxyPortCtlId,IDS_INVALID_PORTNUM);
            return ERROR_PORT_NUM;
        }
    }


    if ( '\0' == *lpszOutput )
    {
        lpszOutput--;

        ASSERT(*lpszOutput == ':');

        *lpszOutput = '\0';
    }

    lpszOutput += lstrlen(lpszOutput);

    //
    // Now we're done return our final sizes.
    //

    *lpdwOutputStrSize = (DWORD)(lpszOutput - lpszOutputStr);

    return ERROR_SUCCESS;
}

/*******************************************************************

  NAME:    RemoveLocalFromExceptionList

Routine Description:

    Scans a delimited list of entries, and removed "<local>
    if found.  If <local> is found we return TRUE.

Arguments:

    lpszExceptionList - String List of proxy excepion entries.


Return Value:

    BOOL
    TRUE - If found <local>

    FALSE - If local was not found.

********************************************************************/
BOOL RemoveLocalFromExceptionList(LPTSTR lpszExceptionList)
{
    LPTSTR lpszLocalInstToRemove;
    BOOL  fFoundLocal;

    if ( !lpszExceptionList || ! *lpszExceptionList )
        return FALSE;

    fFoundLocal = FALSE;
    lpszLocalInstToRemove = lpszExceptionList;

    //
    // Loop looking "<local>" entries in the list.
    //

    do {

        lpszLocalInstToRemove = _tcsstr(lpszLocalInstToRemove,cszLocalString);

        if ( lpszLocalInstToRemove )
        {

            fFoundLocal = TRUE;

            //
            // Nuke <local> out of the string. <local>;otherstuff\0
            //  Dest is: '<'local>;otherstuff\0
            //     ??? (OR) ';'<local> if the ; is the first character.???
            //  Src  is: >'o'therstuff\0
            //  size is: sizeof(';otherstuff\0')
            //

            MoveMemory( lpszLocalInstToRemove,
                        (lpszLocalInstToRemove+(sizeof(cszLocalString)-sizeof('\0'))),
                        lstrlen(lpszLocalInstToRemove+(sizeof(cszLocalString)-sizeof('\0')))
                        + sizeof('\0')
                        );

        }

    } while (lpszLocalInstToRemove && *lpszLocalInstToRemove);

    //
    // If we produced a ; on the end, nuke it.
    //

    lpszLocalInstToRemove = lpszExceptionList;

    GET_TERMINATOR(lpszLocalInstToRemove);

    if ( lpszLocalInstToRemove != lpszExceptionList &&
        *(lpszLocalInstToRemove-1) == ';' )
    {
        *(lpszLocalInstToRemove-1) = '\0';
    }

    return fFoundLocal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\mapicall.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  MAPICALL.H - Header file for MAPI callout module
//      
//

//  HISTORY:
//  
//  1/27/95    jeremys  Created.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//

#ifndef _MAPICALL_H_
#define _MAPICALL_H_

#define MAPI_DIM  10

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  #include <mapidefs.h>
  #include <mapicode.h>
  #include <mspst.h>
  #include <mspab.h>
  #include <mapiwin.h>
  #include <mapitags.h>
  #include <mapiutil.h>
  #include <mapispi.h>
  #include <inetprop.h>

#ifdef DEBUG
  #undef Assert  // avoid multiple definitions
  #include <mapidbg.h>
#endif

#ifdef __cplusplus
}
#endif // __cplusplus

// prototype for function pointer for MAPI util function
typedef HRESULT (CALLBACK * LPHRQUERYALLROWS) (LPMAPITABLE,LPSPropTagArray,
  LPSRestriction,LPSSortOrderSet,LONG,LPSRowSet FAR *);
extern HINSTANCE hInstMAPIDll;    // handle to MAPI dll we load explicitly

// structure used in determining if a service is present in a MAPI profile,
// and to install the service
typedef struct tagMSGSERVICE {
  BOOL fPresent;        // TRUE if service is present
  UINT uIDServiceName;    // ID of str resource with service name (non-UI)
  UINT uIDServiceDescription;  // ID of str resource with service desc (for UI)

  BOOL fNeedConfig;      // TRUE if create-time config proc should be called
  UINT uIDStoreFilename;    // name to try for message store for
  UINT uIDStoreFilename1;    // name to use to generate other message store names
  UINT uPropID;        // prop val ID for message store property for this service
} MSGSERVICE;

#define NUM_SERVICES    3  // number of services in table of MSGSERVICEs

// class to aid in releasing interfaces.  When you obtain an OLE interface,
// you can contruct a RELEASE_ME_LATER object with the pointer to the interface.
// When the object is destructed, it will release the interface.
class RELEASE_ME_LATER
{
private:
  LPUNKNOWN _lpInterface;
public:
  RELEASE_ME_LATER(LPUNKNOWN lpInterface) { _lpInterface = lpInterface; }
  ~RELEASE_ME_LATER() { if (_lpInterface) _lpInterface->Release(); }
};

// defines needed by route 66 config DLL.  Note: don't change these!
#define CONNECT_TYPE_LAN        1
#define CONNECT_TYPE_REMOTE        2  
#define DOWNLOAD_OPTION_HEADERS      1
#define DOWNLOAD_OPTION_MAIL_DELETE     3

class ENUM_MAPI_PROFILE
{
private:
  LPSRowSet   _pProfileRowSet;
  UINT    _iRow;
  UINT    _nEntries;
public:
  ENUM_MAPI_PROFILE();
  ~ENUM_MAPI_PROFILE();
  BOOL Next(LPTSTR * ppProfileName,BOOL * pfDefault);
  UINT GetEntryCount()  { return _nEntries; }
  
};

class ENUM_MAPI_SERVICE
{
private:
  LPSRowSet   _pServiceRowSet;
  UINT    _iRow;
  UINT    _nEntries;
public:
  ENUM_MAPI_SERVICE(LPTSTR pszProfileName);
  ~ENUM_MAPI_SERVICE();
  BOOL Next(LPTSTR * ppServiceName);
  UINT GetEntryCount()  { return _nEntries; }
  
};

#endif // _MAPICALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\propmgr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  PROPMGR.C - Sets up wizard property sheets and runs wizard
//

//  HISTORY:
//  
//  12/21/94  jeremys  Created.
//  96/03/07  markdu  Stop using CLIENTCONFIG modem enum stuff,
//            since we enum modems later with RNA.  This means that we
//            can't use modem count for any default setting determination
//            in InitUserInfo anymore.
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/25  markdu  If a page OK proc returns FALSE, check the state of
//            gfQuitWizard flag.  If TRUE, a fatal error has occured.
//  96/03/25  markdu  If a page init proc returns FALSE, check the state of
//            gfQuitWizard flag.  If TRUE, a fatal error has occured.
//  96/03/27  markdu  Added lots of new pages.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Use lpIcfgNeedInetComponents.
//  96/05/28  markdu  Moved InitConfig and DeInitConfig to DllEntryPoint.
//
//    97/04/23  jmazner    Olympus #3136
//                        Ripped out all mail/news/ldap UI and gave it to
//                        the account manager folks.
//
//    01/01/20  chunhoc   Add MyRestartDialog
//                      
//

#include "wizard.h"
#define DONT_WANT_SHELLDEBUG
#include <shlobj.h>
#include <winuserp.h>
#include "pagefcns.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"
#include "inetcfg.h"
#include <icwcfg.h>
#if !defined(WIN16)
#include <helpids.h>
#endif // !WIN16

#define ARRAYSIZE(a)  (sizeof(a) / sizeof(a[0]))

#define WIZ97_TITLE_FONT_PTS    12
#define OE_PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\MSIMN.EXE")
#define NEWOEVERSION TEXT("5.00.0809\0")
#define MAX_VERSION_LEN 40
#define BITMAP_WIDTH  164
#define BITMAP_HEIGHT 458

#define RECTWIDTH(rc) ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)

//dlg IDs of first and last apprentice pages
UINT    g_uAcctMgrUIFirst, g_uAcctMgrUILast; 
CICWExtension *g_pCICWExtension = NULL;
BOOL    g_fAcctMgrUILoaded = FALSE;
BOOL    g_fIsWizard97 = FALSE;
BOOL    g_fIsExternalWizard97 = FALSE;
BOOL    g_fIsICW = FALSE;
INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
VOID InitWizardState(WIZARDSTATE * pWizardState, DWORD dwFlags);
VOID InitUserInfo(USERINFO * pUserInfo);
VOID InitIMNApprentice();
UINT GetDlgIDFromIndex(UINT uPageIndex);
BOOL SystemAlreadyConfigured(USERINFO * pUserInfo);
BOOL CALLBACK MiscInitProc(HWND hDlg, BOOL fFirstInit, UINT uDlgID);
BOOL GetShellNextFromReg( LPTSTR lpszCommand, LPTSTR lpszParams, DWORD dwStrLen );
void RemoveShellNextFromReg( void );


//in util.cpp
extern void GetCmdLineToken(LPTSTR *ppszCmd,LPTSTR pszOut);


extern ICFGNEEDSYSCOMPONENTS        lpIcfgNeedInetComponents;
extern ICFGGETLASTINSTALLERRORTEXT  lpIcfgGetLastInstallErrorText;

BOOL gfQuitWizard = FALSE;  // global flag used to signal that we
              // want to terminate the wizard ourselves
BOOL gfUserCancelled = FALSE;    // global flag used to signal that
                                // the user cancelled
BOOL gfUserBackedOut = FALSE;    // global flag used to signal that
                                // the user pressed Back on the
                                // first page
BOOL gfUserFinished = FALSE;    // global flag used to signal that
                                // the user pressed Finish on the
                                // final page
BOOL gfOleInitialized = FALSE;    // OLE has been initialized

//IImnAccount *g_pMailAcct = NULL;
//IImnAccount *g_pNewsAcct = NULL;
//IImnAccount *g_pDirServAcct = NULL;


BOOL AllocDialogIDList( void );
BOOL DialogIDAlreadyInUse( UINT uDlgID );
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse );
BOOL DeinitWizard(DWORD dwFlags );
DWORD *g_pdwDialogIDList = NULL;
DWORD g_dwDialogIDListSize = 0;

//
// Added to preserve the REBOOT state from conn1 -> manual and 
// manual -> conn1 - MKarki
//
static BOOL gfBackedUp = FALSE;
static BOOL gfReboot = FALSE;
//
// Table of data for each wizard page
//
// This includes the dialog template ID and pointers to functions for
// each page.  Pages need only provide pointers to functions when they
// want non-default behavior for a certain action (init,next/back,cancel,
// dlg ctrl).
//

PAGEINFO PageInfo[NUM_WIZARD_PAGES] =
{
  { IDD_PAGE_HOWTOCONNECT,       IDD_PAGE_HOWTOCONNECT97,         IDD_PAGE_HOWTOCONNECT97FIRSTLAST,HowToConnectInitProc,    HowToConnectOKProc,     NULL,                   NULL,ICW_SETUP_MANUAL,      0,                          0 },
  { IDD_PAGE_CHOOSEMODEM,        IDD_PAGE_CHOOSEMODEM97,          IDD_PAGE_CHOOSEMODEM97,          ChooseModemInitProc,     ChooseModemOKProc,      ChooseModemCmdProc,     NULL,ICW_CHOOSE_MODEM,      IDS_CHOOSEMODEM_TITLE,      0 },
  { IDD_PAGE_CONNECTEDOK,        IDD_PAGE_CONNECTEDOK97,          IDD_PAGE_CONNECTEDOK97FIRSTLAST, ConnectedOKInitProc,     ConnectedOKOKProc,      NULL,                   NULL,ICW_COMPLETE,          0,                          0 },
  { IDD_PAGE_CONNECTION,         IDD_PAGE_CONNECTION97,           IDD_PAGE_CONNECTION97,           ConnectionInitProc,      ConnectionOKProc,       ConnectionCmdProc,      NULL,ICW_DIALUP_CONNECTION, IDS_CONNECTION_TITLE,       0 },
  { IDD_PAGE_MODIFYCONNECTION,   IDD_PAGE_MODIFYCONNECTION97,     IDD_PAGE_MODIFYCONNECTION97,     ModifyConnectionInitProc,ModifyConnectionOKProc, NULL,                   NULL,ICW_DIALUP_SETTINGS,   IDS_MODIFYCONNECTION_TITLE, 0 },
  { IDD_PAGE_CONNECTIONNAME,     IDD_PAGE_CONNECTIONNAME97,       IDD_PAGE_CONNECTIONNAME97,       ConnectionNameInitProc,  ConnectionNameOKProc,   NULL,                   NULL,ICW_DIALUP_NAME,       IDS_CONNECTIONNAME_TITLE,   0 },
  { IDD_PAGE_PHONENUMBER,        IDD_PAGE_PHONENUMBER97,          IDD_PAGE_PHONENUMBER97,          PhoneNumberInitProc,     PhoneNumberOKProc,      PhoneNumberCmdProc,     NULL,ICW_PHONE_NUMBER,      IDS_PHONENUMBER_TITLE,      0 },
  { IDD_PAGE_NAMEANDPASSWORD,    IDD_PAGE_NAMEANDPASSWORD97,      IDD_PAGE_NAMEANDPASSWORD97,      NameAndPasswordInitProc, NameAndPasswordOKProc,  NULL,                   NULL,ICW_NAME_PASSWORD,     IDS_NAMEANDPASSWORD_TITLE,  0 },
  { IDD_PAGE_USEPROXY,           IDD_PAGE_USEPROXY97,             IDD_PAGE_USEPROXY97,             UseProxyInitProc,        UseProxyOKProc,         UseProxyCmdProc,        NULL,ICW_USE_PROXY,         IDS_LAN_INETCFG_TITLE,      0 },
  { IDD_PAGE_PROXYSERVERS,       IDD_PAGE_PROXYSERVERS97,         IDD_PAGE_PROXYSERVERS97,         ProxyServersInitProc,    ProxyServersOKProc,     ProxyServersCmdProc,    NULL,ICW_PROXY_SERVERS,     IDS_LAN_INETCFG_TITLE,      0 },
  { IDD_PAGE_PROXYEXCEPTIONS,    IDD_PAGE_PROXYEXCEPTIONS97,      IDD_PAGE_PROXYEXCEPTIONS97,      ProxyExceptionsInitProc, ProxyExceptionsOKProc,  NULL,                   NULL,ICW_PROXY_EXCEPTIONS,  IDS_LAN_INETCFG_TITLE,      0 },
  { IDD_PAGE_SETUP_PROXY,        IDD_PAGE_SETUP_PROXY97,          IDD_PAGE_SETUP_PROXY97,          SetupProxyInitProc,      SetupProxyOKProc,       SetupProxyCmdProc,      NULL,ICW_SETUP_PROXY,       IDS_LAN_INETCFG_TITLE,      0 }
};



BOOL CheckOEVersion()
{
    HRESULT hr;
    HKEY    hKey = 0;
    LPVOID  lpVerInfoBlock;
    LPVOID  lpTheVerInfo;
    UINT    uTheVerInfoSize;
    DWORD   dwVerInfoBlockSize, dwUnused, dwPathSize;
    TCHAR   szOELocalPath[MAX_PATH + 1] = TEXT("");
    TCHAR   szSUVersion[MAX_VERSION_LEN];
    DWORD   dwVerPiece;
    DWORD   dwType;
    int     nResult = -1;
    
    // get path to the IE executable
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, OE_PATHKEY,0, KEY_READ, &hKey);
    if (hr != ERROR_SUCCESS) return( FALSE );

    dwPathSize = sizeof (szOELocalPath);
    if (ERROR_SUCCESS == (hr = RegQueryValueEx(hKey, NULL, NULL, &dwType, (LPBYTE) szOELocalPath, &dwPathSize)))
    {
        if (REG_EXPAND_SZ == dwType)
        {
            TCHAR szTemp[MAX_PATH + 1];
            ExpandEnvironmentStrings(szOELocalPath, szTemp, ARRAYSIZE(szTemp));
            lstrcpy(szOELocalPath, szTemp);
        }
    }
    RegCloseKey( hKey );
    if (hr != ERROR_SUCCESS) return( FALSE );

    // now go through the convoluted process of digging up the version info
    dwVerInfoBlockSize = GetFileVersionInfoSize( szOELocalPath, &dwUnused );
    if ( 0 == dwVerInfoBlockSize ) return( FALSE );

    lpVerInfoBlock = GlobalAlloc( GPTR, dwVerInfoBlockSize );
    if( NULL == lpVerInfoBlock ) return( FALSE );

    if( !GetFileVersionInfo( szOELocalPath, NULL, dwVerInfoBlockSize, lpVerInfoBlock ) )
        return( FALSE );

    if( !VerQueryValue(lpVerInfoBlock, TEXT("\\\0"), &lpTheVerInfo, &uTheVerInfoSize) )
        return( FALSE );

    lpTheVerInfo = (LPVOID)((DWORD_PTR)lpTheVerInfo + sizeof(DWORD)*4);
    szSUVersion[0] = 0;
    dwVerPiece = (*((LPDWORD)lpTheVerInfo)) >> 16;
    wsprintf(szSUVersion,TEXT("%d."),dwVerPiece);

    dwVerPiece = (*((LPDWORD)lpTheVerInfo)) & 0x0000ffff;
    wsprintf(szSUVersion,TEXT("%s%02d."),szSUVersion,dwVerPiece);

    dwVerPiece = (((LPDWORD)lpTheVerInfo)[1]) >> 16;
    wsprintf(szSUVersion,TEXT("%s%04d."),szSUVersion,dwVerPiece);

    //dwVerPiece = (((LPDWORD)lpTheVerInfo)[1]) & 0x0000ffff;
    //wsprintf(szSUVersion,"%s%01d",szSUVersion,dwVerPiece);

    nResult = lstrcmp(szSUVersion, NEWOEVERSION);

    GlobalFree( lpVerInfoBlock );

    return( nResult >= 0 );
}

/*******************************************************************

  NAME:    RunSignupWizard

  SYNOPSIS:  Creates property sheet pages, initializes wizard
        property sheet and runs wizard

  ENTRY:    dwFlags - RSW_ flags for signup wizard
          RSW_NOREBOOT - inhibit reboot message.  Used if
          we are being run by some setup entity which needs
          to reboot anyway.

            hwndParent - The parent window of the wizard.

  EXIT:    returns TRUE if user runs wizard to completion,
        FALSE if user cancels or an error occurs

  NOTES:    Wizard pages all use one dialog proc (GenDlgProc).
        They may specify their own handler procs to get called
        at init time or in response to Next, Cancel or a dialog
        control, or use the default behavior of GenDlgProc.

********************************************************************/
BOOL InitWizard(DWORD dwFlags, HWND hwndParent /* = NULL */)
{
    HPROPSHEETPAGE hWizPage[NUM_WIZARD_PAGES];  // array to hold handles to pages
    PROPSHEETPAGE psPage;    // struct used to create prop sheet pages
    PROPSHEETHEADER psHeader;  // struct used to run wizard property sheet
    UINT nPageIndex;
    int iRet;
    HRESULT hr;

    ASSERT(gpWizardState);   // assert that global structs have been allocated
    ASSERT(gpUserInfo);

    // We are in Wizard 97 Mode
    g_fIsWizard97  = TRUE;
  
    //register the Native font control so the dialog won't fail
    //although it's registered in the exe this is a "just in case"
    HINSTANCE hComCtl = LoadLibrary(TEXT("comctl32.dll"));
    if (hComCtl)
    {
        
        PFNInitCommonControlsEx pfnInitCommonControlsEx = NULL;

        if (pfnInitCommonControlsEx = (PFNInitCommonControlsEx)GetProcAddress(hComCtl,"InitCommonControlsEx"))
        {
            //register the Native font control so the dialog won't fail
            INITCOMMONCONTROLSEX iccex;
            iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
            iccex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
            if (!pfnInitCommonControlsEx(&iccex))
                return FALSE;
        }
        FreeLibrary(hComCtl);
    }
    
    AllocDialogIDList();

    if( !gfOleInitialized )
    {
        // initialize OLE
        hr = CoInitialize(NULL);
        if (S_OK != hr && S_FALSE != hr)
        {
          DisplayErrorMessage(NULL,IDS_ERRCoInitialize,(UINT) hr,
            ERRCLS_STANDARD,MB_ICONEXCLAMATION);
          return FALSE;    
        }
        gfOleInitialized = TRUE;
    }

    // initialize mail/news set up options
    InitIMNApprentice();

    if (!(dwFlags & RSW_NOINIT))
    {

        // initialize the rasentry structure
        InitRasEntry(gpRasEntry);

        // initialize the app state structure
        InitWizardState(gpWizardState, dwFlags);

        // save flags away
        gpWizardState->dwRunFlags = dwFlags;

        // initialize user data structure
        InitUserInfo(gpUserInfo);

        //
        // 7/8/97 jmazner Olympus #9040
        // this init needs to happen every time, because whenever we
        // back out, we kill the apprentice. (see comment in RunSignupWizardExit)
        // initialize mail/news set up options
        //InitIMNApprentice();
        //

        // get proxy server config information
        hr = InetGetProxy(&gpUserInfo->fProxyEnable,
          gpUserInfo->szProxyServer, sizeof(gpUserInfo->szProxyServer),
          gpUserInfo->szProxyOverride, sizeof(gpUserInfo->szProxyOverride));

        // return value will be ERROR_FILE_NOT_FOUND if the entry does not exist
        // in the registry.  Allow this, since we have zerod the structure.
        if ((ERROR_SUCCESS != hr) && (ERROR_FILE_NOT_FOUND != hr))
        {
          DisplayErrorMessage(NULL,IDS_ERRReadConfig,(UINT) hr,
            ERRCLS_STANDARD,MB_ICONEXCLAMATION);
          iRet = 0;
          return FALSE;
        }

        // if we're in Plus! setup and the system seems to already be set up
        // for the internet, then pop up a message box asking if the user wants
        // to keep her current settings (and not run the wizard)
        if ( (dwFlags & RSW_NOREBOOT) && SystemAlreadyConfigured(gpUserInfo))
        {
          if (MsgBox(NULL,IDS_SYSTEM_ALREADY_CONFIGURED,MB_ICONQUESTION,MB_YESNO)
            == IDYES) {
              iRet = 0;
              return FALSE;
          }
        }
    }

    //
    // 6/4/97 jmazner Olympus #4245
    // Now that we're done with SystemAlreadyConfigured, clear out szISPName.
    // We don't want it to wind up as the default name for any new connectoids
    // the user creates.
    //
    gpUserInfo->szISPName[0] = '\0';
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function:    MyRestartDialog
//
//    Synopsis:    Supported RestartDialogEx in Whistler while maintaining
//                  backward compatibility
//
//    Arguments:   hwnd - handle to the owner window
//                  lpPrompt - additional string appear in the restart dialog
//                  dwReturn - restart type, prefixed by EWX_
//                  dwReasonCode - restart code defined in winuserp.h
//
//    Returns:    IDYES or IDNO
//
//    History:    chunhoc 20/01/2001
//
//-----------------------------------------------------------------------------
int WINAPI
MyRestartDialog(HWND hwnd, LPCTSTR lpPrompt,  DWORD dwReturn, DWORD dwReasonCode)
{

typedef int (WINAPI *PFNRestartDialog)(HWND hwnd, LPCTSTR lpPrompt, DWORD dwReturn);
typedef int (WINAPI *PFNRestartDialogEx)(HWND hwnd, LPCTSTR lpPrompt, DWORD dwReturn, DWORD dwReasonCode);

    const int RESTARTDIALOG_ORDINAL = 59;
    const int RESTARTDIALOGEX_ORDINAL = 730;
    
    int retval = IDNO;
    HINSTANCE hShell32 = NULL;

    hShell32 = LoadLibrary(TEXT("shell32.dll"));

    if (hShell32)
    {
        PFNRestartDialogEx pfnRestartDialogEx = NULL;
  
        pfnRestartDialogEx = (PFNRestartDialogEx) GetProcAddress(hShell32, (LPCSTR)(INT_PTR)RESTARTDIALOGEX_ORDINAL);

        if (pfnRestartDialogEx)
        {
            retval = pfnRestartDialogEx(hwnd, lpPrompt, dwReturn, dwReasonCode);
        }
        else
        {
            PFNRestartDialog   pfnRestartDialog = NULL;

            pfnRestartDialog   = (PFNRestartDialog) GetProcAddress(hShell32, (LPCSTR)(INT_PTR)RESTARTDIALOG_ORDINAL);

            if (pfnRestartDialog)
            {
                retval = pfnRestartDialog(hwnd, lpPrompt, dwReturn);                
            }
        }
        FreeLibrary(hShell32);
    }

    return retval;

}

BOOL DeinitWizard(DWORD dwFlags)
{
    // uninitialize RNA and unload it, if loaded
    DeInitRNA();

    // unintialize MAPI and unload it, if loaded
    DeInitMAPI();

    //
    // restart system if necessary, and only if we are not in
    // backup mode -MKarki Bug #404
    //

    // Note: 0x42 is the EW_RESTARTWINDOWS constant, however it is not defined
    // in the NT5 headers.
    if (gfBackedUp == FALSE)
    {
      if (gpWizardState->fNeedReboot && !(dwFlags & RSW_NOREBOOT) )
      {
        if ( g_bRebootAtExit ) 
        {
          MyRestartDialog(
            NULL,
            NULL,
            EW_RESTARTWINDOWS, 
            REASON_PLANNED_FLAG | REASON_SWINSTALL);
        }
      }
    }

    //
    // 7/8/97 jmazner Olympus #9040
    // When we back out of the manual path and into icwconn1, we kill inetcfg's
    // property sheet -- it gets rebuilt if the user re-enters the manual path
    // Because of this, we must unload the Apprentice when we exit, and then
    // reload the Apprentice if we return, so that it can re-add its pages to
    // the newly recreated property sheet.
    //
    //if (!(dwFlags & RSW_NOFREE))
    //{
    //

    if (gfOleInitialized)
        CoUninitialize();
    gfOleInitialized = FALSE;

    if( g_pdwDialogIDList )
    {
        GlobalFree(g_pdwDialogIDList);
        g_pdwDialogIDList = NULL;
    }

    g_fAcctMgrUILoaded = FALSE;

    if( g_pCICWExtension )
    {
        g_pCICWExtension->Release();
        g_pCICWExtension = NULL;
    }

    if (!(dwFlags & RSW_NOFREE))
    {
        RemoveShellNextFromReg();
    }

    return TRUE;
}

/*******************************************************************

  NAME:    RunSignupWizard

  SYNOPSIS:  Creates property sheet pages, initializes wizard
        property sheet and runs wizard

  ENTRY:    dwFlags - RSW_ flags for signup wizard
          RSW_NOREBOOT - inhibit reboot message.  Used if
          we are being run by some setup entity which needs
          to reboot anyway.

            hwndParent - The parent window of the wizard.

  EXIT:    returns TRUE if user runs wizard to completion,
        FALSE if user cancels or an error occurs

  NOTES:    Wizard pages all use one dialog proc (GenDlgProc).
        They may specify their own handler procs to get called
        at init time or in response to Next, Cancel or a dialog
        control, or use the default behavior of GenDlgProc.

********************************************************************/
BOOL RunSignupWizard(DWORD dwFlags, HWND hwndParent /* = NULL */)
{
    HPROPSHEETPAGE hWizPage[NUM_WIZARD_PAGES];  // array to hold handles to pages
    PROPSHEETPAGE psPage;    // struct used to create prop sheet pages
    PROPSHEETHEADER psHeader;  // struct used to run wizard property sheet
    UINT nPageIndex;
    BOOL bUse256ColorBmp = FALSE;
    INT_PTR iRet;
    HRESULT hr;
    HDC hdc;

    if (!InitWizard(dwFlags, hwndParent))
    {
        goto RunSignupWizardExit;
    }

    // Compute the color depth we are running in
    hdc = GetDC(NULL);
    if(hdc)
    {
        if(GetDeviceCaps(hdc,BITSPIXEL) >= 8)
            bUse256ColorBmp = TRUE;
        ReleaseDC(NULL, hdc);
    }

    // zero out structures
    ZeroMemory(&hWizPage,sizeof(hWizPage));   // hWizPage is an array
    ZeroMemory(&psPage,sizeof(PROPSHEETPAGE));
    ZeroMemory(&psHeader,sizeof(PROPSHEETHEADER));

    // fill out common data property sheet page struct
    psPage.dwSize    = sizeof(PROPSHEETPAGE);
    psPage.hInstance = ghInstance;
    psPage.pfnDlgProc = GenDlgProc;

    // create a property sheet page for each page in the wizard
    for (nPageIndex = 0;nPageIndex < NUM_WIZARD_PAGES;nPageIndex++) {
      psPage.dwFlags = PSP_DEFAULT | PSP_HASHELP;
      psPage.pszTemplate = MAKEINTRESOURCE(PageInfo[nPageIndex].uDlgID97);
      // set a pointer to the PAGEINFO struct as the private data for this
      // page
      psPage.lParam = (LPARAM) &PageInfo[nPageIndex];
      if (PageInfo[nPageIndex].nIdTitle)
      {
          psPage.dwFlags |= PSP_USEHEADERTITLE;
          psPage.pszHeaderTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdTitle);
      }
              
      if (PageInfo[nPageIndex].nIdSubTitle)
      {
          psPage.dwFlags |= PSP_USEHEADERSUBTITLE;
          psPage.pszHeaderSubTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdSubTitle);
      }
      
      
      // Exceptions to the use HeaderTitle and Subtitle are the start and end pages
      if ((nPageIndex == ORD_PAGE_HOWTOCONNECT) || (nPageIndex  == ORD_PAGE_CONNECTEDOK))
      {
          psPage.dwFlags &= ~PSP_USEHEADERTITLE;
          psPage.dwFlags &= ~PSP_USEHEADERSUBTITLE;
          psPage.dwFlags |= PSP_HIDEHEADER;
      }
      
      hWizPage[nPageIndex] = CreatePropertySheetPage(&psPage);

      if (!hWizPage[nPageIndex]) {
        DEBUGTRAP("Failed to create property sheet page");

        // creating page failed, free any pages already created and bail
        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
        UINT nFreeIndex;
        for (nFreeIndex=0;nFreeIndex<nPageIndex;nFreeIndex++)
          DestroyPropertySheetPage(hWizPage[nFreeIndex]);

          iRet = 0;
          goto RunSignupWizardExit;
      }
    }

    // fill out property sheet header struct
    psHeader.dwSize = sizeof(psHeader);
    psHeader.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_HASHELP | PSH_WATERMARK | PSH_HEADER | PSH_STRETCHWATERMARK;
    psHeader.hwndParent = hwndParent;
    psHeader.hInstance = ghInstance;
    psHeader.nPages = NUM_WIZARD_PAGES;
    psHeader.phpage = hWizPage;
    psHeader.nStartPage = ORD_PAGE_HOWTOCONNECT;

    gpWizardState->cmnStateData.hbmWatermark = (HBITMAP)LoadImage(ghInstance,
                    bUse256ColorBmp ? MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16),
                    IMAGE_BITMAP,
                    0,
                    0,
                    LR_CREATEDIBSECTION);

    psHeader.pszbmHeader = bUse256ColorBmp?MAKEINTRESOURCE(IDB_BANNER256):MAKEINTRESOURCE(IDB_BANNER16);

    //
    // set state of gpWizardState->fNeedReboot and
    // reset the state of Backup Flag here - MKarki Bug #404
    // 
    if (gfBackedUp == TRUE)
    {
        gpWizardState->fNeedReboot = gfReboot;
        gfBackedUp = FALSE;
    }

    // run the Wizard
    iRet = PropertySheet(&psHeader);

    if (iRet < 0) {
      // property sheet failed, most likely due to lack of memory
      MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
    }

RunSignupWizardExit:
    // Clean up allocated bitmaps that might exist from the branding case
    if (gpWizardState->cmnStateData.hbmWatermark)
        DeleteObject(gpWizardState->cmnStateData.hbmWatermark);
    gpWizardState->cmnStateData.hbmWatermark = NULL;

    // Release of gpImnApprentice is done here instead of in the DeinitWizard
    // because the Release() calls DeinitWizard when we are in ICW mode   
    if (gpImnApprentice)
    {
        gpImnApprentice->Release();  // DeinitWizard is called in Release() 
        gpImnApprentice = NULL;
    }
    if (!g_fIsICW)
    {
        DeinitWizard(dwFlags);    
    }
    return iRet > 0;
}


// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}


// ############################################################################
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight)
{
    HRESULT hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONT* plogfont = NULL;

    if (!hwnd) goto MakeBoldExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    plogfont = (LOGFONT*)malloc(sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MakeBoldExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    if (abs(plogfont->lfHeight) < 24 && fSize)
    {
        plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
    }

    plogfont->lfWeight = (int) lfWeight;

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
    free(plogfont);
    
MakeBoldExit:
    //if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    // The answer is Yes. ChrisK 7/1/96
    return hr;
}

// ############################################################################
HRESULT MakeWizard97Title (HWND hwnd)
{
    HRESULT     hr = ERROR_SUCCESS;
    HFONT       hfont = NULL;
    HFONT       hnewfont = NULL;
    LOGFONT     *plogfont = NULL;
    HDC         hDC;
    
    if (!hwnd) goto MakeWizard97TitleExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    plogfont = (LOGFONT*)malloc(sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MakeWizard97TitleExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    // We want 12 PT Veranda for Wizard 97.
    hDC = GetDC(NULL);
    if(hDC)
    {
        plogfont->lfHeight = -MulDiv(WIZ97_TITLE_FONT_PTS, GetDeviceCaps(hDC, LOGPIXELSY), 72); 
        ReleaseDC(NULL, hDC);
    }        
    plogfont->lfWeight = (int) FW_BOLD;
    
    if (!LoadString(ghInstance, IDS_WIZ97_TITLE_FONT_FACE, plogfont->lfFaceName, LF_FACESIZE))
        lstrcpy(plogfont->lfFaceName, TEXT("Verdana"));

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
    free(plogfont);
    
MakeWizard97TitleExit:
    //if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    // The answer is Yes. ChrisK 7/1/96
    return hr;
}

/*******************************************************************
//
//    Function:    PaintWithPaletteBitmap
//
//    Arguments:   lprc is the target rectangle.
//                 cy is the putative dimensions of hbmpPaint.
//                 If the target rectangle is taller than cy, then 
//                 fill the rest with the pixel in the upper left 
//                 corner of the hbmpPaint.
//
//    Returns:     void
//
//    History:      10-29-98    Vyung    -  Stole from prsht.c
//
********************************************************************/
void PaintWithPaletteBitmap(HDC hdc, LPRECT lprc, int cy, HBITMAP hbmpPaint)
{
    HDC hdcBmp;

    hdcBmp = CreateCompatibleDC(hdc);
    SelectObject(hdcBmp, hbmpPaint);
    BitBlt(hdc, lprc->left, lprc->top, RECTWIDTH(*lprc), cy, hdcBmp, 0, 0, SRCCOPY);

    // StretchBlt does mirroring if you pass a negative height,
    // so do the stretch only if there actually is unpainted space
    if (RECTHEIGHT(*lprc) - cy > 0)
        StretchBlt(hdc, lprc->left, cy,
                   RECTWIDTH(*lprc), RECTHEIGHT(*lprc) - cy,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    DeleteDC(hdcBmp);
}
/*******************************************************************
//
//    Function:    Prsht_EraseWizBkgnd
//
//    Arguments:   Draw the background for wizard pages.
//                 hDlg is dialog handle.
//                 hdc is device context
//
//    Returns:     void
//
//    History:     10-29-98    Vyung   - Stole from prsht.c
//
********************************************************************/
LRESULT Prsht_EraseWizBkgnd(HWND hDlg, HDC hdc)
{
    
    HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    RECT rc;
    GetClientRect(hDlg, &rc);
    FillRect(hdc, &rc, hbrWindow);

    rc.right = BITMAP_WIDTH;
    rc.left = 0;

    PaintWithPaletteBitmap(hdc, &rc, BITMAP_HEIGHT, gpWizardState->cmnStateData.hbmWatermark);

    return TRUE;
}

/*******************************************************************

  NAME:    GenDlgProc

  SYNOPSIS:  Generic dialog proc for all wizard pages

  NOTES:    This dialog proc provides the following default behavior:
          init:    back and next buttons enabled
          next btn:  switches to page following current page
          back btn:  switches to previous page
          cancel btn: prompts user to confirm, and cancels the wizard
          dlg ctrl:   does nothing (in response to WM_COMMANDs)
        Wizard pages can specify their own handler functions
        (in the PageInfo table) to override default behavior for
        any of the above actions.

********************************************************************/
INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  static HCURSOR hcurOld = NULL;
  static BOOL bKilledSysmenu = FALSE;
  PAGEINFO *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);

  switch (uMsg) {
        case WM_ERASEBKGND:
        {
            // Only paint the external page 
            if (!pPageInfo->nIdTitle && !g_fIsICW)
            {
                Prsht_EraseWizBkgnd(hDlg, (HDC) wParam);
                return TRUE;
            }                
            break;
        }
        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        {
            // Only paint the external page and except the ISP sel page
            if (!pPageInfo->nIdTitle && !g_fIsICW)
            {

                HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
                DefWindowProc(hDlg, uMsg, wParam, lParam);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (LRESULT)hbrWindow;
            }
            break;
        }
        
    case WM_INITDIALOG:


        //10/25/96 jmazner Normandy #9132
        if( !bKilledSysmenu && !g_fIsICW )
        {
            // Get the main frame window's style
            LONG window_style = GetWindowLong(GetParent(hDlg), GWL_STYLE);

            //Remove the system menu from the window's style
            window_style &= ~WS_SYSMENU;

            //set the style attribute of the main frame window
            SetWindowLong(GetParent(hDlg), GWL_STYLE, window_style);

            bKilledSysmenu = TRUE;
        }

      {
        // get propsheet page struct passed in
        LPPROPSHEETPAGE lpsp = (LPPROPSHEETPAGE) lParam;
        ASSERT(lpsp);
        // fetch our private page info from propsheet struct
        PAGEINFO * pPageInfo = (PAGEINFO *) lpsp->lParam;
        ASSERT(pPageInfo);

        // store pointer to private page info in window data for later
        SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM) pPageInfo);

        // initialize 'back' and 'next' wizard buttons, if
        // page wants something different it can fix in init proc below
        PropSheet_SetWizButtons(GetParent(hDlg),
          PSWIZB_NEXT | PSWIZB_BACK);

        // Make the title text bold
        if (g_fIsWizard97 ||  g_fIsExternalWizard97)
            MakeWizard97Title(GetDlgItem(hDlg,IDC_LBLTITLE));
        else
            MakeBold(GetDlgItem(hDlg,IDC_LBLTITLE),TRUE,FW_BOLD);

        // call init proc for this page if one is specified
        if (pPageInfo->InitProc)
        {
          if (!( pPageInfo->InitProc(hDlg,TRUE)))
          {
            // If a fatal error occured, quit the wizard.
            // Note: gfQuitWizard is also used to terminate the wizard
            // for non-error reasons, but in that case TRUE is returned
            // from the OK proc and the case is handled below.
            if (gfQuitWizard)
            {
              // Don't reboot if error occured.
              gpWizardState->fNeedReboot = FALSE;

              // send a 'cancel' message to ourselves (to keep the prop.
              // page mgr happy)
              //
              // ...Unless we're serving as an Apprentice.  In which case, let
              // the Wizard decide how to deal with this.

              if( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
              {
                  PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
              }
              else
              {
                  g_pExternalIICWExtension->ExternalCancel( CANCEL_SILENT );
              }
            }
          }
        }

        // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
        // Before we return, lets send another message to ourself so
        // we have a second chance of initializing stuff that the 
        // property sheet wizard doesn't normally let us do.
        PostMessage(hDlg, WM_MYINITDIALOG, 1, lParam);


        return TRUE;
      }
      break;  // WM_INITDIALOG

    // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
    case WM_MYINITDIALOG:
    {
        PAGEINFO * pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
        ASSERT(pPageInfo);

        // wParam tells whether this is the first initialization or not
        MiscInitProc(hDlg, (int)wParam, pPageInfo->uDlgID);
        return TRUE;
    }


    case WM_DESTROY:
        ReleaseBold(GetDlgItem(hDlg,IDC_LBLTITLE));
        // 12/18/96 jmazner Normandy #12923
        // bKilledSysmenu is static, so even if the window is killed and reopened later
        // (as happens when user starts in conn1, goes into man path, backs up
        //  to conn1, and then returns to man path), the value of bKilledSysmenu is preserved.
        // So when the window is about to die, set it to FALSE, so that on the next window
        // init we go through and kill the sysmenu again.
        bKilledSysmenu = FALSE;
        break;

    case WM_HELP:
    {
        if (!g_fIsICW)
        {
            DWORD dwData = ICW_OVERVIEW;
            if (pPageInfo->dwHelpID)
                dwData = pPageInfo->dwHelpID;
            WinHelp(hDlg,TEXT("connect.hlp>proc4"),HELP_CONTEXT, dwData);
        }
        break;
    }

    case WM_NOTIFY:
    {
        // get pointer to private page data out of window data
        PAGEINFO * pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
        ASSERT(pPageInfo);
        BOOL fRet,fKeepHistory=TRUE;
        NMHDR * lpnm = (NMHDR *) lParam;
#define NEXTPAGEUNITIALIZED -1
        int iNextPage = NEXTPAGEUNITIALIZED;
        switch (lpnm->code) {
          case PSN_SETACTIVE:
            // If a fatal error occured in first call to init proc
            // from WM_INITDIALOG, don't call init proc again.
            if (FALSE == gfQuitWizard)
            {
              // initialize 'back' and 'next' wizard buttons, if
              // page wants something different it can fix in init proc below
              PropSheet_SetWizButtons(GetParent(hDlg),
                PSWIZB_NEXT | PSWIZB_BACK);

            if (g_fIsICW && (pPageInfo->uDlgID == IDD_PAGE_HOWTOCONNECT))
            {
                iNextPage = g_uExternUIPrev;
                return TRUE;
            }

              // call init proc for this page if one is specified
              if (pPageInfo->InitProc)
              {
                pPageInfo->InitProc(hDlg,FALSE);
              }
            }

            // If we set the wait cursor, set the cursor back
            if (hcurOld)
            {
                SetCursor(hcurOld);
                hcurOld = NULL;
            }

            PostMessage(hDlg, WM_MYINITDIALOG, 0, lParam);


            return TRUE;
            break;

          case PSN_WIZNEXT:
          case PSN_WIZBACK:
          case PSN_WIZFINISH:
            // Change cursor to an hour glass
            hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

            // call OK proc for this page if one is specified
            if (pPageInfo->OKProc) 
              if (!pPageInfo->OKProc(hDlg,(lpnm->code != PSN_WIZBACK),
                (UINT*)&iNextPage,&fKeepHistory))
              {
                // If a fatal error occured, quit the wizard.
                // Note: gfQuitWizard is also used to terminate the wizard
                // for non-error reasons, but in that case TRUE is returned
                // from the OK proc and the case is handled below.
                if (gfQuitWizard)
                {
                  // Don't reboot if error occured.
                  gpWizardState->fNeedReboot = FALSE;

                  // send a 'cancel' message to ourselves (to keep the prop.
                  // page mgr happy)
                  //
                  // ...Unless we're serving as an Apprentice.  In which case, let
                  // the Wizard decide how to deal with this.

                  if( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
                  {
                      PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                  }
                  else
                  {
                      g_pExternalIICWExtension->ExternalCancel( CANCEL_SILENT );
                  }
                }

                // stay on this page
                SetPropSheetResult(hDlg,-1);
                return TRUE;
              }

            if (lpnm->code != PSN_WIZBACK) {
              // 'next' pressed
              ASSERT(gpWizardState->uPagesCompleted <
                NUM_WIZARD_PAGES);

              // save the current page index in the page history,
              // unless this page told us not to when we called
              // its OK proc above
              if (fKeepHistory) {
                gpWizardState->uPageHistory[gpWizardState->
                  uPagesCompleted] = gpWizardState->uCurrentPage;
                DEBUGMSG("propmgr: added page %d (IDD %d) to history list",
                    gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
                gpWizardState->uPagesCompleted++;
              }
              else
              {
                  DEBUGMSG("propmgr: not adding %d (IDD: %d) to the history list",
                      gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
              }


              // if no next page specified or no OK proc,
              // advance page by one
              if (0 > iNextPage)
                iNextPage = gpWizardState->uCurrentPage + 1;

            }
            else
            {
              if (( NEXTPAGEUNITIALIZED == iNextPage ) && (gpWizardState->uPagesCompleted > 0))
              {
                  // get the last page from the history list
                  gpWizardState->uPagesCompleted --;
                  iNextPage = gpWizardState->uPageHistory[gpWizardState->
                    uPagesCompleted];
                  DEBUGMSG("propmgr: extracting page %d (IDD %d) from history list",
                      iNextPage, GetDlgIDFromIndex(iNextPage));
              }
              else
              {
                  // 'back' pressed
                  switch( gpWizardState->uCurrentPage )
                  {
                    //case IDD_PAGE_CONNECTEDOK:  We should only use IDDs for external pages
                    case ORD_PAGE_HOWTOCONNECT:
                        if(( gpWizardState->dwRunFlags & RSW_APPRENTICE ) || g_fIsICW)
                        {
                            // we need to back out of the connection apprentice
                            iNextPage = g_uExternUIPrev;
                            DEBUGMSG("propmgr: backing into AcctMgr Wizard page IDD %d", g_uExternUIPrev);
                        }
                        break;
                    case ORD_PAGE_CONNECTEDOK:
                        if( g_fAcctMgrUILoaded )
                        {
                            // we need to back into the account apprentice
                            iNextPage = g_uAcctMgrUILast;
                            DEBUGMSG("propmgr: backing into AcctMgr UI page IDD %d", g_uAcctMgrUILast);
                        }
                        break;
                    case ORD_PAGE_USEPROXY:
                    case ORD_PAGE_CHOOSEMODEM:
                    case ORD_PAGE_CONNECTION:
                    case ORD_PAGE_PHONENUMBER:
                    case ORD_PAGE_SETUP_PROXY:
                        if (g_fIsICW )
                        {
                            // we need to back out of the connection apprentice
                            iNextPage = g_uExternUIPrev;
                            DEBUGMSG("propmgr: backing into AcctMgr Wizard page IDD %d", g_uExternUIPrev);
                        }
                        break;
                  }
              }


            }

            // if we need to exit the wizard now (e.g. launching
            // signup app and want to terminate the wizard), send
            // a 'cancel' message to ourselves (to keep the prop.
            // page mgr happy)
            if (gfQuitWizard) {
   
              //
              // if we are going from manual to conn1 then
              // then do not show the  REBOOT dialog but
              // still preserve the gpWizardState -MKarki Bug #404
              //
              if (lpnm->code ==  PSN_WIZBACK)
              {
                 gfBackedUp = TRUE;
                 gfReboot = gpWizardState->fNeedReboot;
              }

              // send a 'cancel' message to ourselves (to keep the prop.
              // page mgr happy)
              //
              // ...Unless we're serving as an Apprentice.  In which case, let
              // the Wizard decide how to deal with this.

              if( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
              {
                  PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
              }
              else
              {
                  //
                  // 5/27/97 jmazner Olympus #1134 and IE #32717
                  //
                  if( gpWizardState->fNeedReboot )
                  {
                      g_pExternalIICWExtension->ExternalCancel( CANCEL_REBOOT );
                  }
                  else
                  {
                      g_pExternalIICWExtension->ExternalCancel( CANCEL_SILENT );
                  }
              }

              SetPropSheetResult(hDlg,-1);
              return TRUE;
            }

            // set next page, only if 'next' or 'back' button
            // was pressed
            if (lpnm->code != PSN_WIZFINISH) {

              // set the next current page index
              gpWizardState->uCurrentPage = iNextPage;
              DEBUGMSG("propmgr: going to page %d (IDD %d)", iNextPage, GetDlgIDFromIndex(iNextPage));

              // tell the prop sheet mgr what the next page to
              // display is
              SetPropSheetResult(hDlg,GetDlgIDFromIndex(iNextPage));
              return TRUE;
            }
            else
            {
                //
                // Sanity check: there should be no way that our Apprentice
                // would ever reach this state, since the Apprentice always
                // defers cancels to the main wizard.
                //
                ASSERT(!(gpWizardState->dwRunFlags & RSW_APPRENTICE));
                //
                // run shellnext if it's there
                //
                // 8/12/97    jmazner    Olympus #12419
                // don't shell next if we're about to reboot anyways
                //
                TCHAR szCommand[MAX_PATH + 1] = TEXT("\0");
                TCHAR szParams[MAX_PATH + 1] = TEXT("\0");
                DWORD dwStrLen = MAX_PATH + 1;
                if( !(gpWizardState->fNeedReboot) && GetShellNextFromReg( szCommand, szParams, dwStrLen ) )
                {
                    ShellExecute(NULL,TEXT("open"),szCommand,szParams,NULL,SW_NORMAL);
                }
            }

            break;

            case PSN_HELP:
            {

#if defined(WIN16)
                DWORD dwData = 1000;
                WinHelp(hDlg,TEXT("connect.hlp"),HELP_CONTEXT, dwData);
#else
                // Normandy 12278 ChrisK 12/4/96
                DWORD dwData = ICW_OVERVIEW;
                if (pPageInfo->dwHelpID)
                    dwData = pPageInfo->dwHelpID;
                WinHelp(hDlg,TEXT("connect.hlp>proc4"),HELP_CONTEXT, dwData);
#endif
                break;
            }



          case PSN_QUERYCANCEL:

            // if global flag to exit is set, then this cancel
            // is us pretending to push 'cancel' so prop page mgr
            // will kill the wizard.  Let this through...
            if (gfQuitWizard) {
              SetWindowLongPtr(hDlg,DWLP_MSGRESULT,FALSE);
              return TRUE;
            }

            // if this page has a special cancel proc, call it
            if (pPageInfo->CancelProc)
              fRet = pPageInfo->CancelProc(hDlg);
            else {
              // default behavior: pop up a message box confirming
              // the cancel...
              // ... unless we're serving as an Apprentice, in which case
              // we should let the Wizard handle things
              if( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
              {
                  fRet = (MsgBox(hDlg,IDS_QUERYCANCEL,
                    MB_ICONQUESTION,MB_YESNO |
                    MB_DEFBUTTON2) == IDYES);
                  gfUserCancelled = fRet;
              }
              else
              {
                 gfUserCancelled = g_pExternalIICWExtension->ExternalCancel( CANCEL_PROMPT );
                 fRet = gfUserCancelled;
              }

            }

            // don't reboot if cancelling
            gpWizardState->fNeedReboot = FALSE;

            // return the value thru window data
            SetWindowLongPtr(hDlg,DWLP_MSGRESULT,!fRet);
            return TRUE;
            break;
        }
      }
      break;

    case WM_COMMAND:
      {
        // get pointer to private page data out of window data
        PAGEINFO * pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
        ASSERT(pPageInfo);

        // if this page has a command handler proc, call it
        if (pPageInfo->CmdProc) {
          pPageInfo->CmdProc(hDlg, wParam, lParam);
        }
      }

  }

  return FALSE;
}


/*******************************************************************

  NAME:    InitWizardState

  SYNOPSIS:  Initializes wizard state structure

********************************************************************/
VOID InitWizardState(WIZARDSTATE * pWizardState, DWORD dwFlags)
{
  ASSERT(pWizardState);

  // zero out structure
  ZeroMemory(pWizardState,sizeof(WIZARDSTATE));

  // set starting page
  pWizardState->uCurrentPage = ORD_PAGE_HOWTOCONNECT;

  pWizardState->fNeedReboot = FALSE;
}


/*******************************************************************

  NAME:    InitUserInfo

  SYNOPSIS:  Initializes user data structure

********************************************************************/
VOID InitUserInfo(USERINFO * pUserInfo)
{
  ASSERT(pUserInfo);

  // zero out structure
  ZeroMemory(pUserInfo,sizeof(USERINFO));

  // Set default to modem, even  though we haven't enumerated devices
  pUserInfo->uiConnectionType = CONNECT_RAS;

  // if there's a logged-on user, use that username as the default
  GetDefaultUserName(pUserInfo->szAccountName,
    sizeof(pUserInfo->szAccountName));

  // look in registry for settings left from previous installs
  // get modem/LAN preference from before, if there is one
  RegEntry re(szRegPathInternetSettings,HKEY_LOCAL_MACHINE);

  DWORD dwVal = re.GetNumber(szRegValAccessMedium,0);
  if (dwVal > 0) {
    pUserInfo->fPrevInstallFound = TRUE;
  }
  if (dwVal == USERPREF_LAN) {
    pUserInfo->uiConnectionType = CONNECT_LAN;
  } else if (dwVal == USERPREF_MODEM) {
    pUserInfo->uiConnectionType = CONNECT_RAS;
  }

  // get name of existing Internet connectoid, if there is one
  //  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
  BOOL  fTemp;
  DWORD dwRet = InetGetAutodial(&fTemp, pUserInfo->szISPName,
    sizeof(pUserInfo->szISPName));
  if ((ERROR_SUCCESS == dwRet) && lstrlen(pUserInfo->szISPName))
  {
    pUserInfo->fPrevInstallFound = TRUE;
  }

  pUserInfo->fNewConnection = TRUE;
  pUserInfo->fModifyConnection = FALSE;
  pUserInfo->fModifyAdvanced = FALSE;
  pUserInfo->fAutoDNS = TRUE;
}

/*******************************************************************

  NAME:    InitIMNApprentice

  SYNOPSIS:  Initializes global variables needed to add mail, news
             and LDAP account wizard pages from the Athena Acct Manager.

********************************************************************/
VOID InitIMNApprentice()
{
    HRESULT        hr;

    // Load the Account Manager OLE in-proc server
    if (!CheckOEVersion())
        return;

    hr = CoCreateInstance(CLSID_ApprenticeAcctMgr,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWApprentice,(LPVOID *)&gpImnApprentice);

    if ( !(SUCCEEDED(hr) && gpImnApprentice) )
    {
        g_fAcctMgrUILoaded = FALSE;
        DEBUGMSG("Unable to CoCreateInstance on IID_IICWApprentice!  hr = %x", hr);
    }
}


/*******************************************************************

  NAME:    InitLDAP

  SYNOPSIS:  Initializes global variables for LDAP options.

********************************************************************/
/**
VOID InitLDAP()
{
    TCHAR        szBuf[MAX_PATH+1];
    DWORD        size;
    HKEY        hKey;
    HRESULT        hr;

    // If we came in through the CreateDirService entry point, we
    // want to clear out the mail and news flags.
    if (gpWizardState->dwRunFlags & RSW_DIRSERVACCT)
    {
        gfGetNewsInfo = FALSE;
        gfGetMailInfo = FALSE;
        gpUserInfo->inc.dwFlags &= ~INETC_LOGONMAIL;
        gpUserInfo->inc.dwFlags &= ~INETC_LOGONNEWS;    
    }

    // Load the Internet Mail/News account configuration OLE in-proc server
    // if nobody else has already done so.


    gfGetLDAPInfo = FALSE;
    if( !gpImnAcctMgr )
    {
        hr = CoCreateInstance(CLSID_ImnAccountManager,NULL,CLSCTX_INPROC_SERVER,
                              IID_IImnAccountManager,(LPVOID *)&gpImnAcctMgr);
        if (SUCCEEDED(hr) && gpImnAcctMgr)
        {
            hr = gpImnAcctMgr->Init(NULL, NULL);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Get a list of the LDAP accounts
        hr = gpImnAcctMgr->Enumerate(SRV_LDAP,&gpLDAPAccts);
        // Only continue if there were no fatal errors
        if ( !( FAILED(hr) && (E_NoAccounts!=hr) ) )
            gfGetLDAPInfo = TRUE;
    }

    if (!gfGetLDAPInfo && !gfGetMailInfo && !gfGetNewsInfo && gpImnAcctMgr)
    {
        gpImnAcctMgr->Release();
        gpImnAcctMgr = NULL;
    }

    // If we have been given defaults, get those
    if (gpDirServiceInfo && gfUseDirServiceDefaults)
    {
        ASSERT(sizeof(*gpDirServiceInfo) == gpDirServiceInfo->dwSize);
        
        if (gpDirServiceInfo->szServiceName)
            lstrcpy(gpUserInfo->szDirServiceName, gpDirServiceInfo->szServiceName);
        if (gpDirServiceInfo->szLDAPServer)
            lstrcpy(gpUserInfo->inc.szLDAPServer, gpDirServiceInfo->szLDAPServer);
        gpUserInfo->inc.fLDAPResolve = gpDirServiceInfo->fLDAPResolve;
            
        if (gpDirServiceInfo->fUseSicily)
        {
            // 12/17/96 jmazner Normandy 12871
            //gpUserInfo->fNewsAccount = FALSE;
            gpUserInfo->inc.fLDAPLogonSPA = TRUE;
        }
        // 3/24/97 jmazner Olympus #2052
        else if (gpDirServiceInfo->szUserName && gpDirServiceInfo->szUserName[0])
        {
            lstrcpy(gpUserInfo->inc.szLDAPLogonName, gpDirServiceInfo->szUserName);
            if (gpMailNewsInfo->szPassword)
                lstrcpy(gpUserInfo->inc.szLDAPLogonPassword, gpDirServiceInfo->szPassword);
        }
        else
        {
            gpUserInfo->fLDAPLogon = FALSE;
        }

    }
    else
    {
        // let's make up our own defaults
        gpUserInfo->inc.fLDAPResolve = TRUE;
        gpUserInfo->fLDAPLogon = FALSE;
        gpUserInfo->inc.fLDAPLogonSPA = FALSE;
    }

}
**/

/*******************************************************************

  NAME:    GetDefaultUserName

  SYNOPSIS:  Gets user's login name if there is one (if network or
        user profiles are installed), otherwise sets
        user name to null string.

********************************************************************/
VOID GetDefaultUserName(TCHAR * pszUserName,DWORD cbUserName)
{
  ASSERT(pszUserName);
  *pszUserName = '\0';

  WNetGetUser(NULL,pszUserName,&cbUserName);
}

/*******************************************************************

  NAME:    GetDlgIDFromIndex

  SYNOPSIS:  For a given zero-based page index, returns the
        corresponding dialog ID for the page

  4/24/97    jmazner    When dealing with apprentice pages, we may call
                    this function with dialog IDs (IDD_PAGE_*), rather
                    than an index (ORD_PAGE*).  Added code to check
                    whether the number passed in is an index or dlgID.

********************************************************************/
UINT GetDlgIDFromIndex(UINT uPageIndex)
{
  if( uPageIndex <= MAX_PAGE_INDEX )
  {
    ASSERT(uPageIndex < NUM_WIZARD_PAGES);

    if (g_fIsWizard97)
        return PageInfo[uPageIndex].uDlgID97;
    else if(g_fIsExternalWizard97)
        return PageInfo[uPageIndex].uDlgID97External;
    else
        return PageInfo[uPageIndex].uDlgID;
  }
  else
  {
    return(uPageIndex);
  }
}


/*******************************************************************

  NAME:    SystemAlreadyConfigured

  SYNOPSIS:  Determines if the system is configured for Internet
        or not

  EXIT:    returns TRUE if configured, FALSE if more
        configuration is necessary

********************************************************************/
BOOL SystemAlreadyConfigured(USERINFO * pUserInfo)
{
  BOOL fRet = FALSE;  // assume not configured
  BOOL  fNeedSysComponents = FALSE;
  DWORD dwfInstallOptions = 0;
  
  if ( CONNECT_RAS == pUserInfo->uiConnectionType )
  {
    // If connecting over modem, we need TCP/IP and RNA.
    dwfInstallOptions = ICFG_INSTALLTCP | ICFG_INSTALLRAS;
  }

  // already configured if:
  //   - previous install was detected, and
  //   - we do not need any drivers or files based on existing config &
  // user preference, and
  //   - there is already an internet connectoid established (something
  //     is set for szISPName) or user has LAN for Internet access

  HRESULT hr = lpIcfgNeedInetComponents(dwfInstallOptions, &fNeedSysComponents);
  if (ERROR_SUCCESS != hr)
  {
    TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");
    
    // Get the text of the error message and display it.
    if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
    {
      MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
    }

    return FALSE;
  }

  if ( pUserInfo->fPrevInstallFound && !fNeedSysComponents &&
       (pUserInfo->szISPName[0] || (CONNECT_LAN==pUserInfo->uiConnectionType)) )
  {

    fRet = TRUE;
  }

  return fRet;
}


//-----------------------------------------------------------------------------
//  Function    MiscInitProc
//
//    Synopsis    Our generic dialog proc calls this in case any of the wizard
//                dialogs have to do any sneaky stuff.
//
//    Arguments:    hDlg - dialog window
//                fFirstInit - TRUE if this is the first time the dialog
//                    is initialized, FALSE if this InitProc has been called
//                    before (e.g. went past this page and backed up)
//
//    Returns:    TRUE
// 
//    History:    10/28/96    ValdonB    Created
//                11/25/96    Jmazner    copied from icwconn1\psheet.cpp
//                            Normandy #10586
//
//-----------------------------------------------------------------------------
BOOL CALLBACK MiscInitProc(HWND hDlg, BOOL fFirstInit, UINT uDlgID)
{
    switch( uDlgID )
    {
        case IDD_PAGE_PHONENUMBER:
        case IDD_PAGE_PHONENUMBER97:
            SetFocus(GetDlgItem(hDlg,IDC_PHONENUMBER));
            SendMessage(GetDlgItem(hDlg, IDC_PHONENUMBER),
                    EM_SETSEL,
                    (WPARAM) 0,
#ifdef WIN16
                    MAKELPARAM(0,-1));
#else
                    (LPARAM) -1);
#endif
            break;
    }


    return TRUE;
}


//+----------------------------------------------------------------------------
//
//    Function    AllocDialogIDList
//
//    Synopsis    Allocates memory for the g_pdwDialogIDList variable large enough
//                to maintain 1 bit for every valid external dialog ID
//
//    Arguments    None
//
//    Returns        TRUE if allocation succeeds
//                FALSE otherwise
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL AllocDialogIDList( void )
{
    ASSERT( NULL == g_pdwDialogIDList );
    if( g_pdwDialogIDList )
    {
        DEBUGMSG("AllocDialogIDList called with non-null g_pdwDialogIDList!");
        return FALSE;
    }

    // determine maximum number of external dialogs we need to track
    UINT uNumExternDlgs = EXTERNAL_DIALOGID_MAXIMUM - EXTERNAL_DIALOGID_MINIMUM + 1;

    // we're going to need one bit for each dialogID.
    // Find out how many DWORDS it'll take to get this many bits.
    UINT uNumDWORDsNeeded = (uNumExternDlgs / ( 8 * sizeof(DWORD) )) + 1;

    // set global var with length of the array
    g_dwDialogIDListSize = uNumDWORDsNeeded;

    g_pdwDialogIDList = (DWORD *) GlobalAlloc(GPTR, uNumDWORDsNeeded * sizeof(DWORD));

    if( !g_pdwDialogIDList )
    {
        DEBUGMSG("AllocDialogIDList unable to allocate space for g_pdwDialogIDList!");
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function    DialogIDAlreadyInUse
//
//    Synopsis    Checks whether a given dialog ID is marked as in use in the
//                global array pointed to by g_pdwDialogIDList
//
//    Arguments    uDlgID -- Dialog ID to check
//
//    Returns        TRUE if    -- DialogID is out of range defined by EXTERNAL_DIALOGID_*
//                        -- DialogID is marked as in use
//                FALSE if DialogID is not marked as in use
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL DialogIDAlreadyInUse( UINT uDlgID )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        DEBUGMSG("DialogIDAlreadyInUse received an out of range DialogID, %d", uDlgID);
        return TRUE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERTSZ( (baseIndex < g_dwDialogIDListSize), "ASSERT Failed: baseIndex < g_dwDialogIDListSize");

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;

    BOOL fBitSet = g_pdwDialogIDList[baseIndex] & (dwBitMask);

    //DEBUGMSG("DialogIDAlreadyInUse: ID %d is %s%s", uDlgID, (fBitSet)?"":"_not_ ", "already in use.");

    return( fBitSet );
}

//+----------------------------------------------------------------------------
//
//    Function    SetDialogIDInUse
//
//    Synopsis    Sets or clears the in use bit for a given DialogID
//
//    Arguments    uDlgID -- Dialog ID for which to change status
//                fInUse -- New value for the in use bit.
//
//    Returns        TRUE if status change succeeded.
//                FALSE if DialogID is out of range defined by EXTERNAL_DIALOGID_*
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        DEBUGMSG("SetDialogIDInUse received an out of range DialogID, %d", uDlgID);
        return FALSE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERTSZ( (baseIndex < g_dwDialogIDListSize), "ASSERT Failed: baseIndex < g_dwDialogIDListSize");

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;


    if( fInUse )
    {
        g_pdwDialogIDList[baseIndex] |= (dwBitMask);
        //DEBUGMSG("SetDialogIDInUse: DialogID %d now marked as in use", uDlgID);
    }
    else
    {
        g_pdwDialogIDList[baseIndex] &= ~(dwBitMask);
        //DEBUGMSG("SetDialogIDInUse: DialogID %d now marked as not in use", uDlgID);
    }


    return TRUE;
}


//+---------------------------------------------------------------------------
//
//    Function:    ProcessDBCS
//
//    Synopsis:    Converts control to use DBCS compatible font
//                Use this at the beginning of the dialog procedure
//    
//                Note that this is required due to a bug in Win95-J that prevents
//                it from properly mapping MS Shell Dlg.  This hack is not needed
//                under winNT.
//
//    Arguments:    hwnd - Window handle of the dialog
//                cltID - ID of the control you want changed.
//
//    Returns:    ERROR_SUCCESS
// 
//    History:    4/31/97 a-frankh    Created
//                5/13/97    jmazner        Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
#if defined(WIN16)
    return;
#else
    HFONT hFont = NULL;

    if( IsNT() )
    {
        return;
    }

    hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
    if (hFont == NULL)
        hFont = (HFONT) GetStockObject(SYSTEM_FONT);
    if (hFont != NULL)
        SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
#endif
}


//+---------------------------------------------------------------------------
//
//    Function:    IsSBCSString
//
//    Synopsis:    Walks through a string looking for DBCS characters
//
//    Arguments:    sz -- the string to check
//
//    Returns:    TRUE if no DBCS characters are found
//                FALSE otherwise
// 
//    History:    5/17/97    jmazner        Stole from conn1 to use here
//                                    (Olympus #137)
//----------------------------------------------------------------------------

#if !defined(WIN16)
BOOL IsSBCSString( TCHAR *sz )
{
    ASSERT(sz);

#ifdef UNICODE
    // Check if the string contains only ASCII chars.
    int attrib = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
    // We need to count the NULL terminator in the second parameter because
    // 1. IsTextUnicode takes all the data into account, including the NULL
    // 2. IsTextUnicode interprets unicode string of length 1 as ascii string
    //    terminated by ascii null, e.g. L"1" is regarded as "1\0".
    return (BOOL)IsTextUnicode(sz, (1 + lstrlen(sz))*sizeof(TCHAR) , &attrib);
#else
    while( NULL != *sz )
    {
         if (IsDBCSLeadByte(*sz)) return FALSE;

         sz++;
    }

    return TRUE;
#endif
}
#endif

//+----------------------------------------------------------------------------
//
//    Function:    GetShellNextFromReg
//
//    Synopsis:    Reads the ShellNext key from the registry, and then parses it
//                into a command and parameter.  This key is set by
//                SetShellNext in inetcfg.dll in conjunction with
//                CheckConnectionWizard.
//
//    Arguments:    none
//
//    Returns:    none
//
//    History:    jmazner 7/9/97 Olympus #9170
//
//-----------------------------------------------------------------------------

BOOL GetShellNextFromReg( LPTSTR lpszCommand, LPTSTR lpszParams, DWORD dwStrLen )
{
    BOOL fRet = TRUE;
    LPTSTR lpszShellNextCmd = NULL;
    LPTSTR lpszTemp = NULL;
    DWORD dwShellNextSize = dwStrLen * sizeof(TCHAR);

    ASSERT( (MAX_PATH + 1) == dwStrLen );
    ASSERT( lpszCommand && lpszParams );

    if( !lpszCommand || !lpszParams )
    {
        return FALSE;
    }

    RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);
    

    DWORD dwResult = re.GetError();
    if (ERROR_SUCCESS == dwResult)
    {
        lpszShellNextCmd = (LPTSTR)GlobalAlloc(GPTR, dwShellNextSize);
        ZeroMemory( lpszShellNextCmd, dwShellNextSize );
        if( re.GetString(szRegValShellNext, lpszShellNextCmd, dwShellNextSize) )
        {
            DEBUGMSG("GetShellNextFromReg read ShellNext = %s", lpszShellNextCmd);
        }
        else
        {
            DEBUGMSG("GetShellNextFromReg couldn't read a ShellNext value.");
            fRet = FALSE;
            goto GetShellNextFromRegExit;
        }
    }
    else
    {
        DEBUGMSG("GetShellNextFromReg couldn't open the %s reg key.", szRegPathICWSettings);
        fRet = FALSE;
        goto GetShellNextFromRegExit;
    }

    //
    // This call will parse the first token into lpszCommand, and set szShellNextCmd
    // to point to the remaining tokens (these will be the parameters).  Need to use
    // the pszTemp var because GetCmdLineToken changes the pointer's value, and we
    // need to preserve lpszShellNextCmd's value so that we can GlobalFree it later.
    //
    lpszTemp = lpszShellNextCmd;
    GetCmdLineToken( &lpszTemp, lpszCommand );

    lstrcpy( lpszParams, lpszTemp );

    //
    // it's possible that the shellNext command was wrapped in quotes for
    // parsing purposes.  But since ShellExec doesn't understand quotes,
    // we now need to remove them.
    //
    if( '"' == lpszCommand[0] )
    {
        //
        // get rid of the first quote
        // note that we're shifting the entire string beyond the first quote
        // plus the terminating NULL down by one byte.
        //
        memmove( lpszCommand, &(lpszCommand[1]), lstrlen(lpszCommand) );

        //
        // now get rid of the last quote
        //
        lpszCommand[lstrlen(lpszCommand) - 1] = '\0';
    }


    DEBUGMSG("GetShellNextFromReg got cmd = %s, params = %s",
        lpszCommand, lpszParams);

GetShellNextFromRegExit:

    if( lpszShellNextCmd )
    {
        GlobalFree( lpszShellNextCmd );
        lpszShellNextCmd = NULL;
        lpszTemp = NULL;
    }

    return fRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RemoveShellNextFromReg
//
//    Synopsis:    deletes the ShellNext reg key if present. This key is set by
//                SetShellNext in inetcfg.dll in conjunction with
//                CheckConnectionWizard.
//
//    Arguments:    none
//
//    Returns:    none
//
//    History:    jmazner 7/9/97 Olympus #9170
//
//-----------------------------------------------------------------------------
void RemoveShellNextFromReg( void )
{
    RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);

    DWORD dwResult = re.GetError();
    if (ERROR_SUCCESS == dwResult)
    {
        DEBUGMSG("RemoveShellNextFromReg");
        re.DeleteValue(szRegValShellNext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\inetcfg;$(WINDOWS_INC_PATH);

MAJORCOMP=GETCONN
MINORCOMP=INETCFG

CHICAGO_PRODUCT=1

TARGETNAME=INETCFG
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=DllEntryPoint
DLLBASE=0x60000000
!if $(386)
!if defined(NOT_UNICODE)
DLLDEF=..\inetcfg.def
!else
DLLDEF=..\inetcfg2.def
!endif
!else
!if defined(NOT_UNICODE)
DLLDEF=..\inetrisc.def
!else
DLLDEF=..\inetris2.def
!endif
!endif

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1
C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

BROWSER_INFO="yes"

# Make sure this is built before we continue
SYNCHRONIZE_BLOCK = 1

SOURCES= \
    ..\wizard.rc       \
    ..\callout.cpp     \
    ..\clsutil.cpp     \
    ..\endui.cpp       \
    ..\export.cpp      \
    ..\factory.cpp     \
    ..\icfgcall.cpp    \
    ..\iclient.cpp     \
    ..\icwaprtc.cpp    \
    ..\icwextsn.cpp    \
    ..\ienews.cpp      \
    ..\imnext.cpp      \
    ..\inetapi.cpp     \
    ..\init.cpp        \
    ..\introui.cpp     \
    ..\ispupgui.cpp    \
    ..\mailui.cpp      \
    ..\mapicall.cpp    \
    ..\propmgr.cpp     \
    ..\registry.cpp    \
    ..\rnacall.cpp     \
    ..\strings.cpp     \
    ..\tcpcfg.cpp      \
    ..\tcpui.cpp       \
    ..\uninstal.cpp    \
    ..\util.cpp        \
    ..\wizdll.cpp

# for DOJ compliance, don't link to shell32p.lib

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\mpr.lib           \
    $(SDK_LIB_PATH)\ole32.lib         \
    $(SDK_LIB_PATH)\uuid.lib          \
    $(SDK_LIB_PATH)\version.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\wizard.h
PRECOMPILED_PCH=wizard.pch
PRECOMPILED_OBJ=wizard.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\rnacall.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  RNACALL.H - header file for RNA functions 
//

//  HISTORY:
//  
//  1/20/95   jeremys Created (mostly cloned from RNA UI code)
//  96/01/31  markdu  Renamed CONNENTDLG to OLDCONNENTDLG to avoid
//            conflicts with RNAP.H.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the definition of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also removed RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the definition of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/02/26  markdu  Replaced all remaining internal RNA APIs.
//            Also copied two structures (tagPhoneNum and tapIPData)
//            from rnap.h and tagIAddr from rnaphint.h for internal use only.
//  96/03/07  markdu  Extend ENUM_MODEM class
//  96/03/08  markdu  Added ENUM_MODEM::VerifyDeviceNameAndType
//  96/03/09  markdu  Moved all function prototypes here from wizard.h
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//            Also no longer need GetConnectoidPhoneNumber function.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//            Moved tagPhoneNum to inetapi.h
//  96/03/11  markdu  Moved code to set username and password out of
//            CreateConnectoid into SetConnectoidUsername so it can be reused.
//  96/03/13  markdu  Change ValidateConncectoidName to take LPCSTR.
//  96/03/16  markdu  Added ReInit member function to re-enumerate modems.
//  96/03/25  markdu  Removed GetIPInfo and SetIPInfo.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid,
//            ValidateConnectoidName, and SetConnectoidUsername.
//  96/05/16  markdu  NASH BUG 21810 Added function for IP address validation.
//

#ifndef _RNACALL_H_
#define _RNACALL_H_

// function pointer typedefs for RNA apis from rnaph.dll and rasapi32.dll
typedef DWORD       (WINAPI * RASGETCOUNTRYINFO) (LPRASCTRYINFO, LPDWORD);
typedef DWORD       (WINAPI * RASENUMDEVICES) (LPRASDEVINFO, LPDWORD, LPDWORD);
typedef DWORD       (WINAPI * RASVALIDATEENTRYNAME) (LPCTSTR, LPTSTR);
typedef DWORD       (WINAPI * RASGETERRORSTRING) (UINT, LPTSTR, DWORD);
typedef DWORD       (WINAPI * RASGETENTRYDIALPARAMS) (LPCTSTR, LPRASDIALPARAMS, LPBOOL);
typedef DWORD       (WINAPI * RASSETENTRYDIALPARAMS) (LPCTSTR, LPRASDIALPARAMS, BOOL);
typedef DWORD       (WINAPI * RASSETENTRYPROPERTIES) (LPCTSTR, LPCTSTR, LPBYTE, DWORD, LPBYTE, DWORD);
typedef DWORD       (WINAPI * RASGETENTRYPROPERTIES) (LPTSTR, LPCTSTR, LPBYTE, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD       (WINAPI * RASENUMENTRIES) (LPTSTR,LPTSTR,LPRASENTRYNAME,LPDWORD,LPDWORD);
typedef DWORD       (WINAPI * RASSETCREDENTIALS) (LPTSTR,LPTSTR,LPRASCREDENTIALS,BOOL);

typedef struct  tagCountryCode
{
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
}   COUNTRYCODE, *PCOUNTRYCODE, FAR* LPCOUNTRYCODE;

// Taken from rnap.h
typedef struct tagIPData   {
    DWORD     dwSize;
    DWORD     fdwTCPIP;
    DWORD     dwIPAddr;
    DWORD     dwDNSAddr;
    DWORD     dwDNSAddrAlt;
    DWORD     dwWINSAddr;
    DWORD     dwWINSAddrAlt;
}   IPDATA, *PIPDATA, FAR *LPIPDATA;

// start (taken from rnaphint.h)
// IP Addresses
#define MAX_IP_FIELDS     4
#define MIN_IP_FIELD1     1u  // min allowed value for field 1
#define MAX_IP_FIELD1   255u  // max allowed value for field 1
#define MIN_IP_FIELD2     0u  // min for field 2
#define MAX_IP_FIELD2   255u  // max for field 2
#define MIN_IP_FIELD3     0u  // min for field 3
#define MAX_IP_FIELD3   254u  // max for field 3
#define MIN_IP_FIELD4     1u  // 0 is reserved for broadcast
#define MAX_IP_FIELD4   254u  // max for field 4
#define MIN_IP_VALUE      0u  // default minimum allowable field value
#define MAX_IP_VALUE    255u  // default maximum allowable field value

// used to fix byte ordering
typedef struct tagIAddr {
  union {
  RASIPADDR ia;
  DWORD     dw;
  };
} IADDR;
typedef IADDR * PIADDR;
typedef IADDR * LPIADDR;

#define FValidIaOrZero(pia) ((((PIADDR) (pia))->dw == 0) || FValidIa(pia))
// end (taken from rnaphint.h)

#define MAX_COUNTRY             512
#define DEF_COUNTRY_INFO_SIZE   1024
#define MAX_COUNTRY_NAME        36
#define MAX_AREA_LIST           20
#define MAX_DISPLAY_NAME        36

class ENUM_MODEM
{
private:
  DWORD         m_dwError;
  DWORD         m_dwNumEntries;
  DWORD         m_dwIndex;
  LPRASDEVINFO  m_lpData;
public:
  ENUM_MODEM();
  ~ENUM_MODEM();
  DWORD ReInit();
  TCHAR * Next();
  TCHAR * GetDeviceTypeFromName(LPTSTR szDeviceName);
  TCHAR * GetDeviceNameFromType(LPTSTR szDeviceType);
  BOOL VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType);
  DWORD GetNumDevices() { return m_dwNumEntries; }
  DWORD GetError()  { return m_dwError; }
  void  ResetIndex() { m_dwIndex = 0; }
};

class ENUM_CONNECTOID
{
private:
  DWORD           m_dwError;
  DWORD           m_dwNumEntries;
  DWORD           m_dwIndex;
  LPRASENTRYNAME  m_lpData;
public:
  ENUM_CONNECTOID();
  ~ENUM_CONNECTOID();
  TCHAR * Next();
  DWORD NumEntries();
  DWORD GetError()  { return m_dwError; }
};


// function prototypes
DWORD CreateConnectoid(LPCTSTR pszPhonebook, LPCTSTR pszConnectionName,
  LPRASENTRY lpRasEntry, LPCTSTR pszUserName,LPCTSTR pszPassword);
BOOL InitRNA(HWND hWnd);
VOID DeInitRNA();
DWORD EnsureRNALoaded(VOID);
HRESULT InitModemList(HWND hCB);
VOID InitConnectoidList(HWND hCB, LPTSTR lpszSelect);
VOID InitCountryCodeList(HWND hLB);
VOID FillCountryCodeList(HWND hLB);
VOID GetCountryCodeSelection(HWND hLB,LPCOUNTRYCODE* plpCountryCode);
BOOL SetCountryIDSelection(HWND hwndCB,DWORD dwCountryCode);
VOID DeInitCountryCodeList(VOID);
DWORD ValidateConnectoidName(LPCTSTR pszPhonebook, LPCTSTR pszConnectoidName);
BOOL GetConnectoidUsername(TCHAR * pszConnectoidName,TCHAR * pszUserName,
  DWORD cbUserName,TCHAR * pszPassword,DWORD cbPassword);
DWORD SetConnectoidUsername(LPCTSTR pszPhonebook, LPCTSTR pszConnectoidName,
  LPCTSTR pszUserName, LPCTSTR pszPassword);
void  InitRasEntry(LPRASENTRY lpEntry);
DWORD GetEntry(LPRASENTRY *lplpEntry, LPDWORD lpdwEntrySize, LPCTSTR szEntryName);
VOID  CopyDw2Ia(DWORD dw, RASIPADDR* pia);
DWORD DwFromIa(RASIPADDR *pia);
BOOL FValidIa(RASIPADDR *pia);

#endif // _RNACALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\registry.cpp ===
/****************************************************************************
 *
 *	REGISTRY.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) Microsoft Corporation 1992-1997
 *	All rights reserved
 *
 *	This module provides functionality for self-registering/unregistering via
 *  the regsvr32.exe
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *	4/24/97	jmazner	Created
 *
 ***************************************************************************/

#include "wizard.h"

#include "registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
// 7/2/97 jmazner IE bug #41852
// need to choose a particular key name, so updated setKeyAndValue from
// chapter 12 of InsideCom.
/***
BOOL setKeyAndValue(const char* pszPath,
                    const char* szSubkey,
                    const char* szValue) ;
***/
BOOL setKeyAndValue(const TCHAR* pszPath,
                    const TCHAR* szSubkey,
                    const TCHAR* szValue,
                    const TCHAR* szName = NULL) ;
// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 TCHAR* szCLSID,
                 int length) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const TCHAR* szFriendlyName, // Friendly Name
                       const TCHAR* szVerIndProgID, // Programmatic
                       const TCHAR* szProgID)       //   IDs
{
	// Get server location.
	TCHAR szModule[512] ;
	DWORD dwResult =
		::GetModuleFileName(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(TCHAR)) ;
	ASSERT(dwResult != 0) ;

	// Convert the CLSID into a char.
	TCHAR szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, CLSID_STRING_SIZE) ;

	// Build the key CLSID\\{...}
	TCHAR szKey[CLSID_STRING_SIZE + 10] ;
	lstrcpy(szKey, TEXT("CLSID\\")) ;
	lstrcat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
	setKeyAndValue(szKey, TEXT("InprocServer32"), szModule) ;

	// 7/2/97 jmazner IE bug #41852
	// Add Threading Model
	setKeyAndValue(szKey,
	               TEXT("InprocServer32"),
	               TEXT("Apartment"),
	               TEXT("ThreadingModel")) ; 

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, TEXT("ProgID"), szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, TEXT("VersionIndependentProgID"),
	               szVerIndProgID) ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, TEXT("CLSID"), szCLSID) ;
	setKeyAndValue(szVerIndProgID, TEXT("CurVer"), szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, TEXT("CLSID"), szCLSID) ;

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      const TCHAR* szVerIndProgID, // Programmatic
                      const TCHAR* szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	TCHAR szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, CLSID_STRING_SIZE) ;

	// Build the key CLSID\\{...}
	TCHAR szKey[64] ;
	lstrcpy(szKey, TEXT("CLSID\\")) ;
	lstrcat(szKey, szCLSID) ;

	// Delete the CLSID Key - CLSID\{...}
	LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
	ASSERT((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the version-independent ProgID Key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
	ASSERT((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the ProgID key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
	ASSERT((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtochar(const CLSID& clsid,
                 TCHAR* szCLSID,
                 int cch                // number of characters in szCLSID
                 )
{
	ASSERT(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
	ASSERT(SUCCEEDED(hr)) ;

	// Covert from wide characters to non-wide.
#ifdef UNICODE
	lstrcpyn(szCLSID, (TCHAR *)wszCLSID, cch) ;
#else
	wcstombs(szCLSID, wszCLSID, cch) ;  // characters are 1 byte.
#endif

	// Free memory.
	CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const TCHAR* lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	TCHAR szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const TCHAR* szKey,
                    const TCHAR* szSubkey,
                    const TCHAR* szValue,
                    const TCHAR* szName)
{
	HKEY hKey;
	TCHAR szKeyBuf[1024] ;

	// Copy keyname into buffer.
	lstrcpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		lstrcat(szKeyBuf, TEXT("\\")) ;
		lstrcat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueEx(hKey, szName, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              sizeof(TCHAR)*(lstrlen(szValue)+1)) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\rnacall.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
//
//  RNACALL.C - functions to call RNA dll to create connectoid
//
//  HISTORY:
//  
//  1/18/95   jeremys Cloned from RNA UI code
//  96/01/31  markdu  Renamed CONNENTDLG to OLDCONNENTDLG to avoid
//            conflicts with RNAP.H.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the implementation of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also eliminated IsValidDevice() and RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the implementation of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/02/26  markdu  Replaced all remaining internal RNA APIs.
//  96/03/07  markdu  Extend ENUM_MODEM class, and use global modem
//            enum object.
//  96/03/08  markdu  Do complete verification of device name and type
//            strings passed in to CreateConnectoid.
//  96/03/09  markdu  Moved generic RASENTRY initialization into
//            its own function (InitRasEntry).  Added a wait cursor
//            during loading of RNA.
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//            Also no longer need GetConnectoidPhoneNumber function.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//  96/03/11  markdu  Moved code to set username and password out of
//            CreateConnectoid into SetConnectoidUsername so it can be reused.
//  96/03/11  markdu  Added some flags in InitRasEntry.
//  96/03/13  markdu  Change ValidateConncectoidName to take LPCSTR.
//  96/03/16  markdu  Added ReInit member function to re-enumerate modems.
//  96/03/21  markdu  Work around RNA bug in ENUM_MODEM::ReInit().
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/24  markdu  Replaced lstrcpy with lstrcpyn where appropriate.
//  96/03/25  markdu  Removed GetIPInfo and SetIPInfo.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid,
//            ValidateConnectoidName, and SetConnectoidUsername.
//  96/04/07  markdu  NASH BUG 15645 Work around RNA bug where area code
//            string is required even though it is not being used.
//  96/04/26  markdu  NASH BUG 18605 Handle ERROR_FILE_NOT_FOUND return
//            from ValidateConnectoidName.
//  96/05/14  markdu  NASH BUG 22730 Work around RNA bug.  Flags for terminal
//            settings are swapped by RasSetEntryproperties.
//  96/05/16  markdu  NASH BUG 21810 Added function for IP address validation.
//  96/06/04  markdu  OSR  BUG 7246 Add RASEO_SwCompression and
//            RASEO_ModemLights to default RASENTRY.
//

#include "wizard.h"
#include "tapi.h"

#include "wininet.h"

// WARNING  This flag is defined if WINVER is >= 0x500, but we do not want to build with WINVER >= 0x500
// since we must be able to run on older platforms (Win 95, etc).  This is defined original in ras.h
#ifndef RASEO_ShowDialingProgress
#define RASEO_ShowDialingProgress       0x04000000
#endif
// WARNING  This flag is defined if WINVER is >= 401, but we do not want to build with WINVER >= 401
// since we must be able to run on older platforms (Win 95, etc)
#ifndef RASEO_SecureLocalFiles
#define RASEO_SecureLocalFiles          0x00010000
#endif

typedef BOOL (WINAPI * INTERNETSETOPTION) (IN HINTERNET hInternet OPTIONAL,IN DWORD dwOption,IN LPVOID lpBuffer,IN DWORD dwBufferLength);
static const TCHAR cszWininet[] = TEXT("WININET.DLL");
static const  CHAR cszInternetSetOption[] = "InternetSetOptionA";

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)

// Global variables
HINSTANCE ghInstRNADll=NULL; // handle to RNA dll we load explicitly
HINSTANCE ghInstRNAPHDll=NULL;  // handle to RNAPH dll we load explicitly
DWORD     dwRefCount=0;
BOOL      fRNALoaded=FALSE; // TRUE if RNA function addresses have been loaded
TCHAR *   gpCountryCodeBuf = NULL;  // global list of COUNTRYCODE structures

// global function pointers for RNA apis
RASGETCOUNTRYINFO       lpRasGetCountryInfo=NULL;
RASENUMDEVICES          lpRasEnumDevices=NULL;
RASVALIDATEENTRYNAME    lpRasValidateEntryName=NULL;
RASGETENTRYDIALPARAMS   lpRasGetEntryDialParams=NULL;
RASSETENTRYDIALPARAMS   lpRasSetEntryDialParams=NULL;
RASGETERRORSTRING       lpRasGetErrorString=NULL;
RASSETENTRYPROPERTIES   lpRasSetEntryProperties=NULL;
RASGETENTRYPROPERTIES   lpRasGetEntryProperties=NULL;
RASENUMENTRIES          lpRasEnumEntries=NULL;

// API table for function addresses to fetch
#define NUM_RNAAPI_PROCS   9
APIFCN RnaApiList[NUM_RNAAPI_PROCS] =
{
  { (PVOID *) &lpRasEnumDevices,szRasEnumDevices},
  { (PVOID *) &lpRasGetCountryInfo,szRasGetCountryInfo},
  { (PVOID *) &lpRasValidateEntryName,szRasValidateEntryName},
  { (PVOID *) &lpRasGetEntryDialParams,szRasGetEntryDialParams},
  { (PVOID *) &lpRasSetEntryDialParams,szRasSetEntryDialParams},
  { (PVOID *) &lpRasGetErrorString,szRasGetErrorString},
  { (PVOID *) &lpRasSetEntryProperties,szRasSetEntryProperties},
  { (PVOID *) &lpRasGetEntryProperties,szRasGetEntryProperties},
  { (PVOID *) &lpRasEnumEntries,szRasEnumEntries}
};
//BUGBUG 21-May-1995 bens use #define...sizeof() to define NUM_RNAAPI_PROCS

#pragma data_seg(DATASEG_DEFAULT)

VOID  ShortenName(LPTSTR szLongName, LPTSTR szShortName, DWORD cbShort);
BOOL  GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,UINT nApiProcs);
VOID  SwapDwBytes(LPDWORD lpdw);
void  SwapDWBits(LPDWORD lpdw, DWORD dwBit1, DWORD dwBit2);

#define NO_INTRO  0x00000080  // flag used by RNA wizard
#define US_COUNTRY_CODE    1  // US country code is 1
#define US_COUNTRY_ID      1  // US country ID is 1

/*******************************************************************

  NAME:    InitRNA

  SYNOPSIS:  Loads the RNA dll (RASAPI32), gets proc addresses,
        and loads RNA engine

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

  NOTES:    We load the RNA dll explicitly and get proc addresses
        because these are private APIs and not guaranteed to
        be supported beyond Windows 95.  This way, if the DLL
        isn't there or the entry points we expect aren't there,
        we can display a coherent message instead of the weird
        Windows dialog you get if implicit function addresses
        can't be resolved.

********************************************************************/
BOOL InitRNA(HWND hWnd)
{
  DEBUGMSG("rnacall.c::InitRNA()");

  // only actually do init stuff on first call to this function
  // (when reference count is 0), just increase reference count
  // for subsequent calls
  if (dwRefCount == 0) {

    TCHAR szRNADll[SMALL_BUF_LEN];

    DEBUGMSG("Loading RNA DLL");

    // set an hourglass cursor
    WAITCURSOR WaitCursor;

    // get the filename (RASAPI32.DLL) out of resource
    LoadSz(IDS_RNADLL_FILENAME,szRNADll,sizeof(szRNADll));

    // load the RNA api dll
    ghInstRNADll = LoadLibrary(szRNADll);
    if (!ghInstRNADll) {
      UINT uErr = GetLastError();
      DisplayErrorMessage(hWnd,IDS_ERRLoadRNADll1,uErr,ERRCLS_STANDARD,
        MB_ICONSTOP);
      return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    if (!GetApiProcAddresses(ghInstRNADll,RnaApiList,NUM_RNAAPI_PROCS)) {
      MsgBox(hWnd,IDS_ERRLoadRNADll2,MB_ICONSTOP,MB_OK);
      DeInitRNA();
      return FALSE;
    }

  }

  fRNALoaded = TRUE;

  dwRefCount ++;

  return TRUE;
}

/*******************************************************************

  NAME:    DeInitRNA

  SYNOPSIS:  Unloads RNA dll.

********************************************************************/
VOID DeInitRNA()
{
  DEBUGMSG("rnacall.c::DeInitRNA()");

  UINT nIndex;

  // decrement reference count
  if (dwRefCount)
    dwRefCount --;

  // when the reference count hits zero, do real deinitialization stuff
  if (dwRefCount == 0)
  {
    if (fRNALoaded)
    {
      // set function pointers to NULL
      for (nIndex = 0;nIndex<NUM_RNAAPI_PROCS;nIndex++) 
        *RnaApiList[nIndex].ppFcnPtr = NULL;

      fRNALoaded = FALSE;
    }

    // free the RNA dll
    if (ghInstRNADll)
    {
    DEBUGMSG("Unloading RNA DLL");
      FreeLibrary(ghInstRNADll);
      ghInstRNADll = NULL;
    }

    // free the RNAPH dll
    if (ghInstRNAPHDll)
    {
    DEBUGMSG("Unloading RNAPH DLL");
      FreeLibrary(ghInstRNAPHDll);
      ghInstRNAPHDll = NULL;
    }
  }
}

/*******************************************************************

  NAME:    CreateConnectoid

  SYNOPSIS:  Creates a connectoid (phone book entry) with specified
        name and phone number

  ENTRY:    pszConnectionName - name for the new connectoid
        pszUserName - optional.  If non-NULL, this will be set for the
          user name in new connectoid
        pszPassword - optional.  If non-NULL, this will be set for the
          password in new connectoid

  EXIT:    returns ERROR_SUCCESS if successful, or an RNA error code

  HISTORY:
  96/02/26  markdu    Moved ClearConnectoidIPParams functionality 
            into CreateConnectoid

********************************************************************/
DWORD CreateConnectoid(LPCTSTR pszPhonebook, LPCTSTR pszConnectionName,
  LPRASENTRY lpRasEntry, LPCTSTR pszUserName,LPCTSTR pszPassword)
{
  DEBUGMSG("rnacall.c::CreateConnectoid()");

  DWORD dwRet;

  ASSERT(pszConnectionName);

  // if we don't have a valid RasEntry, bail
  if ((NULL == lpRasEntry) || (sizeof(RASENTRY) != lpRasEntry->dwSize))
  {
    return ERROR_INVALID_PARAMETER;
  }

  // Load RNA if not already loaded
  dwRet = EnsureRNALoaded();
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  // Enumerate the modems.
  if (gpEnumModem)
  {
    // Re-enumerate the modems to be sure we have the most recent changes  
    dwRet = gpEnumModem->ReInit();
  }
  else
  {
    // The object does not exist, so create it.
    gpEnumModem = new ENUM_MODEM;
    if (gpEnumModem)
    {
      dwRet = gpEnumModem->GetError();
    }
    else
    {
      dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
  }
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  // Make sure there is at least one device
  if (0 == gpEnumModem->GetNumDevices())
  {
    return ERROR_DEVICE_DOES_NOT_EXIST;
  }

  // Validate the device if possible
  if (lstrlen(lpRasEntry->szDeviceName) && lstrlen(lpRasEntry->szDeviceType))
  {
    // Verify that there is a device with the given name and type
    if (!gpEnumModem->VerifyDeviceNameAndType(lpRasEntry->szDeviceName, 
      lpRasEntry->szDeviceType))
    {
      // There was no device that matched both name and type,
      // so try to get the first device with matching name.
      LPTSTR szDeviceType = 
        gpEnumModem->GetDeviceTypeFromName(lpRasEntry->szDeviceName);
      if (szDeviceType)
      {
        lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
      }
      else
      {
        // There was no device that matched the given name,
        // so try to get the first device with matching type.
        // If this fails, fall through to recovery case below.
        LPTSTR szDeviceName = 
          gpEnumModem->GetDeviceNameFromType(lpRasEntry->szDeviceType);
        if (szDeviceName)
        {
          lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
        }
        else
        {
          // There was no device that matched the given name OR
          // the given type.  Reset the values so they will be
          // replaced with the first device.
          lpRasEntry->szDeviceName[0] = '\0';
          lpRasEntry->szDeviceType[0] = '\0';
        }
      }
    }
  }
  else if (lstrlen(lpRasEntry->szDeviceName))
  {
    // Only the name was given.  Try to find a matching type.
    // If this fails, fall through to recovery case below.
    LPTSTR szDeviceType = 
      gpEnumModem->GetDeviceTypeFromName(lpRasEntry->szDeviceName);
    if (szDeviceType)
    {
      lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
    }
  }
  else if (lstrlen(lpRasEntry->szDeviceType))
  {
    // Only the type was given.  Try to find a matching name.
    // If this fails, fall through to recovery case below.
    LPTSTR szDeviceName = 
      gpEnumModem->GetDeviceNameFromType(lpRasEntry->szDeviceType);
    if (szDeviceName)
    {
      lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
    }
  }

  // If either name or type is missing, just get first device.
  // Since we already verified that there was at least one device,
  // we can assume that this will succeed.
  if(!lstrlen(lpRasEntry->szDeviceName) ||
     !lstrlen(lpRasEntry->szDeviceType))
  {
    lstrcpy (lpRasEntry->szDeviceName, gpEnumModem->Next());
    lstrcpy (lpRasEntry->szDeviceType,
      gpEnumModem->GetDeviceTypeFromName(lpRasEntry->szDeviceName));
    ASSERT(lstrlen(lpRasEntry->szDeviceName));
    ASSERT(lstrlen(lpRasEntry->szDeviceType));
  }

  // Verify the connectoid name
  dwRet = ValidateConnectoidName(pszPhonebook, pszConnectionName);
  if ((ERROR_SUCCESS != dwRet) &&
    (ERROR_ALREADY_EXISTS != dwRet))
  {
    DEBUGMSG("RasValidateEntryName returned %lu",dwRet);
    return dwRet;
  }

  // 99/04/13  vyung  NT5 BUG 279833
  // New features in NT5 to show progress while dialing. Enable it by default
  if (IsNT5())
  {
    // For NT 5 and greater, File sharing is disabled per connectoid by setting this RAS option.
    lpRasEntry->dwfOptions |= RASEO_SecureLocalFiles;  
    lpRasEntry->dwfOptions |= RASEO_ShowDialingProgress;
  }

  //  96/04/07  markdu  NASH BUG 15645
  // If there is no area code string, and RASEO_UseCountryAndAreaCodes is not
  // set, then the area code will be ignored so put in a default otherwise the
  // call to RasSetEntryProperties will fail due to an RNA bug.
  // if RASEO_UseCountryAndAreaCodes is set, then area code is required, so not
  // having one is an error.  Let RNA report the error.
  if (!lstrlen(lpRasEntry->szAreaCode) &&
    !(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes))
  {
    lstrcpy (lpRasEntry->szAreaCode, szDefaultAreaCode);
  }

  // 96/05/14 markdu  NASH BUG 22730 Work around RNA bug.  Flags for terminal
  // settings are swapped by RasSetEntryproperties, so we swap them before
  // the call.  
  if (IsWin95())
      SwapDWBits(&lpRasEntry->dwfOptions, RASEO_TerminalBeforeDial,
      RASEO_TerminalAfterDial);

  // call RNA to create the connectoid
  ASSERT(lpRasSetEntryProperties);
#ifdef UNICODE
  LPRASENTRY lpRasEntryTmp;

  lpRasEntryTmp = (LPRASENTRY)GlobalAlloc(GPTR, sizeof(RASENTRY) + 512);
  if(lpRasEntry)
    memcpy(lpRasEntryTmp, lpRasEntry, sizeof(RASENTRY));
  else
    lpRasEntryTmp = (LPRASENTRY)lpRasEntry;

  dwRet = lpRasSetEntryProperties(pszPhonebook, pszConnectionName,
    (LPBYTE)lpRasEntryTmp, sizeof(RASENTRY)+512, NULL, 0);

  if(lpRasEntryTmp && lpRasEntryTmp != (LPRASENTRY)lpRasEntry)
  {
    memcpy(lpRasEntry, lpRasEntryTmp, sizeof(RASENTRY));
    GlobalFree(lpRasEntryTmp);
  }

#else
  dwRet = lpRasSetEntryProperties(pszPhonebook, pszConnectionName,
    (LPBYTE)lpRasEntry, sizeof(RASENTRY), NULL, 0);
#endif

  // 96/05/14 markdu  NASH BUG 22730 Work around RNA bug.  Put the bits back
  // to the way they were originally,
  if (IsWin95())
    SwapDWBits(&lpRasEntry->dwfOptions, RASEO_TerminalBeforeDial,
    RASEO_TerminalAfterDial);

  // populate the connectoid with user's account name and password.
  if (dwRet == ERROR_SUCCESS)
  {
    if (pszUserName || pszPassword)
    {
      dwRet = SetConnectoidUsername(pszPhonebook, pszConnectionName,
        pszUserName, pszPassword);
    }
  }
  else
  {
    DEBUGMSG("RasSetEntryProperties returned %lu",dwRet);
  }

  if (dwRet == ERROR_SUCCESS)
  {
    // BUGBUG This prevents the make new connection wizard from being
    //        launched the first time the user opens the RNA folder.
    //        Now that we own the make new connection wizard, we
    //        have to decide whether to do this or not.
    // set a flag to tell RNA not to run the RNA wizard automatically
    // when the folder is opened (they set this flag from their wizard
    // whenever they create a new connectoid).  If this fails just
    // go on, not a critical error
    RegEntry reRNAFolder(szRegPathRNAWizard,HKEY_CURRENT_USER);
    ASSERT(reRNAFolder.GetError() == ERROR_SUCCESS);
    DWORD dwVal = NO_INTRO;
    RegSetValueEx(reRNAFolder.GetKey(),szRegValRNAWizard,
      0,REG_BINARY,(LPBYTE) &dwVal,sizeof(dwVal));


    // We don't use auto discovery for referral and signup connectoid
    if (!g_bUseAutoProxyforConnectoid)
    {
        // VYUNG 12/16/1998
        // REMOVE AUTO DISCOVERY FROM THE DIALUP CONNECTOID

        INTERNET_PER_CONN_OPTION_LISTA list;
        DWORD   dwBufSize = sizeof(list);

        // fill out list struct
        list.dwSize = sizeof(list);
        CHAR szConnectoid [RAS_MaxEntryName];
#ifdef UNICODE
        wcstombs(szConnectoid, pszConnectionName, RAS_MaxEntryName);
#else
        lstrcpyn(szConnectoid, pszConnectionName, lstrlen(pszConnectionName)+1);
#endif
        list.pszConnection = szConnectoid;         
        list.dwOptionCount = 1;                         // one option
        list.pOptions = new INTERNET_PER_CONN_OPTIONA[1];   

        if(list.pOptions)
        {
            // set flags
            list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
            list.pOptions[0].Value.dwValue = PROXY_TYPE_DIRECT;           // no proxy, autoconfig url, or autodiscovery

            // tell wininet
            HINSTANCE hInst = NULL;
            FARPROC fpInternetSetOption = NULL;

            dwRet = ERROR_SUCCESS;
    
            hInst = LoadLibrary(cszWininet);
            if (hInst)
            {
                fpInternetSetOption = GetProcAddress(hInst,cszInternetSetOption);
                if (fpInternetSetOption)
                {
                    if( !((INTERNETSETOPTION)fpInternetSetOption) (NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, dwBufSize) )
                    {
                        dwRet = GetLastError();
                        DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
                    }
                }
                else
                    dwRet = GetLastError();
                FreeLibrary(hInst);
            }

            delete [] list.pOptions;
        }
    }

  }

  return dwRet;
}

/*******************************************************************

  NAME:    InitModemList

  SYNOPSIS:  Fills a combo box window with installed modems

  ENTRY:    hCB - combo box window to fill
  
********************************************************************/
HRESULT InitModemList (HWND hCB)
{
  DEBUGMSG("rnacall.c::InitModemList()");

  LPTSTR pNext;
  int   nIndex;
  DWORD dwRet;

  ASSERT(hCB);

  // Load RNA if not already loaded
  dwRet = EnsureRNALoaded();
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  // Enumerate the modems.
  if (gpEnumModem)
  {
    // Re-enumerate the modems to be sure we have the most recent changes  
    dwRet = gpEnumModem->ReInit();
  }
  else
  {
    // The object does not exist, so create it.
    gpEnumModem = new ENUM_MODEM;
    if (gpEnumModem)
    {
      dwRet = gpEnumModem->GetError();
    }
    else
    {
      dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
  }
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  // clear out the combo box
  ComboBox_ResetContent(hCB);

  while ( pNext = gpEnumModem->Next())
  {
    // Add the device to the combo box
    nIndex = ComboBox_AddString(hCB, pNext);
    ComboBox_SetItemData(hCB, nIndex, NULL);
  }

  // Select the default device
  ComboBox_SetCurSel(hCB, nIndex);

  return ERROR_SUCCESS;
}

/*******************************************************************

  NAME:    InitConnectoidList

  SYNOPSIS:  Fills a list box window with list of RNA connectoids

  ENTRY:    hLB - list box window to fill
            lpszSelect - The connectoid name to select as default
  
********************************************************************/
VOID InitConnectoidList(HWND hLB, LPTSTR lpszSelect)
{
  DEBUGMSG("rnacall.c::InitConnectoidList()");

  ASSERT(hLB);

  LPTSTR pNext;

  // Load RNA if not already loaded
  if (EnsureRNALoaded() != ERROR_SUCCESS)
    return;

  ENUM_CONNECTOID EnumConnectoid;    // class object for enum

  // clear out the list box
  ListBox_ResetContent(hLB);

  int index;
  BOOL fSelected = FALSE;

  // enumerate connectoids
  while ( pNext = EnumConnectoid.Next()) {
    // Add the connectoid to the combo box
    index = ListBox_AddString(hLB, pNext);
        if (!fSelected && !lstrcmpi(pNext, lpszSelect))
        {
                fSelected = TRUE;
                ListBox_SetCurSel(hLB, index);
        }
  }
  if (!fSelected)
          ListBox_SetSel(hLB, TRUE, 0);
}


/*******************************************************************

  NAME:     GetConnectoidUsername

  SYNOPSIS: Get the username and password strings from the phonebook
            entry name specified.

  ENTRY:    pszConnectoidName - phonebook entry name
            pszUserName - string to hold user name
            cbUserName - size of pszUserName buffer
            pszPassword - string to hold password
            cbPassword - size of pszPassword buffer

  EXIT:     TRUE if username and password were copied successfully

********************************************************************/

BOOL GetConnectoidUsername(TCHAR * pszConnectoidName,TCHAR * pszUserName,
  DWORD cbUserName,TCHAR * pszPassword,DWORD cbPassword)
{
  DEBUGMSG("rnacall.c::GetConnectoidUsername()");

  ASSERT(pszConnectoidName);
  ASSERT(pszUserName);
  ASSERT(pszPassword);

  BOOL fRet = FALSE;

  // Load RNA if not already loaded
  DWORD dwRet = EnsureRNALoaded();
  if (dwRet != ERROR_SUCCESS) {
    return FALSE;
  }

  RASDIALPARAMS RasDialParams;
  ZeroMemory(&RasDialParams,sizeof(RASDIALPARAMS));
  RasDialParams.dwSize = sizeof(RASDIALPARAMS);

  lstrcpyn(RasDialParams.szEntryName,pszConnectoidName,
    sizeof(RasDialParams.szEntryName));

  // call RNA to get user name and password
  ASSERT(lpRasGetEntryDialParams);
  BOOL fPasswordSaved;
  dwRet = lpRasGetEntryDialParams(NULL,&RasDialParams,&fPasswordSaved);

  if (dwRet == ERROR_SUCCESS) {
    // copy user name and password to caller's buffers
    lstrcpyn(pszUserName,RasDialParams.szUserName,cbUserName);
    lstrcpyn(pszPassword,RasDialParams.szPassword,cbPassword);
    fRet = TRUE;
  }

  return fRet;
}


/*******************************************************************

  NAME:     SetConnectoidUsername

  SYNOPSIS: Set the username and password strings for the phonebook
            entry name specified.

  ENTRY:    pszConnectoidName - phonebook entry name
            pszUserName - string with user name
            pszPassword - string with password

  EXIT:     Return value of GetEntryDialParams or SetEntryDialParams

********************************************************************/

DWORD SetConnectoidUsername(LPCTSTR pszPhonebook, LPCTSTR pszConnectoidName,
  LPCTSTR pszUserName, LPCTSTR pszPassword)
{
  BOOL bSkipSetting;
  bSkipSetting = TRUE;

  DEBUGMSG("rnacall.c::SetConnectoidUsername()");

  ASSERT(pszConnectoidName);

  // allocate a struct to use to set dialing params
  LPRASDIALPARAMS pRASDialParams = new RASDIALPARAMS;
  if (!pRASDialParams)
    return ERROR_ALLOCATING_MEMORY;

  ZeroMemory(pRASDialParams,sizeof(RASDIALPARAMS));  // zero out structure
  pRASDialParams->dwSize = sizeof(RASDIALPARAMS);
  lstrcpyn(pRASDialParams->szEntryName,pszConnectoidName,
    sizeof(pRASDialParams->szEntryName));

  // get the dialing params for this connectoid so we don't have
  // to reconstruct the fields in struct we aren't changing
  ASSERT(lpRasGetEntryDialParams);
  BOOL fPasswordSaved;
  DWORD dwRet = lpRasGetEntryDialParams(pszPhonebook,
    pRASDialParams,&fPasswordSaved);
  if (dwRet == ERROR_SUCCESS)
  {
    // set the user name and password fields in struct
    // user name and password are optional parameters to this function,
    // make sure pointer is valid
    if (0 != lstrcmp(pRASDialParams->szUserName,pszUserName))
                bSkipSetting = FALSE;
    if (0 != lstrcmp(pRASDialParams->szPassword,pszPassword))
                bSkipSetting = FALSE;

    if (pszUserName)
      lstrcpyn(pRASDialParams->szUserName,pszUserName,
        sizeof(pRASDialParams->szUserName));
    if (pszPassword)
      lstrcpyn(pRASDialParams->szPassword,pszPassword,
        sizeof(pRASDialParams->szPassword));

    // if no password is specified, then set fRemovePassword to TRUE
    // to remove any old password in the connectoid
    BOOL fRemovePassword = (pRASDialParams->szPassword[0] ?
      FALSE : TRUE);

        bSkipSetting = !fRemovePassword && bSkipSetting;

    // set these parameters for connectoid
    ASSERT(lpRasSetEntryDialParams);
        if (!bSkipSetting)
        {
                dwRet = lpRasSetEntryDialParams(pszPhonebook,pRASDialParams,
                  fRemovePassword);
                if (dwRet != ERROR_SUCCESS)
                {
                  DEBUGMSG("RasSetEntryDialParams returned %lu",dwRet);
                }
        }

// ChrisK 9-20-96   Normandy 6096
// For NT4.0 we also have to call RasSetCredentials

        // Check to see if we are running on NT.
        OSVERSIONINFO osver;
        FARPROC fp;
        fp = NULL;
        ZeroMemory(&osver,sizeof(osver));
        osver.dwOSVersionInfoSize = sizeof(osver);
        if (GetVersionEx(&osver))
        {
                if (VER_PLATFORM_WIN32_NT == osver.dwPlatformId)
                {
                        // fill in credential structure
                        RASCREDENTIALS rascred;
                        ZeroMemory(&rascred,sizeof(rascred));
                        rascred.dwSize = sizeof(rascred);
                        rascred.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;
                        lstrcpyn(rascred.szUserName,pszUserName,UNLEN);
                        lstrcpyn(rascred.szPassword,pszPassword,PWLEN);
                        lstrcpyn(rascred.szDomain,TEXT(""),DNLEN);
                        ASSERT(ghInstRNADll);

                        // load API
                        fp = GetProcAddress(ghInstRNADll,szRasSetCredentials);

                        if (fp)
                        {
                                dwRet = ((RASSETCREDENTIALS)fp)(NULL,(LPTSTR)pszConnectoidName,&rascred,FALSE);
                                DEBUGMSG("RasSetCredentials returned, %lu",dwRet);
                        }
                        else
                        {
                                DEBUGMSG("RasSetCredentials api not found.");
                        }
                }
        }


  }
  else
  {
    DEBUGMSG("RasGetEntryDialParams returned %lu",dwRet);
  }

  delete pRASDialParams;

  return dwRet;
}


/*******************************************************************

  NAME:     ValidateConnectoidName

  SYNOPSIS: Validates the phonebook entry name specified.

  ENTRY:    pszConnectoidName - phonebook entry name

  EXIT:     Result of RasValidateEntryName

********************************************************************/

DWORD ValidateConnectoidName(LPCTSTR pszPhonebook, LPCTSTR pszConnectoidName)
{
  DEBUGMSG("rnacall.c::ValidateConnectoidName()");

  ASSERT(pszConnectoidName);

  // Load RNA if not already loaded
  DWORD dwRet = EnsureRNALoaded();
  if (dwRet != ERROR_SUCCESS) {
    return dwRet;
  }

  ASSERT(lpRasValidateEntryName);

  // Although we require a const char *, RasValidateEntryName will
  // accept it, so we have to cast.
  dwRet = lpRasValidateEntryName(pszPhonebook, (LPTSTR)pszConnectoidName);

  // If there are no previous entries, RasValidateEntryName may return
  // ERROR_CANNOT_OPEN_PHONEBOOK.  This is okay.
  if (ERROR_CANNOT_OPEN_PHONEBOOK == dwRet)
          dwRet = ERROR_SUCCESS;

  return dwRet;
}


/*******************************************************************

  NAME:     GetEntry

  SYNOPSIS: Gets the phonebook entry specified.  To get default
            entry, use "" as entry name. 

  ENTRY:    lpEntry - pointer to RASENTRY struct to fill
            szEntryName - phonebook entry name

  EXIT:     Result of RasGetEntryProperties

********************************************************************/

DWORD GetEntry(LPRASENTRY *lplpEntry, LPDWORD lpdwEntrySize, LPCTSTR szEntryName)
{
  DEBUGMSG("rnacall.c::GetEntry()");

  ASSERT(fRNALoaded);  // RNA should be loaded if we get here
  ASSERT(lplpEntry);
  ASSERT(szEntryName);

  // Allocate space if needed
  if (NULL == *lplpEntry)
  {
          *lpdwEntrySize = sizeof(RASENTRY);
          *lplpEntry = (LPRASENTRY) GlobalAlloc(GPTR,*lpdwEntrySize);
          if (NULL == *lplpEntry)
          {
                  *lpdwEntrySize = 0;
                  return ERROR_ALLOCATING_MEMORY;
          }
  }

  // get connectoid information from RNA
  DWORD dwSize = *lpdwEntrySize;
  (*lplpEntry)->dwSize = sizeof(RASENTRY);

  ASSERT(lpRasGetEntryProperties);
  DWORD dwRet = (lpRasGetEntryProperties) (NULL, szEntryName,
    (LPBYTE)*lplpEntry, &dwSize, NULL, NULL);

  // Allocate more space if needed
  if (ERROR_BUFFER_TOO_SMALL == dwRet)
  {
          LPRASENTRY lpNewEntry;

          lpNewEntry = (LPRASENTRY) GlobalReAlloc(*lplpEntry,dwSize,GMEM_MOVEABLE);
          if (NULL == lpNewEntry)
          {
                  return ERROR_ALLOCATING_MEMORY;
          }
          
          *lplpEntry = lpNewEntry;
          *lpdwEntrySize = dwSize;
          dwRet = (lpRasGetEntryProperties) (NULL, szEntryName,
                                                                                 (LPBYTE)*lplpEntry, &dwSize, NULL, NULL);
  }

  return dwRet;
}

VOID FAR PASCAL LineCallback(DWORD hDevice, DWORD dwMsg, 
    DWORD dwCallbackInstance, DWORD dwParam1, DWORD dwParam2, 
    DWORD dwParam3)
{
        return;
}
 
//+----------------------------------------------------------------------------
//
//      Function        GetTapiCountryID
//
//      Synopsis        Get the currenty country ID for the tapi settings
//
//      Arguments       none
//
//      Returns         pdwCountryID - contains address of country ID
//                              ERROR_SUCCESS - no errors
//
//      History         1/8/97  ChrisK Copied from icwconn1/dialerr.cpp
//
//-----------------------------------------------------------------------------
// Normandy 13097 - ChrisK 1/8/97
// NT returns the country ID not the country code
HRESULT GetTapiCountryID(LPDWORD pdwCountryID)
{
        HRESULT hr = ERROR_SUCCESS;
        HLINEAPP hLineApp = NULL;
        DWORD dwCurDev;
        DWORD cDevices;
        DWORD dwAPI;
        LONG lrc;
        LPLINETRANSLATECAPS pTC = NULL;
        LPVOID pv = NULL;
        LPLINELOCATIONENTRY plle = NULL;
        LINEEXTENSIONID leid;
        DWORD dwCurLoc;

        // Get CountryID from TAPI
        //

        *pdwCountryID = 0;

        // Get the handle to the line app
        //

        lineInitialize(&hLineApp,ghInstance,LineCallback," ",&cDevices);
        if (!hLineApp)
        {
                hr = GetLastError();
                goto GetTapiCountryIDExit;
        }

        if (cDevices)
        {

                // Get the TAPI API version
                //

                dwCurDev = 0;
                dwAPI = 0;
                lrc = -1;
                while (lrc && dwCurDev < cDevices)
                {
                        // NOTE: device ID's are 0 based
                        lrc = lineNegotiateAPIVersion(hLineApp,dwCurDev,0x00010004,0x00010004,&dwAPI,&leid);
                        dwCurDev++;
                }
                if (lrc)
                {
                        // TAPI and us can't agree on anything so nevermind...
                        hr = ERROR_GEN_FAILURE;
                        goto GetTapiCountryIDExit;
                }

                // Find the CountryID in the translate cap structure
                //

                pTC = (LINETRANSLATECAPS FAR *)GlobalAlloc(GPTR,sizeof(LINETRANSLATECAPS));
                if (!pTC)
                {
                        // we are in real trouble here, get out!
                        hr = ERROR_NOT_ENOUGH_MEMORY;
                        goto GetTapiCountryIDExit;
                }

                // Get the needed size
                //

                pTC->dwTotalSize = sizeof(LINETRANSLATECAPS);
                lrc = lineGetTranslateCaps(hLineApp,dwAPI,pTC);
                if(lrc)
                {
                        hr = lrc;
                        goto GetTapiCountryIDExit;
                }

                pv = (LPVOID) GlobalAlloc(GPTR,((size_t)pTC->dwNeededSize));
                if (!pv)
                {
                        hr = ERROR_NOT_ENOUGH_MEMORY;
                        goto GetTapiCountryIDExit;
                }
                ((LINETRANSLATECAPS FAR *)pv)->dwTotalSize = pTC->dwNeededSize;
                GlobalFree(pTC);
                pTC = (LINETRANSLATECAPS FAR *)pv;
                pv = NULL;
                lrc = lineGetTranslateCaps(hLineApp,dwAPI,pTC);
                if(lrc)
                {
                        hr = lrc;
                        goto GetTapiCountryIDExit;
                }
        
                plle = LPLINELOCATIONENTRY (LPTSTR(pTC) + pTC->dwLocationListOffset);
                for (dwCurLoc = 0; dwCurLoc < pTC->dwNumLocations; dwCurLoc++)
                {
                        *pdwCountryID = plle->dwPermanentLocationID;
                        if (pTC->dwCurrentLocationID == plle->dwPermanentLocationID)
                        {
                                        *pdwCountryID = plle->dwCountryID;
                                        break; // for loop
                        }
                        plle++;
                }
        }
GetTapiCountryIDExit:
        // 3/4/97       jmazner Olympus #1336
        if( hLineApp )
        {
                // we never call lineOpen, so no need to lineClose
                lineShutdown( hLineApp );
                hLineApp = NULL;
        }
        return hr;
}


/*******************************************************************

  NAME:     InitRasEntry

  SYNOPSIS: Initializes some parts of the RASENTRY struct.

  ENTRY:    lpEntry - pointer to RASENTRY struct to init

  NOTES:    Since this may be called before RNA is loaded, must not
            make any RNA calls.

  96/06/04  markdu  OSR  BUG 7246 Add RASEO_SwCompression and
            RASEO_ModemLights to default RASENTRY.

********************************************************************/

void InitRasEntry(LPRASENTRY lpEntry)
{
  DEBUGMSG("rnacall.c::InitRasEntry()");

  DWORD dwSize = sizeof(RASENTRY);
  ZeroMemory(lpEntry, dwSize);
  lpEntry->dwSize = dwSize;

  // default to use country code and area code
  lpEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

  // default to use IP header compression
  lpEntry->dwfOptions |= RASEO_IpHeaderCompression;

  // default to use remote default gateway
  lpEntry->dwfOptions |= RASEO_RemoteDefaultGateway;

  // configure connectoid to not log on to network
  lpEntry->dwfOptions &= ~RASEO_NetworkLogon;    

  // default to use software compression
  lpEntry->dwfOptions |= RASEO_SwCompression;

  // default to use modem lights
  lpEntry->dwfOptions |= RASEO_ModemLights;

  // set connectoid for PPP
  lpEntry->dwFramingProtocol = RASFP_Ppp;

  // only use TCP/IP protocol
  lpEntry->dwfNetProtocols = RASNP_Ip;

  // default to use TAPI area code and country code
  TCHAR szCountryCode[8];       // 8 is from tapiGetLocationInfo documentation

  if (ERROR_SUCCESS == tapiGetLocationInfo(szCountryCode, lpEntry->szAreaCode))
  {
        // Normandy 13097 - ChrisK 1/8/97
        // NT returns the country ID not the country code
        if (szCountryCode[0])
        {
                if (IsNT())
                {
                        lpEntry->dwCountryID = myatoi(szCountryCode);
                        lpEntry->dwCountryCode = US_COUNTRY_CODE;

                        // Initialize data
                        LINECOUNTRYLIST FAR * lpLineCountryList;
                        DWORD dwSize;
                        dwSize = 0;
                        lpLineCountryList = (LINECOUNTRYLIST FAR *)
                                GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
                        if (NULL == lpLineCountryList)
                                return;
                        lpLineCountryList->dwTotalSize = sizeof(LINECOUNTRYENTRY);

                        // Get size of data structre
                        if(ERROR_SUCCESS != lineGetCountry(lpEntry->dwCountryID,0x10004,lpLineCountryList))
                        {
                                GlobalFree(lpLineCountryList);
                                return;
                        }
                        dwSize = lpLineCountryList->dwNeededSize;
                        GlobalFree(lpLineCountryList);
                        lpLineCountryList = (LINECOUNTRYLIST FAR *)GlobalAlloc(GPTR,dwSize);
                        if (NULL == lpLineCountryList)
                                return;
                        lpLineCountryList->dwTotalSize = dwSize;

                        // Get Country information for given ID
                        if(ERROR_SUCCESS != lineGetCountry(lpEntry->dwCountryID,0x10004,lpLineCountryList))
                        {
                                GlobalFree(lpLineCountryList);
                                return;
                        }
                
                        lpEntry->dwCountryCode = ((LINECOUNTRYENTRY FAR *)((DWORD_PTR)lpLineCountryList +
                                (DWORD)(lpLineCountryList->dwCountryListOffset)))->dwCountryCode;

                        GlobalFree(lpLineCountryList);
                        lpLineCountryList = NULL;

                }
                else
                {
                        lpEntry->dwCountryCode = myatoi(szCountryCode);
                        if (ERROR_SUCCESS != GetTapiCountryID(&lpEntry->dwCountryID))
                                lpEntry->dwCountryID = US_COUNTRY_ID;
                }
        }
  }
  else
  {
          lpEntry->dwCountryCode = US_COUNTRY_CODE;
  }
}


/*******************************************************************

  NAME:    InitCountryCodeList_w

  SYNOPSIS:  Worker function that fills a specified combo box with
        country code selections

  ENTRY:    hLB - HWND of combo box to fill
        dwSelectCountryID - if non-zero, the ID of country code
          to select as default
        fAll - if TRUE, all country codes are enumerated into
          combo box (potentially slow).  If FALSE, only
          the country code in dwSelectCountryID is enumerated.

  NOTES:    Cloned from RNA UI code

********************************************************************/
void InitCountryCodeList_w (HWND hLB, DWORD dwSelectCountryID,BOOL fAll)
{
  DEBUGMSG("rnacall.c::InitCountryCodeList_w()");

  LPRASCTRYINFO lpRasCtryInfo;
  LPCOUNTRYCODE pNext;
  DWORD cbSize;
  DWORD cbList;
  DWORD dwNextCountryID, dwRet;
  LPTSTR szCountryDesc;
  int   nIndex, iSelect;

  ASSERT(fRNALoaded);  // RNA should be loaded if we get here

  BUFFER Fmt(MAX_RES_LEN + SMALL_BUF_LEN);
  BUFFER CountryInfo(DEF_COUNTRY_INFO_SIZE);
  ASSERT(Fmt);
  ASSERT(CountryInfo);
  if (!Fmt || !CountryInfo) 
    return;

  // Load the display format
  LoadSz(IDS_COUNTRY_FMT,Fmt.QueryPtr(),SMALL_BUF_LEN);
  szCountryDesc = Fmt.QueryPtr()+MAX_RES_LEN;

  cbList = (DWORD)(fAll ? sizeof(COUNTRYCODE)*MAX_COUNTRY : sizeof(COUNTRYCODE));

  gpCountryCodeBuf = new TCHAR[cbList];
  ASSERT(gpCountryCodeBuf);
  if (!gpCountryCodeBuf)
    return;
  
  // Start enumerating the info from the first country
  dwNextCountryID   = (fAll || (dwSelectCountryID==0)) ?
                    1 : dwSelectCountryID;
  pNext = (LPCOUNTRYCODE) gpCountryCodeBuf;
  iSelect = 0;
  lpRasCtryInfo = (LPRASCTRYINFO) CountryInfo.QueryPtr();
  lpRasCtryInfo->dwSize = sizeof(RASCTRYINFO);
  ComboBox_ResetContent(hLB);

  // For each country
  while (dwNextCountryID != 0)
  {
    lpRasCtryInfo->dwCountryID  = dwNextCountryID;
    cbSize = CountryInfo.QuerySize();

    // Get the current country information
    ASSERT(lpRasGetCountryInfo);
    dwRet = lpRasGetCountryInfo(lpRasCtryInfo, &cbSize);
    if (ERROR_SUCCESS == dwRet)
    {
      TCHAR  szCountryDisp[MAX_COUNTRY_NAME+1];

      // Make a displayable name
      ShortenName((LPTSTR)(((LPBYTE)lpRasCtryInfo)+lpRasCtryInfo->dwCountryNameOffset),
        szCountryDisp, MAX_COUNTRY_NAME+1);

      // Add the country to the list
      wsprintf(szCountryDesc,Fmt.QueryPtr(), szCountryDisp, lpRasCtryInfo->dwCountryCode);
      nIndex = ComboBox_AddString(hLB, szCountryDesc);
      ASSERT(nIndex >= 0);

      // Copy the country information to our short list
      pNext->dwCountryID   = lpRasCtryInfo->dwCountryID;
      pNext->dwCountryCode = lpRasCtryInfo->dwCountryCode;
      dwNextCountryID      = lpRasCtryInfo->dwNextCountryID;
      ComboBox_SetItemData(hLB, nIndex, pNext);

      // If it is the specified country, make it a default one
      if (pNext->dwCountryID == dwSelectCountryID)
        ComboBox_SetCurSel(hLB, nIndex);

      // if need only one item, bail out
      //
      if (!fAll)
        break;

      // Advance to the next country
      pNext++;
    }
    else
    {
      // If the buffer is too small, reallocate a new one and retry
      if (dwRet == ERROR_BUFFER_TOO_SMALL)
      {
        BOOL fRet=CountryInfo.Resize(cbSize);
        ASSERT(fRet);
        if (!fRet || !CountryInfo)
          return;

        lpRasCtryInfo = (LPRASCTRYINFO) CountryInfo.QueryPtr();
      }
      else
      {
        break;
      }
    }
  }

  // Select the default device
  if ((dwRet == SUCCESS) && (ComboBox_GetCurSel(hLB) == CB_ERR))
    ComboBox_SetCurSel(hLB, 0);

  return;
}

/*******************************************************************

  NAME:    InitCountryCodeList

  SYNOPSIS:  Puts the (single) default country code in specified combo box

  ENTRY:    hLB - HWND of combo box to fill

  NOTES:    -Cloned from RNA UI code
        -Calls InitCountryCodeList_w to do work
        -Caller must call DeInitCountryCodeList when done to free buffer
        -Caller should call FillCountryCodeList when the combo box
          is touched to fill in the whole list of country codes

********************************************************************/
void InitCountryCodeList(HWND hLB)
{
  DEBUGMSG("rnacall.c::InitCountryCodeList()");

  DWORD dwCountryCodeID;

  // Load RNA if not already loaded
  if (EnsureRNALoaded() != ERROR_SUCCESS)
    return;

  // if there is a global rasentry, set default country code to
  // be the same as it... otherwise set default country code to US
  if (sizeof(RASENTRY) == gpRasEntry->dwSize)
  {
    dwCountryCodeID = gpRasEntry->dwCountryID;
  }
  else
  {
    dwCountryCodeID = US_COUNTRY_CODE;
  }

  InitCountryCodeList_w(hLB,dwCountryCodeID,FALSE);
}

/*******************************************************************

  NAME:    FillCountryCodeList

  SYNOPSIS:  Fills the country code listbox with list of all
        country codes

  ENTRY:    hLB - HWND of combo box to fill

  NOTES:    -Cloned from RNA UI code
        -May take a while!  (several seconds)  This shouldn't
          be called unless user plays with combo box
        -Assumes InitCountryCodeList has been called            
        -Caller must call DeInitCountryCodeList when done to free buffer

********************************************************************/
void FillCountryCodeList(HWND hLB)
{
  DEBUGMSG("rnacall.c::FillCountryCodeList()");

  LPCOUNTRYCODE lpcc;
  DWORD dwSelectID;

  ASSERT(fRNALoaded);  // RNA should be loaded if we get here

  // If we already complete the list, do nothing
  if (ComboBox_GetCount(hLB) > 1)
    return;

  // Get the currently selected country code
  if ((lpcc = (LPCOUNTRYCODE)ComboBox_GetItemData(hLB, 0)) != NULL)
  {
    dwSelectID = lpcc->dwCountryID;
  }
  else
  {
    dwSelectID = US_COUNTRY_CODE;
  }

  // free the country code buffer
  DeInitCountryCodeList();

  // set an hourglass cursor
  WAITCURSOR WaitCursor;

  // Enumerate full list of country codes
  InitCountryCodeList_w(hLB, dwSelectID, TRUE);
}

/*******************************************************************

  NAME:     GetCountryCodeSelection

  SYNOPSIS: Gets selected country code and ID based on combo box
        selection and fills them in in phone number struct

  ENTRY:    hLB - handle of combo box
            lpCountryCode - fill in with country code info

********************************************************************/
void GetCountryCodeSelection(HWND hLB,LPCOUNTRYCODE* plpCountryCode)
{
  DEBUGMSG("rnacall.c::GetCountryCodeSelection()");

  ASSERT(hLB);
  ASSERT(plpCountryCode);

  // get index of selected item in combo box
  int iSel = ComboBox_GetCurSel(hLB);

  ASSERT(iSel >= 0);  // should always be a selection
  if (iSel >= 0)
  {
    // get data for item, which is pointer to country code struct
    *plpCountryCode = (LPCOUNTRYCODE) ComboBox_GetItemData(hLB,iSel);
  }
}

/*******************************************************************

  NAME:    SetCountryIDSelection

  SYNOPSIS:  Sets selected country code in combo box

  EXIT:    returns TRUE if successful, FALSE if country code not
        in combo box

********************************************************************/
BOOL SetCountryIDSelection(HWND hwndCB,DWORD dwCountryID)
{
  DEBUGMSG("rnacall.c::SetCountryIDSelection()");

  BOOL fRet = FALSE;

  ASSERT(hwndCB);

  int iCount,iIndex;
  COUNTRYCODE * pcc;

  // search through items in combo box until we find one that
  // matches the specified country ID
  iCount = ComboBox_GetCount(hwndCB);
  for (iIndex = 0;iIndex < iCount;iIndex ++) {
    pcc = (COUNTRYCODE *) ComboBox_GetItemData(hwndCB,iIndex);
    if (pcc && pcc->dwCountryID == dwCountryID) {
      ComboBox_SetCurSel(hwndCB,iIndex);
      return TRUE;
    }
  }

  return FALSE;  // couldn't find country code in combo box
}

/*******************************************************************

  NAME:    DeInitCountryCodeList

  SYNOPSIS:  Frees buffer of country codes

  NOTES:    Call when done with combo box that displays country codes

********************************************************************/
void DeInitCountryCodeList(VOID)
{
  DEBUGMSG("rnacall.c::DeInitCountryCodeList()");

  // free the country code buffer
  ASSERT(gpCountryCodeBuf);
  if (gpCountryCodeBuf)
  {
    delete gpCountryCodeBuf;
    gpCountryCodeBuf = NULL;
  }
}

/*******************************************************************

  NAME:    ShortenName

  SYNOPSIS:  Copies a name to a (potentially shorter) buffer;
        if the name is too large it truncates it and adds "..."

  NOTES:    Cloned from RNA UI code

********************************************************************/
void ShortenName(LPTSTR szLongName, LPTSTR szShortName, DWORD cbShort)
{
//  DEBUGMSG("rnacall.c::ShortenName()");

  static BOOL    gfShortFmt  = FALSE;
  static TCHAR   g_szShortFmt[SMALL_BUF_LEN];
  static DWORD   gdwShortFmt = 0;

  ASSERT(szLongName);
  ASSERT(szShortName);

  // Get the shorten format
  if (!gfShortFmt)
  {
    gdwShortFmt  = LoadString(ghInstance, IDS_SHORT_FMT, g_szShortFmt,
      SMALL_BUF_LEN);
    gdwShortFmt -= 2;  // lstrlen("%s")
    gfShortFmt   = TRUE;
  };

  // Check the size of the long name
  if ((DWORD)lstrlen(szLongName)+1 <= cbShort)
  {
    // The name is shorter than the specified size, copy back the name
    lstrcpy(szShortName, szLongName);
  } else {
    BUFFER bufShorten(cbShort*2);
    ASSERT(bufShorten);

    if (bufShorten) {
      lstrcpyn(bufShorten.QueryPtr(), szLongName, cbShort-gdwShortFmt);
      wsprintf(szShortName, g_szShortFmt,bufShorten.QueryPtr());
    } else {
         lstrcpyn(szShortName, szLongName, cbShort);
    }
  }
}


/*******************************************************************

  NAME:    EnsureRNALoaded

  SYNOPSIS:  Loads RNA if not already loaded

********************************************************************/
DWORD EnsureRNALoaded(VOID)
{
  DEBUGMSG("rnacall.c::EnsureRNALoaded()");

  DWORD dwRet = ERROR_SUCCESS;

  // load RNA if necessary
  if (!fRNALoaded) {
    if (InitRNA(NULL))
      fRNALoaded = TRUE;
    else return ERROR_FILE_NOT_FOUND;
  }

  return dwRet;
}


/*******************************************************************

  NAME:    ENUM_MODEM::ENUM_MODEM

  SYNOPSIS:  Constructor for class to enumerate modems

  NOTES:    Useful to have a class rather than C functions for
        this, due to how the enumerators function

********************************************************************/
ENUM_MODEM::ENUM_MODEM() :
  m_dwError(ERROR_SUCCESS),m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize = 0;

  // Use the reinit member function to do the work.
  this->ReInit();
}


/*******************************************************************

  NAME:     ENUM_MODEM::ReInit

  SYNOPSIS: Re-enumerate the modems, freeing the old memory.

********************************************************************/
DWORD ENUM_MODEM::ReInit()
{
  DWORD cbSize = 0;

  // Clean up the old list
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
  m_dwNumEntries = 0;
  m_dwIndex = 0;

  // call RasEnumDevices with no buffer to find out required buffer size
  ASSERT(lpRasEnumDevices);
  m_dwError = lpRasEnumDevices(NULL, &cbSize, &m_dwNumEntries);

  // Special case check to work around RNA bug where ERROR_BUFFER_TOO_SMALL
  // is returned even if there are no devices.
  // If there are no devices, we are finished.
  if (0 == m_dwNumEntries)
  {
    m_dwError = ERROR_SUCCESS;
    return m_dwError;
  }

  // Since we were just checking how much mem we needed, we expect
  // a return value of ERROR_BUFFER_TOO_SMALL, or it may just return
  // ERROR_SUCCESS (ChrisK  7/9/96).
  if (ERROR_BUFFER_TOO_SMALL != m_dwError && ERROR_SUCCESS != m_dwError)
  {
    return m_dwError;
  }

  // Allocate the space for the data
  m_lpData = (LPRASDEVINFO) new TCHAR[cbSize];
  if (NULL == m_lpData)
  {
    DEBUGTRAP("ENUM_MODEM: Failed to allocate device list buffer");
    m_dwError = ERROR_NOT_ENOUGH_MEMORY;
    return m_dwError;
  }
  m_lpData->dwSize = sizeof(RASDEVINFO);
  m_dwNumEntries = 0;

  // enumerate the modems into buffer
  m_dwError = lpRasEnumDevices(m_lpData, &cbSize,
    &m_dwNumEntries);

  if (ERROR_SUCCESS != m_dwError)
          return m_dwError;

    //
    // ChrisK Olympus 4560 do not include VPN's in the list
    //
    DWORD dwTempNumEntries;
    DWORD idx;
    LPRASDEVINFO lpNextValidDevice;

    dwTempNumEntries = m_dwNumEntries;
    lpNextValidDevice = m_lpData;

        //
        // Walk through the list of devices and copy non-VPN device to the first
        // available element of the array.
        //
        for (idx = 0;idx < dwTempNumEntries; idx++)
        {
        // We only want to show Modem and ISDN (or ADSL in future) device type
        // in this dialog.
        // 
        // char b[400];
        // wsprintf(b, "Type:%s, Name:%s", m_lpData[idx].szDeviceType, m_lpData[idx].szDeviceName);
        // MessageBox(0, b, "Devices", MB_OK);
        //
                if ((0 == lstrcmpi(TEXT("MODEM"),m_lpData[idx].szDeviceType)) ||
            (0 == lstrcmpi(TEXT("ISDN"),m_lpData[idx].szDeviceType)))
                {
                        if (lpNextValidDevice != &m_lpData[idx])
                        {
                                MoveMemory(lpNextValidDevice ,&m_lpData[idx],sizeof(RASDEVINFO));
                        }
                        lpNextValidDevice++;
                }
                else
                {
                        m_dwNumEntries--;
                }
        }
  
  return m_dwError;
}


/*******************************************************************

  NAME:    ENUM_MODEM::~ENUM_MODEM

  SYNOPSIS:  Destructor for class

********************************************************************/
ENUM_MODEM::~ENUM_MODEM()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:     ENUM_MODEM::Next

  SYNOPSIS: Enumerates next modem 

  EXIT:     Returns a pointer to device info structure.  Returns
            NULL if no more modems or error occurred.  Call GetError
            to determine if error occurred.

********************************************************************/
TCHAR * ENUM_MODEM::Next()
{
  if (m_dwIndex < m_dwNumEntries)
  {
    return m_lpData[m_dwIndex++].szDeviceName;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::GetDeviceTypeFromName

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device type string for first
            device name that matches.  Returns
            NULL if no device with specified name is found

********************************************************************/

TCHAR * ENUM_MODEM::GetDeviceTypeFromName(LPTSTR szDeviceName)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return m_lpData[dwIndex].szDeviceType;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::GetDeviceNameFromType

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device name string for first
            device type that matches.  Returns
            NULL if no device with specified Type is found

********************************************************************/

TCHAR * ENUM_MODEM::GetDeviceNameFromType(LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType))
    {
      return m_lpData[dwIndex].szDeviceName;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::VerifyDeviceNameAndType

  SYNOPSIS: Determines whether there is a device with the name
            and type given.

  EXIT:     Returns TRUE if the specified device was found, 
            FALSE otherwise.

********************************************************************/

BOOL ENUM_MODEM::VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType) &&
      !lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return TRUE;
    }
    dwIndex++;
  }

  return FALSE;
}


/*******************************************************************

  NAME:    ENUM_CONNECTOID::ENUM_CONNECTOID

  SYNOPSIS:  Constructor for class to enumerate connectoids

  NOTES:    Useful to have a class rather than C functions for
        this, due to how the enumerators function

********************************************************************/
ENUM_CONNECTOID::ENUM_CONNECTOID() :
  m_dwError(ERROR_SUCCESS),m_dwNumEntries(0),m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize;
  RASENTRYNAME   rasEntryName;
  
  cbSize = sizeof(RASENTRYNAME);
  rasEntryName.dwSize = cbSize;

  // call RasEnumEntries with a temp structure.  this will not likely
  // be big enough, but cbSize will be filled with the required size
  ASSERT(lpRasEnumEntries);
  m_dwError = lpRasEnumEntries(NULL, NULL, &rasEntryName,
    &cbSize, &m_dwNumEntries);
  if ((ERROR_BUFFER_TOO_SMALL != m_dwError) &&
    (ERROR_SUCCESS != m_dwError))
  {
    return;
  }

  // Make sure that there is at least enough room for the structure
  // (RasEnumEntries will return 0 as cbSize if there are no entries)
  cbSize = (cbSize > sizeof(RASENTRYNAME)) ? cbSize : sizeof(RASENTRYNAME);

  // Allocate the space for the data
  m_lpData = (LPRASENTRYNAME) new TCHAR[cbSize];
  if (NULL == m_lpData)
  {
    DEBUGTRAP("ENUM_CONNECTOID: Failed to allocate connectoid list buffer");
    m_dwError = ERROR_NOT_ENOUGH_MEMORY;
    return;
  }
  m_lpData->dwSize = sizeof(RASENTRYNAME);

  m_dwNumEntries = 0;

  // enumerate the connectoids into buffer
  m_dwError = lpRasEnumEntries(NULL, NULL, m_lpData, &cbSize, &m_dwNumEntries);

  if (IsNT5())
  {
    DWORD dwNumEntries = 0;
  
    if (ERROR_SUCCESS == m_dwError && m_dwNumEntries) 
    {
      for(DWORD dwIndx=0; dwIndx < m_dwNumEntries; dwIndx++)
      {
          LPRASENTRY  lpRasEntry = NULL;
          DWORD       dwRasEntrySize = 0;
          if (GetEntry(&lpRasEntry, &dwRasEntrySize, m_lpData[dwIndx].szEntryName) == ERROR_SUCCESS)
          {
              // check connection type
              if ((0 != lstrcmpi(TEXT("MODEM"), lpRasEntry->szDeviceType)) &&
                 (0 != lstrcmpi(TEXT("ISDN"), lpRasEntry->szDeviceType)))
                    *(m_lpData[dwIndx].szEntryName) = 0;
              else
                  dwNumEntries++;
          }
          //
          // Release memory
          //
          if (NULL != lpRasEntry)
          {
              GlobalFree(lpRasEntry);
              lpRasEntry = NULL;
          }
      } // End for loop
      m_dwNumEntries = dwNumEntries;
    }
 
  }


}

/*******************************************************************

  NAME:    ENUM_CONNECTOID::~ENUM_CONNECTOID

  SYNOPSIS:  Destructor for class

********************************************************************/
ENUM_CONNECTOID::~ENUM_CONNECTOID()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:    ENUM_CONNECTOID::Next

  SYNOPSIS:  Enumerates next connectoid

  EXIT:    Returns a pointer to connectoid name.  Returns NULL
        if no more connectoids or error occurred.  Call GetError
        to determine if error occurred.

********************************************************************/
TCHAR * ENUM_CONNECTOID::Next()
{
  while (m_dwIndex < m_dwNumEntries)
  {
      if (0 == *(m_lpData[m_dwIndex].szEntryName))
      {
          m_dwIndex++;
      }
      else
      {
         return m_lpData[m_dwIndex++].szEntryName;
      }
  }

  return NULL;
}

/*******************************************************************

  NAME:    ENUM_CONNECTOID::NumEntries

  SYNOPSIS:  returns number of connectoids stored in this instance

  EXIT:    Returns value of m_dwNumEntries

  HISTORY:      11/11/96        jmazner         Created.

********************************************************************/
DWORD ENUM_CONNECTOID::NumEntries()
{
        return m_dwNumEntries;
}

//+----------------------------------------------------------------------------
//      Function:       FRasValidatePatch
//
//      Synopsis:       With all of the other Ras functions there exists a common entry
//                              point for WinNT and Win95, usually the A version.  However,
//                              RasValidateEntryName only has an A and W version on WinNT and
//                              an unqualified version on Win95.  Therefore we have to do some
//                              special processing to try to find it
//
//      Input:          ppFP - Location to save function point to
//                              hInst1 - First DLL to check for entry point
//                              hInst2 - Second DLL to check for entry point
//                              lpszName - Name of the function (if it isn't RasValidateEntryName)
//                                      we just skip it and move on.
//
//      Return:         TRUE - success
//
//      History:        7/3/96          Created, ChrisK
//
//-----------------------------------------------------------------------------
BOOL FRasValidatePatch(PVOID *ppFP, HINSTANCE hInst1, HINSTANCE hInst2, LPCSTR lpszName)
{
        BOOL bRC = TRUE;

        //
        // Validate parameters
        //
        if (ppFP && hInst1 && lpszName)
        {

                //
                // Check that we are really looking for RasValidateEntryName
                //
                if (0 == lstrcmpA(lpszName,szRasValidateEntryName))
                {
                        //
                        // Find entry point with alternate name
                        //
                        *ppFP = GetProcAddress(hInst1,szRasValidateEntryName);
                        if (!*ppFP && hInst2)
                                *ppFP = GetProcAddress(hInst2,szRasValidateEntryName);
                        if (!*ppFP)
                        {
                                DEBUGMSG("INETCFG: FRasValidatePatch entry point not found is either DLL.\n");
                                bRC = FALSE;
                        }
                }
                else
                {
                        bRC = FALSE;
                }
        }
        else
        {
                DEBUGMSG("INETCFG: FRasValidatePatch invalid parameters.\n");
                bRC = FALSE;
        }

//FRasValidatePatchExit:
        return bRC;
}

/*******************************************************************

  NAME:    GetApiProcAddresses

  SYNOPSIS:  Gets proc addresses for a table of functions

  EXIT:    returns TRUE if successful, FALSE if unable to retrieve
        any proc address in table

  HISTORY: 
  96/02/28  markdu  If the api is not found in the module passed in,
            try the backup (RNAPH.DLL)

********************************************************************/
BOOL GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,UINT nApiProcs)
{
  DEBUGMSG("rnacall.c::GetApiProcAddresses()");

  UINT nIndex;
  // cycle through the API table and get proc addresses for all the APIs we
  // need
  for (nIndex = 0;nIndex < nApiProcs;nIndex++)
  {
    if (!(*pApiProcList[nIndex].ppFcnPtr = (PVOID) GetProcAddress(hModDLL,
      pApiProcList[nIndex].pszName)))
    {
      // Try to find the address in RNAPH.DLL.  This is useful in the
      // case thatRASAPI32.DLL did not contain the function that we
      // were trying to load.
      if (FALSE == IsNT())
          {
                  if (!ghInstRNAPHDll)
                  {
                        TCHAR szRNAPHDll[SMALL_BUF_LEN];

                        LoadSz(IDS_RNAPHDLL_FILENAME,szRNAPHDll,sizeof(szRNAPHDll));
                        ghInstRNAPHDll = LoadLibrary(szRNAPHDll);
                  }

                  if ((!ghInstRNAPHDll) ||  !(*pApiProcList[nIndex].ppFcnPtr =
                        (PVOID) GetProcAddress(ghInstRNAPHDll,pApiProcList[nIndex].pszName)))
                  {
                          if (!FRasValidatePatch(pApiProcList[nIndex].ppFcnPtr, hModDLL,
                                  ghInstRNAPHDll, pApiProcList[nIndex].pszName))
                          {
                                DEBUGMSG("Unable to get address of function %s",
                                        pApiProcList[nIndex].pszName);

                                for (nIndex = 0;nIndex<nApiProcs;nIndex++)
                                        *pApiProcList[nIndex].ppFcnPtr = NULL;

                                return FALSE;
                          }
                  }
                }
        }
  }

  return TRUE;
}


/*******************************************************************

  NAME:    GetRNAErrorText

  SYNOPSIS:  Gets text string corresponding to RNA error code

  ENTRY:    uErr - RNA error code
        pszErrText - buffer to retrieve error text description
        cbErrText - size of pszErrText buffer

********************************************************************/

VOID GetRNAErrorText(UINT uErr,TCHAR * pszErrText,DWORD cbErrText)
{
  DEBUGMSG("rnacall.c::GetRNAErrorText()");

  ASSERT(pszErrText);

  ASSERT(lpRasGetErrorString);
  DWORD dwRet = lpRasGetErrorString(uErr,pszErrText,cbErrText);

  if (dwRet != ERROR_SUCCESS) {
    // if we couldn't get real error text, then make generic string
    // with the error number
    TCHAR szFmt[SMALL_BUF_LEN+1];
    LoadSz(IDS_GENERIC_RNA_ERROR,szFmt,sizeof(szFmt));
    wsprintf(pszErrText,szFmt,uErr);
  }
}


/* S W A P  D W  B Y T E S Taken from rnaph.c */
/*----------------------------------------------------------------------------
  %%Function: SwapDwBytes

  Swap the bytes of a DWORD.
  (BSWAP isn't available on a 386)

----------------------------------------------------------------------------*/
VOID SwapDwBytes(LPDWORD lpdw)
{
  IADDR iaddr;

  iaddr.ia.a = ((PIADDR) lpdw)->ia.d;
  iaddr.ia.b = ((PIADDR) lpdw)->ia.c;
  iaddr.ia.c = ((PIADDR) lpdw)->ia.b;
  iaddr.ia.d = ((PIADDR) lpdw)->ia.a;

  *lpdw = iaddr.dw;
}

/* C O P Y  D W  2  I A   Taken from rnaph.c */
/*----------------------------------------------------------------------------
  %%Function: CopyDw2Ia

  Convert a DWORD to an Internet Address

----------------------------------------------------------------------------*/
VOID CopyDw2Ia(DWORD dw, RASIPADDR* pia)
{
  SwapDwBytes(&dw);
  *pia = ((PIADDR) &dw)->ia;
}

/* D W  F R O M  I A Taken from rnaph.c */
/*----------------------------------------------------------------------------
  %%Function: DwFromIa

  Convert an Internet Address to a DWORD

----------------------------------------------------------------------------*/
DWORD DwFromIa(RASIPADDR *pia)
{
  IADDR iaddr;

  iaddr.dw = * (LPDWORD) pia;
  SwapDwBytes(&iaddr.dw);  
  
  return iaddr.dw;
}

/* F  V A L I D  I A    Taken from rnaph.c */
/*----------------------------------------------------------------------------
  %%Function: FValidIa

  Return TRUE if the IP address is valid

----------------------------------------------------------------------------*/
BOOL FValidIa(RASIPADDR *pia)
{
  BYTE b;

  b = ((PIADDR) pia)->ia.a;
  if (b < MIN_IP_FIELD1 || b > MAX_IP_FIELD1 || b == 127)
    return FALSE;

  b = ((PIADDR) pia)->ia.d;
  if (b > MAX_IP_FIELD4)
    return FALSE;

  return TRUE;
}


/*******************************************************************

  NAME:     SwapDwBits

  SYNOPSIS: Swap the values of the specified bits

  ENTRY:    lpdw - address of DWORD with bits to be swapped
            dwBit1 - mask for first bit
            dwBit2 - mask for second bit

  HISTORY:
  96/05/14  markdu  NASH BUG 22730 Created to work around RNA bug.

********************************************************************/

void SwapDWBits(LPDWORD lpdw, DWORD dwBit1, DWORD dwBit2)
{
  ASSERT(lpdw);

  // Only need to swap if exactly one of the two bits is set since
  // otherwise the bits are identical.
  if (((*lpdw & dwBit1) &&
    !(*lpdw & dwBit2)) ||
    (!(*lpdw & dwBit1) &&
    (*lpdw & dwBit2)))
  {
    // Since only one of the two bits was set, we can simulate the swap
    // by flipping each bit.
    *lpdw ^= dwBit1;
    *lpdw ^= dwBit2;
  }
}

//+----------------------------------------------------------------------------
//
//      Function:       InitTAPILocation
//
//      Synopsis:       Ensure that TAPI location information is configured correctly;
//                              if not, prompt user to fill it in.
//
//      Arguments:      hwndParent -- parent window for TAPI dialog to use
//                                                      (_must_ be a valid window HWND, see note below)
//
//      Returns:        void
//
//      Notes:          The docs for lineTranslateDialog lie when they say that the
//                              fourth parameter (hwndOwner) can be null.  In fact, if this
//                              is null, the call will return with LINEERR_INVALPARAM.
//                              
//
//      History:        7/15/97 jmazner Created for Olympus #6294
//
//-----------------------------------------------------------------------------
BOOL InitTAPILocation(HWND hwndParent)
{
    HLINEAPP hLineApp=NULL;
    TCHAR szTempCountryCode[8];
    TCHAR szTempCityCode[8];
    BOOL bRetVal = TRUE;
    DWORD dwTapiErr = 0;
    DWORD cDevices=0;
    DWORD dwCurDevice = 0;


    ASSERT( IsWindow(hwndParent) );

    //
    // see if we can get location info from TAPI
    //
    dwTapiErr = tapiGetLocationInfo(szTempCountryCode,szTempCityCode);
    if( 0 != dwTapiErr )
    {
        // 
        // GetLocation failed.  let's try calling the TAPI mini dialog.  Note
        // that when called in this fashion, the dialog has _no_ cancel option,
        // the user is forced to enter info and hit OK.
        //
        DEBUGMSG("InitTAPILocation, tapiGetLocationInfo failed");
        
        dwTapiErr = lineInitialize(&hLineApp,ghInstance,LineCallback," ",&cDevices);
        if (dwTapiErr == ERROR_SUCCESS)
        {
            //
            // loop through all TAPI devices and try to call lineTranslateDialog
            // The call might fail for VPN devices, thus we want to try every
            // device until we get a success.
            //
            dwTapiErr = LINEERR_INVALPARAM;

            while( (dwTapiErr != 0) && (dwCurDevice < cDevices) )
            {
                BOOL bIsNT5 = IsNT5();
                if (bIsNT5)
                    EnableWindow(hwndParent, FALSE);
                dwTapiErr = lineTranslateDialog(hLineApp,dwCurDevice,0x10004,hwndParent,NULL);
                if (bIsNT5)
                    EnableWindow(hwndParent, TRUE);

                if( 0 != dwTapiErr )
                {
                    DEBUGMSG("InitTAPILocation, lineTranslateDialog on device %d failed with err = %d!",
                        dwCurDevice, dwTapiErr);
                    if (bIsNT5)
                    {
                        bRetVal = FALSE;
                        break;
                    }
                }
                dwCurDevice++;
            }
        }
        else
        {
            DEBUGMSG("InitTAPILocation, lineInitialize failed with err = %d", dwTapiErr);
        }

        dwTapiErr = tapiGetLocationInfo(szTempCountryCode,szTempCityCode);
        if( 0 != dwTapiErr )
        {
            DEBUGMSG("InitTAPILocation still failed on GetLocationInfo, bummer.");
        }
        else
        {
            DEBUGMSG("InitTAPILocation, TAPI location is initialized now");
        }
    }

    if( hLineApp )
    {
        lineShutdown(hLineApp);
        hLineApp = NULL;
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\registry.h ===
/****************************************************************************
 *
 *	REGISTRY.h
 *
 *	Microsoft Confidential
 *	Copyright (c) Microsoft Corporation 1992-1997
 *	All rights reserved
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *	4/24/97	jmazner	Created
 *
 ***************************************************************************/

#ifndef __Registry_H__
#define __Registry_H__
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const TCHAR* szFriendlyName,
                       const TCHAR* szVerIndProgID,
                       const TCHAR* szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         const TCHAR* szVerIndProgID,
                         const TCHAR* szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\strings.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  STRINGS.C - String literals for hard-coded strings
//

//  HISTORY:
//  
//  12/22/94  jeremys Created.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the implementation of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also removed RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the implementation of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/03/25  markdu  Removed szDefAreaCode.
//  96/04/24  markdu  NASH BUG 19289 Added /NOMSN command line flag
//  96/07/02  ChrisK  Added A to Ras entry points for NT 4.0
//

#include "wizard.h"

#pragma data_seg(DATASEG_READONLY)

//////////////////////////////////////////////////////
// registry strings
//////////////////////////////////////////////////////

// "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
static const TCHAR szRegPathInternetSettings[] = REGSTR_PATH_INTERNET_SETTINGS;

// "System\\CurrentControlSet\\Services\\VxD\\MSTCP"
static const TCHAR szTCPGlobalKeyName[] =     REGSTR_PATH_VXD TEXT("\\MSTCP");

static const TCHAR szRegValRNAWizard[] =     TEXT("wizard");

// "RemoteAccess"
static const TCHAR szRegPathRNAWizard[] =     REGSTR_PATH_REMOTEACCESS;

static const TCHAR szRegValHostName[] =       TEXT("HostName");

// "InternetProfile"
static const TCHAR szRegValInternetProfile[] =   REGSTR_VAL_INTERNETPROFILE;

// "BackupInternetProfile"
static const TCHAR szRegValBkupInternetProfile[] =   REGSTR_VAL_BKUPINTERNETPROFILE;

// "EnableAutodial"
static const TCHAR szRegValEnableAutodial[] =  REGSTR_VAL_ENABLEAUTODIAL;

// "NoNetAutodial"
static const TCHAR szRegValNoNetAutodial[] =  REGSTR_VAL_NONETAUTODIAL;

// "EnableSecurityCheck"
static const TCHAR szRegValEnableSecurityCheck[] = REGSTR_VAL_ENABLESECURITYCHECK;

// "AccessMedium"
static const TCHAR szRegValAccessMedium[] =    REGSTR_VAL_ACCESSMEDIUM;

// "AccessType"
static const TCHAR szRegValAccessType[] =    REGSTR_VAL_ACCESSTYPE;

static const TCHAR szRegValInstalledMSN105[] =  TEXT("InstallData1");

static const TCHAR szRegPathWarningFlags[] =    TEXT("Software\\Microsoft\\MOS\\Connection");
static const TCHAR szRegValDisableDNSWarning[] = TEXT("NoDNSWarning");

// "Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents"
static const TCHAR szRegPathOptComponents[]=REGSTR_PATH_SETUP REGSTR_KEY_SETUP TEXT("\\OptionalComponents");

static const TCHAR szRegPathMSNetwork105[] =    TEXT("MSNetwork105");
static const TCHAR szRegValInstalled[] =     TEXT("Installed");

//    //10/24/96 jmazner Normandy 6968
//    //No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.
static const TCHAR szRegPathInternetIconCommand[] = TEXT("CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}\\Shell\\Open\\Command");

static const TCHAR szRegPathIexploreAppPath[] =  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE");
static const TCHAR szPathSubKey[] = TEXT("Path");
static const TCHAR szRegPathNameSpace[] =    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace");
static const TCHAR szRegKeyInternetIcon[] =     TEXT("{FBF23B42-E3F0-101B-8488-00AA003E56F8}");

// Athena Mail and News
static const TCHAR szRegPathMailApp[] = TEXT("CLSID\\{89292102-4755-11cf-9DC2-00AA006C2B84}\\InProcServer32");
static const TCHAR szRegPathNewsApp[] = TEXT("CLSID\\{89292103-4755-11cf-9DC2-00AA006C2B84}\\InProcServer32");
static const  CHAR szSetDefaultMailHandler[] = "SetDefaultMailHandler";
static const  CHAR szSetDefaultNewsHandler[] = "SetDefaultNewsHandler";

// ICW settings
static const TCHAR szICWShellNextFlag[] = TEXT("/shellnext ");
// reg keys under HKCR
static const TCHAR cszRegPathXInternetSignup[] = TEXT("x-internet-signup\\Shell\\Open\\command");
// reg keys under HKCU
static const TCHAR szRegPathICWSettings[] = TEXT("Software\\Microsoft\\Internet Connection Wizard");
static const TCHAR szRegValICWCompleted[] = TEXT("Completed");
static const TCHAR szRegValShellNext[] = TEXT("ShellNext");
// reg keys under HKLM
static const TCHAR cszRegPathAppPaths[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths");
static const TCHAR cszPath[] = TEXT("Path");
static const TCHAR cszInstallationDirectory[] = TEXT("InstallationDirectory");

// IEAK values
static const TCHAR szRegIEAKSettings[] = TEXT("Software\\Microsoft\\IEAK");
static const TCHAR szREgIEAKNeededKey[] = TEXT("ISP Signup Required");
static const TCHAR szIEAKSignupFilename[] = TEXT("Signup\\Signup.htm");

//
// Smart start flag
//
static const TCHAR szICWSmartStartFlag[]    = TEXT("/smartstart ");

static const TCHAR szFullICWFileName[] = TEXT("ICWCONN1.EXE");
static const TCHAR szManualICWFileName[] = TEXT("INETWIZ.EXE");
static const TCHAR szISignupICWFileName[] = TEXT("ISIGNUP.EXE");


//////////////////////////////////////////////////////
// MAPI api function names
//////////////////////////////////////////////////////
static const CHAR szMAPIInitialize[] =       "MAPIInitialize";
static const CHAR szMAPIUninitialize[] =     "MAPIUninitialize";
static const CHAR szMAPIAdminProfiles[] =    "MAPIAdminProfiles";
static const CHAR szMAPIAllocateBuffer[] =   "MAPIAllocateBuffer";
static const CHAR szMAPIFreeBuffer[] =       "MAPIFreeBuffer";
static const CHAR szHrQueryAllRows[] =       "HrQueryAllRows@24";
                                               

//////////////////////////////////////////////////////
// RNA api function names
//////////////////////////////////////////////////////
static const CHAR szRasValidateEntryNamePlain[] =  "RasValidateEntryNameA";

#ifdef UNICODE
static const CHAR szRasGetCountryInfo[] =     "RasGetCountryInfoW";
static const CHAR szRasEnumDevices[] =        "RasEnumDevicesW";
static const CHAR szRasValidateEntryName[] = "RasValidateEntryNameW";
static const CHAR szRasGetErrorString[] =     "RasGetErrorStringW";
static const CHAR szRasGetEntryDialParams[] = "RasGetEntryDialParamsW";
static const CHAR szRasSetEntryDialParams[] = "RasSetEntryDialParamsW";
static const CHAR szRasSetEntryProperties[] = "RasSetEntryPropertiesW";
static const CHAR szRasGetEntryProperties[] = "RasGetEntryPropertiesW";
static const CHAR szRasEnumEntries[] =        "RasEnumEntriesW";
static const CHAR szRasSetCredentials[] =     "RasSetCredentialsW";
#else  // !UNICODE
static const CHAR szRasGetCountryInfo[] =     "RasGetCountryInfoA";
static const CHAR szRasEnumDevices[] =        "RasEnumDevicesA";
static const CHAR szRasValidateEntryName[] =  "RasValidateEntryNameA";
static const CHAR szRasGetErrorString[] =     "RasGetErrorStringA";
static const CHAR szRasGetEntryDialParams[] = "RasGetEntryDialParamsA";
static const CHAR szRasSetEntryDialParams[] = "RasSetEntryDialParamsA";
static const CHAR szRasSetEntryProperties[] = "RasSetEntryPropertiesA";
static const CHAR szRasGetEntryProperties[] = "RasGetEntryPropertiesA";
static const CHAR szRasEnumEntries[] =        "RasEnumEntriesA";
static const CHAR szRasSetCredentials[] =     "RasSetCredentialsA";
#endif // !UNICODE


//////////////////////////////////////////////////////
// Config api function names
//////////////////////////////////////////////////////
static const CHAR szDoGenInstall[] =                "DoGenInstall";
static const CHAR szGetSETUPXErrorText[] =          "GetSETUPXErrorText";
static const CHAR szIcfgSetInstallSourcePath[] =    "IcfgSetInstallSourcePath";
static const CHAR szIcfgInstallInetComponents[] =   "IcfgInstallInetComponents";
static const CHAR szIcfgNeedInetComponents[] =      "IcfgNeedInetComponents";
static const CHAR szIcfgIsGlobalDNS[] =             "IcfgIsGlobalDNS";
static const CHAR szIcfgRemoveGlobalDNS[] =         "IcfgRemoveGlobalDNS";
static const CHAR szIcfgTurnOffFileSharing[] =      "IcfgTurnOffFileSharing";
static const CHAR szIcfgIsFileSharingTurnedOn[] =   "IcfgIsFileSharingTurnedOn";
static const CHAR szIcfgGetLastInstallErrorText[] = "IcfgGetLastInstallErrorText";
static const CHAR szIcfgStartServices[] =           "IcfgStartServices";
//
// Available only on NT icfg32.dll
//
static const CHAR szIcfgNeedModem[] =               "IcfgNeedModem";
static const CHAR szIcfgInstallModem[] =            "IcfgInstallModem";



//////////////////////////////////////////////////////
// misc strings
//////////////////////////////////////////////////////
static const TCHAR sz0[]  =       TEXT("0");
static const TCHAR sz1[]  =        TEXT("1");
static const TCHAR szNull[] =       TEXT("");
static const TCHAR szSlash[] =       TEXT("\\");
static const TCHAR szNOREBOOT[] =    TEXT("/NOREBOOT");
static const TCHAR szUNINSTALL[] =     TEXT("/UNINSTALL");
static const TCHAR szNOMSN[] =    TEXT("/NOMSN");
static const TCHAR szFmtAppendIntToString[] =  TEXT("%s %d");
static const TCHAR szDefaultAreaCode[] = TEXT("555");
static const TCHAR szNOIMN[] =    TEXT("/NOIMN");

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\strings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  STRINGS.H - Header file for hard-coded strings
//

//  HISTORY:
//  
//  12/22/94  jeremys Created.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the implementation of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also removed RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the implementation of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/03/25  markdu  Removed szDefAreaCode.
//  96/04/24  markdu  NASH BUG 19289 Added /NOMSN command line flag
//

#ifndef _STRINGS_H_
#define _STRINGS_H_

// registry strings
extern const TCHAR szRegPathInternetSettings[];
extern const TCHAR szTCPGlobalKeyName[];
extern const TCHAR szRegValRNAWizard[];
extern const TCHAR szRegPathRNAWizard[];
extern const TCHAR szRegValHostName[];
extern const TCHAR szRegValInternetProfile[];
extern const TCHAR szRegValBkupInternetProfile[];
extern const TCHAR szRegValEnableAutodial[];
extern const TCHAR szRegValNoNetAutodial[];
extern const TCHAR szRegValEnableSecurityCheck[];
extern const TCHAR szRegValAccessMedium[];
extern const TCHAR szRegValAccessType[];
extern const TCHAR szRegPathWarningFlags[];
extern const TCHAR szRegValDisableDNSWarning[];
extern const TCHAR szRegValInstalledMSN105[];
extern const TCHAR szRegPathOptComponents[];
extern const TCHAR szRegPathMSNetwork105[];
extern const TCHAR szRegValInstalled[];

//	//10/24/96 jmazner Normandy 6968
//	//No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.
extern const TCHAR szRegPathInternetIconCommand[];

extern const TCHAR szRegPathIexploreAppPath[];
extern const TCHAR szRegPathNameSpace[];
extern const TCHAR szRegKeyInternetIcon[];
extern const TCHAR szRegPathMailApp[];
extern const TCHAR szRegPathNewsApp[];
extern const TCHAR szRegPathICWSettings[];
extern const TCHAR szRegValICWCompleted[];
extern const TCHAR szRegValShellNext[];
extern const TCHAR szICWShellNextFlag[];

extern const TCHAR cszRegPathXInternetSignup[];
extern const TCHAR cszRegPathAppPaths[];
extern const TCHAR cszPath[];
extern const TCHAR cszInstallationDirectory[];

extern const TCHAR szICWSmartStartFlag[];

extern const TCHAR szFullICWFileName[];
extern const TCHAR szManualICWFileName[];
extern const TCHAR szISignupICWFileName[];

extern const TCHAR szRegIEAKSettings[];
extern const TCHAR szREgIEAKNeededKey[];
extern const TCHAR szPathSubKey[];
extern const TCHAR szIEAKSignupFilename[];


// mailnews api function names
extern const CHAR szSetDefaultMailHandler[];
extern const CHAR szSetDefaultNewsHandler[];

// MAPI api function names
extern const CHAR szMAPIInitialize[];
extern const CHAR szMAPIUninitialize[];
extern const CHAR szMAPIAdminProfiles[];
extern const CHAR szMAPIAllocateBuffer[];
extern const CHAR szMAPIFreeBuffer[];
extern const CHAR szHrQueryAllRows[];

// RNA api function names
extern const CHAR szRasGetCountryInfo[];
extern const CHAR szRasEnumDevices[];
extern const CHAR szRasValidateEntryName[];
extern const CHAR szRasValidateEntryNameA[];
extern const CHAR szRasGetErrorString[];
extern const CHAR szRasGetEntryDialParams[];
extern const CHAR szRasSetEntryDialParams[];
extern const CHAR szRasSetEntryProperties[];
extern const CHAR szRasGetEntryProperties[];
extern const CHAR szRasEnumEntries[];
extern const CHAR szRasSetCredentials[];

// Config api function names
extern const CHAR szDoGenInstall[];          
extern const CHAR szGetSETUPXErrorText[];    
extern const CHAR szIcfgSetInstallSourcePath[];  
extern const CHAR szIcfgInstallInetComponents[];        
extern const CHAR szIcfgNeedInetComponents[];           
extern const CHAR szIcfgIsGlobalDNS[];  
extern const CHAR szIcfgRemoveGlobalDNS[];    
extern const CHAR szIcfgTurnOffFileSharing[];  
extern const CHAR szIcfgIsFileSharingTurnedOn[];         
extern const CHAR szIcfgGetLastInstallErrorText[];         
extern const CHAR szIcfgStartServices[];
//
// Available only on NT icfg32.dll
//
extern const CHAR szIcfgNeedModem[];
extern const CHAR szIcfgInstallModem[];


// misc strings
extern const TCHAR sz0[];
extern const TCHAR sz1[];
extern const TCHAR szNull[];
extern const TCHAR szSlash[];
extern const TCHAR szNOREBOOT[];
extern const TCHAR szUNINSTALL[];
extern const TCHAR szNOMSN[];
extern const TCHAR szFmtAppendIntToString[];
extern const TCHAR szDefaultAreaCode[];
extern const TCHAR szNOIMN[];

#endif // _STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\tcpcfg.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  TCPCFG.C - Functions to read and set TCP/IP configuration
//

//  HISTORY:
//  
//  11/27/94  jeremys  Created.
//  96/02/29  markdu  Replaced call to RNAGetIPInfo with call to 
//            GetIPInfo in rnacall.c
//  96/03/23  markdu  Removed Get/ApplyInstanceTcpInfo functions.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/25  markdu  Removed connectoid name parameter from 
//            Get/ApplyGlobalTcpInfo functions since they should not
//            be setting per-connectoid stuff anymore.
//            Renamed ApplyGlobalTcpInfo to ClearGlobalTcpInfo, and 
//            changed function to just clear the settings.
//            Renamed GetGlobalTcpInfo to IsThereGlobalTcpInfo, and
//            changed function to just get the settings.
//  96/04/04  markdu  Added pfNeedsRestart to WarnIfServerBound, and
//            added function RemoveIfServerBound.
//  96/04/23  markdu  NASH BUG 18748 Initialize reboot variable before
//            returning.
//  96/05/26  markdu  Use lpTurnOffFileSharing and lpIsFileSharingTurnedOn.
//

#include "wizard.h"

extern ICFGTURNOFFFILESHARING     lpIcfgTurnOffFileSharing;
extern ICFGISFILESHARINGTURNEDON  lpIcfgIsFileSharingTurnedOn;

/*******************************************************************

  NAME:    WarnIfServerBound

  SYNOPSIS:  Checks to see if file server (VSERVER) is bound
        to TCP/IP instance used for Internet.  If so,
        warns the user and recommends that she let us
        remove the binding.  Removes the binding if user
        gives go-ahead.

  ENTRY:    hDlg - parent window
        dwCardFlags - an INSTANCE_xxx flag to specify what
          card type to check server-TCP/IP bindings for
          pfNeedsRestart - set to TRUE if we need a restart

  NOTES:    This is important because if we don't unbind server
        from instances of TCP/IP we install, user could be
        inadvertently sharing files over the Internet.

        Calls worker function DetectModifyTCPIPBindings to
        do work.

********************************************************************/
HRESULT WarnIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart)
{
  HRESULT err = ERROR_SUCCESS;

  //  96/04/23  markdu  NASH BUG 18748 Initialize reboot variable before
  //            returning.
  // Default to no restart.
  ASSERT(pfNeedsRestart);
  *pfNeedsRestart = FALSE;

  // this function may get called more than once (to guarantee we
  // call it regardless of how pages are navigated), set a flag
  // so we don't warn user more than once
  static BOOL fWarned = FALSE;
  if (fWarned)
  {
    return ERROR_SUCCESS;
  }
  
  // check to see if file server is bound to TCP/IP instance used
  // to connect to the internet
  BOOL  fSharingOn;
  HRESULT hr = lpIcfgIsFileSharingTurnedOn(INSTANCE_PPPDRIVER, &fSharingOn);

  //
  // 5/12/97 jmazner Olympus #3442  IE #30886
  // TEMP TODO at the moment, icfgnt doesn't implement FileSharingTurnedOn
  // Until it does, assume that on NT file sharing is always off.
  //
  if( IsNT() )
  {
	  DEBUGMSG("Ignoring return code from IcfgIsFileSharingTurnedOn");
	  fSharingOn = FALSE;
  }


  if ((ERROR_SUCCESS == hr) && (TRUE == fSharingOn))
  {
    // if so, warn the user and ask if we should remove it
    BUFFER Msg(MAX_RES_LEN+1);  // allocate buffer for part of message
    ASSERT(Msg);
    if (!Msg)
    {
      return ERROR_NOT_ENOUGH_MEMORY;  // out of memory
    }

    // message is long and takes 2 strings, so load the 2nd resource and
    // use it as an insertable parameter into the first string
    LoadSz(IDS_WARN_SERVER_BOUND1,Msg.QueryPtr(),Msg.QuerySize());
    if (MsgBoxParam(hDlg,IDS_WARN_SERVER_BOUND,MB_ICONEXCLAMATION,MB_YESNO,
      Msg.QueryPtr()) == IDYES)
    {
      // remove the binding
      err = lpIcfgTurnOffFileSharing(dwCardFlags, hDlg);
      ASSERT(err == ERROR_SUCCESS);
      if (ERROR_SUCCESS == err)
      {
        // We need to restart.
        *pfNeedsRestart = TRUE;
      }
    }
  }

  fWarned = TRUE;
  return err;
}

/*******************************************************************

  NAME:    RemoveIfServerBound

  SYNOPSIS:  Checks to see if file server (VSERVER) is bound
        to TCP/IP instance used for Internet.  If so,
        informs the user that we cannot continue unless we
        remove the binding.  Removes the binding if user
        gives go-ahead.

  ENTRY:    hDlg - parent window
        dwCardFlags - an INSTANCE_xxx flag to specify what
          card type to check server-TCP/IP bindings for
          pfNeedsRestart - set to TRUE if we need a restart

  NOTES:    This is important because if we don't unbind server
        from instances of TCP/IP we install, user could be
        inadvertently sharing files over the Internet.

        Calls worker function DetectModifyTCPIPBindings to
        do work.

********************************************************************/
HRESULT RemoveIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart)
{
  HRESULT err = ERROR_SUCCESS;

  // Default to no restart.
  ASSERT(pfNeedsRestart);
  *pfNeedsRestart = FALSE;

  // check to see if file server is bound to TCP/IP instance used
  // to connect to the internet
  BOOL  fSharingOn;
  HRESULT hr = lpIcfgIsFileSharingTurnedOn(INSTANCE_PPPDRIVER, &fSharingOn);

  if ((ERROR_SUCCESS == hr) && (TRUE == fSharingOn))
  {
    // if so, warn the user and ask if we should remove it
    BUFFER Msg(MAX_RES_LEN+1);  // allocate buffer for part of message
    ASSERT(Msg);
    if (!Msg)
    {
      return ERROR_NOT_ENOUGH_MEMORY;  // out of memory
    }

    // message is long and takes 2 strings, so load the 2nd resource and
    // use it as an insertable parameter into the first string
    LoadSz(IDS_REMOVE_SERVER_BOUND1,Msg.QueryPtr(),Msg.QuerySize());
    if (MsgBoxParam(hDlg,IDS_REMOVE_SERVER_BOUND,MB_ICONEXCLAMATION,MB_OKCANCEL,
      Msg.QueryPtr()) == IDOK)
    {
      // remove the binding
      err = lpIcfgTurnOffFileSharing(dwCardFlags, hDlg);
      ASSERT(err == ERROR_SUCCESS);
      if (ERROR_SUCCESS == err)
      {
        // We need to restart.
        *pfNeedsRestart = TRUE;
      }
    }
    else
    {
      // user cancelled.
      err = ERROR_CANCELLED;
    }
  }

  return err;
}


#define FIELD_LEN 3
#define NUM_FIELDS 4
/*******************************************************************

  NAME:    IPStrToLong

  SYNOPSIS:  Translates a text string to a numeric IPADDRESS

  ENTRY:    pszAddress - text string with ip address
        pipAddress - IPADDRESS to translate into

  EXIT:    TRUE if successful, FALSE if the string is invalid

  NOTES:    borrowed from net setup TCP/IP UI

********************************************************************/
BOOL IPStrToLong(LPCTSTR pszAddress,IPADDRESS * pipAddress)
{
    LPTSTR pch = (LPTSTR) pszAddress;
    TCHAR szField[FIELD_LEN+1];
    int nFields = 0;
    int nFieldLen = 0;
    BYTE nFieldVal[NUM_FIELDS];
    BOOL fContinue = TRUE;

  ASSERT(pszAddress);
  ASSERT(pipAddress);

    *pipAddress = (IPADDRESS) 0;

  // retrieve the numeric value for each of the four fields
    while (fContinue) {

        if (!(*pch)) fContinue = FALSE;

        if (*pch == '.' || !*pch) {
            if (nFields >= NUM_FIELDS) return FALSE;  // invalid pszAddress
            *(szField+nFieldLen) = '\0';    // null-terminate
      UINT uFieldVal = (UINT) myatoi(szField);  // convert string to int
      if (uFieldVal > 255)
        return FALSE;  // field is > 255, invalid
            nFieldVal[nFields] = (BYTE) uFieldVal;
            nFields++;
            nFieldLen = 0;
            pch++;
        } else {
      if (! ((*pch >= '0') && (*pch <= '9')) )
        return FALSE;  // non-numeric character, invalid pszAddress
            *(szField + nFieldLen) = *pch;
            nFieldLen++;
            pch++;
            if (nFieldLen > FIELD_LEN) return FALSE;    // invalid pszAddress
        }
    }

    if (nFields < NUM_FIELDS) return FALSE; // invalid szAddress

  // build an address from the fields
  *pipAddress = (IPADDRESS)MAKEIPADDRESS(nFieldVal[0],nFieldVal[1],nFieldVal[2],
        nFieldVal[3]);

    return TRUE;
}


/*******************************************************************

  NAME:    IPLongToStr

  SYNOPSIS:  Translates a single numeric IP address to a text string

  ENTRY:    ipAddress - numeric IP address to translate from
        pszAddress - buffer for translated string
        cbAddress - size of pszAddress buffer

  EXIT:    TRUE if successful, FALSE if the buffer is too short

  NOTES:    borrowed from net setup TCP/IP UI

********************************************************************/
BOOL IPLongToStr(IPADDRESS ipAddress,LPTSTR pszAddress,UINT cbAddress)
{
  ASSERT(pszAddress);

  if (cbAddress < IP_ADDRESS_LEN + 1)
    return FALSE;

    wsprintf(pszAddress,TEXT("%u.%u.%u.%u"),
        (BYTE) (ipAddress>>24),(BYTE) (ipAddress>>16),
        (BYTE) (ipAddress>>8), (BYTE) ipAddress);

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\tcpcmn.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  TCPCMN.H - central header file for TCP/IP structures and configuration
//         functions
//

//  HISTORY:
//  
//  12/6/94    jeremys  Created.
//  96/03/23  markdu  Removed Get/ApplyInstanceTcpInfo functions.
//  96/03/23  markdu  Removed TCPINFO struct and TCPINSTANCE struct.
//  96/03/25  markdu  Removed connectoid name parameter from 
//            Get/ApplyGlobalTcpInfo functions since they should not
//            be setting per-connectoid stuff anymore.
//            Renamed ApplyGlobalTcpInfo to ClearGlobalTcpInfo, and 
//            changed function to just clear the settings.
//            Renamed GetGlobalTcpInfo to IsThereGlobalTcpInfo, and
//            changed function to just get the settings.
//            Removed TCPGLOBAL struct,
//  96/04/04  markdu  Added pfNeedsRestart to WarnIfServerBound, and
//            added function RemoveIfServerBound.
//

#ifndef _TCPCMN_H_
#define _TCPCMN_H_

typedef DWORD IPADDRESS;

// same limits as in net setup UI
#define IP_ADDRESS_LEN          15    // big enough for www.xxx.yyy.zzz
#define MAX_GATEWAYS      8
#define MAX_DNSSERVER      3

// big enough for <ip>,<ip>,...
#define MAX_DNSSERVERLEN    MAX_DNSSERVER * (IP_ADDRESS_LEN+1)
#define MAX_GATEWAYLEN      MAX_GATEWAYS * (IP_ADDRESS_LEN+1)

// functions in TCPCFG.C
HRESULT WarnIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart);
HRESULT RemoveIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart);
BOOL IPStrToLong(LPCTSTR pszAddress,IPADDRESS * pipAddress);
BOOL IPLongToStr(IPADDRESS ipAddress,LPTSTR pszAddress,UINT cbAddress);

// dwGet/ApplyFlags bits for GetInstanceTCPInfo / ApplyInstanceTCPInfo:
// use INSTANCE_NETDRIVER, INSTANCE_PPPDRIVER, INSTANCE_ALL defined in wizglob.h

#define MAKEIPADDRESS(b1,b2,b3,b4)  ((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

// node type flags for _dwNodeFlags
#define NT_DRIVERNODE  0x0001
#define NT_ENUMNODE    0x0002

class ENUM_TCP_INSTANCE
{
private:
  DWORD       _dwCardFlags;  // INSTANCE_NETDRIVER, INSTANCE_PPPDRIVER, etc
  DWORD      _dwNodeFlags;  // NT_DRIVERNODE, NT_ENUMNODE, etc
  UINT       _error;
  HKEY       _hkeyTcpNode;
  VOID      CloseNode();
public:
  ENUM_TCP_INSTANCE(DWORD dwCardFlags,DWORD dwNodeFlags);
  ~ENUM_TCP_INSTANCE();
  HKEY Next();
  UINT GetError()  { return _error; }
};


#endif  // _TCPCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\wizthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\uninstal.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UNINSTAL.C - code to uninstall MSN
//

//  HISTORY:
//  
//  6/22/95  jeremys    Created.
//

#include "wizard.h"

extern DOGENINSTALL lpDoGenInstall;

/*******************************************************************

  NAME:    DoUninstall

  SYNOPSIS:  Uninstalls MSN1.05 if we installed it in the past,
        and it's still installed

********************************************************************/
BOOL DoUninstall(VOID)
{
  BOOL fRet = TRUE;
  BOOL fNeedToRemoveMSN105 = FALSE;
  // check registry entry to see if we installed MSN1.05

  RegEntry re(szRegPathInternetSettings,HKEY_LOCAL_MACHINE);
  ASSERT(re.GetError() == ERROR_SUCCESS);

  if (re.GetError() == ERROR_SUCCESS) {

    if (re.GetNumber(szRegValInstalledMSN105,0) > 0) {

      // yes, we installed MSN1.05.  now see if it's still installed.

      RegEntry reSetup(szRegPathOptComponents,HKEY_LOCAL_MACHINE);
      ASSERT(reSetup.GetError() == ERROR_SUCCESS);
      reSetup.MoveToSubKey(szRegPathMSNetwork105);
      ASSERT(reSetup.GetError() == ERROR_SUCCESS);
      if (reSetup.GetError() == ERROR_SUCCESS) {
        TCHAR szInstalledVal[10];  // big enough for "1"
        if (reSetup.GetString(szRegValInstalled,szInstalledVal,
          sizeof(szInstalledVal))
          && !lstrcmpi(szInstalledVal,sz1)) {

          // yes, MSN1.05 is still installed.  we need to remove it.
          fNeedToRemoveMSN105 = TRUE;
        }
      }
    }
  }

  if (fNeedToRemoveMSN105) {
    // warn user that this will remove MSN!
    int iRet=MsgBox(NULL,IDS_WARNWillRemoveMSN,MB_ICONEXCLAMATION,MB_OKCANCEL);
    if (iRet == IDOK) {

      TCHAR szInfFilename[SMALL_BUF_LEN+1];
      TCHAR szInfSectionName[SMALL_BUF_LEN+1];

      DEBUGMSG("Uninstalling MSN 1.05");

      // load file name and section name out of resources
      LoadSz(IDS_MSN105_INF_FILE,szInfFilename,sizeof(szInfFilename));
      LoadSz(IDS_MSN105_UNINSTALL_SECT,szInfSectionName,
        sizeof(szInfSectionName));
      // call GenInstall to remove files, do registry edits, etc.
      RETERR err = lpDoGenInstall(NULL,szInfFilename,szInfSectionName);

      if (err == OK) {
        DEBUGMSG("Uninstalling MSN 1.0");

        // load file name and section name out of resources
        LoadSz(IDS_MSN100_INF_FILE,szInfFilename,sizeof(szInfFilename));
        LoadSz(IDS_MSN100_UNINSTALL_SECT,szInfSectionName,
          sizeof(szInfSectionName));
        // call GenInstall to remove files, do registry edits, etc.
        RETERR err = lpDoGenInstall(NULL,szInfFilename,szInfSectionName);
      }

      if (err != OK) {
        DisplayErrorMessage(NULL,IDS_ERRUninstallMSN,err,ERRCLS_SETUPX,
          MB_ICONEXCLAMATION);
        fRet = FALSE;
      } else {
        // remove our registry marker that we installed MSN 1.05
        re.DeleteValue(szRegValInstalledMSN105);
      }

    }
  }

  // remove the Internet icon from the desktop.  To do this, we have to
  // delete a registry key (not a value!).  Plus! setup won't
  // do this from their .inf file, they can only delete values.  So we
  // have to write some actual code here to remove the key.

  // open the name space key.  The key we want to remove is a subkey
  // of this key.

	//	//10/24/96 jmazner Normandy 6968
	//	//No longer neccessary thanks to Valdon's hooks for invoking ICW.
	// 11/21/96 jmazner Normandy 11812
	// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
	// ICW 1.1 needs to morph the IE 3 icon.

  RegEntry reNameSpace(szRegPathNameSpace,HKEY_LOCAL_MACHINE);
  ASSERT(reNameSpace.GetError() == ERROR_SUCCESS);
  if (reNameSpace.GetError() == ERROR_SUCCESS) {
    // delete the subkey that causes the internet icon to appear
    RegDeleteKey(reNameSpace.GetKey(),szRegKeyInternetIcon);
  }

  return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\tcpui.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  TCPUI.C - Functions for Wizard TCP/IP pages
//      
//

//  HISTORY:
//  
//  1/9/95    jeremys    Created.
//  96/03/10  markdu    Made all TCP/IP stuff be per-connectoid.
//  96/03/11  markdu    Set RASEO_ flags for ip and dns addresses.
//  96/03/22  markdu  Remove IP setup from LAN path.
//  96/03/23  markdu  Remove all LAN path leftovers.
//  96/03/23  markdu  Removed ReadTCPIPSettings.
//  96/03/25  markdu  If a fatal error occurs, set gfQuitWizard.
//  96/03/26  markdu  Store values from UI even when back is pressed.
//  96/04/04  markdu  Added pfNeedsRestart to WarnIfServerBound
//  96/04/06  markdu  Moved CommitConfigurationChanges call to last page.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//  96/05/16  markdu  NASH BUG 21810 Perform same IP address validation as RNA.
//

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"

VOID EnableDNSAddressControls(HWND hDlg);
VOID EnableIPControls(HWND hDlg);
VOID DisplayInvalidIPAddrMsg(HWND hDlg,UINT uCtrl,TCHAR * pszAddr);

/*******************************************************************

  NAME:    EnableIPControls

  SYNOPSIS:  If "Use DHCP" is checked, disables controls for
        specific IP selection; if not, enables them.

********************************************************************/
VOID EnableIPControls(HWND hDlg)
{
  BOOL fDHCP = IsDlgButtonChecked(hDlg,IDC_USE_DHCP);
  
  EnableDlgItem(hDlg,IDC_IP_ADDR_LABEL,!fDHCP);
  EnableDlgItem(hDlg,IDC_IPADDR,!fDHCP);
  EnableDlgItem(hDlg,IDC_TX_IPADDR,!fDHCP);
}


/*******************************************************************

  NAME:    IPAddressInitProc

  SYNOPSIS:  Called when IP address page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK IPAddressInitProc(HWND hDlg,BOOL fFirstInit)
{
  TCHAR szAddr[IP_ADDRESS_LEN+1];

  if (fFirstInit)
  {
    // limit IP address control text lengths
    SendDlgItemMessage(hDlg,IDC_IPADDR,EM_LIMITTEXT,IP_ADDRESS_LEN,0L);
  }

  // check either the "use DHCP" or "use specific IP" buttons.
  // if IP address is set to 0.0.0.0, that means use DHCP.
  // (The "0.0.0.0 == DHCP" convention is used by the TCP/IP
  // VxDs, we might as well play along.)
  BOOL fDHCP = (gpRasEntry->dwfOptions & RASEO_SpecificIpAddr) ? FALSE : TRUE;
  CheckDlgButton(hDlg,(IDC_USE_DHCP),fDHCP);
  CheckDlgButton(hDlg,(IDC_USE_IP),!fDHCP);

  // set the IP address in dialog control

  // 11/25/96	jmazner	Normandy #10222
  // don't use return value of DwFromIa as basis of deciding whether or
  // not to fill in IP address field; rely only on the SpecificIPAddr flag.
  //if ((gpRasEntry->dwfOptions & RASEO_SpecificIpAddr) &&
  //  DwFromIa(&gpRasEntry->ipaddr))

  if (gpRasEntry->dwfOptions & RASEO_SpecificIpAddr)
  {
    IPLongToStr(DwFromIa(&gpRasEntry->ipaddr),
      szAddr,sizeof(szAddr));
    SetDlgItemText(hDlg,IDC_IPADDR,szAddr);
  }
  else
  {
    SetDlgItemText(hDlg,IDC_IPADDR,szNull);
  }

  // enable IP address controls appropriately
  EnableIPControls(hDlg);

  return TRUE;
}

/*******************************************************************

  NAME:    IPAddressOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from IP address page

  ENTRY:    hDlg - dialog window

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK IPAddressOKProc(HWND hDlg)
{
  ASSERT(puNextPage);

  // check the radio buttons to determine if DHCP or not
  BOOL fDHCP = IsDlgButtonChecked(hDlg,IDC_USE_DHCP);

  if (fDHCP)
  {
    // for DHCP, set IP address to 0.0.0.0
    CopyDw2Ia(0, &gpRasEntry->ipaddr);

    // Turn off Specific IP address flag
    gpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;    
  }
  else
  {
    TCHAR  szAddr[IP_ADDRESS_LEN+1];
    DWORD dwAddr;

    // get IP address
    GetDlgItemText(hDlg,IDC_IPADDR,szAddr,sizeof(szAddr)+1);
    if (!lstrlen(szAddr))
    {
      // IP address field is blank, warn user and stay on this page
      DisplayFieldErrorMsg(hDlg,IDC_IPADDR,IDS_NEED_IPADDR);
       return FALSE;
    }

	//
	// 5/17/97	jmazner Olympus #137
	// check for DBCS chars.
	//

#if !defined(WIN16)
	if (!IsSBCSString(szAddr))
	{
		DisplayFieldErrorMsg(hDlg,IDC_IPADDR,IDS_SBCSONLY);
		return FALSE;
	}
#endif


    // convert text to numeric address
    if (IPStrToLong(szAddr,&dwAddr))
    {
      CopyDw2Ia(dwAddr, &gpRasEntry->ipaddr);
      //  96/05/16  markdu  NASH BUG 21810 Perform same IP address validation as RNA.
/*    if (!FValidIa(&gpRasEntry->ipaddr))
      {
        // IP address field is invalid, warn user and stay on this page
        DisplayInvalidIPAddrMsg(hDlg,IDC_IPADDR,szAddr);
         return FALSE;
      }
*/
    }
    else
    {
       // conversion failed, the string is not valid
       DisplayInvalidIPAddrMsg(hDlg,IDC_IPADDR,szAddr);
       return FALSE;
    }
    
    // Turn on Specific IP address flag
    gpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;    
  }

  return TRUE;
}

/*******************************************************************

  NAME:    IPAddressCmdProc

  SYNOPSIS:  Called when dlg control pressed on IP address page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK IPAddressCmdProc(HWND hDlg,UINT uCtrlID)
{
  switch (uCtrlID) {

    case IDC_USE_DHCP:
    case IDC_USE_IP:
      // if radio buttons pushed, enable IP controls appropriately
      EnableIPControls(hDlg);
      break;
  }

  return TRUE;
}


/*******************************************************************

  NAME:    EnableDNSAddressControls

  SYNOPSIS:  If static DNS address is checked, enable controls to
            enter DNS addresses.  If not, disable them.

********************************************************************/
VOID EnableDNSAddressControls(HWND hDlg)
{
  BOOL fEnable = IsDlgButtonChecked(hDlg,IDC_STATIC_DNS);
  
  EnableDlgItem(hDlg,IDC_DNSADDR1,fEnable);
  EnableDlgItem(hDlg,IDC_DNSADDR2,fEnable);
  EnableDlgItem(hDlg,IDC_TX_DNSADDR1,fEnable);
  EnableDlgItem(hDlg,IDC_TX_DNSADDR2,fEnable);
  EnableDlgItem(hDlg,IDC_PRIM_LABEL,fEnable);
  EnableDlgItem(hDlg,IDC_SEC_LABEL,fEnable);
}


/*******************************************************************

  NAME:    DNSAddressInitProc

  SYNOPSIS:  Called when DNS page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK DNSAddressInitProc(HWND hDlg,BOOL fFirstInit)
{
  if (fFirstInit)
  {
    // if file server is bound to instance of TCP/IP that will be
    // used to access the internet, warn user and remove
    BOOL  fTemp;
    WarnIfServerBound(hDlg, INSTANCE_PPPDRIVER, &fTemp);
    if (TRUE == fTemp)
    {
      gpWizardState->fNeedReboot = TRUE;
    }

    // limit DNS address control text lengths
    SendDlgItemMessage(hDlg,IDC_DNSADDR1,EM_LIMITTEXT,IP_ADDRESS_LEN,0L);
    SendDlgItemMessage(hDlg,IDC_DNSADDR2,EM_LIMITTEXT,IP_ADDRESS_LEN,0L);

	// set radio buttons
	CheckDlgButton(hDlg,IDC_AUTO_DNS,gpUserInfo->fAutoDNS);
	CheckDlgButton(hDlg,IDC_STATIC_DNS,!gpUserInfo->fAutoDNS);
  }

  TCHAR szAddr[IP_ADDRESS_LEN+1];

  // set primary DNS server

  // 11/25/96	jmazner	Normandy #10222
  // don't use return value of DwFromIa as basis of deciding whether or
  // not to fill in IP address field; rely only on the SpecificNameServers flag.
  //if ((gpRasEntry->dwfOptions & RASEO_SpecificNameServers) &&
  //  DwFromIa(&gpRasEntry->ipaddrDns))

  if (gpRasEntry->dwfOptions & RASEO_SpecificNameServers)
  {
	  IPLongToStr(DwFromIa(&gpRasEntry->ipaddrDns),
       szAddr,sizeof(szAddr));
	  SetDlgItemText(hDlg,IDC_DNSADDR1,szAddr);
  }
  else
  {
    SetDlgItemText(hDlg,IDC_DNSADDR1,szNull);
  }

  // set backup DNS server
  // 11/25/96	jmazner	Normandy #10222
  //if ((gpRasEntry->dwfOptions & RASEO_SpecificNameServers) &&
  //  DwFromIa(&gpRasEntry->ipaddrDnsAlt))

  if (gpRasEntry->dwfOptions & RASEO_SpecificNameServers)
  {
     IPLongToStr(DwFromIa(&gpRasEntry->ipaddrDnsAlt),
       szAddr,sizeof(szAddr));
    SetDlgItemText(hDlg,IDC_DNSADDR2,szAddr);
  }
  else
  {
    SetDlgItemText(hDlg,IDC_DNSADDR2,szNull);
  }

  EnableDNSAddressControls(hDlg);

  return TRUE;
}

/*******************************************************************

  NAME:    DNSAddressOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from DNS address page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK DNSAddressOKProc(HWND hDlg)
{
  ASSERT(puNextPage);

  UINT uServers = 0;
  TCHAR szAddr[IP_ADDRESS_LEN+1];
  DWORD dwAddr;

  gpUserInfo->fAutoDNS = IsDlgButtonChecked(hDlg, IDC_AUTO_DNS);
  if (gpUserInfo->fAutoDNS)
  {
	  // Turn off Specific Name servers address flag
	  gpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
  }
  else
  {
	  // get primary DNS server address
	  GetDlgItemText(hDlg,IDC_DNSADDR1,szAddr,sizeof(szAddr)+1);
	  if (lstrlen(szAddr))
	  {
		//
		// 5/17/97	jmazner Olympus #137
		// check for DBCS chars.
		//

#if !defined(WIN16)
		if (!IsSBCSString(szAddr))
		{
			DisplayFieldErrorMsg(hDlg,IDC_DNSADDR1,IDS_SBCSONLY);
			return FALSE;
		}
#endif

		// convert text to numeric address
		if (IPStrToLong(szAddr,&dwAddr))
		{
		  CopyDw2Ia(dwAddr, &gpRasEntry->ipaddrDns);
		  //  96/05/16  markdu  NASH BUG 21810 Perform same IP address validation as RNA.
/*		  if (!FValidIaOrZero(&gpRasEntry->ipaddrDns))
		  {
			// DNS address field is invalid, warn user and stay on this page
			DisplayInvalidIPAddrMsg(hDlg,IDC_DNSADDR1,szAddr);
			 return FALSE;
		  }
*/
		}
		else
		{
			// conversion failed, the string is not valid
			DisplayInvalidIPAddrMsg(hDlg,IDC_DNSADDR1,szAddr);
			return FALSE;
		}
		uServers++;
	  }
	  else
	  {
		  CopyDw2Ia(0, &gpRasEntry->ipaddrDns);
	  }

	  // get alternate DNS server address
	  GetDlgItemText(hDlg,IDC_DNSADDR2,szAddr,sizeof(szAddr)+1);
	  if (lstrlen(szAddr))
	  {
		//
		// 5/17/97	jmazner Olympus #137
		// check for DBCS chars.
		//

#if !defined(WIN16)
		if (!IsSBCSString(szAddr))
		{
			DisplayFieldErrorMsg(hDlg,IDC_DNSADDR2,IDS_SBCSONLY);
			return FALSE;
		}
#endif

		// convert text to numeric address
		if (IPStrToLong(szAddr,&dwAddr))
		{
		  CopyDw2Ia(dwAddr, &gpRasEntry->ipaddrDnsAlt);
		  //  96/05/16  markdu  NASH BUG 21810 Perform same IP address validation as RNA.
/*		  if (!FValidIaOrZero(&gpRasEntry->ipaddrDnsAlt))
		  {
			// DNS address field is invalid, warn user and stay on this page
			DisplayInvalidIPAddrMsg(hDlg,IDC_DNSADDR2,szAddr);
			 return FALSE;
		  }
*/
		}
		else
		{
			// conversion failed, the string is not valid
			DisplayInvalidIPAddrMsg(hDlg,IDC_DNSADDR2,szAddr);
			return FALSE;
		}
		uServers++;
	  }
	  else
	  {
		  CopyDw2Ia(0, &gpRasEntry->ipaddrDnsAlt);
	  }
  
	  if (uServers)
	  {
		// Turn on Specific name servers
		gpRasEntry->dwfOptions |= RASEO_SpecificNameServers;    
	  }
	  else
	  {
		  // no DNS servers entered, warn user (but let her proceed if
		  // she really wants to)
		  if (!WarnFieldIsEmpty(hDlg,IDC_DNSADDR1,IDS_WARN_EMPTY_DNS))
			return FALSE;  // user heeded warning, stay on this page

		// Turn off Specific Name servers address flag
		gpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
	  }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    DNSAddressCmdProc

  SYNOPSIS:  Called when dlg control pressed on DNS address page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK DNSAddressCmdProc(HWND hDlg,UINT uCtrlID)
{
  switch (uCtrlID) {

    case IDC_AUTO_DNS:
    case IDC_STATIC_DNS:
      // if radio buttons pushed, enable IP controls appropriately
      EnableDNSAddressControls(hDlg);
      break;
  }

  return TRUE;
}


/*******************************************************************

  NAME:    DisplayInvalidIPAddrMsg

  SYNOPSIS:  Displays a message that the address the user typed
        is invalid and adds a tip on who to contact if they
        don't know what address to type

********************************************************************/
VOID DisplayInvalidIPAddrMsg(HWND hDlg,UINT uCtrl,TCHAR * pszAddr)
{
  MsgBoxParam(hDlg,IDS_INVALID_IPADDR,MB_ICONINFORMATION,MB_OK,
    pszAddr);
  SetFocus(GetDlgItem(hDlg,uCtrl));
  SendDlgItemMessage(hDlg,uCtrl,EM_SETSEL,0,-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\wizard.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  WIZARD.H - central header file for Internet setup/signup wizard
//

//  HISTORY:
//  
//  11/20/94  jeremys  Created.
//  96/02/24  markdu  Added RNAPH.H
//  96/02/27  markdu  Replaced internal RNA header files with RAS.H
//  96/03/07  markdu  Added gpEnumModem
//  96/03/09  markdu  Moved all rnacall function prototypes to rnacall.h
//  96/03/09  markdu  Added gpRasEntry
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//  96/04/24  markdu  NASH BUG 19289 Added /NOMSN command line flag
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#ifndef _WIZARD_H_
#define _WIZARD_H_

#define STRICT                      // Use strict handle types
#define _SHELL32_

#ifdef DEBUG
// component name for debug spew
#define SZ_COMPNAME "INETWIZ: "
#endif // DEBUG

#include <windows.h>                
#include <windowsx.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <inetreg.h>
#include <oharestr.h>

  // various RNA header files
#pragma pack(8)
  #include <ras.h>
  #include <ras2.h>
#pragma pack()
  #include <raserror.h>
//  #include <rnaph.h>
  #include "rnacall.h"

  #include <wizglob.h>
  #include <wizdebug.h>

  #include <shlobj.h>
//  #include <shsemip.h>

#undef DATASEG_READONLY  
#define DATASEG_READONLY  ".rdata"
#include <stdio.h>                

#include "icwunicd.h"

#include "inetcfg.h"
#include "cfgapi.h"
#include "clsutil.h"
#include "tcpcmn.h"
#include "mapicall.h"
#include "wizdef.h"
#include "icfgcall.h"
#include "ids.h"
#include "strings.h"
#include "icwcmn.h"

// Terminology: ISP - Internet Service Provider

// Globals

extern LPRASENTRY   gpRasEntry;     // pointer to RASENTRY struct to hold all data
extern DWORD        gdwRasEntrySize;// bytes allocated for gpRasEntry
extern ENUM_MODEM*  gpEnumModem;    // modem enumeration object
extern HINSTANCE    ghInstance;     // global module instance handle
extern USERINFO*    gpUserInfo;     // global user information 
extern WIZARDSTATE* gpWizardState;  // global wizard state
extern BOOL         gfQuitWizard;   // global flag used to signal that we
                                    // want to terminate the wizard ourselves
extern BOOL gfFirstNewConnection;	// first time the user selected new connection
extern BOOL gfUserFinished;			// user finished wizard
extern BOOL gfUserBackedOut;		// user click back on first page
extern BOOL gfUserCancelled;		// user cancalled wizard
extern BOOL gfOleInitialized;

extern BOOL g_fAcctMgrUILoaded;
//extern BOOL	g_MailUIAvailable, g_NewsUIAvailable, g_DirServUIAvailable;

extern BOOL    g_fIsExternalWizard97;
extern BOOL    g_fIsWizard97;
extern BOOL    g_fIsICW;

extern BOOL   g_bReboot;            //used to signify that we  should reboot  - MKarki 5/2/97 - Fix for Bug #3111
extern BOOL   g_bRebootAtExit;      //used to signify that we  should reboot when exit
extern BOOL   g_bSkipMultiModem;
extern BOOL   g_bUseAutoProxyforConnectoid;

// Defines

// error class defines for DisplayErrorMessage
#define ERRCLS_STANDARD 0x0001
#define ERRCLS_SETUPX   0x0002
#define ERRCLS_RNA      0x0003
#define ERRCLS_MAPI     0x0004

// flags for RunSignupWizard
#define RSW_NOREBOOT    0x0001
#define RSW_UNINSTALL   0x0002
#define RSW_NOMSN       0x0004
#define RSW_NOINIT      0x0008
#define RSW_NOFREE      0x0010
#define RSW_NOIMN       0x0020

//#define RSW_MAILACCT    0x0100
//#define RSW_NEWSACCT    0x0200
//#define	RSW_DIRSERVACCT	0x0400
#define	RSW_APPRENTICE	0x0100

#define OK        0    // success code for SETUPX class errors

// 11/25/96	jmazner Normandy #10586
#define WM_MYINITDIALOG	WM_USER

// Modem specific info
#define ISIGNUP_KEY TEXT("Software\\Microsoft\\ISIGNUP")
#define DEVICENAMEKEY TEXT("DeviceName")
#define DEVICETYPEKEY TEXT("DeviceType")

// functions in PROPMGR.C
BOOL InitWizard(DWORD dwFlags, HWND hwndParent = NULL);
BOOL DeinitWizard(DWORD dwFlags);
BOOL RunSignupWizard(DWORD dwFlags, HWND hwndParent = NULL);
VOID GetDefaultUserName(TCHAR * pszUserName,DWORD cbUserName);
void ProcessDBCS(HWND hDlg, int ctlID);
#if !defined(WIN16)
BOOL IsSBCSString( TCHAR *sz );
#endif

// functions in CALLOUT.C
UINT InvokeModemWizard(HWND hwndToHide);

// functions in UTIL.C
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
// jmazner 11/6/96	modified for RISC compatability
//int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...);
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons, LPTSTR szParam = NULL);

LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);
BOOL EnableDlgItem(HWND hDlg,UINT uID,BOOL fEnable);

// modified for RISC compatability
//VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
//  UINT uErrorClass,UINT uIcon,...);
VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,LPTSTR szArg = NULL);
BOOL WarnFieldIsEmpty(HWND hDlg,UINT uCtrlID,UINT uStrID);
BOOL TweakAutoRun(BOOL bEnable);
VOID DisplayFieldErrorMsg(HWND hDlg,UINT uCtrlID,UINT uStrID);
VOID GetErrorDescription(TCHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass);
VOID SetBackupInternetConnectoid(LPCTSTR pszEntryName);
UINT myatoi (TCHAR * szVal);
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent);
BOOL GetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf, DWORD dwSize);

//	//10/24/96 jmazner Normandy 6968
//	//No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.
BOOL SetDesktopInternetIconToBrowser(VOID);

// 11/11/96 jmazner Normandy 7623
BOOL IsDialableString( LPTSTR szBuff );

//
// 6/6/97 jmazner Olympus #5413
//
#ifdef WIN32
VOID Win95JMoveDlgItem( HWND hwndParent, HWND hwndItem, int iUp );
#endif

// functions in MAPICALL.C
BOOL InitMAPI(HWND hWnd);
VOID DeInitMAPI(VOID);
HRESULT SetMailProfileInformation(MAILCONFIGINFO * pMailConfigInfo);
BOOL FindInternetMailService(TCHAR * pszEmailAddress,DWORD cbEmailAddress,
  TCHAR * pszEmailServer, DWORD cbEmailServer);

// functions in INETAPI.C
BOOL DoDNSCheck(HWND hwndParent,BOOL * pfNeedRestart);

// functions in UNINSTALL.C
BOOL DoUninstall(VOID);

// structure for getting proc addresses of api functions
typedef struct APIFCN {
  PVOID * ppFcnPtr;
  LPCSTR pszName;   // Proc name. Don't be wide char.
} APIFCN;

// user preference defines for registry
#define USERPREF_MODEM      0x0001
#define USERPREF_LAN      0x0002

#define ACCESSTYPE_MSN      0x0001
#define ACCESSTYPE_OTHER_ISP  0x0002

#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT    DATASEG_SHARED

inline BOOL IsNT(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}

inline BOOL IsNT5(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return ((VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId) && (OsVersionInfo.dwMajorVersion >= 5));
}

inline BOOL IsWin95(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return ((VER_PLATFORM_WIN32_WINDOWS == OsVersionInfo.dwPlatformId) && (0 == OsVersionInfo.dwMinorVersion));
}

inline BOOL IsNT4SP3Lower(void)
{
	OSVERSIONINFO os;
	os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		
	GetVersionEx(&os);

	if(os.dwPlatformId != VER_PLATFORM_WIN32_NT)
        return FALSE;

    // Exclude NT5 or higher
    if(os.dwMajorVersion > 4)
        return FALSE;

	if(os.dwMajorVersion < 4)
        return TRUE;

	// version 4.0
	if ( os.dwMinorVersion > 0)
        return FALSE;		// assume that sp3 is not needed for nt 4.1 or higher

	int nServicePack;
	if(_stscanf(os.szCSDVersion, TEXT("Service Pack %d"), &nServicePack) != 1)
        return TRUE;

	if(nServicePack < 4)
        return TRUE;
	return FALSE;
}

//
// 7/21/97 jmazner Olympus #9903
// we only want this version of inetcfg to work with the corresponding
// version of other icwconn1 components.  If an older icw component tries to
// load this dll, we should fail -- gracefully
#define ICW_MINIMUM_MAJOR_VERSION (UINT) 4
#define ICW_MINIMUM_MINOR_VERSION (UINT) 71
#define ICW_MINIMUM_VERSIONMS (DWORD) ((ICW_MINIMUM_MAJOR_VERSION << 16) | ICW_MINIMUM_MINOR_VERSION)

//
// in util.cpp
//
extern BOOL GetFileVersion(LPTSTR lpszFilePath, PDWORD pdwVerNumMS, PDWORD pdwVerNumLS);
extern BOOL IsParentICW10( void );
extern void SetICWRegKeysToPath( LPTSTR lpszICWPath );
extern void GetICW11Path( TCHAR szPath[MAX_PATH + 1], BOOL *fPathSetTo11 );

typedef BOOL (WINAPI *PFNInitCommonControlsEx)(LPINITCOMMONCONTROLSEX);

#endif // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  12/21/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//            Need to keep a modified SetInternetConnectoid to set the
//            MSN backup connectoid.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//

#include "wizard.h"
#if 0
#include "string.h"
#endif

#define MAX_MSG_PARAM     8


#include "winver.h"
BOOL GetIEVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS);
// IE 4 has major.minor version 4.71
// IE 3 golden has major.minor.release.build version # > 4.70.0.1155
// IE 2 has major.minor of 4.40
#define IE4_MAJOR_VERSION (UINT) 4
#define IE4_MINOR_VERSION (UINT) 71
#define IE4_VERSIONMS (DWORD) ((IE4_MAJOR_VERSION << 16) | IE4_MINOR_VERSION)


// function prototypes
VOID _cdecl FormatErrorMessage(TCHAR * pszMsg,DWORD cbMsg,TCHAR * pszFmt,LPTSTR szArg);
extern VOID GetRNAErrorText(UINT uErr,TCHAR * pszErrText,DWORD cbErrText);
extern VOID GetMAPIErrorText(UINT uErr,TCHAR * pszErrText,DWORD cbErrText);
extern GETSETUPXERRORTEXT lpGetSETUPXErrorText;
#ifdef WIN32
VOID Win95JMoveDlgItem( HWND hwndParent, HWND hwndItem, int iUp );
#endif

void GetCmdLineToken(LPTSTR *ppszCmd,LPTSTR pszOut);

#define NUMICWFILENAMES	4
TCHAR  *g_ppszICWFileNames[NUMICWFILENAMES] = { TEXT("ICWCONN1.EXE\0"),
						TEXT("ISIGNUP.EXE\0"),
						TEXT("INETWIZ.EXE\0"),
						TEXT("ICWCONN2.EXE\0") };



/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    TCHAR szMsgBuf[MAX_RES_LEN+1];
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];

    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    LoadSz(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];
  LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

/*******************************************************************

  NAME:    MsgBoxParam

  SYNOPSIS:  Displays a message box with the specified string ID

  NOTES:    //extra parameters are string pointers inserted into nMsgID.
			jmazner 11/6/96 For RISC compatability, we don't want
			to use va_list; since current source code never uses more than
			one string parameter anyways, just change function signature
			to explicitly include that one parameter.

********************************************************************/
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,LPTSTR szParam)
{
  BUFFER Msg(3*MAX_RES_LEN+1);  // nice n' big for room for inserts
  BUFFER MsgFmt(MAX_RES_LEN+1);
  //va_list args;

  if (!Msg || !MsgFmt) {
    return MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONSTOP,MB_OK);
  }

    LoadSz(nMsgID,MsgFmt.QueryPtr(),MsgFmt.QuerySize());

  //va_start(args,uButtons);
  //FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
  //  MsgFmt.QueryPtr(),args);
	FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
		MsgFmt.QueryPtr(),szParam);

  return MsgBoxSz(hWnd,Msg.QueryPtr(),uIcon,uButtons);
}

BOOL EnableDlgItem(HWND hDlg,UINT uID,BOOL fEnable)
{
    return EnableWindow(GetDlgItem(hDlg,uID),fEnable);
}

/*******************************************************************

  NAME:    LoadSz

  SYNOPSIS:  Loads specified string resource into buffer

  EXIT:    returns a pointer to the passed-in buffer

  NOTES:    If this function fails (most likely due to low
        memory), the returned buffer will have a leading NULL
        so it is generally safe to use this without checking for
        failure.

********************************************************************/
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
  ASSERT(lpszBuf);

  // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

/*******************************************************************

  NAME:    GetErrorDescription

  SYNOPSIS:  Retrieves the text description for a given error code
        and class of error (standard, setupx)

********************************************************************/
VOID GetErrorDescription(TCHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass)
{
  ASSERT(pszErrorDesc);

  // set a leading null in error description
  *pszErrorDesc = '\0';
  
  switch (uErrorClass) {

    case ERRCLS_STANDARD:

      if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,
        uError,0,pszErrorDesc,cbErrorDesc,NULL)) {
        // if getting system text fails, make a string a la
        // "error <n> occurred"
        TCHAR szFmt[SMALL_BUF_LEN+1];
        LoadSz(IDS_ERRFORMAT,szFmt,sizeof(szFmt));
        wsprintf(pszErrorDesc,szFmt,uError);
      }

      break;

    case ERRCLS_SETUPX:

      lpGetSETUPXErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    case ERRCLS_RNA:

      GetRNAErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    case ERRCLS_MAPI:

      GetMAPIErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    default:

      DEBUGTRAP("Unknown error class %lu in GetErrorDescription",
        uErrorClass);

  }

}
  
/*******************************************************************

  NAME:    FormatErrorMessage

  SYNOPSIS:  Builds an error message by calling FormatMessage

  NOTES:    Worker function for DisplayErrorMessage

********************************************************************/
VOID _cdecl FormatErrorMessage(TCHAR * pszMsg,DWORD cbMsg,TCHAR * pszFmt,LPTSTR szArg)
{
  ASSERT(pszMsg);
  ASSERT(pszFmt);

  // build the message into the pszMsg buffer
  DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
    pszFmt,0,0,pszMsg,cbMsg,(va_list*) &szArg);
  ASSERT(dwCount > 0);
}

/*******************************************************************

  NAME:    DisplayErrorMessage

  SYNOPSIS:  Displays an error message for given error 

  ENTRY:    hWnd - parent window
        uStrID - ID of string resource with message format.
          Should contain %1 to be replaced by error text,
          additional parameters can be specified as well.
        uError - error code for error to display
        uErrorClass - ERRCLS_xxx ID of class of error that
          uError belongs to (standard, setupx)
        uIcon - icon to display
        //... - additional parameters to be inserted in string
        //  specified by uStrID
		jmazner 11/6/96 change to just one parameter for
		RISC compatability.

********************************************************************/
VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,LPTSTR szArg)
{
  // dynamically allocate buffers for messages
  BUFFER ErrorDesc(MAX_RES_LEN+1);
  BUFFER ErrorFmt(MAX_RES_LEN+1);
  BUFFER ErrorMsg(2*MAX_RES_LEN+1);  

  if (!ErrorDesc || !ErrorFmt || !ErrorMsg) {
    // if can't allocate buffers, display out of memory error
    MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
    return;
  }

  // get a text description based on the error code and the class
  // of error it is
  GetErrorDescription(ErrorDesc.QueryPtr(),
    ErrorDesc.QuerySize(),uError,uErrorClass);

  // load the string for the message format
  LoadSz(uStrID,ErrorFmt.QueryPtr(),ErrorFmt.QuerySize());

  //LPSTR args[MAX_MSG_PARAM];
  //args[0] = (LPSTR) ErrorDesc.QueryPtr();
  //memcpy(&args[1],((TCHAR *) &uIcon) + sizeof(uIcon),(MAX_MSG_PARAM - 1) * sizeof(LPSTR));

  //FormatErrorMessage(ErrorMsg.QueryPtr(),ErrorMsg.QuerySize(),
  //  ErrorFmt.QueryPtr(),(va_list) &args[0]);
  FormatErrorMessage(ErrorMsg.QueryPtr(),ErrorMsg.QuerySize(),
    ErrorFmt.QueryPtr(),ErrorDesc.QueryPtr());


  // display the message
  MsgBoxSz(hWnd,ErrorMsg.QueryPtr(),uIcon,MB_OK);

}

/*******************************************************************

  NAME:    WarnFieldIsEmpty

  SYNOPSIS:  Pops up a warning message if the user tries to leave
        a page without filling out a text field and asks if she
        wants to continue.
        
  ENTRY:    hDlg - parent windows
        uCtrlID - ID of control left blank
        uStrID - ID of string resource with warning message

  EXIT:    returns TRUE if user wants to continue anyway, FALSE
        if user wants to stay on same page.

********************************************************************/
BOOL WarnFieldIsEmpty(HWND hDlg,UINT uCtrlID,UINT uStrID)
{
  // warn the user
  if (MsgBox(hDlg,uStrID,MB_ICONEXCLAMATION,
    MB_YESNO | MB_DEFBUTTON2) == IDNO) {
    // user chose no, wants to stay on same page

    // set focus to control in question
    SetFocus(GetDlgItem(hDlg,uCtrlID));
    return FALSE;
  }

  return TRUE;
}

BOOL TweakAutoRun(BOOL bEnable)
{
    HKEY  hKey        = NULL;
    DWORD dwType      = 0;
    DWORD dwSize      = 0;
    DWORD dwVal       = 0;
    BOOL  bWasEnabled = FALSE;

    RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"), 0, KEY_ALL_ACCESS, &hKey);
    if (hKey)
    {
        RegQueryValueEx(hKey, (LPTSTR)TEXT("NoDriveTypeAutoRun"), 0, &dwType, (LPBYTE)&dwVal, &dwSize);
        RegQueryValueEx(hKey, (LPTSTR)TEXT("NoDriveTypeAutoRun"), 0, &dwType, (LPBYTE)&dwVal, &dwSize);

        if (dwVal & DRIVE_CDROM)
            bWasEnabled = TRUE;

        if (bEnable)
            dwVal |= DRIVE_CDROM;
        else
            dwVal &=~DRIVE_CDROM;
        
        RegSetValueEx(hKey, (LPTSTR)TEXT("NoDriveTypeAutoRun"), 0, dwType,  (LPBYTE)&dwVal, dwSize);

        CloseHandle(hKey);
    }
    return bWasEnabled;
}

/*******************************************************************

  NAME:    DisplayFieldErrorMsg

  SYNOPSIS:  Pops up a warning message about a field, sets focus to
        the field and selects any text in it.

  ENTRY:    hDlg - parent windows
        uCtrlID - ID of control left blank
        uStrID - ID of string resource with warning message

********************************************************************/
VOID DisplayFieldErrorMsg(HWND hDlg,UINT uCtrlID,UINT uStrID)
{
  MsgBox(hDlg,uStrID,MB_ICONEXCLAMATION,MB_OK);
  SetFocus(GetDlgItem(hDlg,uCtrlID));
  SendDlgItemMessage(hDlg,uCtrlID,EM_SETSEL,0,-1);
}

/*******************************************************************

  NAME:    SetBackupInternetConnectoid

  SYNOPSIS:  Sets the name of the backup connectoid used to autodial to the
        Internet

  ENTRY:    pszEntryName - name of connectoid to set.  If NULL,
          then the registry entry is removed.

  NOTES:    sets value in registry

********************************************************************/
VOID SetBackupInternetConnectoid(LPCTSTR pszEntryName)
{
  RegEntry re(szRegPathRNAWizard,HKEY_CURRENT_USER);
  if (re.GetError() == ERROR_SUCCESS)
  {
    if (pszEntryName)
    {
      re.SetValue(szRegValBkupInternetProfile,pszEntryName);
    }
    else
    {
       re.DeleteValue(szRegValBkupInternetProfile);
    }
  }
}

/*******************************************************************

  NAME:    myatoi

  SYNOPSIS:  Converts numeric string to numeric value

  NOTES:    implementation of atoi to avoid pulling in C runtime

********************************************************************/
UINT myatoi (TCHAR * szVal)
{
    TCHAR * lpch;
    WORD wDigitVal=1,wTotal=0;

    for (lpch = szVal + lstrlen(szVal)-1; lpch >= szVal ; lpch --,
        wDigitVal *= 10)
  if ( *lpch >= '0' && *lpch <= '9')
            wTotal += (*lpch - '0') * wDigitVal;

    return (UINT) wTotal;
}

/*******************************************************************

  NAME:    MsgWaitForMultipleObjectsLoop

  SYNOPSIS:  Blocks until the specified object is signaled, while
        still dispatching messages to the main thread.

********************************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent)
{
    MSG msg;
    DWORD dwObject;
    while (1)
    {
        // NB We need to let the run dialog become active so we have to half handle sent
        // messages but we don't want to handle any input events or we'll swallow the
        // type-ahead.
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE,INFINITE, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
      // got a message, dispatch it and wait again
      while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) {
        DispatchMessage(&msg);
      }
            break;
        }
    }
    // never gets here
}


/*******************************************************************

//	//10/24/96 jmazner Normandy 6968
//	//No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.

  NAME:    SetDesktopInternetIconToBrowser

  SYNOPSIS:  "Points" The Internet desktop icon to web browser
        (Internet Explorer)

  NOTES:    For IE 3, the Internet icon may initially "point" at this wizard,
        we need to set it to launch web browser once we complete
        successfully.

********************************************************************/
BOOL SetDesktopInternetIconToBrowser(VOID)
{
  TCHAR szAppPath[MAX_PATH+1]=TEXT("");
  BOOL fRet = FALSE;

  	DWORD dwVerMS, dwVerLS;

	if( !GetIEVersion( &dwVerMS, &dwVerLS ) ) 
	{
		return( FALSE );
	}

	if( (dwVerMS >= IE4_VERSIONMS) )
	{
		// we're dealing with IE 4, don't touch the icon stuff
		return( TRUE );
	}

  // look in the app path section in registry to get path to internet
  // explorer

  RegEntry reAppPath(szRegPathIexploreAppPath,HKEY_LOCAL_MACHINE);
  ASSERT(reAppPath.GetError() == ERROR_SUCCESS);
  if (reAppPath.GetError() == ERROR_SUCCESS) {

    reAppPath.GetString(szNull,szAppPath,sizeof(szAppPath));
    ASSERT(reAppPath.GetError() == ERROR_SUCCESS);

  }

  // set the path to internet explorer as the open command for the 
  // internet desktop icon
  if (lstrlen(szAppPath)) {
    RegEntry reIconOpenCmd(szRegPathInternetIconCommand,HKEY_CLASSES_ROOT);
    ASSERT(reIconOpenCmd.GetError() == ERROR_SUCCESS);
    if (reIconOpenCmd.GetError() == ERROR_SUCCESS) {
      UINT uErr = reIconOpenCmd.SetValue(szNull,szAppPath);
      ASSERT(uErr == ERROR_SUCCESS);
      
      fRet = (uErr == ERROR_SUCCESS);
    }
  }

  return fRet;
}



//+----------------------------------------------------------------------------
//
//	Function	IsDialableString
//
//	Synopsis	Determines whether a string has any non dialable characters.
//
//	Arguments	szBuff - the string to check.
//
//	Returns		TRUE is no chars other than 0123456789ABCDabcdPpTtWw!@$-.()+*#,& and <space>
//				FALSE otherwise.
//
//	History		11/11/96	jmazner	created for Normandy #7623
//
//-----------------------------------------------------------------------------
BOOL IsDialableString(LPTSTR szBuff)
{
	LPTSTR szDialableChars = TEXT("0123456789ABCDabcdPpTtWw!@$-.()+*#,& ");

	int i = 0;

	for( i = 0; szBuff[i]; i++ )
	{
		if( !_tcschr(szDialableChars, szBuff[i]) )
			return FALSE;
	}

	return TRUE;
}


//+----------------------------------------------------------------------------
//
//	Function:	GetIEVersion
//
//	Synopsis:	Gets the major and minor version # of the installed copy of Internet Explorer
//
//	Arguments:	pdwVerNumMS - pointer to a DWORD;
//				  On succesful return, the top 16 bits will contain the major version number,
//				  and the lower 16 bits will contain the minor version number
//				  (this is the data in VS_FIXEDFILEINFO.dwProductVersionMS)
//				pdwVerNumLS - pointer to a DWORD;
//				  On succesful return, the top 16 bits will contain the release number,
//				  and the lower 16 bits will contain the build number
//				  (this is the data in VS_FIXEDFILEINFO.dwProductVersionLS)
//
//	Returns:	TRUE - Success.  *pdwVerNumMS and LS contains installed IE version number
//				FALSE - Failure. *pdVerNumMS == *pdVerNumLS == 0
//
//	History:	jmazner		Created		8/19/96	(as fix for Normandy #4571)
//				jmazner		updated to deal with release.build as well 10/11/96
//				jmazner		stolen from isign32\isignup.cpp 11/21/96
//							(for Normandy #11812)
//
//-----------------------------------------------------------------------------
BOOL GetIEVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS)
{
	HRESULT hr;
	HKEY hKey = 0;
	LPVOID lpVerInfoBlock;
	VS_FIXEDFILEINFO *lpTheVerInfo;
	UINT uTheVerInfoSize;
	DWORD dwVerInfoBlockSize, dwUnused, dwPathSize;
	TCHAR szIELocalPath[MAX_PATH + 1] = TEXT("");


	*pdwVerNumMS = 0;
	*pdwVerNumLS = 0;

	// get path to the IE executable
	hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPathIexploreAppPath,0, KEY_READ, &hKey);
	if (hr != ERROR_SUCCESS) return( FALSE );

	dwPathSize = sizeof (szIELocalPath);
	hr = RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szIELocalPath, &dwPathSize);
	RegCloseKey( hKey );
	if (hr != ERROR_SUCCESS) return( FALSE );

	// now go through the convoluted process of digging up the version info
    dwVerInfoBlockSize = GetFileVersionInfoSize( szIELocalPath, &dwUnused );
	if ( 0 == dwVerInfoBlockSize ) return( FALSE );

	lpVerInfoBlock = GlobalAlloc( GPTR, dwVerInfoBlockSize );
	if( NULL == lpVerInfoBlock ) return( FALSE );

	if( !GetFileVersionInfo( szIELocalPath, NULL, dwVerInfoBlockSize, lpVerInfoBlock ) )
		return( FALSE );

	if( !VerQueryValue(lpVerInfoBlock, TEXT("\\"), (void **)&lpTheVerInfo, &uTheVerInfoSize) )
		return( FALSE );

	*pdwVerNumMS = lpTheVerInfo->dwProductVersionMS;
	*pdwVerNumLS = lpTheVerInfo->dwProductVersionLS;


	GlobalFree( lpVerInfoBlock );

	return( TRUE );
}


//+----------------------------------------------------------------------------
//
//	Function:	Win95JMoveDlgItem
//
//	Synopsis:	Moves a particular dialog item on a non-localized ICW
//				up or down on Win 95 J systems
//				to work around a w95J rendering glitch that mis-sizes our
//				wizard window.
//
//	Arguments:	hwndParent - Handle to parent window which contains the hwndItem
//				hwndItem -- Handle to dlg item to move
//				iUp -- number of units upward the item should be shifted.  A
//						negative value here implies that the item should be shifted
//						downward.
//
//	Returns:	VOID
//
//	History:	6/6/97	jmazner	Created for Olympus #5413
//				6/29/97	jmazner	Updated to only do this on English ICW (Oly #5413)
//				
//
//-----------------------------------------------------------------------------
#ifdef WIN32
DWORD GetBuildLCID();
VOID Win95JMoveDlgItem( HWND hwndParent, HWND hwndItem, int iUp )
{
	LCID LangID = 0x409; // default to English
	// 0x411 is Japanese

	
	LangID = GetUserDefaultLCID();

	//
	// IE v 4.1 bug 37072 ChrisK 8/19/97
	// The fix for 5413 incorrectly compared the primary language ID with the
	// full LCID for the build.  The result was 9 != x409 when it should have
	// been equal.  This fix was to use the primary language id from the build
	// instead of the full LCID
	//
	if( (0x411 == LangID) && 
		!(IsNT()) &&
		(LANG_ENGLISH == PRIMARYLANGID(GetBuildLCID())))
	{
		// assume that if it's Japanese, and it's not NT, it must be win95J!
		RECT itemRect;
		POINT thePoint;

		GetWindowRect(hwndItem, &itemRect);

		// need to convert the coords from global to local client,
		// since MoveWindow below will expext client coords.

		thePoint.x = itemRect.left;
		thePoint.y = itemRect.top;
		ScreenToClient(hwndParent, &thePoint );
		itemRect.left = thePoint.x;
		itemRect.top = thePoint.y;
		
		thePoint.x = itemRect.right;
		thePoint.y = itemRect.bottom;
		ScreenToClient(hwndParent, &thePoint );
		itemRect.right = thePoint.x;
		itemRect.bottom = thePoint.y;

		MoveWindow(hwndItem,
			itemRect.left,
			itemRect.top - iUp,
			(itemRect.right - itemRect.left),
			(itemRect.bottom - itemRect.top), TRUE);
	}
}

//+----------------------------------------------------------------------------
//
//	Function:	GetBuildLCID
//
//	Synopsis:	return the LCID of the file that this function resides in
//
//	Arguments:	none
//
//	Returns:	DWORD - LCID of the file or 0 if it failed
//
//	History:	ChrisK	6/25/97	Created
//				jmazner	6/29/97	Ported from Conn1 for Olympus 5413
//
//-----------------------------------------------------------------------------
DWORD GetBuildLCID()
{
	DWORD dw = 0;
	HMODULE hMod = NULL;
	TCHAR szFileName[MAX_PATH +1] = TEXT("\0uninit");
	DWORD dwSize = 0;
	LPVOID lpv = NULL;
	LPVOID lpvVerValue = NULL;
	UINT uLen = 0;
	DWORD dwRC = 0;

	DEBUGMSG("INETCFG: GetBuildLCID.\n");

	//
	// Get the name of this file
	//

	hMod = GetModuleHandle(NULL);
	if (NULL == hMod)
	{
		goto GetBuildLCIDExit;
	}

	if (0 == GetModuleFileName(hMod, szFileName, MAX_PATH))
	{
		goto GetBuildLCIDExit;
	}

	//
	// Get size and value of version structure
	//
	dwSize = GetFileVersionInfoSize(szFileName,&dw);
	if (0 == dwSize )
	{
		goto GetBuildLCIDExit;
	}

	lpv = (LPVOID)GlobalAlloc(GPTR, dwSize);
	if (NULL == lpv)
	{
		goto GetBuildLCIDExit;
	}

	if ( FALSE == GetFileVersionInfo(szFileName,0,dwSize,lpv))
	{
		goto GetBuildLCIDExit;
	}

	if ( 0 == VerQueryValue(lpv,TEXT("\\VarFileInfo\\Translation"),&lpvVerValue,&uLen))
	{
		goto GetBuildLCIDExit;
	}

	//
	// separate version information from character set
	//
	dwRC = (LOWORD(*(DWORD*)lpvVerValue));

GetBuildLCIDExit:
	if (NULL != lpv)
	{
		GlobalFree(lpv);
		lpv = NULL;
	}

	return dwRC;
}
#endif

//+----------------------------------------------------------------------------
//
//	Function:	GetCmdLineToken
//
//	Synopsis:	Returns the first token in a string
//
//	Arguements:
//		ppszCmd [in] -- pointer to head of string
//		ppszCmd [out] -- pointer to second token in string
//		pszOut [out] -- contains the first token in the passed in string.
//
//	Returns:	None
//
//	Notes:		Considers the space character ' ' to delineate tokens, but
//				treats anything between double quotes as one token.
//				For example, the following consists of five tokens:
//					first second "this is the third token" fourth "fifth"
//
//	History:	7/9/97	jmazner	stolen from icwconn1\connmain.cpp for #9170
//
//-----------------------------------------------------------------------------
void GetCmdLineToken(LPTSTR *ppszCmd,LPTSTR pszOut)
{
	TCHAR *c;
	int i = 0;
	BOOL fInQuote = FALSE;
	
	c = *ppszCmd;

	pszOut[0] = *c;
	if (!*c) return;
	if (*c == ' ') 
	{
		pszOut[1] = '\0';
		*ppszCmd = c+1;
		return;
	}
	else if( '"' == *c )
	{
		fInQuote = TRUE;
	}

NextChar:
	i++;
	c++;
	if( !*c || (!fInQuote && (*c == ' ')) )
	{
		pszOut[i] = '\0';
		*ppszCmd = c;
		return;
	}
	else if( fInQuote && (*c == '"') )
	{
		fInQuote = FALSE;
		pszOut[i] = *c;
		
		i++;
		c++;
		pszOut[i] = '\0';
		*ppszCmd = c;
		return;
	}
	else
	{
		pszOut[i] = *c;
		goto NextChar;
	}


}

//+----------------------------------------------------------------------------
//
//	Function:	ValidateProductSuite
//
//	Synopsis:	Check registry for a particular Product Suite string
//
//	Arguments:	SuiteName - name of product suite to look for
//
//	Returns:	TRUE - the suite exists
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
BOOL 
ValidateProductSuite(LPTSTR SuiteName)
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPTSTR ProductSuite = NULL;
    LPTSTR p;

	DEBUGMSG("INETCFG: ValidateProductSuite\n");
	//
	// Determine the size required to read registry values
	//
    Rslt = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
	{
        goto ValidateProductSuiteExit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        TEXT("ProductSuite"),
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) 
	{
        goto ValidateProductSuiteExit;
    }

    if (!Size) 
	{
        goto ValidateProductSuiteExit;
    }

    ProductSuite = (LPTSTR) GlobalAlloc( GPTR, Size );
    if (!ProductSuite) 
	{
        goto ValidateProductSuiteExit;
    }

	//
	// Read ProductSuite information
	//
    Rslt = RegQueryValueEx(
        hKey,
        TEXT("ProductSuite"),
        NULL,
        &Type,
        (LPBYTE) ProductSuite,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) 
	{
        goto ValidateProductSuiteExit;
    }

    if (Type != REG_MULTI_SZ) 
	{
        goto ValidateProductSuiteExit;
    }

	//
	// Look for a particular string in the data returned
	// Note: data is terminiated with two NULLs
	//
    p = ProductSuite;
    while (*p) {
        if (_tcsstr( p, SuiteName )) 
		{
            rVal = TRUE;
            break;
        }
        p += (lstrlen( p ) + 1);
    }

ValidateProductSuiteExit:
    if (ProductSuite) 
	{
        GlobalFree( ProductSuite );
    }

    if (hKey) 
	{
        RegCloseKey( hKey );
    }

    return rVal;
}


//+----------------------------------------------------------------------------
//
//	Function:	GetFileVersion
//
//	Synopsis:	Gets the major and minor version # of a file
//
//	Arguments:	pdwVerNumMS - pointer to a DWORD;
//				  On succesful return, the top 16 bits will contain the major version number,
//				  and the lower 16 bits will contain the minor version number
//				  (this is the data in VS_FIXEDFILEINFO.dwProductVersionMS)
//				pdwVerNumLS - pointer to a DWORD;
//				  On succesful return, the top 16 bits will contain the release number,
//				  and the lower 16 bits will contain the build number
//				  (this is the data in VS_FIXEDFILEINFO.dwProductVersionLS)
//
//	Returns:	TRUE - Success.  *pdwVerNumMS and LS contains version number
//				FALSE - Failure. *pdVerNumMS == *pdVerNumLS == 0
//
//	History:	jmazner		Created		8/19/96	(as fix for Normandy #4571)
//				jmazner		updated to deal with release.build as well 10/11/96
//				jmazner		7/22/97 ported from isign32 for bug 9903
//
//-----------------------------------------------------------------------------
BOOL GetFileVersion(LPTSTR lpszFilePath, PDWORD pdwVerNumMS, PDWORD pdwVerNumLS)
{
	HRESULT hr;
	HKEY hKey = 0;
	LPVOID lpVerInfoBlock;
	VS_FIXEDFILEINFO *lpTheVerInfo;
	UINT uTheVerInfoSize;
	DWORD dwVerInfoBlockSize, dwUnused, dwPathSize;
	DWORD fRet = TRUE;

	ASSERT( pdwVerNumMS );
	ASSERT( pdwVerNumLS );
	ASSERT( lpszFilePath );

	if( !pdwVerNumMS || !pdwVerNumLS || !lpszFilePath )
	{
		DEBUGMSG("GetFileVersion: invalid parameters!");
		return FALSE;
	}

	*pdwVerNumMS = 0;
	*pdwVerNumLS = 0;

	//
	// go through the convoluted process of digging up the version info
	//
    dwVerInfoBlockSize = GetFileVersionInfoSize( lpszFilePath, &dwUnused );
	if ( 0 == dwVerInfoBlockSize ) return( FALSE );

	lpVerInfoBlock = GlobalAlloc( GPTR, dwVerInfoBlockSize );
	if( NULL == lpVerInfoBlock ) return( FALSE );

	if( !GetFileVersionInfo( lpszFilePath, NULL, dwVerInfoBlockSize, lpVerInfoBlock ) )
	{
		fRet = FALSE;
		goto GetFileVersionExit;
	}

	if( !VerQueryValue(lpVerInfoBlock, TEXT("\\"), (void **)&lpTheVerInfo, &uTheVerInfoSize) )
	{
		fRet = FALSE;
		goto GetFileVersionExit;
	}

	*pdwVerNumMS = lpTheVerInfo->dwProductVersionMS;
	*pdwVerNumLS = lpTheVerInfo->dwProductVersionLS;

GetFileVersionExit:
	if( lpVerInfoBlock )
	{
		GlobalFree( lpVerInfoBlock );
		lpVerInfoBlock = NULL;
	}

	return( fRet );
}

//+----------------------------------------------------------------------------
//
//	Function:	ExtractFilenameFromPath
//
//	Synopsis:	Divides a full path into path and filename parts
//
//	Arguments:
//		szPath [in] -- fully qualified path and filename
//		lplpszFilename [in] -- pointer to a LPSTR.  On entry, the LPSTR
//							   to which it points should be NULL.
//		lplpszFilename [out] -- The LPSTR to which it points is set to the
//								first character of the filename in szPath.
//								
//
//	Returns:	FALSE - Parameters are invalid.
//				TRUE - Success.
//
//	History:	7/22/97	jmazner	Created for Olympus #9903
//
//-----------------------------------------------------------------------------
BOOL ExtractFilenameFromPath( TCHAR szPath[MAX_PATH + 1], LPTSTR *lplpszFilename )
{
	ASSERT( szPath[0] );
	ASSERT( lplpszFilename );
	ASSERT( *lplpszFilename == NULL );
	
	if( !szPath[0] || !lplpszFilename )
	{
		return FALSE;
	}

	//
	// extract the executable name from the full path
	//
	*lplpszFilename = &(szPath[ lstrlen(szPath) ]);
	while( ('\\' != **lplpszFilename) && (*lplpszFilename > szPath) )
	{

		*lplpszFilename = CharPrev( szPath, *lplpszFilename );
		
		ASSERT( *lplpszFilename > szPath );
	}

	
	//
	// now szFilename should point to the \, so do a char next.
	//
	if( '\\' == **lplpszFilename )
	{
		*lplpszFilename = CharNext( *lplpszFilename );
	}
	else
	{
		DEBUGMSG("ExtractFilenameFromPath: bogus path passed in, %s", szPath);
		return FALSE;
	}

	return TRUE;
}

//+----------------------------------------------------------------------------
//
//	Function:	IsParentICW10
//
//	Synopsis:	Determines whether the parent of this module is an ICW 1.0
//				executable (isignup, icwconn1, icwconn2 or inetwiz)
//
//	Arguments:	none
//
//	Returns:	TRUE - Parent module is an ICW 1.0 component
//				FALSE - Parent module is not an ICW 1.0 component, -or-
//						parent module could not be determined
//
//	History:	7/22/97	jmazner	Created for Olympus #9903
//
//-----------------------------------------------------------------------------
BOOL IsParentICW10( )
{
	HMODULE hParentModule = GetModuleHandle( NULL );
	LPTSTR lpszParentFullPath = NULL;
	LPTSTR lpszTemp = NULL;
	int	i = 0;
	BOOL fMatchFound = FALSE;
	BOOL fRet = FALSE;

	lpszParentFullPath = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH + 1);

	if( NULL == lpszParentFullPath )
	{
		DEBUGMSG("IsParentICW10 Out of memory!");
		goto IsParentICW10Exit;
	}

	GetModuleFileName( hParentModule, lpszParentFullPath, MAX_PATH );
	DEBUGMSG("IsParentICW10 parent module is %s", lpszParentFullPath);

	if( NULL == lpszParentFullPath[0] )
	{
		fRet = FALSE;
		goto IsParentICW10Exit;
	}

	ExtractFilenameFromPath( lpszParentFullPath, &lpszTemp );

	//
	// walk through the array of ICW binary names, see if anything matches
	//
	for( i = 0; i < NUMICWFILENAMES; i++ )
	{
		if ( 0 == lstrcmpi(g_ppszICWFileNames[i], lpszTemp) )
		{
			fMatchFound = TRUE;
			DEBUGMSG("IsParentICW10 Match found for %s", lpszTemp);
			break;
		}
	}

	if( !fMatchFound )
	{
		fRet = FALSE;
		goto IsParentICW10Exit;
	}
	else
	{
		//
		// we have one of the four binaries we're interested in; now check
		// its version number
		//
		DWORD dwMS = 0;
		DWORD dwLS = 0;
		GetFileVersion( lpszParentFullPath, &dwMS, &dwLS );
		DEBUGMSG("IsParentICW10: file version is %d.%d", HIWORD(dwMS), LOWORD(dwMS) );

		if( dwMS < ICW_MINIMUM_VERSIONMS )
		{
			fRet = TRUE;
		}
	}

IsParentICW10Exit:
	if( lpszParentFullPath )
	{
		GlobalFree( lpszParentFullPath );
		lpszParentFullPath = NULL;
	}

	return fRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	SetICWRegKeysToPath
//
//	Synopsis:	Sets all ICW reg keys to point to binaries in the given path
//
//	Arguments:	lpszICWPath -- pointer to a string containing the full path
//								to a directory containing ICW components
//
//	Returns:	void
//
//	Notes:		Sets the following reg keys:
//				HKCR\x-internet-signup\Shell\Open\command, (default)=[path]\isignup.exe %1
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN1.EXE, (default) = [path]\ICWCONN1.EXE
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN1.EXE, Path = [path];
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ISIGNUP.EXE, (default) = [path]\ISIGNUP.EXE
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ISIGNUP.EXE, Path = [path];
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\INETWIZ.EXE, (default) = [path]\INETWIZ.EXE
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\INETWIZ.EXE, Path = [path];
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN2.EXE, (default) = [path]\ICWCONN2.EXE
//				HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN2.EXE, Path = [path];
//
//	History:	7/22/97	jmazner	Created for Olympus #9903
//
//-----------------------------------------------------------------------------
void SetICWRegKeysToPath( LPTSTR lpszICWPath )
{
	DWORD dwResult = ERROR_SUCCESS;
	TCHAR szBuffer[MAX_PATH + 4];
	TCHAR szAppPathsBuffer[MAX_PATH + 1];
	TCHAR szThePath[MAX_PATH + 2];
	UINT i=0;

	ASSERT( lpszICWPath );

	if( !lpszICWPath )
	{
		DEBUGMSG("SetICWRegKeysToPath: invalid parameter!!");
		return;
	}

	//
	// make sure last character is neither \ nor ;
	//
	switch( lpszICWPath[lstrlen(lpszICWPath) - 1] )
	{
		case '\\':
		case ';':
			ASSERTSZ(0, "Path given to SetICWRegKeysToPath is a bit malformed!");
			lpszICWPath[lstrlen(lpszICWPath) - 1] = '\0';
	}


	//
	// HKCR\x-internet-signup\Shell\Open\command, (default)=path\isignup.exe %1
	//
	DEBUGMSG("SetICWRegKeysToPath: setting %s", cszRegPathXInternetSignup);
	lstrcpy( szBuffer, lpszICWPath );
	lstrcat( szBuffer, TEXT("\\") );
	lstrcat( szBuffer, szISignupICWFileName );
	lstrcat( szBuffer, TEXT(" %1"));
	RegEntry re(cszRegPathXInternetSignup,HKEY_CLASSES_ROOT);
	dwResult = re.GetError();
	if (ERROR_SUCCESS == dwResult)
	{
		re.SetValue(NULL, szBuffer);
		DEBUGMSG("SetICWRegKeysToPath: set %s, %s = %s (error %d)",
				 cszRegPathXInternetSignup, "(default)", szBuffer, re.GetError());
	}
	else
	{
		DEBUGMSG("SetICWRegKeysToPath: FAILED with %d: %s, NULL = %s",
				 dwResult, cszRegPathXInternetSignup, szBuffer);
	}


	//
	// HKLM\software\microsoft\windows\currentVersion\App Paths
	//
	DEBUGMSG("SetICWRegKeysToPath: setting %s", cszRegPathAppPaths);

	lstrcpy( szThePath, lpszICWPath );
	lstrcat( szThePath, TEXT(";") );


	for( i=0; i<NUMICWFILENAMES; i++ )
	{
		lstrcpy( szAppPathsBuffer, cszRegPathAppPaths );
		lstrcat( szAppPathsBuffer, TEXT("\\"));
		lstrcat( szAppPathsBuffer, g_ppszICWFileNames[i] );

		lstrcpy( szBuffer, lpszICWPath );
		lstrcat( szBuffer, TEXT("\\") );
		lstrcat( szBuffer, g_ppszICWFileNames[i] );

		RegEntry re(szAppPathsBuffer,HKEY_LOCAL_MACHINE);
		dwResult = re.GetError();
		if (ERROR_SUCCESS == dwResult)
		{
			re.SetValue(NULL, szBuffer);
			DEBUGMSG("SetICWRegKeysToPath: set %s, %s = %s (error %d)",
					 szAppPathsBuffer, TEXT("(default)"), szBuffer, re.GetError());

			re.SetValue(cszPath, szThePath);
			DEBUGMSG("SetICWRegKeysToPath: set %s, %s = %s (error %d)",
					 szAppPathsBuffer, cszPath, szThePath, re.GetError());

		}
		else
		{
			DEBUGMSG("SetICWRegKeysToPath: FAILED with %d: %s, NULL = %s",
					 dwResult, szAppPathsBuffer, szBuffer);
		}
	}

}

//+----------------------------------------------------------------------------
//
//	Function:	GetICW11Path
//
//	Synopsis:	Finds the path to the ICW 1.1 installation directory
//
//	Arguments:
//		szPath [out] -- on succesfull exit, contains path to ICW 1.1
//						directory.  Path does _not_ terminate in \ or ;
//		fPathSetTo11 [out] -- indicates whether the App Paths\ICWCONN1.EXE
//							  currently points to the ICW 1.1 installation
//							  directory
//								
//	Returns:
//		Function results are determined by looking at both parameters
//		szPath: "", *fPathSetTo11: FALSE indicates App Paths\Icwconn1 does not
//			currently point to 1.1 files, and that a path to the 1.1
//			files could not be determined
//
//		szPath: non-empty, *fPathSetTo11: FALSE indicates App Paths\ICWCONN1
//			does not currently point to 1.1 files.  The path to the 1.1 files
//			is contained in szPath
//
//		szPath: non-empty, *fPathSetTo11: TRUE indicates that App Path\ICWCONN1
//			currently points to 1.1 files.  The path to the files is contained
//			in szPath
//		
//
//	History:	7/22/97	jmazner	Created for Olympus #9903
//
//-----------------------------------------------------------------------------
void GetICW11Path( TCHAR szPath[MAX_PATH + 1], BOOL *fPathSetTo11 )
{
	TCHAR szAppPathsBuffer[MAX_PATH + 1];
	LPTSTR lpszTemp = NULL;
	DWORD dwResult = ERROR_SUCCESS;
	DWORD dwMS = 0;
	DWORD dwLS = 0;

	ASSERT( fPathSetTo11 );
	ASSERT( szPath );

	if( !fPathSetTo11 || !szPath )
	{
		DEBUGMSG("GetICW11Path: invalid parameter!");
		return;
	}

	ZeroMemory( szPath, sizeof(szPath) );
	*fPathSetTo11 = FALSE;

	//
	// first let's check whether the App Path for ICW is currently pointing
	// to the 1.1 files
	//
	lstrcpy( szAppPathsBuffer, cszRegPathAppPaths );
	lstrcat( szAppPathsBuffer, TEXT("\\"));
	lstrcat( szAppPathsBuffer, g_ppszICWFileNames[0] );

	RegEntry reICWAppPath(szAppPathsBuffer, HKEY_LOCAL_MACHINE);
	dwResult = reICWAppPath.GetError();
	if (ERROR_SUCCESS == dwResult)
	{
		reICWAppPath.GetString(NULL, szPath, sizeof(TCHAR)*(MAX_PATH + 1));
	}

	if( szPath[0] )
	{
		GetFileVersion( szPath, &dwMS, &dwLS );
		DEBUGMSG("GetICW11Path: reg key %s = %s, which has file version %d.%d",
				 szAppPathsBuffer, szPath, HIWORD(dwMS), LOWORD(dwMS) );

		if( dwMS >= ICW_MINIMUM_VERSIONMS )
		{
			//
			// App Path is already pointing to 1.1 binaries!
			//
			*fPathSetTo11 = TRUE;

			//
			// for completness' sake, strip the .exe name out of
			// szPath so that it will in fact contain just the path
			// to the ICW 1.1 files.
			ExtractFilenameFromPath( szPath, &lpszTemp );
			szPath[lstrlen(szPath) - lstrlen(lpszTemp) - 1] = '\0';

			//
			// return values:
			// szPath = path to ICW 1.1 binaries, no terminating \ or ;
			// fPathSetTo11 = TRUE
			//
			return;
		}
	}
	else
	{
		DEBUGMSG("GetICW11Path: unable to read current AppPath key %s", szAppPathsBuffer);
	}


	//
	// look for the Installation Directory value in
	// HKLM\Software\Microsoft\Internet Connection Wizard
	// If it's there, it should point to the directory where the
	// 1.1 binaries are installed.
	//
	RegEntry re11Path(szRegPathICWSettings, HKEY_LOCAL_MACHINE);
	dwResult = re11Path.GetError();
	if (ERROR_SUCCESS == dwResult)
	{
		re11Path.GetString(cszInstallationDirectory, szPath, sizeof(TCHAR)*(MAX_PATH + 1));
	}

	if( NULL == szPath[0] )
	{
		DEBUGMSG("GetICW11Path: unable to read reg key %s", szRegPathICWSettings);

		//
		// return values:
		// szPath = ""
		// fPathSetTo11 = FALSE
		//
		return;
	}
	else
	{
		DEBUGMSG("GetICW11Path: %s, %s = %s",
				 szRegPathICWSettings, cszInstallationDirectory, szPath);

		//
		// okay, we got a path -- now let's make sure that the thing
		// it points to is in fact a 1.1 binary.
		//

		//
		// chop off the terminating semicolon if it's there
		//
		if( ';' == szPath[ lstrlen(szPath) ] )
		{
			szPath[ lstrlen(szPath) ] = '\0';
		}

		//
		// do we have a terminating \ now? if not, add it in
		//
		if( '\\' != szPath[ lstrlen(szPath) ] )
		{
			lstrcat( szPath, TEXT("\\") );
		}

		//
		// add in a binary filename to use for the version check
		// (just use whatever's first in our filename array)
		//
		lstrcat( szPath, g_ppszICWFileNames[0] );

		//
		// now check the version number of the file
		//
		GetFileVersion( szPath, &dwMS, &dwLS );
		DEBUGMSG("GetICW11Path: %s has file version %d.%d",
				 szPath, HIWORD(dwMS), LOWORD(dwMS) );

		if( dwMS >= ICW_MINIMUM_VERSIONMS )
		{
			//
			// Yes, this path is valid!
			// now hack off the filename so that we're back to just a
			// path with no terminating \ or ;
			//
			ExtractFilenameFromPath( szPath, &lpszTemp );
			szPath[lstrlen(szPath) - lstrlen(lpszTemp) - 1] = '\0';

			//
			// return values:
			// szPath = path to ICW 1.1 binaries, no terminating \ or ;
			// fPathSetTo11 = FALSE
			//
			return;
		}
		else
		{
			DEBUGMSG("GetICW11Path  %s doesn't actually point to a 1.1 binary!",
					 szPath);
			szPath[0] = '\0';

			//
			// return values:
			// szPath = ""
			// fPathSetTo11 = FALSE
			//
			return;
		}

	}
}

#ifdef UNICODE
PWCHAR ToUnicodeWithAlloc
(
    LPCSTR  lpszSrc
)
{
    PWCHAR  lpWChar;
    INT     iLength = 0;
    DWORD   dwResult;

    if (lpszSrc == NULL)
    {
        return NULL;
    }

    iLength = MultiByteToWideChar(  CP_ACP,
                                    0,
                                    lpszSrc,
                                    -1,
                                    NULL,
                                    0 );

    if(iLength == 0)
        return NULL;

    
    lpWChar = (WCHAR *) GlobalAlloc( GPTR, sizeof(WCHAR) * iLength );
    if(!lpWChar)
        return NULL;

    dwResult = MultiByteToWideChar(  CP_ACP,
                                     0,
                                     lpszSrc,
                                     -1,
                                     lpWChar,
                                     iLength );
    if(!dwResult)
    {
        GlobalFree(lpWChar);
        return NULL;
    }

    return lpWChar;
}

VOID ToAnsiClientInfo
(
    LPINETCLIENTINFOA lpInetClientInfoA,
    LPINETCLIENTINFOW lpInetClientInfoW
)
{
    if(lpInetClientInfoW == NULL || lpInetClientInfoA == NULL)
        return;

    lpInetClientInfoA->dwSize        = lpInetClientInfoW->dwSize;
    lpInetClientInfoA->dwFlags       = lpInetClientInfoW->dwFlags;
    lpInetClientInfoA->iIncomingProtocol = lpInetClientInfoW->iIncomingProtocol;
    lpInetClientInfoA->fMailLogonSPA = lpInetClientInfoW->fMailLogonSPA;
    lpInetClientInfoA->fNewsLogonSPA = lpInetClientInfoW->fNewsLogonSPA;
    lpInetClientInfoA->fLDAPLogonSPA = lpInetClientInfoW->fLDAPLogonSPA;
    lpInetClientInfoA->fLDAPResolve  = lpInetClientInfoW->fLDAPResolve;

    wcstombs(lpInetClientInfoA->szEMailName,
             lpInetClientInfoW->szEMailName,
             MAX_EMAIL_NAME+1);
    wcstombs(lpInetClientInfoA->szEMailAddress,
             lpInetClientInfoW->szEMailAddress,
             MAX_EMAIL_ADDRESS+1);
    wcstombs(lpInetClientInfoA->szPOPLogonName,
             lpInetClientInfoW->szPOPLogonName,
             MAX_LOGON_NAME+1);
    wcstombs(lpInetClientInfoA->szPOPLogonPassword,
             lpInetClientInfoW->szPOPLogonPassword,
             MAX_LOGON_PASSWORD+1);
    wcstombs(lpInetClientInfoA->szPOPServer,
             lpInetClientInfoW->szPOPServer,
             MAX_SERVER_NAME+1);
    wcstombs(lpInetClientInfoA->szSMTPServer,
             lpInetClientInfoW->szSMTPServer,
             MAX_SERVER_NAME+1);
    wcstombs(lpInetClientInfoA->szNNTPLogonName,
             lpInetClientInfoW->szNNTPLogonName,
             MAX_LOGON_NAME+1);
    wcstombs(lpInetClientInfoA->szNNTPLogonPassword,
             lpInetClientInfoW->szNNTPLogonPassword,
             MAX_LOGON_PASSWORD+1);
    wcstombs(lpInetClientInfoA->szNNTPServer,
             lpInetClientInfoW->szNNTPServer,
             MAX_SERVER_NAME+1);
    wcstombs(lpInetClientInfoA->szNNTPName,
             lpInetClientInfoW->szNNTPName,
             MAX_EMAIL_NAME+1);
    wcstombs(lpInetClientInfoA->szNNTPAddress,
             lpInetClientInfoW->szNNTPAddress,
             MAX_EMAIL_ADDRESS+1);
    wcstombs(lpInetClientInfoA->szIncomingMailLogonName,
             lpInetClientInfoW->szIncomingMailLogonName,
             MAX_LOGON_NAME+1);
    wcstombs(lpInetClientInfoA->szIncomingMailLogonPassword,
             lpInetClientInfoW->szIncomingMailLogonPassword,
             MAX_LOGON_PASSWORD+1);
    wcstombs(lpInetClientInfoA->szIncomingMailServer,
             lpInetClientInfoW->szIncomingMailServer,
             MAX_SERVER_NAME+1);
    wcstombs(lpInetClientInfoA->szLDAPLogonName,
             lpInetClientInfoW->szLDAPLogonName,
             MAX_LOGON_NAME+1);
    wcstombs(lpInetClientInfoA->szLDAPLogonPassword,
             lpInetClientInfoW->szLDAPLogonPassword,
             MAX_LOGON_PASSWORD+1);
    wcstombs(lpInetClientInfoA->szLDAPServer,
             lpInetClientInfoW->szLDAPServer,
             MAX_SERVER_NAME+1);
}

VOID ToUnicodeClientInfo
(
    LPINETCLIENTINFOW lpInetClientInfoW,
    LPINETCLIENTINFOA lpInetClientInfoA
)
{
    if(lpInetClientInfoW == NULL || lpInetClientInfoA == NULL)
        return;

    lpInetClientInfoW->dwSize        = lpInetClientInfoA->dwSize;
    lpInetClientInfoW->dwFlags       = lpInetClientInfoA->dwFlags;
    lpInetClientInfoW->iIncomingProtocol = lpInetClientInfoA->iIncomingProtocol;
    lpInetClientInfoW->fMailLogonSPA = lpInetClientInfoA->fMailLogonSPA;
    lpInetClientInfoW->fNewsLogonSPA = lpInetClientInfoA->fNewsLogonSPA;
    lpInetClientInfoW->fLDAPLogonSPA = lpInetClientInfoA->fLDAPLogonSPA;
    lpInetClientInfoW->fLDAPResolve  = lpInetClientInfoA->fLDAPResolve;

    mbstowcs(lpInetClientInfoW->szEMailName,
             lpInetClientInfoA->szEMailName,
             lstrlenA(lpInetClientInfoA->szEMailName)+1);
    mbstowcs(lpInetClientInfoW->szEMailAddress,
             lpInetClientInfoA->szEMailAddress,
             lstrlenA(lpInetClientInfoA->szEMailAddress)+1);
    mbstowcs(lpInetClientInfoW->szPOPLogonName,
             lpInetClientInfoA->szPOPLogonName,
             lstrlenA(lpInetClientInfoA->szPOPLogonName)+1);
    mbstowcs(lpInetClientInfoW->szPOPLogonPassword,
             lpInetClientInfoA->szPOPLogonPassword,
             lstrlenA(lpInetClientInfoA->szPOPLogonPassword)+1);
    mbstowcs(lpInetClientInfoW->szPOPServer,
             lpInetClientInfoA->szPOPServer,
             lstrlenA(lpInetClientInfoA->szPOPServer)+1);
    mbstowcs(lpInetClientInfoW->szSMTPServer,
             lpInetClientInfoA->szSMTPServer,
             lstrlenA(lpInetClientInfoA->szSMTPServer)+1);
    mbstowcs(lpInetClientInfoW->szNNTPLogonName,
             lpInetClientInfoA->szNNTPLogonName,
             lstrlenA(lpInetClientInfoA->szNNTPLogonName)+1);
    mbstowcs(lpInetClientInfoW->szNNTPLogonPassword,
             lpInetClientInfoA->szNNTPLogonPassword,
             lstrlenA(lpInetClientInfoA->szNNTPLogonPassword)+1);
    mbstowcs(lpInetClientInfoW->szNNTPServer,
             lpInetClientInfoA->szNNTPServer,
             lstrlenA(lpInetClientInfoA->szNNTPServer)+1);
    mbstowcs(lpInetClientInfoW->szNNTPName,
             lpInetClientInfoA->szNNTPName,
             lstrlenA(lpInetClientInfoA->szNNTPName)+1);
    mbstowcs(lpInetClientInfoW->szNNTPAddress,
             lpInetClientInfoA->szNNTPAddress,
             lstrlenA(lpInetClientInfoA->szNNTPAddress)+1);
    mbstowcs(lpInetClientInfoW->szIncomingMailLogonName,
             lpInetClientInfoA->szIncomingMailLogonName,
             lstrlenA(lpInetClientInfoA->szIncomingMailLogonName)+1);
    mbstowcs(lpInetClientInfoW->szIncomingMailLogonPassword,
             lpInetClientInfoA->szIncomingMailLogonPassword,
             lstrlenA(lpInetClientInfoA->szIncomingMailLogonPassword)+1);
    mbstowcs(lpInetClientInfoW->szIncomingMailServer,
             lpInetClientInfoA->szIncomingMailServer,
             lstrlenA(lpInetClientInfoA->szIncomingMailServer)+1);
    mbstowcs(lpInetClientInfoW->szLDAPLogonName,
             lpInetClientInfoA->szLDAPLogonName,
             lstrlenA(lpInetClientInfoA->szLDAPLogonName)+1);
    mbstowcs(lpInetClientInfoW->szLDAPLogonPassword,
             lpInetClientInfoA->szLDAPLogonPassword,
             lstrlenA(lpInetClientInfoA->szLDAPLogonPassword)+1);
    mbstowcs(lpInetClientInfoW->szLDAPServer,
             lpInetClientInfoA->szLDAPServer,
             lstrlenA(lpInetClientInfoA->szLDAPServer)+1);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\wizdll.h ===
#include <windows.h>
#include <wizglob.h>

#ifdef DEBUG
#define SZ_COMPNAME "INETCFG: "
#endif // DEBUG

#include <wizdebug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\wizdef.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  WIZDEF.H -   data structures and constants for Internet setup/signup wizard
//

//  HISTORY:
//  
//  11/20/94  jeremys Created.
//  96/02/27  markdu  Changed RAS_MaxLocal to RAS_MaxPhoneNumber
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//  96/03/23  markdu  Remove unused IP LAN pages.
//  96/03/23  markdu  Removed TCPINFO struct from CLIENTINFO struct.
//  96/03/23  markdu  Since TCPINFO struct was removed from CLIENTINFO, 
//            CLIENTINFO contained only a CLIENTCONFIG.  So, CLIENTINFO
//            has been removed and all occurrences replaced with CLIENTCONFIG.
//  96/03/24  markdu  Changed all MAX_ISP_ defines to use the values used
//            by RASDIALPARAMS.  Note that since for some reason RNA won't
//            create an entry of length RAS_MaxEntryName even though 
//            RasValidateEntryName succeeds, we have to subtract one.
//  96/03/27  markdu  Added lots of new pages.
//  96/04/19  markdu  NASH BUG 13387 Changed RAS_MaxPhoneNumber.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//	96/09/05  valdonb NORMANDY BUG 6248 Added pages for mail and news set up
//

#ifndef _WIZDEF_H_
#define _WIZDEF_H_

#include "icwcmn.h"

// Defines
#define MAX_ISP_NAME        (RAS_MaxEntryName-1)  // internet service provider name
#define MAX_ISP_USERNAME    UNLEN  // max length of login username
#define MAX_ISP_PASSWORD    PWLEN  // max length of login password
#define MAX_PORT_LEN		5      // max length of proxy port number (max # = 65535)

#define MAX_SCHEME_NAME_LENGTH	sizeof("gopher")
#define MAX_URL_STRING (1024 + MAX_SCHEME_NAME_LENGTH + sizeof("://"))	// max length of URL

#define MAX_REG_LEN			2048	// max length of registry entries
#define MAX_RES_LEN         255 // max length of string resources
#define SMALL_BUF_LEN       48  // convenient size for small text buffers

#define MAX_UI_AREA_CODE    RAS_MaxAreaCode
// NASH BUG 13387 MAX_UI_PHONENUM should be defined as RAS_MaxPhoneNumber, since that
// what is used in RASENTRY, but internally RNA uses RAS_MaxLocal, which is 36.  There
// is a bug in RNA though:  it chops off the 36th character if you enter it.
#define MAX_UI_PHONENUM     35

// Keep in sync with CCHMAX_ACCOUNT_NAME in imnact.h.  This is used here because
// we can't include imnact.h in this file because using a precompiled header
// conflicts with the use of DEFINE_GUID.
#define MAX_ACCOUNT_NAME	256


// 11/23/96 jmazner Normandy #8504
#define MAX_SERVERPROTOCOL_NAME		16
#define NUM_MAILSERVERPROTOCOLS		2	/*  POP3
											IMAP
										*/

// Data structures

// we distinguish two kinds of phone numbers: "machine-readable"
// which are just the digits stored sequentially ("18003524060"), and
// "human readable" which is just text and may look like "(206) 352-9060
// ext. 910".  We will never parse "human readable" numbers.

// structure to hold information about the user
// The fixed-lengths fields are a little wasteful, but we only have one
// of these, it's dynamically allocated and it's much more convenient this way.
typedef struct tagUSERINFO {
  UINT cbStruct;                // == sizeof(USERINFO)

  // various choices made along the way...
  
  // 5/4/97	jmazner	Olympus #1347
  // Updated to allow for new Manual connection type. 
  //BOOL fConnectOverLAN;  // use LAN to connect, if user has both modem & LAN
  UINT uiConnectionType;

  // ISP (Internet Service Provider) information
  BOOL fNewConnection;
  BOOL fModifyConnection;
  BOOL fModifyAdvanced;
  BOOL fAutoDNS;
  TCHAR szISPName[MAX_ISP_NAME+1];
  TCHAR szAccountName[MAX_ISP_USERNAME+1];    // requested username
  TCHAR szPassword[MAX_ISP_PASSWORD+1];    // requested password

  // proxy server config information
  TCHAR  szAutoConfigURL[MAX_URL_STRING+1];
  BOOL  fProxyEnable;
  BOOL  bByPassLocal;
  BOOL  bAutoConfigScript;
  BOOL  bAutoDiscovery;
  TCHAR  szProxyServer[MAX_URL_STRING+1];
  TCHAR  szProxyOverride[MAX_URL_STRING+1];

  BOOL fPrevInstallFound;      // previous install was found

} USERINFO;

// structure used to pass information to mail profile config APIs.
// Most likely the pointers point into a USERINFO struct, 
typedef struct MAILCONFIGINFO {
  TCHAR * pszEmailAddress;          // user's email address
  TCHAR * pszEmailServer;          // user's email server path
  TCHAR * pszEmailDisplayName;        // user's name
  TCHAR * pszEmailAccountName;        // account name
  TCHAR * pszEmailAccountPwd;        // account password
  TCHAR * pszProfileName;          // name of profile to use
                      // (create or use default if NULL)
  BOOL fSetProfileAsDefault;        // set profile as default profile

  TCHAR * pszConnectoidName;        // name of connectoid to dial
  BOOL fRememberPassword;          // password cached if TRUE
} MAILCONFIGINFO;

#define NUM_WIZARD_PAGES	12    //39  // total number of pages in wizard

#define MAX_PAGE_INDEX	    11

// page index defines
#define ORD_PAGE_HOWTOCONNECT         0
#define ORD_PAGE_CHOOSEMODEM          1
#define ORD_PAGE_CONNECTEDOK          2
#define ORD_PAGE_CONNECTION           3
#define ORD_PAGE_MODIFYCONNECTION     4
#define ORD_PAGE_CONNECTIONNAME       5
#define ORD_PAGE_PHONENUMBER          6
#define ORD_PAGE_NAMEANDPASSWORD      7
#define ORD_PAGE_USEPROXY             8
#define ORD_PAGE_PROXYSERVERS         9
#define ORD_PAGE_PROXYEXCEPTIONS      10
#define ORD_PAGE_SETUP_PROXY          11


// structure to hold information about wizard state
typedef struct tagWIZARDSTATE  {

  UINT uCurrentPage;    // index of current page wizard is on

  // keeps a history of which pages were visited, so user can
  // back up and we know the last page completed in case of reboot.
  UINT uPageHistory[NUM_WIZARD_PAGES]; // array of page #'s we visited
  UINT uPagesCompleted;         // # of pages in uPageHistory

  BOOL fMAPIActive;    // MAPI initialized

  BOOL fNeedReboot;    // reboot needed at end

  DWORD dwRunFlags;    // flags passed to us
  
  // State data that is common to both sides of the WIZARD
  CMNSTATEDATA cmnStateData;
} WIZARDSTATE;



// handler proc for OK, cancel, etc button handlers
typedef BOOL (CALLBACK* INITPROC)(HWND,BOOL);
typedef BOOL (CALLBACK* OKPROC)(HWND,BOOL,UINT *,BOOL *);
typedef BOOL (CALLBACK* CANCELPROC)(HWND);
typedef BOOL (CALLBACK* CMDPROC)(HWND,WPARAM,LPARAM);

// structure with information for each wizard page
typedef struct tagPAGEINFO
{
  UINT       uDlgID;            // dialog ID to use for page
  UINT       uDlgID97External;  // dialog ID to use for pages given to an external Wizard 97
  UINT       uDlgID97;          // dialog ID to use for a Wizard 97 that we build
  // handler procedures for each page-- any of these can be
  // NULL in which case the default behavior is used
  INITPROC    InitProc;
  OKPROC      OKProc;
  CMDPROC     CmdProc;
  CANCELPROC  CancelProc;
  // Normandy 12278 ChrisK 12/4/96
#if !defined(WIN16)
  DWORD       dwHelpID;
#endif //!WIN16

  int       nIdTitle;
  int       nIdSubTitle;
  
} PAGEINFO;

#define SetPropSheetResult( hwnd, result ) SetWindowLongPtr(hwnd, DWLP_MSGRESULT, result)


#endif // _WIZDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\wizdll.cpp ===
/*****************************************************************/
/**          Microsoft Windows for Workgroups        **/
/**          Copyright (C) Microsoft Corp., 1991-1992      **/
/*****************************************************************/ 

//
//  WIZDLL.C - 32-bit stubs for functions that call into 16-bit DLL
//

//  HISTORY:
//  
//  11/20/94  jeremys  Created.
//  96/03/13  markdu  Added IcfgSetInstallSourcePath().
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/05/28  markdu  InitConfig and DeInitConfig in DllEntryPoint.
//

#include "wizard.h"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
HINSTANCE ghInstance=NULL;
#pragma data_seg(DATASEG_DEFAULT)

typedef UINT RETERR;

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to WIZ16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
  if( fdwReason == DLL_PROCESS_ATTACH )
  {
    ghInstance = hInstDll;

	//
	// 7/22/97 jmazner Olympus #9903
	//
	TCHAR szPath[MAX_PATH + 1];
	BOOL fPathAlreadySet = FALSE;

	GetICW11Path( szPath, &fPathAlreadySet );

	if( !fPathAlreadySet && szPath[0] )
	{
		SetICWRegKeysToPath( szPath );
	}

	if( IsParentICW10() )
	{
		DEBUGMSG("DllEntryPoint, INETCFG called from old component, bailing out!");
		return FALSE;
	}


	// load the config dll proc addresses
    BOOL fRet = InitConfig(NULL);
    if (FALSE == fRet)
    {
      // Error message was already displayed in InitConfig.
      return FALSE;
    }
  }

  if( fdwReason == DLL_PROCESS_DETACH )
  {
    DeInitConfig();
  }

  return TRUE;
}


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

void __cdecl main() {};

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetwiz\ids.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// string resource IDs
#define IDS_WIZ_WINDOW_NAME				1000
#define IDS_WIZ_CLASS_NAME				1001
#define IDS_WANTTOREBOOT                1002
#define IDS_EXITFAILED                  1003
#define IDS_ADMIN_ACCESS_DENIED         1004
#define IDS_ADMIN_ACCESS_DENIED_TITLE   1005
#define IDS_IEAK_ACCESS_DENIED          1006
#define IDS_IEAK_ACCESS_DENIED_TITLE    1007
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetwiz\reboot.cpp ===
#include "wizard.h"
#define REGSTR_PATH_RUNONCE	TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")

#if !defined (WIN16)


#include  <shlobj.h>

static const TCHAR cszICW_StartFileName[] = TEXT("ICWStart.bat");
static const TCHAR cszICW_StartCommand[] = TEXT("@start ");
static const TCHAR cszICW_DummyWndName[] = TEXT("\"ICW\" ");
static const TCHAR cszICW_ExitCommand[] = TEXT("\r\n@exit");

static TCHAR g_cszAppName[257] = TEXT("inetwiz");

//+----------------------------------------------------------------------------
//
//	Function	SetRunOnce
//
//	Synopsis	Before we reboot we have to make sure this
//              executable is automatically run after startup
//
//	Arguments	none
//
//	Returns:    DWORD - status
//				
//  History:
//              MKarki      modified    - for INETWIZ.EXE
//
//-----------------------------------------------------------------------------
DWORD SetRunOnce (
        VOID
        )
{
    TCHAR szTemp[MAX_PATH + MAX_PATH + 1];
	TCHAR szTemp2[MAX_PATH + 1];
    DWORD dwRet = ERROR_CANTREAD;
    HKEY hKey;
	LPTSTR lpszFilePart;


    //
    // get the name of the executable
    //
    if (GetModuleFileName(NULL,szTemp2,sizeof(szTemp2)) != 0)
    
    {

        GetShortPathName (szTemp2, szTemp, sizeof (szTemp)); 
      
        //
		// Determine Version of the OS we are runningon
        //
		OSVERSIONINFO osvi;
		ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
 		if (!GetVersionEx(&osvi))
		{
			ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
		}

        
		if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
		{
            //
            // if running on NT than copy the command into a
            //  batch file to be run after reboot
            //
			dwRet = SetStartUpCommand (szTemp);
		}
		else
		{
            //
            // in case of Win95 we can safely put our path
            // in the RUNONCE registry key
            //
			dwRet = RegCreateKey (
				        HKEY_LOCAL_MACHINE,
				        REGSTR_PATH_RUNONCE,
				        &hKey
                        );
			if (ERROR_SUCCESS == dwRet)
			{
				dwRet = RegSetValueEx (
					        hKey,
					        g_cszAppName,
					        0L,
					        REG_SZ,
					        (LPBYTE)szTemp,
					        sizeof(szTemp)
                            );
				RegCloseKey (hKey);
			}
		}
    }

    return (dwRet);

}   //  end of SetRunOnce function
//+----------------------------------------------------------------------------
//
//	Function	SetStartUpCommand
//
//	Synopsis	On an NT machine the RunOnce method is not reliable.  Therefore
//				we will restart the ICW by placing a .BAT file in the common
//				startup directory.
//
//	Arguments	lpCmd - command line used to restart the ICW
//
//	Returns:    BOOL - success/failure	
//				
//
//	History		1-10-97	ChrisK	Created
//              5/2/97  MKarki  modified  for INETWIZ
//
//-----------------------------------------------------------------------------
BOOL
SetStartUpCommand (
        LPTSTR lpCmd
        )
{
	BOOL bRC = FALSE;
	HANDLE hFile = INVALID_HANDLE_VALUE ;
	DWORD dwWLen;	// dummy variable used to make WriteFile happy
	TCHAR szCommandLine[MAX_PATH + 1];
	LPITEMIDLIST lpItemDList = NULL;
	HRESULT hr = ERROR_SUCCESS;
    BOOL    bRetVal = FALSE;
    IMalloc *pMalloc = NULL;

    //
	// build full filename
    //
	hr = SHGetSpecialFolderLocation(NULL,CSIDL_COMMON_STARTUP,&lpItemDList);
	if (ERROR_SUCCESS != hr)
		goto SetStartUpCommandExit;

	if (FALSE == SHGetPathFromIDList(lpItemDList, szCommandLine))
		goto SetStartUpCommandExit;

    
    //
    // Free up the memory allocated for LPITEMIDLIST
    // because seems like we are clobberig something later
    // by not freeing this
    //
    hr = SHGetMalloc (&pMalloc);
    if (SUCCEEDED (hr))
    {
        pMalloc->Free (lpItemDList);
        pMalloc->Release ();
    }

    //
	// make sure there is a trailing \ character
    //
	if ('\\' != szCommandLine[lstrlen(szCommandLine)-1])
		lstrcat(szCommandLine,TEXT("\\"));
	lstrcat(szCommandLine,cszICW_StartFileName);

    //
	// Open file
    //
	hFile = CreateFile (
                szCommandLine,
                GENERIC_WRITE,
                0,
                0,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                NULL
                );
	if (INVALID_HANDLE_VALUE == hFile)
		goto SetStartUpCommandExit;

    //
	// Write the restart commands to the file
    //
    
	bRetVal = WriteFile(
                      hFile,
                      cszICW_StartCommand,
                      lstrlen(cszICW_StartCommand),
                      &dwWLen,
                      NULL
                      );
    if (FALSE == bRetVal)
		goto SetStartUpCommandExit;

    //
	// 1/20/96	jmazner Normandy #13287
	// Start command considers the first thing it sees 
    // in quotes to be a window title
	// So, since our path is in quotes, put in a fake window title
    //
	bRetVal = WriteFile (
                    hFile,
                    cszICW_DummyWndName,
                    lstrlen(cszICW_DummyWndName),
                    &dwWLen,NULL
                    );
    if (FALSE == bRetVal)
		goto SetStartUpCommandExit;

    //
    // write the path name of the executable now
    //
    bRetVal = WriteFile (
                    hFile,
                    lpCmd,
                    lstrlen(lpCmd),
                    &dwWLen,
                    NULL
                    );
    if (FALSE == bRetVal)
		goto SetStartUpCommandExit;

    //
    // write the exit command in the next line
    //
    bRetVal = WriteFile (
                    hFile,
                    cszICW_ExitCommand,
                    lstrlen (cszICW_ExitCommand),
                    &dwWLen,
                    NULL
                    );
    if (FALSE == bRetVal)
		goto SetStartUpCommandExit;

	bRC = TRUE;

SetStartUpCommandExit:

    //
	// Close handle and exit
    //
	if (INVALID_HANDLE_VALUE != hFile)
		CloseHandle(hFile);

	return bRC;

}  // end of SetStartUpCommand function

//+----------------------------------------------------------------------------
//
//	Function:	DeleteStartUpCommand
//
//	Synopsis:	After restart the ICW we need to delete the .bat file from
//				the common startup directory
//
//	Arguements: None
//
//	Returns:	None
//
//	History:	1-10-97	ChrisK	Created
//
//-----------------------------------------------------------------------------
VOID DeleteStartUpCommand (
        VOID
        )
{
	TCHAR szStartUpFile[MAX_PATH + 1];
	LPITEMIDLIST lpItemDList = NULL;
	HRESULT hr = ERROR_SUCCESS;
    IMalloc *pMalloc = NULL;

    //
    // Sleep for 10 seconds
    //


	// build full filename
    //
	hr = SHGetSpecialFolderLocation(NULL,CSIDL_COMMON_STARTUP,&lpItemDList);
	if (ERROR_SUCCESS != hr)
		goto DeleteStartUpCommandExit;

	if (FALSE == SHGetPathFromIDList(lpItemDList, szStartUpFile))
		goto DeleteStartUpCommandExit;

    //
    // Free up the memory allocated for LPITEMIDLIST
    // because seems like we are clobberig something later
    // by not freeing this
    //
    hr = SHGetMalloc (&pMalloc);
    if (SUCCEEDED (hr))
    {
        pMalloc->Free (lpItemDList);
        pMalloc->Release ();
    }

    //
	// make sure there is a trailing \ character
    //
	if ('\\' != szStartUpFile[lstrlen(szStartUpFile)-1])
		lstrcat(szStartUpFile,TEXT("\\"));
	lstrcat(szStartUpFile,cszICW_StartFileName);

    //
    //  we dont care if the file does not exist
    //
	DeleteFile(szStartUpFile);

DeleteStartUpCommandExit:

	return;

}   //  end of DeleteStartUpCommand function

#endif // !defined (WIN16)

//+----------------------------------------------------------------------------
//
//	Function:	FGetSystemShutdownPrivledge
//
//	Synopsis:	For windows NT the process must explicitly ask for permission
//				to reboot the system.
//
//	Arguements:	none
//
//	Return:		TRUE - privledges granted
//				FALSE - DENIED
//
//	History:	8/14/96	ChrisK	Created
//
//	Note:		BUGBUG for Win95 we are going to have to softlink to these
//				entry points.  Otherwise the app won't even load.
//				Also, this code was originally lifted out of MSDN July96
//				"Shutting down the system"
//-----------------------------------------------------------------------------
BOOL 
FGetSystemShutdownPrivledge (
        VOID
        )
{
	HANDLE hToken = NULL;
	TOKEN_PRIVILEGES tkp;
 
	BOOL bRC = FALSE;

	if (IsNT())
	{
		// 
		// Get the current process token handle 
		// so we can get shutdown privilege. 
		//

		if (!OpenProcessToken(GetCurrentProcess(), 
				TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
				goto FGetSystemShutdownPrivledgeExit;

		//
		// Get the LUID for shutdown privilege.
		//

		ZeroMemory(&tkp,sizeof(tkp));
		LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
				&tkp.Privileges[0].Luid); 

		tkp.PrivilegeCount = 1;  /* one privilege to set    */ 
		tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

		//
		// Get shutdown privilege for this process.
		//

		AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
			(PTOKEN_PRIVILEGES) NULL, 0); 

		if (ERROR_SUCCESS == GetLastError())
			bRC = TRUE;
	}
	else
	{
		bRC = TRUE;
	}

FGetSystemShutdownPrivledgeExit:
	if (hToken) CloseHandle(hToken);
	return bRC;
}

//+-------------------------------------------------------------------
//
//	Function:	IsNT
//
//	Synopsis:	findout If we are running on NT
//
//	Arguements:	none
//
//	Return:		TRUE -  Yes
//				FALSE - No
//
//--------------------------------------------------------------------
BOOL 
IsNT (
    VOID
    )
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);

}  //end of IsNT function call

//+-------------------------------------------------------------------
//
//	Function:	IsNT5
//
//	Synopsis:	findout If we are running on NT5
//
//	Arguements:	none
//
//	Return:		TRUE -  Yes
//				FALSE - No
//
//--------------------------------------------------------------------
BOOL 
IsNT5 (
    VOID
    )
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return ((VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId) && (OsVersionInfo.dwMajorVersion >= 5));

}  //end of IsNT function call
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetwiz\wizard.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//	WIZARD.H - central header file for Internet setup/signup wizard
//

//	HISTORY:
//	
//	11/20/94	jeremys	Created.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//

#ifndef _WIZARD_H_
#define _WIZARD_H_

#define STRICT                      // Use strict handle types
#define _SHELL32_

#ifdef DEBUG
// component name for debug spew
#define SZ_COMPNAME "INETWIZ: "
#endif // DEBUG

#include <windows.h>                
#include <windowsx.h>
#include <locale.h>

#include "..\inc\wizdebug.h"
#include "ids.h"

#ifdef WIN32

extern VOID
ProcessCmdLine (
        LPCTSTR lpszCmd
        );
//
// here the function declaration for the reboot functionality
//
extern 
DWORD 
SetRunOnce (
  VOID
  );

extern BOOL
SetStartUpCommand (
        LPTSTR lpCmd
        );

extern VOID
DeleteStartUpCommand (
        VOID
        );

extern BOOL 
FGetSystemShutdownPrivledge (
        VOID
        );

extern BOOL 
IsNT (
    VOID
    );

extern BOOL 
IsNT5 (
    VOID
    );

#endif // ifdef WIN32

#define SMALL_BUF_LEN	48

#endif // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetwiz\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

MAJORCOMP=GETCONN
MINORCOMP=INETWIZ

TARGETNAME=INETWIZ
TARGETTYPE=PROGRAM
TARGETPATH=obj
UMTYPE=windows
UMENTRY=winmain
NOT_LEAN_AND_MEAN=1
RCNOFONTMAP=1
C_DEFINES=-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

# PASS0_SOURCEDIR=.

# only build after the inetcfg lib is done
SYNCHRONIZE_DRAIN = 1

USE_MSVCRT40=1

SOURCES=            \
	..\inetwiz.rc   \
	..\init.cpp     \
    ..\reboot.cpp

TARGETLIBS=                                         \
!if defined(NOT_UNICODE)
    $(GETCONN_DIR)\inetcfg\ansi\$O\inetcfg.lib      \
!else
    $(GETCONN_DIR)\inetcfg\unicode\$O\inetcfg.lib   \
!endif
    $(SDK_LIB_PATH)\user32.lib	                    \
    $(SDK_LIB_PATH)\shell32.lib	                    \
    $(SDK_LIB_PATH)\kernel32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetwiz\init.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//	INIT.C - WinMain and initialization code for Internet setup/signup wizard
//

//	HISTORY:
//	
//	11/20/94	jeremys	Created.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//

#include "wizard.h"

#ifdef WIN32
#include "..\inc\semaphor.h"
#endif

#define IEAK_RESTRICTION_REGKEY        TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define IEAK_RESTRICTION_REGKEY_VALUE  TEXT("Connwiz Admin Lock")

// superceded by definition in semaphor.h
//#define SEMAPHORE_NAME "Internet Connection Wizard INETWIZ.EXE"

HINSTANCE ghInstance=NULL;

LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

	VOID WINAPI LaunchSignupWizard(LPTSTR lpCmdLine,int nCmdShow, PBOOL pReboot);

#ifdef __cplusplus
}
#endif // __cplusplus

BOOL DoesUserHaveAdminPrivleges(HINSTANCE hInstance)
{
    HKEY hKey = NULL;
    BOOL bRet = FALSE;

    if (!IsNT())
        return TRUE;

    // BUGBUG: We should allow NT5 to run in all user groups
    // except normal users.
    if (IsNT5())
        return TRUE;

    //
    // Ensure caller is an administrator on this machine.
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      (TCHAR*)TEXT("SYSTEM\\CurrentControlSet"),
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hKey))
    {
        bRet = TRUE;
        CloseHandle(hKey);
    }
    else
    {
        TCHAR szAdminDenied      [MAX_PATH] = TEXT("\0");
        TCHAR szAdminDeniedTitle [MAX_PATH] = TEXT("\0");
        LoadString(hInstance, IDS_ADMIN_ACCESS_DENIED, szAdminDenied, MAX_PATH);
        LoadString(hInstance, IDS_ADMIN_ACCESS_DENIED_TITLE, szAdminDeniedTitle, MAX_PATH);
        MessageBox(NULL, szAdminDenied, szAdminDeniedTitle, MB_OK | MB_ICONSTOP);
    }

    return bRet;
}

BOOL CheckForIEAKRestriction(HINSTANCE hInstance)
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,
        IEAK_RESTRICTION_REGKEY,&hkey))
    {
        dwSize = sizeof(dwData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,IEAK_RESTRICTION_REGKEY_VALUE,0,&dwType,
            (LPBYTE)&dwData,&dwSize))
        {
            if (dwData)
            {   
                TCHAR szIEAKDenied[MAX_PATH];
                TCHAR szIEAKDeniedTitle[MAX_PATH];
                LoadString(hInstance, IDS_IEAK_ACCESS_DENIED, szIEAKDenied, MAX_PATH);
                LoadString(hInstance, IDS_IEAK_ACCESS_DENIED_TITLE, szIEAKDeniedTitle, MAX_PATH);
                MessageBox(NULL, szIEAKDenied, szIEAKDeniedTitle, MB_OK | MB_ICONSTOP);
                bRC = TRUE;
            }
        }
   }

   if (hkey)
        RegCloseKey(hkey);

    return bRC;
}

/*******************************************************************

	NAME:		WinMain

	SYNOPSIS:	App entry point

********************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,
	LPSTR lpCmdLine,int nCmdShow)
{
    BOOL bReboot = FALSE;
    
#ifdef UNICODE
    // Initialize the C runtime locale to the system locale.
    setlocale(LC_ALL, "");
#endif

	// only allow one instance of wizard
	// note: hPrevInstance is always NULL for Win32 apps, so need to look
	// for existing window

    HANDLE hSemaphore = NULL;
	hSemaphore = CreateSemaphore(NULL, 1, 1, ICW_ELSE_SEMAPHORE);
	DWORD dwErr = GetLastError();
	if ( ERROR_ALREADY_EXISTS == dwErr )
	{
		IsAnotherComponentRunning32( FALSE );
		// every instance should close its own semaphore handle
		goto WinMainExit;
	}
	else
	{
		if( IsAnotherComponentRunning32( TRUE ) )
			goto WinMainExit;
	}

    //
    // remove the batch files if we are running of NT and
    // started of 1
    //
    if (IsNT ())
        DeleteStartUpCommand();

    if (!DoesUserHaveAdminPrivleges(hInstance))
        //no, bail.
        goto WinMainExit;

    if (CheckForIEAKRestriction(hInstance))
        //yes, bail.
        goto WinMainExit;

    //
	// call our DLL to run the wizard
    //
#ifdef UNICODE
        TCHAR szCmdLine[MAX_PATH+1];
        mbstowcs(szCmdLine, lpCmdLine, MAX_PATH+1);
	LaunchSignupWizard(szCmdLine, nCmdShow, &bReboot);
#else
	LaunchSignupWizard(lpCmdLine, nCmdShow, &bReboot);
#endif

    //
    // we should reboot, if the flag is set
    //
    if (TRUE == bReboot)
    {
        //
        // as the user if we would like to reboot at this time
        //
        TCHAR szMessage[256];
        TCHAR szTitle[256];
        LoadSz (IDS_WANTTOREBOOT, szMessage, sizeof (szMessage));
        LoadSz (IDS_WIZ_WINDOW_NAME, szTitle, sizeof (szTitle));

	    if (IDYES == MessageBox(NULL, szMessage, szTitle, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2))

		{
            SetRunOnce ();
		    if (!FGetSystemShutdownPrivledge() ||
					!ExitWindowsEx(EWX_REBOOT,0))
	        {
                
                TCHAR szFailMessage[256];
                LoadSz (IDS_EXITFAILED, szFailMessage, sizeof (szFailMessage));
	            MessageBox(NULL, szFailMessage, szTitle, MB_ICONERROR | MB_OK);

		    }

			//
			// ChrisK Olympus 4212, Allow Inetwiz to exit on restart
			//
            //else
            //{
            //    //      
            //    //  We will wait for the System to release all
            //    //  resources, 5 minutes should be more than 
            //    //  enough for this 
            //    //  - MKarki (4/22/97)  Fix for Bug #3109
            //    //
            //    Sleep (300000);
            //}
		}
    }


WinMainExit:
	if( hSemaphore ) 
		CloseHandle(hSemaphore);

	return 0;

}

/*******************************************************************

	NAME:		LoadSz

	SYNOPSIS:	Loads specified string resource into buffer

	EXIT:		returns a pointer to the passed-in buffer

	NOTES:		If this function fails (most likely due to low
				memory), the returned buffer will have a leading NULL
				so it is generally safe to use this without checking for
				failure.

********************************************************************/
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
	ASSERT(lpszBuf);

	// Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}



#ifdef WIN32
//+---------------------------------------------------------------------------
//
//  Function:   IsAnotherComponentRunning32()
//
//  Synopsis:   Checks if there's another ICW component already
//				running.  If so, it will set focus to that component's window.
//
//				This functionality is needed by all of our .exe's.  However,
//				the actual components to check for differ between .exe's.
//				The comment COMPONENT SPECIFIC designates lines of code
//				that vary between components' source code.
//
//				For ICWCONN1, we return FALSE if the following are already running:
//				  another instance of ICWCONN1, any other component
//
//  Arguments:  bCreatedSemaphore --
//					--	if TRUE, then this component has successfully created
//						it's semaphore, and we want to check whether other
//						components are running
//					--	if FALSE, then this component could not create
//						it's semaphore, and we want to find the already
//						running instance of this component
//
//	Returns:	TRUE if another component is already running
//				FALSE otherwise
//
//  History:    12/3/96	jmazner		Created, with help from IsAnotherInstanceRunning
//									in icwconn1\connmain.cpp
//
//----------------------------------------------------------------------------
BOOL IsAnotherComponentRunning32(BOOL bCreatedSemaphore)
{

	HWND hWnd = NULL;
	HANDLE hSemaphore = NULL;
	DWORD dwErr = 0;

	TCHAR szWindowName[SMALL_BUF_LEN+1];
	
	if( !bCreatedSemaphore )
	{
		// something other than conn1 is running,
		// let's find it!
		// COMPONENT SPECIFIC
		LoadSz(IDS_WIZ_WINDOW_NAME,szWindowName,sizeof(szWindowName));
		hWnd = FindWindow(DIALOG_CLASS_NAME, szWindowName);

		if( hWnd )
		{
			SetFocus(hWnd);
			SetForegroundWindow(hWnd);
		}

		// regardless of whether we found the window, return TRUE
		// since bCreatedSemaphore tells us this component was already running.
		return TRUE;
	}
	else
	{
		// check whether CONN1 is running
	    // The particular semaphores we look for are
		// COMPONENT SPECIFIC

		// is conn1 running?
		hSemaphore = CreateSemaphore(NULL, 1, 1, ICWCONN1_SEMAPHORE);
		dwErr = GetLastError();

		// close the semaphore right away since we have no use for it.
		if( hSemaphore )
			CloseHandle(hSemaphore);
		
		if( ERROR_ALREADY_EXISTS == dwErr )
		{
			// conn1 is running.
			// Bring the running instance's window to the foreground
			LoadSz(IDS_WIZ_WINDOW_NAME,szWindowName,sizeof(szWindowName));
			hWnd = FindWindow(DIALOG_CLASS_NAME, szWindowName);
			
			if( hWnd )
			{
				SetFocus(hWnd);
				SetForegroundWindow(hWnd);
			}

			return( TRUE );
		}

		// didn't find any other running components!
		return( FALSE );
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\autodial.h ===
#define IDI_WARN                        4001

#define IDC_ERROR                       4101
#define IDC_STATUS                      4102
#define IDC_CONNECT                     4103
#define IDC_PHONENUMBER                 4104

#define IDS_CONNECTING_TO               4401
#define IDS_STATUS                      4402
#define IDS_RETRY                       4403
#define IDS_REDIAL                      4404
#define IDS_BUSYREDIAL                  4405
#define IDS_REDIALCANCEL                4406
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\autodial.cpp ===
#include "isignup.h"

#include "dialutil.h"
#include "autodial.h"

#define NUMRETRIES      3

#define MAXHANGUPDELAY  20
#define ONE_SECOND      1000
#define TIMER_ID        0

#define SMALLBUFLEN 80

static HRASCONN g_hRasConn = NULL;
static UINT g_cDialAttempts = 0;
static UINT g_cHangupDelay = 0;
static TCHAR g_szEntryName[RAS_MaxEntryName + 1] = TEXT("");

static const TCHAR szBrowserClass1[] = TEXT("IExplorer_Frame");
static const TCHAR szBrowserClass2[] = TEXT("Internet Explorer_Frame");
static const TCHAR szBrowserClass3[] = TEXT("IEFrame");

static DWORD AutoDialConnect(HWND hDlg, LPRASDIALPARAMS lpDialParams);
static BOOL AutoDialEvent(HWND hDlg, RASCONNSTATE state, LPDWORD lpdwError);
static VOID SetDialogTitle(HWND hDlg, LPCTSTR pszConnectoidName);
static HWND FindBrowser(void);
static UINT RetryMessage(HWND hDlg, DWORD dwError);

#ifdef WIN16
extern "C" BOOL CALLBACK __export AutoDialDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
extern "C" BOOL CALLBACK __export PhoneNumberDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
extern "C" BOOL CALLBACK __export RetryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
#else
INT_PTR CALLBACK AutoDialDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
INT_PTR CALLBACK PhoneNumberDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
INT_PTR CALLBACK RetryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
#endif

#ifdef UNICODE
BOOL WINAPI AutoDialSignupW(HWND, LPCTSTR, DWORD, LPDWORD);
BOOL WINAPI AutoDialSignupA
(
    HWND    hwndParent,	
    LPCSTR  lpszEntry,
    DWORD   dwFlags,
    LPDWORD pdwRetCode
)
{
    TCHAR szEntry[RAS_MaxEntryName + 1];

    mbstowcs(szEntry, lpszEntry, lstrlenA(lpszEntry)+1);
    return AutoDialSignupW(hwndParent, szEntry, dwFlags, pdwRetCode);
}

BOOL WINAPI AutoDialSignupW
#else
BOOL WINAPI AutoDialSignupA
#endif
(
    HWND    hwndParent,	
    LPCTSTR lpszEntry,
    DWORD   dwFlags,
    LPDWORD pdwRetCode
)
{
    LoadRnaFunctions(hwndParent);

    lstrcpyn(g_szEntryName,  lpszEntry, sizeof(g_szEntryName));

    if (DialogBoxParam(
        ghInstance,
        TEXT("AutoDial"),
        hwndParent,
        AutoDialDlgProc,
        (DWORD_PTR)pdwRetCode) == -1)
    {
        *pdwRetCode = ERROR_CANCELLED;
    }

    if (ERROR_SUCCESS != *pdwRetCode)
    {
        HWND hwndBrowser;

        hwndBrowser = FindBrowser();

        if (NULL != hwndBrowser)
        {
            SendMessage(hwndBrowser, WM_CLOSE, 0, 0);
        }
    }

    UnloadRnaFunctions();

    return TRUE;
}

#ifdef WIN16
extern "C" BOOL CALLBACK __export AutoDialDlgProc(
#else
INT_PTR CALLBACK AutoDialDlgProc(
#endif
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    static LPDWORD lpdwRet;
    static UINT uEventMsg;
    static LPRASDIALPARAMS lpDialParams = NULL;
    BOOL fPassword;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            lpdwRet = (LPDWORD)lParam;

            SetWindowPos(
                hDlg,
                HWND_TOPMOST,
                0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE);

            g_cDialAttempts = 0;

            SetDialogTitle(hDlg, g_szEntryName);

            CenterWindow(hDlg, GetParent(hDlg));

            uEventMsg = RegisterWindowMessageA( RASDIALEVENT );
            if (0 == uEventMsg)
            {
                uEventMsg =  WM_RASDIALEVENT;
            }

            g_hRasConn = NULL;

            lpDialParams = (LPRASDIALPARAMS)LocalAlloc(LPTR, sizeof(RASDIALPARAMS));

            if (NULL == lpDialParams)
            {
                *lpdwRet = ERROR_OUTOFMEMORY;
                return FALSE;
            }

            lpDialParams->dwSize = sizeof(RASDIALPARAMS);
            lstrcpyn(lpDialParams->szEntryName,  g_szEntryName, sizeof(lpDialParams->szEntryName));
            *lpdwRet = lpfnRasGetEntryDialParams(
                NULL,
                lpDialParams,
                &fPassword);
            if (ERROR_SUCCESS == *lpdwRet)
            {
                lstrcpyn(lpDialParams->szPassword, GetPassword(),
                    SIZEOF_TCHAR_BUFFER(lpDialParams->szPassword));

                GetPhoneNumber(g_szEntryName, lpDialParams->szPhoneNumber);

                if (DialogBoxParam(
                    ghInstance,
                    TEXT("PhoneNumber"),
                    hDlg,
                    PhoneNumberDlgProc,
                    (LPARAM)GetDisplayPhone(lpDialParams->szPhoneNumber)) != IDOK)
                {
                    *lpdwRet = ERROR_USER_DISCONNECTION;
                    EndDialog(hDlg, 0);
                }
                else
                {
                    PostMessage(hDlg, WM_COMMAND, IDC_CONNECT, 0);
                    *lpdwRet = ERROR_SUCCESS;
                }
            }

            if (ERROR_SUCCESS != *lpdwRet)
            {
                if (NULL != lpDialParams)
                {
                    LocalFree(lpDialParams);
                    lpDialParams = NULL;
                }
                EndDialog(hDlg, 0);
            }
            return TRUE;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDC_CONNECT:
                    ++g_cDialAttempts;

                    ShowWindow(hDlg, SW_NORMAL);
                    *lpdwRet = lpfnRasDial(
                        NULL,
                        NULL,
                        lpDialParams,
                        (DWORD) -1,
                        (LPVOID)hDlg,
                        &g_hRasConn);

                    if (ERROR_SUCCESS != *lpdwRet)
                    {
                        EndDialog(hDlg, 0);
                    }
                    return TRUE;
                    
                case IDCANCEL:
                    if (NULL != g_hRasConn)
                    {
                        lpfnRasHangUp(g_hRasConn);
                        g_hRasConn = NULL;
                    }
                    *lpdwRet = ERROR_USER_DISCONNECTION;
                    EndDialog(hDlg, 0);
                    return TRUE;

                case IDOK:
                    ShowWindow(hDlg, SW_HIDE);
                    if (MinimizeRNAWindow(g_szEntryName))
                    {
                        EndDialog(hDlg, 0);
                    }
                    else
                    {
                        // try again later
                        SetTimer(hDlg, TIMER_ID, ONE_SECOND, NULL);
                    }
                    return TRUE;
                default:
                    break;
            }

        case WM_TIMER:
            if (ERROR_SUCCESS == *lpdwRet)
            {
                // try to minimize one more time
                MinimizeRNAWindow(g_szEntryName);
                EndDialog(hDlg, 0);
            }
            else if (NULL != g_hRasConn)
            {
                DWORD dwRet;
                RASCONNSTATUS status;

                status.dwSize = sizeof(RASCONNSTATUS);
                dwRet = lpfnRasGetConnectStatus(g_hRasConn, &status);
                if (ERROR_INVALID_HANDLE != dwRet)
                {
                    if (0 == --g_cHangupDelay)
                    {
                        // wait no longer
                        EndDialog(hDlg, 0);
                    }
                    return TRUE;
                }
                // hang up is complete
                g_hRasConn = NULL;
                PostMessage(hDlg, WM_COMMAND, IDC_CONNECT, 0);
            }
            KillTimer(hDlg, TIMER_ID);
            return TRUE;

        case WM_DESTROY:
            if (NULL != lpDialParams)
            {
                LocalFree(lpDialParams);
                lpDialParams = NULL;
            }
            return TRUE;

        default:
            if (uMsg == uEventMsg)
            {
                *lpdwRet = (DWORD)lParam;
                // AutoDialEvent returns TRUE if complete
                if (AutoDialEvent(hDlg, (RASCONNSTATE)wParam, lpdwRet))
                {
                    if (ERROR_SUCCESS == *lpdwRet)
                    {
                        // we can't just exit, if we do we won't minimize window
                        PostMessage(hDlg, WM_COMMAND, IDOK, 0);
                    }
                    else
                    {
                        EndDialog(hDlg, 0);
                    }
                }
                return TRUE;
            }
    }

    return FALSE;
}



static BOOL AutoDialEvent(HWND hDlg, RASCONNSTATE state, LPDWORD lpdwError)
{

    TCHAR szMessage[SMALLBUFLEN + 1];

    _RasGetStateString(state, szMessage, sizeof(szMessage));
    SetDlgItemText(hDlg, IDC_STATUS, szMessage);

    if (ERROR_SUCCESS == *lpdwError)
    {
        if (state & RASCS_DONE)
        {
            // we're done dialing
            return TRUE;
        }
    }
    else
    {
        // looks like we got an error
        // if we haven't hungup already, hangup
        if (NULL != g_hRasConn)
        {
            g_cHangupDelay = MAXHANGUPDELAY;
            lpfnRasHangUp(g_hRasConn);
        }

        if ((ERROR_LINE_BUSY == *lpdwError) && (g_cDialAttempts < NUMRETRIES))
        {
            LoadString(ghInstance, IDS_BUSYREDIAL, szMessage, sizeof(szMessage));
            SetDlgItemText(hDlg, IDC_STATUS, szMessage);

            SetTimer(hDlg, TIMER_ID, ONE_SECOND, NULL);
        }
        else
        {
            TCHAR szError[160];
            TCHAR szFmt[80];
            TCHAR szMessage[240];

            ShowWindow(hDlg, SW_HIDE);

#if 1 
            lpfnRasGetErrorString(
                (int)*lpdwError,
                szError,
                sizeof(szError));

            LoadString(ghInstance, IDS_RETRY, szFmt, sizeof(szFmt));
            
            wsprintf(szMessage, szFmt, szError);
            if (MessageBox(
                    hDlg,
                    szMessage,
                    g_szEntryName,
                    MB_ICONEXCLAMATION |
                    MB_RETRYCANCEL) == IDRETRY)
#else
            if (DialogBoxParam(
                  ghInstance,
                  TEXT("Retry"),
                  hDlg,
                  RetryDlgProc,
                  (LPARAM)*lpdwError) == IDRETRY)
#endif
            {
                ShowWindow(hDlg, SW_SHOW);
                LoadString(ghInstance, IDS_REDIAL, szMessage, sizeof(szMessage));
                SetDlgItemText(hDlg, IDC_STATUS, szMessage);

                g_cDialAttempts = 0;

                SetTimer(hDlg, TIMER_ID, ONE_SECOND, NULL);
            }
            else
            {
                // user cancelled
                *lpdwError = ERROR_USER_DISCONNECTION;
                return TRUE;
            }
        }
    }

    // keep dialing
    return FALSE;
}


static VOID SetDialogTitle(HWND hDlg, LPCTSTR lpszConnectoidName)
{
	TCHAR szFmt[SMALLBUFLEN + 1];
	TCHAR szTitle[RAS_MaxEntryName + SMALLBUFLEN + 1];

    // load the title format ("connecting to <connectoid name>" from resource
    LoadString(ghInstance, IDS_CONNECTING_TO, szFmt, sizeof(szFmt));
    // build the title
    wsprintf(szTitle, szFmt, lpszConnectoidName);

    SetWindowText(hDlg, szTitle);
}



static HWND FindBrowser(void)
{
    HWND hwnd;

    //look for all the microsoft browsers under the sun

    if ((hwnd = FindWindow(szBrowserClass1, NULL)) == NULL)
    {
        if ((hwnd = FindWindow(szBrowserClass2, NULL)) == NULL)
        {
            hwnd = FindWindow(szBrowserClass3, NULL);
        }
    }

    return hwnd;
}
#ifdef WIN16
extern "C" BOOL CALLBACK __export RetryDlgProc(
#else
INT_PTR CALLBACK RetryDlgProc( 
#endif
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            TCHAR szMessage[SMALLBUFLEN + 1];
            lpfnRasGetErrorString(
                (int)lParam,
                szMessage,
                sizeof(szMessage));

            SetDlgItemText(hDlg, IDC_ERROR, szMessage);

            SetWindowText(hDlg, g_szEntryName);

            CenterWindow(hDlg, GetParent(hDlg));

            return TRUE;
        }

        case WM_COMMAND:
            switch (wParam)
            {
                case IDRETRY:
                case IDCANCEL:
                    EndDialog(hDlg, wParam);
                    return TRUE;

                default:
                    break;
            }

        default:
            break;
    }

    return FALSE;
}


#ifdef WIN16
extern "C" BOOL CALLBACK __export PhoneNumberDlgProc(
#else
INT_PTR CALLBACK PhoneNumberDlgProc(
#endif
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    static LPTSTR lpszPhone;

    switch (uMsg)
    {
        case WM_INITDIALOG:

            lpszPhone = (LPTSTR)lParam;
            
            SetDlgItemText(
                hDlg,
                IDC_PHONENUMBER,
                lpszPhone);

            SetWindowText(hDlg, g_szEntryName);

            CenterWindow(hDlg, GetParent(hDlg));

            return TRUE;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDOK:
                    GetDlgItemText(
                        hDlg,
                        IDC_PHONENUMBER,
                        lpszPhone,
                        RAS_MaxPhoneNumber - 5);
                case IDCANCEL:
                    EndDialog(hDlg, wParam);
                    return TRUE;

                default:
                    break;
            }

        default:
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\autodial.inc ===
/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_WARN                ICON    DISCARDABLE     "warning.ico"
//IDI_PHONE               ICON    DISCARDABLE     "phone.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

AUTODIAL DIALOG DISCARDABLE  0, 0, 200, 60
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION ""
FONT 8, "MS Shell Dlg"
BEGIN
    ICON            IDI_PHONE,IDC_STATIC,7,7,21,20
    LTEXT           "Status:",IDC_STATIC,37,7,23,12
    LTEXT           "Preparing to dial",IDC_STATUS,64,7,129,12
    PUSHBUTTON      "Cancel Signup",IDCANCEL,70,39,60,14
END

RETRY DIALOG DISCARDABLE  0, 0, 200, 60
STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
FONT 8, "MS Shell Dlg"
BEGIN
    ICON            IDI_WARN,IDC_STATIC,7,7,21,20,WS_GROUP
    LTEXT           "Static",IDC_ERROR,37,7,156,10
    LTEXT           "Would you like to redial or cancel signup?",IDC_STATIC,
                    37,19,156,10
    DEFPUSHBUTTON   "Redial",IDRETRY,36,39,60,14,WS_GROUP
    PUSHBUTTON      "Cancel Signup",IDCANCEL,108,39,60,14
END

PHONENUMBER DIALOG DISCARDABLE  0, 0, 200, 90
STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
FONT 8, "MS Shell Dlg"
BEGIN
    ICON            IDI_PHONE,IDC_STATIC,7,7,21,20,WS_GROUP
    LTEXT           "Please verify that the number below is correct for dialing.  If you need to dial a special number to get an outside line make sure that it is there.",
                    IDC_STATIC,40,7,153,34
    EDITTEXT        IDC_PHONENUMBER,40,40,88,14,ES_AUTOHSCROLL
    DEFPUSHBUTTON   "Dial Now",IDOK,32,69,60,14,WS_GROUP
    PUSHBUTTON      "Cancel Signup",IDCANCEL,108,69,60,14
END

/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_CONNECTING_TO       "Connecting to %s"
    IDS_STATUS              "Status: %s"
    IDS_RETRY               "%s\n\nWould you like to retry dialing or cancel signup?"
    IDS_REDIAL              "Preparing For Redial"
    IDS_BUSYREDIAL          "Line is busy - Preparing For Redial"
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\client.cpp ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       client.c
//  Content:    This file contains all the functions that handle importing
//              client information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "isignup.h"

HRESULT PopulateNTAutodialAddress(LPCTSTR pszFileName, LPCTSTR pszEntryName);
LPTSTR MoveToNextAddress(LPTSTR lpsz);
#define TAPI_CURRENT_VERSION 0x00010004
#include <tapi.h>

#pragma data_seg(".rdata")

// "INI" file constants
static const TCHAR cszEMailSection[] =       TEXT("Internet_Mail");
static const TCHAR cszEMailName[] =          TEXT("EMail_Name");
static const TCHAR cszEMailAddress[] =       TEXT("EMail_Address");
static const TCHAR cszPOPLogonName[] =       TEXT("POP_Logon_Name");
static const TCHAR cszPOPLogonPassword[] =   TEXT("POP_Logon_Password");
static const TCHAR cszPOPServer[] =          TEXT("POP_Server");
static const TCHAR cszSMTPServer[] =         TEXT("SMTP_Server");
static const TCHAR cszNewsSection[] =        TEXT("Internet_News");
static const TCHAR cszNNTPLogonName[] =      TEXT("NNTP_Logon_Name");
static const TCHAR cszNNTPLogonPassword[] =  TEXT("NNTP_Logon_Password");
static const TCHAR cszNNTPServer[] =         TEXT("NNTP_Server");
static const TCHAR cszUseExchange[] =        TEXT("Use_MS_Exchange");
static const TCHAR cszUserSection[] =        TEXT("User");
static const TCHAR cszDisplayPassword[] =    TEXT("Display_Password");
static const TCHAR cszNull[] = TEXT("");
static const TCHAR cszYes[] = TEXT("yes");
static const TCHAR cszNo[] = TEXT("no");
static const TCHAR cszCMHeader[] =           TEXT("Connection Manager CMS 0");
static const TCHAR cszEntrySection[] =       TEXT("Entry");
static const TCHAR cszEntryName[]    =       TEXT("Entry_Name");

TCHAR FAR cszCMCFG_DLL[] = TEXT("CMCFG32.DLL\0");
CHAR  FAR cszCMCFG_CONFIGURE[] = "CMConfig\0";
CHAR  FAR cszCMCFG_CONFIGUREEX[] = "CMConfigEx\0"; // Proc address

typedef BOOL (WINAPI * CMCONFIGUREEX)(LPCSTR lpszINSFile);
typedef BOOL (WINAPI * CMCONFIGURE)(LPCSTR lpszINSFile, LPCSTR lpszConnectoidNams);
CMCONFIGURE   lpfnCMConfigure;
CMCONFIGUREEX lpfnCMConfigureEx;

#define CLIENT_OFFSET(elem)    ((DWORD)(DWORD_PTR)&(((LPINETCLIENTINFO)(NULL))->elem))
#define CLIENT_SIZE(elem)      sizeof(((LPINETCLIENTINFO)(NULL))->elem)
#define CLIENT_ENTRY(section, value, elem) \
    {section, value, CLIENT_OFFSET(elem), CLIENT_SIZE(elem)}

typedef struct
{
    LPCTSTR  lpszSection;
    LPCTSTR  lpszValue;
    UINT    uOffset;
    UINT    uSize;
} CLIENT_TABLE, FAR *LPCLIENT_TABLE;

CLIENT_TABLE iniTable[] =
{
    CLIENT_ENTRY(cszEMailSection, cszEMailName,         szEMailName),
    CLIENT_ENTRY(cszEMailSection, cszEMailAddress,      szEMailAddress),
    CLIENT_ENTRY(cszEMailSection, cszPOPLogonName,      szPOPLogonName),
    CLIENT_ENTRY(cszEMailSection, cszPOPLogonPassword,  szPOPLogonPassword),
    CLIENT_ENTRY(cszEMailSection, cszPOPServer,         szPOPServer),
    CLIENT_ENTRY(cszEMailSection, cszSMTPServer,        szSMTPServer),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPLogonName,     szNNTPLogonName),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPLogonPassword, szNNTPLogonPassword),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPServer,        szNNTPServer),
    {NULL, NULL, 0, 0}
};

#pragma data_seg()

//
// 5/19/97	jmazner	Olympus #3663
// The branding DLL (IEDKCS32.DLL) is responsible for all
// proxy configuration.
//
/****
DWORD ImportProxySettings(LPCTSTR lpszFile)
{
    TCHAR szServer[MAX_SERVER_NAME + 1];
    TCHAR szOverride[1024];
    LPTSTR lpszServer = NULL;
    LPTSTR lpszOverride = NULL;
    BOOL fEnable = FALSE;

    if (GetPrivateProfileString(cszProxySection,
            cszProxyServer,
            cszNull,
            szServer,
            sizeof(szServer),
            lpszFile) != 0)
    {
        fEnable = TRUE;
        lpszServer = szServer;

        GetPrivateProfileString(cszProxySection,
                cszProxyOverride,
                cszNull,
                szOverride,
                sizeof(szOverride),
                lpszFile);

        lpszOverride = szOverride;
    }
    
    return lpfnInetSetProxy(fEnable, lpszServer, lpszOverride);
}
****/

DWORD ReadClientInfo(LPCTSTR lpszFile, LPINETCLIENTINFO lpClientInfo, LPCLIENT_TABLE lpClientTable)
{
    LPCLIENT_TABLE lpTable;

    for (lpTable = lpClientTable; NULL != lpTable->lpszSection; ++lpTable)
    {
        GetPrivateProfileString(lpTable->lpszSection,
                lpTable->lpszValue,
                cszNull,
                (LPTSTR)((LPBYTE)lpClientInfo + lpTable->uOffset),
                lpTable->uSize / sizeof(TCHAR),
                lpszFile);
    }

    lpClientInfo->dwFlags = 0;
    if (*lpClientInfo->szPOPLogonName)
    {
        lpClientInfo->dwFlags |= INETC_LOGONMAIL;
    }
    if ((*lpClientInfo->szNNTPLogonName) || (*lpClientInfo->szNNTPServer))
    {
        lpClientInfo->dwFlags |= INETC_LOGONNEWS;
    }

    return ERROR_SUCCESS;
}

BOOL WantsExchangeInstalled(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszEMailSection,
            cszUseExchange,
            cszNo,
            szTemp,
            10,
            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}


//+----------------------------------------------------------------------------
//
//    Function:    CallCMConfig
//
//    Synopsis:    Call into the Connection Manager dll's Configure function to allow CM to
//                process the .ins file as needed.
//
//    Arguements: lpszINSFile -- full path to the .ins file
//
//    Returns:    TRUE if a CM profile is created, FALSE otherwise
//
//    History:    09/02/98    DONALDM
//
//-----------------------------------------------------------------------------
BOOL CallCMConfig(LPCTSTR lpszINSFile)
{
    HINSTANCE   hCMDLL = NULL;
    BOOL        bRet = FALSE;

    // Load DLL and entry point
    hCMDLL = LoadLibrary(cszCMCFG_DLL);
    if (NULL != hCMDLL)
    {
        
        // To determine whether we should call CMConfig or CMConfigEx
        // Loop to find the appropriate buffer size to retieve the ins to memory
        ULONG ulBufferSize = 1024*10;
        // Parse the ISP section in the INI file to find query pair to append
        TCHAR *pszKeys = NULL;
        PTSTR pszKey = NULL;
        ULONG ulRetVal     = 0;
        BOOL  bEnumerate = TRUE;
        BOOL  bUseEx = FALSE;
 
        PTSTR pszBuff = NULL;
        ulRetVal = 0;

        pszKeys = new TCHAR [ulBufferSize];
        while (ulRetVal < (ulBufferSize - 2))
        {

            ulRetVal = ::GetPrivateProfileString(NULL, NULL, _T(""), pszKeys, ulBufferSize, lpszINSFile);
            if (0 == ulRetVal)
               bEnumerate = FALSE;

            if (ulRetVal < (ulBufferSize - 2))
            {
                break;
            }
            delete [] pszKeys;
            ulBufferSize += ulBufferSize;
            pszKeys = new TCHAR [ulBufferSize];
            if (!pszKeys)
            {
                bEnumerate = FALSE;
            }

        }

        if (bEnumerate)
        {
            pszKey = pszKeys;
            if (ulRetVal != 0) 
            {
                while (*pszKey)
                {
                    if (!lstrcmpi(pszKey, cszCMHeader)) 
                    {
                        bUseEx = TRUE;
                        break;
                    }
                    pszKey += lstrlen(pszKey) + 1;
                }
            }
        }


        if (pszKeys)
            delete [] pszKeys;

        TCHAR   szConnectoidName[RAS_MaxEntryName];
        // Get the connectoid name from the [Entry] Section
        GetPrivateProfileString(cszEntrySection,
                                    cszEntryName,
                                    cszNull,
                                    szConnectoidName,
                                    RAS_MaxEntryName,
                                    lpszINSFile);
        if (bUseEx)
        {
            // Call CMConfigEx
            lpfnCMConfigureEx = (CMCONFIGUREEX)GetProcAddress(hCMDLL,cszCMCFG_CONFIGUREEX);
            if( lpfnCMConfigureEx )
            {
#ifdef UNICODE
                CHAR szFile[_MAX_PATH + 1];

                wcstombs(szFile, lpszINSFile, _MAX_PATH + 1);

                bRet = lpfnCMConfigureEx(szFile);    
#else
                bRet = lpfnCMConfigureEx(lpszINSFile);    
#endif
            }
        }
        else
        {
            // Call CMConfig
            lpfnCMConfigure = (CMCONFIGURE)GetProcAddress(hCMDLL,cszCMCFG_CONFIGURE);
            if( lpfnCMConfigure )
            {

#ifdef UNICODE
                CHAR szEntry[RAS_MaxEntryName];
                CHAR szFile[_MAX_PATH + 1];

                wcstombs(szEntry, szConnectoidName, RAS_MaxEntryName);
                wcstombs(szFile, lpszINSFile, _MAX_PATH + 1);

                bRet = lpfnCMConfigure(szFile, szEntry);  
#else
                bRet = lpfnCMConfigure(lpszINSFile, szConnectoidName);  
#endif
            }
        }

        if (bRet)
        {
            // restore original autodial settings
            lpfnInetSetAutodial(TRUE, szConnectoidName);
        }     
    }

    // Cleanup
    if( hCMDLL )
        FreeLibrary(hCMDLL);
    if( lpfnCMConfigure )
        lpfnCMConfigure = NULL;

    return bRet;
}

BOOL DisplayPassword(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszUserSection,
            cszDisplayPassword,
            cszNo,
            szTemp,
            10,
            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

DWORD ImportClientInfo(
    LPCTSTR lpszFile,
    LPINETCLIENTINFO lpClientInfo)
{
    DWORD dwRet;

    lpClientInfo->dwSize = sizeof(INETCLIENTINFO);

    dwRet = ReadClientInfo(lpszFile, lpClientInfo, iniTable);

    return dwRet;
}

DWORD ConfigureClient(
    HWND hwnd,
    LPCTSTR lpszFile,
    LPBOOL lpfNeedsRestart,
    LPBOOL lpfConnectoidCreated,
    BOOL fHookAutodial,
    LPTSTR szConnectoidName,
    DWORD dwConnectoidNameSize   
    )
{
    LPICONNECTION pConn;
    LPINETCLIENTINFO pClientInfo;
    DWORD dwRet = ERROR_SUCCESS;
    UINT cb = sizeof(ICONNECTION) + sizeof(INETCLIENTINFO);
    DWORD dwfOptions = INETCFG_INSTALLTCP | INETCFG_WARNIFSHARINGBOUND;
    LPRASENTRY pRasEntry = NULL;

	//
	// ChrisK Olympus 4756 5/25/97
	// Do not display busy animation on Win95
	//
	if (IsNT())
	{
		dwfOptions |=  INETCFG_SHOWBUSYANIMATION;
	}

    // Allocate a buffer for connection and clientinfo objects
    //
    if ((pConn = (LPICONNECTION)LocalAlloc(LPTR, cb)) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }
    
    if (WantsExchangeInstalled(lpszFile))
    {
        dwfOptions |= INETCFG_INSTALLMAIL;
    }

    // Create either a CM profile, or a connectoid
    if (CallCMConfig(lpszFile))
    {
        *lpfConnectoidCreated = TRUE;       // A dialup connection was created
    }
    else
    {

        dwRet = ImportConnection(lpszFile, pConn);
        if (ERROR_SUCCESS == dwRet)
        {
            pRasEntry = &pConn->RasEntry;
            dwfOptions |= INETCFG_SETASAUTODIAL |
                        INETCFG_INSTALLRNA |
                        INETCFG_INSTALLMODEM;
        }
        else if (ERROR_NO_MATCH == dwRet)
        {
            // 10/07/98 vyung IE bug#32882 hack.
            // If we do not detect the [Entry] section in the ins file,
            // we will assume it is an OE ins file.  Then we will assume
            // we have a autodial connection and pass the INS to OE.
            return dwRet;
        }
        else if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY != dwRet)
        {
            return dwRet;
        } 

        if (DisplayPassword(lpszFile))
        {
            if (*pConn->szPassword || *pConn->szUserName)
            {
                TCHAR szFmt[128];
                TCHAR szMsg[384];

                LoadString(ghInstance,IDS_PASSWORD,szFmt,sizeof(szFmt));
                wsprintf(szMsg, szFmt, pConn->szUserName, pConn->szPassword);

                MessageBox(hwnd,szMsg,cszAppName,MB_ICONINFORMATION | MB_OK);
            }
        }

        if (fHookAutodial &&
            ((0 == *pConn->RasEntry.szAutodialDll) ||
            (0 == *pConn->RasEntry.szAutodialFunc)))
        {
            lstrcpy(pConn->RasEntry.szAutodialDll, TEXT("isign32.dll"));
            lstrcpy(pConn->RasEntry.szAutodialFunc, TEXT("AutoDialLogon"));
        }
 
        if (ERROR_SUCCESS != dwRet)
        {
            pClientInfo = NULL;

        }

        // humongous hack for ISBU
        dwRet = lpfnInetConfigClient(hwnd,
                                     NULL,
                                     pConn->szEntryName,
                                     pRasEntry,
                                     pConn->szUserName,
                                     pConn->szPassword,
                                     NULL,
                                     NULL,
                                     dwfOptions & ~INETCFG_INSTALLMAIL,
                                     lpfNeedsRestart);
        lstrcpy(szConnectoidName, pConn->szEntryName);

        LclSetEntryScriptPatch(pRasEntry->szScript,pConn->szEntryName);
	    BOOL fEnabled = TRUE;
	    DWORD dwResult = 0xba;
	    dwResult = lpfnInetGetAutodial(&fEnabled, pConn->szEntryName, RAS_MaxEntryName+1);
	    if ((ERROR_SUCCESS == dwRet) && lstrlen(pConn->szEntryName))
	    {
		    *lpfConnectoidCreated = (NULL != pRasEntry);
            PopulateNTAutodialAddress( lpszFile, pConn->szEntryName );
	    }
	    else
	    {
		    DebugOut("ISIGNUP: ERROR: InetGetAutodial failed, will not be able to set NT Autodial\n");
	    }
    }

    if (ERROR_SUCCESS == dwRet)
    {
        // Get the mail client info
        INETCLIENTINFO pClientInfo;

        ImportClientInfo(lpszFile, &pClientInfo);
   
        dwRet = lpfnInetConfigClient(
                hwnd,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                &pClientInfo,
                dwfOptions & INETCFG_INSTALLMAIL,
                lpfNeedsRestart);
    }

    LocalFree(pConn);

    return dwRet;
 }


//+----------------------------------------------------------------------------
//
//	Function:	PopulateNTAutodialAddress
//
//	Synopsis:	Take Internet addresses from INS file and load them into the
//				autodial database
//
//	Arguments:	pszFileName - pointer to INS file name
//
//	Returns:	Error code (ERROR_SUCCESS == success)
//
//	History:	8/29/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
#define AUTODIAL_ADDRESS_BUFFER_SIZE 2048
#define AUTODIAL_ADDRESS_SECTION_NAME TEXT("Autodial_Addresses_for_NT")
HRESULT PopulateNTAutodialAddress(LPCTSTR pszFileName, LPCTSTR pszEntryName)
{
	HRESULT hr = ERROR_SUCCESS;
	LONG lRC = 0;
	LPLINETRANSLATECAPS lpcap = NULL;
	LPLINETRANSLATECAPS lpTemp = NULL;
	LPLINELOCATIONENTRY lpLE = NULL;
	LPRASAUTODIALENTRY rADE;
	INT idx = 0;
	LPTSTR lpszBuffer = NULL;
	LPTSTR lpszNextAddress = NULL;
	rADE = NULL;

	//RNAAPI *pRnaapi = NULL;

	// jmazner  10/8/96  this function is NT specific
	if( !IsNT() )
	{
		DebugOut("ISIGNUP: Bypassing PopulateNTAutodialAddress for win95.\r\n");
		return( ERROR_SUCCESS );
	}

	//Assert(pszFileName && pszEntryName);
	//dprintf("ISIGNUP: PopulateNTAutodialAddress "%s %s.\r\n",pszFileName, pszEntryName);
	DebugOut(pszFileName);
	DebugOut(", ");
	DebugOut(pszEntryName);
	DebugOut(".\r\n");

	// allocate this guy for making softlink calls to Ras functions
	//pRnaapi = new RNAAPI;
	//if( !pRnaapi )
	//{
		//hr = ERROR_NOT_ENOUGH_MEMORY;
		//goto PopulateNTAutodialAddressExit;
	//}

	//
	// Get list of TAPI locations
	//

	lpcap = (LPLINETRANSLATECAPS)GlobalAlloc(GPTR,sizeof(LINETRANSLATECAPS));
	if (!lpcap)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto PopulateNTAutodialAddressExit;
	}
	lpcap->dwTotalSize = sizeof(LINETRANSLATECAPS);
	lRC = lineGetTranslateCaps(0,0x10004,lpcap);
	if (SUCCESS == lRC)
	{
		lpTemp = (LPLINETRANSLATECAPS)GlobalAlloc(GPTR,lpcap->dwNeededSize);
		if (!lpTemp)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto PopulateNTAutodialAddressExit;
		}
		lpTemp->dwTotalSize = lpcap->dwNeededSize;
		GlobalFree(lpcap);
		lpcap = (LPLINETRANSLATECAPS)lpTemp;
		lpTemp = NULL;
		lRC = lineGetTranslateCaps(0,0x10004,lpcap);
	}

	if (SUCCESS != lRC)
	{
		hr = (HRESULT)lRC; // REVIEW: not real sure about this.
		goto PopulateNTAutodialAddressExit;
	}

	//
	// Create an array of RASAUTODIALENTRY structs
	//
	
	rADE = (LPRASAUTODIALENTRY)GlobalAlloc(GPTR,
		sizeof(RASAUTODIALENTRY)*lpcap->dwNumLocations);
	if (!rADE)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto PopulateNTAutodialAddressExit;
	}
	

	//
	// Enable autodialing for all locations
	//
	idx = lpcap->dwNumLocations;
	lpLE = (LPLINELOCATIONENTRY)((DWORD_PTR)lpcap + (DWORD)lpcap->dwLocationListOffset);
	while (idx)
	{
		idx--;
		lpfnRasSetAutodialEnable(lpLE[idx].dwPermanentLocationID,TRUE);

		//
		// fill in array values
		//
		rADE[idx].dwSize = sizeof(RASAUTODIALENTRY);
		rADE[idx].dwDialingLocation = lpLE[idx].dwPermanentLocationID;
		lstrcpyn(rADE[idx].szEntry,pszEntryName,RAS_MaxEntryName);
	}

	//
	// Get list of addresses
	//
	lpszBuffer = (LPTSTR)GlobalAlloc(GPTR,AUTODIAL_ADDRESS_BUFFER_SIZE);
	if (!lpszBuffer)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto PopulateNTAutodialAddressExit;
	}

	if((AUTODIAL_ADDRESS_BUFFER_SIZE-2) == GetPrivateProfileSection(AUTODIAL_ADDRESS_SECTION_NAME,
		lpszBuffer,AUTODIAL_ADDRESS_BUFFER_SIZE,pszFileName))
	{
		//AssertSz(0,"Autodial address section bigger than buffer.\r\n");
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto PopulateNTAutodialAddressExit;
	}

	//
	// Walk list of addresses and set autodialing for each one
	//
	lpszNextAddress = lpszBuffer;
	do
	{
		lpszNextAddress = MoveToNextAddress(lpszNextAddress);
		if (!(*lpszNextAddress))
			break;	// do-while
		lpfnRasSetAutodialAddress(lpszNextAddress,0,rADE,
			sizeof(RASAUTODIALENTRY)*lpcap->dwNumLocations,lpcap->dwNumLocations);
		lpszNextAddress = lpszNextAddress + lstrlen(lpszNextAddress);
	} while(1);

PopulateNTAutodialAddressExit:
	if (lpcap) 
		GlobalFree(lpcap);
	lpcap = NULL;
	if (rADE)
		GlobalFree(rADE);
	rADE = NULL;
	if (lpszBuffer)
		GlobalFree(lpszBuffer);
	lpszBuffer = NULL;
	//if( pRnaapi )
	//	delete pRnaapi;
	//pRnaapi = NULL;
	return hr;
}



//+----------------------------------------------------------------------------
//
//	Function:	MoveToNextAddress
//
//	Synopsis:	Given a pointer into the data bufffer, this function will move
//				through the buffer until it points to the begining of the next
//				address or it reaches the end of the buffer.
//
//	Arguements:	lpsz - pointer into buffer
//
//	Returns:	Pointer to the next address, return value will point to NULL
//				if there are no more addresses
//
//	History:	8/29/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
LPTSTR MoveToNextAddress(LPTSTR lpsz)
{
	BOOL fLastCharWasNULL = FALSE;

	//AssertSz(lpsz,"MoveToNextAddress: NULL input\r\n");

	//
	// Look for an = sign
	//
	do
	{
		if (fLastCharWasNULL && '\0' == *lpsz)
			break; // are we at the end of the data?

		if ('\0' == *lpsz)
			fLastCharWasNULL = TRUE;
		else
			fLastCharWasNULL = FALSE;

		if ('=' == *lpsz)
			break;

		if (*lpsz)
			lpsz = CharNext(lpsz);
		else
			lpsz += sizeof(TCHAR);
	} while (1);
	
	//
	// Move to the first character beyond the = sign.
	//
	if (*lpsz)
		lpsz = CharNext(lpsz);

	return lpsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\dialutil.h ===
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   dialutil.h
//
//  PURPOSE:  contains dialutil declarations
//


#ifndef _DIALUTIL_H
#define _DIALUTIL_H

#define IDS_RASCS                    100
#define IDS_OPENPORT                 IDS_RASCS+ 0
#define IDS_PORTOPENED               IDS_RASCS+ 1
#define IDS_CONNECTDEVICE            IDS_RASCS+ 2
#define IDS_DEVICECONNECTED          IDS_RASCS+ 3
#define IDS_ALLDEVICESCONNECTED      IDS_RASCS+ 4
#define IDS_AUTHENTICATE             IDS_RASCS+ 5
#define IDS_AUTHNOTIFY               IDS_RASCS+ 6
#define IDS_AUTHRETRY                IDS_RASCS+ 7
#define IDS_AUTHCALLBACK             IDS_RASCS+ 8
#define IDS_AUTHCHANGEPASSWORD       IDS_RASCS+ 9
#define IDS_AUTHPROJECT              IDS_RASCS+10
#define IDS_AUTHLINKSPEED            IDS_RASCS+11
#define IDS_AUTHACK                  IDS_RASCS+12
#define IDS_REAUTHENTICATE           IDS_RASCS+13
#define IDS_AUTHENTICATED            IDS_RASCS+14
#define IDS_PREPAREFORCALLBACK       IDS_RASCS+15
#define IDS_WAITFORMODEMRESET        IDS_RASCS+16
#define IDS_WAITFORCALLBACK          IDS_RASCS+17
#define IDS_INTERACTIVE              IDS_RASCS+18
#define IDS_RETRYAUTHENTICATION      IDS_RASCS+19
#define IDS_CALLBACKSETBYCALLER      IDS_RASCS+20
#define IDS_PASSWORDEXPIRED          IDS_RASCS+21
#define IDS_CONNECTED                IDS_RASCS+22
#define IDS_DISCONNECTED             IDS_RASCS+23
#define IDS_RASCS_END                IDS_DISCONNECTED
#define IDS_UNDEFINED_ERROR          IDS_RASCS_END+1

#define IDS_CONNECTED_TO             200


BOOL MinimizeRNAWindow(LPTSTR pszConnectoidName);
DWORD GetPhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber);
LPTSTR NEAR PASCAL GetDisplayPhone(LPTSTR szPhoneNum);
DWORD _RasGetStateString(RASCONNSTATE state, LPTSTR lpszState, DWORD cb);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\dialutil.cpp ===
#ifdef WIN16 
typedef int WCHAR;
#include <memory.h>
#include <ietapi.h>
#endif
#include "isignup.h"
#include <tapi.h>
#include "dialutil.h"

#define CANONICAL_CAP      TEXT("+%d (%s) %s")
#define CANONICAL_CXP      TEXT("+%d %s")

#define TAPI_VERSION        0x00010004

#define SMALLBUFLEN 80
#define ASSERT(c)
#define TRACE_OUT(c)

#define lstrnicmp(sz1, sz2, cch)          (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, sz1, cch, sz2, cch) - 2)
#define lstrncmp(sz1, sz2, cch)           (CompareString(LOCALE_USER_DEFAULT, 0, sz1, cch, sz2, cch) - 2)

static const TCHAR szRnaAppWindowClass[] = TEXT("#32770");	// hard coded dialog class name

#ifdef WIN16

#define NORM_IGNORECASE         0x00000001  /* ignore case */ 
#define LOCALE_USER_DEFAULT		0

int CompareString(
    LCID Locale,	// locale identifier 
    DWORD dwCmpFlags,	// comparison-style options 
    LPCTSTR lpString1,	// pointer to first string 
    int cchCount1,	// size, in bytes or characters, of first string 
    LPCTSTR lpString2,	// pointer to second string 
    int cchCount2 	// size, in bytes or characters, of second string  
   )
{ 
	//
	// This is kind of tricky, but it should work.  We'll save the
	// characters at the end of the strings, put a NULL in their
	// place, use lstrcmp and lstrcmpi, and then replace the
	// characters.
	//
	TCHAR cSave1, cSave2;    
	int iRet;
	
	cSave1 = lpString1[cchCount1];
	lpString1[cchCount1] = '\0';
	cSave2 = lpString2[cchCount2];
	lpString2[cchCount2] = '\0';
	
	if (dwCmpFlags & NORM_IGNORECASE)
		iRet = lstrcmpi(lpString1, lpString2) + 2;
	else
		iRet = lstrcmp(lpString1, lpString2) + 2;
	
	lpString1[cchCount1] = cSave1;
	lpString2[cchCount2] = cSave2;
                                 
	return iRet;
}
#endif

void CALLBACK LineCallbackProc (DWORD handle, DWORD dwMsg, DWORD dwInst,
                                DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);

static HWND hwndFound = NULL;

static BOOL CALLBACK MyEnumWindowsProc(HWND hwnd, LPARAM lparam)
{
	TCHAR szTemp[SMALLBUFLEN+2];
	LPTSTR pszTitle;
	UINT uLen1, uLen2;

	if(!IsWindowVisible(hwnd))
		return TRUE;
	if(GetClassName(hwnd, szTemp, SMALLBUFLEN)==0)
		return TRUE; // continue enumerating
	if(lstrcmp(szTemp, szRnaAppWindowClass)!=0)
		return TRUE;
	if(GetWindowText(hwnd, szTemp, SMALLBUFLEN)==0)
		return TRUE;
	szTemp[SMALLBUFLEN] = 0;
	uLen1 = lstrlen(szTemp);
	if (uLen1 > 5)
		uLen1 -= 5; // skip last 5 chars of title (avoid "...")
	pszTitle = (LPTSTR)lparam;
	ASSERT(pszTitle);
	uLen2 = lstrlen(pszTitle);
	TRACE_OUT(("Title=(%s), len=%d, Window=(%s), len=%d\r\n", pszTitle, uLen2, szTemp, uLen1));
	if(uLen2 < uLen1)
		return TRUE;
	if(lstrnicmp(pszTitle, szTemp, uLen1)!=0)
		return TRUE;
	hwndFound = hwnd;
	return FALSE;
}

static HWND MyFindRNAWindow(LPTSTR pszTitle)
{
	DWORD dwRet;
	hwndFound = NULL;
	dwRet = EnumWindows((WNDENUMPROC)(&MyEnumWindowsProc), (LPARAM)pszTitle);
	TRACE_OUT(("EnumWindows returned %d\r\n", dwRet));
	return hwndFound;
}


/*******************************************************************

	NAME:		MinimizeRNAWindow

	SYNOPSIS:	Finds and minimizes the annoying RNA window

    ENTRY:		pszConnectoidName - name of connectoid launched

********************************************************************/
BOOL MinimizeRNAWindow(LPTSTR pszConnectoidName)
{
	HWND hwndRNAApp;
	TCHAR szFmt[SMALLBUFLEN + 1];
	TCHAR szTitle[RAS_MaxEntryName + SMALLBUFLEN + 1];
	
	// load the title format ("connected to <connectoid name>" from resource
	LoadString(ghInstance, IDS_CONNECTED_TO, szFmt, sizeof(szFmt));
	// build the title
	wsprintf(szTitle, szFmt, pszConnectoidName);

	hwndRNAApp=MyFindRNAWindow((LPTSTR)szTitle);
	if(hwndRNAApp)
	{
		// minimize the RNA window
		ShowWindow(hwndRNAApp,SW_MINIMIZE);
        return TRUE;
	}
    return FALSE;
}

//****************************************************************************
// static LPTSTR NEAR PASCAL GetDisplayPhone (LPTSTR)
//
// This function returns the pointer to displayable phone number. It stripped
//   all the prefixes we do not want to show to the user.
//
// History:
//  Tue 26-Jul-1994 16:07:00  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

LPTSTR NEAR PASCAL GetDisplayPhone (LPTSTR szPhoneNum)
{
  // Check whether the first string is the know prefix
  //
  if ((*szPhoneNum == 'T') || (*szPhoneNum == 'P'))
  {
    // It is the prefix
    //
    szPhoneNum++;

    // The first displayable number is not white space after prefix
    //
    while ((*szPhoneNum == ' ') || (*szPhoneNum == '\t'))
      szPhoneNum++;
  };
  return szPhoneNum;
}

void CALLBACK LineCallbackProc (DWORD handle, DWORD dwMsg, DWORD dwInst,
                                DWORD dwParam1, DWORD dwParam2, DWORD dwParam3)
{
}

//****************************************************************************
// TranslateCanonicalAddress()
//
// Function: This function translate a canonical address to a dialable address.
//
// Returns:  SUCCESS or an error code
//
//****************************************************************************

static DWORD NEAR PASCAL TranslateCanonicalAddress(DWORD dwID, LPTSTR szCanonical,
                                            LPTSTR szDialable, DWORD cb)
{
  DWORD dwRet;

#ifdef WIN16

	char szBuffer[1024];
	LPLINETRANSLATEOUTPUT lpLine;
	
	memset(&szBuffer[0], 0, sizeof(szBuffer));
	lpLine = (LPLINETRANSLATEOUTPUT) & szBuffer[0];
	lpLine->dwTotalSize = sizeof(szBuffer);
	dwRet = IETapiTranslateAddress(NULL, szCanonical, 0L, 0L, lpLine);
	if (0 == dwRet)
		lstrcpy(szDialable, &szBuffer[lpLine->dwDialableStringOffset+3]);
		
#else //WIN16

  LINETRANSLATEOUTPUT lto, FAR* lplto;
  DWORD cDevices;
  HLINEAPP hApp;
  
  if ((dwRet = lineInitialize(&hApp, ghInstance,
                                (LINECALLBACK)LineCallbackProc,
                                NULL, &cDevices)) == SUCCESS)
  {

    // Get the actual buffer size
    lto.dwTotalSize = sizeof(lto);
    if ((dwRet = lineTranslateAddress(hApp, dwID,
                                      TAPI_VERSION, szCanonical, 0,
                                      LINETRANSLATEOPTION_CANCELCALLWAITING,
                                      &lto)) == SUCCESS)
    {
      // Allocate the dialable number buffer
      if ((lplto = (LPLINETRANSLATEOUTPUT)LocalAlloc(LMEM_FIXED, lto.dwNeededSize))
          != NULL)
      {
        // Translate the phone number
        lplto->dwTotalSize = lto.dwNeededSize;
        if ((dwRet = lineTranslateAddress(hApp, dwID,
                                          TAPI_VERSION, szCanonical, 0,
                                          LINETRANSLATEOPTION_CANCELCALLWAITING,
                                          lplto)) == SUCCESS)
        {
          LPTSTR szPhone;

          szPhone = (LPTSTR)(((LPBYTE)lplto)+lplto->dwDialableStringOffset);
          lstrcpyn(szDialable, szPhone, (int)cb);
        }
        else
          dwRet = ERROR_TAPI_CONFIGURATION;


        LocalFree(lplto);
      }
      else
        dwRet = ERROR_OUTOFMEMORY;
    }
    else
      dwRet = ERROR_TAPI_CONFIGURATION;
  }
  else
    dwRet = ERROR_TAPI_CONFIGURATION;

  lineShutdown(hApp);
  
#endif	// #ifdef WIN16 ... #else ...

  return dwRet;
}

//****************************************************************************
// DWORD NEAR PASCAL BuildPhoneString (LPBYTE, LPPHONENUM)
//
// This function builds a phone number string from the phone number struct
//
// History:
//  Mon 14-Mar-1994 13:10:44  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

static DWORD NEAR PASCAL BuildPhoneString (LPTSTR szPhoneNum, LPRASENTRY lpRasEntry)
{
  if (*lpRasEntry->szAreaCode != '\0')
  {
    wsprintf(szPhoneNum, CANONICAL_CAP, lpRasEntry->dwCountryCode,
             lpRasEntry->szAreaCode, lpRasEntry->szLocalPhoneNumber);
  }
  else
  {
    wsprintf(szPhoneNum, CANONICAL_CXP, lpRasEntry->dwCountryCode,
             lpRasEntry->szLocalPhoneNumber);
  };
  return SUCCESS;
};

//****************************************************************************
// BOOL NEAR PASCAL TranslatePhoneNumber(LPTSTR, LPPHONENUM, LPTSTR)
//
// Translate phone number into a dialble string.
//
// Returns TRUE if successful, FALSE if use default.
//
// History:
//   Fri 17-Jun-1994 08:42:49  -by-  Viroon  Touranachun [viroont]
// Created
//****************************************************************************

static BOOL NEAR PASCAL TranslatePhoneNumber(LPRASENTRY lpRasEntry, LPTSTR szPhoneNumber)
{
  TCHAR    szOrgPhone[RAS_MaxPhoneNumber+1];

  // Do we need to use the addrees book phone number?
  //
  if (lpRasEntry != NULL)
  {
    // Yes! Do we need to translate anything?
    //
    if (lpRasEntry->dwCountryID == 0)
    {
      // No! we dial as is.
      //
      lstrcpyn(szOrgPhone, lpRasEntry->szLocalPhoneNumber, sizeof(szOrgPhone));
    }
    else
    {
      // Yes! build the phone number
      //
      BuildPhoneString (szOrgPhone, lpRasEntry);
    };
  }
  else
  {
    // No! we have a overwritten phone number
    //
    ASSERT(lstrlen(szPhoneNumber) != 0);
    lstrcpyn(szOrgPhone, szPhoneNumber, sizeof(szOrgPhone));
  };

  // Attempt address translation
  //
  if (TranslateCanonicalAddress(0, szOrgPhone,
                            szPhoneNumber, RAS_MaxPhoneNumber+1)
  != ERROR_SUCCESS)
  {
    // Translation fails, use default phone number
    //
    if (lpRasEntry != NULL)
    {
      // Use entry's local phone number
      //
      lstrcpy(szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
    }
    else
    {
      // Restore the original phone number
      //
      lstrcpy(szPhoneNumber, szOrgPhone);
    };
    return FALSE;
  };

  return TRUE;
}


DWORD GetPhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber)
{
    DWORD dwEntrySize = 0;
    DWORD dwSize = 0;
    DWORD dwRet;
    LPRASENTRY lpRasEntry = NULL;

    // get size needed for RASENTRY struct
    lpfnRasGetEntryProperties(
        NULL,
        lpszEntryName,
	    NULL,
        &dwEntrySize,
        NULL,
        &dwSize);

    lpRasEntry = (LPRASENTRY)LocalAlloc(LPTR, dwEntrySize + dwSize);

    if (NULL == lpRasEntry)
    {
        dwRet = ERROR_OUTOFMEMORY;
    }
    else
    {
        lpRasEntry->dwSize = dwEntrySize;

        dwRet = lpfnRasGetEntryProperties(
            NULL,
            lpszEntryName,
	        (LPBYTE)lpRasEntry,
            &dwEntrySize,
            ((LPBYTE)lpRasEntry) + dwEntrySize,
            &dwSize);

        if (ERROR_SUCCESS == dwRet)
        {
            TranslatePhoneNumber(lpRasEntry, lpszPhoneNumber);
        }

        LocalFree(lpRasEntry);
    }

    return dwRet;
}

DWORD _RasGetStateString(RASCONNSTATE state, LPTSTR lpszState, DWORD cb)
{
    UINT idString;

    switch(state)
    {
        case RASCS_OpenPort:
            idString  = IDS_OPENPORT;
            break;
        case RASCS_PortOpened:
            idString = IDS_PORTOPENED;            
            break;
        case RASCS_ConnectDevice:
            idString = IDS_CONNECTDEVICE;        
            break;
        case RASCS_DeviceConnected:
            idString = IDS_DEVICECONNECTED;       
            break;
        case RASCS_AllDevicesConnected:
            idString = IDS_ALLDEVICESCONNECTED;   
            break;
        case RASCS_Authenticate:
            idString = IDS_AUTHENTICATE;          
            break;
        case RASCS_AuthNotify:
            idString = IDS_AUTHNOTIFY;            
            break;
        case RASCS_AuthRetry:
            idString = IDS_AUTHRETRY;             
            break;
        case RASCS_AuthCallback:
            idString = IDS_AUTHCALLBACK;          
            break;
        case RASCS_AuthChangePassword:
            idString = IDS_AUTHCHANGEPASSWORD;    
            break;
        case RASCS_AuthProject:
            idString = IDS_AUTHPROJECT;           
            break;
        case RASCS_AuthLinkSpeed:
            idString = IDS_AUTHLINKSPEED;         
            break;
        case RASCS_AuthAck: 
            idString = IDS_AUTHACK;               
            break;
        case RASCS_ReAuthenticate:
            idString = IDS_REAUTHENTICATE;        
            break;
        case RASCS_Authenticated:
            idString = IDS_AUTHENTICATED;         
            break;
        case RASCS_PrepareForCallback:
            idString = IDS_PREPAREFORCALLBACK;    
            break;
        case RASCS_WaitForModemReset:
            idString = IDS_WAITFORMODEMRESET;     
            break;
        case RASCS_WaitForCallback:
            idString = IDS_WAITFORCALLBACK;       
            break;
        case RASCS_Interactive:
            idString = IDS_INTERACTIVE;           
            break;
        case RASCS_RetryAuthentication: 
            idString = IDS_RETRYAUTHENTICATION;            
            break;
        case RASCS_CallbackSetByCaller: 
            idString = IDS_CALLBACKSETBYCALLER;   
            break;
        case RASCS_PasswordExpired:
            idString = IDS_PASSWORDEXPIRED;       
            break;
        case RASCS_Connected:
            idString = IDS_CONNECTED;            
            break;
        case RASCS_Disconnected:
            idString = IDS_DISCONNECTED;          
            break;
        default:
            idString = IDS_UNDEFINED_ERROR;
            break;
    }
    if (LoadString(ghInstance, idString, lpszState, (int)cb))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\enumodem.h ===
// jmazner  pinched from inetcfg\rnacall.h class ENUM_MODEM

class CEnumModem
{
private:
  DWORD         m_dwError;
  DWORD         m_dwNumEntries;
  DWORD         m_dwIndex;
  LPRASDEVINFO  m_lpData;
public:
  CEnumModem();
  ~CEnumModem();
  DWORD ReInit();
  TCHAR * Next();
  TCHAR * GetDeviceTypeFromName(LPTSTR szDeviceName);
  TCHAR * GetDeviceNameFromType(LPTSTR szDeviceType);
  BOOL VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType);
  DWORD GetNumDevices() { return m_dwNumEntries; }
  DWORD GetError()  { return m_dwError; }
  void  ResetIndex() { m_dwIndex = 0; }
};

// from inetcfg\export.cpp
// structure to pass data back from IDD_CHOOSEMODEMNAME handler
typedef struct tagCHOOSEMODEMDLGINFO
{
  TCHAR szModemName[RAS_MaxDeviceName + 1];
} CHOOSEMODEMDLGINFO, * PCHOOSEMODEMDLGINFO;

INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);
BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);


//rnacall.cpp
HRESULT InitModemList(HWND hCB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\dialutil.inc ===
/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_OPENPORT            "Opening Port"
    IDS_PORTOPENED          "Port Opened"
    IDS_CONNECTDEVICE       "Connecting Device"
    IDS_DEVICECONNECTED     "Device Connected"
    IDS_ALLDEVICESCONNECTED "All Devices Connected"
    IDS_AUTHENTICATE        "Starting Authentication"
    IDS_AUTHNOTIFY          "Authentication Notify"
    IDS_AUTHRETRY           "Authentication Retry"
    IDS_AUTHCALLBACK        "Callback Requested"
    IDS_AUTHCHANGEPASSWORD  "Change Password Requested"
    IDS_AUTHPROJECT         "Projection Phase Started"
    IDS_AUTHLINKSPEED       "Link Speed Calculation"
    IDS_AUTHACK             "Authentication Acknowledged"
    IDS_REAUTHENTICATE      "Reauthentication Started"
    IDS_AUTHENTICATED       "Authenticated"
    IDS_PREPAREFORCALLBACK  "Preparation For Callback"
    IDS_WAITFORMODEMRESET   "Waiting For Modem Reset"
    IDS_WAITFORCALLBACK     "Waiting For Callback"
    IDS_INTERACTIVE         "Interactive"
    IDS_RETRYAUTHENTICATION "Retry Authentication"
    IDS_CALLBACKSETBYCALLER "Callback Set By Caller"
    IDS_PASSWORDEXPIRED     "Password Expired"
    IDS_CONNECTED           "Connected"
    IDS_DISCONNECTED        "Disconnected"
    IDS_UNDEFINED_ERROR     "Undefine Error Code"
    IDS_CONNECTED_TO        "Connected to %s"
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\custom.cpp ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       custom.c
//  Content:    This file contains all the functions that handle importing
//              connection information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//          some of this code started its life in ixport.c in RNAUI.DLL
//          my thanks to viroont
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "isignup.h"


#pragma data_seg(".rdata")

static const TCHAR cszCustomSection[]      = TEXT("Custom");
static const TCHAR cszFileName[]           = TEXT("Custom_File");
static const TCHAR cszRun[]                = TEXT("Run");
static const TCHAR cszArgument[]           = TEXT("Argument");
static const TCHAR cszCustomFileSection[]  = TEXT("Custom_File");

static const TCHAR cszNull[] = TEXT("");

#pragma data_seg()

//****************************************************************************
// DWORD NEAR PASCAL ImportCustomFile(LPSTR szImportFile)
//
// This function imports the custom file
//
// History:
//  Mon 21-Mar-1996 12:40:00  -by-  Mark MacLin [mmaclin]
// Created.
//****************************************************************************

DWORD ImportCustomFile(LPCTSTR lpszImportFile)
{
  TCHAR   szFile[_MAX_PATH];
  TCHAR   szTemp[_MAX_PATH];

  // If a custom file name does not exist, do nothing
  //
  if (GetPrivateProfileString(cszCustomSection,
                              cszFileName,
                              cszNull,
                              szTemp,
                              _MAX_PATH,
                              lpszImportFile) == 0)
  {
    return ERROR_SUCCESS;
  };

  GetWindowsDirectory(szFile, _MAX_PATH);
  if (*CharPrev(szFile, szFile + lstrlen(szFile)) != '\\')
  {
    lstrcat(szFile, TEXT("\\"));
  }
  lstrcat(szFile, szTemp);
  
  return (ImportFile(lpszImportFile, cszCustomFileSection, szFile));

}

DWORD ImportCustomInfo(
        LPCTSTR lpszImportFile,
        LPTSTR lpszExecutable,
        DWORD cbExecutable,
        LPTSTR lpszArgument,
        DWORD cbArgument)
{
    GetPrivateProfileString(cszCustomSection,
                              cszRun,
                              cszNull,
                              lpszExecutable,
                              (int)cbExecutable,
                              lpszImportFile);

    GetPrivateProfileString(cszCustomSection,
                              cszArgument,
                              cszNull,
                              lpszArgument,
                              (int)cbArgument,
                              lpszImportFile);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\enumodem.cpp ===
/*-----------------------------------------------------------------------------
	enumodem.cpp

	Holds code that deals with the "Choose a modem" dialog needed when user has
	multiple modems installed

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		jmazner Jeremy Mazner

	History:
		10/19/96        jmazner Created, cloned almost verbatim from 
							INETCFG's rnacall.cpp and export.cpp    

-----------------------------------------------------------------------------*/


#include "isignup.h"
#include "enumodem.h"

#include <WINDOWSX.H>

//+---------------------------------------------------------------------------
//
//      Function:       ProcessDBCS
//
//      Synopsis:       Converts control to use DBCS compatible font
//                              Use this at the beginning of the dialog procedure
//      
//                              Note that this is required due to a bug in Win95-J that prevents
//                              it from properly mapping MS Shell Dlg.  This hack is not needed
//                              under winNT.
//
//      Arguments:      hwnd - Window handle of the dialog
//                              cltID - ID of the control you want changed.
//
//      Returns:        ERROR_SUCCESS
// 
//      History:        4/31/97 a-frankh        Created
//                              5/13/97 jmazner         Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
#if defined(WIN16)
	return;
#else
	HFONT hFont = NULL;

	if( IsNT() )
	{
		return;
	}

	hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
	if (hFont == NULL)
		hFont = (HFONT) GetStockObject(SYSTEM_FONT);
	if (hFont != NULL)
		SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
#endif
}


/*******************************************************************

  NAME:    CEnumModem::CEnumModem

  SYNOPSIS:  Constructor for class to enumerate modems

  NOTES:    Useful to have a class rather than C functions for
	this, due to how the enumerators function

********************************************************************/
CEnumModem::CEnumModem() :
  m_dwError(ERROR_SUCCESS),m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize = 0;

  if (!LoadRnaFunctions(NULL))
	  m_dwError = GetLastError();
  else
	  // Use the reinit member function to do the work.
	  this->ReInit();
}


/*******************************************************************

  NAME:     CEnumModem::ReInit

  SYNOPSIS: Re-enumerate the modems, freeing the old memory.

********************************************************************/
DWORD CEnumModem::ReInit()
{
  DWORD cbSize = 0;

  // Clean up the old list
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
  m_dwNumEntries = 0;
  m_dwIndex = 0;

  // call RasEnumDevices with no buffer to find out required buffer size
  m_dwError = (lpfnRasEnumDevices)(NULL, &cbSize, &m_dwNumEntries);

  // Special case check to work around RNA bug where ERROR_BUFFER_TOO_SMALL
  // is returned even if there are no devices.
  // If there are no devices, we are finished.
  if (0 == m_dwNumEntries)
  {
    m_dwError = ERROR_SUCCESS;
    return m_dwError;
  }

  // Since we were just checking how much mem we needed, we expect
  // a return value of ERROR_BUFFER_TOO_SMALL, or it may just return
  // ERROR_SUCCESS (ChrisK  7/9/96).
  if (ERROR_BUFFER_TOO_SMALL != m_dwError && ERROR_SUCCESS != m_dwError)
  {
    return m_dwError;
  }

  // Allocate the space for the data
  m_lpData = (LPRASDEVINFO) new TCHAR[cbSize];
  if (NULL == m_lpData)
  {
	  DebugOut("ICWCONN1: CEnumModem: Failed to allocate device list buffer\n");
	  m_dwError = ERROR_NOT_ENOUGH_MEMORY;
	  return m_dwError;
  }
  m_lpData->dwSize = sizeof(RASDEVINFO);
  m_dwNumEntries = 0;

  // enumerate the modems into buffer
  m_dwError = (lpfnRasEnumDevices)(m_lpData, &cbSize,
    &m_dwNumEntries);

  if (ERROR_SUCCESS != m_dwError)
	  return m_dwError;
    
    //
    // ChrisK Olympus 4560 do not include VPN's in the list
    //
    DWORD dwTempNumEntries;
    DWORD idx;
    LPRASDEVINFO lpNextValidDevice;

    dwTempNumEntries = m_dwNumEntries;
    lpNextValidDevice = m_lpData;

	//
	// Walk through the list of devices and copy non-VPN device to the first
	// available element of the array.
	//
	for (idx = 0;idx < dwTempNumEntries; idx++)
	{
		if (0 != lstrcmpi(TEXT("VPN"),m_lpData[idx].szDeviceType))
		{
			if (lpNextValidDevice != &m_lpData[idx])
			{
				MoveMemory(lpNextValidDevice ,&m_lpData[idx],sizeof(RASDEVINFO));
			}
			lpNextValidDevice++;
		}
		else
		{
			m_dwNumEntries--;
		}
	}

	return m_dwError;
}


/*******************************************************************

  NAME:    CEnumModem::~CEnumModem

  SYNOPSIS:  Destructor for class

********************************************************************/
CEnumModem::~CEnumModem()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:     CEnumModem::Next

  SYNOPSIS: Enumerates next modem 

  EXIT:     Returns a pointer to device info structure.  Returns
	    NULL if no more modems or error occurred.  Call GetError
	    to determine if error occurred.

********************************************************************/
TCHAR * CEnumModem::Next()
{
  if (m_dwIndex < m_dwNumEntries)
  {
    return m_lpData[m_dwIndex++].szDeviceName;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceTypeFromName

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device type string for first
	    device name that matches.  Returns
	    NULL if no device with specified name is found

********************************************************************/

TCHAR * CEnumModem::GetDeviceTypeFromName(LPTSTR szDeviceName)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return m_lpData[dwIndex].szDeviceType;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceNameFromType

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device name string for first
	    device type that matches.  Returns
	    NULL if no device with specified Type is found

********************************************************************/

TCHAR * CEnumModem::GetDeviceNameFromType(LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType))
    {
      return m_lpData[dwIndex].szDeviceName;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::VerifyDeviceNameAndType

  SYNOPSIS: Determines whether there is a device with the name
	    and type given.

  EXIT:     Returns TRUE if the specified device was found, 
	    FALSE otherwise.

********************************************************************/

BOOL CEnumModem::VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType) &&
      !lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return TRUE;
    }
    dwIndex++;
  }

  return FALSE;
}





/*******************************************************************

  NAME:     ChooseModemDlgProc

  SYNOPSIS: Dialog proc for choosing modem

********************************************************************/

INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
	BOOL fRet;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			// lParam contains pointer to CHOOSEMODEMDLGINFO struct, set it
			// in window data
			//Assert(lParam);
			SetWindowLongPtr(hDlg,DWLP_USER,lParam);
			fRet = ChooseModemDlgInit(hDlg,(PCHOOSEMODEMDLGINFO) lParam);
			if (!fRet)
			{
				// An error occured.
				EndDialog(hDlg,FALSE);
			}
#if !defined(WIN16)
			SetForegroundWindow(hDlg);
#endif
			return fRet;
			break;
		
		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
			case IDC_CMDOK:
				{
					// get data pointer from window data
					PCHOOSEMODEMDLGINFO pChooseModemDlgInfo =
						(PCHOOSEMODEMDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
					//Assert(pChooseModemDlgInfo);

					// pass the data to the OK handler
					fRet=ChooseModemDlgOK(hDlg,pChooseModemDlgInfo);
					if (fRet)
					{
						EndDialog(hDlg,TRUE);
					}
				}
				break;

			case IDC_CMDCANCEL:
				SetLastError(ERROR_CANCELLED);
				EndDialog(hDlg,FALSE);
				break;                  
			}
			break;
	}

	return FALSE;
}


/*******************************************************************

  NAME:    ChooseModemDlgInit

  SYNOPSIS: proc to handle initialization of dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
	//Assert(pChooseModemDlgInfo);

	// put the dialog in the center of the screen
	//RECT rc;
	//GetWindowRect(hDlg, &rc);
	//SetWindowPos(hDlg, NULL,
	//      ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
	//      ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
	//      0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

	// fill the combobox with available modems
	ProcessDBCS(hDlg,IDC_MODEM);
	DWORD dwRet = InitModemList(GetDlgItem(hDlg,IDC_MODEM));
	if (ERROR_SUCCESS != dwRet)
	{
		DebugOut("ICWCONN1: ChooseModemDlgInit: Error initializing modem list!\n");

		SetLastError(dwRet);
		return FALSE;
	}

	return TRUE;
}

/*******************************************************************

  NAME:    ChooseModemDlgOK

  SYNOPSIS:  OK handler for dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
	//Assert(pChooseModemDlgInfo);

	// should always have a selection in combo box if we get here
	//Assert(ComboBox_GetCurSel(GetDlgItem(hDlg,IDC_MODEM)) >= 0);

	// get modem name out of combo box
	ComboBox_GetText(GetDlgItem(hDlg,IDC_MODEM),
		pChooseModemDlgInfo->szModemName,
		sizeof(pChooseModemDlgInfo->szModemName));
	//Assert(lstrlen(pChooseModemDlgInfo->szModemName));
    
	// clear the modem list
	ComboBox_ResetContent(GetDlgItem(hDlg,IDC_MODEM));
	
	return TRUE;
}


/*******************************************************************

  NAME:    InitModemList

  SYNOPSIS:  Fills a combo box window with installed modems

  ENTRY:    hCB - combo box window to fill
  
********************************************************************/
HRESULT InitModemList (HWND hCB)
{
	DebugOut("ICWCONN1::enumodem.cpp  InitModemList()\n");

	LPTSTR pNext;
	int   nIndex;
	DWORD dwRet;

	//Assert(hCB);

	CEnumModem cEnumModem;

	// clear out the combo box
	ComboBox_ResetContent(hCB);

	while ( pNext = cEnumModem.Next() )
	{
		// Add the device to the combo box
		nIndex = ComboBox_AddString(hCB, pNext);
		ComboBox_SetItemData(hCB, nIndex, NULL);
	}

	// Select the default device
	ComboBox_SetCurSel(hCB, nIndex);

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\exdispid.h ===
#ifndef EXDISPID_H_
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: exdispid.h
//
//--------------------------------------------------------------------------


//
// Dispatch IDS for IExplorer Dispatch Events.
//
#define DISPID_BEFORENAVIGATE     100   // this is sent before navigation to give a chance to abort
#define DISPID_NAVIGATECOMPLETE   101   // in async, this is sent when we have enough to show
#define DISPID_STATUSTEXTCHANGE   102
#define DISPID_QUIT               103
#define DISPID_DOWNLOADCOMPLETE   104
#define DISPID_COMMANDSTATECHANGE 105
#define DISPID_DOWNLOADBEGIN      106
#define DISPID_NEWWINDOW          107   // sent when a new window should be created
#define DISPID_PROGRESSCHANGE     108   // sent when download progress is updated
#define DISPID_WINDOWMOVE         109   // sent when main window has been moved
#define DISPID_WINDOWRESIZE       110   // sent when main window has been sized
#define DISPID_WINDOWACTIVATE     111   // sent when main window has been activated
#define DISPID_PROPERTYCHANGE     112   // sent when the PutProperty method is called
#define DISPID_TITLECHANGE        113   // sent when the document title changes

#define DISPID_FRAMEBEFORENAVIGATE    200
#define DISPID_FRAMENAVIGATECOMPLETE  201
#define DISPID_FRAMENEWWINDOW         204


#define EXDISPID_H_
#endif // EXDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\extfunc.h ===
typedef DWORD (WINAPI * RASENUMCONNECTIONS)
        (LPRASCONN lpRasConn, LPDWORD lpcb, LPDWORD lpcConnections);
extern RASENUMCONNECTIONS  lpfnRasEnumConnections;

typedef DWORD (WINAPI * RASHANGUP)
        (HRASCONN hRasConn);
extern RASHANGUP  lpfnRasHangUp;

typedef DWORD (WINAPI * RASGETENTRYDIALPARAMS)
        (LPTSTR, LPRASDIALPARAMS, LPBOOL );
extern RASGETENTRYDIALPARAMS lpfnRasGetEntryDialParams;

typedef DWORD (WINAPI * RASSETENTRYDIALPARAMS)
		(LPTSTR, LPRASDIALPARAMS, BOOL);
extern RASSETENTRYDIALPARAMS lpfnRasSetEntryDialParams;

typedef DWORD (WINAPI * RASDIAL)
        (LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN );
extern RASDIAL lpfnRasDial;

typedef DWORD (WINAPI * RASGETCONECTSTATUS)
        (HRASCONN, LPRASCONNSTATUS );
extern RASGETCONECTSTATUS lpfnRasGetConnectStatus;

typedef DWORD (WINAPI * RASGETERRORSTRING)
        ( UINT, LPTSTR, DWORD );
extern RASGETERRORSTRING lpfnRasGetErrorString;

typedef DWORD (WINAPI * RASVALIDATEENTRYNAME)
        (LPTSTR lpszPhonebook, LPTSTR szEntry);
extern RASVALIDATEENTRYNAME  lpfnRasValidateEntryName;

typedef DWORD (WINAPI * RASRENAMEENTRY)
        (LPTSTR lpszPhonebook, LPTSTR szEntryOld, LPTSTR szEntryNew);
extern RASRENAMEENTRY lpfnRasRenameEntry;

typedef DWORD (WINAPI * RASDELETEENTRY)
        (LPTSTR lpszPhonebook, LPTSTR szEntry);
extern RASDELETEENTRY lpfnRasDeleteEntry;

typedef DWORD (WINAPI * RASGETENTRYPROPERTIES)
        (LPTSTR lpszPhonebook, LPTSTR szEntry, LPBYTE lpbEntry,
        LPDWORD lpdwEntrySize, LPBYTE lpb, LPDWORD lpdwSize);
extern RASGETENTRYPROPERTIES lpfnRasGetEntryProperties;

typedef DWORD (WINAPI * RASSETENTRYPROPERTIES)
        (LPTSTR lpszPhonebook, LPTSTR szEntry, LPBYTE lpbEntry,
        DWORD dwEntrySize, LPBYTE lpb, DWORD dwSize);
extern RASSETENTRYPROPERTIES lpfnRasSetEntryProperties;

typedef DWORD (WINAPI * RASGETCOUNTRYINFO)
        (LPRASCTRYINFO lpCtryInfo, LPDWORD lpdwSize);
extern RASGETCOUNTRYINFO lpfnRasGetCountryInfo;

typedef DWORD (WINAPI * RASENUMDEVICES)
    (LPRASDEVINFO lpBuff, LPDWORD lpcbSize, LPDWORD lpcDevices);
extern RASENUMDEVICES lpfnRasEnumDevices;

#if !defined(WIN16)
typedef DWORD (WINAPI * RASSETAUTODIALENABLE)
    (DWORD dwDialingLocation, BOOL fEnabled);
extern RASSETAUTODIALENABLE lpfnRasSetAutodialEnable;

typedef DWORD (WINAPI * RASSETAUTODIALADDRESS)
	(LPTSTR lpszAddress,DWORD dwReserved,LPRASAUTODIALENTRY lpAutoDialEntries,
	DWORD dwcbAutoDialEntries,DWORD dwcAutoDialEntries);
extern RASSETAUTODIALADDRESS lpfnRasSetAutodialAddress;
#endif

typedef DWORD (WINAPI *INETCONFIGSYSTEM)
    (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart);
extern INETCONFIGSYSTEM lpfnInetConfigSystem;

typedef DWORD (WINAPI *INETCONFIGCLIENT)
    (HWND hwndParent, LPCTSTR lpszPhoneBook,
    LPCTSTR lpszEntryName, LPRASENTRY lpRasEntry,
    LPCTSTR lpszUserName, LPCTSTR lpszPassword,
    LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo,
    DWORD dwfOptions, LPBOOL lpfNeedsRestart);
extern INETCONFIGCLIENT lpfnInetConfigClient;

typedef DWORD (WINAPI *INETGETAUTODIAL)
    (LPBOOL lpfEnable, LPCTSTR lpszEntryName, DWORD cbEntryNameSize);
extern INETGETAUTODIAL lpfnInetGetAutodial;

typedef DWORD (WINAPI *INETSETAUTODIAL)
    (BOOL fEnable, LPCTSTR lpszEntryName);
extern INETSETAUTODIAL lpfnInetSetAutodial;

typedef DWORD (WINAPI *INETGETCLIENTINFO)
    (LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo);
extern INETGETCLIENTINFO lpfnInetGetClientInfo;

typedef DWORD (WINAPI *INETSETCLIENTINFO)
    (LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo);
extern INETSETCLIENTINFO lpfnInetSetClientInfo;

typedef DWORD (WINAPI *INETGETPROXY)
    (LPBOOL lpfEnable, LPCTSTR lpszServer, DWORD cbServer,
    LPCTSTR lpszOverride, DWORD cbOverride);
extern INETGETPROXY lpfnInetGetProxy;

typedef DWORD (WINAPI *INETSETPROXY)
    (BOOL fEnable, LPCTSTR lpszServer, LPCTSTR lpszOverride);
extern INETSETPROXY lpfnInetSetProxy;

typedef BOOL (WINAPI *BRANDME)
  (LPCTSTR pszIns, LPCTSTR pszPath);
extern BRANDME  lpfnBrandMe;

typedef BOOL (WINAPI *BRANDICW)
  (LPCSTR pszIns, LPCSTR pszPath, DWORD dwFlags, LPCSTR pszConnectoid);
extern BRANDICW  lpfnBrandICW;

extern BOOL LoadRnaFunctions(HWND hwndParent);
extern BOOL LoadInetFunctions(HWND hwndParent);
extern BOOL LoadBrandingFunctions(void);
extern void UnloadRnaFunctions(void);
extern void UnloadInetFunctions(void);
extern void UnloadBrandingFunctions(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\icw.cpp ===
#include "isignup.h"
#include "icw.h"
#include "appdefs.h"

BOOL UseICWForIEAK(TCHAR* szIEAKFileName)
{
    TCHAR szUseICW[2] = TEXT("\0");
    //If we can't find this section it the isp file we'll assume "no".
    GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_USEICW, TEXT("0"), szUseICW, 2, szIEAKFileName);
    return (BOOL)_ttoi(szUseICW);
}

void LocateICWFromReigistry(TCHAR* pszICWLocation, size_t size)
{
    HKEY hKey = NULL;

    TCHAR    szICWPath[MAX_PATH];
    DWORD   dwcbPath = sizeof(szICWPath); 

    //Look fo the ICW in the app paths 
    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE, ICW50_PATHKEY, 0, KEY_QUERY_VALUE, &hKey)) == ERROR_SUCCESS)
    {
        //get the default for the key
        RegQueryValueEx(hKey, NULL , NULL, NULL, (BYTE *)szICWPath, (DWORD *)&dwcbPath);
    }        
    if (hKey) 
        RegCloseKey(hKey);

    // No assert macro?
    //Assert(szICWPath);
    //Assert(size >= MAX_PATH);
    if (size >= MAX_PATH)
        lstrcpy(pszICWLocation, szICWPath);
}

void RunICWinIEAKMode(TCHAR* pszIEAKFileName)
{
    //this must be big enough to hold the path to the icw as well as
    //the ieak file
    TCHAR szCmdLine[MAX_PATH * 4 + 8];
    TCHAR szICWPath[MAX_PATH + 1] = TEXT("");
   
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    MSG                 msg;
    DWORD               iWaitResult = 0;
    BOOL                bRetVal     = FALSE;

    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    
    //Get the path to the icw
    LocateICWFromReigistry(szICWPath, sizeof(szICWPath));

    if (szICWPath[0] != TEXT('\0'))
    {
        if ((szICWPath[0] != TEXT('\"')) ||
            (szICWPath[lstrlen(szICWPath) - 1] != TEXT('\"')))
        {
            //use quotes in case there are spaces
            lstrcpy(szCmdLine, TEXT("\""));
            lstrcat(szCmdLine, szICWPath);
            lstrcat(szCmdLine, TEXT("\" "));
        }
        else
        {
            lstrcpy(szCmdLine, szICWPath);
            lstrcat(szCmdLine, TEXT(" "));
        }
        
        //set the IEAK switch, pass in the path to the file
        //used to invoke isign32
        lstrcat(szCmdLine, ICW_IEAK_CMD);
        lstrcat(szCmdLine, TEXT(" \""));
        lstrcat(szCmdLine, pszIEAKFileName);
        lstrcat(szCmdLine, TEXT("\""));
       
        if(CreateProcess(NULL, 
                         szCmdLine, 
                         NULL, 
                         NULL, 
                         TRUE, 
                         0, 
                         NULL, 
                         NULL, 
                         &si, 
                         &pi))
        {
            // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
            while((iWaitResult=MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
            {
                // read all of the messages in this next loop
                // removing each message as we read it
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    // how to handle quit message?
                    if (msg.message == WM_QUIT)
                    {
                        CloseHandle(pi.hThread);
                        CloseHandle(pi.hProcess);
                    }
                    else
                        DispatchMessage(&msg);
                }
            }
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\icw.h ===
#ifndef __ICW_H
#define __ICW_H

BOOL UseICWForIEAK(TCHAR* szIEAKFileName);
void RunICWinIEAKMode(TCHAR* szIEAKFileName);

#endif //__ICW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\impfile.cpp ===
//****************************************************************************
// DWORD NEAR PASCAL ImportFile(LPCSTR szImportFile)
//
// This function imports a file from the given section
//
// History:
//  Mon 21-Mar-1996 12:40:00  -by-  Mark MacLin [mmaclin]
// Created.
//****************************************************************************

#include "isignup.h"

#define MAXLONGLEN      80

#define SIZE_ReadBuf    0x00008000    // 32K buffer size

#pragma data_seg(".rdata")

static TCHAR szNull[] = TEXT("");

#pragma data_seg()

//int atoi (LPCSTR szBuf)
//{
//  int   iRet = 0;
//
//  while ((*szBuf >= '0') && (*szBuf <= '9'))
//  {
//    iRet = (iRet*10)+(int)(*szBuf-'0');
//    szBuf++;
//  };
//  return iRet;
//}


DWORD ImportFile(LPCTSTR lpszImportFile, LPCTSTR lpszSection, LPCTSTR lpszOutputFile)
{
  HFILE hFile;
  LPTSTR  pszLine, pszFile;
  int    i, iMaxLine;
  UINT   cbSize, cbRet;
  DWORD  dwRet = ERROR_SUCCESS;

  // Allocate a buffer for the file
  //
  if ((pszFile = (LPTSTR)LocalAlloc(LMEM_FIXED, SIZE_ReadBuf))
       == NULL)
  {
    return ERROR_OUTOFMEMORY;
  }

  // Look for script
  //
  if (GetPrivateProfileString(lpszSection,
                              NULL,
                              szNull,
                              pszFile,
                              SIZE_ReadBuf,
                              lpszImportFile) != 0)
  {
    // Get the maximum line number
    //
    pszLine = pszFile;
    iMaxLine = -1;
    while (*pszLine)
    {
      i = _ttoi(pszLine);
      iMaxLine = max(iMaxLine, i);
      pszLine += lstrlen(pszLine)+1;
    };

    // If we have at least one line, we will import the script file
    //
    if (iMaxLine >= 0)
    {
      // Create the script file
      //
#ifdef UNICODE
      CHAR szTmp[MAX_PATH+1];
      wcstombs(szTmp, lpszOutputFile, MAX_PATH+1);
      hFile = _lcreat(szTmp, 0);
#else
      hFile = _lcreat(lpszOutputFile, 0);
#endif

      if (hFile != HFILE_ERROR)
      {
        TCHAR   szLineNum[MAXLONGLEN+1];

        // From The first line to the last line
        //
        for (i = 0; i <= iMaxLine; i++)
        {
          // Read the script line
          //
          wsprintf(szLineNum, TEXT("%d"), i);
          if ((cbSize = GetPrivateProfileString(lpszSection,
                                                szLineNum,
                                                szNull,
                                                pszLine,
                                                SIZE_ReadBuf,
                                                lpszImportFile)) != 0)
          {
            // Write to the script file
            //
            lstrcat(pszLine, TEXT("\x0d\x0a"));
#ifdef UNICODE
            wcstombs(szTmp, pszLine, MAX_PATH+1);
            cbRet=_lwrite(hFile, szTmp, cbSize+2);
#else
            cbRet=_lwrite(hFile, pszLine, cbSize+2);
#endif
          };
        };

        _lclose(hFile);
      }
      else
      {
        dwRet = ERROR_PATH_NOT_FOUND;
      };
    }
    else
    {
      dwRet = ERROR_PATH_NOT_FOUND;
    };
  }
  else
  {
    dwRet = ERROR_PATH_NOT_FOUND;
  };
  LocalFree(pszFile);

  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\iedde.cpp ===
/*----------------------------------------------------------------------------
	iedde.cpp

	Sends URL open command to IE using DDE

	Copyright (C) 1995-96 Microsoft Corporation
	All right reserved

  Authors:
	VetriV		Vellore T. Vetrivelkumaran
	jmazner		Jeremy Mazner

  History:
	8/29/96   jmazner  created, with minor changes for 32 bit world, from
	                   VetriV's ie16dde.cpp
----------------------------------------------------------------------------*/
#include "isignup.h"

#if defined(WIN16)
  #include <windows.h>
#endif

#include <ddeml.h>
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

static FARPROC lpfnDDEProc;
static HCONV hConv = (HCONV) NULL;
static HSZ hszMosaicService = (HSZ) NULL;
static HSZ hszTopic = (HSZ) NULL;
static HSZ hszItem = (HSZ) NULL;
static DWORD g_dwInstance = 0;




//+---------------------------------------------------------------------------
//
//  Function:   Dprintf
//
//  Synopsis:   Prints the values contained in the variable number of 
//				arguments in the specified format 
//
//  Arguments:  [pcsz - Format string]
//
//	Returns:	Nothing
//
//  History:    8/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void Dprintf(LPCSTR pcsz, ...)
{
#ifdef DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

	wvsprintf(szBuf, pcsz, argp);

	OutputDebugString(szBuf);
	va_end(argp);
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   DdeCallback
//
//  Synopsis:   Callback function used in DDEIntialize
//
//  Arguments:  [Please see DdeInitialize documentation]
//
//	Returns:	Nothing
//
//  History:    8/9/96     VetriV    Created
//              8/29/96    jmazner   minor change in signature for 32 bit world
//
//----------------------------------------------------------------------------
#if defined(WIN16)
extern "C" 
HDDEDATA CALLBACK _export DdeCallBack(UINT uType,    // transaction type
#else
HDDEDATA CALLBACK DdeCallBack(UINT uType,    // transaction type
#endif

										UINT uFmt,   // clipboard data format
										HCONV hconv, // handle of the conversation
										HSZ hsz1,    // handle of a string	
										HSZ hsz2,    // handle of a string
										HDDEDATA hdata, // handle of a global memory object	
										DWORD dwData1,  // transaction-specific data
										DWORD dwData2)  // transaction-specific data
{
	return 0;
}






//+---------------------------------------------------------------------------
//
//  Function:   OpenURL
//
//  Synopsis:   Opens the given URL use DDE.
//				Warning: This function uses global static variables and hence
//						 it is not re-entrant.
//
//  Arguments:  [lpsszURL - URL to be opened]
//
//	Returns:	Nothing
//
//  History:    8/9/96     VetriV    Created
//				9/3/96	   jmazner	 Minor tweaks; moved string handle code in from DdeInit
//
//----------------------------------------------------------------------------
int OpenURL(LPCTSTR lpcszURL)
{
	TCHAR szOpenURL[] = TEXT("WWW_OpenURL");
	TCHAR szRemainingParams[] = TEXT("\"\",-1,0,\"\",\"\",\"\"");
	TCHAR szArg[1024];
	HDDEDATA trans_ret;
	long long_result;

	
	if ((NULL == lpcszURL) || ('\0' == lpcszURL[0]))
		goto ErrorOpenURL;
                   
	//
	// Create String handle for the Operation WWW_OpenURL
	//
	if (hszTopic)
		DdeFreeStringHandle(g_dwInstance, hszTopic);
	hszTopic = DdeCreateStringHandle(g_dwInstance, szOpenURL, CP_WINANSI);
	
	if (!hszTopic)
	{
		Dprintf("DdeCreateStringHandle for %s failed with %u\r\n", 
					szOpenURL, DdeGetLastError(g_dwInstance));
		goto ErrorOpenURL;
	}

	
	//
	// Compose the argument string
	//
	if (lstrlen(lpcszURL) + lstrlen(szRemainingParams) > 1020)
		goto ErrorOpenURL;
	memset(szArg, 0, sizeof(szArg));
	wsprintf(szArg, TEXT("\"%s\",%s"), lpcszURL, szRemainingParams);

	
	//
	// Create String Handle for the Arguments
	//
	if (hszItem)
		DdeFreeStringHandle(g_dwInstance, hszItem);
	hszItem = DdeCreateStringHandle(g_dwInstance, szArg, CP_WINANSI);
						
	if (!hszItem)
	{
		Dprintf("DdeCreateStringHandle for %s failed with %u\r\n", 
					szArg, DdeGetLastError(g_dwInstance));
		goto ErrorOpenURL;
	}

	//
	// Connect to DDE Server
	//
	hConv = DdeConnect(g_dwInstance, hszMosaicService, hszTopic, NULL);
	if (!hConv)
	{
		Dprintf("DdeConnect failed with %u\r\n", 
					DdeGetLastError(g_dwInstance));
		goto ErrorOpenURL;
	}
	
	//
	// Request
	//
	trans_ret = DdeClientTransaction(NULL, 0, hConv, hszItem, CF_TEXT, 
										XTYP_REQUEST, 60000, NULL);
	
	
	//
	// long integer return value
	//
	if (trans_ret != DDE_FNOTPROCESSED)
	{
		DdeGetData(trans_ret, (LPBYTE) &long_result, sizeof(long_result), 0);
		DdeFreeDataHandle(trans_ret);
		return 0;					// Successfully started opening the URL
	}
	else
	{
		Dprintf("DdeClientTransaction failed with %u\r\n", 
					DdeGetLastError(g_dwInstance));
		goto ErrorOpenURL;
	}



ErrorOpenURL:
	if (hConv)
	{
		DdeDisconnect(hConv);
		hConv = (HCONV) NULL;
	}
	if (hszTopic)
	{
		DdeFreeStringHandle(g_dwInstance, hszTopic);
		hszTopic = NULL;
	}
	if (hszItem)
	{
		DdeFreeStringHandle(g_dwInstance, hszItem);
		hszItem = NULL;
	}

	return -1;
}



//+---------------------------------------------------------------------------
//
//  Function:   DDEClose
//
//  Synopsis:   Shutsdown DDE and releases string handles
//				Warning: This function uses global static variables and hence
//						 it is not re-entrant.
//
//  Arguments:  None
//
//	Returns:	Nothing
//
//  History:    8/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void DDEClose(void)
{
	Dprintf("DDEClose called\r\n");
	
	if (0 != g_dwInstance)
	{
		if (hConv)
		{
			DdeDisconnect(hConv);
			hConv = (HCONV) NULL;
		}
		
		if (hszTopic)
		{
			DdeFreeStringHandle(g_dwInstance, hszTopic);
			hszTopic = NULL;
		}
		if (hszItem)
		{
			DdeFreeStringHandle(g_dwInstance, hszItem);
			hszItem = NULL;
		}
		if (hszMosaicService)
		{
			DdeFreeStringHandle(g_dwInstance, hszMosaicService);
			hszMosaicService = NULL;
		}

		DdeUninitialize(g_dwInstance);
		g_dwInstance = 0;
	}

	return;
}





//+---------------------------------------------------------------------------
//
//  Function:   DDEinit
//
//  Synopsis:   Intializes DDE, creates string handles for service 
//				and registers the names.
//				Warning: This function uses global static variables and hence
//						 it is not re-entrant.
//
//  Arguments:  [hInst - Instance handle]
//
//	Returns:	0 if successful
//				Negative values, otherwise
//
//  History:    8/9/96     VetriV    Created
//              8/29/96    jmazner	 Removed calls to make us a DDE server,
//									 moved string handle code to openUrl
//
//----------------------------------------------------------------------------
int DDEInit(HINSTANCE hInst)
{
	UINT uiRetValue;

	Dprintf("DDEInit called with %u\r\n", hInst);

	if (g_dwInstance == 0)
	{
		lpfnDDEProc = MakeProcInstance((FARPROC) DdeCallBack, hInst);
		if (NULL == lpfnDDEProc)
		{
			Dprintf("MakeProcInstance failed");
			return -1;
		}

		uiRetValue = DdeInitialize(&g_dwInstance, (PFNCALLBACK) lpfnDDEProc, 
										APPCLASS_STANDARD, 0);
		if (DMLERR_NO_ERROR != uiRetValue)
		{
			Dprintf("DdeInitialize failed with %u\r\n", uiRetValue);
			g_dwInstance = 0;
			return -2;
		}
	}
	

	
	hszMosaicService = DdeCreateStringHandle(g_dwInstance, TEXT("IEXPLORE"), CP_WINANSI);
	if (NULL == hszMosaicService)
	{
		Dprintf("DdeCreateStringHandle for IEXPLORE failed with %u\r\n", 
					DdeGetLastError(g_dwInstance));
	}



	return( TRUE );
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\icwerr.cpp ===
/*-----------------------------------------------------------------------------
	icwerr.cpp

	Maps RAS and downloading errors to string resource indices

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "isignup.h"
#include "..\inc\icwerr.h"

#define RAS_BOGUS_AUTHFAILCODE_1	84
#define RAS_BOGUS_AUTHFAILCODE_2	74389484

// ############################################################################
WORD RasErrorToIDS(DWORD dwErr)
{
	if(dwErr==RAS_BOGUS_AUTHFAILCODE_1 || dwErr==RAS_BOGUS_AUTHFAILCODE_2)
	{
		return IDS_PPPRANDOMFAILURE;
	}

	if((dwErr>=653 && dwErr<=663) || (dwErr==667) || (dwErr>=669 && dwErr<=675))
	{
		OutputDebugString(TEXT("Got random RAS MEDIA error!\r\n"));
		return IDS_MEDIAINIERROR;
	}
	
	switch(dwErr)
	{
	default:
		return IDS_PPPRANDOMFAILURE;

	case SUCCESS:
		return 0;
		
	case ERROR_LINE_BUSY:
		return IDS_PHONEBUSY;

	case ERROR_NO_ANSWER:
		return IDS_NOANSWER;
		
	case ERROR_VOICE_ANSWER:
	case ERROR_NO_CARRIER:
		return IDS_RASNOCARRIER;
		
	case ERROR_NO_DIALTONE:
		return IDS_NODIALTONE;

	case ERROR_HARDWARE_FAILURE:	// modem turned off
	case ERROR_PORT_ALREADY_OPEN:	// procomm/hypertrm/RAS has COM port
	case ERROR_PORT_OR_DEVICE:	// got this when hypertrm had the device open -- jmazner

		return IDS_NODEVICE;

	case ERROR_USER_DISCONNECTION:
		return IDS_USERCANCELEDDIAL;

	case ERROR_BUFFER_INVALID:				// bad/empty rasdilap struct
	case ERROR_BUFFER_TOO_SMALL:			// ditto?
	case ERROR_CANNOT_FIND_PHONEBOOK_ENTRY:	// if connectoid name in registry is wrong
		return IDS_TCPINSTALLERROR;

    case ERROR_AUTHENTICATION_FAILURE:		// get this on actual CHAP reject
		return IDS_PPPRANDOMFAILURE;

	case ERROR_PPP_TIMEOUT:		// get this on CHAP timeout
		return IDS_PPPRANDOMFAILURE;

	case ERROR_REMOTE_DISCONNECTION:		// Ascend drops connection on auth-fail
		return IDS_PPPRANDOMFAILURE;

	case ERROR_AUTH_INTERNAL:				// got this on random POP failure
	case ERROR_PROTOCOL_NOT_CONFIGURED:		// get this if LCP fails
	case ERROR_PPP_NO_PROTOCOLS_CONFIGURED:	// get this if IPCP addr download gives garbage
		return IDS_PPPRANDOMFAILURE;

	case ERROR_USERCANCEL:
		return IDS_USERCANCELEDDIAL;

/******
    case ERROR_CHANGING_PASSWORD:
    case ERROR_PASSWD_EXPIRED:
        ev = EVENT_INVALIDPASSWORD; break;

    case ERROR_ACCT_DISABLED:
    case ERROR_ACCT_EXPIRED:
		ev = EVENT_LOCKEDACCOUNT; break;

    case ERROR_NO_DIALIN_PERMISSION:
    case ERROR_RESTRICTED_LOGON_HOURS:
    case ERROR_AUTHENTICATION_FAILURE:
		ev = EVENT_RAS_AUTH_FAILED; break;

	case ERROR_ALREADY_DISCONNECTING:
	case ERROR_DISCONNECTION:
		ev = EVENT_CONNECTION_DROPPED; break;

	case PENDING: 
	case ERROR_INVALID_PORT_HANDLE:
	case ERROR_CANNOT_SET_PORT_INFO:
	case ERROR_PORT_NOT_CONNECTED:
	case ERROR_DEVICE_DOES_NOT_EXIST:
	case ERROR_DEVICETYPE_DOES_NOT_EXIST:
	case ERROR_PORT_NOT_FOUND:
	case ERROR_DEVICENAME_TOO_LONG:
	case ERROR_DEVICENAME_NOT_FOUND:
	 	ev=EVENT_BAD_MODEM_CONFIG; break;

	case ERROR_TAPI_CONFIGURATION:
		ev=EVENT_BAD_TAPI_CONFIG; break;
	
		ev=EVENT_MODEM_BUSY; break;
	
	case ERROR_BUFFER_TOO_SMALL:
	case ERROR_WRONG_INFO_SPECIFIED:
	case ERROR_EVENT_INVALID:
	case ERROR_BUFFER_INVALID:
	case ERROR_ASYNC_REQUEST_PENDING:
	case ERROR_CANNOT_OPEN_PHONEBOOK:
	case ERROR_CANNOT_LOAD_PHONEBOOK:
	case ERROR_CANNOT_WRITE_PHONEBOOK:
	case ERROR_CORRUPT_PHONEBOOK:
	case ERROR_CANNOT_LOAD_STRING:
	case ERROR_OUT_OF_BUFFERS:
	case ERROR_MACRO_NOT_FOUND:
	case ERROR_MACRO_NOT_DEFINED:
	case ERROR_MESSAGE_MACRO_NOT_FOUND:
	case ERROR_DEFAULTOFF_MACRO_NOT_FOUND:
	case ERROR_FILE_COULD_NOT_BE_OPENED:
	case ERROR_PORT_NOT_OPEN:
	case ERROR_PORT_DISCONNECTED:
	case ERROR_NO_ENDPOINTS:
	case ERROR_KEY_NOT_FOUND:
	case ERROR_INVALID_SIZE:
	case ERROR_PORT_NOT_AVAILABLE:
	case ERROR_UNKNOWN:
	case ERROR_WRONG_DEVICE_ATTACHED:
	case ERROR_BAD_STRING:
	case ERROR_BAD_USAGE_IN_INI_FILE:
	case ERROR_READING_SECTIONNAME:
	case ERROR_READING_DEVICETYPE:
	case ERROR_READING_DEVICENAME:
	case ERROR_READING_USAGE:
	case ERROR_READING_MAXCONNECTBPS:
	case ERROR_READING_MAXCARRIERBPS:
	case ERROR_IN_COMMAND:
	case ERROR_WRITING_SECTIONNAME:
	case ERROR_WRITING_DEVICETYPE:
	case ERROR_WRITING_DEVICENAME:
	case ERROR_WRITING_MAXCONNECTBPS:
	case ERROR_WRITING_MAXCARRIERBPS:
	case ERROR_WRITING_USAGE:
	case ERROR_WRITING_DEFAULTOFF:
	case ERROR_READING_DEFAULTOFF:
	case ERROR_EMPTY_INI_FILE:
	case ERROR_FROM_DEVICE:
	case ERROR_UNRECOGNIZED_RESPONSE:
	case ERROR_NO_RESPONSES:
	case ERROR_NO_COMMAND_FOUND:
	case ERROR_WRONG_KEY_SPECIFIED:
	case ERROR_UNKNOWN_DEVICE_TYPE:
	case ERROR_ALLOCATING_MEMORY:
	case ERROR_PORT_NOT_CONFIGURED:
	case ERROR_DEVICE_NOT_READY:
	case ERROR_READING_INI_FILE:
	case ERROR_NO_CONNECTION:
	case ERROR_PORT_OR_DEVICE:
	case ERROR_NOT_BINARY_MACRO:
	case ERROR_DCB_NOT_FOUND:
	case ERROR_STATE_MACHINES_NOT_STARTED:
	case ERROR_STATE_MACHINES_ALREADY_STARTED:
	case ERROR_PARTIAL_RESPONSE_LOOPING:
	case ERROR_UNKNOWN_RESPONSE_KEY:
	case ERROR_RECV_BUF_FULL:
	case ERROR_CMD_TOO_LONG:
	case ERROR_UNSUPPORTED_BPS:
	case ERROR_UNEXPECTED_RESPONSE:
	case ERROR_INTERACTIVE_MODE:
	case ERROR_BAD_CALLBACK_NUMBER:
	case ERROR_INVALID_AUTH_STATE:
	case ERROR_WRITING_INITBPS:
	case ERROR_X25_DIAGNOSTIC:
	case ERROR_OVERRUN:
	case ERROR_RASMAN_CANNOT_INITIALIZE:
	case ERROR_BIPLEX_PORT_NOT_AVAILABLE:
	case ERROR_NO_ACTIVE_ISDN_LINES:
	case ERROR_NO_ISDN_CHANNELS_AVAILABLE:
	case ERROR_TOO_MANY_LINE_ERRORS:
		ev=EVENT_INTERNAL_ERROR; break;
	
	case ERROR_ROUTE_NOT_AVAILABLE:
	case ERROR_ROUTE_NOT_ALLOCATED:
	case ERROR_INVALID_COMPRESSION_SPECIFIED:
	case ERROR_CANNOT_PROJECT_CLIENT:
	case ERROR_CANNOT_GET_LANA:
	case ERROR_NETBIOS_ERROR:
	case ERROR_NAME_EXISTS_ON_NET:
		ev=EVENT_BAD_NET_CONFIG; break;
	
	case ERROR_REQUEST_TIMEOUT:
	case ERROR_SERVER_OUT_OF_RESOURCES:
	case ERROR_SERVER_GENERAL_NET_FAILURE:
	case WARNING_MSG_ALIAS_NOT_ADDED:
	case ERROR_SERVER_NOT_RESPONDING:
		ev=EVENT_GENERAL_NET_ERROR; break;
		
	case ERROR_IP_CONFIGURATION:
	case ERROR_NO_IP_ADDRESSES:
	case ERROR_PPP_REMOTE_TERMINATED:
	case ERROR_PPP_NO_RESPONSE:
	case ERROR_PPP_INVALID_PACKET:
	case ERROR_PHONE_NUMBER_TOO_LONG:
	case ERROR_IPXCP_NO_DIALOUT_CONFIGURED:
	case ERROR_IPXCP_NO_DIALIN_CONFIGURED:
	case ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE:
	case ERROR_ACCESSING_TCPCFGDLL:
	case ERROR_NO_IP_RAS_ADAPTER:
	case ERROR_SLIP_REQUIRES_IP:
	case ERROR_PROJECTION_NOT_COMPLETE:
	case ERROR_PPP_NOT_CONVERGING:
	case ERROR_PPP_CP_REJECTED:
	case ERROR_PPP_LCP_TERMINATED:
	case ERROR_PPP_REQUIRED_ADDRESS_REJECTED:
	case ERROR_PPP_NCP_TERMINATED:
	case ERROR_PPP_LOOPBACK_DETECTED:
	case ERROR_PPP_NO_ADDRESS_ASSIGNED:
	case ERROR_CANNOT_USE_LOGON_CREDENTIALS:
	case ERROR_NO_LOCAL_ENCRYPTION:
	case ERROR_NO_REMOTE_ENCRYPTION:
	case ERROR_REMOTE_REQUIRES_ENCRYPTION:
	case ERROR_IPXCP_NET_NUMBER_CONFLICT:
		ev = EVENT_PPP_FAILURE; break;
***********/
	}
	return (0xFFFF);
}


// ############################################################################
	
HRESULT LoadDialErrorString(HRESULT hrIN, LPTSTR lpszBuff, DWORD dwBufferSize)
{
	if (lpszBuff && dwBufferSize)
	{
		WORD wSID = 0;
		wSID = RasErrorToIDS(hrIN);
		if (0xFFFF != wSID)
		{
			if (0 != LoadString(ghInstance,wSID,lpszBuff,(int)dwBufferSize))
				return ERROR_SUCCESS;
		}
	}
	return ERROR_INVALID_PARAMETER;
}

HRESULT WINAPI StatusMessageCallback(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize)
{
	WORD iIDS = 0;

	switch(dwStatus)
	{
		case RASCS_OpenPort:
			iIDS = IDS_RAS_OPENPORT;
			break;
		case RASCS_PortOpened:
			iIDS = IDS_RAS_PORTOPENED;
			break;
		case RASCS_ConnectDevice:
			iIDS = IDS_RAS_DIALING;
			break;
		case RASCS_DeviceConnected:
			iIDS = IDS_RAS_CONNECTED;
			break;
#if (WINVER >= 0x400) 
		case RASCS_StartAuthentication:
		case RASCS_LogonNetwork:
			iIDS = IDS_RAS_LOCATING;
			break;
//		case RASCS_CallbackComplete:
//			iIDS = IDS_RAS_CONNECTED;
//			break;
#endif 

/* ETC...
				RASCS_AllDevicesConnected, 
				RASCS_Authenticate, 
				RASCS_AuthNotify, 
				RASCS_AuthRetry, 
				RASCS_AuthCallback, 
				RASCS_AuthChangePassword, 
				RASCS_AuthProject, 
				RASCS_AuthLinkSpeed, 
				RASCS_AuthAck, 
				RASCS_ReAuthenticate, 
				RASCS_Authenticated, 
				RASCS_PrepareForCallback, 
				RASCS_WaitForModemReset, 
				RASCS_WaitForCallback,
				RASCS_Projected, 
 
 
				RASCS_Interactive = RASCS_PAUSED, 
				RASCS_RetryAuthentication, 
				RASCS_CallbackSetByCaller, 
				RASCS_PasswordExpired, 
 */
		case RASCS_Connected:
			break;

		case RASCS_Disconnected:
			break;
	}
	if (iIDS && 0 != LoadString(ghInstance,iIDS,pszBuffer,(int)dwBufferSize))
		return ERROR_SUCCESS;
	else
		return ERROR_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\extfunc.cpp ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       extfunc.c
//  Content:    This file contains all the functions that handle 
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "isignup.h"


static const TCHAR cszRnaPhDLL[] = TEXT("RNAPH.DLL");
#ifdef WIN32
static const TCHAR cszRasDLL[] = TEXT("RASAPI32.DLL");
static const TCHAR cszBrandingDLL[] = TEXT("IEDKCS32.DLL");
#else
static const CHAR cszRasDLL[] = "RASC16IE.DLL";
static const CHAR cszBrandingDLL[] = "IEDKCS16.DLL";
#endif

RASENUMCONNECTIONS    lpfnRasEnumConnections    = NULL;
RASHANGUP             lpfnRasHangUp             = NULL;
RASDELETEENTRY        lpfnRasDeleteEntry        = NULL;
RASGETENTRYDIALPARAMS lpfnRasGetEntryDialParams = NULL;
RASDIAL               lpfnRasDial               = NULL;
RASGETCONECTSTATUS    lpfnRasGetConnectStatus   = NULL;
RASGETERRORSTRING     lpfnRasGetErrorString     = NULL;
RASGETENTRYPROPERTIES lpfnRasGetEntryProperties = NULL;
RASENUMDEVICES        lpfnRasEnumDevices        = NULL;
RASSETENTRYPROPERTIES lpfnRasSetEntryProperties = NULL;
RASSETENTRYDIALPARAMS lpfnRasSetEntryDialParams = NULL;

#ifdef WIN32
// these two should only be used on NT, and _not_ on Win95
RASSETAUTODIALENABLE  lpfnRasSetAutodialEnable	= NULL;
RASSETAUTODIALADDRESS lpfnRasSetAutodialAddress	= NULL;
#endif

#ifdef UNUSED
RASVALIDATEENTRYNAME  lpfnRasValidateEntryName  = NULL;
RASRENAMEENTRY        lpfnRasRenameEntry        = NULL;
RASGETCOUNTRYINFO     lpfnRasGetCountryInfo     = NULL;
#endif

#ifdef WIN32
INETCONFIGSYSTEM  lpfnInetConfigSystem  = NULL;
INETGETPROXY      lpfnInetGetProxy      = NULL;
#endif
INETCONFIGCLIENT  lpfnInetConfigClient  = NULL;
INETGETAUTODIAL   lpfnInetGetAutodial   = NULL;
INETSETAUTODIAL   lpfnInetSetAutodial   = NULL;
INETSETCLIENTINFO lpfnInetSetClientInfo = NULL;
INETSETPROXY      lpfnInetSetProxy      = NULL;
#ifdef UNUSED
INETGETCLIENTINFO lpfnInetGetClientInfo = NULL;
#endif

#ifdef WIN32
BRANDICW  lpfnBrandICW  = NULL;
#else
BRANDME  lpfnBrandMe  = NULL;
#endif

typedef struct tagApiFcn {
    LPVOID FAR* lplpfn;
    LPCSTR   szApiName;
} APIFCN;


#ifdef UNICODE
APIFCN RasProcList[] = {
    { (LPVOID *) &lpfnRasEnumConnections,   "RasEnumConnectionsW"},
    { (LPVOID *) &lpfnRasHangUp,            "RasHangUpW"},
    { (LPVOID *) &lpfnRasGetEntryDialParams,"RasGetEntryDialParamsW"},
    { (LPVOID *) &lpfnRasDial,              "RasDialW"},
    { (LPVOID *) &lpfnRasGetConnectStatus,  "RasGetConnectStatusW"},
    { (LPVOID *) &lpfnRasGetErrorString,    "RasGetErrorStringW"},
    { (LPVOID *) &lpfnRasSetEntryDialParams,"RasSetEntryDialParamsW"},
};
#else  // UNICODE
APIFCN RasProcList[] = {
    { (LPVOID *) &lpfnRasEnumConnections,   "RasEnumConnectionsA"},
    { (LPVOID *) &lpfnRasHangUp,            "RasHangUpA"},
    { (LPVOID *) &lpfnRasGetEntryDialParams,"RasGetEntryDialParamsA"},
    { (LPVOID *) &lpfnRasDial,              "RasDialA"},
    { (LPVOID *) &lpfnRasGetConnectStatus,  "RasGetConnectStatusA"},
    { (LPVOID *) &lpfnRasGetErrorString,    "RasGetErrorStringA"},
    { (LPVOID *) &lpfnRasSetEntryDialParams,"RasSetEntryDialParamsA"},
};
#endif // UNICODE

#define cRasProc (sizeof(RasProcList) / sizeof(RasProcList[0]))

#ifdef WIN32
#ifdef UNICODE
APIFCN RasProcListNT[] = {
    { (LPVOID *) &lpfnRasEnumConnections,   "RasEnumConnectionsW"},
    { (LPVOID *) &lpfnRasHangUp,            "RasHangUpW"},
    { (LPVOID *) &lpfnRasGetEntryDialParams,"RasGetEntryDialParamsW"},
    { (LPVOID *) &lpfnRasDial,              "RasDialW"},
    { (LPVOID *) &lpfnRasGetConnectStatus,  "RasGetConnectStatusW"},
    { (LPVOID *) &lpfnRasGetErrorString,    "RasGetErrorStringW"},
    { (LPVOID *) &lpfnRasSetAutodialEnable, "RasSetAutodialEnableW"},
    { (LPVOID *) &lpfnRasSetAutodialAddress,"RasSetAutodialAddressW"},
    { (LPVOID *) &lpfnRasSetEntryDialParams,"RasSetEntryDialParamsW"},
};
#else // UNICODE
APIFCN RasProcListNT[] = {
    { (LPVOID *) &lpfnRasEnumConnections,   "RasEnumConnectionsA"},
    { (LPVOID *) &lpfnRasHangUp,            "RasHangUpA"},
    { (LPVOID *) &lpfnRasGetEntryDialParams,"RasGetEntryDialParamsA"},
    { (LPVOID *) &lpfnRasDial,              "RasDialA"},
    { (LPVOID *) &lpfnRasGetConnectStatus,  "RasGetConnectStatusA"},
    { (LPVOID *) &lpfnRasGetErrorString,    "RasGetErrorStringA"},
    { (LPVOID *) &lpfnRasSetAutodialEnable, "RasSetAutodialEnableA"},
    { (LPVOID *) &lpfnRasSetAutodialAddress,"RasSetAutodialAddressA"},
    { (LPVOID *) &lpfnRasSetEntryDialParams,"RasSetEntryDialParamsA"},
};
#endif // UNICODE

#define cRasProcNT (sizeof(RasProcListNT) / sizeof(RasProcListNT[0]))
#endif


APIFCN RnaPhProcList[] = {
#ifdef UNICODE
    { (LPVOID *) &lpfnRasDeleteEntry,       "RasDeleteEntryW"},
    { (LPVOID *) &lpfnRasGetEntryProperties,"RasGetEntryPropertiesW"},
    { (LPVOID *) &lpfnRasEnumDevices,       "RasEnumDevicesW"},
    { (LPVOID *) &lpfnRasSetEntryProperties,"RasSetEntryPropertiesW"},
#else
    { (LPVOID *) &lpfnRasDeleteEntry,       "RasDeleteEntryA"},
    { (LPVOID *) &lpfnRasGetEntryProperties,"RasGetEntryPropertiesA"},
    { (LPVOID *) &lpfnRasEnumDevices,       "RasEnumDevicesA"},
    { (LPVOID *) &lpfnRasSetEntryProperties,"RasSetEntryPropertiesA"},
#endif

#ifdef UNUSED
    { (LPVOID *) &lpfnRasValidateEntryName, "RasValidateEntryName"},
    { (LPVOID *) &lpfnRasRenameEntry,       "RasRenameEntry"},
    { (LPVOID *) &lpfnRasGetCountryInfo,    "RasGetCountryInfo"},
#endif
};

#define cRnaPhProc (sizeof(RnaPhProcList) / sizeof(RnaPhProcList[0]))

APIFCN InetProcList[] = {
#ifdef WIN32
    { (LPVOID *) &lpfnInetConfigSystem,  "InetConfigSystem"},
#ifdef UNICODE
    { (LPVOID *) &lpfnInetGetProxy,      "InetGetProxyW"},
#else
    { (LPVOID *) &lpfnInetGetProxy,      "InetGetProxy"},
#endif // UNICODE
#endif // WIN32
#ifdef UNICODE
    { (LPVOID *) &lpfnInetConfigClient,  "InetConfigClientW"},
    { (LPVOID *) &lpfnInetGetAutodial,   "InetGetAutodialW"},
    { (LPVOID *) &lpfnInetSetAutodial,   "InetSetAutodialW"},
    { (LPVOID *) &lpfnInetSetClientInfo, "InetSetClientInfoW"},
    { (LPVOID *) &lpfnInetSetProxy,      "InetSetProxyW"},
#else 
    { (LPVOID *) &lpfnInetConfigClient,  "InetConfigClient"},
    { (LPVOID *) &lpfnInetGetAutodial,   "InetGetAutodial"},
    { (LPVOID *) &lpfnInetSetAutodial,   "InetSetAutodial"},
    { (LPVOID *) &lpfnInetSetClientInfo, "InetSetClientInfo"},
    { (LPVOID *) &lpfnInetSetProxy,      "InetSetProxy"},
#endif // UNICODE

#ifdef UNUSED
#ifdef UNICODE
    { (LPVOID *) &lpfnInetGetClientInfo, "InetGetClientInfoW"},
#else
    { (LPVOID *) &lpfnInetGetClientInfo, "InetGetClientInfo"},
#endif
#endif
};

#define cInetProc (sizeof(InetProcList) / sizeof(InetProcList[0]))

APIFCN BrandingProcList[] = {
#ifdef WIN32
    { (LPVOID *) &lpfnBrandICW,   "BrandICW2"},
#else
    { (LPVOID *) &lpfnBrandMe,   "BrandMe"},
#endif
};

#define cBrandingProc (sizeof(BrandingProcList) / sizeof(BrandingProcList[0]))

static HINSTANCE ghRas = NULL;
static HINSTANCE ghRnaPh = NULL;
static HINSTANCE ghInet = NULL;
static HINSTANCE ghBranding = NULL;

#ifndef WIN32
static int iRasRefs = 0;
static int iInetRefs = 0;
static int iBrandingRefs = 0;
#endif

HINSTANCE InitLpfn(LPCTSTR szDllName, APIFCN *pProcList, int cProcs);

BOOL LoadRnaFunctions(HWND hwndParent)
{
#if !defined(WIN16)
	if (!IsRASReady())
	{
		DebugOut("ISIGN32: Attempted to load RAS API's however, the system isn't ready for it.\r\n");
		return FALSE;
	}
#endif
    if (ghRas == NULL)
    {
        if (RAS_MaxEntryName != 256)
        {
        //      MessageBox(NULL, "Invalid header used for compile", szAppName, MB_OK);
            return FALSE;
        }

#ifdef WIN32
		// 1/7/96 jmazner	Normandy #12930
		// init different proc lists based on whether we're in NT or not.
		if( IsNT() )
		{
			if ((ghRas = InitLpfn(cszRasDLL, RasProcListNT, cRasProcNT)) == NULL)
			{
				ErrorMsg(hwndParent, IDS_MISSINGRNADLL);
				return FALSE;
			}
		}
		else
		{
#endif
			if ((ghRas = InitLpfn(cszRasDLL, RasProcList, cRasProc)) == NULL)
			{
				ErrorMsg(hwndParent, IDS_MISSINGRNADLL);
				return FALSE;
			}
#ifdef WIN32
		}
#endif


        if ((ghRnaPh = InitLpfn(cszRasDLL, RnaPhProcList, cRnaPhProc)) == NULL)
        {
#ifdef WIN32
			//
			// we only load RNAPH.DLL if it is not NT
			// MKarki (5/4/97) - Fix for Bug #3378
			//
			 if (FALSE == IsNT ())
			{
#endif
				if ((ghRnaPh = InitLpfn(cszRnaPhDLL, RnaPhProcList, cRnaPhProc)) == NULL)
				{
					FreeLibrary(ghRas);
					ghRas = NULL;
					ErrorMsg(hwndParent, IDS_WRONGRNADLLVER);
					return FALSE;
				}
#ifdef WIN32
			}
			else
			{
					FreeLibrary(ghRas);
					ghRas = NULL;
					ErrorMsg(hwndParent, IDS_WRONGRNADLLVER);
					return FALSE;
				
			}
#endif
        }
    }

#ifndef WIN32
    ++iRasRefs;
#endif
    return TRUE;
}

BOOL LoadInetFunctions(HWND hwndParent)
{
    if (ghInet == NULL)
    {
        if ((ghInet = InitLpfn(TEXT("INETCFG.DLL"), InetProcList, cInetProc)) == NULL)
        {
            ErrorMsg(hwndParent, IDS_MISSINGCFGDLL);
            return FALSE;
        }
    }

#ifndef WIN32
    ++iInetRefs;
#endif
    return TRUE;
}

BOOL LoadBrandingFunctions(void)
{
    if (ghBranding == NULL)
    {
        if ((ghBranding = InitLpfn(cszBrandingDLL, BrandingProcList, cBrandingProc)) == NULL)
        {
            return FALSE;
        }
    }

#ifndef WIN32
    ++iBrandingRefs;
#endif
    return TRUE;
}

HINSTANCE InitLpfn(LPCTSTR szDllName, APIFCN *pProcList, int cProcs)
{
    int i;
    HINSTANCE hLib;
    hLib = LoadLibrary(szDllName);

    if (hLib != NULL)
    {
        for (i = 0; i < cProcs; i++)
        {
            *pProcList[i].lplpfn = (LPVOID) GetProcAddress(hLib, pProcList[i].szApiName);
            if (*pProcList[i].lplpfn == NULL)
            {
#if 0
                CHAR szMsg[256];

                wsprintf(szMsg,
                        "Could not find %s in %s",
                        pProcList[i].szApiName,
                        szDllName);
                MessageBox(NULL, szMsg, "Internet Signup", MB_OK);
#endif
                FreeLibrary(hLib);
                return NULL;
            }
        }
    }
#if 0
    else
    {
        wsprintf(szMsg,
                "Could not load %s",
                szDllName);
        MessageBox(NULL, szMsg, "Internet Signup", MB_OK);
    }
#endif

    return hLib;
}


void UnloadRnaFunctions(void)
{
#ifndef WIN32
    if (0 != --iRasRefs)
    {
        return;
    }
#endif

    // need to unload libraries 
    if (NULL != ghRas)
    {
        FreeLibrary(ghRas);
        ghRas = NULL;
    }
    if (NULL != ghRnaPh)
    {
        FreeLibrary(ghRnaPh);
        ghRas = NULL;
    }
}

void UnloadInetFunctions(void)
{
#ifndef WIN32
    if (0 != --iInetRefs)
    {
        return;
    }
#endif

    if (NULL != ghInet)
    {
        FreeLibrary(ghInet);
        ghInet = NULL;
    }
}

void UnloadBrandingFunctions(void)
{
#ifndef WIN32
    if (0 != --iBrandingRefs)
    {
        return;
    }
#endif

    if (NULL != ghBranding)
    {
        FreeLibrary(ghBranding);
        ghBranding = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\isignole.h ===
//****************************************************************************
//
//  File:       isignole.h
//
//  Content:    This is the include file with the Ole Automation stuff needed by
//				isignup.cpp and sink.cpp.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//
//  Copyright (c) Microsoft Corporation 1996
//
//****************************************************************************

//WIN32 wrappers for these?


#include <objbase.h>

#include <exdisp.h>
#include <exdispid.h>

#include <olectl.h>
#include <ocidl.h>



extern IConnectionPoint * GetConnectionPoint(void);
extern HRESULT InitOle( void );
extern HRESULT KillOle( void );
extern HRESULT IENavigate( TCHAR *szURL );


class CDExplorerEvents : public DWebBrowserEvents
{
    private:
        ULONG       m_cRef;     //Reference count
        //PAPP        m_pApp;     //For calling Message
        //UINT        m_uID;      //Sink identifier

    public:
        //Connection key, public for CApp's usage
        DWORD       m_dwCookie;

    public:
        CDExplorerEvents( void );
        ~CDExplorerEvents(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, VOID * *);
        STDMETHODIMP_(DWORD) AddRef(void);
        STDMETHODIMP_(DWORD) Release(void);

        /* IDispatch methods */
        STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

        STDMETHOD(GetTypeInfo)(UINT itinfo,LCID lcid,ITypeInfo FAR* FAR* pptinfo);

        STDMETHOD(GetIDsOfNames)(REFIID riid,OLECHAR FAR* FAR* rgszNames,UINT cNames,
              LCID lcid, DISPID FAR* rgdispid);

        STDMETHOD(Invoke)(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                  DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\import.cpp ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       import.c
//  Content:    This file contains all the functions that handle importing
//              connection information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//          this code started its life as ixport.c in RNAUI.DLL
//          my thanks to viroont
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "isignup.h"

#define MAXNAME         80
#define MAXIPADDRLEN    20
#define SIZE_ReadBuf    0x00008000    // 32K buffer size

//#pragma data_seg(".rdata")

static const TCHAR cszEntrySection[] = TEXT("Entry");
static const TCHAR cszEntryName[]    = TEXT("Entry_Name");
static const TCHAR cszAlias[]        = TEXT("Import_Name");
static const TCHAR cszML[]           = TEXT("Multilink");

static const TCHAR cszPhoneSection[] = TEXT("Phone");
static const TCHAR cszDialAsIs[]     = TEXT("Dial_As_Is");
static const TCHAR cszPhone[]        = TEXT("Phone_Number");
static const TCHAR cszAreaCode[]     = TEXT("Area_Code");
static const TCHAR cszCountryCode[]  = TEXT("Country_Code");
static const TCHAR cszCountryID[]    = TEXT("Country_ID");

static const TCHAR cszDeviceSection[] = TEXT("Device");
static const TCHAR cszDeviceType[]    = TEXT("Type");
static const TCHAR cszDeviceName[]    = TEXT("Name");
static const TCHAR cszDevCfgSize[]    = TEXT("Settings_Size");
static const TCHAR cszDevCfg[]        = TEXT("Settings");

static const TCHAR cszServerSection[] = TEXT("Server");
static const TCHAR cszServerType[]    = TEXT("Type");
static const TCHAR cszSWCompress[]    = TEXT("SW_Compress");
static const TCHAR cszPWEncrypt[]     = TEXT("PW_Encrypt");
static const TCHAR cszNetLogon[]      = TEXT("Network_Logon");
static const TCHAR cszSWEncrypt[]     = TEXT("SW_Encrypt");
static const TCHAR cszNetBEUI[]       = TEXT("Negotiate_NetBEUI");
static const TCHAR cszIPX[]           = TEXT("Negotiate_IPX/SPX");
static const TCHAR cszIP[]            = TEXT("Negotiate_TCP/IP");
static TCHAR cszDisableLcp[]          = TEXT("Disable_LCP");

static const TCHAR cszIPSection[]     = TEXT("TCP/IP");
static const TCHAR cszIPSpec[]        = TEXT("Specify_IP_Address");
static const TCHAR cszIPAddress[]     = TEXT("IP_address");
static const TCHAR cszServerSpec[]    = TEXT("Specify_Server_Address");
static const TCHAR cszDNSAddress[]    = TEXT("DNS_address");
static const TCHAR cszDNSAltAddress[] = TEXT("DNS_Alt_address");
static const TCHAR cszWINSAddress[]   = TEXT("WINS_address");
static const TCHAR cszWINSAltAddress[]= TEXT("WINS_Alt_address");
static const TCHAR cszIPCompress[]    = TEXT("IP_Header_Compress");
static const TCHAR cszWanPri[]        = TEXT("Gateway_On_Remote");

static const TCHAR cszMLSection[]     = TEXT("Multilink");
static const TCHAR cszLinkIndex[]     = TEXT("Line_%s");

static const TCHAR cszScriptingSection[] = TEXT("Scripting");
static const TCHAR cszScriptName[]    = TEXT("Name");

static const TCHAR cszScriptSection[] = TEXT("Script_File");

#if !defined(WIN16)
static const TCHAR cszCustomDialerSection[] = TEXT("Custom_Dialer");
static const TCHAR cszAutoDialDLL[] = TEXT("Auto_Dial_DLL");
static const TCHAR cszAutoDialFunc[] = TEXT("Auto_Dial_Function");
#endif //!WIN16

static const TCHAR cszYes[]           = TEXT("yes");
static const TCHAR cszNo[]            = TEXT("no");

static const TCHAR cszUserSection[]   = TEXT("User");
static const TCHAR cszUserName[]      = TEXT("Name");
static const TCHAR cszPassword[]      = TEXT("Password");

static const TCHAR cszNull[] = TEXT("");

struct {
    TCHAR *szType;
    DWORD dwType;
    DWORD dwfOptions;
} aServerTypes[] =
{ 
    {TEXT("PPP"),     RASFP_Ppp,  0},
    {TEXT("SLIP"),    RASFP_Slip, 0},
    {TEXT("CSLIP"),   RASFP_Slip, RASEO_IpHeaderCompression},
    {TEXT("RAS"),     RASFP_Ras,  0}
};

//#pragma data_seg()

#define myisdigit(ch) (((ch) >= '0') && ((ch) <= '9'))

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//	Function:	ImportCustomDialer
//
//	Synopsis:	Import custom dialer information from the specified file
//				and save the information in the RASENTRY
//
//	Arguments:	lpRasEntry - pointer to a valid RASENTRY structure
//				szFileName - text file (in .ini file format) containing the
//				Custom Dialer information
//
//	Returns:	ERROR_SUCCESS - success otherwise a Win32 error
//
//	History:	ChrisK	Created		7/11/96
//			8/12/96	ChrisK	Ported from \\trango
//
//-----------------------------------------------------------------------------
DWORD ImportCustomDialer(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{

	// If there is an error reading the information from the file, or the entry
	// missing or blank, the default value (cszNull) will be used.
	GetPrivateProfileString(cszCustomDialerSection,
	                        cszAutoDialDLL,
	                        cszNull,
	                        lpRasEntry->szAutodialDll,
	                        MAX_PATH,
	                        szFileName);

	GetPrivateProfileString(cszCustomDialerSection,
	                        cszAutoDialFunc,
	                        cszNull,
	                        lpRasEntry->szAutodialFunc,
	                        MAX_PATH,
	                        szFileName);

	return ERROR_SUCCESS;
}
#endif //!WIN16

//****************************************************************************
// DWORD NEAR PASCAL StrToip (LPTSTR szIPAddress, LPDWORD lpdwAddr)
//
// This function converts a IP address string to an IP address structure.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Cloned from SMMSCRPT.
//****************************************************************************

LPCTSTR NEAR PASCAL StrToSubip (LPCTSTR szIPAddress, LPBYTE pVal)
{
  LPCTSTR pszIP = szIPAddress;
  BYTE val = 0;

  // skip separators (non digits)
  while (*pszIP && !myisdigit(*pszIP))
  {
      ++pszIP;
  }

  while (myisdigit(*pszIP))
  {
      val = (val * 10) + (BYTE)(*pszIP - '0');
      ++pszIP;
  }
   
  *pVal = val;

  return pszIP;
}


DWORD NEAR PASCAL StrToip (LPCTSTR szIPAddress, RASIPADDR *ipAddr)
{
  LPCTSTR pszIP = szIPAddress;

  pszIP = StrToSubip(pszIP, &ipAddr->a);
  pszIP = StrToSubip(pszIP, &ipAddr->b);
  pszIP = StrToSubip(pszIP, &ipAddr->c);
  pszIP = StrToSubip(pszIP, &ipAddr->d);

  return ERROR_SUCCESS;
}


//****************************************************************************
// DWORD NEAR PASCAL ImportPhoneInfo(PPHONENUM ppn, LPCTSTR szFileName)
//
// This function imports the phone number.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szYesNo[MAXNAME];

  if (GetPrivateProfileString(cszPhoneSection,
                              cszPhone,
                              cszNull,
                              lpRasEntry->szLocalPhoneNumber,
                              RAS_MaxPhoneNumber,
                              szFileName) == 0)
  {
    return ERROR_BAD_PHONE_NUMBER;
  };

  lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

  GetPrivateProfileString(cszPhoneSection,
                          cszDialAsIs,
                          cszNo,
                          szYesNo,
                          MAXNAME,
                          szFileName);

  // Do we have to get country code and area code?
  //
  if (!lstrcmpi(szYesNo, cszNo))
  {

    // If we cannot get the country ID or it is zero, default to dial as is
    //
    if ((lpRasEntry->dwCountryID = GetPrivateProfileInt(cszPhoneSection,
                                                 cszCountryID,
                                                 0,
                                                 szFileName)) != 0)
    {
      lpRasEntry->dwCountryCode = GetPrivateProfileInt(cszPhoneSection,
                                                cszCountryCode,
                                                1,
                                                szFileName);

      GetPrivateProfileString(cszPhoneSection,
                              cszAreaCode,
                              cszNull,
                              lpRasEntry->szAreaCode,
                              RAS_MaxAreaCode,
                              szFileName);

      lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

    }
  }
#ifdef WIN32
  else
  {
      // bug in RasSetEntryProperties still checks area codes
      // even when RASEO_UseCountryAndAreaCodes is not set
      lstrcpy(lpRasEntry->szAreaCode, TEXT("805"));
      lpRasEntry->dwCountryID = 1;
      lpRasEntry->dwCountryCode = 1;
  }
#endif
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportServerInfo(PSMMINFO psmmi, LPTSTR szFileName)
//
// This function imports the server type name and settings.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportServerInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szYesNo[MAXNAME];
  TCHAR   szType[MAXNAME];
  DWORD  i;

  // Get the server type name
  //
  GetPrivateProfileString(cszServerSection,
                          cszServerType,
                          cszNull,
                          szType,
                          MAXNAME,
                          szFileName);

  // need to convert the string into
  // one of the following values
  //   RASFP_Ppp
  //   RASFP_Slip  Note CSLIP is SLIP with IP compression on
  //   RASFP_Ras

  for (i = 0; i < sizeof(aServerTypes)/sizeof(aServerTypes[0]); ++i)
  {
    if (!lstrcmpi(aServerTypes[i].szType, szType))
    {
       lpRasEntry->dwFramingProtocol = aServerTypes[i].dwType;
       lpRasEntry->dwfOptions |= aServerTypes[i].dwfOptions;
       break;
    }
  }

  // Get the server type settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszSWCompress,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_SwCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_SwCompression;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszPWEncrypt,
                              cszNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireEncryptedPw;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszNetLogon,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_NetworkLogon;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_NetworkLogon;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszSWEncrypt,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireDataEncryption;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
    };
  };

  // Get the protocol settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszNetBEUI,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfNetProtocols &= ~RASNP_NetBEUI;
    }
    else
    {
      lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIPX,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfNetProtocols &= ~RASNP_Ipx;
    }
    else
    {
      lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIP,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfNetProtocols &= ~RASNP_Ip;
    }
    else
    {
      lpRasEntry->dwfNetProtocols |= RASNP_Ip;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszDisableLcp,
							  cszNull,
							  szYesNo,
							  MAXNAME,
							  szFileName))
  {
	if (!lstrcmpi(szYesNo, cszYes))
	{
		lpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
	}
	else
	{
		lpRasEntry->dwfOptions &= ~RASEO_DisableLcpExtensions;
	}
  };

  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportIPInfo(LPTSTR szEntryName, LPTSTR szFileName)
//
// This function imports the TCP/IP information
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportIPInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szIPAddr[MAXIPADDRLEN];
  TCHAR   szYesNo[MAXNAME];

  // Import IP address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPSpec,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has IP address specified, get the IP address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
      if (GetPrivateProfileString(cszIPSection,
                                  cszIPAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddr);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;
    };
  };

  // Import Server address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszServerSpec,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has server address specified, get the server address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDns);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAltAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDnsAlt);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWins);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAltAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWinsAlt);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
    };
  };

  // Header compression and the gateway settings
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPCompress,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
    };
  };

  if (GetPrivateProfileString(cszIPSection,
                              cszWanPri,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RemoteDefaultGateway;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
    };
  };

  return ERROR_SUCCESS;
}

DWORD NEAR PASCAL ImportScriptFile(
    LPCTSTR lpszImportFile,
    LPTSTR szScriptFile,
    UINT cbScriptFile)
{
    TCHAR szTemp[_MAX_PATH];
    DWORD dwRet = ERROR_SUCCESS;
    
    // Get the script filename
    //
    if (GetPrivateProfileString(cszScriptingSection,
                                cszScriptName,
                                cszNull,
                                szTemp,
                                _MAX_PATH,
                                lpszImportFile) != 0)
    {
 
//!!! commonize this code
//!!! make it DBCS compatible
//!!! check for overruns
//!!! check for absolute path name
        GetWindowsDirectory(szScriptFile, cbScriptFile);
        if (*CharPrev(szScriptFile, szScriptFile + lstrlen(szScriptFile)) != '\\')
        {
            lstrcat(szScriptFile, TEXT("\\"));
        }
        lstrcat(szScriptFile, szTemp);
  
        dwRet =ImportFile(lpszImportFile, cszScriptSection, szScriptFile);
    }

    return dwRet;
}
 
//****************************************************************************
// DWORD WINAPI RnaValidateImportEntry (LPTSTR)
//
// This function is called to validate an importable file
//
// History:
//  Wed 03-Jan-1996 09:45:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD WINAPI RnaValidateImportEntry (LPCTSTR szFileName)
{
  TCHAR  szTmp[MAX_PATH+1];

  // Get the alias entry name
  //
  // 12/4/96	jmazner	Normandy #12373
  // If no such key, don't return ERROR_INVALID_PHONEBOOK_ENTRY,
  // since ConfigureClient always ignores that error code.

  return (GetPrivateProfileString(cszEntrySection,
                                  cszEntryName,
                                  cszNull,
                                  szTmp,
                                  MAX_PATH,
                                  szFileName) > 0 ?
          ERROR_SUCCESS : ERROR_NO_MATCH);
}

//****************************************************************************
// DWORD WINAPI RnaImportEntry (LPTSTR, LPBYTE, DWORD)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD ImportRasEntry (LPCTSTR szFileName, LPRASENTRY lpRasEntry)
{
    DWORD         dwRet;

    dwRet = ImportPhoneInfo(lpRasEntry, szFileName);
    if (ERROR_SUCCESS == dwRet)
    {
        // Get device type
        //
        GetPrivateProfileString(cszDeviceSection,
                              cszDeviceType,
                              cszNull,
                              lpRasEntry->szDeviceType,
                              RAS_MaxDeviceType,
                              szFileName);
        
        // Get Server Type settings
        //
        dwRet = ImportServerInfo(lpRasEntry, szFileName);
        if (ERROR_SUCCESS == dwRet)
        {
            // Get IP address
            //
            dwRet = ImportIPInfo(lpRasEntry, szFileName);
        }
    }

    return dwRet;
}


//****************************************************************************
// DWORD WINAPI RnaImportEntry (LPTSTR, LPBYTE, DWORD)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD ImportConnection (LPCTSTR szFileName, LPICONNECTION lpConn)
{
    DWORD   dwRet;

    lpConn->RasEntry.dwSize = sizeof(RASENTRY);

    dwRet = RnaValidateImportEntry(szFileName);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    GetPrivateProfileString(cszEntrySection,
                          cszEntryName,
                          cszNull,
                          lpConn->szEntryName,
                          RAS_MaxEntryName,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszUserName,
                          cszNull,
                          lpConn->szUserName,
                          UNLEN,
                          szFileName);
  
    GetPrivateProfileString(cszUserSection,
                          cszPassword,
                          cszNull,
                          lpConn->szPassword,
                          PWLEN,
                          szFileName);
  
    dwRet = ImportRasEntry(szFileName, &lpConn->RasEntry);
#if !defined(WIN16)
    if (ERROR_SUCCESS == dwRet)
    {
        dwRet = ImportCustomDialer(&lpConn->RasEntry, szFileName);
    }
#endif //!WIN16

    if (ERROR_SUCCESS == dwRet)
    {
        // Import the script file
        //
        dwRet = ImportScriptFile(szFileName,
                lpConn->RasEntry.szScript,
                sizeof(lpConn->RasEntry.szScript)/sizeof(TCHAR));
    }

#if !defined(WIN16)
	dwRet = ConfigRasEntryDevice(&lpConn->RasEntry);
	switch( dwRet )
	{
		case ERROR_SUCCESS:
			break;
		case ERROR_CANCELLED:
			InfoMsg(NULL, IDS_SIGNUPCANCELLED);
			// Fall through
		default:
			goto ImportConnectionExit;
	}

#endif

ImportConnectionExit:
  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\isignole.cpp ===
/*----------------------------------------------------------------------------
	isignole.cpp

	Contains the functions that control IE OLE Automation for ISIGN32

	Copyright (C) 1995-96 Microsoft Corporation
	All right reserved

  Authors:
	jmazner		Jeremy Mazner

  History:
	9/27/96		jmazner		Created.  Most of this code is stolen from josephh's CONNECT.EXE
							source code at \\josephh8\connect\sink.cpp.
							He in turn stole most of the code from examples in Brockshmidt's
							"Inside OLE, 2nd edition"

							Comments from CDExplorerEvents functions are from josephh
----------------------------------------------------------------------------*/

#include "isignup.h"

#ifdef WIN32
#define INITGUID

#include "isignole.h"
// 4-29-97 ChrisK Olympus 131
#include <urlmon.h>


EXTERN_C const GUID DIID_DWebBrowserEvents;

EXTERN_C const GUID IID_IWebBrowserApp;

#endif


extern INET_FILETYPE GetInetFileType(LPCTSTR lpszFile);

extern IWebBrowserApp FAR * g_iwbapp;
extern CDExplorerEvents * g_pMySink;
extern IConnectionPoint	*g_pCP;
extern TCHAR	g_szISPPath[MAX_URL + 1];

extern BOOL CreateSecurityPatchBackup( void );




/*****************************************************
**
** Function: CDExplorerEvents::CDExplorerEvents
**
** Description: Constructor for CDExplorerEvents
**
** Because we stole this code from a sample app, we
** need to decide if we should do reference counts.
** It works ok without it in simple senerios, but
** we should probably research this area, and update
** the code to handle this properly.
**
** Parameters:
**
**
** Returns: Not
**
**
******************************************************/

CDExplorerEvents::CDExplorerEvents( void )
    {
	DebugOut("CDExplorerEvents:: constructor.\n");
    m_cRef=0;
    m_dwCookie=0;
    return;
    }

/*****************************************************
**
** Function: CDExplorerEvents::~CDExplorerEvents
**
** Description: Destructor for CDExplorerEvents
**
** Parameters: Not
**
** Returns: Not
**
**
******************************************************/

CDExplorerEvents::~CDExplorerEvents(void)
	{
	DebugOut("CDExplorerEvents:: destructor.\n");
    return;
	}



/*****************************************************
**
** Function: CDExplorerEvents::QueryInterface
**
** Description: Is called to QueryInterface for DExplorerEvents.
**
** Parameters:
**
** REFIID riid,  //Reference ID
** LPVOID FAR* ppvObj //Pointer to this object
**
** Returns:
** S_OK if interface supported
** E_NOINTERFACE if not
**
******************************************************/

STDMETHODIMP CDExplorerEvents::QueryInterface (
   REFIID riid,  //Reference ID
   LPVOID FAR* ppvObj //Pointer to this object
   )
{
    if (IsEqualIID(riid, IID_IDispatch)
           )
    {
        *ppvObj = (DWebBrowserEvents *)this;
        AddRef();
        DebugOut("CDExplorerEvents::QueryInterface IID_IDispatch returned S_OK\r\n");
        return S_OK;
    }

    if (
    IsEqualIID(riid, DIID_DWebBrowserEvents)
           )
    {
        *ppvObj = (DWebBrowserEvents *)this;
        AddRef();
        DebugOut("CDExplorerEvents::QueryInterface DIID_DExplorerEvents returned S_OK\r\n");
        return S_OK;
    }

    if (
    IsEqualIID(riid, IID_IUnknown)
           )
    {
        *ppvObj = (DWebBrowserEvents *)this;
        AddRef();
        DebugOut("CDExplorerEvents::QueryInterface IID_IUnknown returned S_OK\r\n");
        return S_OK;
    }


    DebugOut("CDExplorerEvents::QueryInterface returned E_NOINTERFACE\r\n");
    return E_NOINTERFACE;
}

/*****************************************************
**
** Function: CDExplorerEvents::AddRef
**
** Description: Increments the Reference Count for this
** object.
**
** Parameters: Not
**
** Returns: New Reference Count
**
******************************************************/


STDMETHODIMP_(ULONG) CDExplorerEvents::AddRef(void)
    {
	DebugOut("CDExplorerEvents:: AddRef.\n");
    return ++m_cRef;
    }

/*****************************************************
**
** Function: CDExplorerEvents::Release
**
** Description: Decrements the reference count, frees
** the object if zero.
**
** Parameters: not
**
** Returns: decremented reference count
**
******************************************************/

STDMETHODIMP_(ULONG) CDExplorerEvents::Release(void)
    {
	DebugOut("CDExplorerEvents:: Release.\n");
    if (0!=--m_cRef)
        return m_cRef;

    delete this;
    return 0;
    }


/*****************************************************
**
** Function: CDExplorerEvents::GetTypeInfoCount
**
** Description: GetTypeInfoCount is required, but STUBBED
**
** Parameters: Not used
**
** Returns: E_NOTIMPL
**
******************************************************/


STDMETHODIMP  CDExplorerEvents::GetTypeInfoCount (UINT FAR* pctinfo)
{
    return E_NOTIMPL;
}

/*****************************************************
**
** Function: CDExplorerEvents::GetTypeInfo
**
** Description: GetTypeInfo is required, but STUBBED
**
** Parameters: Not used
**
** Returns: E_NOTIMPL
**
******************************************************/

STDMETHODIMP CDExplorerEvents::GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo FAR* FAR* pptinfo)
{
    return E_NOTIMPL;
}

/*****************************************************
**
** Function: CDExplorerEvents::GetIDsOfNames
**
** Description: GetIDsOfNames is required, but STUBBED
**
** Parameters: Not used
**
** Returns: E_NOTIMPL
**
******************************************************/

STDMETHODIMP CDExplorerEvents::GetIDsOfNames (REFIID riid,OLECHAR FAR* FAR* rgszNames,UINT cNames,
      LCID lcid, DISPID FAR* rgdispid)
{
    return E_NOTIMPL;
}


/*****************************************************
**
** Function: CDExplorerEvents::Invoke
**
** Description: This is the callback for our IE event sink.
**
**				jmazner -- we only handle two events:
**					BEFORENAVIGATE: check whether the UEL is an .isp file.
**									if so, cancel the navigation and signal processISP
**									Otherwise, allow the navigation to continue
**									(note  that this means .ins files are handled by IE
**									 execing another instance of isignup)
**					QUIT: we want to release our hold on IWebBrowserApp; if we send the quit
**							ourselves, this is actually done in KillOle, but if IE quits of
**							its own accord, we have to handle it here.
**
** Parameters:  Many
**
** Returns: S_OK
**
******************************************************/

STDMETHODIMP CDExplorerEvents::Invoke (
   DISPID dispidMember,
   REFIID riid,
   LCID lcid,
   WORD wFlags,
   DISPPARAMS FAR* pdispparams,
   VARIANT FAR* pvarResult,
   EXCEPINFO FAR* pexcepinfo,
   UINT FAR* puArgErr
   )
{
	INET_FILETYPE fileType;
	DWORD dwresult;
	HRESULT hresult;
	DWORD szMultiByteLength;
	TCHAR *szTheURL = NULL;

	static fAlreadyBackedUpSecurity = FALSE;

	switch (dispidMember)
    {	
	case DISPID_BEFORENAVIGATE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_NAVIGATEBEGIN) called\r\n");
		//Assert( pdispparams->cArgs == 6 )
	//TODO UNDONE what's the right way to figure out which arg is which???
#ifndef UNICODE
		szMultiByteLength = WideCharToMultiByte(
			CP_ACP,
			NULL,
			pdispparams->rgvarg[5].bstrVal, // first arg is URL
			-1, //NUll terminated?  I hope so!
			NULL, //tell us how long the string needs to be
			0,
			NULL,
			NULL);

		if( 0 == szMultiByteLength )
		{
			DebugOut("ISIGNUP: CDExplorerEvents::Invoke couldn't determine ASCII URL length\r\n");
			dwresult = GetLastError();
			hresult = HRESULT_FROM_WIN32( dwresult );
			return( hresult );
		}

		szTheURL = (CHAR *) GlobalAlloc( GPTR, sizeof(CHAR) * szMultiByteLength );

		if( !szTheURL )
		{
			DebugOut("ISIGNUP: CDExplorerEvents::Invoke couldn't allocate szTheURL\r\n");
			hresult = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
			return( hresult );
		}

		dwresult = WideCharToMultiByte(
			CP_ACP,
			NULL,
			pdispparams->rgvarg[5].bstrVal, // first arg is URL
			-1, //NUll terminated?  I hope so!
			szTheURL,
			szMultiByteLength,
			NULL,
			NULL);

		if( 0 == dwresult )
		{
			DebugOut("ISIGNUP: CDExplorerEvents::Invoke WideCharToMultiByte failed\r\n");
			dwresult = GetLastError();
			hresult = HRESULT_FROM_WIN32( dwresult );
			return( hresult );
		}
#else  // UNICODE
		szTheURL = (TCHAR *) GlobalAlloc( GPTR, sizeof(TCHAR) * (lstrlen(pdispparams->rgvarg[5].bstrVal)+1) );
                lstrcpy(szTheURL, pdispparams->rgvarg[5].bstrVal);
#endif // UNICODE


		fileType = GetInetFileType(szTheURL);

		DebugOut("ISIGNUP: BEFORENAVIGATE got '");
		DebugOut(szTheURL);
		DebugOut("'\r\n");

		if( ISP_FILE != fileType)
		{
			// let IE process as normal
			return( S_OK );
		}
		else
		{
			// cancel the navigation
			//TODO UNDONE BUG  what's the right way to find which argument is cancel flag?
			
			// jmazner 11/6/96 alpha build
			// Alpha doesn't like pbool field, but pboolVal seems to work
			// Should make no difference, it's just one big union
			//*(pdispparams->rgvarg[0].pbool) = TRUE;
			*(pdispparams->rgvarg[0].pboolVal) = TRUE;

			if (!IsCurrentlyProcessingISP())
			{
				lstrcpy( g_szISPPath, szTheURL );
			}
			GlobalFree( szTheURL );

			PostMessage(GetHwndMain(), WM_PROCESSISP, 0, 0);

		}
		break;

	case DISPID_NAVIGATECOMPLETE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_NAVIGATECOMPLETE) called\r\n");
		if( NeedBackupSecurity() && !fAlreadyBackedUpSecurity )
		{
			if( !CreateSecurityPatchBackup() )
			{
				DebugOut("ISIGN32: CreateSecurityPatchBackup Failed!!\r\n");
			}

			fAlreadyBackedUpSecurity = TRUE;
		}
		break;

	case DISPID_STATUSTEXTCHANGE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_STATUSTEXTCHANGE) called\r\n");
		break;

	case DISPID_QUIT:
		DebugOut("CDExplorerEvents::Invoke (DISPID_QUIT) called\r\n");

		// browser is about to cloes itself down, so g_iwbapp is about to become invalid
		if( g_pCP && g_pMySink)
		{

			hresult = g_pCP->Unadvise(g_pMySink->m_dwCookie);
			if ( FAILED( hresult ) )
			{
				DebugOut("ISIGNUP: KillSink unadvise failed\r\n");
			}

			g_pMySink->m_dwCookie = 0;
			
			g_pCP->Release();
			
			g_pCP = NULL;
		}

		if( g_iwbapp )
		{
			g_iwbapp->Release();
			g_iwbapp = NULL;
		}

	    PostMessage(GetHwndMain(), WM_CLOSE, 0, 0);
		break;

	case DISPID_DOWNLOADCOMPLETE :
		DebugOut("CDExplorerEvents::Invoke (DISPID_DOWNLOADCOMPLETE) called\r\n");
		break;

	case DISPID_COMMANDSTATECHANGE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_COMMANDSTATECHANGE) called\r\n");
		break;

	case DISPID_DOWNLOADBEGIN:
		DebugOut("CDExplorerEvents::Invoke (DISPID_DOWNLOADBEGIN) called\r\n");
		break;

	case DISPID_NEWWINDOW:
		DebugOut("CDExplorerEvents::Invoke (DISPID_NEWWINDOW) called\r\n");
		break;

	case DISPID_PROGRESSCHANGE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_PROGRESS) called\r\n");
		break;

	case DISPID_WINDOWMOVE       :
		DebugOut("CDExplorerEvents::Invoke (DISPID_WINDOWMOVE) called\r\n");
		break;

	case DISPID_WINDOWRESIZE     :
		DebugOut("CDExplorerEvents::Invoke (DISPID_WINDOWRESIZE) called\r\n");
		break;

	case DISPID_WINDOWACTIVATE   :
		DebugOut("CDExplorerEvents::Invoke (DISPID_WINDOWACTIVATE) called\r\n");
		break;
		
	case DISPID_PROPERTYCHANGE   :
		DebugOut("CDExplorerEvents::Invoke (DISPID_PROPERTYCHANGE) called\r\n");
		break;

	case DISPID_TITLECHANGE:
		DebugOut("CDExplorerEvents::Invoke (DISPID_TITLECHANGE) called\r\n");
		break;

	default:
		DebugOut("CDExplorerEvents::Invoke (Unkwown) called\r\n");
		break;
	}
	
	return S_OK;
}

//+---------------------------------------------------------------------------
//
//	Function:	GetConnectionPoint
//
//	Synopsis:	Gets a connection point from IE so that we can become an event sync
//
//	Arguments:	none
//
//	Returns:	pointer to connection point; returns NULL if couldn't connect
//
//	History:	9/27/96	jmazner	created; mostly stolen from josephh who stole from Inside OLE
//----------------------------------------------------------------------------
IConnectionPoint * GetConnectionPoint(void)
{
    HRESULT                     hr;
    IConnectionPointContainer  *pCPCont = NULL;
    IConnectionPoint           *pCP = NULL;



    if (!g_iwbapp)
      return (NULL);

    hr = g_iwbapp->QueryInterface(IID_IConnectionPointContainer, (VOID * *)&pCPCont);

    if ( FAILED(hr) )
    {
        DebugOut("ISIGNUP: GetConnectionPoint unable to QI for IConnectionPointContainter:IWebBrowserApp\r\n");
        return NULL;
    }

    hr=pCPCont->FindConnectionPoint(
      DIID_DWebBrowserEvents,
      &pCP
      );


    if ( FAILED(hr) )
    {
        DebugOut("ISIGNUP: GetConnectionPoint failed on FindConnectionPoint:IWebBrowserApp\r\n");
        pCPCont->Release();
        return NULL;
    }

    hr = pCPCont->Release();
	if ( FAILED(hr) )
    {
        DebugOut("ISIGNUP: WARNING: GetConnectionPoint failed on pCPCont->Release()\r\n");
    }

    return pCP;
}


//+---------------------------------------------------------------------------
//
//	Function:	KillOle
//
//	Synopsis:	Cleans up all the OLE pointers and references that we used
//
//	Arguments:	none
//
//	Returns:	hresult of any operation that failed; if nothing fails, then returns
//				a SUCCESS hresult
//
//	History:	9/27/96	jmazner	created;
//----------------------------------------------------------------------------

HRESULT KillOle( void )
{

	HRESULT hresult;
	BOOL	bAlreadyDead = TRUE;

	if( g_iwbapp )
	{
		bAlreadyDead = FALSE;
		hresult = g_iwbapp->Release();
		if ( FAILED( hresult ) )
		{
			DebugOut("ISIGNUP: g_iwbapp->Release() unadvise failed\r\n");
		}


		g_iwbapp = NULL;
	}

	if( g_pCP && !bAlreadyDead && g_pMySink)
	{

		hresult = g_pCP->Unadvise(g_pMySink->m_dwCookie);
		if ( FAILED( hresult ) )
		{
			DebugOut("ISIGNUP: KillSink unadvise failed\r\n");
		}

		g_pMySink->m_dwCookie = 0;
		
		if (g_pCP) g_pCP->Release();
		
		g_pCP = NULL;
	}

	if( g_pMySink )
	{
		//delete (g_pMySink);
		//
		// 5/10/97 ChrisK Windows NT Bug 82032
		//
		g_pMySink->Release();

		g_pMySink = NULL;
	}

	CoUninitialize();

	return( hresult );
}


//+---------------------------------------------------------------------------
//
//	Function:	InitOle
//
//	Synopsis:	Fire up the OLE bits that we'll need, establish the Interface pointer to IE
//
//	Arguments:	none
//
//	Returns:	hresult of any operation that failed; if nothing fails, then returns
//				a SUCCESS hresult
//
//	History:	9/27/96	jmazner	created; mostly stolen from josephh who stole from Inside OLE
//----------------------------------------------------------------------------


HRESULT InitOle( void )
{
	IUnknown FAR * punk;
	HRESULT hresult;


	hresult = CoInitialize( NULL );
	if( FAILED(hresult) )
	{
		DebugOut("ISIGNUP: CoInitialize failed\n");
		return( hresult );		
	}

	hresult = CoCreateInstance (
        CLSID_InternetExplorer,
        NULL, //Not part of an agregate object
        CLSCTX_LOCAL_SERVER, //I hope...
        IID_IUnknown,
        (void FAR * FAR*) & punk
        );

	if( FAILED(hresult) )
	{
		DebugOut("ISIGNUP: CoCreateInstance failed\n");
		return( hresult );		
	}


    hresult = punk->QueryInterface(IID_IWebBrowserApp,
									(void FAR* FAR*)&(g_iwbapp) );
	if( FAILED(hresult) )
	{
		DebugOut("ISIGNUP: punk->QueryInterface on IID_IWebBrowserApp failed\n");
		return( hresult );		

	}


	//UNDONE TODO BUG do we need to do this?
	g_iwbapp->AddRef();

	punk->Release();
	punk = NULL;

	return( hresult );
}

typedef HRESULT (WINAPI *URLDOWNLOADTOCACHEFILE)(LPUNKNOWN,LPCWSTR,LPWSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
#define ICWSETTINGSPATH TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICWENABLEURLDOWNLOADTOCACHEFILE TEXT("URLDownloadToCacheFileW")
//+----------------------------------------------------------------------------
// This is a temporary work around to allow the testing team to continue
// testing while allowing the IE team to debug a problem with
// URLDownloadToCacheFileW
// UNDONE : BUGBUG
//-----------------------------------------------------------------------------
BOOL EnableURLDownloadToCacheFileW()
{

	HKEY hkey = NULL;
	BOOL bRC = FALSE;
	DWORD dwType = 0;
	DWORD dwData = 0;
	DWORD dwSize = sizeof(dwData);

	if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,ICWSETTINGSPATH,&hkey))
		goto EnableURLDownloadToCacheFileWExit;

	if (ERROR_SUCCESS != RegQueryValueEx(hkey,
		ICWENABLEURLDOWNLOADTOCACHEFILE,0,&dwType,(LPBYTE)&dwData,&dwSize))
		goto EnableURLDownloadToCacheFileWExit;

	bRC = (dwData != 0);
EnableURLDownloadToCacheFileWExit:
	if (NULL != hkey)
		RegCloseKey(hkey);
	hkey = NULL;

	if (bRC)
		DebugOut("ISIGNUP: URLDownloadToCacheFileW ENABLED.\n");
	else
		DebugOut("ISIGNUP: URLDownloadToCacheFileW disabled.\n");

	return bRC;
}

//+---------------------------------------------------------------------------
//
//	Function:	IENavigate
//
//	Synopsis:	Converts ASCII URL to Unicode and tells IE to navigate to it
//
//	Arguments:	CHAR * szURL -- ASCII URL to navigate to
//
//	Returns:	hresult of any operation that failed; if nothing fails, then returns
//				a SUCCESS hresult
//
//	History:	9/27/96	jmazner	created; mostly stolen from josephh who stole from Inside OLE
//----------------------------------------------------------------------------

HRESULT IENavigate( TCHAR *szURL )
{
	HRESULT hresult;
	DWORD		dwresult;
	BSTR bstr = NULL;
	WCHAR * szWide;  // Used to store unicode version of URL to open
	int	iWideSize = 0;
	HINSTANCE hUrlMon = NULL;
	FARPROC fp = NULL;
	WCHAR szCacheFile[MAX_PATH];
	
#ifndef UNICODE
	iWideSize = MultiByteToWideChar( CP_ACP,
						MB_PRECOMPOSED,
						szURL,
						-1,
						NULL,
						0);

	if( 0 == iWideSize )
	{
		DebugOut("ISIGNUP: IENavigate couldn't determine size for szWide");
		dwresult = GetLastError();
		hresult = HRESULT_FROM_WIN32( dwresult );
		goto IENavigateExit;
	}

	szWide = (WCHAR *) GlobalAlloc( GPTR, sizeof(WCHAR) * iWideSize );

	if( !szWide )
	{
		DebugOut("ISIGNUP: IENavigate couldn't alloc memory for szWide");
		hresult = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
		goto IENavigateExit;
	}


	dwresult = MultiByteToWideChar( CP_ACP,
						MB_PRECOMPOSED,
						szURL,
						-1,
						szWide,
						iWideSize);

	if( 0 == dwresult )
	{
		DebugOut("ISIGNUP: IENavigate couldn't convert ANSI URL to Unicdoe");
		GlobalFree( szWide );
		szWide = NULL;
		dwresult = GetLastError();
		hresult = HRESULT_FROM_WIN32( dwresult );
		goto IENavigateExit;
	}
#endif

	// 4/15/97 - ChrisK Olympus 131
	// Download the initial URL in order to see if the page is available
	if (NULL == (hUrlMon = LoadLibrary(TEXT("URLMON.DLL"))))
	{
		hresult = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
		goto IENavigateExit;
	}

	if (NULL == (fp = GetProcAddress(hUrlMon,"URLDownloadToCacheFileW")))
	{
		hresult = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
		goto IENavigateExit;
	}

	if (FALSE != EnableURLDownloadToCacheFileW())
	{
//		iBSC = new CBindStatusCallback(NULL, NULL, NULL, NULL);
#ifdef UNICODE
		hresult = ((URLDOWNLOADTOCACHEFILE)fp)(NULL, szURL, szCacheFile, sizeof(szCacheFile), 0, NULL);
#else
		hresult = ((URLDOWNLOADTOCACHEFILE)fp)(NULL, szWide, szCacheFile, sizeof(szCacheFile), 0, NULL);
#endif
		if (S_OK != hresult)
			goto IENavigateExit;
	}

#ifdef UNICODE
	bstr = SysAllocString(szURL);
#else
	bstr = SysAllocString(szWide);
#endif
	if( !bstr )
	{
		DebugOut("ISIGNUP: IENavigate couldn't alloc memory for bstr");
		hresult = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
		goto IENavigateExit;
	}


	VARIANT vFlags          ;
	VARIANT vTargetFrameName;
	VARIANT vPostData       ;
	VARIANT vHeaders        ;

	VariantInit (&vFlags);
	VariantInit (&vTargetFrameName);
	VariantInit (&vPostData);
	VariantInit (&vHeaders);
	V_VT(&vFlags) = VT_ERROR;
	V_ERROR(&vFlags) = DISP_E_PARAMNOTFOUND;
	V_VT(&vTargetFrameName) = VT_ERROR;
	V_ERROR(&vTargetFrameName) = DISP_E_PARAMNOTFOUND;
	V_VT(&vPostData) = VT_ERROR;
	V_ERROR(&vPostData) = DISP_E_PARAMNOTFOUND;
	V_VT(&vHeaders) = VT_ERROR;
	V_ERROR(&vHeaders) = DISP_E_PARAMNOTFOUND;

	hresult = g_iwbapp->Navigate(
								bstr,
								&vFlags,			//Flags
								&vTargetFrameName,  //TargetFrameName
								&vPostData,			//PostData,
								&vHeaders);         // Headers,
IENavigateExit:
#ifndef UNICODE
	if( szWide )
	{
		GlobalFree( szWide );
		szWide = NULL;
	}
#endif

	if (NULL != hUrlMon)
		FreeLibrary(hUrlMon);

	if (NULL != bstr)
		SysFreeString( bstr );

	return( hresult );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\logon.cpp ===
#include "isignup.h"

typedef DWORD (WINAPI *WNETGETUSER)
        (LPCTSTR  lpName, LPTSTR  lpUserName,  LPDWORD  lpnLength);

typedef DWORD (WINAPI * WNETLOGON)
		(LPCTSTR lpProvider, HWND hwndOwner);

#ifdef WIN16
#define MB_SETFOREGROUND            0

#define NO_ERROR	ERROR_SUCCESS

//
// MessageId: ERROR_NO_NETWORK
//
// MessageText:
//
//  The network is not present or not started.
//
#define ERROR_NO_NETWORK                 1222L

//
// MessageId: ERROR_NOT_LOGGED_ON
//
// MessageText:
//
//  The operation being requested was not performed because the user
//  has not logged on to the network.
//  The specified service does not exist.
//
#define ERROR_NOT_LOGGED_ON              1245L

//
// MessageId: ERROR_NOT_CONNECTED
//
// MessageText:
//
//  This network connection does not exist.
//
#define ERROR_NOT_CONNECTED              2250L

#endif

#ifdef UNICODE
BOOL WINAPI AutoDialLogonW(HWND, LPCTSTR, DWORD, LPDWORD);
BOOL WINAPI AutoDialLogonA
(
    HWND    hwndParent,	
    LPCSTR  lpszEntry,
    DWORD   dwFlags,
    LPDWORD pdwRetCode
)
{
    TCHAR szEntry[RAS_MaxEntryName + 1];

    mbstowcs(szEntry, lpszEntry, lstrlenA(lpszEntry)+1);
    return AutoDialLogonW(hwndParent, szEntry, dwFlags, pdwRetCode);
}

BOOL WINAPI AutoDialLogonW
#else
BOOL WINAPI AutoDialLogonA
#endif
(
    HWND    hwndParent,	
    LPCTSTR lpszEntry,
    DWORD   dwFlags,
    LPDWORD pdwRetCode
)
{   
    DWORD dwRet;
    TCHAR szUser[80];
    DWORD size;
    HINSTANCE hLib;
    WNETLOGON lpfnWNetLogon;
    WNETGETUSER lpfnWNetGetUser;

    hLib = LoadLibrary(TEXT("mpr.dll"));
    if ((HINSTANCE)32 >= hLib)
    {
        return 0;
    }

#ifdef UNICODE
    lpfnWNetLogon = (WNETLOGON) GetProcAddress(hLib, "WNetLogonW");
    lpfnWNetGetUser = (WNETGETUSER) GetProcAddress(hLib, "WNetGetUserW");
#else
    lpfnWNetLogon = (WNETLOGON) GetProcAddress(hLib, "WNetLogonA");
    lpfnWNetGetUser = (WNETGETUSER) GetProcAddress(hLib, "WNetGetUserA");
#endif
	if (NULL == lpfnWNetLogon || NULL == lpfnWNetGetUser)
	{
		FreeLibrary(hLib);
		return 0;
	}

    size = sizeof(szUser);
    dwRet = lpfnWNetGetUser(NULL, szUser, &size);
    if (NO_ERROR != dwRet)
    {
        LPTSTR lpszErr;
        TCHAR szMsg[256];
        TCHAR szCaption[256];
        
        dwRet = GetLastError();

        LoadString(
                ghInstance,
                IDS_LOGONMESSAGE,
                szMsg,
                sizeof(szMsg));

        LoadString(
                ghInstance,
                IDS_LOGONCAPTION,
                szCaption,
                sizeof(szCaption));

        switch (dwRet)
        {
            case ERROR_NOT_LOGGED_ON:
                while (1)
                {
                    dwRet = lpfnWNetLogon(NULL, NULL);

                    if (WN_CANCEL != dwRet)
                    {
                        break;
                    }
                    if (MessageBox(
                            hwndParent,
                            szMsg,
                            szCaption,
                            MB_SETFOREGROUND | 
                            MB_ICONWARNING |
                            MB_RETRYCANCEL) == IDCANCEL)
                    {
                        break;
                    }
                }
                break;

            case ERROR_NO_NETWORK:
                lpszErr = TEXT("No Network");
                break;

            case ERROR_NOT_CONNECTED:
                lpszErr = TEXT("Not Connected");
                break;
            
            default:
                lpszErr = TEXT("Who knows?");
                break;
        }

        MessageBox(NULL, lpszErr, TEXT("WNetGetUser returned"), MB_OK);
    }

    FreeLibrary(hLib);

    *pdwRetCode = ERROR_SUCCESS;
    return FALSE;
}


DWORD SignupLogon(
    HWND hwndParent	
)
{   
    DWORD dwRet;
    TCHAR szUser[80];
    DWORD size;
    HINSTANCE hLib;
    WNETLOGON lpfnWNetLogon;
    WNETGETUSER lpfnWNetGetUser;

    hLib = LoadLibrary(TEXT("mpr.dll"));
    if ((HINSTANCE)32 >= hLib)
    {
        return GetLastError();
    }

#ifdef UNICODE
    lpfnWNetLogon = (WNETLOGON) GetProcAddress(hLib, "WNetLogonW");
    lpfnWNetGetUser = (WNETGETUSER) GetProcAddress(hLib, "WNetGetUserW");
#else
    lpfnWNetLogon = (WNETLOGON) GetProcAddress(hLib, "WNetLogonA");
    lpfnWNetGetUser = (WNETGETUSER) GetProcAddress(hLib, "WNetGetUserA");
#endif
	if (NULL == lpfnWNetLogon || NULL == lpfnWNetGetUser)
	{
		FreeLibrary(hLib);
		return ERROR_SUCCESS;
	}

    size = sizeof(szUser);
    dwRet = lpfnWNetGetUser(NULL, szUser, &size);
    if (NO_ERROR != dwRet)
    {
        TCHAR szMsg[256];

        dwRet = GetLastError();

        LoadString(
                ghInstance,
                IDS_SIGNUPLOGON,
                szMsg,
                sizeof(szMsg));

        if (ERROR_NOT_LOGGED_ON == dwRet)
        {
            while (1)
            {
                dwRet = lpfnWNetLogon(NULL, NULL);

                if (WN_CANCEL != dwRet)
                {
                    dwRet = ERROR_SUCCESS;
                    break;
                }
                if (MessageBox(
                        hwndParent,
                        szMsg,
                        cszAppName,
                        MB_SETFOREGROUND | 
                        MB_ICONWARNING |
                        MB_RETRYCANCEL) == IDCANCEL)
                {
                    dwRet = ERROR_CANCELLED;
                    break;
                }
            }
        }
    }

    FreeLibrary(hLib);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\isignup.h ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       isignup.h
//  Content:    This is the "main" include file for the internet signup "wizard".
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#ifndef ISIGNUP_H
#define ISIGNUP_H


#ifdef DEBUG

#define DebugOut(sz)    OutputDebugString(sz)

void _ISIGN32_Assert(LPCTSTR, unsigned);

#define ISIGN32_ASSERT(f)        \
    if (f)                  \
        {}                  \
    else                    \
        _ISIGN32_Assert(TEXT(__FILE__), __LINE__)

#else

#define DebugOut(sz)

#define ISIGN32_ASSERT(f)

#endif

#include <windows.h>

#ifdef WIN32
#include <regstr.h>
#endif

#ifdef WIN32
#include <ras.h>
#include <raserror.h>
//#include <rnaph.h>
#include "ras2.h"
#else
#include <rasc.h>
#include <raserr.h>
#endif        

#ifdef WIN32
#define EXPORT
#else
//typedef DWORD HRESULT;
#include <shellapi.h>
#include <ctype.h>
#include <win16def.h>
#define CharPrev(start, current) (((LPTSTR)(current)) - 1)
#define CharNext(current) (((LPTSTR)(current)) + 1)
#define LocalAlloc(flag, size)	MyLocalAlloc(flag, size)
#define LocalFree(lpv) MyLocalFree(lpv)
//#define ERROR_PATH_NOT_FOUND    ERROR_CANTOPEN
#define EXPORT _export
#endif

#include "icwunicd.h"
#include "..\inc\inetcfg.h"
#include "extfunc.h"
#include "rsrc.h"

#define WM_PROCESSISP WM_USER + 1 //used by IE OLE Automation

// 8/19/96 jmazner  Normandy #4571
#ifdef WIN32
// Note that bryanst and marcl have confirmed that this key will work for IE 3 and IE 4
#define IE_PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")

#define ICW20_PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE")

// Lowest IE we want to work with is IE 3,
//     which has major.minor.release.build version # > 4.70.0.1155
// (note that IE 2 has major.minor of 4.40)
//
// The HUMAN_READABLE string will be inserted into the IDS_IELOWVERSION string. Keep it in sync
// with the major.minor version numbers
#define IE_MINIMUM_VERSION_HUMAN_READABLE TEXT("3.0") 
#define IE_MINIMUM_MAJOR_VERSION (UINT) 4
#define IE_MINIMUM_MINOR_VERSION (UINT) 70
#define IE_MINIMUM_RELEASE_VERSION (UINT) 0
#define IE_MINIMUM_BUILD_VERSION (UINT) 1155
#define IE_MINIMUM_VERSIONMS (DWORD) ((IE_MINIMUM_MAJOR_VERSION << 16) | IE_MINIMUM_MINOR_VERSION)
#define IE_MINIMUM_VERSIONLS (DWORD) ((IE_MINIMUM_RELEASE_VERSION << 16) | IE_MINIMUM_BUILD_VERSION)

#define ICW20_MINIMUM_VERSION_HUMAN_READABLE TEXT("4.0") 
#define ICW20_MINIMUM_MAJOR_VERSION (UINT) 4
#define ICW20_MINIMUM_MINOR_VERSION (UINT) 72
#define ICW20_MINIMUM_RELEASE_VERSION (UINT) 0
#define ICW20_MINIMUM_BUILD_VERSION (UINT) 3012
#define ICW20_MINIMUM_VERSIONMS (DWORD) ((ICW20_MINIMUM_MAJOR_VERSION << 16) | ICW20_MINIMUM_MINOR_VERSION)
#define ICW20_MINIMUM_VERSIONLS (DWORD) ((ICW20_MINIMUM_RELEASE_VERSION << 16) | ICW20_MINIMUM_BUILD_VERSION)

#endif

#define ACCTMGR_PATHKEY TEXT("SOFTWARE\\Microsoft\\Internet Account Manager")
#define ACCTMGR_DLLPATH TEXT("DllPath")


#define MAX_URL     1024
//#define REGSTR_PATH_IEXPLORER           "Software\\Microsoft\\Internet Explorer"
//#define REGSTR_PATH_IE_MAIN             REGSTR_PATH_IEXPLORER "\\Main"

#define SIZEOF_TCHAR_BUFFER(buf)    ((sizeof(buf) / sizeof(TCHAR)))

typedef struct
{
    TCHAR          szEntryName[RAS_MaxEntryName+1];
    TCHAR          szUserName[UNLEN+1];
    TCHAR          szPassword[PWLEN+1];
    TCHAR          szScriptFile[_MAX_PATH+1];
    RASENTRY       RasEntry;
} ICONNECTION, FAR * LPICONNECTION;

 
extern DWORD ConfigureClient(
    HWND hwnd,
    LPCTSTR lpszFile,
    LPBOOL lpfNeedsRestart,
    LPBOOL fConnectiodCreated,
    BOOL fHookAutodial,
    LPTSTR szConnectoidName,
    DWORD dwConnectoidNameSize   
    );
extern DWORD ImportFile (
    LPCTSTR lpszImportFile,
    LPCTSTR lpszSection,
    LPCTSTR lpszOutputFile);
extern DWORD ImportConnection (
    LPCTSTR szFileName,
    LPICONNECTION lpConnection);
extern DWORD ImportClientInfo (
    LPCTSTR lpszFileName,
    LPINETCLIENTINFO lpClientInfo);
extern DWORD ImportCustomInfo (
    LPCTSTR lpszImportFile,
    LPTSTR lpszExecutable,
    DWORD cbExecutable,
    LPTSTR lpszArgument,
    DWORD cbArgument);
extern DWORD ImportCustomFile (LPCTSTR lpszFileName);
extern DWORD ImportFavorites (LPCTSTR lpszFileName);
extern DWORD ImportBrandingInfo (LPCTSTR pszIns, LPCTSTR lpszConnectoidName);
#ifdef WIN32
extern DWORD CallSBSConfig(HWND hwnd, LPCTSTR lpszINSFile);
#endif
//extern DWORD ImportProxySettings(LPCTSTR lpszFile);
extern BOOL WantsExchangeInstalled(LPCTSTR lpszFile);

extern BOOL ProcessISP(HWND hwnd, LPCTSTR lpszFile);


extern BOOL WarningMsg(HWND hwnd, UINT uId);
extern void ErrorMsg(HWND hwnd, UINT uId);
extern void ErrorMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg);
extern void InfoMsg(HWND hwnd, UINT uId);
extern BOOL PromptRestart(HWND hwnd);
extern BOOL PromptRestartNow(HWND hwnd);
extern VOID CenterWindow(HWND hwndChild, HWND hwndParent);

// 8/16/96 jmazner  Normandy #4593   This is what puts up the huge background "screen o death"
//extern HWND SplashInit(HWND hwnd);

extern HWND ProgressInit(HWND hwnd);

extern DWORD SignupLogon(HWND hwndParent);

extern TCHAR FAR cszWndClassName[];
extern TCHAR FAR cszAppName[];
extern HINSTANCE ghInstance;

#ifdef WIN16

CHAR*  GetPassword();

#else

TCHAR* GetPassword();
BOOL  IsRASReady();

#endif

HWND GetHwndMain();

BOOL IsCurrentlyProcessingISP();

BOOL NeedBackupSecurity();

extern HRESULT WINAPI StatusMessageCallback(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize);
extern HRESULT LoadDialErrorString(HRESULT hrIN,LPTSTR lpszBuff, DWORD dwBufferSize);

#ifdef WIN16
extern LPVOID MyLocalAlloc(DWORD flag, DWORD size);
extern LPVOID MyLocalFree(LPVOID lpv);
#endif

int DDEInit(HINSTANCE);
void DDEClose(void);
int OpenURL(LPCTSTR);

#if !defined(WIN16)
extern BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry);
extern DWORD ConfigRasEntryDevice( LPRASENTRY lpRasEntry );

extern BOOL IsNT(void);

inline BOOL IsNT(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}

#endif //!win16

typedef enum
{
    UNKNOWN_FILE,
    INS_FILE,
    ISP_FILE,
    HTML_FILE
}  INET_FILETYPE;


#define HARDCODED_IEAK_ISP_FILENAME TEXT("signup.isp")

#endif /* ISIGNUP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\isignup.cpp ===
/*----------------------------------------------------------------------------
    isignup.cpp

    This is the "main" file for the internet signup "wizard".

    Copyright (C) 1995-96 Microsoft Corporation
    All right reserved

  Authors:
    MMaclin        Mark Maclin

  History:
    Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
    8/2/96    ChrisK    Ported to Win32
    9/27/96    jmazner    Modified to use OLE Automation to control IE
----------------------------------------------------------------------------*/
#include "isignup.h"
#include "icw.h"

#ifdef WIN32
#include "icwacct.h"
#include "isignole.h"
#include "enumodem.h"
#include "..\inc\semaphor.h"
#include <shlobj.h>
#include <math.h>
#include <stdlib.h>
#endif

#include "..\inc\icwdial.h"

#ifndef WIN32
#include <string.h>
#include <direct.h>
#include <time.h>
#include <io.h>


DWORD GetFullPathName(
    LPCTSTR lpFileName,
    DWORD nBufferLength,
    LPTSTR lpBuffer,
    LPTSTR FAR *lpFilePart);

BOOL SetCurrentDirectory(
    LPCTSTR  lpPathName);

BOOL ShutDownIEDial(HWND hWnd);

#endif


const TCHAR g_szICWCONN1[] = TEXT("ICWCONN1.EXE");
const TCHAR g_szRestoreDesktop[] = TEXT("/restoredesktop");

#ifdef WIN32
#define SETUPSTACK      1
#endif

// Signup Entry Flags

#define SEF_RUNONCE            0x0001
#define SEF_PROGRESS           0x0002
#define SEF_SPLASH             0x0004

// 3/14/97 jmazner TEMP
// temporary hack until we can work with IE for a better solution
#define SEF_NOSECURITYBACKUP   0x0008


// Signup eXit Flags

#define SXF_RESTOREAUTODIAL    0x0001
#define SXF_RUNEXECUTABLE      0x0002
#define SXF_WAITEXECUTABLE     0x0004
#define SXF_KEEPCONNECTION     0x0008
#define SXF_KEEPBROWSER        0x0010
#define SXF_RESTOREDEFCHECK    0x0020
// 8/21/96 jmazner Normandy 4592
#define SXF_RESTOREIEWINDOWPLACEMENT    0x0040

extern void Dprintf(LPCSTR pcsz, ...);

/*** moved to isignup.h
typedef enum
{
    UNKNOWN_FILE,
    INS_FILE,
    ISP_FILE,
    HTML_FILE
}  INET_FILETYPE;
*/

#define WAIT_TIME   20   // time in seconds to wait after exec'ing browser
            // before checking if it has gone away.

#define MAX_RETRIES 3 // number of times the dialer with attempt automatic redials

#pragma data_seg(".rdata")

static const TCHAR szBrowserClass1[] = TEXT("IExplorer_Frame");
static const TCHAR szBrowserClassIE4[] = TEXT("CabinetWClass");
static const TCHAR szBrowserClass2[] = TEXT("Internet Explorer_Frame");
static const TCHAR szBrowserClass3[] = TEXT("IEFrame");

static const TCHAR cszURLSection[] = TEXT("URL");
static const TCHAR cszSignupURL[] =  TEXT("Signup");

static const TCHAR cszExtINS[] = TEXT(".ins");
static const TCHAR cszExtISP[] = TEXT(".isp");
static const TCHAR cszExtHTM[] = TEXT(".htm");
static const TCHAR cszExtHTML[] = TEXT(".html");

static const TCHAR cszEntrySection[]     = TEXT("Entry");
static const TCHAR cszEntryName[]    = TEXT("Entry_Name");
static const TCHAR cszCancel[]           = TEXT("Cancel");
static const TCHAR cszHangup[]           = TEXT("Hangup");
static const TCHAR cszRun[]              = TEXT("Run");
static const TCHAR cszArgument[]         = TEXT("Argument");

static const TCHAR cszConnect2[]         = TEXT("icwconn2.exe");
static const TCHAR cszClientSetupSection[]  = TEXT("ClientSetup");

static const TCHAR cszUserSection[]    = TEXT("User");
static const TCHAR cszRequiresLogon[]  = TEXT("Requires_Logon");

static const TCHAR cszCustomSection[]  = TEXT("Custom");
static const TCHAR cszKeepConnection[] = TEXT("Keep_Connection");
static const TCHAR cszKeepBrowser[]    = TEXT("Keep_Browser");

static const TCHAR cszBrandingSection[]  = TEXT("Branding");
static const TCHAR cszBrandingFlags[] = TEXT("Flags");
static const TCHAR cszBrandingServerless[] = TEXT("Serverless");

static const TCHAR cszHTTPS[] = TEXT("https:");
// code relies on these two being the same length
static const TCHAR cszHTTP[] = TEXT("http:");
static const TCHAR cszFILE[] = TEXT("file:");

#if defined(WIN16)
// "-d" disables the security warnings
static const TCHAR cszKioskMode[] = TEXT("-d -k ");
#else
static const CHAR cszKioskMode[] = "-k ";
#endif
static const TCHAR cszOpen[] = TEXT("open");
static const TCHAR cszBrowser[] = TEXT("iexplore.exe");
static const TCHAR szNull[] = TEXT("");

static const TCHAR cszYes[]           = TEXT("yes");
static const TCHAR cszNo[]            = TEXT("no");

// UNDONE: finish porting warnings disable
static const TCHAR cszDEFAULT_BROWSER_KEY[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
static const TCHAR cszDEFAULT_BROWSER_VALUE[] = TEXT("check_associations");
// 8/21/96 jmazner  Normandy #4592
static const TCHAR cszIEWINDOW_PLACEMENT[] = TEXT("Window_Placement");

// Registry keys which will contain News and Mail settings
//#define MAIL_KEY        "SOFTWARE\\Microsoft\\Internet Mail and News\\Mail"
//#define MAIL_POP3_KEY    "SOFTWARE\\Microsoft\\Internet Mail and News\\Mail\\POP3\\"
//#define MAIL_SMTP_KEY    "SOFTWARE\\Microsoft\\Internet Mail and News\\Mail\\SMTP\\"
//#define NEWS_KEY        "SOFTWARE\\Microsoft\\Internet Mail and News\\News"
//#define MAIL_NEWS_INPROC_SERVER32 "CLSID\\{89292102-4755-11cf-9DC2-00AA006C2B84}\\InProcServer32"
#define ICWSETTINGSPATH TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICWCOMPLETEDKEY TEXT("Completed")
#define ICWDESKTOPCHANGED TEXT("DesktopChanged")

//typedef HRESULT (WINAPI *PFNSETDEFAULTNEWSHANDLER)(void);

//
// TEMP TEMP TEMP TEMP TEMP
// 6/4/97 jmazner
// these typedefs live in icwacct.h, but we can't include icwacct.h in 16 bit builds
// just yet because the OLE stuff is all goofy.  So, for now, copy these in here to
// make 16 bit build correctly.
#ifdef WIN16
typedef enum
    {
    CONNECT_LAN = 0,
    CONNECT_MANUAL,
    CONNECT_RAS
    };

typedef struct tagCONNECTINFO
    {
    DWORD   cbSize;
    DWORD   type;
    TCHAR   szConnectoid[MAX_PATH];
    } CONNECTINFO;
#endif

typedef HRESULT (WINAPI *PFNCREATEACCOUNTSFROMFILEEX)(LPTSTR szFile, CONNECTINFO *pCI, DWORD dwFlags);


// These are the field names from an INS file that will
// determine the mail and news settings
//static const CHAR cszMailSection[]    = "Internet_Mail";
//static const CHAR cszEmailName[]    = "Email_Name";
//static const CHAR cszEmailAddress[] = "Email_Address";
//static const CHAR cszEntryName[]    = "Entry_Name";
//static const CHAR cszPOPServer[]    = "POP_Server";
//static const CHAR cszPOPServerPortNumber[]    = "POP_Server_Port_Number";
//static const CHAR cszPOPLogonName[]            = "POP_Logon_Name";
//static const CHAR cszPOPLogonPassword[]        = "POP_Logon_Password";
//static const CHAR cszSMTPServer[]            = "SMTP_Server";
//static const CHAR cszSMTPServerPortNumber[]    = "SMTP_Server_Port_Number";
//static const CHAR cszNewsSection[]            = "Internet_News";
//static const CHAR cszNNTPServer[]            = "NNTP_Server";
//static const CHAR cszNNTPServerPortNumber[]    = "NNTP_Server_Port_Number";
// 8/19/96 jmazner Normandy #4601
//static const CHAR cszNNTPLogonRequired[]    = "Logon_Required";
//static const CHAR cszNNTPLogonName[]        = "NNTP_Logon_Name";
//static const CHAR cszNNTPLogonPassword[]    = "NNTP_Logon_Password";
//static const CHAR cszUseMSInternetMail[]    = "Install_Mail";
//static const CHAR cszUseMSInternetNews[]    = "Install_News";

// These are the value names where the INS settings will be saved
// into the registry
/****
static const TCHAR cszMailSenderName[]        = TEXT("Sender Name");
static const TCHAR cszMailSenderEMail[]        = TEXT("Sender EMail");
static const TCHAR cszMailRASPhonebookEntry[]= TEXT("RAS Phonebook Entry");
static const TCHAR cszMailConnectionType[]    = TEXT("Connection Type");
static const TCHAR cszDefaultPOP3Server[]    = TEXT("Default POP3 Server");
static const TCHAR cszDefaultSMTPServer[]    = TEXT("Default SMTP Server");
static const TCHAR cszPOP3Account[]            = TEXT("Account");
static const TCHAR cszPOP3Password[]            = TEXT("Password");
static const TCHAR cszPOP3Port[]                = TEXT("Port");
static const TCHAR cszSMTPPort[]                = TEXT("Port");
static const TCHAR cszNNTPSenderName[]        = TEXT("Sender Name");
static const TCHAR cszNNTPSenderEMail[]        = TEXT("Sender EMail");
static const TCHAR cszNNTPDefaultServer[]    = TEXT("DefaultServer"); // NOTE: NO space between "Default" and "Server".
static const TCHAR cszNNTPAccountName[]        = TEXT("Account Name");
static const TCHAR cszNNTPPassword[]            = TEXT("Password");
static const TCHAR cszNNTPPort[]                = TEXT("Port");
static const TCHAR cszNNTPRasPhonebookEntry[]= TEXT("RAS Phonebook Entry");
static const TCHAR cszNNTPConnectionType[]    = TEXT("Connection Type");
****/

static const TCHAR arBase64[] = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U',
            'V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',
            'q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','='};

#pragma data_seg()

#define BRAND_FAVORITES 1
#define BRAND_STARTSEARCH 2
#define BRAND_TITLE 4
#define BRAND_BITMAPS 8
#define BRAND_MAIL 16
#define BRAND_NEWS 32

#define BRAND_DEFAULT (BRAND_FAVORITES | BRAND_TITLE | BRAND_BITMAPS)

//********* Start of Memory Map File for Share Data ************

#define SCF_SIGNUPCOMPLETED         0x00000001
#define SCF_SYSTEMCONFIGURED        0x00000002
#define SCF_BROWSERLAUNCHED         0x00000004
#define SCF_AUTODIALSAVED           0x00000008
#define SCF_AUTODIALENABLED         0x00000010
#define SCF_PROXYENABLED            0x00000020
#define SCF_LOGONREQUIRED           0x00000040

#if !defined(WIN16)

#define SCF_SAFESET                 0x00000080
#define SCF_NEEDBACKUPSECURITY      0x00000100
#define SCF_ISPPROCESSING           0x00000200
#define SCF_RASREADY                0x00000400
#define SCF_RECONNECTTHREADQUITED   0x00000800
#define SCF_HANGUPEXPECTED          0x00001000
#define SCF_ICWCOMPLETEDKEYRESETED  0x00002000

#endif

#define SCF_CANCELINSPROCESSED      0x00004000
#define SCF_HANGUPINSPROCESSED      0x00008000
#define SCF_SILENT                  0x00010000


typedef struct tagISign32Share
{
    DWORD   dwControlFlags;
    DWORD   dwExitFlags;
    DWORD   dwBrandFlags;
    
    TCHAR   szAutodialConnection[RAS_MaxEntryName + 1];
    TCHAR   szSignupConnection[RAS_MaxEntryName + 1];
    TCHAR   szPassword[PWLEN + 1];
    TCHAR   szCheckAssociations[20];

#if !defined(WIN16)

    TCHAR   szFile[MAX_PATH + 1];
    TCHAR   szISPFile[MAX_PATH + 1];
    HANDLE  hReconnectEvent;

#endif
    
    TCHAR   szRunExecutable[_MAX_PATH + 1];
    TCHAR   szRunArgument[_MAX_PATH + 1];
    
    BYTE    pbIEWindowPlacement[_MAX_PATH];
    DWORD   dwIEWindowPlacementSize;
    
    HWND    hwndMain;
    HWND    hwndBrowser;
    HWND    hwndLaunch;
    
} ISIGN32SHARE, *PISIGN32SHARE;

static PISIGN32SHARE pDynShare = NULL;

inline BOOL TestControlFlags(DWORD filter)
{
    return ((pDynShare->dwControlFlags & filter) != 0);
}

inline void SetControlFlags(DWORD filter)
{
    pDynShare->dwControlFlags |= filter;
}

inline void ClearControlFlags(DWORD filter)
{
    pDynShare->dwControlFlags &= (~filter);
}

inline BOOL TestExitFlags(DWORD filter)
{
    return (pDynShare->dwExitFlags & (filter)) != 0;
}

inline void SetExitFlags(DWORD filter)
{
    pDynShare->dwExitFlags |= (filter);
}
    
inline void ClearExitFlags(DWORD filter)
{
    pDynShare->dwExitFlags &= (~filter);
}

BOOL LibShareEntry(BOOL fInit)
{
    static TCHAR    szSharedMemName[] = TEXT("ISIGN32_SHAREMEMORY");
    static HANDLE   hSharedMem = 0;

    BOOL    retval = FALSE;
    
    if (fInit)
    {
        DWORD   dwErr = ERROR_SUCCESS;
        
        SetLastError(0);

        hSharedMem = CreateFileMapping(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            sizeof(ISIGN32SHARE),
            szSharedMemName);

        dwErr = GetLastError();
            
        switch (dwErr)
        {
        case ERROR_ALREADY_EXISTS:
        case ERROR_SUCCESS:
            pDynShare = (PISIGN32SHARE) MapViewOfFile(
                hSharedMem,
                FILE_MAP_WRITE,
                0,
                0,
                0);
            if (pDynShare != NULL)
            {
                if (dwErr == ERROR_SUCCESS)
                {
                    pDynShare->dwControlFlags = 0;
                    pDynShare->dwBrandFlags = BRAND_DEFAULT;
                    pDynShare->dwExitFlags = 0;

                    pDynShare->szAutodialConnection[0] = (TCHAR)0;
                    pDynShare->szCheckAssociations[0] = (TCHAR)0;

                    #if !defined(WIN16)
                    
                    pDynShare->szISPFile[0] = (TCHAR)0;
                    lstrcpyn(
                        pDynShare->szFile,
                        TEXT("uninited\0"),
                        SIZEOF_TCHAR_BUFFER(pDynShare->szFile));
                    pDynShare->hReconnectEvent = NULL;

                    SetControlFlags(SCF_NEEDBACKUPSECURITY);

                    #endif
                    
                    pDynShare->szSignupConnection[0] = (TCHAR)0;
                    pDynShare->szPassword[0] = (TCHAR)0;
                    pDynShare->szRunExecutable[0] = (TCHAR)0;
                    pDynShare->szRunArgument[0] = (TCHAR)0;

                    pDynShare->pbIEWindowPlacement[0] = (TCHAR)0;
                    pDynShare->dwIEWindowPlacementSize = 0;

                    pDynShare->hwndBrowser = NULL;
                    pDynShare->hwndMain = NULL;
                    pDynShare->hwndLaunch = NULL;
                }
                else    // dwErr == ERROR_ALREADY_EXISTS
                {

                }

                retval = TRUE;
                
            }
            else
            {
                Dprintf("MapViewOfFile failed: 0x%08lx", GetLastError());
                CloseHandle(hSharedMem);
                hSharedMem = 0;
                retval = FALSE;
            }
            break;
            
        default:
            Dprintf("CreateFileMapping failed: 0x08lx", dwErr);
            hSharedMem = 0;
            retval = FALSE;
            
        }
        
    }
    else
    {
        if (pDynShare)
        {
            UnmapViewOfFile(pDynShare);
            pDynShare = NULL;
        }

        if (hSharedMem)
        {
            CloseHandle(hSharedMem);
            hSharedMem = NULL;
        }

        retval = TRUE;
    }

    return retval;
    
}


//************ End of Memory Map File for Share Data ************



TCHAR FAR cszWndClassName[] = TEXT("Internet Signup\0");
TCHAR FAR cszAppName[MAX_PATH + 1] = TEXT("");
TCHAR FAR cszICWDIAL_DLL[] = TEXT("ICWDIAL.DLL\0");
CHAR  FAR cszICWDIAL_DIALDLG[] = "DialingDownloadDialog\0";
CHAR  FAR cszICWDIAL_ERRORDLG[] = "DialingErrorDialog\0";


HINSTANCE ghInstance;


#ifdef WIN32
// NOT shared
IWebBrowserApp FAR * g_iwbapp = NULL;
CDExplorerEvents * g_pMySink = NULL;
IConnectionPoint    *g_pCP = NULL;

//BOOL    g_bISPWaiting = FALSE;
TCHAR    g_szISPPath[MAX_URL + 1] = TEXT("not initialized\0");

// For single instance checking.
HANDLE g_hSemaphore = NULL;

//
// ChrisK Olympus 6198 6/10/97
//
#define REG_ZONE3_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3")
#define REG_ZONE1601_KEY TEXT("1601")
DWORD g_dwZone_1601 = 0;
BOOL  g_fReadZone = FALSE;

#endif

static DWORD dwConnectedTime = 0;

static BOOL ProcessCommandLine(LPCTSTR lpszCmdLine, LPDWORD lpdwFlags, LPTSTR lpszFile, DWORD cb);
//static INET_FILETYPE GetInetFileType(LPCTSTR lpszFile);
INET_FILETYPE GetInetFileType(LPCTSTR lpszFile);

static BOOL ProcessHTML(HWND hwnd, LPCTSTR lpszFile);
static BOOL ProcessINS(HWND hwnd, LPCTSTR lpszFile, BOOL fSignup);
//static BOOL ProcessISP(HWND hwnd, LPCTSTR lpszFile);
static DWORD SetRunOnce(LPCTSTR lpszFileName);
static BOOL GetURL(LPCTSTR lpszFile,LPCTSTR lpszKey, LPTSTR lpszURL, DWORD cb);
static void DoExit();
static HWND MainInit(void);
static void SaveAutoDial(void);
static void RestoreAutoDial(void);
static DWORD RunExecutable(BOOL bWait);
static DWORD CreateConnection(LPCTSTR lpszFile);
static DWORD KillConnection(void);
static BOOL ExecBrowser(HWND hwnd,  LPCTSTR lpszURL);
VOID RemoveQuotes (LPTSTR pCommandLine);            //MKarki -(5/1/97) Fix forBug #4049

#if !defined(WIN16)
// 8/19/96 jmazner Normandy #4571
static BOOL IEInstalled(void);
static BOOL GetAppVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS, LPTSTR lpszAppName);
// 8/21/96 jmazner Normandy #4592
static BOOL RestoreIEWindowPlacement( void );
static BOOL SaveIEWindowPlacement( void );
// 10-9-96 Chrisk 8782
static void InstallScripter(void);
// 10-15-96 ChrisK
static BOOL FGetSystemShutdownPrivledge();
// 10-17-96 ChrisK
static BOOL VerifyRasServicesRunning(HWND hwnd);

// 1/20/97 jmazner Normandy #9403
static BOOL SetStartUpCommand(LPTSTR lpCmd);
static void DeleteStartUpCommand( void );

// 1/28/97 jmazner Normandy #13454
static BOOL GetICWCompleted( DWORD *pdwCompleted );
static BOOL SetICWCompleted( DWORD dwCompleted );

// 2/19/97 jmazner Olympus #1106 -- SAM/SBS integration
TCHAR FAR cszSBSCFG_DLL[] = TEXT("SBSCFG.DLL\0");
CHAR  FAR cszSBSCFG_CONFIGURE[] = "Configure\0";
typedef DWORD (WINAPI * SBSCONFIGURE) (HWND hwnd, LPTSTR lpszINSFile, LPTSTR szConnectoidName);
SBSCONFIGURE  lpfnConfigure;

// 8/7/97 jmazner Olympus #6059
BOOL CreateSecurityPatchBackup( void );

// 3/11/97 jmazner Olympus #1545
VOID RestoreSecurityPatch( void );

#endif

static HWND FindBrowser(void);
static void KillBrowser(void);
static DWORD ImportBrandingInfo(LPCTSTR lpszFile);
static DWORD MassageFile(LPCTSTR lpszFile);
static HWND LaunchInit(HWND hwndParent);
static HRESULT DialConnection(LPCTSTR lpszFile);
static DWORD ImportMailAndNewsInfo(LPCTSTR lpszFile, BOOL fConnectPhone);
//static HRESULT WriteMailAndNewsKey(HKEY hKey, LPCTSTR lpszSection, LPCTSTR lpszValue, LPTSTR lpszBuff, DWORD dwBuffLen,LPCTSTR lpszSubKey, DWORD dwType, LPCTSTR lpszFile);
static HRESULT PreparePassword(LPTSTR szBuff, DWORD dwBuffLen);
//static BOOL FIsAthenaPresent();
static BOOL FTurnOffBrowserDefaultChecking();
static BOOL FRestoreBrowserDefaultChecking();
static HRESULT DeleteFileKindaLikeThisOne(LPCTSTR lpszFileName);

/*
#ifdef DEBUG
#define DebugOut(sz)    OutputDebugString(sz)
#else
#define DebugOut(sz)
#endif
*/

LRESULT FAR PASCAL WndProc (HWND, UINT, WPARAM, LPARAM) ;

#if !defined(ERROR_USERCANCEL)
#    define ERROR_USERCANCEL 32767
#endif
#if !defined(ERROR_USERBACK)
#    define ERROR_USERBACK 32766
#endif
#if !defined(ERROR_USERNEXT)
#    define ERROR_USERNEXT 32765
#endif

#define MAX_ERROR_MESSAGE 1024
typedef HRESULT (WINAPI*PFNDIALDLG)(PDIALDLGDATA pDD);
typedef HRESULT (WINAPI*PFNERRORDLG)(PERRORDLGDATA pED);


//
// WIN32 only function prototypes
//
#define DEVICENAMEKEY TEXT("DeviceName")
#define DEVICETYPEKEY TEXT("DeviceType")

static BOOL     DeleteUserDeviceSelection(LPTSTR szKey);
VOID   WINAPI   RasDial1Callback(HRASCONN,    UINT, RASCONNSTATE, DWORD, DWORD);
DWORD  WINAPI   StartNTReconnectThread (HRASCONN hrasconn);
DWORD           ConfigRasEntryDevice( LPRASENTRY lpRasEntry );
TCHAR           g_szDeviceName[RAS_MaxDeviceName + 1] = TEXT("\0"); //holds the user's modem choice when multiple
TCHAR           g_szDeviceType[RAS_MaxDeviceType + 1] = TEXT("\0"); // modems are installed
BOOL            IsSingleInstance(BOOL bProcessingINS);
void            ReleaseSingleInstance();

#define ISIGNUP_KEY TEXT("Software\\Microsoft\\ISIGNUP")

#if !defined(WIN16)
// There are other headers that contain copies of this structure (AUTODIAL).
// so if you change anything here, you have to go hunt down the other copies.
//
#pragma pack(2)
#define MAX_PROMO       64
#define MAX_OEMNAME     64
#define MAX_AREACODE    RAS_MaxAreaCode
#define MAX_EXCHANGE    8
#define MAX_VERSION_LEN 40

typedef struct tagGATHEREDINFO
{
    LCID    lcid;
    DWORD   dwOS;
    DWORD   dwMajorVersion;
    DWORD   dwMinorVersion;
    WORD    wArchitecture;
    TCHAR   szPromo[MAX_PROMO];
    TCHAR   szOEM[MAX_OEMNAME];
    TCHAR   szAreaCode[MAX_AREACODE+1];
    TCHAR   szExchange[MAX_EXCHANGE+1];
    DWORD   dwCountry;
    TCHAR   szSUVersion[MAX_VERSION_LEN];
    WORD    wState;
    BYTE    fType;
    BYTE    bMask;
    TCHAR   szISPFile[MAX_PATH+1];
    TCHAR   szAppDir[MAX_PATH+1];
} GATHEREDINFO, *PGATHEREDINFO;
#pragma pack()
#endif //!WIN16

#ifdef  DEBUG

void _ISIGN32_Assert(LPCTSTR strFile, unsigned uLine)
{
    TCHAR   buf[512];
    
    wsprintf(buf, TEXT("Assertion failed: %s, line %u"),
        strFile, uLine);
    
    OutputDebugString(buf);    
}

#endif


#ifdef WIN32
/*******************************************************************

    NAME:       DllEntryPoint

    SYNOPSIS:   Entry point for DLL.

    NOTES:

********************************************************************/
extern "C" BOOL APIENTRY LibMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL retval = TRUE;
    
    if( fdwReason == DLL_PROCESS_ATTACH )
    {
        ghInstance = hInstDll;
        LoadString(ghInstance, IDS_APP_TITLE, cszAppName, SIZEOF_TCHAR_BUFFER(cszAppName));

        retval = LibShareEntry(TRUE);
    }
    else if ( fdwReason == DLL_PROCESS_DETACH )
    {
        retval = LibShareEntry(FALSE);
    }

    return retval;
}

#else
/*******************************************************************

    NAME:       LibMain

    SYNOPSIS:   Used to trace NDI messages

    ENTRY:      hinst - handle of library instance
        wDataSeg - library data segment
        cbHeapSize - default heap size
        lpszCmdLine - command-line arguments

    EXIT:       returns 1

    NOTES:

********************************************************************/
int CALLBACK LibMain(
    HINSTANCE hinst,    /* handle of library instance   */
    WORD  wDataSeg,     /* library data segment */
    WORD  cbHeapSize,   /* default heap size    */
    LPTSTR  lpszCmdLine  /* command-line arguments   */
  )
{
    ghInstance = hinst;
    LoadString(ghInstance, IDS_APP_TITLE, cszAppName, SIZEOF_TCHAR_BUFFER(cszAppName));
    return LibShareEntry(TRUE);
}
#endif

int EXPORT WINAPI Signup
(
    HANDLE hInstance,
    HANDLE hPrevInstance,
    LPTSTR lpszCmdLine,
    int nCmdShow
)
{
    HWND        hwnd = NULL;
    BOOL        fRet;
    DWORD       dwFlags;
    TCHAR        szFileName[_MAX_PATH + 1];
    int         iRet = 0;
    INET_FILETYPE fileType;
    HWND hwndProgress = NULL;
    HKEY hKey = NULL;
    TCHAR szTemp[4];
    BOOL bISetAsSAFE = FALSE;

    if (!LoadInetFunctions(pDynShare->hwndMain))
    {
        return 0;
    }

    if (!ProcessCommandLine(lpszCmdLine, &dwFlags, szFileName, sizeof(szFileName)))
    {            
        if (0 == lstrlen(lpszCmdLine))
        {
            ErrorMsg(pDynShare->hwndMain, IDS_NOCMDLINE);
        }
        else
        {
            ErrorMsg1(pDynShare->hwndMain, IDS_INVALIDCMDLINE,
                lpszCmdLine ? lpszCmdLine : TEXT("\0"));
        }
        
        goto exit;
    }

    if (dwFlags & SEF_RUNONCE)
    { 
        SetControlFlags(SCF_SYSTEMCONFIGURED);
    }

    fileType = GetInetFileType(szFileName);
    switch (fileType)
    {
    case INS_FILE:
        DebugOut("ISIGNUP: Process INS\n");

        IsSingleInstance( TRUE );

        ProcessINS(pDynShare->hwndMain, szFileName, NULL != pDynShare->hwndMain);

        if (NULL == pDynShare->hwndMain)
        {
            DoExit();
        }
        goto exit;

    case HTML_FILE:
    case ISP_FILE:
    {
        if (!IsSingleInstance(FALSE))
            return FALSE;

        TCHAR szDrive [_MAX_DRIVE]    = TEXT("\0");
        TCHAR szDir   [_MAX_DIR]      = TEXT("\0");
        TCHAR szTemp  [_MAX_PATH + 1] = TEXT("\0");

        _tsplitpath(szFileName, szDrive, szDir, NULL, NULL);
        _tmakepath (szTemp, szDrive, szDir, HARDCODED_IEAK_ISP_FILENAME, NULL);

        //Examine the isp or htm file to see if they want to run the ICW
        if ((GetFileAttributes(szTemp) != 0xFFFFFFFF) && (UseICWForIEAK(szTemp)))
        {
            //they do .. let's do it.
            RunICWinIEAKMode(szTemp);
        }
        else //else RUN IEXPLORE Kiosk
        {
            // 8/19/96 jmazner Normandy #4571 and #10293
            // Check to ensure that the right version IE is installed before trying to exec it
            if ( !IEInstalled() )
            {
                ErrorMsg( hwnd, IDS_MISSINGIE );
                return(FALSE);
            }

            DWORD dwVerMS, dwVerLS;

            if( !GetAppVersion( &dwVerMS, &dwVerLS,IE_PATHKEY ) )
            {
                ErrorMsg( hwnd, IDS_MISSINGIE );
                return (FALSE);
            }

            if( !( (dwVerMS >= IE_MINIMUM_VERSIONMS) && (dwVerLS >= IE_MINIMUM_VERSIONLS) ) )
            {
                Dprintf("ISIGN32: user has IE version %d.%d.%d.%d; min ver is %d.%d.%d.%d\n",
                    HIWORD(dwVerMS), LOWORD(dwVerMS), HIWORD(dwVerLS), LOWORD(dwVerLS),
                    HIWORD(IE_MINIMUM_VERSIONMS),LOWORD(IE_MINIMUM_VERSIONMS),
                    HIWORD(IE_MINIMUM_VERSIONLS),LOWORD(IE_MINIMUM_VERSIONLS));
                ErrorMsg1( hwnd, IDS_IELOWVERSION, IE_MINIMUM_VERSION_HUMAN_READABLE );
                return(FALSE);
            }

            // 8/21/96  jmazner Normandy #4592
           
            if( !TestControlFlags(SCF_BROWSERLAUNCHED) )
            {
                if ( SaveIEWindowPlacement() )
                {
                    SetExitFlags(SXF_RESTOREIEWINDOWPLACEMENT);
                }
            }

            // check to see if we are the first window
            if (NULL == pDynShare->hwndMain)
            {
                DebugOut("ISIGNUP: First Window\n");

                hwnd = pDynShare->hwndMain = MainInit(); 
                
                if (dwFlags & SEF_SPLASH)
                {
                    pDynShare->hwndLaunch = LaunchInit(NULL); 
                }
                if (dwFlags & SEF_PROGRESS)
                {
                    // 8/16/96 jmazner Normandy #4593  pass NULL as ProgressInit's parent window
                    hwndProgress = ProgressInit(NULL);
                }
            }

            // 3/11/97 jmazner Olympus #1545
    // -------------------------------------------------------------------------
    // The entire section between here and the #endif was added to fix a security
    // hole in IE3.01.  The problem was based around .INS files being marked as
    // safe when in fact they could be used to launch any application if you knew
    // the right incantation, and someone figured it out.
    //
    //
            if (FALSE == TestControlFlags(SCF_SAFESET))
            {
    #define ISIGNUP_PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ISIGNUP.EXE")
                hKey = NULL;
                //szPath[0] = '\0';
                //hSecureRegFile = INVALID_HANDLE_VALUE;

                Dprintf("ISIGN32: Adjusting EditFlags settings\n");

                //
                // ChrisK Olympus 6198 6/10/97
                // Allow HTML form submissions from ICW
                //
                if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,REG_ZONE3_KEY,&hKey))
                {
                    DWORD dwZoneData;
                    DWORD dwType;
                    DWORD dwSize;
                    g_dwZone_1601 = 0;
                    dwSize = sizeof(g_dwZone_1601);
                    dwType = 0;
                    //
                    // Read current setting for zone3 1601
                    //
                    if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                        REG_ZONE1601_KEY,
                                                        NULL,
                                                        &dwType,
                                                        (LPBYTE)&g_dwZone_1601,
                                                        &dwSize))
                    {
                        DebugOut("ISIGN32: Read zone settings succesfully.\n");
                        g_fReadZone = TRUE;
                    }
                    else
                    {
                        DebugOut("ISIGN32: Read zone settings failed.\n");
                    }
                    RegCloseKey(hKey);
                    hKey = NULL;
                }

                //
                // 8/7/97    jmazner Olympus #6059
                // Due to the way IE 4 shell deals with RunOnce processing,
                // don't add any thing to RunOnce until the browser is
                // completely initialized (we get a DISPID_NAVIGATECOMPLETE event.)
                //
                if (!(SEF_NOSECURITYBACKUP & dwFlags))
                {
                    SetControlFlags(SCF_NEEDBACKUPSECURITY);
                }
                else
                {
                    ClearControlFlags(SCF_NEEDBACKUPSECURITY);
                } 

                // Fix security hole for malious .isp/.ins file combinations
                BYTE szBytes[4];
                szBytes[0] = (BYTE)0;
                szBytes[1] = (BYTE)0;
                szBytes[2] = (BYTE)1;
                szBytes[3] = (BYTE)0;
                // Mark various registry entries as safe.
                if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT("x-internet-signup"),&hKey))
                {
                    RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szBytes[0],(DWORD)4);
                    RegCloseKey(hKey);
                    hKey = NULL;
                }
                if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT(".ins"),&hKey))
                {
                    RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szBytes[0],(DWORD)4);
                    RegCloseKey(hKey);
                    hKey = NULL;
                }
                if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT(".isp"),&hKey))
                {
                    RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szBytes[0],(DWORD)4);
                    RegCloseKey(hKey);
                    hKey = NULL;
                }
                bISetAsSAFE=TRUE;

                SetControlFlags(SCF_SAFESET); 

                //
                // ChrisK Olympus 6198 6/10/97
                // Allow HTML form submissions from ICW
                //
                if (g_fReadZone &&
                    ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,REG_ZONE3_KEY,&hKey))
                {
                    DWORD dwZoneData;

                    //
                    // Set value for zone to 0, therefore opening security window
                    //
                    dwZoneData = 0;
                    RegSetValueEx(hKey,
                                    REG_ZONE1601_KEY,
                                    NULL,
                                    REG_DWORD,
                                    (LPBYTE)&dwZoneData,
                                    sizeof(dwZoneData));
                    RegCloseKey(hKey);
                    hKey = NULL;
                }
            }
    //EndOfSecurityHandling:

            // jmazner 11/5/96 Normandy #8717
            // save autodial and clear out proxy _before_ bringing up the
            // IE instance.
            SaveAutoDial();
            SetExitFlags(SXF_RESTOREAUTODIAL);

            if (HTML_FILE == fileType)
            {
                DebugOut("ISIGNUP: Process HTML\n");
                
                fRet = ProcessHTML(pDynShare->hwndMain, szFileName);
            }
            else
            {
                DebugOut("ISIGNUP: Process ISP\n");

                if (TestControlFlags(SCF_ISPPROCESSING))
                {
                    SetForegroundWindow(pDynShare->hwndMain);
                    ReleaseSingleInstance();
                    return FALSE;
                }
                else
                { 
                    SetControlFlags(SCF_ISPPROCESSING);
                }

                fRet = ProcessISP(pDynShare->hwndMain, szFileName);
                
                SetControlFlags(SCF_ISPPROCESSING);
                
            }
        }//end else RUN IEXPLORE Kiosk
        break;
    }
    default:
        
        if (IsSingleInstance(FALSE))
        {
            ErrorMsg1(pDynShare->hwndMain, IDS_INVALIDFILETYPE, szFileName);
        }
        if (NULL != pDynShare->hwndMain)
        {
            PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
        }
        
        break;
    }

    // if we are the first window
    if ((hwnd == pDynShare->hwndMain) && (NULL != hwnd))
    {
        if (fRet)
        {
            MSG   msg;

            SetTimer(hwnd, 0, 1000, NULL);

            DebugOut("ISIGNUP: Message loop\n");

            while (GetMessage (&msg, NULL, 0, 0))
            {
                TranslateMessage (&msg) ;
                DispatchMessage  (&msg) ;
            }
            iRet = (int)msg.wParam ;
        }

        DoExit();

        if (NULL != hwndProgress)
        {
            DestroyWindow(hwndProgress);
            hwndProgress = NULL;
        }

        if (NULL != pDynShare->hwndLaunch)
        {
            DestroyWindow(pDynShare->hwndLaunch);
            pDynShare->hwndLaunch = NULL;
        }
        
        if (pDynShare->hwndMain)
        {
            DeleteUserDeviceSelection(DEVICENAMEKEY);
            DeleteUserDeviceSelection(DEVICETYPEKEY);
        }

        pDynShare->hwndMain = NULL;
         

    }

exit:

    // 3/11/97    jmazner    Olympus #1545
    if (TRUE == bISetAsSAFE)
    {
        RestoreSecurityPatch();
        ClearControlFlags(SCF_SAFESET); 
    }
    UnloadInetFunctions();
    ReleaseSingleInstance();
    return iRet;
}

HWND MainInit()
{
    HWND        hwnd ;
    WNDCLASS    wndclass ;

    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.lpfnWndProc   = WndProc ;
    wndclass.cbClsExtra    = 0 ;
    wndclass.cbWndExtra    = 0 ;
    wndclass.hInstance     = ghInstance ;
    wndclass.hIcon         = LoadIcon (ghInstance, TEXT("ICO_APP")) ;
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
    wndclass.hbrBackground = (HBRUSH)GetStockObject (WHITE_BRUSH) ;
    wndclass.lpszMenuName  = NULL ;
    wndclass.lpszClassName = cszWndClassName;

    RegisterClass (&wndclass) ;

    hwnd = CreateWindow (cszWndClassName,       // window class name
          cszAppName,              // window caption
          WS_POPUP,                // window style
          CW_USEDEFAULT,           // initial x position
          CW_USEDEFAULT,           // initial y position
          CW_USEDEFAULT,           // initial x size
          CW_USEDEFAULT,           // initial y size
          NULL,                    // parent window handle
          NULL,                    // window menu handle
          ghInstance,              // program instance handle
          NULL) ;                  // creation parameters

    return hwnd;
}

LRESULT EXPORT FAR PASCAL WndProc (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
#ifdef WIN32
    case WM_PROCESSISP:
        DebugOut("ISIGNUP: Message loop got WM_PROCESSISP");

        if (TestControlFlags(SCF_ISPPROCESSING))
        {
            DebugOut("ISIGNUP: Received another WM_PROCESSISP message with gbCurrentlyProcessingISP = TRUE\r\n");

            SetForegroundWindow(pDynShare->hwndMain);
            // that's it, don't do anything else!
        }
        else
        { 
            SetControlFlags(SCF_ISPPROCESSING);
            
            if ( !ProcessISP(pDynShare->hwndMain, g_szISPPath) )
            {
                PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
            }
        }

        break;
#endif
    case WM_TIMER:
        {
            
        HWND hwndTemp = FindBrowser();

        if (NULL == hwndTemp)
        {
            
            if (!TestControlFlags(SCF_SIGNUPCOMPLETED))
            {
                ++dwConnectedTime;
 
                if (pDynShare->hwndBrowser != NULL)
                {
                    // browser went away
                    KillTimer(hwnd, 0);
                    KillConnection();
                    InfoMsg(hwnd, IDS_BROWSERTERMINATED);
                    PostQuitMessage(0);
                }
                else if (dwConnectedTime > WAIT_TIME)
                {
                    KillTimer(hwnd, 0);

                    if (NULL != pDynShare->hwndLaunch)
                    {
                        ShowWindow(pDynShare->hwndLaunch, SW_HIDE);
                    }
                    InfoMsg(hwnd, IDS_BROWSERNEVERFOUND);
                    PostQuitMessage(0);
                }
            }
        }
        else
        {
            
#ifdef WIN32 // don't do this with OLE automation; we're already full screen, and this causes flicker
            //if (NULL == hwndBrowser)
            //{
            //first time browser has been detected
            //    ShowWindow(hwndTemp, SW_MAXIMIZE);
            //}
            
#endif
  
            if ((NULL != pDynShare->hwndLaunch) && IsWindowVisible(hwndTemp))
            {
                ShowWindow(pDynShare->hwndLaunch, SW_HIDE);
            }
        }
        pDynShare->hwndBrowser = hwndTemp;         
        }
        break;

    case WM_DESTROY:
        
#if !defined(WIN16)
 
        if (pDynShare->hReconnectEvent)
        {
            DebugOut("ISIGN32: Set event to end reconnect thread.\r\n"); 

            SetControlFlags(SCF_RECONNECTTHREADQUITED);
            SetEvent(pDynShare->hReconnectEvent);
            CloseHandle(pDynShare->hReconnectEvent);
            pDynShare->hReconnectEvent = NULL;
        }
#endif

        PostQuitMessage(0);
        return 0 ;
    }

    return DefWindowProc (hwnd, message, wParam, lParam) ;
}

void DoExit(void)
{

    if (TestExitFlags(SXF_RESTOREDEFCHECK))
    {
        // restore IE check for default browser
        FRestoreBrowserDefaultChecking();
    }

    if (!TestExitFlags(SXF_KEEPCONNECTION))
    {
        // make sure the connection is closed
        KillConnection();
    }

    if (!TestExitFlags(SXF_KEEPBROWSER))
    {
        // make sure the browser is closed
        KillBrowser();
    }

    if (TestExitFlags(SXF_RESTOREAUTODIAL))
    {
        // restore original autodial settings
        RestoreAutoDial();
    }

#if !defined(WIN16)
    // 8/21/96  jmazner Normandy #4592
    if ( TestExitFlags( SXF_RESTOREIEWINDOWPLACEMENT ))
    {
        RestoreIEWindowPlacement();
    }
#endif

    if (TestExitFlags(SXF_RUNEXECUTABLE))
    {
        BOOL fWait;

        fWait = TestExitFlags(SXF_WAITEXECUTABLE);

        if (RunExecutable(fWait) != ERROR_SUCCESS)
        {
            // clean up left overs
            if (TestExitFlags(SXF_KEEPCONNECTION))
            {
                // make sure the connection is closed
                KillConnection();
            }

            if (TestExitFlags(SXF_KEEPBROWSER))
            {
                // make sure the browser is closed
                KillBrowser();
            }
             
            ErrorMsg1(NULL, IDS_EXECFAILED, pDynShare->szRunExecutable);
            
            return;
        }
    }

}


BOOL HasPrefix(LPCTSTR lpszURL)
{
    TCHAR szTemp[sizeof(cszHTTPS)];

    //
    // Check is the prefix is https
    //
    lstrcpyn(szTemp, lpszURL, lstrlen(cszHTTPS) + 1);
    if (lstrcmp(szTemp, cszHTTPS) == 0)
        return TRUE;
    else
    {
        TCHAR szTemp[sizeof(cszHTTP)];
        lstrcpyn(szTemp, lpszURL, lstrlen(cszHTTP) + 1);
        return ((lstrcmp(szTemp, cszHTTP) == 0) || (lstrcmp(szTemp, cszFILE) == 0));
    }
}


#ifdef WIN32
DWORD FixUpLocalURL(LPCTSTR lpszURL, LPTSTR lpszFullURL, DWORD cb)
{
    TCHAR szLong[MAX_URL];
    TCHAR szShort[MAX_URL];
    DWORD dwSize;

    if (GetFullPathName(
            lpszURL,
            MAX_URL,
            szLong,
            NULL) != 0)
    {
        if (GetShortPathName(
                szLong,
                szShort,
                sizeof(szShort)) != 0)
            {
            dwSize = sizeof(cszFILE) + lstrlen(szShort);

            if (dwSize < cb)
            {
                lpszFullURL[0] = '\0';
// Do not prepend file: for local files
// IE3.0 hack for bug :MSN Systems Bugs #9280
//                lstrcpy(lpszFullURL, cszFILE);
                lstrcat(lpszFullURL, szShort);
                return dwSize;
            }
        }
    }
    return 0;
}
#else
DWORD FixUpLocalURL(LPCTSTR lpszURL, LPTSTR lpszFullURL, DWORD cb)
{
    TCHAR szPath[MAX_URL];
    DWORD dwSize;

    if (GetFullPathName(
            lpszURL,
            MAX_URL,
            szPath,
            NULL) != 0)
    {
        dwSize = sizeof(cszFILE) + lstrlen(szPath);

        if (dwSize < cb)
        {
            lstrcpy(lpszFullURL, cszFILE);
            lstrcat(lpszFullURL, szPath);
            return dwSize;
        }
    }
    return 0;
}
#endif



DWORD FixUpURL(LPCTSTR lpszURL, LPTSTR lpszFullURL, DWORD cb)
{
    DWORD dwSize;

    if (HasPrefix(lpszURL))
    {
    dwSize = lstrlen(lpszURL);

    if (dwSize < cb)
    {
        lstrcpyn(lpszFullURL, lpszURL, (int)cb);
        return dwSize;
    }
    else
    {
        return 0;
    }
    }
    else
    {
    return (FixUpLocalURL(lpszURL, lpszFullURL, cb));
    }
}


BOOL GetURL(LPCTSTR lpszFile, LPCTSTR lpszKey, LPTSTR lpszURL, DWORD cb)
{
    return (GetPrivateProfileString(cszURLSection,
                  lpszKey,
                  szNull,
                  lpszURL,
                  (int)cb,
                  lpszFile) != 0);
}

LPTSTR mystrrchr(LPCTSTR lpString, TCHAR ch)
{
    LPCTSTR lpTemp = lpString;
    LPTSTR lpLast = NULL;

    while (*lpTemp)
    {
    if (*lpTemp == ch)
    {
        lpLast = (LPTSTR)lpTemp;
    }
    lpTemp = CharNext(lpTemp);
    }
    return lpLast;
}

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//    Function    CopyUntil
//
//    Synopsis    Copy from source until destination until running out of source
//                or until the next character of the source is the chend character
//
//    Arguments    dest - buffer to recieve characters
//                src - source buffer
//                lpdwLen - length of dest buffer
//                chend - the terminating character
//
//    Returns        FALSE - ran out of room in dest buffer
//
//    Histroy        10/25/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL CopyUntil(LPTSTR *dest, LPTSTR *src, LPDWORD lpdwLen, TCHAR chend)
{
    while (('\0' != **src) && (chend != **src) && (0 != *lpdwLen))
    {
        **dest = **src;
        (*lpdwLen)--;
        (*dest)++;
        (*src)++;
    }
    return (0 != *lpdwLen);
}

//+----------------------------------------------------------------------------
//    Function    ConvertToLongFilename
//
//    Synopsis    convert a file to the full long file name
//                ie. c:\progra~1\icw-in~1\isignup.exe becomes
//                c:\program files\icw-internet connection wizard\isignup.exe
//
//    Arguments    szOut - output buffer
//                szIn - filename to be converted
//                dwSize - size of the output buffer
//
//    Returns        TRUE - success
//
//    History        10/25/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL ConvertToLongFilename(LPTSTR szOut, LPTSTR szIn, DWORD dwSize)
{
    BOOL bRC = FALSE;
    LPTSTR pCur = szIn;
    LPTSTR pCurOut = szOut;
    LPTSTR pCurOutFilename = NULL;
    WIN32_FIND_DATA fd;
    DWORD dwSizeTemp;
    LPTSTR pTemp = NULL;

    ZeroMemory(pCurOut,dwSize);

    //
    // Validate parameters
    //
    if (NULL != pCurOut && NULL != pCur && 0 != dwSize)
    {

        //
        // Copy drive letter
        //
        if (!CopyUntil(&pCurOut,&pCur,&dwSize,'\\'))
            goto ConvertToLongFilenameExit;
        pCurOut[0] = '\\';
        dwSize--;
        pCur++;
        pCurOut++;
        pCurOutFilename = pCurOut;

        while (*pCur)
        {
            //
            // Copy over possibly short name
            //
            pCurOut = pCurOutFilename;
            dwSizeTemp = dwSize;
            if (!CopyUntil(&pCurOut,&pCur,&dwSize,'\\'))
                goto ConvertToLongFilenameExit;

            ZeroMemory(&fd, sizeof(fd));
            //
            // Get long filename
            //
            if (INVALID_HANDLE_VALUE != FindFirstFile(szOut,&fd))
            {
                //
                // Replace short filename with long filename
                //
                dwSize = dwSizeTemp;
                pTemp = &(fd.cFileName[0]);
                if (!CopyUntil(&pCurOutFilename,&pTemp,&dwSize,'\0'))
                    goto ConvertToLongFilenameExit;
                if (*pCur)
                {
                    //
                    // If there is another section then we just copied a directory
                    // name.  Append a \ character;
                    //
                    pTemp = (LPTSTR)memcpy(TEXT("\\X"),TEXT("\\X"),0);
                    if (!CopyUntil(&pCurOutFilename,&pTemp,&dwSize,'X'))
                        goto ConvertToLongFilenameExit;
                    pCur++;
                }
            }
            else
            {
                break;
            }
        }
        //
        // Did we get to the end (TRUE) or fail before that (FALSE)?
        //

        bRC = ('\0' == *pCur);
    }
ConvertToLongFilenameExit:
    return bRC;
}
#endif //!WIN16

INET_FILETYPE GetInetFileType(LPCTSTR lpszFile)
{
    LPTSTR lpszExt;
    INET_FILETYPE ft = UNKNOWN_FILE;

    lpszExt = mystrrchr(lpszFile, '.');
    if (NULL != lpszExt)
    {
    if (!lstrcmpi(lpszExt, cszExtINS))
    {
        ft = INS_FILE;
    }
    else if (!lstrcmpi(lpszExt, cszExtISP))
    {
        ft = ISP_FILE;
    }
    else if (!lstrcmpi(lpszExt, cszExtHTM))
    {
        ft = HTML_FILE;
    }
    else if (!lstrcmpi(lpszExt, cszExtHTML))
    {
        ft = HTML_FILE;
    }
    }

    return ft;
}

#ifdef SETUPSTACK
DWORD SetRunOnce(LPCTSTR lpszFileName)
{
    TCHAR szTemp[MAX_PATH + MAX_PATH + 1];
    TCHAR szTemp2[MAX_PATH + 1];
    DWORD dwRet = ERROR_CANTREAD;
    HKEY hKey;
    LPTSTR lpszFilePart;


    if (GetModuleFileName(NULL,szTemp2,sizeof(szTemp2)) != 0)
    {
        //
        // Will not convert the ShortPathName into LongPathName even in
        // case of NT/Win-95 as START.EXE parses long file names incorrectly
        // on NT (short path names will work fine from Win-95's RUNONCE registry
        // entry too. MKarki - Fix for Bug #346(OLYMPUS) 4/21/97
        //
#if 0   //!defined(WIN16)
        // szTemp2 contains the module name in short format
        ConvertToLongFilename(szTemp,szTemp2,MAX_PATH);
        // add quotes
        wsprintf(szTemp2,TEXT("\"%s\""),szTemp);
        // copy back into szTemp
        lstrcpy(szTemp,szTemp2);
#else
        GetShortPathName (szTemp2, szTemp, sizeof (szTemp));
          //lstrcpy(szTemp,szTemp2);
#endif

        // Determine Version
        OSVERSIONINFO osvi;
        ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
         if (!GetVersionEx(&osvi))
        {
            ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
        }

        // 1/20/96 jmazner Normandy #9403
        // For NT only, use the startup menu
        if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
        {
            // 3/14/97 jmazner TEMP
            // temporary hack until we can work with IE for a better solution
            //lstrcat(szTemp, " -r ");

            //
            // adding a -b switch so that when we start again we
            // know that we are starting of a batch file
            // MKarki (5/1/97) -Fix for Bug #4049
            //
            lstrcat(szTemp, TEXT(" -b -r -h "));

            //
            // adding extra quote at the front and end of file
            // as we dont want start.exe to parse the filename
            // MKarki (5/1/97) -Fix for Bug #4049
            //
            lstrcat (szTemp,TEXT("\""));
            lstrcat(szTemp, lpszFileName);
            lstrcat (szTemp,TEXT("\""));
            SetStartUpCommand( szTemp );
        }
        else
        {
            //
            // 3/14/97 jmazner TEMP
            // temporary hack until we can work with IE for a better solution
            //
            // 8/8/97 jmazner Olympus #6059
            // Well, we have a somewhat better solution.  The problem here was that
            // isignup without the -h sticks the backup security into the RunOnce key.
            // But if Isignup itself was started from a RunOnce entry, there was a
            // chance that RunOnce would also then execute the backup plan.  For 6059
            // the backup plan RunOnce entry has been defered, so it's okay to get
            // rid of the -h now
            //
            lstrcat(szTemp, TEXT(" -r "));
            //lstrcat(szTemp, TEXT(" -r -h "));
            lstrcat(szTemp, lpszFileName);

            dwRet = RegCreateKey(
                HKEY_LOCAL_MACHINE,
                REGSTR_PATH_RUNONCE,
                &hKey);

            if (ERROR_SUCCESS == dwRet)
            {
                dwRet = RegSetValueEx(
                    hKey,
                    cszAppName,
                    0L,
                    REG_SZ,
                    (LPBYTE)szTemp,
                    MAX_PATH + MAX_PATH + 1);

                RegCloseKey(hKey);
            }
        }
    }

    return dwRet;
}
#endif

static BOOL ProcessCommandLine(
                               LPCTSTR lpszCmdLine,
                               LPDWORD lpdwfOptions,
                               LPTSTR lpszFile,
                               DWORD cb)
{
    LPTSTR lpszCmd = NULL;
    TCHAR szCommandLine[MAX_PATH +1];
    TCHAR szTemp[_MAX_PATH + 1] = TEXT("");
    LPTSTR lpszFilePart = NULL;
    LPTSTR lpszConn = NULL;
    BOOL fEnabled;


    //
    // need to copy the command line into our own buffers
    // as it might be modified
    // MKarki (5/1/97) - Fix for Bug#4049
    //
    CopyMemory (szCommandLine, lpszCmdLine, MAX_PATH);
    lpszCmd = szCommandLine;

    *lpdwfOptions = SEF_SPLASH;

#ifdef WIN32
    // Determine Version
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
     if (!GetVersionEx(&osvi))
    {
        ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    }
#endif


    // check to see if invoked from run once
    while ((*lpszCmd == '-') || (*lpszCmd == '/'))
    {
        ++lpszCmd;  // skip '-' or '/'

        switch (*lpszCmd)
        {

        case 'b':       // we are running off a batch file
            ++lpszCmd;  // skip 'b'
#ifdef WIN32
            //
            // another thing specific to WINNT is to remove the
            // quotes from front and end of the file name, these
            // have been put so that start.exe does not act smart
            // and start parsing it and find things like & as special
            // chars
            // MKarki (5/1/97) - Fix for Bug #4049
            if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
            {
                RemoveQuotes (lpszCmd);
            }
#endif

        case 'r':
            ++lpszCmd;  // skip 'r'
            *lpdwfOptions |= SEF_RUNONCE;
#ifdef WIN32
            // 1/20/96 jmazner Normandy #9403
            // clean up the .bat file if we did a run once under NT
            if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
            {
                DeleteStartUpCommand();
            }
#endif
            break;

        case 'a':
            ++lpszCmd;  // skip 'a'

            *lpdwfOptions &= ~SEF_SPLASH;
             
            SetControlFlags(SCF_AUTODIALSAVED);
            
            SetExitFlags(SXF_RESTOREAUTODIAL);

            // get the name of the ISBU referal server, we may need it later.
            lpfnInetGetAutodial(
                &fEnabled,
                pDynShare->szSignupConnection,
                sizeof(pDynShare->szSignupConnection));
 
            if (*lpszCmd++ == '1')
            { 
                SetControlFlags(SCF_AUTODIALENABLED);
            }
            break;

        case 'p':
            ++lpszCmd;  // skip 'p'

            if (*lpszCmd++ == '1')
            { 
                SetControlFlags(SCF_PROXYENABLED);
            }
            break;

        case 'c':
            ++lpszCmd;  // skip 'c'
            if (*lpszCmd++ != '"')
            {
                return FALSE;
            }

            lpszConn = pDynShare->szAutodialConnection;
            
            while(*lpszCmd)
            {
                if (*lpszCmd == '"')
                {
                    ++lpszCmd;  // skip '"'
                    break;
                }
                *lpszConn++ = *lpszCmd++;
            }
            *lpszConn = 0;  // terminate string
            break;

        case 'x':
            ++lpszCmd;  // skip 'x'
            *lpdwfOptions |= SEF_PROGRESS;
            break;

#if !defined(WIN16)
        case 's':
            ++lpszCmd;  // skip 's'
 
            SetControlFlags(SCF_SILENT);
            
            break;
#endif
            // 3/14/97 jmazner TEMP
            // temporary hack until we can work with IE for a better solution
            case 'h':
                ++lpszCmd; // skip 'h'
                *lpdwfOptions |= SEF_NOSECURITYBACKUP;
                break;

        default:
            break;
        }

        // strip away spaces
        while(*lpszCmd == ' ')
        {
            ++lpszCmd;
        }
    }

    if (0 == GetFullPathName(lpszCmd, _MAX_PATH + 1, szTemp, &lpszFilePart))
    {
        return FALSE;
    }

    // 11/26/96 jmazner Normandy #12142
    // GetFullPathName called with lpszCmd == "c:" will return successfully, but
    // lpszFilePart will be NULL.  Check for that case.
    if( !lpszFilePart )
        return FALSE;

    if (lstrlen(szTemp) >= (int)cb)
    {
        return FALSE;
    }

    lstrcpy(lpszFile, szTemp);

    *lpszFilePart = '\0';

    // set the current directory
    // so that relative path will work
    if (!SetCurrentDirectory(szTemp))
    {
        return FALSE;
    }

    return TRUE;
}

static BOOL KeepBrowser(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszCustomSection,
        cszKeepBrowser,
        cszNo,
        szTemp,
        10,
        lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

static BOOL KeepConnection(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszCustomSection,
        cszKeepConnection,
        cszNo,
        szTemp,
        10,
        lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

#if defined(WIN16)
static int CopyFile(LPCTSTR lpcszSrcFile, LPCTSTR lpcszDestFile)
{
    HFILE hSrcFile, hDestFile;
    UINT uiBytesRead = 0;
    TCHAR szBuf[2048];


    hSrcFile = _lopen(lpcszSrcFile, READ);
    if (HFILE_ERROR == hSrcFile)
        return -1;

    //
    // Create new file or if the file esists truncate it
    //
    hDestFile = _lcreat(lpcszDestFile, 0);
    if (HFILE_ERROR == hDestFile)
    {
        _lclose(hSrcFile);
        return -1;
    }


    do
    {
        uiBytesRead = _lread(hSrcFile, &szBuf[0], 2048);
        if (HFILE_ERROR == uiBytesRead)
            break;
        _lwrite(hDestFile, &szBuf[0], uiBytesRead);

    }  while (0 != uiBytesRead);


    _lclose(hSrcFile);
    _lclose(hDestFile);

    return 0;
}
#endif

#if defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function:    BackUpINSFile
//
//    Synopsis:    The 3.1 version of IE2.01 will delete the .ins file too soon
//                therefore the ICW will make a backup of the ins file for use
//                later.
//
//    Arguments:    lpszFile - name of INS file
//
//    Returns:    TRUE - success
//                FALSE - failure
//
//    History:    3/19/97 ChrisK    extracted from ProcessINS
//-----------------------------------------------------------------------------
BOOL BackUpINSFile(LPCTSTR lpszFile)
{
    LPTSTR lpszTemp;
    TCHAR szNewFileName[MAX_PATH+2];
    BOOL bRC = FALSE;
    HWND hwnd = NULL;

    ZeroMemory(&szNewFileName[0], MAX_PATH+1);

    //
    // Check if the last character in prefix is 'a'
    // If it is, change it to 'b' in the new file name
    // otherwise, change it to 'a' in the new file name
    // Eg.: C:\iexplore\vetriv.ins --> C:\iexplore\vetria.ins
    // Eg.: C:\iexplore\aaaaa.ins --> C:\iexplore\aaaab.ins
    //
    lpszTemp = strrchr(lpszFile, '.');
    if (NULL == lpszTemp)
    {
      ErrorMsg(hwnd, IDS_CANNOTPROCESSINS);
      goto BackUpINSFileExit;
    }

    lstrcpyn(szNewFileName, lpszFile, lpszTemp - lpszFile);
    if ((*(lpszTemp - 1)) == 'a')
        lstrcat(szNewFileName, TEXT("b.INS"));
    else
        lstrcat(szNewFileName, TEXT("a.INS"));

    //
    // Copy the contents
    //
    if (0 != CopyFile(lpszFile, szNewFileName))
    {
      ErrorMsg(hwnd, IDS_CANNOTPROCESSINS);
      goto BackUpINSFileExit;
    }
    else
    {
        lpszFile = &szNewFileName[0];
    }

    bRC = TRUE;
BackUpINSFileExit:
    return bRC;
}
#endif // WIN16

//+----------------------------------------------------------------------------
//
//    Function:    IsCancelINSFile
//
//    Synopsis:    This function will determine if the ins file is a cancel
//                file, and if it is this function will handle it accordingly
//
//    Arguments:    lpszFile - name of ins file
//                fSignup - TRUE if part of the signup process
//
//    Returns:    TRUE - ins file is a cancel file
//
//    History:    3/19/97    ChrisK    separated from process INS
//-----------------------------------------------------------------------------
BOOL IsCancelINSFile(LPCTSTR lpszFile,BOOL fSignup)
{
    TCHAR szTemp[_MAX_PATH] = TEXT("XX");
    BOOL bRC = FALSE;
    HWND hwndMsg;
    if (GetPrivateProfileString(cszEntrySection,
                                    cszCancel,
                                    szNull,
                                    szTemp,
                                    _MAX_PATH,
                                    lpszFile) != 0)
    {
        bRC = TRUE;
         
        if (fSignup && !TestControlFlags(SCF_CANCELINSPROCESSED))
        {
            // If this instance is part of a signup process
            
#if !defined(WIN16)

            SetControlFlags(SCF_HANGUPEXPECTED);

#endif // !WIN16

            SetControlFlags(SCF_CANCELINSPROCESSED);
            
            KillConnection();
 
            // jmazner 4/17/97 Olympus #2471
            // kill IE window here to prevent user from clicking on cancel.ins link
            // multiple times.
            PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);

            InfoMsg(NULL, IDS_SIGNUPCANCELLED);

            //PostMessage(hwndMain, WM_CLOSE, 0, 0);
        }
        else if (TestControlFlags(SCF_CANCELINSPROCESSED))
        {
            // Bring the ISIGNUP widows to the front
            hwndMsg = FindWindow(TEXT("#32770"),cszAppName);
            if (hwndMsg)
            {
                
#if !defined(WIN16)
                SetForegroundWindow (hwndMsg);
#else // !WIN16
                SetFocus (hwndMsg);
#endif // !WIN16

            }
            
        }

    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    IsHangupINSFile
//
//    Synopsis:    This function will determine if the ins file is a hangup
//                file, and if it is this function will handle it accordingly
//
//    Arguments:    lpszFile - name of ins file
//                fSignup - TRUE if part of the signup process
//
//    Returns:    TRUE - ins file is a hangup file
//
//    History:    3/19/97    donaldm
//-----------------------------------------------------------------------------
BOOL IsHangupINSFile(LPCTSTR lpszFile,BOOL fSignup)
{
    TCHAR szTemp[_MAX_PATH] = TEXT("XX");
    BOOL bRC = FALSE;
    HWND hwndMsg;
    if (GetPrivateProfileString(cszEntrySection,
                                    cszHangup,
                                    szNull,
                                    szTemp,
                                    _MAX_PATH,
                                    lpszFile) != 0)
    {
        bRC = TRUE; 
        
        if (fSignup && !TestControlFlags(SCF_HANGUPINSPROCESSED))
        {
            // If this instance is part of a signup process

#if !defined(WIN16)

            SetControlFlags(SCF_HANGUPEXPECTED);

#endif // !WIN16

            SetControlFlags(SCF_HANGUPINSPROCESSED);
            
            KillConnection();
 
            // jmazner 4/17/97 Olympus #2471
            // kill IE window here to prevent user from clicking on cancel.ins link
            // multiple times.
            PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
            
        }
        else if (TestControlFlags(SCF_HANGUPINSPROCESSED))
        {
            // Bring the ISIGNUP widows to the front
            hwndMsg = FindWindow(TEXT("#32770"),cszAppName);
            if (hwndMsg)
            {
                
#if !defined(WIN16)
                SetForegroundWindow (hwndMsg);
#else // !WIN16
                SetFocus (hwndMsg);
#endif // !WIN16

            }
            
        }

    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    ProcessINS
//
//    Synopsis:    This function will process the contents of an .INS file
//
//    Arguments:    hwnd - pointer to parent window for all UI elements
//                lpszFile - name of .INS file
//                fSignup - if TRUE then this INS file is being processed as
//                    part a signup
//
//    Returns:    TRUE - success
//                FALSE - failure
//
//    History:    3/19/97    ChrisK    Reworked the function considerbly to clean up
//                    a lot of problem with deleting INS files.
//-----------------------------------------------------------------------------
BOOL ProcessINS(HWND hwnd, LPCTSTR lpszFile, BOOL fSignup)
{
    BOOL fNeedsRestart = FALSE;
    LPRASENTRY lpRasEntry = NULL;
    BOOL fConnectoidCreated = FALSE;
    DWORD dwRet = 0xFF;
    TCHAR szTemp[MAX_PATH] = TEXT("XX");
    TCHAR szConnectoidName[RAS_MaxEntryName*2] = TEXT("");
    BOOL fClientSetup = FALSE;
    BOOL bRC = FALSE;
    BOOL fErrMsgShown = FALSE;
#if !defined(WIN16)
    DWORD dwSBSRet = ERROR_SUCCESS;
#endif // WIN16

    HKEY    hKey = NULL;
    DWORD   dwSize = sizeof(DWORD);
    DWORD   dwDesktopChanged = 0;


    // 3/11/97 jmazner Olympus #1545
    // close up the security hole ASAP.  This will unfortunately also
    // prevent a clever .ins file from bringing the user back to the
    // referall page to choose a different ISP
#if !defined (WIN16)
    RestoreSecurityPatch();
#endif // !WIN16

    //
    // Insure that the contents of the file are formatted correctly so
    // that the GetPrivateProfile calls can parse the contents.
    //
    dwRet = MassageFile(lpszFile);
    if (ERROR_SUCCESS != dwRet)
    {
        ErrorMsg(hwnd, IDS_CANNOTPROCESSINS);
        goto ProcessINSExit;
    }

    //
    // Determine if the .INS file is a "cancel" file
    //
    if (FALSE != IsCancelINSFile(lpszFile,fSignup))
        goto ProcessINSExit;

    //
    // Determine if the .INS file is a "hangup" file
    //
    if (FALSE != IsHangupINSFile(lpszFile,fSignup))
        goto ProcessINSExit;

    //
    // Make sure that the RAS services are running before calling any RAS APIs.
    // This only applies to NT, but the function is smart enough to figure that
    // out
    //
#if !defined(WIN16)
    if (!VerifyRasServicesRunning(hwnd))
        goto ProcessINSExit;
#endif // !WIN16 

    //
    // If we are no in the signup process, warn the user before changing there
    // settings
    //
    if (!fSignup && !TestControlFlags(SCF_SILENT))
    {
        if (!WarningMsg(NULL, IDS_INSFILEWARNING))
        {
            goto ProcessINSExit;
        }
    }
    else
    {
#if !defined (WIN16)
        // If there is a ClientSetup section, then we know that icwconn2
        // will have to be run after isignup in order to handle the
        // settings
        if (GetPrivateProfileSection(cszClientSetupSection,
            szTemp,
            MAX_PATH,
            lpszFile) != 0)
            fClientSetup = TRUE;
#endif // !WIN16

        if (fClientSetup || KeepConnection(lpszFile))
            SetExitFlags(SXF_KEEPCONNECTION);

        if (KeepBrowser(lpszFile))
            SetExitFlags(SXF_KEEPBROWSER);

        if (!TestExitFlags(SXF_KEEPCONNECTION))
            KillConnection();
    }

    //
    // Import various information from INS file
    //

    // Import name of executable to be launched after isignup
    ImportCustomInfo(
        lpszFile,
        pDynShare->szRunExecutable,
        SIZEOF_TCHAR_BUFFER(pDynShare->szRunExecutable),
        pDynShare->szRunArgument,
        SIZEOF_TCHAR_BUFFER(pDynShare->szRunArgument));

    // Import RAS log-on script file
    ImportCustomFile(lpszFile);
 
    
    // Import network connection settings information and configure client
    // pieces to use them.
    dwRet = ConfigureClient(
        hwnd,
        lpszFile,
        &fNeedsRestart,
        &fConnectoidCreated,
        TestControlFlags(SCF_LOGONREQUIRED),
        szConnectoidName,
        RAS_MaxEntryName);

    //
    // 6/2/97 jmazner Olympus #4573
    // display an appropriate error msg
    //
    if( ERROR_SUCCESS != dwRet )
    {
        // 10/07/98 vyung IE bug#32882 hack.
        // If we do not detect the [Entry] section in the ins file,
        // we will assume it is an OE ins file.  Then we will assume
        // we have a autodial connection and pass the INS to OE.
        if (ERROR_NO_MATCH == dwRet)
        {
            ImportMailAndNewsInfo(lpszFile, TRUE);
            return TRUE;
        }
        else
        {
            ErrorMsg(hwnd, IDS_INSTALLFAILED);
            fErrMsgShown = TRUE;
        }
    }

    // Import information used to brand the broswer
    ImportBrandingInfo(lpszFile, szConnectoidName);

#if !defined(WIN16)
    // If we created a connectoid, tell the world that ICW
    // has left the building...
    SetICWCompleted( (DWORD)1 );
    
    ClearControlFlags(SCF_ICWCOMPLETEDKEYRESETED);

    // 2/19/97 jmazner    Olympus 1106
    // For SBS/SAM integration.
    dwSBSRet = CallSBSConfig(hwnd, lpszFile);
    switch( dwSBSRet )
    {
        case ERROR_SUCCESS:
            break;
        case ERROR_MOD_NOT_FOUND:
        case ERROR_DLL_NOT_FOUND:
            Dprintf("ISIGN32: SBSCFG DLL not found, I guess SAM ain't installed.\n");
            break;
        default:
            ErrorMsg(hwnd, IDS_SBSCFGERROR);
    }
#endif // !WIN16

#if defined(WIN16)

    //
    // Since IE 21 deletes the file from cache, we have to make
    // a private copy of it, if we are going to run a 3rd EXE
    //    
    if (*(pDynShare->szRunExecutable))
    {
        if (FALSE == BackUpINSFile(lpszFile))
          goto ProcessINSExit;
    }
    
#endif // WIN16

#if !defined (WIN16)
    //
    // If the INS file contains the ClientSetup section, build the commandline
    // arguments for ICWCONN2.exe.
    //
    if (fClientSetup)
    {
        // Check to see if a REBOOT is needed and tell the next application to
        // handle it.
        if (fNeedsRestart)
        {
            wsprintf(pDynShare->szRunArgument,TEXT(" /INS:\"%s\" /REBOOT"),lpszFile);
            fNeedsRestart = FALSE;
        }
        else
        {
            wsprintf(pDynShare->szRunArgument,TEXT(" /INS:\"%s\""),lpszFile);
        }

    }
#else // !WIN16

    wsprintf(szRunArgument," /INS:\"%s\"",lpszFile);

#endif // !WIN16

    SetControlFlags(SCF_SIGNUPCOMPLETED);
    
    if (!TestExitFlags(SXF_KEEPBROWSER))
        KillBrowser();

#ifdef WIN32
    // humongous hack for ISBU
    if (ERROR_SUCCESS != dwRet && fConnectoidCreated)
    {
        InfoMsg(hwnd, IDS_MAILFAILED);
        dwRet = ERROR_SUCCESS;
    }
#endif

    //
    // Import settings for mail and new read from INS file (ChrisK, 7/1/96)
    //
    if (ERROR_SUCCESS == dwRet)
        ImportMailAndNewsInfo(lpszFile, fConnectoidCreated);

    //
    // Close up final details and clean up
    //
    if (ERROR_SUCCESS == dwRet)
    {
        // if the connectoid was created, do not restore the old autodial settings
        if (fConnectoidCreated)
            ClearExitFlags(SXF_RESTOREAUTODIAL);

#ifdef SETUPSTACK
        // Is it necessary to reboot for configuration to take effect?
        if (fNeedsRestart)
        {
            // what do we do if we need to run executable and
            // we need the link or the browser  BARF!!
            if (PromptRestart(hwnd))
            {
                // 3/13/97 jmazner Olympus #1682
                // technically, shouldn't need this here since we did it at the start
                // of processINS, but better safe...
                RestoreSecurityPatch();

                FGetSystemShutdownPrivledge();
                ExitWindowsEx(EWX_REBOOT, 0);
                //
                //  We will wait for the System to release all
                //  resources, 5 minutes should be more than
                //  enough for this
                //  - MKarki (4/22/97) - MKarki
                //  Fix for Bug #3109
                //
                // 7/8/97 jmazner Olympus 4212
                // No, sleeping for 5 minutes turns out not to be such a good idea.
                //Sleep (300000);
                //
            }
        }
        else
#endif
        {
 
            if (*(pDynShare->szRunExecutable))
            {
                SetExitFlags(SXF_RUNEXECUTABLE | SXF_WAITEXECUTABLE);
            }
            else
            {
                 
                if (!TestControlFlags(SCF_SILENT))
                    InfoMsg(hwnd, IDS_SIGNUPCOMPLETE);
                
            }
        }
    }
    else
    {
        // In case of an error with network or connection settings
        ClearExitFlags(~SXF_RESTOREAUTODIAL);

        if( !fErrMsgShown )
        {
            ErrorMsg(hwnd, IDS_BADSETTINGS);
            fErrMsgShown = TRUE;
        }
    }

    // If this is part of signup process, then signal the first instance
    // to close
    if (fSignup)
    {
         
        PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
    }

    // Restore the desktop icons if we have the newer version of ICWCONN1.EXE,
    // and we previsouly munged them.
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,ICWSETTINGSPATH,&hKey))
    {
        RegQueryValueEx(hKey,
                        ICWDESKTOPCHANGED,
                        0,
                        NULL,
                        (BYTE*)&dwDesktopChanged,
                        &dwSize);
        RegCloseKey(hKey);
    }

    if (dwDesktopChanged)
    {
        DWORD dwVerMS, dwVerLS;
        if( GetAppVersion( &dwVerMS, &dwVerLS, ICW20_PATHKEY ) )
        {
//        if( ( (dwVerMS >= ICW20_MINIMUM_VERSIONMS) && (dwVerLS >= ICW20_MINIMUM_VERSIONLS) ) )
            if(dwVerMS >= ICW20_MINIMUM_VERSIONMS)
            {
                ShellExecute(NULL, cszOpen, g_szICWCONN1, g_szRestoreDesktop, NULL, SW_HIDE);
            }
        }
    }

    bRC = TRUE;
ProcessINSExit: 

    // 3/11/97 jmazner Olympus #1233, 252
    // if no 3rd exe, and this instance is part of a signup process and
    // SERVERLESS flag is not set for IEAK, then delete the .ins file
    if ( (fSignup) &&
         (('\0' == pDynShare->szRunExecutable[0]) || (ERROR_SUCCESS != dwRet)) )
    {
        if (1 != GetPrivateProfileInt(
            cszBrandingSection,
            cszBrandingServerless,
            0,
            lpszFile))
        {
            DeleteFileKindaLikeThisOne(lpszFile);
        }
        else
        {
            Dprintf("ISIGN32: Preserving .ins file for SERVERLESS flag\n");
        }
    }
    return bRC;
}

static BOOL RequiresLogon(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszUserSection,
        cszRequiresLogon,
        cszNo,
        szTemp,
        10,
        lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}


static UINT GetBrandingFlags(LPCTSTR lpszFile)
{
    return GetPrivateProfileInt(
        cszBrandingSection,
        cszBrandingFlags,
        BRAND_DEFAULT,
        lpszFile);
}

//+----------------------------------------------------------------------------
//
//    Function:    SetGlobalOffline
//
//    Synopsis:    Set IE4 into online or offline mode
//
//    Arguments:    fOffline - TRUE to set OFFLINE mode
//                            FALSE to set ONLINE mode
//
//    Returns:    none
//
//    History:    7/15/97    ChrisK imported from DarrenMi's email
//
//-----------------------------------------------------------------------------

typedef struct {
    DWORD dwConnectedState;
    DWORD dwFlags;
} INTERNET_CONNECTED_INFO, * LPINTERNET_CONNECTED_INFO;

//
// the following can be indicated in a state change notification:
//

#define INTERNET_STATE_CONNECTED                0x00000001  // connected state (mutually exclusive with disconnected)
#define INTERNET_STATE_DISCONNECTED             0x00000002  // disconnected from network
#define INTERNET_STATE_DISCONNECTED_BY_USER     0x00000010  // disconnected by user request
#define INTERNET_STATE_IDLE                     0x00000100  // no network requests being made (by Wininet)
#define INTERNET_STATE_BUSY                     0x00000200  // network requests being made (by Wininet)

#define ISO_FORCE_DISCONNECTED  0x00000001

#define INTERNET_OPTION_CONNECTED_STATE         50

typedef BOOL (WINAPI *PFNSETINTERNETOPTIONA)(LPVOID, DWORD, LPVOID, DWORD);

void SetGlobalOffline(BOOL fOffline)
{
    DebugOut("ISIGN32: SetGlobalOffline.\n");
    INTERNET_CONNECTED_INFO ci;
    HMODULE hMod = LoadLibrary(TEXT("wininet.dll"));
    FARPROC fp = NULL;
    BOOL bRC = FALSE;

    ZeroMemory(&ci, sizeof(ci));

    if (NULL == hMod)
    {
        Dprintf("ISIGN32: Wininet.dll did not load.  Error:%d.\n",GetLastError());
        goto InternetSetOptionExit;
    }

#ifdef UNICODE
    if (NULL == (fp = GetProcAddress(hMod,"InternetSetOptionW")))
#else
    if (NULL == (fp = GetProcAddress(hMod,"InternetSetOptionA")))
#endif
    {
        Dprintf("ISIGN32: InternetSetOptionA did not load.  Error:%d.\n",GetLastError());
        goto InternetSetOptionExit;
    }

    if(fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    DebugOut("ISIGN32: Setting offline\\online.\n");
    bRC = ((PFNSETINTERNETOPTIONA)fp) (NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
#ifdef DEBUG
    if (bRC)
    {
        DebugOut("ISIGN32: GetGlobalOffline returned TRUE.\n");
    }
    else
    {
        DebugOut("ISIGN32: GetGlobalOffline returned FALSE.\n");
    }
#endif
InternetSetOptionExit:
    DebugOut("ISIGN32: Exit SetGlobalOffline.\n");
    return;
}

BOOL ProcessISP(HWND hwnd, LPCTSTR lpszFile)
{

    TCHAR  szSignupURL[MAX_URL + 1];
#if !defined(WIN16)
    HKEY hKey;
    GATHEREDINFO gi;
#endif //!WIN16

    //
    // 4/30/97    jmazner    Olympus 3969
    // For security reasons, do not process the [Custom] Run= command in an .isp
    // file!
    //
 #if DEBUG
   if (GetPrivateProfileString(
        cszEntrySection,
        cszRun,
        szNull,
        pDynShare->szRunExecutable,
        SIZEOF_TCHAR_BUFFER(pDynShare->szRunExecutable),
        lpszFile) != 0)
    {
        //
        // 4/30/97    jmazner    Olympus 3969
        // For security reasons, do not process the [Custom] Run= command in an .isp
        // file!
        //
        lstrcpyn(pDynShare->szRunExecutable, TEXT("\0"), 1);
        
        ClearExitFlags(SXF_RUNEXECUTABLE | SXF_WAITEXECUTABLE);
        
        Dprintf("ISIGN32: The file %s has the [Custom] Run= command!", lpszFile);
        MessageBox( hwnd,
                    TEXT("The .isp file you're running contains the [Custom] Run= command.\n\nThis functionality has been removed."),
                    TEXT("DEBUG information msgBox -- this is NOT a bug"),
                    MB_OK );
/*****
        dwExitFlags |= (SXF_RUNEXECUTABLE | SXF_WAITEXECUTABLE);

        GetPrivateProfileString(cszEntrySection,
            cszArgument,
            szNull,
            szRunArgument,
            sizeof(szRunArgument),
            lpszFile);

        PostMessage(hwnd, WM_CLOSE, 0, 0);
        return FALSE;
******/
    }
#endif

#if !defined(WIN16)
    // Make sure the isp file exists before setting up stack.
    if (0xFFFFFFFF == GetFileAttributes(lpszFile))
    {
        DWORD dwFileErr = GetLastError();
        Dprintf("ISIGN32: ProcessISP couldn't GetAttrib for %s, error = %d",
                lpszFile, dwFileErr);
        if( ERROR_FILE_NOT_FOUND == dwFileErr )
        {
            ErrorMsg1(hwnd, IDS_INVALIDCMDLINE, lpszFile);
        }

        ErrorMsg(hwnd, IDS_BADSIGNUPFILE);
        return FALSE;
    }
#endif

    // Register file extensions if not already registered

    // Configure stack if not already configured.
    // This may required a restart. If so warn the user.
    // We may want to check to see if the user is calling
    // us again without restarting after configuring the stack.

#ifdef SETUPSTACK
 
    if (!TestControlFlags(SCF_SYSTEMCONFIGURED))
    {
        DWORD dwRet;
        BOOL  fNeedsRestart = FALSE;

        //
        // ChrisK Olympus 4756 5/25/97
        // Do not display busy animation on Win95
        //
        dwRet = lpfnInetConfigSystem(
            hwnd,
            INETCFG_INSTALLRNA |
            INETCFG_INSTALLTCP |
            INETCFG_INSTALLMODEM |
            (IsNT()?INETCFG_SHOWBUSYANIMATION:0) |
            INETCFG_REMOVEIFSHARINGBOUND,
            &fNeedsRestart);

        if (ERROR_SUCCESS == dwRet)
        {            
            SetControlFlags(SCF_SYSTEMCONFIGURED);
            
            InstallScripter();

            if (fNeedsRestart)
            {
            if (PromptRestartNow(hwnd))
            {
                SetRunOnce(lpszFile);

                // 3/13/97 jmazner Olympus #1682
                RestoreSecurityPatch();

                FGetSystemShutdownPrivledge();
                ExitWindowsEx(EWX_REBOOT, 0);
                //
                //  We will wait for the System to release all
                //  resources, 5 minutes should be more than
                //  enough for this
                //  - MKarki (4/22/97) - MKarki
                //  Fix for Bug #3109
                //
                // 7/8/97 jmazner Olympus 4212
                // No, sleeping for 5 minutes turns out not to be such a good idea.
                //Sleep (300000);
                //
            }
            return FALSE;
            }
        }
        else
        {
            ErrorMsg(hwnd, IDS_INSTALLFAILED);

            return FALSE;
        }
    }

    if (!VerifyRasServicesRunning(hwnd))
        return FALSE;
#endif

/******** 11/5/96 jmazner    Normandy #8717
    // if the original autodial settings have not been saved
    SaveAutoDial();
    dwExitFlags |= SXF_RESTOREAUTODIAL;
********/

    // kill the old connection
    KillConnection();

    // Create a new connectoid and set the autodial
    DWORD dwRC;
    dwRC = CreateConnection(lpszFile);
    if (ERROR_SUCCESS != dwRC)
    {
        //
        //    ChrisK Olympus 6083 6/10/97
        //    If the user canceled, we have already acknowledged it.
        //
        if (ERROR_CANCELLED != dwRC)
        {
            ErrorMsg(hwnd, IDS_BADSIGNUPFILE);
        }
        return FALSE;
    }

#ifndef WIN16
    //
    // Dial connectoid
    //
    if (ERROR_USERNEXT != DialConnection(lpszFile))
    {
        
        SetControlFlags(SCF_BROWSERLAUNCHED);
        
        KillBrowser();
        return FALSE;
    }

    lstrcpyn(
        pDynShare->szISPFile,
        lpszFile,
        SIZEOF_TCHAR_BUFFER(pDynShare->szISPFile));

    //
    // Tell IE that it is OK to make a connection to the Internet and do not
    // display the dialog asking if the user wants to go online.
    //
    SetGlobalOffline(FALSE);

#endif

    // Get the URL that we need for signup
    GetURL(lpszFile,
        cszSignupURL,
        szSignupURL,
        MAX_URL + 1);

#ifdef WIN32
    if (RequiresLogon(lpszFile))
    {
        SetControlFlags(SCF_LOGONREQUIRED);

        if (ERROR_CANCELLED == SignupLogon(hwnd))
        {
            InfoMsg(NULL, IDS_SIGNUPCANCELLED); 
            PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
            return FALSE;
        }
    }

    // OSR 10582
    // We need to pass the name of the ISP file to the autodialer, so that the
    // autodialer can extract the password that may be included
    ZeroMemory(&gi,sizeof(gi));
    hKey = NULL;
    lstrcpyn(gi.szISPFile,lpszFile,MAX_PATH);
    if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY,&hKey))
    {
        RegSetValueEx(hKey,TEXT("UserInfo"),0,REG_BINARY,(LPBYTE)&gi,sizeof(gi));
        RegCloseKey(hKey);
        hKey = NULL;
    }
#endif

    pDynShare->dwBrandFlags = GetBrandingFlags(lpszFile);

    return (ExecBrowser(hwnd, szSignupURL));
}



//+---------------------------------------------------------------------------
//
//    Function:    WaitForConnectionTermination
//
//    Synopsis:    Waits for the given Ras Connection to complete termination
//
//    Arguments:    hConn - Connection handle of the RAS connection being terminated
//
//    Returns:    TRUE if wait till connection termination was successful
//                FALSE otherwise
//
//    History:    6/30/96    VetriV    Created
//                8/29/96    VetriV    Added code to sleep for a second on WIN 3.1
//----------------------------------------------------------------------------
// Normandy #12547 Chrisk 12-18-96
#define MAX_TIME_FOR_TERMINATION 5
BOOL WaitForConnectionTermination(HRASCONN hConn)
{
    RASCONNSTATUS RasConnStatus;
    DWORD dwRetCode;
// Normandy #12547 Chrisk 12-18-96
#if !defined(WIN16)
    INT cnt = 0;
#endif

    //
    // Get Connection status for hConn in a loop until
    // RasGetConnectStatus returns ERROR_INVALID_HANDLE
    //
    do
    {
        //
        // Intialize RASCONNSTATUS struct
        // GetConnectStatus API will fail if dwSize is not set correctly!!
        //
        ZeroMemory(&RasConnStatus, sizeof(RASCONNSTATUS));

        RasConnStatus.dwSize = sizeof(RASCONNSTATUS);

        //
        // Sleep for a second and then get the connection status
        //
#if defined(WIN16)
        time_t StartTime = time(NULL);

        do
        {
            MSG msg;


            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            //
            // Check if we have waited atleast 1 second and less than 2 seconds
            //
        }
        while ((time(NULL) - StartTime) <= 1);
#else
        Sleep(1000L);
        // Normandy #12547 Chrisk 12-18-96
        cnt++;
#endif

        if (NULL == lpfnRasGetConnectStatus)
            return FALSE;

        dwRetCode = lpfnRasGetConnectStatus(hConn, &RasConnStatus);
        if (0 != dwRetCode)
            return FALSE;


#if defined(WIN16)
    } while (RASCS_Disconnected != RasConnStatus.rasconnstate);
#else
    // Normandy #12547 Chrisk 12-18-96
    } while ((ERROR_INVALID_HANDLE != RasConnStatus.dwError) && (cnt < MAX_TIME_FOR_TERMINATION));
#endif

    return TRUE;
}




BOOL ProcessHTML(HWND hwnd, LPCTSTR lpszFile)
{
    BOOL  fNeedsRestart = FALSE;
#if SETUPSTACK
    DWORD dwRet;
     
    if (!TestControlFlags(SCF_SYSTEMCONFIGURED))
    {
        //
        // ChrisK Olympus 4756 5/25/97
        // Do not display busy animation on Win95
        //
        dwRet = lpfnInetConfigSystem(
            hwnd,
            INETCFG_INSTALLRNA |
            INETCFG_INSTALLTCP |
            INETCFG_INSTALLMODEM |
            (IsNT()?INETCFG_SHOWBUSYANIMATION:0) |
            INETCFG_REMOVEIFSHARINGBOUND,
            &fNeedsRestart);

        if (ERROR_SUCCESS == dwRet)
        {

            SetControlFlags(SCF_SYSTEMCONFIGURED);
            
            InstallScripter();

            if (fNeedsRestart)
            {
            if (PromptRestart(hwnd))
            {
                SetRunOnce(lpszFile);

                // 3/13/97 jmazner Olympus #1682
                RestoreSecurityPatch();

                FGetSystemShutdownPrivledge();
                ExitWindowsEx(EWX_REBOOT, 0);
                //
                //  We will wait for the System to release all
                //  resources, 5 minutes should be more than
                //  enough for this
                //  - MKarki (4/22/97) - MKarki
                //  Fix for Bug #3109
                //
                // 7/8/97 jmazner Olympus 4212
                // No, sleeping for 5 minutes turns out not to be such a good idea.
                //Sleep (300000);
                //
            }
            return FALSE;
            }
        }
        else
        {
            ErrorMsg(hwnd, IDS_INSTALLFAILED);

            return FALSE;
        }
    }

    if (!VerifyRasServicesRunning(hwnd))
        return FALSE;

#endif

    return (ExecBrowser(hwnd, lpszFile));
}

#ifdef WIN32
DWORD RunExecutable(BOOL fWait)
{
    DWORD dwRet;
    SHELLEXECUTEINFO sei;
 
    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = cszOpen;
    sei.lpFile = pDynShare->szRunExecutable;
    sei.lpParameters = pDynShare->szRunArgument;
    sei.lpDirectory = NULL;
    sei.nShow = SW_SHOWNORMAL;
    sei.hInstApp = NULL;
    // Optional members
    sei.hProcess = NULL;

    if (ShellExecuteEx(&sei))
    {
    if (fWait)
    {
//          WaitForSingleObject(sei.hProcess, INFINITE);
        DWORD iWaitResult = 0;
        // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
        while((iWaitResult=MsgWaitForMultipleObjects(1, &sei.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
        {
           MSG msg ;
           // read all of the messages in this next loop
           // removing each message as we read it
           while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
           {
           // how to handle quit message?
           if (msg.message == WM_QUIT)
           {
               CloseHandle(sei.hProcess);
               return NO_ERROR;
           }
           else
               DispatchMessage(&msg);
        }
       }
    }
    CloseHandle(sei.hProcess);
    dwRet = ERROR_SUCCESS;
    }
    else
    {
    dwRet = GetLastError();
    }

    return dwRet;
}
#else

DWORD RunExecutable(BOOL fWait)
{
    DWORD dwRet;
 
    dwRet = (DWORD)ShellExecute(
        NULL,
        cszOpen,
        pDynShare->szRunExecutable,
        pDynShare->szRunArgument,
        NULL,
        SW_SHOWNORMAL);

    if (32 < dwRet)
    {
    dwRet = ERROR_SUCCESS;
    }
    else if (0 == dwRet)
    {
    dwRet = ERROR_OUTOFMEMORY;
    }

    return dwRet;
}
#endif

void SaveAutoDial(void)
{
    // if the original autodial settings have not been saved
     
    if (!TestControlFlags(SCF_AUTODIALSAVED))
    {
        // save the current autodial settings
        BOOL fEnabled;
        
        lpfnInetGetAutodial(
            &fEnabled,
            pDynShare->szAutodialConnection,
            sizeof(pDynShare->szAutodialConnection));

        if (fEnabled)
        {
            SetControlFlags(SCF_AUTODIALENABLED);
        }
        else
        {
            ClearControlFlags(SCF_AUTODIALENABLED);
        }            

#ifdef WIN32
        lpfnInetGetProxy(
            &fEnabled,
            NULL, 0,
            NULL, 0);

        if (fEnabled)
        {
            SetControlFlags(SCF_PROXYENABLED);
        }
        else
        {
            ClearControlFlags(SCF_PROXYENABLED);
        }
        // turn off proxy
        lpfnInetSetProxy(FALSE, NULL, NULL);
#endif
        SetControlFlags(SCF_AUTODIALSAVED);
        
    }
}

void RestoreAutoDial(void)
{
     
    if (TestControlFlags(SCF_AUTODIALSAVED))
    {
        // restore original autodial settings
         
        lpfnInetSetAutodial(
            TestControlFlags(SCF_AUTODIALENABLED),
            pDynShare->szAutodialConnection);
        
        
#ifdef WIN32
         lpfnInetSetProxy(TestControlFlags(SCF_PROXYENABLED), NULL, NULL);
#endif
        ClearControlFlags(SCF_AUTODIALSAVED);
    }
}

DWORD CreateConnection(LPCTSTR lpszFile)
{
    DWORD dwRet;
    LPICONNECTION pConn;

    // Allocate a buffer for connection object
    //
    pConn = (LPICONNECTION)LocalAlloc(LPTR, sizeof(ICONNECTION));
    if (NULL == pConn)
    {
    return ERROR_OUTOFMEMORY;
    };

    dwRet = ImportConnection(lpszFile, pConn);
    if (ERROR_SUCCESS == dwRet)
    {
        
#ifdef WIN32
        if ((0 == *pConn->RasEntry.szAutodialDll) ||
            (0 == *pConn->RasEntry.szAutodialFunc))
        {
            lstrcpy(pConn->RasEntry.szAutodialDll, TEXT("ICWDIAL.dll"));
            lstrcpy(pConn->RasEntry.szAutodialFunc, TEXT("AutoDialHandler"));

            // save the password in case it doesn't get cached
            lstrcpyn(
                pDynShare->szPassword,
                pConn->szPassword,
                SIZEOF_TCHAR_BUFFER(pDynShare->szPassword));

        }
#endif

        dwRet = lpfnInetConfigClient(
            NULL,
            NULL,
            pConn->szEntryName,
            &pConn->RasEntry,
            pConn->szUserName,
            pConn->szPassword,
            NULL,
            NULL,
            INETCFG_SETASAUTODIAL |
            INETCFG_OVERWRITEENTRY |
            INETCFG_TEMPPHONEBOOKENTRY,
            NULL);

#if !defined(WIN16)
        LclSetEntryScriptPatch(pConn->RasEntry.szScript,pConn->szEntryName);
#endif

        if (ERROR_SUCCESS == dwRet)
        {
            lstrcpyn(
                pDynShare->szSignupConnection,
                pConn->szEntryName,
                RAS_MaxEntryName + 1);
            
        }
    }

    LocalFree(pConn);

    return dwRet;
}

DWORD DeleteConnection(void)
{
     
    if (*(pDynShare->szSignupConnection))
    {
        // delete the signup entry
        lpfnRasDeleteEntry(NULL, pDynShare->szSignupConnection);
        pDynShare->szSignupConnection[0] = (TCHAR)'\0';
    }

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//    Function:    KillThisConnection
//
//    Synopsis:    Disconnects the connectoid named in lpzConnectoid and waits
//                until the connection is completely torn down.  Then the
//                connectoid is deleted.
//
//    Arguments:    lpzConnectoid - name of connection to disconnect
//
//    Returns:    (return) - win32 error code
//
//    History:    4/27/97    Chrisk    Created
//-----------------------------------------------------------------------------
DWORD KillThisConnection(LPTSTR lpzConnectoid)
{
    LPRASCONN pRasConn=NULL;
    DWORD dwSize = sizeof(RASCONN);
    DWORD dwSizeRasConn = dwSize;
    DWORD dwRet = ERROR_SUCCESS;

    if ('\0' == *lpzConnectoid)
        return ERROR_NO_CONNECTION;

    // OK were ready for Rna now
    if (!LoadRnaFunctions(pDynShare->hwndMain))
        return ERROR_NO_CONNECTION;

    if ((pRasConn = (LPRASCONN)LocalAlloc(LPTR, (int)dwSize)) == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    pRasConn->dwSize = dwSize;
    dwRet = lpfnRasEnumConnections(pRasConn, &dwSize, &dwSizeRasConn);
    if (ERROR_SUCCESS != dwRet)
    {
        dwRet = ERROR_NO_CONNECTION;
        goto KillThisConnectionExit;
    }

    // check entry name to see if
    // its ours
#ifndef WIN32
    //
    // Workaround for WIN16 RAS Bug - it sometimes truncates
    // the name of the connectoid
    //
    if (!strncmp(pRasConn->szEntryName, lpzConnectoid,
                    lstrlen(pRasConn->szEntryName)))
#else
    if (!lstrcmp(pRasConn->szEntryName, lpzConnectoid))
#endif
    {
        // Normandy 12642 ChrisK 12-18-9
        // We don't want the user to reconnect here.
#if !defined(WIN16)

        SetControlFlags(SCF_HANGUPEXPECTED);

#endif
        // then hangup
        lpfnRasHangUp(pRasConn->hrasconn);
        WaitForConnectionTermination(pRasConn->hrasconn);
    }

    // delete the signup entry
    lpfnRasDeleteEntry(NULL, lpzConnectoid);

KillThisConnectionExit:
    if (pRasConn)
        LocalFree(pRasConn);

    return dwRet;
}

//+----------------------------------------------------------------------------
//    Function:    KillConnection
//
//    Synopsis:    Calls KillThisConnection and passes in the name of the signup
//                connection that is saved in szSignupConnection
//
//    Arguments:    none
//
//    Returns:    (return) - win32 error code
//
//    History:    4/27/97    Chrisk    modified to call KillThisConnection
//-----------------------------------------------------------------------------
DWORD KillConnection(void)
{
    DWORD dwRet;
     
    dwRet = KillThisConnection(pDynShare->szSignupConnection);

#if defined(WIN16)
    ShutDownIEDial(pDynShare->hwndMain);
#endif // WIN16

    pDynShare->szSignupConnection[0] = (TCHAR)'\0';
    UnloadRnaFunctions();

    return dwRet;
}

BOOL ExecBrowser(HWND hwnd, LPCTSTR lpszURL)
{

    HRESULT hresult;
    TCHAR szFullURL[MAX_URL + 1];


    if (!FixUpURL(lpszURL, szFullURL, MAX_URL + 1))
    {
        //
        // ChrisK Olympus 4002 5/26/97
        // If the URL is empty, this error message doesn't make
        // a lot of sense.  So use a different message.
        //
        if (lstrlen(lpszURL))
        {
            ErrorMsg1(hwnd, IDS_INVALIDURL, lpszURL);
        }
        else
        {
            ErrorMsg(hwnd, IDS_INVALIDNOURL);
        }
        return FALSE;
    }
 
    if (TestControlFlags(SCF_BROWSERLAUNCHED))
    {
#ifdef WIN32
        // No assert macro defined for isign32????
        //Assert(g_iwbapp);
        if( !g_iwbapp )
        {
            DebugOut("ISIGNUP: fatal err, fBrowserLaunched disagrees with g_iwbapp\n");

            return( FALSE );
        }

        // TODO find out what the result codes should be!
        hresult = IENavigate( szFullURL );

        if( FAILED(hresult) )
        {
            DebugOut("ISIGNUP: second Navigate _failed_, hresult was failure\n");
            return FALSE;
        }
        else
        {
            DebugOut("ISIGNUP: second Navigate success!, hresult was success\n");
        }

        //g_iwbapp->put_Visible( TRUE );



#else

        DDEInit(ghInstance);
        OpenURL(szFullURL);
        DDEClose();
#endif

    }
    else
    {
        TCHAR szTemp[MAX_URL + sizeof(cszKioskMode)/sizeof(TCHAR)];
        HWND hwndTemp;
        HANDLE hBrowser;
#ifndef WIN32
        time_t start;
#endif
 
        if (NULL != pDynShare->hwndLaunch)
        {
            ShowWindow(pDynShare->hwndLaunch, SW_SHOW);
            UpdateWindow(pDynShare->hwndLaunch);
        }

// for OLE Autmoation we only want to pass in the URL (no "-k") and then call FullScreen,
// so only -k for win16
#ifndef WIN32

        lstrcpy(szTemp, cszKioskMode);
        lstrcat(szTemp, szFullURL);

        // no point in doing this for IE4, which may have lots of windows already open
        hwndTemp = FindBrowser();

        if (NULL != hwndTemp)
        {
            PostMessage(hwndTemp, WM_CLOSE, 0, 0L);
        }
#endif


#ifdef WIN32
        // 8/19/96 jmazner Normandy #4571
        // Check to ensure that the right version IE is installed before trying to exec it
/******** Normandy #10293, do this verification before going through the whole
          dialing process

        if ( !IEInstalled() )
        {
            ErrorMsg( hwnd, IDS_MISSINGIE );
            return(FALSE);
        }

        DWORD dwVerMS, dwVerLS;

        if( !GetAppVersion( &dwVerMS, &dwVerLS,IE_PATHKEY ) )
            return (FALSE);

        if( !( (dwVerMS >= IE_MINIMUM_VERSIONMS) && (dwVerLS >= IE_MINIMUM_VERSIONLS) ) )
        {
            Dprintf("ISIGN32: user has IE version %d.%d.%d.%d; min ver is %d.%d.%d.%d\n",
                HIWORD(dwVerMS), LOWORD(dwVerMS), HIWORD(dwVerLS), LOWORD(dwVerLS),
                HIWORD(IE_MINIMUM_VERSIONMS),LOWORD(IE_MINIMUM_VERSIONMS),
                HIWORD(IE_MINIMUM_VERSIONLS),LOWORD(IE_MINIMUM_VERSIONLS));
            ErrorMsg1( hwnd, IDS_IELOWVERSION, IE_MINIMUM_VERSION_HUMAN_READABLE );
            return(FALSE);
        }
***********/


        if (FTurnOffBrowserDefaultChecking())
        {
            SetExitFlags(SXF_RESTOREDEFCHECK);
        }
/*
        hBrowser = ShellExecute(
            NULL,
            cszOpen,
            cszBrowser,
            szTemp,
            NULL,
            SW_SHOWNORMAL);
*/

        // 1/20/97 jmazner Normandy #13454
        // need make sure the ICW completed reg key is set before trying
        // to browse to an html page with IE
        DWORD dwICWCompleted = 0;

        GetICWCompleted(&dwICWCompleted);
        if( 1 != dwICWCompleted )
        {

            SetControlFlags(SCF_ICWCOMPLETEDKEYRESETED);
            
            SetICWCompleted( 1 );
        }

        hresult = InitOle();

        if( FAILED(hresult) )
        {
            DebugOut("ISIGNUP: InitOle failed\n");
            ErrorMsg(hwnd, IDS_LAUNCHFAILED);
            return FALSE;
        }

        SetControlFlags(SCF_BROWSERLAUNCHED);

        //
        // we want to hook up the event sink before doing that first navigate!
        //
/******************* SINK code starts here ***********/

        if (!g_iwbapp)
            return (NULL);

        g_pMySink = new CDExplorerEvents;

        //
        // 5/10/97 ChrisK Windows NT Bug 82032
        //
        g_pMySink->AddRef();

        if ( !g_pMySink )
        {
            DebugOut("Unable to allocate g_pMySink\r\n");
            return FALSE;
        }


        g_pCP = GetConnectionPoint();

        if ( !g_pCP )
        {
            DebugOut("Unable to GetConnectionPoint\r\n");
            return FALSE;
        }

        hresult = g_pCP->Advise(g_pMySink, &(g_pMySink->m_dwCookie));

        if ( FAILED(hresult) )
        {
            DebugOut("Unable to Advise for IConnectionPointContainter:IWebBrowserApp\r\n");
            return FALSE;
        }


/***************  SINK code ends here         *****************/

        // TODO figure out result codes
        hresult = IENavigate( szFullURL );

        if( FAILED(hresult) )
        {
            DebugOut("ISIGNUP: first Navigate _failed_, hresult was failure\n");
            ErrorMsg(hwnd, IDS_LAUNCHFAILED);
            return FALSE;
        }
        else
        {
            DebugOut("ISIGNUP: first Navigate success!, hresult was success\n");
        }

        g_iwbapp->put_FullScreen( TRUE );
        g_iwbapp->put_Visible( TRUE );

        // IE 4 for win95 isn't bringing us up as the foreground window!
        g_iwbapp->get_HWND( (LONG_PTR *)&(pDynShare->hwndBrowser) );
        SetForegroundWindow( pDynShare->hwndBrowser );

#else
        start = time(NULL);


        if (NULL != hwndTemp)
        {
            MSG   msg;

            SetTimer(hwnd, 0, 1000, NULL);
            DebugOut("ISIGNUP: Timer message loop\n");

            while (GetMessage (&msg, NULL, 0, 0))
            {
                if (WM_TIMER == msg.message)
                {
                    DebugOut("ISIGNUP: Got timer message\n");
                    if (NULL == FindBrowser())
                    {
                        DebugOut("ISIGNUP: Browser is gone\n");
                        break;
                    }
                }
                TranslateMessage (&msg) ;
                DispatchMessage  (&msg) ;
            }

            KillTimer(hwnd, 0);
        }


        while (((hBrowser = ShellExecute(
            NULL,
            cszOpen,
            cszBrowser,
            szTemp,
            NULL,
            SW_SHOWNORMAL)) == 16) && ((time(NULL) - start) < 180))
        {
            DebugOut("ISIGNUP: Yielding\n");
            Yield();
        }
#endif

        DebugOut("ISIGNUP: I am back!!\n");         
        if (NULL != pDynShare->hwndLaunch)
        {
            ShowWindow(pDynShare->hwndLaunch, SW_HIDE);
        }

#ifdef WIN16
        if (hBrowser <= (HANDLE)32)
        {
            ErrorMsg(hwnd, IDS_LAUNCHFAILED);

            return FALSE;
        }
#endif

        SetControlFlags(SCF_BROWSERLAUNCHED);
        
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function:    IEInstalled
//
//    Synopsis:    Tests whether a version of Internet Explorer is installed via registry keys
//
//    Arguments:    None
//
//    Returns:    TRUE - Found the IE executable
//                FALSE - No IE executable found
//
//    History:    jmazner        Created        8/19/96    (as fix for Normandy #4571)
//
//-----------------------------------------------------------------------------

#if !defined(WIN16)

BOOL IEInstalled(void)
{
    HRESULT hr;
    HKEY hKey = 0;
    HANDLE hFindResult;
    TCHAR szIELocalPath[MAX_PATH + 1] = TEXT("");
    DWORD dwPathSize;
    WIN32_FIND_DATA foundData;

    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, IE_PATHKEY,0, KEY_READ, &hKey);
    if (hr != ERROR_SUCCESS) return( FALSE );

    dwPathSize = sizeof (szIELocalPath);
    hr = RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szIELocalPath, &dwPathSize);
    RegCloseKey( hKey );
    if (hr != ERROR_SUCCESS) return( FALSE );

    hFindResult = FindFirstFile( szIELocalPath, &foundData );
    FindClose( hFindResult );
    if (INVALID_HANDLE_VALUE == hFindResult) return( FALSE );

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//    Function:    GetAppVersion
//
//    Synopsis:    Gets the major and minor version # of the installed copy of Internet Explorer
//
//    Arguments:    pdwVerNumMS - pointer to a DWORD;
//                  On succesful return, the top 16 bits will contain the major version number,
//                  and the lower 16 bits will contain the minor version number
//                  (this is the data in VS_FIXEDFILEINFO.dwProductVersionMS)
//                pdwVerNumLS - pointer to a DWORD;
//                  On succesful return, the top 16 bits will contain the release number,
//                  and the lower 16 bits will contain the build number
//                  (this is the data in VS_FIXEDFILEINFO.dwProductVersionLS)
//
//    Returns:    TRUE - Success.  *pdwVerNumMS and LS contains installed IE version number
//                FALSE - Failure. *pdVerNumMS == *pdVerNumLS == 0
//
//    History:    jmazner        Created        8/19/96    (as fix for Normandy #4571)
//                jmazner        updated to deal with release.build as well 10/11/96
//
//-----------------------------------------------------------------------------
BOOL GetAppVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS, LPTSTR lpszApp)
{
    HRESULT hr;
    HKEY hKey = 0;
    LPVOID lpVerInfoBlock;
    VS_FIXEDFILEINFO *lpTheVerInfo;
    UINT uTheVerInfoSize;
    DWORD dwVerInfoBlockSize, dwUnused, dwPathSize;
    TCHAR szIELocalPath[MAX_PATH + 1] = TEXT("");


    *pdwVerNumMS = 0;
    *pdwVerNumLS = 0;

    // get path to the IE executable
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszApp,0, KEY_READ, &hKey);
    if (hr != ERROR_SUCCESS) return( FALSE );

    dwPathSize = sizeof (szIELocalPath);
    hr = RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szIELocalPath, &dwPathSize);
    RegCloseKey( hKey );
    if (hr != ERROR_SUCCESS) return( FALSE );

    // now go through the convoluted process of digging up the version info
    dwVerInfoBlockSize = GetFileVersionInfoSize( szIELocalPath, &dwUnused );
    if ( 0 == dwVerInfoBlockSize ) return( FALSE );

    lpVerInfoBlock = GlobalAlloc( GPTR, dwVerInfoBlockSize );
    if( NULL == lpVerInfoBlock ) return( FALSE );

    if( !GetFileVersionInfo( szIELocalPath, NULL, dwVerInfoBlockSize, lpVerInfoBlock ) )
        return( FALSE );

    if( !VerQueryValue(lpVerInfoBlock, TEXT("\\"), (void **)&lpTheVerInfo, &uTheVerInfoSize) )
        return( FALSE );

    *pdwVerNumMS = lpTheVerInfo->dwProductVersionMS;
    *pdwVerNumLS = lpTheVerInfo->dwProductVersionLS;


    GlobalFree( lpVerInfoBlock );

    return( TRUE );
}
#endif // !defined(WIN16)


HWND FindBrowser(void)
{
    HWND hwnd;

    if ((hwnd = FindWindow(szBrowserClass1, NULL)) == NULL)
    {
        if ((hwnd = FindWindow(szBrowserClass2, NULL)) == NULL)
        {
            if( (hwnd = FindWindow(szBrowserClass3, NULL)) == NULL )
            {
                hwnd = FindWindow(szBrowserClassIE4, NULL);
            }
        }
    }

    return hwnd;
}

void KillBrowser(void)
{
#ifdef WIN32

    if( TestControlFlags(SCF_ICWCOMPLETEDKEYRESETED) )
    {
        SetICWCompleted( 0 );
    }

    if( g_iwbapp )
    {
        g_iwbapp->Quit();
    }

    KillOle();

    return;

#else
    // if we launched the browser
 
    if (TestControlFlags(SCF_BROWSERLAUNCHED))
    {
        HWND hwndBrowser;

        // find it and close it
        hwndBrowser = FindBrowser();

        if (NULL != hwndBrowser)
        {
            PostMessage(hwndBrowser, WM_CLOSE, 0, 0L);
        }
        
        SetControlFlags(SCF_BROWSERLAUNCHED);
    }
    
#endif

}

DWORD ImportBrandingInfo(LPCTSTR lpszFile, LPCTSTR lpszConnectoidName)
{
    TCHAR szPath[_MAX_PATH + 1];

    GetWindowsDirectory(szPath, _MAX_PATH + 1);

    // Load the branding library.
    // Note: if we cannot load the library we just fail quietly and assume
    // we cannot brand
    if (LoadBrandingFunctions())
    {
#ifdef WIN32
        
#ifdef UNICODE

        CHAR szEntry[RAS_MaxEntryName];
        CHAR szFile[_MAX_PATH + 1];
        CHAR szAsiPath[_MAX_PATH + 1];
 
        wcstombs(szEntry, lpszConnectoidName, RAS_MaxEntryName);
        wcstombs(szFile, lpszFile, _MAX_PATH + 1);
        wcstombs(szAsiPath, szPath, _MAX_PATH + 1);

        lpfnBrandICW(szFile, szAsiPath, pDynShare->dwBrandFlags, szEntry);
        
#else
 
        lpfnBrandICW(lpszFile, szPath, pDynShare->dwBrandFlags, lpszConnectoidName);

#endif

#else

        lpfnBrandMe(lpszFile, szPath);

#endif

      UnloadBrandingFunctions();
    }

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//    Function:    CallSBSConfig
//
//    Synopsis:    Call into the SBSCFG dll's Configure function to allow SBS to
//                process the .ins file as needed
//
//    Arguements: hwnd -- hwnd of parent, in case sbs wants to put up messages
//                lpszINSFile -- full path to the .ins file
//
//    Returns:    windows error code that sbscfg returns.
//
//    History:    2/19/97    jmazner    Created for Olympus #1106
//
//-----------------------------------------------------------------------------
#if defined(WIN32)
DWORD CallSBSConfig(HWND hwnd, LPCTSTR lpszINSFile)
{
    HINSTANCE hSBSDLL = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    TCHAR lpszConnectoidName[RAS_MaxEntryName] = TEXT("nogood\0");

    //
    // Get name of connectoid we created by looking in autodial
    // We need to pass this name into SBSCFG
    // 5/14/97    jmazner    Windosw NT Bugs #87209
    //
    BOOL fEnabled = FALSE;

    if( NULL == lpfnInetGetAutodial )
    {
        Dprintf("lpfnInetGetAutodial is NULL!!!!");
        return ERROR_INVALID_FUNCTION;
    }

    dwRet = lpfnInetGetAutodial(&fEnabled,lpszConnectoidName,RAS_MaxEntryName);

    Dprintf("ISIGN32: Calling LoadLibrary on %s\n", cszSBSCFG_DLL);
    hSBSDLL = LoadLibrary(cszSBSCFG_DLL);

    // Load DLL and entry point
    if (NULL != hSBSDLL)
    {
        Dprintf("ISIGN32: Calling GetProcAddress on %s\n", cszSBSCFG_CONFIGURE);
        lpfnConfigure = (SBSCONFIGURE)GetProcAddress(hSBSDLL,cszSBSCFG_CONFIGURE);
    }
    else
    {
        // 4/2/97    ChrisK    Olympus 2759
        // If the DLL can't be loaded, pick a specific error message to return.
        dwRet = ERROR_DLL_NOT_FOUND;
        goto CallSBSConfigExit;
    }

    // Call function
    if( hSBSDLL && lpfnConfigure )
    {
        Dprintf("ISIGN32: Calling the Configure entry point: %s, %s\n", lpszINSFile, lpszConnectoidName);
        dwRet = lpfnConfigure(hwnd, (TCHAR *)lpszINSFile, lpszConnectoidName);
    }
    else
    {
        Dprintf("ISIGN32: Unable to call the Configure entry point\n");
        dwRet = GetLastError();
    }

CallSBSConfigExit:
    if( hSBSDLL )
        FreeLibrary(hSBSDLL);
    if( lpfnConfigure )
        lpfnConfigure = NULL;

    Dprintf("ISIGN32: CallSBSConfig exiting with error code %d \n", dwRet);
    return dwRet;
}
#endif


#if defined(WIN16)
#define FILE_BUFFER_SIZE 8092
#else
#define FILE_BUFFER_SIZE 65534
#endif

#ifndef FILE_BEGIN
#define FILE_BEGIN  0
#endif


DWORD MassageFile(LPCTSTR lpszFile)
{
    LPBYTE  lpBufferIn;
    LPBYTE  lpBufferOut;
    HFILE   hfile;
    DWORD   dwRet = ERROR_SUCCESS;

#ifdef WIN32
    if (!SetFileAttributes(lpszFile, FILE_ATTRIBUTE_NORMAL))
    {
        return GetLastError();
    }
#endif

    lpBufferIn = (LPBYTE) LocalAlloc(LPTR, 2 * FILE_BUFFER_SIZE);
    if (NULL == lpBufferIn)
    {
    return ERROR_OUTOFMEMORY;
    }
    lpBufferOut = lpBufferIn + FILE_BUFFER_SIZE;

#ifdef UNICODE
    CHAR szTmp[MAX_PATH+1];
    wcstombs(szTmp, lpszFile, MAX_PATH+1);
    hfile = _lopen(szTmp, OF_READWRITE);
#else
    hfile = _lopen(lpszFile, OF_READWRITE);
#endif
    if (HFILE_ERROR != hfile)
    {
    BOOL    fChanged = FALSE;
    UINT    uBytesOut = 0;
    UINT    uBytesIn = _lread(hfile, lpBufferIn, (UINT)(FILE_BUFFER_SIZE - 1));

    // Note:  we asume, in our use of lpCharIn, that the file is always less than
    // FILE_BUFFER_SIZE
    if (HFILE_ERROR != uBytesIn)
    {
        LPBYTE  lpCharIn = lpBufferIn;
        LPBYTE  lpCharOut = lpBufferOut;

        while ((*lpCharIn) && (FILE_BUFFER_SIZE - 2 > uBytesOut))
        {
          *lpCharOut++ = *lpCharIn;
          uBytesOut++;
          if ((0x0d == *lpCharIn) && (0x0a != *(lpCharIn + 1)))
          {
        fChanged = TRUE;

        *lpCharOut++ = 0x0a;
        uBytesOut++;
          }
          lpCharIn++;
        }

        if (fChanged)
        {
        if (HFILE_ERROR != _llseek(hfile, 0, FILE_BEGIN))
        {
            if (HFILE_ERROR ==_lwrite(hfile, (LPCSTR)lpBufferOut, uBytesOut))
            {
#ifdef WIN32
            dwRet = GetLastError();
#else
            dwRet = ERROR_CANTWRITE;
#endif
            }
        }
        else
        {
#ifdef WIN32
            dwRet = GetLastError();
#else
            dwRet = ERROR_CANTWRITE;
#endif
        }
        }
    }
    else
    {
#ifdef WIN32
        dwRet = GetLastError();
#else
        dwRet = ERROR_CANTREAD;
#endif
    }
    _lclose(hfile);
    }
    else
    {
#ifdef WIN32
    dwRet = GetLastError();
#else
    dwRet = ERROR_CANTOPEN;
#endif
    }

    LocalFree(lpBufferIn);

    return dwRet;
}

#ifndef WIN32
// This function only handle formats like
//      drive:\file, drive:\dir1\file, drive:\dir1\dir2\file, etc
//      file, dir1\file, dir1\dir2\file, etc.
// It does not currently handle
//      drive:file, drive:dir\file, etc.
//      \file, \dir\file, etc.
//      ..\file, ..\dir\file, etc.

DWORD MakeFullPathName(
    LPCTSTR lpDir,
    LPCTSTR lpFileName,
    DWORD nBufferLength,
    LPTSTR lpBuffer)
{
    DWORD dwSize;

    // check for unsupported format
    if ('.' == *lpFileName)
    {
    return 0;
    }

    // check for full path name
    // assuming full path if ":" is in path
    if (strchr(lpFileName, ':') != NULL)
    {
    dwSize = lstrlen(lpFileName);
    if (dwSize > nBufferLength)
    {
        return dwSize;
    }
    lstrcpy(lpBuffer, lpFileName);
    }
    else
    {
    lstrcpy(lpBuffer, lpDir);

    // make sure the directory ends in back slash
    if (lpBuffer[lstrlen(lpBuffer) - 1] != '\\')
    {
        lstrcat(lpBuffer, TEXT("\\"));
    }

    dwSize = lstrlen(lpBuffer) + lstrlen(lpFileName);
    if (dwSize > nBufferLength)
    {
        return dwSize;
    }
    lstrcat(lpBuffer, lpFileName);
    }

    return dwSize;
}


// This function only handle formats like
//      drive:\file, drive:\dir1\file, drive:\dir1\dir2\file, etc
//      file, dir1\file, dir1\dir2\file, etc.
// It does not currently handle
//      drive:file, drive:dir\file, etc.
//      \file, \dir\file, etc.
//      ..\file, ..\dir\file, etc.

DWORD GetFullPathName(
    LPCTSTR lpFileName,
    DWORD nBufferLength,
    LPTSTR lpBuffer,
    LPTSTR FAR *lpFilePart)
{
    DWORD dwSize;
    TCHAR szDir[_MAX_PATH + 1];

    if (_getcwd(szDir, _MAX_PATH + 1) == NULL)
    {
    return 0;
    }

    dwSize = MakeFullPathName(
        szDir,
        lpFileName,
        nBufferLength,
        lpBuffer);

    if ((0 != dwSize) && (NULL != lpFilePart))
    {
    // find last back slash
    *lpFilePart = strrchr(lpBuffer, '\\');
    if (NULL == *lpFilePart)
    {
        // must have been in the unsupported format of drive:file
        return 0;
    }

    // point to the filename
    *lpFilePart += 1;
    }

    return dwSize;
}

BOOL SetCurrentDirectory(
    LPCTSTR  lpPathName)
{
    TCHAR szTemp[_MAX_PATH];
    TCHAR FAR* lpChar;

    lstrcpy(szTemp, lpPathName);

    lpChar = szTemp + lstrlen(szTemp) - 1;

    if (*lpChar == '\\' && *(lpChar - 1) != ':')
    {
    *lpChar = '\0';
    }

    return (0 == _chdir(szTemp));
}
#endif

#ifdef WIN16
extern "C" BOOL CALLBACK __export LaunchDlgProc(
#else
BOOL CALLBACK LaunchDlgProc(
#endif
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam);

HWND LaunchInit(HWND hwndParent)
{
    HWND        hwnd;

    hwnd = CreateDialog (ghInstance, TEXT("Launch"), NULL, (DLGPROC)LaunchDlgProc);
    if (NULL != hwnd)
    {
    CenterWindow(hwnd, NULL);
    }

    return hwnd;
}

#ifdef WIN16
extern "C" BOOL CALLBACK __export LaunchDlgProc(
#else
BOOL CALLBACK LaunchDlgProc(
#endif
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    return FALSE;
}

//+----------------------------------------------------------------------------
//    Function:    ReleaseConnectionStructures
//
//    Synopsis:    Free memory allocated for dialing and error dialogs
//
//    Arguments:    pDDD - pointer to dialing dialog data
//                pEDD - pointer to error dialog data
//
//    Returns:    HRESULT - ERROR_SUCCESS indicates success
//
//    History:
//            7/23/96        ChrisK        Created
//
//-----------------------------------------------------------------------------
HRESULT ReleaseConnectionStructures(LPDIALDLGDATA pDDD, LPERRORDLGDATA pEDD)
{
    DebugOut("ISIGN32:ReleaseConnectionStructures()\r\n");
    if (pDDD->pszMessage)
        LocalFree(pDDD->pszMessage);

    if (pDDD->pszDunFile)
        LocalFree(pDDD->pszDunFile);

    if (pDDD->pszRasEntryName)
        LocalFree(pDDD->pszRasEntryName);

    if (pEDD->pszRasEntryName)
        LocalFree(pEDD->pszRasEntryName);

    if (pEDD->pszMessage)
        LocalFree(pEDD->pszMessage);

    ZeroMemory(pDDD,sizeof(DIALDLGDATA));
    ZeroMemory(pEDD,sizeof(ERRORDLGDATA));

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//    Function:    FillConnectionStructures
//
//    Synopsis:    Fills in structures for dialing and error dialogs
//
//    Arguments:    lpszFile - ISP file name
//                pDDD - pointer to dialing dialog data
//                pEDD - pointer to error dialog data
//
//    Returns:    HRESULT - ERROR_SUCCESS indicates success
//
//    History:
//            7/23/96        ChrisK        Created
//
//-----------------------------------------------------------------------------
static HRESULT FillConnectionStructures(LPCTSTR lpszFile,LPDIALDLGDATA pDDD, LPERRORDLGDATA pEDD)
{
    HRESULT hr = ERROR_SUCCESS;

    DebugOut("ISIGN32:FillConnectionStructures()\r\n");
    //
    // Initialize DDD structure
    //

    ZeroMemory(pDDD,sizeof(DIALDLGDATA));
    pDDD->dwSize = sizeof(DIALDLGDATA);
    pDDD->hInst = ghInstance;
    pDDD->pfnStatusCallback = StatusMessageCallback;

    //
    // Set DUN file, in this case the ISP file contains the contents of a DUN file
    //

    pDDD->pszDunFile = (LPTSTR)LocalAlloc(LPTR,(lstrlen(lpszFile)+1)* sizeof(TCHAR));
    if (0 == pDDD->pszDunFile)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto FillConnectionStructuresExit;
    }
    lstrcpy(pDDD->pszDunFile,lpszFile);

    //
    // Load message string
    //

    pDDD->pszMessage = (LPTSTR)LocalAlloc(LPTR,1024* sizeof(TCHAR));
    if (0 == pDDD->pszMessage)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto FillConnectionStructuresExit;
    }

    if (0 == LoadString(ghInstance,IDS_ISP_DIAL_MESSAGE,
        pDDD->pszMessage,1024))
    {
        hr = GetLastError();
        goto FillConnectionStructuresExit;
    }

    //
    // Get Connectoid name
    //

    pDDD->pszRasEntryName = (LPTSTR)LocalAlloc(LPTR, (RAS_MaxEntryName + 1)*sizeof(TCHAR));
    if (0 == pDDD->pszRasEntryName)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto FillConnectionStructuresExit;
    }
    if( 0 == GetPrivateProfileString(cszEntrySection,cszEntryName,szNull,
        pDDD->pszRasEntryName,RAS_MaxEntryName,lpszFile))
    {
        hr = ERROR_INVALID_PARAMETER;
        goto FillConnectionStructuresExit;
    }

    //
    // Hook in reconnect mechanism
    //
#if !defined(WIN16)
    pDDD->pfnRasDialFunc1 = RasDial1Callback;
#endif

    //
    // Initialize EDD structure
    //
    ZeroMemory(pEDD,sizeof(ERRORDLGDATA));
    pEDD->dwSize = sizeof(ERRORDLGDATA);

    //
    // Copy common fields to Error dialog data
    //
    pEDD->hInst = pDDD->hInst;
    pEDD->pszRasEntryName = (LPTSTR)LocalAlloc(LPTR,(lstrlen(pDDD->pszRasEntryName)+1)*sizeof(TCHAR));
    if (NULL == pEDD->pszRasEntryName)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto FillConnectionStructuresExit;
    }
    lstrcpy(pEDD->pszRasEntryName,pDDD->pszRasEntryName);

    //
    // Allocate buffer for error messages
    //
    pEDD->pszMessage = (LPTSTR)LocalAlloc(LPTR,MAX_ERROR_MESSAGE*sizeof(TCHAR));
    if (NULL == pEDD->pszMessage)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto FillConnectionStructuresExit;
    }

FillConnectionStructuresExit:
    return hr;
}

//+----------------------------------------------------------------------------
//    Function    FShouldRetry
//
//    Synopsis    Given a RAS error should the dialer automatically retry
//
//    Arguments    dwErr - RAS error value
//
//    Returns        TRUE - the dialer should automatically retry
//
//    Histroy        10/16/96    ChrisK    Ported from icwconn1
//
//-----------------------------------------------------------------------------
static BOOL FShouldRetry(DWORD dwErr)
{
    BOOL bRC;

    if (dwErr == ERROR_LINE_BUSY ||
        dwErr == ERROR_VOICE_ANSWER ||
        dwErr == ERROR_NO_ANSWER ||
        dwErr == ERROR_NO_CARRIER ||
        dwErr == ERROR_AUTHENTICATION_FAILURE ||
        dwErr == ERROR_PPP_TIMEOUT ||
        dwErr == ERROR_REMOTE_DISCONNECTION ||
        dwErr == ERROR_AUTH_INTERNAL ||
        dwErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        dwErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    RepairDeviceInfo
//
//    Synopsis:    In some win95 configurations, RasSetEntryProperties will create
//                a connectoid with invalid information about the modem.  This
//                function attempts to correct the problem by reading and
//                rewriting the connectoid.
//
//    Arguments:    lpszEntry - name of connectoid
//
//    Returns:    none
//
//    History:    ChrisK 7/25/97    Created
//
//-----------------------------------------------------------------------------
#if !defined(WIN16)
BOOL RepairDeviceInfo(LPTSTR lpszEntry)
{
    DWORD dwEntrySize = 0;
    DWORD dwDeviceSize = 0;
    LPRASENTRY lpRasEntry = NULL;
    LPBYTE    lpbDevice = NULL;
    OSVERSIONINFO osver;
    TCHAR szTemp[1024];
    BOOL bRC = FALSE;
    RASDIALPARAMS rasdialp;
    BOOL bpassword = FALSE;

    //
    // Validate parameters
    //
    if (NULL == lpszEntry)
    {
        DebugOut("ISIGN32: RepairDevice invalid parameter.\n");
        goto RepairDeviceInfoExit;
    }

    //
    // This fix only applies to golden win95 build 950
    //
    osver.dwOSVersionInfoSize = sizeof(osver);
    GetVersionEx(&osver);
    if (VER_PLATFORM_WIN32_WINDOWS != osver.dwPlatformId ||
        4 != osver.dwMajorVersion ||
        0 != osver.dwMinorVersion ||
        950 != LOWORD(osver.dwBuildNumber))
    {
        DebugOut("ISIGN32: RepairDevice wrong platform.\n");
        wsprintf(szTemp,TEXT("ISIGN32: %d.%d.%d.\n"),
            osver.dwMajorVersion,
            osver.dwMinorVersion,
            LOWORD(osver.dwBuildNumber));
        DebugOut(szTemp);
        goto RepairDeviceInfoExit;
    }

    //
    // Get the RAS Entry
    //
    lpfnRasGetEntryProperties(NULL,
                                lpszEntry,
                                NULL,
                                &dwEntrySize,
                                NULL,
                                &dwDeviceSize);

    lpRasEntry = (LPRASENTRY)LocalAlloc(LPTR, dwEntrySize);
    lpbDevice = (LPBYTE)LocalAlloc(LPTR,dwDeviceSize);

    if (NULL == lpRasEntry || NULL == lpbDevice)
    {
        DebugOut("ISIGN32: RepairDevice Out of memory.\n");
        goto RepairDeviceInfoExit;
    }

    if (sizeof(RASENTRY) != dwEntrySize)
    {
        DebugOut("ISIGN32: RepairDevice Entry size is not equal to sizeof(RASENTRY).\n");
    }

    lpRasEntry->dwSize = sizeof(RASENTRY);

    if (ERROR_SUCCESS != lpfnRasGetEntryProperties(NULL,
                                                    lpszEntry,
                                                    (LPBYTE)lpRasEntry,
                                                    &dwEntrySize,
                                                    lpbDevice,
                                                    &dwDeviceSize))
    {
        DebugOut("ISIGN32: RepairDevice can not read entry.\n");
        goto RepairDeviceInfoExit;
    }

    //
    // Get the connectoid's user ID and password
    //
    ZeroMemory(&rasdialp,sizeof(rasdialp));
    rasdialp.dwSize = sizeof(rasdialp);
    lstrcpyn(rasdialp.szEntryName,lpszEntry,RAS_MaxEntryName);

    if (ERROR_SUCCESS != lpfnRasGetEntryDialParams(NULL,
                                                    &rasdialp,
                                                    &bpassword))
    {
        DebugOut("ISIGN32: RepairDevice can not read dial params.\n");
        goto RepairDeviceInfoExit;
    }

    //
    // Delete the existing entry
    //
    if (ERROR_SUCCESS != lpfnRasDeleteEntry(NULL,lpszEntry))
    {
        DebugOut("ISIGN32: RepairDevice can not delete entry.\n");
        goto RepairDeviceInfoExit;
    }

    //
    // Rewrite entry with "fixed" device size
    //
    if (ERROR_SUCCESS != lpfnRasSetEntryProperties(NULL,
                                                    lpszEntry,
                                                    (LPBYTE)lpRasEntry,
                                                    dwEntrySize,
                                                    NULL,
                                                    0))
    {
        DebugOut("ISIGN32: RepairDevice can not write entry.\n");
        goto RepairDeviceInfoExit;
    }

    //
    // Clear unnecessary values
    //
    rasdialp.szPhoneNumber[0] = '\0';
    rasdialp.szCallbackNumber[0] = '\0';

    //
    // Save connectoid's username and password
    //
    if (ERROR_SUCCESS != lpfnRasSetEntryDialParams(NULL,
                                                    &rasdialp,
                                                    FALSE))
    {
        DebugOut("ISIGN32: RepairDevice can not write dial params.\n");
        goto RepairDeviceInfoExit;
    }


    bRC = TRUE;
RepairDeviceInfoExit:
    if (lpRasEntry)
    {
        LocalFree(lpRasEntry);
    }
    if (lpbDevice)
    {
        LocalFree(lpbDevice);
    }
    return bRC;
}
#endif

//+----------------------------------------------------------------------------
//    Function:    DialConnection
//
//    Synopsis:    Dials connectoin created for ISP file
//
//    Arguments:    lpszFile - ISP file name
//
//    Returns:    HRESULT - ERROR_SUCCESS indicates success
//
//    History:
//            7/22/96        ChrisK        Created
//
//-----------------------------------------------------------------------------
static HRESULT DialConnection(LPCTSTR lpszFile)
{
    HRESULT hr = ERROR_SUCCESS;
    DIALDLGDATA dddISPDialDlg;
    ERRORDLGDATA eddISPDialDlg;
    HINSTANCE hDialDLL = NULL;
    PFNDIALDLG pfnDial = NULL;
    PFNERRORDLG pfnError = NULL;
    INT iRetry;

    DebugOut("ISIGNUP:DialConnection()\r\n");
    //
    // Initize data structures
    //

    hr = FillConnectionStructures(lpszFile,&dddISPDialDlg, &eddISPDialDlg);
    if (ERROR_SUCCESS != hr)
        goto DialConnectionExit;

    //
    // Load functions
    //
    TCHAR szBuffer[MAX_PATH];
    if (GetSystemDirectory(szBuffer,MAX_PATH))
    {
        lstrcat(szBuffer, TEXT("\\"));
        lstrcat(szBuffer, cszICWDIAL_DLL);
        hDialDLL = LoadLibrary(szBuffer);
    }
    
    if (!hDialDLL)
        hDialDLL = LoadLibrary(cszICWDIAL_DLL);
    if (NULL != hDialDLL)
    {
        pfnDial = (PFNDIALDLG)GetProcAddress(hDialDLL,cszICWDIAL_DIALDLG);
        if (NULL != pfnDial)
            pfnError = (PFNERRORDLG)GetProcAddress(hDialDLL,cszICWDIAL_ERRORDLG);
    }

    if(!(hDialDLL && pfnDial && pfnError))
    {
        hr = GetLastError();
        goto DialConnectionExit;
    }

    //
    // Dial connection
    //
    iRetry = 0;
DialConnectionDial:
    hr = pfnDial(&dddISPDialDlg);
    if (1 == hr)
    {
        // This is a special case when the user has killed the browser
        // out from behind the dialer.  In this case, shut down and exit
        // as cleanly as possible.
        goto DialConnectionExit;
    }
    else if (ERROR_USERNEXT != hr)
    {
        if ((iRetry < MAX_RETRIES) && FShouldRetry(hr))
        {
            iRetry++;
            goto DialConnectionDial;
        }
        else
        {
#if !defined(WIN16)
            if (0 == iRetry && ERROR_WRONG_INFO_SPECIFIED == hr)
            {
                DebugOut("ISIGN32: Attempt device info repair.\n");
                if (RepairDeviceInfo(dddISPDialDlg.pszRasEntryName))
                {
                    iRetry++;
                    goto DialConnectionDial;
                }
            }
#endif
            iRetry = 0;
            hr = LoadDialErrorString(hr,eddISPDialDlg.pszMessage,MAX_ERROR_MESSAGE);
            hr = pfnError(&eddISPDialDlg);
            if (ERROR_USERCANCEL == hr)
                goto DialConnectionExit;
            else if (ERROR_USERNEXT == hr)
                goto DialConnectionDial;
            else
                goto DialConnectionExit;
        }
    }

DialConnectionExit:
    ReleaseConnectionStructures(&dddISPDialDlg, &eddISPDialDlg);
    if (hDialDLL)
    {
        FreeLibrary(hDialDLL);
        hDialDLL = NULL;
        pfnDial = NULL;
        pfnError = NULL;
    }
    return hr;
}

#ifdef WIN16
LPVOID MyLocalAlloc(DWORD flag, DWORD size)
{
    LPVOID lpv;

    lpv = calloc(1, (INT)size);

    return lpv;
}

LPVOID MyLocalFree(LPVOID lpv)
{
    free(lpv);

    return NULL;
}
#endif

// ############################################################################
//
//    Name:    ImportMailAndNewsInfo
//
//    Description:    Import information from INS file and set the associated
//                        registry keys for Internet Mail and News (Athena)
//
//    Input:    lpszFile - Fully qualified filename of INS file
//
//    Return:    Error value
//
//    History:        6/27/96        Created
//                    5/12/97        Updated to use the new CreateAccountsFromFile
//                                in Athena's inetcomm.dll.  This function was
//                                created expresly for us to use here.
//                                (See Olympus #266)  -- jmazner
//
// ############################################################################

static DWORD ImportMailAndNewsInfo(LPCTSTR lpszFile, BOOL fConnectPhone)
{
    DWORD dwRet = ERROR_SUCCESS;
#ifndef WIN16
    TCHAR szAcctMgrPath[MAX_PATH + 1] = TEXT("");
    TCHAR szExpandedPath[MAX_PATH + 1] = TEXT("");
    DWORD dwAcctMgrPathSize = 0;
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    HINSTANCE hInst = NULL;
    CONNECTINFO connectInfo;
    TCHAR szConnectoidName[RAS_MaxEntryName] = TEXT("nogood\0");
    PFNCREATEACCOUNTSFROMFILEEX fp = NULL;


    // get path to the AcctMgr dll
    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACCTMGR_PATHKEY,0, KEY_READ, &hKey);
    if ( (dwRet != ERROR_SUCCESS) || (NULL == hKey) )
    {
        Dprintf("ImportMailAndNewsInfo couldn't open reg key %s\n", ACCTMGR_PATHKEY);
        return( dwRet );
    }

    dwAcctMgrPathSize = sizeof (szAcctMgrPath);
    dwRet = RegQueryValueEx(hKey, ACCTMGR_DLLPATH, NULL, NULL, (LPBYTE) szAcctMgrPath, &dwAcctMgrPathSize);


    RegCloseKey( hKey );

    if ( dwRet != ERROR_SUCCESS )
    {
        Dprintf("ImportMailAndNewsInfo: RegQuery failed with error %d\n", dwRet);
        return( dwRet );
    }

    // 6/18/97 jmazner Olympus #6819
    Dprintf("ImportMailAndNewsInfo: read in DllPath of %s\n", szAcctMgrPath);
    ExpandEnvironmentStrings( szAcctMgrPath, szExpandedPath, MAX_PATH + 1 );

    //
    // 6/4/97 jmazner
    // if we created a connectoid, then get its name and use that as the
    // connection type.  Otherwise, assume we're supposed to connect via LAN
    //
    connectInfo.cbSize = sizeof(CONNECTINFO);
    connectInfo.type = CONNECT_LAN;

    if( fConnectPhone && lpfnInetGetAutodial )
    {
        BOOL fEnabled = FALSE;

        dwRet = lpfnInetGetAutodial(&fEnabled,szConnectoidName,RAS_MaxEntryName);

        if( ERROR_SUCCESS==dwRet && szConnectoidName[0] )
        {
            connectInfo.type = CONNECT_RAS;
#ifdef UNICODE
            wcstombs(connectInfo.szConnectoid, szConnectoidName, MAX_PATH);
#else
            lstrcpyn( connectInfo.szConnectoid, szConnectoidName, MAX_PATH );
#endif 
            Dprintf("ImportMailAndNewsInfo: setting connection type to RAS with %s\n", szConnectoidName);
        }
    }

    if( CONNECT_LAN == connectInfo.type )
    {
        Dprintf("ImportMailAndNewsInfo: setting connection type to LAN\n");
#ifdef UNICODE
        wcstombs(connectInfo.szConnectoid, TEXT("I said CONNECT_LAN!"), MAX_PATH);
#else
        lstrcpy( connectInfo.szConnectoid, TEXT("I said CONNECT_LAN!") );
#endif
    }



    hInst = LoadLibrary(szExpandedPath);
    if (hInst)
    {
        fp = (PFNCREATEACCOUNTSFROMFILEEX) GetProcAddress(hInst,"CreateAccountsFromFileEx");
        if (fp)
            hr = fp( (TCHAR *)lpszFile, &connectInfo, NULL );
    }
    else
    {
        Dprintf("ImportMailAndNewsInfo unable to LoadLibrary on %s\n", szAcctMgrPath);
    }

    //
    // Clean up and release resourecs
    //
    if( hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    if( fp )
    {
        fp = NULL;
    }


//ImportMailAndNewsInfoExit:
#endif
    return dwRet;
}

// ############################################################################
//
//    Name:    WriteMailAndNewsKey
//
//    Description:    Read a string value from the given INS file and write it
//                    to the registry
//
//    Input:    hKey - Registry key where the data will be written
//            lpszSection - Section name inside of INS file where data is read
//                from
//            lpszValue -    Name of value to read from INS file
//            lpszBuff - buffer where data will be read into
//            dwBuffLen - size of lpszBuff
//            lpszSubKey - Value name where information will be written to
//            dwType - data type (Should always be REG_SZ)
//            lpszFileName - Fully qualified filename to INS file
//
//    Return:    Error value
//
//    Histroy:        6/27/96            Created
//                    5/12/97            Commented out -- no longer needed
//                                    (See Olympus #266)
//
// ############################################################################
/***
static HRESULT WriteMailAndNewsKey(HKEY hKey, LPCTSTR lpszSection, LPCTSTR lpszValue,
                            LPTSTR lpszBuff, DWORD dwBuffLen,LPCTSTR lpszSubKey,
                            DWORD dwType, LPCTSTR lpszFile)
{
#ifndef WIN16
    ZeroMemory(lpszBuff,dwBuffLen);
    GetPrivateProfileString(lpszSection,lpszValue,TEXT(""),lpszBuff,dwBuffLen,lpszFile);
    if (lstrlen(lpszBuff))
    {
        return RegSetValueEx(hKey,lpszSubKey,0,dwType,(CONST BYTE*)lpszBuff,
            sizeof(TCHAR)*(lstrlen(lpszBuff)+1));
    }
    else
    {
        DebugOut("ISIGNUP: WriteMailAndNewsKey, missing value in INS file\n");
        return ERROR_NO_MORE_ITEMS;
    }
#else
    return ERROR_GEN_FAILURE;
#endif
}
***/


// ############################################################################
//
//    Name:    PreparePassword
//
//    Description:    Encode given password and return value in place.  The
//                    encoding is done right to left in order to avoid having
//                    to allocate a copy of the data.  The encoding uses base64
//                    standard as specified in RFC 1341 5.2
//
//    Input:    szBuff - Null terminated data to be encoded
//            dwBuffLen - Full length of buffer, this should exceed the length of
//                the input data by at least 1/3
//
//    Return:    Error value
//
//    Histroy:        6/27/96            Created
//
// ############################################################################
static HRESULT PreparePassword(LPTSTR szBuff, DWORD dwBuffLen)
{
    DWORD dw;
    LPTSTR szOut = NULL;
    LPTSTR szNext = NULL;
    HRESULT hr = ERROR_SUCCESS;
    BYTE bTemp = 0;
    DWORD dwLen = 0;

    dwLen = lstrlen(szBuff);
    if (!dwLen)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto PreparePasswordExit;
    }

    // Calculate the size of the buffer that will be needed to hold
    // encoded data
    //

    szNext = &szBuff[dwLen-1];
    dwLen = (((dwLen % 3 ? (3-(dwLen%3)):0) + dwLen) * 4 / 3);

    if (dwBuffLen < dwLen+1)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto PreparePasswordExit;
    }

    szOut = &szBuff[dwLen];
    *szOut-- = '\0';

    // Add padding = characters
    //

    switch (lstrlen(szBuff) % 3)
    {
    case 0:
        // no padding
        break;
    case 1:
        *szOut-- = 64;
        *szOut-- = 64;
        *szOut-- = (*szNext & 0x3) << 4;
        *szOut-- = (*szNext-- & 0xFC) >> 2;
        break;
    case 2:
        *szOut-- = 64;
        *szOut-- = (*szNext & 0xF) << 2;
        *szOut = ((*szNext-- & 0xF0) >> 4);
        *szOut-- |= ((*szNext & 0x3) << 4);
        *szOut-- = (*szNext-- & 0xFC) >> 2;
    }

    // Encrypt data into indicies
    //

    while (szOut > szNext && szNext >= szBuff)
    {
        *szOut-- = *szNext & 0x3F;
        *szOut = ((*szNext-- & 0xC0) >> 6);
        *szOut-- |= ((*szNext & 0xF) << 2);
        *szOut = ((*szNext-- & 0xF0) >> 4);
        *szOut-- |= ((*szNext & 0x3) << 4);
        *szOut-- = (*szNext-- & 0xFC) >> 2;
    }

    // Translate indicies into printable characters
    //

    szNext = szBuff;

    // BUG OSR#10435--if there is a 0 in the generated string of base-64
    // encoded digits (this can happen if the password is "Willypassword"
    // for example), then instead of encoding the 0 to 'A', we just quit
    // at this point, produces an invalid base-64 string.

    // while (*szNext)
    for(dw=0; dw<dwLen; dw++)
        *szNext = arBase64[*szNext++];

PreparePasswordExit:
    return hr;
}

// ############################################################################
//
//    Name: FIsAthenaPresent
//
//    Description:    Determine if Microsoft Internet Mail And News client (Athena)
//                    is installed
//
//    Input:    none
//
//    Return:    TRUE - Athena is installed
//            FALSE - Athena is NOT installed
//
//    History:        7/1/96            Created
//                    5/14/97            No longer needed after work for Olympus #266
//
// ############################################################################
/****
static BOOL FIsAthenaPresent()
{
#ifndef WIN16
    TCHAR szBuff[MAX_PATH + 1];
    HRESULT hr = ERROR_SUCCESS;
    HINSTANCE hInst = NULL;
    LONG lLen = 0;

    // Get path to Athena client
    //

    lLen = MAX_PATH;
    hr = RegQueryValue(HKEY_CLASSES_ROOT,MAIL_NEWS_INPROC_SERVER32,szBuff,&lLen);
    if (hr == ERROR_SUCCESS)
    {
        // Attempt to load client
        //

        hInst = LoadLibrary(szBuff);
        if (!hInst)
        {
            DebugOut("ISIGNUP: Internet Mail and News server didn't load.\n");
            hr = ERROR_FILE_NOT_FOUND;
        } else {
            FreeLibrary(hInst);
        }
        hInst = NULL;
    }

    return (hr == ERROR_SUCCESS);
#else
    return FALSE;
#endif // win16
}
*****/

// ############################################################################
//
//    Name:    FTurnOffBrowserDefaultChecking
//
//    Description:    Turn Off IE checking to see if it is the default browser
//
//    Input:    none
//
//    Output:    TRUE - success
//            FALSE - failed
//
//    History:        7/2/96            Created
//
// ############################################################################
static BOOL FTurnOffBrowserDefaultChecking()
{
    BOOL bRC = TRUE;
#ifndef WIN16
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;

    //
    // Open IE settings registry key
    //
    if (RegOpenKey(HKEY_CURRENT_USER,cszDEFAULT_BROWSER_KEY,&hKey))
    {
        bRC = FALSE;
        goto FTurnOffBrowserDefaultCheckingExit;
    }

    //
    // Read current settings for check associations
    //
    dwType = 0;
    dwSize = sizeof(pDynShare->szCheckAssociations);
    ZeroMemory(pDynShare->szCheckAssociations, dwSize);
    RegQueryValueEx(hKey,
                    cszDEFAULT_BROWSER_VALUE,
                    0,
                    &dwType,
                    (LPBYTE)pDynShare->szCheckAssociations,
                    &dwSize);
    
    // ignore return value, even if the calls fails we are going to try
    // to change the setting to "NO"

    //
    // Set value to "no" to turn off checking
    //
    if (RegSetValueEx(hKey,
                      cszDEFAULT_BROWSER_VALUE,
                      0,
                      REG_SZ,
                      (LPBYTE)cszNo,
                      sizeof(TCHAR)*(lstrlen(cszNo)+1)))
    {
        bRC = FALSE;
        goto FTurnOffBrowserDefaultCheckingExit;
    }

    //
    // Clean up and return
    //
FTurnOffBrowserDefaultCheckingExit:
    if (hKey)
        RegCloseKey(hKey);
    if (bRC)
        SetExitFlags(SXF_RESTOREDEFCHECK);
    hKey = NULL;
#endif
    return bRC;
}

// ############################################################################
//
//    Name:    FRestoreBrowserDefaultChecking
//
//    Description:    Restore IE checking to see if it is the default browser
//
//    Input:    none
//
//    Output:    TRUE - success
//            FALSE - failed
//
//    History:        7/2/96            Created
//
// ############################################################################
static BOOL FRestoreBrowserDefaultChecking()
{
    BOOL bRC = TRUE;
#ifndef WIN16
    HKEY hKey = NULL;

    //
    // Open IE settings registry key
    //
    if (RegOpenKey(HKEY_CURRENT_USER,cszDEFAULT_BROWSER_KEY,&hKey))
    {
        bRC = FALSE;
        goto FRestoreBrowserDefaultCheckingExit;
    }
         
    //
    // Set value to original value
    //
    if (RegSetValueEx(hKey,
                      cszDEFAULT_BROWSER_VALUE,
                      0,
                      REG_SZ,
                      (LPBYTE)pDynShare->szCheckAssociations,
                      sizeof(TCHAR)*(lstrlen(pDynShare->szCheckAssociations)+1)))
    {
        bRC = FALSE;
        goto FRestoreBrowserDefaultCheckingExit;
    }

FRestoreBrowserDefaultCheckingExit:
    if (hKey)
        RegCloseKey(hKey);
    hKey = NULL;
#endif
    return bRC;
}


#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function:     SaveIEWindowPlacement
//
//    Synopsis:    Saves the registry value for IE window placement into a global for later restoration
//                Should only be called once in the signup process.
//
//    Arguments:    None, but uses global pbIEWindowPlacement, which it expects to be NULL
//
//    Returns:      TRUE - The value was read and stored
//                  FALSE - function failed.
//
//    History:      8/21/96     jmazner        Created    (as fix for Normandy #4592)
//                  10/11/96    jmazner        updated to dynamicaly determine size of the key
//
//-----------------------------------------------------------------------------
BOOL SaveIEWindowPlacement( void )
{
    HKEY    hKey = NULL;
    //DWORD dwSize = 0;
    LONG    lQueryErr = 0xEE; // initialize to something strange
    DWORD   dwIEWindowPlacementSize = 0;
    PBYTE   pbIEWindowPlacement = NULL;
    
    // Argh, no Assert defined in isign32!
    if ( pDynShare->dwIEWindowPlacementSize != 0 )
    {
#if DEBUG
        DebugOut("ISIGN32: SaveIEWindowPlacement called a second time!\n");
        MessageBox(
            hwndMain,
            TEXT("ISIGN32 ERROR: Window_Placement global var is not null --jmazner\n"),
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONEXCLAMATION |
            MB_OKCANCEL);
#endif
        DebugOut("ISIGN32: SaveIEWindowPlacement called a second time!\n");
        goto SaveIEWindowPlacementErrExit;
    }
    
    //
    // Open IE settings registry key
    //
    if ( ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                       cszDEFAULT_BROWSER_KEY,
                                       NULL,
                                       KEY_READ,
                                       &hKey) )
        goto SaveIEWindowPlacementErrExit;


    // Determine size of buffer needed to hold the window_placement key


     lQueryErr = RegQueryValueEx(hKey,
                          cszIEWINDOW_PLACEMENT,
                          NULL,
                          NULL,
                          NULL,
                          &dwIEWindowPlacementSize);

    // for unknown reasons, lQueryErr is ending up as ERROR_SUCCESS after this call!
//    if( ERROR_MORE_DATA != lQueryErr )
//        goto SaveIEWindowPlacementErrExit;


    ISIGN32_ASSERT(sizeof(pDynShare->pbIEWindowPlacement) >= dwIEWindowPlacementSize);
    
    pbIEWindowPlacement = pDynShare->pbIEWindowPlacement;
    
    //
    // Read current settings for window_placement
    //
    //dwSize = sizeof(pbIEWindowPlacement);
    //ZeroMemory(pbIEWindowPlacement,dwSize);
    lQueryErr = RegQueryValueEx(hKey,
                          cszIEWINDOW_PLACEMENT,
                          NULL,
                          NULL,
                          (LPBYTE)pbIEWindowPlacement,
                          &dwIEWindowPlacementSize);

    if (ERROR_SUCCESS != lQueryErr)
    {
#ifdef DEBUG
        MessageBox(
            hwndMain,
            TEXT("ISIGNUP ERROR: Window_Placement reg key is longer than expected! --jmazner\n"),
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONEXCLAMATION |
            MB_OKCANCEL);
#endif
        DebugOut("ISIGN32 ERROR: SaveIEWindowPlacement RegQueryValue failed\n");
        goto SaveIEWindowPlacementErrExit;
    }

    RegCloseKey( hKey );

    pDynShare->dwIEWindowPlacementSize = dwIEWindowPlacementSize;    

    return( TRUE );

SaveIEWindowPlacementErrExit:
    if ( hKey ) RegCloseKey( hKey );
    return( FALSE );

}

// note we're still in #if !defined(WIN16)

//+----------------------------------------------------------------------------
//
//    Function:    RestoreIEWindowPlacement
//
//    Synopsis:    Restores the registry value for IE window placement from a global
//                 NOTE:  compatability with Nashville/IE 4?
//
//    Arguments:   None
//
//    Returns:     TRUE - The value was restored
//                 FALSE - function failed.
//
//    History:     jmazner        Created        8/21/96    (as fix for Normandy #4592)
//
//-----------------------------------------------------------------------------
BOOL RestoreIEWindowPlacement( void )
{
    HKEY hKey = NULL;
     
    if ( pDynShare->dwIEWindowPlacementSize == 0 )
    {
        DebugOut("ISIGN32: RestoreIEWindowPlacement called with null global!\n");
        return( FALSE );
    }

    //
    // Open IE settings registry key
    //
    if ( ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                       cszDEFAULT_BROWSER_KEY,
                                       NULL,
                                       KEY_SET_VALUE,
                                       &hKey) )
        return( FALSE );

    //
    // Write saved settings for window_placement
    //
    if (ERROR_SUCCESS != RegSetValueEx(hKey,
                          cszIEWINDOW_PLACEMENT,
                          NULL,
                          REG_BINARY,
                          (LPBYTE)pDynShare->pbIEWindowPlacement,
                          pDynShare->dwIEWindowPlacementSize) )
        return( FALSE );

    RegCloseKey( hKey );

    pDynShare->pbIEWindowPlacement[0] = (TCHAR) 0;
    pDynShare->dwIEWindowPlacementSize = 0;
    
    return( TRUE );
}
#endif //(!defined win16)


//+----------------------------------------------------------------------------
//
//    Function:    DeleteFileKindaLikeThisOne
//
//  Synopsis:    This function serve the single function of cleaning up after
//                IE3.0, because IE3.0 will issue multiple POST and get back
//                multiple .INS files.  These files contain sensative data that
//                we don't want lying around, so we are going out, guessing what
//                their names are, and deleting them.
//
//    Arguments:    lpszFileName - the full name of the file to delete
//
//    Returns:    error code, ERROR_SUCCESS == success
//
//    History:    7/96    ChrisK    Created
//                7/96    ChrisK    Bug fix for long filenames
//                8/2/96    ChrisK    Port to Win32
//-----------------------------------------------------------------------------

static HRESULT DeleteFileKindaLikeThisOne(LPCTSTR lpszFileName)
{
    HRESULT hr = ERROR_SUCCESS;
#ifndef WIN16
    LPCTSTR lpNext = NULL;
    WORD wRes = 0;
    HANDLE hFind = NULL;
    WIN32_FIND_DATA sFoundFile;
    TCHAR szPath[MAX_PATH];
    TCHAR szSearchPath[MAX_PATH + 1];
    LPTSTR lpszFilePart = NULL;

    // Validate parameter
    //

    if (!lpszFileName || lstrlen(lpszFileName) <= 4)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto DeleteFileKindaLikeThisOneExit;
    }

    // Determine the directory name where the INS files are located
    //

    ZeroMemory(szPath,MAX_PATH);
    if (GetFullPathName(lpszFileName,MAX_PATH,szPath,&lpszFilePart))
    {
        *lpszFilePart = '\0';
    } else {
        hr = GetLastError();
        goto DeleteFileKindaLikeThisOneExit;
    };

    // Munge filename into search parameters
    //

    lpNext = &lpszFileName[lstrlen(lpszFileName)-4];

    if (CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,lpNext,4,TEXT(".INS"),4) != 2) goto DeleteFileKindaLikeThisOneExit;

    ZeroMemory(szSearchPath,MAX_PATH + 1);
    lstrcpyn(szSearchPath,szPath,MAX_PATH);
    lstrcat(szSearchPath,TEXT("*.INS"));

    // Start wiping out files
    //

    ZeroMemory(&sFoundFile,sizeof(sFoundFile));
    hFind = FindFirstFile(szSearchPath,&sFoundFile);
    if (hFind)
    {
        do {
            lstrcpy(lpszFilePart,sFoundFile.cFileName);
            SetFileAttributes(szPath,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szPath);
            ZeroMemory(&sFoundFile,sizeof(sFoundFile));
        } while (FindNextFile(hFind,&sFoundFile));
        FindClose(hFind);
    }

    hFind = NULL;

DeleteFileKindaLikeThisOneExit:
#endif
    return hr;
}


#if defined(WIN16)

#define MAIN_WNDCLASS_NAME      "IE_DialerMainWnd"
#define IEDIAL_REGISTER_MSG     "IEDialQueryPrevInstance"
#define IEDIALMSG_QUERY            (0)
#define IEDIALMSG_SHUTDOWN        (1)
#define    IEDIAL_SHUTDOWN_TIMER    1001

//+---------------------------------------------------------------------------
//
//  Function:   ShutDownIEDial()
//
//  Synopsis:   Shutdown the instance IEDial if it running and
//                in disconnected state - otherwise it interfers with dialing
//                from icwconn2
//
//  Arguments:  [hWnd - Window handle (used for creating timer)
//
//    Returns:    TRUE if successful shutdown or instance does not exist
//                FALSE otherwise
//
//  History:    8/24/96        VetriV        Created
//
//----------------------------------------------------------------------------
BOOL ShutDownIEDial(HWND hWnd)
{
    HINSTANCE hInstance;
    static UINT WM_IEDIAL_INSTANCEQUERY = 0;
    UINT uiAttempts = 0;
    MSG   msg;

    //
    // Check if IEDial is running
    //
    hInstance = FindWindow(MAIN_WNDCLASS_NAME, NULL);
    if (NULL != hInstance)
    {
        if (0 == WM_IEDIAL_INSTANCEQUERY)
            WM_IEDIAL_INSTANCEQUERY= RegisterWindowMessage(IEDIAL_REGISTER_MSG);


        //
        // Check if it is in connected state
        //
        if (SendMessage(hInstance, WM_IEDIAL_INSTANCEQUERY,
                            IEDIALMSG_QUERY, 0))
        {
            //
            // Not connected - Send quit message
            //
            SendMessage(hInstance, WM_IEDIAL_INSTANCEQUERY,
                            IEDIALMSG_SHUTDOWN, 0);
            return TRUE;
        }


        //
        // If IEDIAL is in connected state try for another 3 seconds
        // waiting for 1 second between tries
        // We have to do this because, IEDIAL can take upto 2 seconds
        // to realize it lost the connection!!
        //
        SetTimer(hWnd, IEDIAL_SHUTDOWN_TIMER, 1000, NULL);
        DebugOut("ISIGNUP: IEDIAL Timer message loop\n");

        while (GetMessage (&msg, NULL, 0, 0))
        {
            if (WM_TIMER == msg.message)
            {
                //
                // Check if it is in connected state
                //
                if (SendMessage(hInstance, WM_IEDIAL_INSTANCEQUERY,
                                    IEDIALMSG_QUERY, 0))
                {
                    //
                    // Not connected - Send quit message
                    //
                    SendMessage(hInstance, WM_IEDIAL_INSTANCEQUERY,
                                    IEDIALMSG_SHUTDOWN, 0);
                    break;
                }

                //
                // If we have tried thrice - get out
                //
                if (++uiAttempts > 3)
                    break;
            }
            else
            {
                TranslateMessage (&msg) ;
                DispatchMessage  (&msg) ;
            }
        }
        KillTimer(hWnd, IEDIAL_SHUTDOWN_TIMER);

        if (uiAttempts > 3)
            return FALSE;
    }

    return TRUE;
}

#endif // WIN16

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function    LclSetEntryScriptPatch
//
//    Synopsis    Softlink to RasSetEntryPropertiesScriptPatch
//
//    Arguments    see RasSetEntryPropertiesScriptPatch
//
//    Returns        see RasSetEntryPropertiesScriptPatch
//
//    Histroy        10/3/96    ChrisK Created
//
//-----------------------------------------------------------------------------
typedef BOOL (WINAPI* LCLSETENTRYSCRIPTPATCH)(LPTSTR, LPTSTR);
BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry)
{
    HINSTANCE hinst = NULL;
    LCLSETENTRYSCRIPTPATCH fp = NULL;
    BOOL bRC = FALSE;

    hinst = LoadLibrary(TEXT("ICWDIAL.DLL"));
    if (hinst)
    {
        fp = (LCLSETENTRYSCRIPTPATCH)GetProcAddress(hinst,"RasSetEntryPropertiesScriptPatch");
        if (fp)
            bRC = (fp)(lpszScript,lpszEntry);
        FreeLibrary(hinst);
        hinst = NULL;
        fp = NULL;
    }
    return bRC;
}
#endif //!WIN16


#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function    IsMSDUN12Installed
//
//    Synopsis    Check if MSDUN 1.2 or higher is installed
//
//    Arguments    none
//
//    Returns        TRUE - MSDUN 1.2 is installed
//
//    History        5/28/97 ChrisK created for Olympus Bug 4392
//
//-----------------------------------------------------------------------------

//
// 8/5/97 jmazner Olympus #11404
//
//#define DUN_12_Version (1.2e0f)
#define DUN_12_Version ((double)1.2)
BOOL IsMSDUN12Installed()
{
    TCHAR szBuffer[MAX_PATH] = {TEXT("\0")};
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(szBuffer);
    FLOAT flVersion = 0e0f;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\RemoteAccess"),
        &hkey))
    {
        goto IsMSDUN12InstalledExit;
    }

    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
        TEXT("Version"),
        NULL,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize))
    {
        goto IsMSDUN12InstalledExit;
    }

#ifdef UNICODE
    CHAR szTmp[MAX_PATH];
    wcstombs(szTmp, szBuffer, MAX_PATH+1);
    bRC = DUN_12_Version <= atof(szTmp);
#else
    bRC = DUN_12_Version <= atof(szBuffer);
#endif
IsMSDUN12InstalledExit:
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    IsScriptingInstalled
//
//    Synopsis    Check to see if scripting is already installed
//
//    Arguments    none
//
//    Returns        TRUE - scripting has been installed
//
//    History        10/14/96    ChrisK    Creaed
//
//-----------------------------------------------------------------------------
static BOOL IsScriptingInstalled()
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    LONG lrc = 0;
    HINSTANCE hInst = NULL;
    TCHAR szData[MAX_PATH+1];
    OSVERSIONINFO osver;
    //
    //    Check version information
    //
    ZeroMemory(&osver,sizeof(osver));
    osver.dwOSVersionInfoSize = sizeof(osver);
    GetVersionEx(&osver);

    //
    // check for SMMSCRPT.DLL being present
    //

    if (VER_PLATFORM_WIN32_NT == osver.dwPlatformId)
    {
        bRC = TRUE;
    }
    else if (IsMSDUN12Installed())
    {
        bRC = TRUE;
    }
    else
    {
        //
        // Verify scripting by checking for smmscrpt.dll in RemoteAccess registry key
        //
        if (1111 <= (osver.dwBuildNumber & 0xFFFF))
        {
            bRC = TRUE;
        }
        else
        {
            bRC = FALSE;
            hkey = NULL;
            lrc=RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\SMM_FILES\\PPP"),&hkey);
            if (ERROR_SUCCESS == lrc)
            {
                dwSize = sizeof(TCHAR)*MAX_PATH;
                lrc = RegQueryValueEx(hkey,TEXT("Path"),0,&dwType,(LPBYTE)szData,&dwSize);
                if (ERROR_SUCCESS == lrc)
                {
                    if (0 == lstrcmpi(szData,TEXT("smmscrpt.dll")))
                        bRC = TRUE;
                }
            }
            if (hkey)
                RegCloseKey(hkey);
            hkey = NULL;
        }

        //
        // Verify that the DLL can be loaded
        //
        if (bRC)
        {
            hInst = LoadLibrary(TEXT("smmscrpt.dll"));
            if (hInst)
                FreeLibrary(hInst);
            else
                bRC = FALSE;
            hInst = NULL;
        }
    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    InstallScripter
//
//    Synopsis    Install scripting on win95 950.6 builds (not on OSR2)
//
//    Arguments    none
//
//    Returns        none
//
//    History        10/9/96    ChrisK    Copied from mt.cpp in \\trango sources
//
//-----------------------------------------------------------------------------
static void InstallScripter(void)
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    MSG                    msg ;
    DWORD                iWaitResult = 0;
    HINSTANCE            hInst = LoadLibrary(TEXT("smmscrpt.dll"));

    DebugOut("ISIGN32: Install Scripter.\r\n");
    //
    // Check if we need to install scripting
    //
    if (!IsScriptingInstalled())
    {

        memset(&pi, 0, sizeof(pi));
        memset(&si, 0, sizeof(si));
        if(!CreateProcess(NULL, TEXT("icwscrpt.exe"), NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        {
            DebugOut("ISIGN32: Cant find ICWSCRPT.EXE\r\n");
        }
        else
        {
            DebugOut("ISIGN32: Launched ICWSCRPT.EXE. Waiting for exit.\r\n");
            //
            // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
            //
            while((iWaitResult=MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
            {
                //
                // read all of the messages in this next loop
                   // removing each message as we read it
                //
                   while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                   {
                    DebugOut("ISIGN32: Got msg\r\n");
                    //
                    // how to handle quit message?
                    //
                    if (msg.message == WM_QUIT)
                    {
                        DebugOut("ISIGN32: Got quit msg\r\n");
                        goto done;
                    }
                    else
                        DispatchMessage(&msg);
                }
            }
        done:
             CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            DebugOut("ISIGN32: ICWSCRPT.EXE done\r\n");
        }
    }
}

//+----------------------------------------------------------------------------
//
//    Function:    FGetSystemShutdownPrivledge
//
//    Synopsis:    For windows NT the process must explicitly ask for permission
//                to reboot the system.
//
//    Arguements:    none
//
//    Return:        TRUE - privledges granted
//                FALSE - DENIED
//
//    History:    8/14/96    ChrisK    Created
//
//    Note:        BUGBUG for Win95 we are going to have to softlink to these
//                entry points.  Otherwise the app won't even load.
//                Also, this code was originally lifted out of MSDN July96
//                "Shutting down the system"
//-----------------------------------------------------------------------------
static BOOL FGetSystemShutdownPrivledge()
{
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;
    BOOL bRC = FALSE;
    OSVERSIONINFO osver;

    ZeroMemory(&osver,sizeof(osver));
    osver.dwOSVersionInfoSize = sizeof(osver);
    if (!GetVersionEx(&osver))
        goto FGetSystemShutdownPrivledgeExit;

    if (VER_PLATFORM_WIN32_NT == osver.dwPlatformId)
    {
        //
        // Get the current process token handle
        // so we can get shutdown privilege.
        //

        if (!OpenProcessToken(GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
                goto FGetSystemShutdownPrivledgeExit;

        //
        // Get the LUID for shutdown privilege.
        //

        ZeroMemory(&tkp,sizeof(tkp));
        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME,
                &tkp.Privileges[0].Luid);

        tkp.PrivilegeCount = 1;  /* one privilege to set    */
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        //
        // Get shutdown privilege for this process.
        //

        AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
            (PTOKEN_PRIVILEGES) NULL, 0);

        if (ERROR_SUCCESS == GetLastError())
            bRC = TRUE;
    }
    else
    {
        bRC = TRUE;
    }

FGetSystemShutdownPrivledgeExit:
    if (hToken) CloseHandle(hToken);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Function    VerifyRasServicesRunning
//
//    Synopsis    Make sure that the RAS services are enabled and running
//
//    Arguments    HWND - parent window
//
//    Return        FALSE - if the services couldn't be started
//
//    History        10/16/96    ChrisK    Created
//-----------------------------------------------------------------------------
typedef HRESULT (WINAPI *PFINETSTARTSERVICES)(void);
#define MAX_STRING 256
static BOOL VerifyRasServicesRunning(HWND hwnd)
{
    HINSTANCE hInst = NULL;
    FARPROC fp = NULL;
    BOOL bRC = FALSE;
    HRESULT hr = ERROR_SUCCESS;

    hInst = LoadLibrary(TEXT("INETCFG.DLL"));
    if (hInst)
    {
        fp = GetProcAddress(hInst, "InetStartServices");
        if (fp)
        {
            //
            // Check Services
            //
            hr = ((PFINETSTARTSERVICES)fp)();
            if (ERROR_SUCCESS == hr)
            {
                bRC = TRUE;
            }
            else
            {
                //
                // Report the erorr
                //
                TCHAR szMsg[MAX_STRING + 1];

                    LoadString(
                        ghInstance,
                        IDS_SERVICEDISABLED,
                        szMsg,
                        sizeof(szMsg));

                //
                // we reach here in the condition when
                // 1) user deliberately removes some file
                // 2) Did not reboot after installing RAS
                // MKarki - (5/7/97) - Fix for Bug #4004
                //
                MessageBox(
                    hwnd,
                    szMsg,
                    cszAppName,
                    MB_OK| MB_ICONERROR | MB_SETFOREGROUND
                    );
                bRC = FALSE;
            }
        }
        FreeLibrary(hInst);
    }
    
#if !defined(WIN16)

    if (bRC)
    {
        SetControlFlags(SCF_RASREADY);
    }
    else
    {
        ClearControlFlags(SCF_RASREADY);
    }

#endif
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    GetDeviceSelectedByUser
//
//    Synopsis    Get the name of the RAS device that the user had already picked
//
//    Arguements    szKey - name of sub key
//                szBuf - pointer to buffer
//                dwSize - size of buffer
//
//    Return        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL GetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf, DWORD dwSize)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    DWORD dwType = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY,&hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,szKey,0,&dwType,
            (LPBYTE)szBuf,&dwSize))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Function    SetDeviceSelectedByUser
//
//    Synopsis    Write user's device selection to registry
//
//    Arguments    szKey - name of key
//                szBuf - data to write to key
//
//    Returns        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL SetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf)
{
    BOOL bRC = FALSE;
    HKEY hkey = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY,&hkey))
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkey,szKey,0,REG_SZ,
            (LPBYTE)szBuf,sizeof(TCHAR)*lstrlen(szBuf)))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Funciton    DeleteUserDeviceSelection
//
//    Synopsis    Remove registry keys with device selection
//
//    Arguments    szKey - name of value to remove
//
//    Returns        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL DeleteUserDeviceSelection(LPTSTR szKey)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY,&hkey))
        bRC = (ERROR_SUCCESS == RegDeleteValue(hkey,szKey));
    return bRC;
}
//+---------------------------------------------------------------------------
//
//  Function:   ConfigRasEntryDevice()
//
//  Synopsis:   Checks whether user has already specified a modem to use;
//                If so, verifies that modem is valid.
//                If not, or if modem is invalid, presents user a dialog
//                to choose which modem to use (if only one modem is installed,
//                it automaticaly selects that device and bypasses the dialog)
//
//  Arguments:  lpRasEntry - Pointer to the RasEntry whose szDeviceName and
//                             szDeviceType members you wish to verify/configure
//
//    Returns:    ERROR_CANCELLED - Had to bring up "Choose Modem" dialog, and
//                                  and user hit its "Cancel" button
//                Otherwise returns any error code encountered.
//                ERROR_SUCCESS indicates success.
//
//  History:    5/18/96     VetriV    Created
//
//----------------------------------------------------------------------------
DWORD ConfigRasEntryDevice( LPRASENTRY lpRasEntry )
{
    DWORD    dwRet = ERROR_SUCCESS;
    CEnumModem  EnumModem;

    GetDeviceSelectedByUser(DEVICENAMEKEY, g_szDeviceName, sizeof(g_szDeviceName));
    GetDeviceSelectedByUser(DEVICETYPEKEY, g_szDeviceType, sizeof(g_szDeviceType));

    dwRet = EnumModem.GetError();
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }


    // If there are no modems, we're horked
    if (0 == EnumModem.GetNumDevices())
    {
        DebugOut("ISIGN32: import.cpp: ConfigRasEntryDevice: ERROR: No modems installed!\n");

        //
        // ChrisK Olympus 6796 6/24/97
        // If there is no modem currently configured, there will be by the time the
        // connectoid is created.
        //
        return ERROR_SUCCESS;
    }


    // Validate the device if possible
    if ( lpRasEntry->szDeviceName[0] && lpRasEntry->szDeviceType[0] )
    {
        // Verify that there is a device with the given name and type
        if (!EnumModem.VerifyDeviceNameAndType(lpRasEntry->szDeviceName,
                                                lpRasEntry->szDeviceType))
        {
            // There was no device that matched both name and type,
            // so reset the strings and bring up the choose modem UI.
            lpRasEntry->szDeviceName[0] = '\0';
            lpRasEntry->szDeviceType[0] = '\0';
        }
    }
    else if ( lpRasEntry->szDeviceName[0] )
    {
        // Only the name was given.  Try to find a matching type.
        // If this fails, fall through to recovery case below.
        LPTSTR szDeviceType =
            EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName);
        if (szDeviceType)
        {
            lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
        }
    }
    else if ( lpRasEntry->szDeviceType[0] )
    {
        // Only the type was given.  Try to find a matching name.
        // If this fails, fall through to recovery case below.
        LPTSTR szDeviceName =
            EnumModem.GetDeviceNameFromType(lpRasEntry->szDeviceType);
        if (szDeviceName)
        {
            lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
        }
    }

    // If either name or type is missing, check whether the user has already made a choice.
    // if not, bring up choose modem UI if there
    // are multiple devices, else just get first device.
    // Since we already verified that there was at least one device,
    // we can assume that this will succeed.

    if( !(lpRasEntry->szDeviceName[0]) ||
        !(lpRasEntry->szDeviceType[0]) )
    {
        DebugOut("ISIGN32: ConfigRasEntryDevice: no valid device passed in\n");

        if( g_szDeviceName[0] )
        {
            // it looks like we have already stored the user's choice.
            // store the DeviceName in lpRasEntry, then call GetDeviceTypeFromName
            // to confirm that the deviceName we saved actually exists on the system
            lstrcpy(lpRasEntry->szDeviceName, g_szDeviceName);

            if( 0 == lstrcmp(EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName),
                              g_szDeviceType) )
            {
                //DebugOut("ISIGN32: ConfigRasEntryDevice using previously stored choice, '%s'\n",
                //        g_szDeviceName);
                lstrcpy(lpRasEntry->szDeviceType, g_szDeviceType);
                return ERROR_SUCCESS;
            }
            else
            {
                // whatever we previously stored has somehow gone bad; fall through to code below
                //DebugOut("ISIGN32: ConfigRasEntryDevice: previously stored choice '%s' is not valid\n",
                //        g_szDeviceName);
            }
        }


        if (1 == EnumModem.GetNumDevices())
        {
            // There is just one device installed, so copy the name
            DebugOut("ISIGN32: import.cpp: ConfigRasEntryDevice: only one modem installed, using it\n");
            lstrcpy (lpRasEntry->szDeviceName, EnumModem.Next());
        }
        else
        {
            DebugOut("ISIGN32: import.cpp: ConfigRasEntryDevice: multiple modems detected\n");

            // structure to pass to dialog to fill out
            CHOOSEMODEMDLGINFO ChooseModemDlgInfo;
             
            // Display a dialog and allow the user to select modem
            // TODO:  is g_hWndMain the right thing to use for parent?
            int iRet = (int)DialogBoxParam(
                GetModuleHandle(TEXT("ISIGN32.DLL")),
                MAKEINTRESOURCE(IDD_CHOOSEMODEMNAME),
                pDynShare->hwndMain,
                ChooseModemDlgProc,
                (LPARAM) &ChooseModemDlgInfo);
            
            if (0 == iRet)
            {
                // user cancelled
                dwRet = ERROR_CANCELLED;
            }
            else if (-1 == iRet)
            {
                // an error occurred.
                dwRet = GetLastError();
                if (ERROR_SUCCESS == dwRet)
                {
                    // Error occurred, but the error code was not set.
                    dwRet = ERROR_INETCFG_UNKNOWN;
                }
            }

            // Copy the modem name string
            lstrcpy (lpRasEntry->szDeviceName, ChooseModemDlgInfo.szModemName);
        }

        // Now get the type string for this modem
        lstrcpy (lpRasEntry->szDeviceType,
            EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName));
        //Assert(lstrlen(lpRasEntry->szDeviceName));
        //Assert(lstrlen(lpRasEntry->szDeviceType));
    }

    lstrcpy(g_szDeviceName, lpRasEntry->szDeviceName);
    lstrcpy(g_szDeviceType, lpRasEntry->szDeviceType);

    // Save data in registry
    SetDeviceSelectedByUser(DEVICENAMEKEY, g_szDeviceName);
    SetDeviceSelectedByUser (DEVICETYPEKEY, g_szDeviceType);

    return dwRet;
}

//+----------------------------------------------------------------------------
//    Function    RasDial1Callback
//
//    Synopsis    This function will be called with RAS status information.
//                For most message this function will simply pass the data on to
//                the hwnd in the dialer.  However, if the connection is dropped
//                unexpectedly then the function will allow the user to
//                reconnect.  Note, the reconnection only applies to NT since
//                win95 machines will automatically handle this.
//
//    Arguments    hrasconn,    // handle to RAS connection
//                unMsg,    // type of event that has occurred
//                rascs,    // connection state about to be entered
//                dwError,    // error that may have occurred
//                dwExtendedError    // extended error information for some errors
//                (See RasDialFunc for more details)
//
//    Returns        none
//
//    History        10/28/96    ChrisK    Created
//-----------------------------------------------------------------------------
VOID WINAPI RasDial1Callback(
    HRASCONN hrasconn,    // handle to RAS connection
    UINT unMsg,    // type of event that has occurred
    RASCONNSTATE rascs,    // connection state about to be entered
    DWORD dwError,    // error that may have occurred
    DWORD dwExtendedError    // extended error information for some errors
   )
{
    static BOOL fIsConnected = FALSE;
    static HWND    hwndDialDlg = NULL;
    static DWORD dwPlatformId = 0xFFFFFFFF;
    static UINT unRasMsg = 0;
    OSVERSIONINFO osver;
    HANDLE hThread = INVALID_HANDLE_VALUE;
    DWORD dwTID = 0;

    //
    // Initial registration
    //
    if (WM_RegisterHWND == unMsg)
    {
        //
        // dwError actually contains an HWND in this case.
        //
        if (hwndDialDlg)
        {
            DebugOut("ISIGN32: ERROR hwndDialDlg is not NULL.\r\n");
        }
        if (fIsConnected)
        {
            DebugOut("ISIGN32: ERROR fIsConnected is not FALSE.\r\n");
        }
        if (0xFFFFFFFF != dwPlatformId)
        {
            DebugOut("ISIGN32: ERROR dwPlatformId is not initial value.\r\n");
        }
        //
        // Remember HWND value
        //
        hwndDialDlg = (HWND)UlongToPtr(dwError);

        //
        // Determine the current platform
        //
        ZeroMemory(&osver,sizeof(osver));
        osver.dwOSVersionInfoSize = sizeof(osver);
        if (GetVersionEx(&osver))
            dwPlatformId = osver.dwPlatformId;

        //
        // Figure out ras event value
        //
        unRasMsg = RegisterWindowMessageA(RASDIALEVENT);
        if (unRasMsg == 0) unRasMsg = WM_RASDIALEVENT;


        //
        // Don't call into the HWND if this is the initial call
        //
        goto RasDial1CallbackExit;
    }

    //
    // Remember if the connection was successfull
    //
    if (RASCS_Connected == rascs)
    {
        fIsConnected = TRUE;
        if (VER_PLATFORM_WIN32_NT == dwPlatformId)
        {
            hThread = CreateThread(NULL,0,
                (LPTHREAD_START_ROUTINE)StartNTReconnectThread,
                (LPVOID)hrasconn,0,&dwTID);
            if (hThread)
                CloseHandle(hThread);
            else
                DebugOut("ISIGN32: Failed to start reconnect thread.\r\n");
        }
    }

    //
    // Pass the message on to the Dialing dialog
    //
    if (IsWindow(hwndDialDlg))
    {
        if (WM_RASDIALEVENT == unMsg)
        {
            if (0 == unRasMsg)
            {
                DebugOut("ISIGN32: ERROR we are about to send message 0.  Very bad...\r\n");
            }
            SendMessage(hwndDialDlg,unRasMsg,(WPARAM)rascs,(LPARAM)dwError);
        }
        else
        {
            SendMessage(hwndDialDlg,unMsg,(WPARAM)rascs,(LPARAM)dwError);
        }
    }
RasDial1CallbackExit:
    return;
}

//+----------------------------------------------------------------------------
//    Function    SLRasConnectionNotification
//
//    Synopsis    Soft link to RasConnectionNotification
//
//    Arguments    hrasconn - handle to connection
//                hEvent - handle to event
//                dwFlags - flags to determine the type of notification
//
//    Returns        ERROR_SUCCESS - if successful
//
//    History        10/29/96    ChrisK    Created
//-----------------------------------------------------------------------------
typedef DWORD (APIENTRY *PFNRASCONNECTIONNOTIFICATION)( HRASCONN, HANDLE, DWORD );
// 1/7/96 jmazner  already defined in ras2.h
//#define RASCN_Disconnection 2
#define CONNECT_CHECK_INTERVAL 500

static DWORD SLRasConnectionNotification(HRASCONN hrasconn, HANDLE hEvent, DWORD dwFlags)
{
    DWORD dwRC = ERROR_DLL_NOT_FOUND;
    FARPROC fp = NULL;
    HINSTANCE hinst = NULL;

    if(hinst = LoadLibrary(TEXT("RASAPI32.DLL")))
#ifdef UNICODE
        if (fp = GetProcAddress(hinst,"RasConnectionNotificationW"))
#else
        if (fp = GetProcAddress(hinst,"RasConnectionNotificationA"))
#endif
            dwRC = ((PFNRASCONNECTIONNOTIFICATION)fp)(hrasconn, hEvent, dwFlags);

    if (hinst)
        FreeLibrary(hinst);

    return dwRC;
}

//+----------------------------------------------------------------------------
//    Function    IsConnectionClosed
//
//    Synopsis    Given a particular connection handle, determine if the
//                connection is still valid
//
//    Arguments    hrasconn - handle to the connection to be checked
//
//    Returns        TRUE - if the connection is closed
//
//    History        10/29/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL IsConnectionClosed(HRASCONN hrasconn)
{
    BOOL bRC = FALSE;
    LPRASCONN lprasconn = NULL;
    DWORD dwSize = 0;
    DWORD cConnections = 0;
    DWORD dwRet = 0;

    //
    // Make sure the DLL is loaded
    //
    if (!lpfnRasEnumConnections)
        if (!LoadRnaFunctions(NULL))
            goto IsConnectionClosedExit;

    //
    // Get list of current connections
    //
    lprasconn = (LPRASCONN)GlobalAlloc(GPTR,sizeof(RASCONN));
    lprasconn->dwSize = dwSize = sizeof(RASCONN);
    cConnections = 0;

    dwRet = lpfnRasEnumConnections(lprasconn, &dwSize, &cConnections);
    if (ERROR_BUFFER_TOO_SMALL == dwRet)
    {
        GlobalFree(lprasconn);
        lprasconn = (LPRASCONN)GlobalAlloc(GPTR,dwSize);
        lprasconn->dwSize = dwSize;
        dwRet = lpfnRasEnumConnections(lprasconn, &dwSize, &cConnections);
    }

    if (ERROR_SUCCESS != dwRet)
        goto IsConnectionClosedExit;

    //
    // Check to see if the handle matches
    //

    while (cConnections)
    {
        if (lprasconn[cConnections-1].hrasconn == hrasconn)
            goto IsConnectionClosedExit; // The connection is still open
        cConnections--;
    }
    bRC = TRUE;

IsConnectionClosedExit:
    if (lprasconn)
        GlobalFree(lprasconn);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Function    StartNTReconnectThread
//
//    Synopsis    This function will detect when the connection has been dropped
//                unexpectedly and it will then offer the user a chance to
//                reconnect
//
//    Arguments    hrasconn - the connection to be watched
//
//    Returns        none
//
//    History        10/29/96    ChrisK    Created
//-----------------------------------------------------------------------------
DWORD WINAPI StartNTReconnectThread (HRASCONN hrasconn)
{
    TCHAR szEntryName[RAS_MaxEntryName + 1];
    DWORD dwRC = 0;

    //
    // Validate state
    //
    if (NULL == hrasconn)
        goto StartNTReconnectThreadExit;
    if (TestControlFlags(SCF_RECONNECTTHREADQUITED) != FALSE)
        goto StartNTReconnectThreadExit;
    if (NULL != pDynShare->hReconnectEvent)
        goto StartNTReconnectThreadExit;

    //
    // Register Event
    //
    pDynShare->hReconnectEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    
    if (NULL  == pDynShare->hReconnectEvent)
        goto StartNTReconnectThreadExit;
    if (0 != SLRasConnectionNotification(hrasconn, pDynShare->hReconnectEvent,RASCN_Disconnection))
        goto StartNTReconnectThreadExit;

    //
    // Wait for event
    //
    do {
        dwRC = WaitForSingleObject(pDynShare->hReconnectEvent,CONNECT_CHECK_INTERVAL);
        if (WAIT_FAILED == dwRC)
        {
            DebugOut("ISIGN32: Quitting reconnect thread because wait failed.\r\n");
            goto StartNTReconnectThreadExit;
        }
    } while ((WAIT_TIMEOUT == dwRC) && !IsConnectionClosed(hrasconn));

    //
    // Clear values
    //
    hrasconn = NULL;

    CloseHandle(pDynShare->hReconnectEvent);
    pDynShare->hReconnectEvent = NULL;
    
    //
    //    Determine if we should offer to reconnect
    //
    if (FALSE != TestControlFlags(SCF_RECONNECTTHREADQUITED))
    {
        DebugOut("ISIGN32: Quitting reconnect thread because app is quitting.\r\n");
        goto StartNTReconnectThreadExit;
    }
    else if (FALSE == TestControlFlags(SCF_HANGUPEXPECTED))
    {
        DebugOut("ISIGN32: Reconnect thread will ask about reconnecting.\r\n");
        TCHAR szMsg[MAX_STRING + 1];

        //
        // Prompt user
        //
        LoadString(ghInstance,IDS_RECONNECT_QUERY,szMsg,sizeof(szMsg));
        if (IDYES == MessageBox(
                pDynShare->hwndMain,
                szMsg,
                cszAppName,
                MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_YESNO))
        {
            //
            // Reconnect
            //
             
            if (ERROR_USERNEXT != DialConnection(pDynShare->szISPFile))
            {
                DebugOut("ISIGN32: Quitting reconnect thread because user canceled dialing.\r\n");
                KillConnection();
                InfoMsg(NULL, IDS_SIGNUPCANCELLED);
                PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
                goto StartNTReconnectThreadExit;
            }

        }
        else
        {
            //
            // Forget it, we're out of here (close down signup)
            //
            KillConnection();
            InfoMsg(NULL, IDS_SIGNUPCANCELLED);
            PostMessage(pDynShare->hwndMain, WM_CLOSE, 0, 0);
            DebugOut("ISIGN32: Quitting reconnect thread because user doesn't want to reconnect.\r\n");
            goto StartNTReconnectThreadExit;

        }
    }
StartNTReconnectThreadExit:
    return 1;
}

//+----------------------------------------------------------------------------
//    Function    IsSingleInstance and ReleaseSingleInstance
//
//    Synopsis    These two function check to see if another instance of isignup
//                is already running.  ISign32 does have to allow mutliple instances
//                to run in order to handle the .INS files, but in other instances
//                there should only be one copy running at a time
//
//    Arguments    bProcessingINS -- are we in the .ins path?
//
//    Returns        IsSingleInstance - TRUE - this is the first instance
//                ReleaseSingleInstance - none
//
//    History        11/1/96    ChrisK    Created
//                12/3/96    jmazner    Modified to allow the processINS path to create
//                                a semaphore (to prevent others from running),
//                                but to not check whether the create succeeded.
//-----------------------------------------------------------------------------

// superceded by definition in semaphor.h
//#define SEMAPHORE_NAME "Internet Connection Wizard ISIGNUP.EXE"
BOOL IsSingleInstance(BOOL bProcessingINS)
{
    g_hSemaphore = CreateSemaphore(NULL, 1, 1, ICW_ELSE_SEMAPHORE);
    DWORD dwErr = GetLastError();
    if( ERROR_ALREADY_EXISTS == dwErr )
    {
        g_hSemaphore = NULL;
        if( !bProcessingINS )
            IsAnotherComponentRunning32( NULL );
        return FALSE;
    }

    return TRUE;
}

void ReleaseSingleInstance()
{
    if (g_hSemaphore)
    {
        CloseHandle(g_hSemaphore);
        g_hSemaphore = NULL;
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAnotherComponentRunning32()
//
//  Synopsis:   Checks if there's another ICW component already
//              running.  If so, it will set focus to that component's window.
//
//              This functionality is needed by all of our .exe's.  However,
//              the actual components to check for differ between .exe's.
//              The comment COMPONENT SPECIFIC designates lines of code
//              that vary between components' source code.
//
//              For ISIGN32, this function only gets called if we couldn't create
//              the ICW_ELSE semaphore, so all we need to do here is find the
//              other running ICW_ELSE component and bring it to the foreground.
//
//  Arguments:  bUnused -- not used in this component
//
//  Returns:    TRUE if another component is already running
//              FALSE otherwise
//
//  History:    12/3/96    jmazner    Created, with help from IsAnotherInstanceRunning
//                                    in icwconn1\connmain.cpp
//
//----------------------------------------------------------------------------
BOOL IsAnotherComponentRunning32(BOOL bUnused)
{

    HWND hWnd = NULL;
    HANDLE hSemaphore = NULL;
    DWORD dwErr = 0; 

    // for isignup, we only get here if we failed to create the ICW_ELSE semaphore
    // try and bring focus to the IE window if we have one
    if( pDynShare->hwndBrowser )
    {
        SetFocus(pDynShare->hwndBrowser);
        SetForegroundWindow(pDynShare->hwndBrowser);
    }
    else
    {
        // if that didn't work, try finding a conn2 or inetwiz instance
        // Bring the running instance's window to the foreground
        // if conn1 is running, we may accidentaly bring it to the foreground,
        // since it shares a window name with conn2 and inetwiz.  oh well.
        hWnd = FindWindow(DIALOG_CLASS_NAME, cszAppName);

        if( hWnd )
        {
            SetFocus(hWnd);
            SetForegroundWindow(hWnd);
        }
    }

    return TRUE;

/**
    if( hWnd || hwndBrowser )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
**/
}


#endif //!WIN16


#if !defined(WIN16)

//+----------------------------------------------------------------------------
//
//    Function    SetStartUpCommand
//
//    Synopsis    On an NT machine the RunOnce method is not reliable.  Therefore
//                we will restart the ICW by placing a .BAT file in the common
//                startup directory.
//
//    Arguments    lpCmd - command line used to restart the ICW
//
//    Returns        TRUE if it worked
//                FALSE otherwise.
//
//    History        1-10-97    ChrisK    Created
//
//-----------------------------------------------------------------------------
static const TCHAR cszICW_StartFileName[] = TEXT("ICWStart.bat");
static const TCHAR cszICW_StartCommand[] = TEXT("@start ");
static const TCHAR cszICW_DummyWndName[] = TEXT("\"ICW\" ");
static const TCHAR cszICW_ExitCommand[] = TEXT("\r\n@exit");

BOOL SetStartUpCommand(LPTSTR lpCmd)
{
    BOOL bRC = FALSE;
    HANDLE hFile = INVALID_HANDLE_VALUE ;
    DWORD dwWLen;    // dummy variable used to make WriteFile happy
    TCHAR szCommandLine[MAX_PATH + 1];
    LPITEMIDLIST lpItemDList = NULL;
    HRESULT hr = ERROR_SUCCESS;
    IMalloc *pMalloc = NULL;

    // build full filename
    // NOTE: the memory allocated for lpItemDList is leaked.  We are not real
    // concerned about this since this code is only run once and then the
    // system is restarted.  In order to free the memory appropriately
    // this code would have to call SHGetMalloc to retrieve the shell's IMalloc
    // implementation and then free the memory.
    hr = SHGetSpecialFolderLocation(NULL,CSIDL_COMMON_STARTUP,&lpItemDList);
    if (ERROR_SUCCESS != hr)
        goto SetStartUpCommandExit;

    if (FALSE == SHGetPathFromIDList(lpItemDList, szCommandLine))
        goto SetStartUpCommandExit;


    //
    // Free up the memory allocated for LPITEMIDLIST
    // because seems like we are clobberig something later
    // by not freeing this
    //
    hr = SHGetMalloc (&pMalloc);
    if (SUCCEEDED (hr))
    {
        pMalloc->Free (lpItemDList);
        pMalloc->Release ();
    }

    // make sure there is a trailing \ character
    if ('\\' != szCommandLine[lstrlen(szCommandLine)-1])
        lstrcat(szCommandLine,TEXT("\\"));
    lstrcat(szCommandLine,cszICW_StartFileName);

    // Open file
    hFile = CreateFile(szCommandLine,GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL |
        FILE_FLAG_WRITE_THROUGH,NULL);

    if (INVALID_HANDLE_VALUE == hFile)
        goto SetStartUpCommandExit;

    // Write the restart commands to the file
    if (FALSE == WriteFile(hFile,cszICW_StartCommand,lstrlen(cszICW_StartCommand),&dwWLen,NULL))
        goto SetStartUpCommandExit;
    // 1/20/96    jmazner Normandy #13287
    // Start command considers the first thing it sees in quotes to be a window title
    // So, since our path is in quotes, put in a fake window title
    if (FALSE == WriteFile(hFile,cszICW_DummyWndName,lstrlen(cszICW_DummyWndName),&dwWLen,NULL))
        goto SetStartUpCommandExit;
    if (FALSE == WriteFile(hFile,lpCmd,lstrlen(lpCmd),&dwWLen,NULL))
        goto SetStartUpCommandExit;
    if (FALSE == WriteFile(hFile,cszICW_ExitCommand,lstrlen(cszICW_ExitCommand),&dwWLen,NULL))
        goto SetStartUpCommandExit;

    bRC = TRUE;
SetStartUpCommandExit:
    // Close handle and exit
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    DeleteStartUpCommand
//
//    Synopsis:    After restart the ICW we need to delete the .bat file from
//                the common startup directory
//
//    Arguements: None
//
//    Returns:    None
//
//    History:    1-10-97    ChrisK    Created
//
//-----------------------------------------------------------------------------
void DeleteStartUpCommand ()
{
    TCHAR szStartUpFile[MAX_PATH + 1];
    LPITEMIDLIST lpItemDList = NULL;
    HRESULT hr = ERROR_SUCCESS;
    IMalloc *pMalloc = NULL;

    // build full filename
    // NOTE: the memory allocated for lpItemDList is leaked.  We are not real
    // concerned about this since this code is only run once and then the
    // system is restarted.  In order to free the memory appropriately
    // this code would have to call SHGetMalloc to retrieve the shell's IMalloc
    // implementation and then free the memory.
    hr = SHGetSpecialFolderLocation(NULL,CSIDL_COMMON_STARTUP,&lpItemDList);
    if (ERROR_SUCCESS != hr)
        goto DeleteStartUpCommandExit;

    if (FALSE == SHGetPathFromIDList(lpItemDList, szStartUpFile))
        goto DeleteStartUpCommandExit;

    //
    // Free up the memory allocated for LPITEMIDLIST
    // because seems like we are clobberig something later
    // by not freeing this
    //
    hr = SHGetMalloc (&pMalloc);
    if (SUCCEEDED (hr))
    {
        pMalloc->Free (lpItemDList);
        pMalloc->Release ();
    }


    // make sure there is a trailing \ character
    if ('\\' != szStartUpFile[lstrlen(szStartUpFile)-1])
        lstrcat(szStartUpFile,TEXT("\\"));
    lstrcat(szStartUpFile,cszICW_StartFileName);

    DeleteFile(szStartUpFile);
DeleteStartUpCommandExit:
    return;
}

#endif //!Win16

#ifdef WIN32
BOOL GetICWCompleted( DWORD *pdwCompleted )
{
    HKEY hKey = NULL;
    DWORD dwSize = sizeof(DWORD);

    HRESULT hr = RegOpenKey(HKEY_CURRENT_USER,ICWSETTINGSPATH,&hKey);
    if (ERROR_SUCCESS == hr)
    {
        hr = RegQueryValueEx(hKey, ICWCOMPLETEDKEY, 0, NULL,
                    (BYTE*)pdwCompleted, &dwSize);
        RegCloseKey(hKey);
    }

    if( ERROR_SUCCESS == hr )
        return TRUE;
    else
        return FALSE;

}

BOOL SetICWCompleted( DWORD dwCompleted )
{
    HKEY hKey = NULL;

    HRESULT hr = RegCreateKey(HKEY_CURRENT_USER,ICWSETTINGSPATH,&hKey);
    if (ERROR_SUCCESS == hr)
    {
        hr = RegSetValueEx(hKey, ICWCOMPLETEDKEY, 0, REG_DWORD,
                    (CONST BYTE*)&dwCompleted, sizeof(dwCompleted));
        RegCloseKey(hKey);
    }

    if( ERROR_SUCCESS == hr )
        return TRUE;
    else
        return FALSE;

}
#endif


#ifdef WIN32
//+----------------------------------------------------------------------------
//
//    Function:    CreateSecurityPatchBackup
//
//    Synopsis:    Creates a .reg file to restore security settings, and installs
//                the filenmae into the RunOnce reg keys.
//
//    Arguements: None
//
//    Returns:    None
//
//    History:    8/7/97    jmazner    Created for Olympus #6059
//
//-----------------------------------------------------------------------------
BOOL CreateSecurityPatchBackup( void )
{
    Dprintf("ISIGN32: CreateSecurityPatchBackup\n");

    HKEY hKey = NULL;
    TCHAR szPath[MAX_PATH + 1] = TEXT("\0");
    HANDLE hSecureRegFile = INVALID_HANDLE_VALUE;
    TCHAR szRegText[1024];
    TCHAR szRunOnceEntry[1024];
    DWORD dwBytesWritten = 0;


    if (0 == GetTempPath(MAX_PATH,szPath))
    {
        //
        // if GetTempPath Failed, use the current directory
        //
        if (0 == GetCurrentDirectory (MAX_PATH, szPath))
        {
            Dprintf("ISIGN32: unable to get temp path or current directory!\n");
            return FALSE;
        }
    }

    //
    // Get the name of the temporary file
    //
    if (0 == GetTempFileName(szPath, TEXT("hyjk"), 0, pDynShare->szFile))
    {
        //
        // If we failed, probably, the TMP directory does not
        // exist, we should use the current directory
        // MKarki (4/27/97) - Fix for Bug #3504
        //
        if (0 == GetCurrentDirectory (MAX_PATH, szPath))
        {
            return FALSE;
        }

        //
        // try getting the temp file name again
        //
        if (0 == GetTempFileName(szPath, TEXT("hyjk"), 0, pDynShare->szFile))
        {
            return FALSE;
        }
    }

    hSecureRegFile = CreateFile(pDynShare->szFile,
                                GENERIC_WRITE,
                                0, //no sharing
                                NULL, //no inheritance allowed
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                                NULL //no template file
                                );

    if (INVALID_HANDLE_VALUE == hSecureRegFile)
    {
        Dprintf("ISIGN32: unable to createFile secureRegFile %s\n", pDynShare->szFile);
        return FALSE;
    }
    else
    {
        Dprintf("ISIGN32: writing secureRegFile %s\n",pDynShare->szFile );
        ZeroMemory( szRegText, 1023 );
        dwBytesWritten = 0;
        lstrcpy(szRegText, TEXT("REGEDIT4\n\n"));
        lstrcat(szRegText, TEXT("[HKEY_CLASSES_ROOT\\.ins]\n"));
        lstrcat(szRegText, TEXT("\"EditFlags\"=hex:00,00,00,00\n\n"));
        lstrcat(szRegText, TEXT("[HKEY_CLASSES_ROOT\\.isp]\n"));
        lstrcat(szRegText, TEXT("\"EditFlags\"=hex:00,00,00,00\n\n"));
        lstrcat(szRegText, TEXT("[HKEY_CLASSES_ROOT\\x-internet-signup]\n"));
        lstrcat(szRegText, TEXT("\"EditFlags\"=hex:00,00,00,00\n\n"));

        //
        // ChrisK Olympus 6198 6/10/97
        //
        lstrcat(szRegText, TEXT("[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3]\n"));
        lstrcat(szRegText, TEXT("\"1601\"=dword:"));
        TCHAR szZoneSetting[16];
        wsprintf(szZoneSetting,TEXT("%08x\n\n"),g_dwZone_1601);
        lstrcat(szRegText, szZoneSetting);

        WriteFile(hSecureRegFile, (LPVOID) &szRegText[0], lstrlen(szRegText),
                    &dwBytesWritten, NULL );

        CloseHandle(hSecureRegFile);
        hSecureRegFile = INVALID_HANDLE_VALUE;

        Dprintf("ISIGN32: installing security RunOnce entry\n");
        ZeroMemory(szRunOnceEntry, 1023 );
        wsprintf(szRunOnceEntry, TEXT("regedit /s \"%s\""), pDynShare->szFile);
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),&hKey))
        {
            RegSetValueEx(hKey,TEXT("hyjk"),(DWORD)NULL,(DWORD)REG_SZ,
                            (BYTE*)szRunOnceEntry,sizeof(TCHAR)*lstrlen(szRunOnceEntry));
            RegCloseKey(hKey);
            hKey = NULL;
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function:    RestoreSecurityPatch
//
//    Synopsis:    Reset the EditFlags for our file types to indicate that these
//                files are not safe.  Remove the runOnce we set as a backup.
//
//    Arguements: None
//
//    Returns:    None
//
//    History:    3/11/97    jmazner     created for Olympus #1545
//
//-----------------------------------------------------------------------------
VOID RestoreSecurityPatch( void )
{
    HKEY hKey = NULL;
    TCHAR szTemp[4];

    hKey = NULL;
    szTemp[0] = (TCHAR)0;
    szTemp[1] = (TCHAR)0;
    szTemp[2] = (TCHAR)0;
    szTemp[3] = (TCHAR)0;

    Dprintf("ISIGN32: Restoring EditFlags settings\n");

    // Mark various registry entries as unsafe.
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT("x-internet-signup"),&hKey))
    {
        RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szTemp[0],(DWORD)4);
        RegCloseKey(hKey);
    }
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT(".ins"),&hKey))
    {
        RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szTemp[0],(DWORD)4);
        RegCloseKey(hKey);
    }
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT,TEXT(".isp"),&hKey))
    {
        RegSetValueEx(hKey,TEXT("EditFlags"),(DWORD)NULL,(DWORD)REG_BINARY,(BYTE*)&szTemp[0],(DWORD)4);
        RegCloseKey(hKey);
    }

    //
    // ChrisK Olympus 6198 6/10/97
    // replace HTML form submission value.
    //
    if (g_fReadZone &&
        ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,REG_ZONE3_KEY,&hKey))
    {
        //
        // Set value for zone to initial value.
        //
        RegSetValueEx(hKey,
                        REG_ZONE1601_KEY,
                        NULL,
                        REG_DWORD,
                        (LPBYTE)&g_dwZone_1601,
                        sizeof(g_dwZone_1601));
        RegCloseKey(hKey);
    }

    // Remove run once key
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("Software\\microsoft\\Windows\\CurrentVersion\\RunOnce"),&hKey))
    {
        RegDeleteValue(hKey,TEXT("hyjk"));
    }
     
    // Remove reg file
    DeleteFile(pDynShare->szFile);

}
#endif

#ifdef WIN32
//++--------------------------------------------------------------
//
//  Function:   RemoveQuotes
//
//  Synopsis:   This  Function strips the file name in the command
//              line of its quote
//              Fix For Bug #4049
//
//  Arguments:  [IN] PTSTR - pointer to command line
//
//  Returns:    VOID
//
//  Called By:  Signup Function
//
//  History:    MKarki      Created     5/1/97
//
//----------------------------------------------------------------
VOID
RemoveQuotes (
    LPTSTR   pCommandLine
    )
{
    const TCHAR  QUOTE = '"';
    const TCHAR  SPACE = ' ';
    const TCHAR  NIL   = '\0';
    TCHAR * pTemp =  NULL;


    if (NULL == pCommandLine)
        return;

    //
    //  find the starting quote first
    //  do we care for MBCS/UNICODE ?
    //
    pTemp = _tcschr  (pCommandLine, QUOTE);
    if (NULL != pTemp)
    {
        //
        //  replace the quote with a space
        //
        *pTemp = SPACE;

        //
        //  search for the ending quote now
        //
        pTemp = _tcsrchr (pCommandLine, QUOTE);
        if (NULL != pTemp)
        {
            //
            // end the string here
            //
            *pTemp = NIL;
        }

    }

    return;

}   // end of RemoveQuotes function

#endif


//++--------------------------------------------------------------
//
//  Function:   IEAKProcessISP
//
//  Synopsis:   A hacked version of ProcessISP, intended for use
//                by the IEAK folks.  The function will create a
//                connectoid and establish a connection in the same
//                manner as ProcsesISP.  However, once the connection
//                is established, we will execute the command in the
//                [Entry] Run= section and exit
//
//                This function does _not_ wait around for the
//                .exe that it launches, and thus does _not_ kill the
//                dial-up connection.  It's up to the calling app to
//                worry about that.
//
//  Arguments:  [IN] hwnd - handle of parent window
//                [IN] LPCTSTR - pointer to path to .isp file
//
//  Returns:    TRUE if able to create the connectoid and dial
//                FALSE otherwise
//
//
//  History:    5/23/97    jmazner    Created for Olympus #4679
//
//----------------------------------------------------------------

#ifdef WIN16
extern "C" BOOL WINAPI __export IEAKProcessISP(HWND hwnd, LPCTSTR lpszFile)
#else
#ifdef UNICODE
BOOL EXPORT WINAPI IEAKProcessISPW(HWND, LPCTSTR);
BOOL EXPORT WINAPI IEAKProcessISPA
(
    HWND hwnd,
    LPCSTR lpszFile
)
{
    TCHAR szFile[MAX_PATH+1];

    mbstowcs(szFile, lpszFile, lstrlenA(lpszFile)+1);
    return IEAKProcessISPW(hwnd, szFile);
}

BOOL EXPORT WINAPI IEAKProcessISPW
#else
BOOL EXPORT WINAPI IEAKProcessISPA
#endif
(
    HWND hwnd,
    LPCTSTR lpszFile
)
#endif
{

    TCHAR  szSignupURL[MAX_URL + 1];
#if !defined(WIN16)
    HKEY hKey;
    GATHEREDINFO gi;
#endif //!WIN16

#if !defined(WIN16)
        if (!IsSingleInstance(FALSE))
            return FALSE;
#endif

    if (!LoadInetFunctions(hwnd))
    {
        Dprintf("ISIGN32: IEAKProcessISP couldn't load INETCFG.DLL!");

        return FALSE;
    }


#if !defined(WIN16)
    // Make sure the isp file exists before setting up stack.
    if (0xFFFFFFFF == GetFileAttributes(lpszFile))
    {
        DWORD dwFileErr = GetLastError();
        Dprintf("ISIGN32: ProcessISP couldn't GetAttrib for %s, error = %d",
            lpszFile, dwFileErr);
        if( ERROR_FILE_NOT_FOUND == dwFileErr )
        {
            ErrorMsg1(hwnd, IDS_INVALIDCMDLINE, lpszFile);
        }

        ErrorMsg(hwnd, IDS_BADSIGNUPFILE);
        return FALSE;
    }
#endif

    // Configure stack if not already configured.
    // If this requires a restart, we're in trouble, so
    // just return FALSE.

#ifdef SETUPSTACK
 
    if (!TestControlFlags(SCF_SYSTEMCONFIGURED))
    {
        DWORD dwRet;
        BOOL  fNeedsRestart = FALSE;

        dwRet = lpfnInetConfigSystem(
            hwnd,
            INETCFG_INSTALLRNA |
            INETCFG_INSTALLTCP |
            INETCFG_INSTALLMODEM |
            INETCFG_SHOWBUSYANIMATION |
            INETCFG_REMOVEIFSHARINGBOUND,
            &fNeedsRestart);

        if (ERROR_SUCCESS == dwRet)
        {
            SetControlFlags(SCF_SYSTEMCONFIGURED);
            
            InstallScripter();

            if (fNeedsRestart)
            {
                Dprintf("ISIGN32: IEAKProcessISP needs to restart!");
                return FALSE;
            }
        }
        else
        {
            ErrorMsg(hwnd, IDS_INSTALLFAILED);

            return FALSE;
        }
    }

    if (!VerifyRasServicesRunning(hwnd))
        return FALSE;
#endif

    // kill the old connection
    KillConnection();

    // Create a new connectoid and set the autodial
    if (ERROR_SUCCESS != CreateConnection(lpszFile))
    {
        ErrorMsg(hwnd, IDS_BADSIGNUPFILE);
        return FALSE;
    }

#ifndef WIN16
    //
    // Dial connectoid
    //
    if (ERROR_USERNEXT != DialConnection(lpszFile))
    {
        Dprintf("ISIGN32: IEAKProcessISP unable to DialConnection!");
        return FALSE;
    }
#endif

    if (GetPrivateProfileString(cszEntrySection,
                                cszRun,
                                szNull,
                                pDynShare->szRunExecutable,
                                SIZEOF_TCHAR_BUFFER(pDynShare->szRunExecutable),
                                lpszFile) != 0)
    {
        
        GetPrivateProfileString(cszEntrySection,
                                cszArgument,
                                szNull,
                                pDynShare->szRunArgument,
                                SIZEOF_TCHAR_BUFFER(pDynShare->szRunArgument),
                                lpszFile);

        if (RunExecutable(FALSE) != ERROR_SUCCESS)
        {
            // make sure the connection is closed
            KillConnection();
            ErrorMsg1(NULL, IDS_EXECFAILED, pDynShare->szRunExecutable);
            return FALSE;
        }
    }


    DeleteConnection();

    UnloadInetFunctions();
    
#if !defined(WIN16)
    ReleaseSingleInstance();
#endif

    return( TRUE );
}

#ifdef WIN16

CHAR* GetPassword()
{
     
    return pDynShare->szPassword;
    
}

#else

TCHAR* GetPassword()
{ 
    return pDynShare->szPassword;
}

BOOL IsRASReady()
{ 
    return TestControlFlags(SCF_RASREADY);
}

#endif


BOOL IsCurrentlyProcessingISP()
{
#if !defined(WIN16)
    return TestControlFlags(SCF_ISPPROCESSING);
#else
    return FALSE;
#endif
}

BOOL NeedBackupSecurity()
{
#if !defined(WIN16)
    return TestControlFlags(SCF_NEEDBACKUPSECURITY);
#else
    return FALSE;
#endif
}

HWND GetHwndMain()
{
    return pDynShare->hwndMain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\rsrc.h ===
#define     IDI_PHONE       100
#define     IDB_ARROW       101
#define     IDB_LOGO        102
#define     IDC_LOGO        103
#define     IDC_STEP1       201
#define     IDC_STEP2       202
#define     IDC_STEP3       203
#define     IDC_PCTARROW1   301
#define     IDC_PCTARROW2   302
#define     IDC_PCTARROW3   303
#define     IDC_LBLSTEPS    400
#define     IDC_PHONE1        401
#define     IDC_INSTRUCT_TEXT 402
#define     IDC_ONE_TEXT      403
#define     IDC_SETUP_TEXT    404
#define     IDC_TWO_TEXT      405
#define     IDC_SIGNUP_TEXT   406
#define     IDC_THREE_TEXT    407
#define     IDC_REQ_TEXT      408
#define     IDC_FRAME         409
#define     IDC_PHONE2        410
#define     IDC_MODEM_TEXT    411

#define     IDS_INVALIDCMDLINE  1001
#define     IDS_INVALIDFILETYPE 1002
#define     IDS_CANNOTPROCESSINS  1003
#define     IDS_SIGNUPCANCELLED 1004
#define     IDS_LAUNCHFAILED    1005
#define     IDS_INSTALLFAILED   1006
#define     IDS_BADSETTINGS     1007
#define     IDS_RESTART         1008
#define     IDS_RESTARTNOW      1009
#define     IDS_SETTINGCHANGE   1010
#define     IDS_SIGNUPCOMPLETE  1011
#define     IDS_EXECFAILED      1012
#define     IDS_INSFILEWARNING  1013
#define     IDS_BADSIGNUPFILE   1014
#define     IDS_MISSINGCFGDLL   1015
#define     IDS_MISSINGRNADLL   1016
#define     IDS_WRONGRNADLLVER  1017
#define     IDS_PASSWORD        1018
#define     IDS_LOGONMESSAGE    1019
#define     IDS_LOGONCAPTION    1020
#define     IDS_SIGNUPLOGON     1021
#define     IDS_BROWSERTERMINATED 1022
#define     IDS_BROWSERNEVERFOUND 1023
#define     IDS_INVALIDURL      1024
#define     IDS_MAILFAILED      1025
#define     IDS_ISP_DIAL_MESSAGE 1026
#define		IDS_MISSINGIE		1027
#define		IDS_IELOWVERSION	1028
#define		IDS_SBSCFGERROR		1029
#define		IDS_NOCMDLINE       1030
#define     IDS_ISPBROWSEFAIL   1031
#define		IDS_INVALIDNOURL	1032

#define     IDS_APP_TITLE       1101
#define     IDS_VERSION         1102
#define     IDS_DESCRIPTION     1103

#define     IDS_DEFAULT_SCP             1201
#define     IDS_INI_SCRIPT_DIR          1202
#define     IDS_INI_SCRIPT_SHORTDIR     1203

#define		IDS_SERVICEDISABLED 1210
#define		IDS_RECONNECT_QUERY 1211

#define		IDD_CHOOSEMODEMNAME	1250
#define		IDC_MODEM			1251
#define		IDC_CMDOK			1252
#define		IDC_CMDCANCEL		1253
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\progress.cpp ===
#include "isignup.h"

LRESULT FAR PASCAL ProgressProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

HWND ProgressInit(HWND hwndParent)
{
    HWND        hwnd;
    WNDCLASS    wndclass ;

    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.lpfnWndProc   = ProgressProc ;
    wndclass.cbClsExtra    = 0 ;
    wndclass.cbWndExtra    = DLGWINDOWEXTRA ;
    wndclass.hInstance     = ghInstance ;
    wndclass.hIcon         = NULL ;
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
    wndclass.hbrBackground = (HBRUSH)COLOR_APPWORKSPACE ;
    wndclass.lpszMenuName  = NULL ;
    wndclass.lpszClassName = TEXT("Internet Signup Progress");

    RegisterClass (&wndclass) ;

    hwnd = CreateDialog (ghInstance, TEXT("Progress"), hwndParent, NULL);

    ShowWindow (hwnd, SW_NORMAL);

    return hwnd;
}

LONG_PTR FAR PASCAL ProgressProc (
        HWND hwnd,
        UINT message,
        WPARAM wParam,
        LPARAM lParam)
{
    switch (message)
    {
        case WM_MOUSEACTIVATE:
            return MA_NOACTIVATEANDEAT;

        default:
            break;
    }

    return DefWindowProc (hwnd, message, wParam, lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\isign32

MAJORCOMP=GETCONN
MINORCOMP=ISIGN32

TARGETNAME=ISIGN32
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=LibMain
DLLBASE=$(DEFBASEADDR)
!if defined(NOT_UNICODE)
DLLDEF=..\isignup.def
!else
DLLDEF=..\isignup2.def
!endif
NOT_LEAN_AND_MEAN=1
RCNOFONTMAP=1
# PASS0_SOURCEDIR=.
C_DEFINES = -DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT40=1

386_STDCALL     = 0

MSC_WARNING_LEVEL=/W3 /WX

SOURCES= \
    ..\isignup.rc   \
    ..\iedde.cpp    \
    ..\autodial.cpp \
    ..\client.cpp   \
    ..\custom.cpp   \
    ..\dialutil.cpp \
    ..\extfunc.cpp  \
    ..\icwerr.cpp   \
    ..\impfile.cpp  \
    ..\import.cpp   \
    ..\isignup.cpp  \
    ..\logon.cpp    \
    ..\progress.cpp \
    ..\utils.cpp    \
    ..\enumodem.cpp \
    ..\icw.cpp      \
    ..\isignole.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\version.lib       \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\oleaut32.lib      \
    $(SDK_LIB_PATH)\uuid.lib          \
    $(SDK_LIB_PATH)\hlink.lib         \
    $(SDK_LIB_PATH)\ole32.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\isignup.h
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\splash.cpp ===
/**************
 *
 * THIS ENTIRE FILE HAS BEEN COMMENTED OUT
 *
 * 8/16/96 jmazner Normandy #4593
 * The sole purpose of this file is to stick up a full screen window with the background color.
 * It was (apparently) originaly intended to eliminate any desktop icons/clutter, but has since
 * become known as the screen o' death and RAIDed as a bug.
 *
    

#include "isignup.h"

static char cszSplash[] = "Internet Signup Splash";

long EXPORT FAR PASCAL SplashProc (HWND, UINT, UINT, LONG) ;

HWND SplashInit(HWND hwndParent)
{
    HWND        hwnd ;
    WNDCLASS    wndclass ;
#ifdef WIN32
    RECT        rect ;
#endif

    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.lpfnWndProc   = SplashProc ;
    wndclass.cbClsExtra    = 0 ;
    wndclass.cbWndExtra    = 0 ;
    wndclass.hInstance     = ghInstance ;
    wndclass.hIcon         = NULL ;
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
    wndclass.hbrBackground = (HBRUSH)(COLOR_BACKGROUND + 1);
    wndclass.lpszMenuName  = NULL ;
    wndclass.lpszClassName = cszSplash ;

    RegisterClass (&wndclass) ;

    hwnd = CreateWindow (cszSplash,        // window class name
                  cszAppName,              // window caption
                  WS_POPUP,                // window style
                  CW_USEDEFAULT,           // initial x position
                  CW_USEDEFAULT,           // initial y position
                  CW_USEDEFAULT,           // initial x size
                  CW_USEDEFAULT,           // initial y size
                  hwndParent,              // parent window handle
                  NULL,                    // window menu handle
                  ghInstance,              // program instance handle
                  NULL) ;                  // creation parameters


#ifdef WIN32
    // these were added as per ChrisK's instructions
    SystemParametersInfo(SPI_GETWORKAREA,0,(PVOID)&rect,0);
    MoveWindow(hwnd,rect.left,rect.top,rect.right-rect.left,rect.bottom-rect.top,FALSE);
    ShowWindow(hwnd,SW_NORMAL);
#else
    ShowWindow(hwnd,SW_MAXIMIZE);
#endif

    UpdateWindow(hwnd);

    return hwnd;
}

long EXPORT FAR PASCAL SplashProc (
        HWND hwnd,
        UINT message,
        UINT wParam,
        LONG lParam)
{
    switch (message)
    {
        case WM_MOUSEACTIVATE:
            return MA_NOACTIVATEANDEAT;

        default:
            break;
    }

    return DefWindowProc (hwnd, message, wParam, lParam) ;
}


*
*
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\strings.inc ===
STRINGTABLE
BEGIN
	IDS_APP_TITLE       "Internet Connection Wizard"
	IDS_VERSION         "Internet Connection Wizard (Version 0.1)"
	IDS_DESCRIPTION     "Internet Connection Wizard Application"
END

STRINGTABLE
BEGIN
	IDS_INVALIDCMDLINE  "Invalid command line '%s'."
	IDS_NOCMDLINE       "The sign-up portion of the Internet Connection Wizard cannot be started using  'ISIGNUP.EXE'. To start the Internet Connection Wizard, click the Connection Wizard icon on the Start menu."
	IDS_INVALIDFILETYPE "'%s' is not a file type that can be processed by the Internet Connection Wizard."
	IDS_CANNOTPROCESSINS "Unable to process the Internet Signup file."
    IDS_SIGNUPCANCELLED "Internet Signup has been canceled."
    IDS_LAUNCHFAILED    "Could not launch Internet Explorer.\n\nPlease verify that Internet Explorer is installed."
    IDS_INSTALLFAILED   "The Internet Connection Wizard could not configure your computer for the Internet.\n\nYou will need to manually set up your own TCP/IP protocols, Dial-Up Networking, and modem, ISDN line, or other device you use to dial out from your computer."
    IDS_BADSETTINGS     "Received corrupted Internet Signup parameters.  Internet Signup has been canceled."
    IDS_RESTART         "You must restart your computer before the new settings will take effect.\n\nDo you want to restart your computer now?"
    IDS_RESTARTNOW      "You must restart your computer now for the new settings to take effect.\n\nIf you select Cancel, the signup process will be terminated."
    IDS_SETTINGCHANGE   "Systems Setting Change"
#ifdef WIN32
    IDS_SIGNUPCOMPLETE  "You are ready to connect to the Internet.\n\nTo continue, double click the Internet Explorer icon on your desktop."
#else
    IDS_SIGNUPCOMPLETE  "You are ready to connect to the Internet.\n\nTo continue, double click the Internet Explorer icon in the Program Manager."
#endif
    IDS_EXECFAILED      "Failed to execute %s.\n\nInternet Signup has been canceled."
	IDS_INSFILEWARNING	"Warning you are about to change your Internet settings.\n\nIf you wish to continue click OK, else click Cancel."
	IDS_BADSIGNUPFILE   "Internet Signup file is corrupt.  Signup aborted."
    IDS_MISSINGCFGDLL   "Unable to load the Internet Configuration library (INETCFG.DLL)."
    IDS_MISSINGRNADLL   "Unable to load the Remote Network Access library (RASAPI32.DLL)."
    IDS_WRONGRNADLLVER  "The Remote Network Access library (RASAPI32) is not the correct version. You may need a different version of Windows."
	IDS_PASSWORD		"Please record the following information for future use.\n\nAccount Name:  %s\nPassword:  %s"
	IDS_LOGONMESSAGE    "You must logon to retrieve your cached Internet password."
	IDS_LOGONCAPTION    "User Logon"
	IDS_SIGNUPLOGON     "You must logon to continue with the signup process."
    IDS_BROWSERTERMINATED "Internet Signup has been canceled."
    IDS_BROWSERNEVERFOUND "Internet Explorer window can not be found.\n\nInternet Signup has been canceled."
	IDS_INVALIDURL		"%s is not a valid URL or does not exist."
	IDS_INVALIDNOURL	"The specified URL is empty."
	IDS_MAILFAILED		"Could not install Windows Messaging and Internet Mail. You will need to install this before you can use Internet Mail services. Please contact your provider for assistance."
	IDS_ISP_DIAL_MESSAGE	"The Internet Connection Wizard will now connect to your Internet service provider."
	IDS_MISSINGIE		"The Internet Connection Wizard cannot continue because Internet Explorer is not properly installed.\n\nPlease install Internet Explorer and try again."

	IDS_IELOWVERSION	"The Internet Connection Wizard cannot continue because the version of Internet Explorer installed on your machine is not supported.\n\nPlease install Internet Explorer version %s or greater."
	// Localizers, please also see the corresponding version number string defined as IE_MINIMUM_VERSION_HUMAN_READABLE in isign32/isignup.h	
	IDS_SERVICEDISABLED "The Internet Connection Wizard could not start the RAS services and therefore cannot continue.  Please check the services control panel to make sure these services were installed properly and they are not disabled."
	IDS_RECONNECT_QUERY	"The modem connection has been interrupted.  The Internet Connection Wizard cannot proceed without this connection.  Do you want to reconnect?"

	IDS_SBSCFGERROR "Your small business server cannot process your Internet service information.  Contact your Internet service provider for help."
	IDS_ISPBROWSEFAIL   "The signup up for the service provider is temporarily unavailable.  Try again later or select a different service provider."
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isignup\isignup.h ===
#include <windows.h>
#include <locale.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isign32\utils.cpp ===
#include "isignup.h"

#ifndef MB_ICONERROR
#define MB_ICONERROR        MB_ICONHAND
#endif
#ifndef MB_SETFOREGROUND
#define MB_SETFOREGROUND    0
#endif
#define MAX_STRING      256
                             
static const HWND hwndNil = NULL;

BOOL WarningMsg(HWND hwnd, UINT uId)
{
    TCHAR szMsg[MAX_STRING + 1];

    LoadString(
            ghInstance,
            uId,
            szMsg,
            sizeof(szMsg));

    return (MessageBox(
            hwnd,
            szMsg,
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONEXCLAMATION |
            MB_OKCANCEL) == IDOK);
}

void ErrorMsg(HWND hwnd, UINT uId)
{
    TCHAR szMsg[MAX_STRING + 1];

    LoadString(
            ghInstance,
            uId,
            szMsg,
            sizeof(szMsg));

    MessageBox(
            hwnd,
            szMsg,
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONERROR |
            MB_OK);
}

void ErrorMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg)
{
    TCHAR szTemp[MAX_STRING + 1];
    TCHAR szMsg[MAX_STRING + 1];

    LoadString(
            ghInstance,
            uId,
            szTemp,
            sizeof(szTemp));

    wsprintf(szMsg, szTemp, lpszArg);

    MessageBox(
            hwnd,
            szMsg,
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONERROR |
            MB_OK);
}

void InfoMsg(HWND hwnd, UINT uId)
{
    TCHAR szMsg[MAX_STRING];

    LoadString(
            ghInstance,
            uId,
            szMsg,
            sizeof(szMsg));

    MessageBox(
            hwnd,
            szMsg,
            cszAppName,
            MB_SETFOREGROUND |
            MB_ICONINFORMATION |
            MB_OK);
}

int PromptR(HWND hwnd, UINT uId, UINT uType)
{
    TCHAR szMsg[MAX_STRING + 1];
    TCHAR szCaption[MAX_STRING + 1];

    LoadString(
            ghInstance,
            uId,
            szMsg,
            sizeof(szMsg));

    LoadString(
            ghInstance,
            IDS_SETTINGCHANGE,
            szCaption,
            sizeof(szMsg));

    return MessageBox(
            hwnd,
            szMsg,
            szCaption,
            uType);
}

 

BOOL PromptRestart(HWND hwnd)
{
    return (PromptR(
            hwnd,
            IDS_RESTART,
            MB_SETFOREGROUND |
            MB_ICONQUESTION |
            MB_YESNO) == IDYES);
}

BOOL PromptRestartNow(HWND hwnd)
{
    return (PromptR(
            hwnd,
            IDS_RESTARTNOW,
            MB_SETFOREGROUND |
            MB_ICONINFORMATION |
            MB_OKCANCEL) == IDOK);
}

/*  C E N T E R  W I N D O W */
/*-------------------------------------------------------------------------
    %%Function: CenterWindow

    Center a window over another window.
-------------------------------------------------------------------------*/
VOID CenterWindow(HWND hwndChild, HWND hwndParent)
{
    int   xNew, yNew;
    int   cxChild, cyChild;
    int   cxParent, cyParent;
    int   cxScreen, cyScreen;
    RECT  rcChild, rcParent;
    HDC   hdc;

    // Get the Height and Width of the child window
    GetWindowRect(hwndChild, &rcChild);
    cxChild = rcChild.right - rcChild.left;
    cyChild = rcChild.bottom - rcChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect(hwndParent, &rcParent);
    cxParent = rcParent.right - rcParent.left;
    cyParent = rcParent.bottom - rcParent.top;

    // Get the display limits
    hdc = GetDC(hwndChild);
    if (hdc == NULL) {
        // major problems - move window to 0,0
        xNew = yNew = 0;
    } else {
        cxScreen = GetDeviceCaps(hdc, HORZRES);
        cyScreen = GetDeviceCaps(hdc, VERTRES);
        ReleaseDC(hwndChild, hdc);

        if (hwndParent == hwndNil) {
            cxParent = cxScreen;
            cyParent = cyScreen;
            SetRect(&rcParent, 0, 0, cxScreen, cyScreen);
        }

        // Calculate new X position, then adjust for screen
        xNew = rcParent.left + ((cxParent - cxChild) / 2);
        if (xNew < 0) {
            xNew = 0;
        } else if ((xNew + cxChild) > cxScreen) {
            xNew = cxScreen - cxChild;
        }

        // Calculate new Y position, then adjust for screen
        yNew = rcParent.top  + ((cyParent - cyChild) / 2);
        if (yNew < 0) {
            yNew = 0;
        } else if ((yNew + cyChild) > cyScreen) {
            yNew = cyScreen - cyChild;
        }

    }

    SetWindowPos(hwndChild, NULL, xNew, yNew,   0, 0,
        SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isignup\isignupx.cpp ===
//****************************************************************************
//
//  Module:     ISIGNUP.EXE
//  File:       isignupx.c
//  Content:    This is the "main" file for the internet signup "wizard".
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "isignup.h"

#ifndef EXPORT
#ifdef WIN32
#define EXPORT
#else
#define EXPORT _export
#endif
#endif


typedef int (WINAPI * SIGNUP)
        (HANDLE hInstance, HANDLE hPrevInstance,
        LPTSTR lpszCmdLine, int nCmdShow);

CHAR szSignup[] = "Signup";
#ifdef WIN32
TCHAR szSignupDll[] = TEXT("isign32.dll");
#else
char szSignupDll[] = "isign16.dll";
#endif

int EXPORT WINAPI Signup(HANDLE hInstance, HANDLE hPrevInstance,
                   LPTSTR lpszCmdLine, int nCmdShow);

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpszCmdLine, int nCmdShow)
{
    HINSTANCE hLib;
    SIGNUP lpfnSignup;
    int iRet = 0;
    
#ifdef UNICODE
    // Initialize the C runtime locale to the system locale.
    setlocale(LC_ALL, "");
#endif

    hLib = LoadLibrary(szSignupDll);
    if (NULL != hLib)
    {
        lpfnSignup = (SIGNUP)GetProcAddress(hLib, szSignup);
        if (NULL != lpfnSignup)
        {
#ifdef UNICODE
            TCHAR szCmdLineTmp[256];
            if(lpszCmdLine)
                mbstowcs(szCmdLineTmp, lpszCmdLine, 256);
            iRet = lpfnSignup(hInstance, hPrevInstance, szCmdLineTmp, nCmdShow);
#else
            iRet = lpfnSignup(hInstance, hPrevInstance, lpszCmdLine, nCmdShow);
#endif
        }
        FreeLibrary(hLib);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\isignup\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

MAJORCOMP=GETCONN
MINORCOMP=ISIGNUP

TARGETNAME=ISIGNUP
TARGETTYPE=PROGRAM
TARGETPATH=obj
UMTYPE=windows
UMENTRY=winmain

NOT_LEAN_AND_MEAN=1
RCNOFONTMAP=1
C_DEFINES = -DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT40=1

SOURCES= \
    ..\isignup.rc   \
    ..\isignupx.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\kernel32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\lib\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     =  ..\..

!include $(GETCONN_DIR)\common.inc

# Make sure this is built before we continue
SYNCHRONIZE_BLOCK = 1

SOURCES_USED    = $(SOURCES_USED) $(GETCONN_DIR)\common.inc

TARGETNAME      = stocklib
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\debug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\lib\debug.c ===
//
// Debug squirty functions
//

#include "proj.h"
#pragma  hdrstop

#if defined(DEBUG) || defined(PRODUCT_PROF)
// (c_szCcshellIniFile and c_szCcshellIniSecDebug are declared in debug.h)
extern CHAR const FAR c_szCcshellIniFile[];
extern CHAR const FAR c_szCcshellIniSecDebug[];

/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

Cond:    --
*/
static
BOOL
MyStrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    BOOL bRet;
    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = CharNextA(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
        }

    // Or is this hexadecimal?
    //
    pszAdj = CharNextA(psz);
    if ((STIF_SUPPORT_HEX & dwFlags) &&
        *psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;
        psz = CharNextA(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = CharNextA(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }
    else
        {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGIT(*psz); psz = CharNextA(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }

    *piRet = bNeg ? -n : n;

    return bRet;
    }

#endif

#ifdef DEBUG

DWORD g_dwDumpFlags     = 0;        // DF_*
#ifdef FULL_DEBUG
DWORD g_dwBreakFlags    = BF_ONVALIDATE;        // BF_*
#else
DWORD g_dwBreakFlags    = 0;        // BF_*
#endif
DWORD g_dwTraceFlags    = 0;        // TF_*
DWORD g_dwPrototype     = 0;        
DWORD g_dwFuncTraceFlags = 0;       // FTF_*

// TLS slot used to store depth for CcshellFuncMsg indentation

static DWORD g_tlsStackDepth = TLS_OUT_OF_INDEXES;

// Hack stack depth counter used when g_tlsStackDepth is not available

static DWORD g_dwHackStackDepth = 0;

static char g_szIndentLeader[] = "                                                                                ";

static WCHAR g_wszIndentLeader[] = L"                                                                                ";


#pragma data_seg(DATASEG_READONLY)

static CHAR const FAR c_szNewline[] = "\r\n";   // (Deliberately CHAR)
static WCHAR const FAR c_wszNewline[] = TEXTW("\r\n");

#pragma data_seg()

extern CHAR const FAR c_szTrace[];              // (Deliberately CHAR)
extern CHAR const FAR c_szErrorDbg[];           // (Deliberately CHAR)
extern CHAR const FAR c_szWarningDbg[];         // (Deliberately CHAR)
extern WCHAR const FAR c_wszTrace[];
extern WCHAR const FAR c_wszErrorDbg[]; 
extern WCHAR const FAR c_wszWarningDbg[];

extern const CHAR  FAR c_szAssertMsg[];
extern CHAR const FAR c_szAssertFailed[];
extern const WCHAR  FAR c_wszAssertMsg[];
extern WCHAR const FAR c_wszAssertFailed[];


void
SetPrefixStringA(
    OUT LPSTR pszBuf,
    IN  DWORD dwFlags)
{
    if (TF_ALWAYS == dwFlags)
        lstrcpyA(pszBuf, c_szTrace);
    else if (IsFlagSet(dwFlags, TF_WARNING))
        lstrcpyA(pszBuf, c_szWarningDbg);
    else if (IsFlagSet(dwFlags, TF_ERROR))
        lstrcpyA(pszBuf, c_szErrorDbg);
    else
        lstrcpyA(pszBuf, c_szTrace);
}


void
SetPrefixStringW(
    OUT LPWSTR pszBuf,
    IN  DWORD  dwFlags)
{
    if (TF_ALWAYS == dwFlags)
        lstrcpyW(pszBuf, c_wszTrace);
    else if (IsFlagSet(dwFlags, TF_WARNING))
        lstrcpyW(pszBuf, c_wszWarningDbg);
    else if (IsFlagSet(dwFlags, TF_ERROR))
        lstrcpyW(pszBuf, c_wszErrorDbg);
    else
        lstrcpyW(pszBuf, c_wszTrace);
}


// Hack!  The MSDEV debugger has some smarts where if it sees
// an ASSERT (all caps) in the source, and there is a debug break,
// then it sticks up a sorta friendly assert message box.
// For the debug function below where the break occurs inside,
// we add a nop ASSERT line in here to fake MSDEV to give us
// a friendly message box.

#undef ASSERT
#define ASSERT(f)   DEBUG_BREAK



// BUGBUG (scotth): Use the Ccshell functions.  _AssertMsg and
// _DebugMsg are obsolete.  They will be removed once all the 
// components don't have TEXT() wrapping their debug strings anymore.


void 
WINCAPI 
_AssertMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);

        wvsprintfA(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
            ASSERT(0);
    }
}

void 
WINCAPI 
_AssertMsgW(
    BOOL f, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);

        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
            ASSERT(0);
    }
}

void 
_AssertStrLenW(
    LPCWSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenW(pszStr))
    {                                           
        ASSERT(0);
    }
}

void 
_AssertStrLenA(
    LPCSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenA(pszStr))
    {                                           
        ASSERT(0);
    }
}

void 
WINCAPI 
_DebugMsgA(
    DWORD flag, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringA(ach, flag);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfA(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringA(pszMsg);
        }

        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            DEBUG_BREAK;
        }
    }
}

void 
WINCAPI 
_DebugMsgW(
    DWORD flag, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfW(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringW(pszMsg);
        }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            DEBUG_BREAK;
        }
    }
}


//
//  Smart debug functions
//



/*----------------------------------------------------------
Purpose: Displays assertion string.

Returns: TRUE to debugbreak
Cond:    --
*/
BOOL
CDECL
CcshellAssertFailedA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlenA(pszFile); psz != pszFile; psz=CharPrevA(pszFile, psz))
    {
        if ((CharPrevA(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wsprintfA(ach, c_szAssertFailed, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
    {
        if (bBreakInside)
        {
            // See the hack we have above about redefining ASSERT
            ASSERT(0);
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays assertion string.

Returns: --
Cond:    --
*/
BOOL
CDECL
CcshellAssertFailedW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[256];

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlenW(pszFile); psz && (psz != pszFile); psz=CharPrevW(pszFile, psz))
    {
        if ((CharPrevW(pszFile, psz)!= (psz-2)) && *(psz - 1) == TEXT('\\'))
            break;
    }

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  We can get this
    // if we get an assert in some of the W functions in shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellAssertFailedA(szFile, line, szEval, bBreakInside);
    }

    wsprintfW(ach, c_wszAssertFailed, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
    {
        if (bBreakInside)
        {
            // See the hack we have above about redefining ASSERT
            ASSERT(0);
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for function call trace
         messages.

Returns: --
Cond:    --
*/
void
CcshellStackEnter(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = (DWORD)((DWORD_PTR)TlsGetValue(g_tlsStackDepth));

        TlsSetValue(g_tlsStackDepth, (LPVOID)((DWORD_PTR)dwDepth + 1));
        }
    else
        {
        g_dwHackStackDepth++;
        }
    }


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for functionc all trace
         messages.

Returns: --
Cond:    --
*/
void
CcshellStackLeave(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = (DWORD)((DWORD_PTR)TlsGetValue(g_tlsStackDepth));

        if (EVAL(0 < dwDepth))
            {
            EVAL(TlsSetValue(g_tlsStackDepth, (LPVOID)((DWORD_PTR)dwDepth - 1)));
            }
        }
    else
        {
        if (EVAL(0 < g_dwHackStackDepth))
            {
            g_dwHackStackDepth--;
            }
        }
    }


/*----------------------------------------------------------
Purpose: Return the stack depth.

Returns: see above
Cond:    --
*/
static
DWORD
CcshellGetStackDepth(void)
    {
    DWORD dwDepth;

    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        dwDepth = (DWORD)((DWORD_PTR)TlsGetValue(g_tlsStackDepth));
        }
    else
        {
        dwDepth = g_dwHackStackDepth;
        }

    return dwDepth;
    }


/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

Cond:    --
*/
BOOL
UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
        {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            pwsz = pwszBuf;
            }

        if (pwsz)
            {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppwszWide = pwsz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppwszWide);
            *ppwszWide = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellAssertMsgA
Returns: --
Cond:    --
*/
void
CDECL
CcshellAssertMsgW(
    BOOL f,
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
        {
        int cch;
#if 0
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
#endif

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

#if 0
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }
#endif
        // This is a W version of CcshellDebugMsg.
        // Don't need to call UnicodeFromAnsi
        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
            ASSERT(0);
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellDebugMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

Returns: --
Cond:    --
*/
void
CDECL
CcshellDebugMsgW(
    DWORD flag,
    LPCWSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;
#if 0
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
#endif

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

#if 0
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
        {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }
#endif
        // This is a W version of CcshellDebugMsg.
        // Don't need to call UnicodeFromAnsi
        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            DEBUG_BREAK;
        }
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellFuncMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

Returns: --
Cond:    --
*/
void
CDECL
CcshellFuncMsgW(
    DWORD flag,
    LPCWSTR pszMsg, ...)         // (this is deliberately CHAR)
    {
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_dwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
#if 0
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
#endif
        DWORD dwStackDepth;
        LPWSTR pszLeaderEnd;
        WCHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < SIZECHARS(g_szIndentLeader))
            {
            pszLeaderEnd = &g_wszIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_wszIndentLeader[SIZECHARS(g_wszIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfW(ach, L"%s %s", c_wszTrace, g_wszIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

#if 0
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }
#endif
        // This is a W version of CcshellDebugMsg.
        // Don't need to call UnicodeFromAnsi
        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Assert failed message only
Returns: --
Cond:    --
*/
void
CDECL
CcshellAssertMsgA(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
            ASSERT(0);
    }
}


/*----------------------------------------------------------
Purpose: Debug spew
Returns: --
Cond:    --
*/
void
CDECL
CcshellDebugMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringA(ach, flag);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            DEBUG_BREAK;
        }
    }
}


/*----------------------------------------------------------
Purpose: Debug spew for function trace calls
Returns: --
Cond:    --
*/
void
CDECL
CcshellFuncMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
    {
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_dwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        DWORD dwStackDepth;
        LPSTR pszLeaderEnd;
        CHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < sizeof(g_szIndentLeader))
            {
            pszLeaderEnd = &g_szIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_szIndentLeader[sizeof(g_szIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfA(ach, "%s %s", c_szTrace, g_szIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);
        }
    }


//
//  Debug .ini functions
//


#pragma data_seg(DATASEG_READONLY)

// (These are deliberately CHAR)
CHAR const FAR c_szNull[] = "";
CHAR const FAR c_szZero[] = "0";
CHAR const FAR c_szIniKeyBreakFlags[] = "BreakFlags";
CHAR const FAR c_szIniKeyTraceFlags[] = "TraceFlags";
CHAR const FAR c_szIniKeyFuncTraceFlags[] = "FuncTraceFlags";
CHAR const FAR c_szIniKeyDumpFlags[] = "DumpFlags";
CHAR const FAR c_szIniKeyProtoFlags[] = "Prototype";

#pragma data_seg()


// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCTSTR pszSectionName;
    LPCTSTR pszKeyName;
    LPCTSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    } INTINIKEY;


#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {CHAR sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


#ifdef BOOL_INI_VALUES
/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszTrue[] =
    {
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszFalse[] =
    {
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
    };
#endif


#ifdef BOOL_INI_VALUES
/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
Cond:    --
*/
BOOL
PRIVATE
IsIniYes(
    LPCTSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    Assert(psz);

    /* Is the value TRUE? */

    for (i = 0; i < ARRAYSIZE(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAYSIZE(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            TraceMsg(TF_WARNING, "IsIniYes() called on unknown Boolean RHS '%s'.", psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
Returns: --
Cond:    --
*/
void
PRIVATE
ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAX_BUF];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, TEXT(""), szRHS,
                                   SIZECHARS(szRHS), c_szCcshellIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s set in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s cleared in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }
#endif


#ifdef UNICODE

/*----------------------------------------------------------
Purpose: This function converts a wide-char string to a multi-byte
         string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszAnsi will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszWide is NULL, then *ppszAnsi will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

Cond:    --
*/
static
BOOL
MyAnsiFromUnicode(
    LPSTR * ppszAnsi,
    LPCWSTR pwszWide,        // NULL to clean up
    LPSTR pszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
        {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)LocalAlloc(LPTR, CbFromCchA(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            Assert(pszBuf);
            psz = pszBuf;
            }

        if (psz)
            {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppszAnsi = psz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppszAnsi);
            *ppszAnsi = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char wrapper for StrToIntExA.

Returns: see StrToIntExA
Cond:    --
*/
static
BOOL
MyStrToIntExW(
    LPCWSTR   pwszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
    {
    // Most strings will simply use this temporary buffer, but AnsiFromUnicode
    // will allocate a buffer if the supplied string is bigger.
    CHAR szBuf[MAX_PATH];

    LPSTR pszString;
    BOOL bRet = MyAnsiFromUnicode(&pszString, pwszString, szBuf, SIZECHARS(szBuf));

    if (bRet)
        {
        bRet = MyStrToIntExA(pszString, dwFlags, piRet);
        MyAnsiFromUnicode(&pszString, NULL, szBuf, 0);
        }
    return bRet;
    }
#endif // UNICODE


#ifdef UNICODE
#define MyStrToIntEx        MyStrToIntExW
#else
#define MyStrToIntEx        MyStrToIntExA
#endif



/*----------------------------------------------------------
Purpose: This function reads a .ini file to determine the debug
         flags to set.  The .ini file and section are specified
         by the following manifest constants:

                SZ_DEBUGINI
                SZ_DEBUGSECTION

         The debug variables that are set by this function are
         g_dwDumpFlags, g_dwTraceFlags, g_dwBreakFlags, and
         g_dwFuncTraceFlags, g_dwPrototype.

Returns: TRUE if initialization is successful
Cond:    --
*/
BOOL
PUBLIC
CcshellGetDebugFlags(void)
    {
    CHAR szRHS[MAX_PATH];
    int val;

    // BUGBUG (scotth): Yes, COMCTL32 exports StrToIntEx, but I
    //  don't want to cause a dependency delta and force everyone
    //  to get a new comctl32 just because they built debug.
    //  So use a local version of StrToIntEx.

    // Trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwTraceFlags = (DWORD)val;

    TraceMsgA(TF_GENERAL, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyTraceFlags, g_dwTraceFlags);

    // Function trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyFuncTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwFuncTraceFlags = (DWORD)val;

    TraceMsgA(TF_GENERAL, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyFuncTraceFlags, g_dwFuncTraceFlags);

    // Dump Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyDumpFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwDumpFlags = (DWORD)val;

    TraceMsgA(TF_GENERAL, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyDumpFlags, g_dwDumpFlags);

    // Break Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyBreakFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwBreakFlags = (DWORD)val;

    TraceMsgA(TF_GENERAL, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyBreakFlags, g_dwBreakFlags);

    // Prototype Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyProtoFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwPrototype = (DWORD)val;

    TraceMsgA(TF_GENERAL, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyProtoFlags, g_dwPrototype);

    return TRUE;
    }


#endif // DEBUG

#ifdef PRODUCT_PROF

DWORD g_dwProfileCAP = 0;        

BOOL PUBLIC CcshellGetDebugFlags(void)
{
    CHAR szRHS[MAX_PATH];
    int val;

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "Profile",
                            "",
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwProfileCAP = (DWORD)val;

    return TRUE;
}
#endif // PRODUCT_PROF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\lib\proj.h ===
//
// proj.h:      Main header
//
//


#ifndef __PROJ_H__
#define __PROJ_H__

#define STRICT

#if defined(WINNT) || defined(WINNT_ENV)

//
// NT uses DBG=1 for its debug builds, but the Win95 shell uses
// DEBUG.  Do the appropriate mapping here.
//
#if DBG
#define DEBUG 1
#endif

#endif  // WINNT

#include <windows.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <shlobj.h>
#include <port32.h>
#include <ccstock.h>
#include "..\inc\debug.h"

#include <shlobj.h>

#endif // __PROJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mapidbg.h ===
/*
 *  M A P I D B G . H
 *
 *  Debugging support for MAPI service providers.
 *  Support functions are implemented in MAPIDBG.C.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef __MAPIDBG_H_
#define __MAPIDBG_H_

/*
 * Debugging Macros -------------------------------------------------------
 *
 *      IFDBG(x)        Results in the expression x if DEBUG is defined, or
 *                      to nothing if DEBUG is not defined
 *  
 *      IFNDBG(x)       Results in the expression x if DEBUG is not defined,
 *                      or to nothing if DEBUG is defined
 *  
 *      Unreferenced(a) Causes a to be referenced so that the compiler
 *                      doesn't issue warnings about unused local variables
 *                      which exist but are reserved for future use (eg
 *                      ulFlags in many cases)
 */

#if defined(DEBUG)
#define IFDBG(x)            x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)           x
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN      extern "C" {
#define EXTERN_C_END        }
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

#define dimensionof(a)      (sizeof(a)/sizeof(*(a)))

#define Unreferenced(a)     ((void)(a))

typedef long SCODE;
typedef unsigned long ULONG;
typedef unsigned long DWORD;

/*
 *   Assert Macros ---------------------------------------------------------
 *  
 *      Assert(a)       Displays a message indicating the file and line number
 *                      of this Assert() if a == 0.  OK'ing an assert traps
 *                      into the debugger.
 *  
 *      AssertSz(a,sz)  Works like an Assert(), but displays the string sz
 *                      along with the file and line number.
 *  
 *      Side asserts    A side assert works like an Assert(), but evaluates
 *                      'a' even when asserts are not enabled.
 *  
 *      NF asserts      A NF (Non-Fatal) assert works like an Assert(), but
 *                      continues instead of trapping into the debugger when
 *                      OK'ed.
 */

#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)           x
#else
#define IFTRAP(x)           0
#endif

#define Trap()                                          IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)                                     IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))
#define TrapSz1(psz,a1)                                 IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1))
#define TrapSz2(psz,a1,a2)                              IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2))
#define TrapSz3(psz,a1,a2,a3)                           IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3))
#define TrapSz4(psz,a1,a2,a3,a4)                        IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4))
#define TrapSz5(psz,a1,a2,a3,a4,a5)                     IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5))
#define TrapSz6(psz,a1,a2,a3,a4,a5,a6)                  IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6))
#define TrapSz7(psz,a1,a2,a3,a4,a5,a6,a7)               IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7))
#define TrapSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)            IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TrapSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)         IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

#define Assert(t)                                       IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)                                 IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))
#define AssertSz1(t,psz,a1)                             IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1),0))
#define AssertSz2(t,psz,a1,a2)                          IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2),0))
#define AssertSz3(t,psz,a1,a2,a3)                       IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define AssertSz4(t,psz,a1,a2,a3,a4)                    IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define AssertSz5(t,psz,a1,a2,a3,a4,a5)                 IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define AssertSz6(t,psz,a1,a2,a3,a4,a5,a6)              IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define AssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)           IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define AssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)        IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define AssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)     IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define SideAssert(t)                                   ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)                             ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)
#define SideAssertSz1(t,psz,a1)                         ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1)),0)
#define SideAssertSz2(t,psz,a1,a2)                      ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2)),0)
#define SideAssertSz3(t,psz,a1,a2,a3)                   ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define SideAssertSz4(t,psz,a1,a2,a3,a4)                ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define SideAssertSz5(t,psz,a1,a2,a3,a4,a5)             ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define SideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)          ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define SideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)       ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define SideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)    ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define SideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9) ((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

#define NFAssert(t)                                     IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define NFAssertSz(t,psz)                               IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz),0))
#define NFAssertSz1(t,psz,a1)                           IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1),0))
#define NFAssertSz2(t,psz,a1,a2)                        IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2),0))
#define NFAssertSz3(t,psz,a1,a2,a3)                     IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define NFAssertSz4(t,psz,a1,a2,a3,a4)                  IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define NFAssertSz5(t,psz,a1,a2,a3,a4,a5)               IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define NFAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)            IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define NFAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)         IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define NFAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)      IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define NFAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)   IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define NFSideAssert(t)                                 ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define NFSideAssertSz(t,psz)                           ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz)),0)
#define NFSideAssertSz1(t,psz,a1)                       ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1)),0)
#define NFSideAssertSz2(t,psz,a1,a2)                    ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2)),0)
#define NFSideAssertSz3(t,psz,a1,a2,a3)                 ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define NFSideAssertSz4(t,psz,a1,a2,a3,a4)              ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define NFSideAssertSz5(t,psz,a1,a2,a3,a4,a5)           ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define NFSideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)        ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define NFSideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)     ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define NFSideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)  ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define NFSideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)   ((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

/*
 *   Trace Macros ------------------------------------------------------------
 *  
 *      DebugTrace          Use for arbitrary formatted output. It
 *                          takes exactly the same arguments as the
 *                          Windows wsprintf() function.
 *      DebugTraceResult    Shorthand for error tracing with an
 *                          HRESULT. Arguments are the name of the
 *                          function (not quoted) and the HRESULT.
 *      DebugTraceSc        Shorthand for error tracing with an
 *                          SCODE. Arguments are the name of the
 *                          function (not quoted) and the SCODE.
 *      DebugTraceArg       Shorthand for invalid parameter
 *                          tracing. Arguments are the name of the
 *                          function (not quoted) and a quoted
 *                          string describing the bad parameter.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)          x
#define DebugTrace          DebugTraceFn
#else
#define IFTRACE(x)          0
#define DebugTrace          1?0:DebugTraceFn
#endif

#define DebugTraceResult(f,hr)                          IFTRACE(((hr) ? DebugTraceFn(#f " returns 0x%08lX %s\n", GetScode(hr), SzDecodeScode(GetScode(hr))) : 0))
#define DebugTraceSc(f,sc)                              IFTRACE(((sc) ? DebugTraceFn(#f " returns 0x%08lX %s\n", sc, SzDecodeScode(sc)) : 0))
#define DebugTraceArg(f,s)                              IFTRACE(DebugTraceFn(#f ": bad parameter: " s "\n"))
#define DebugTraceLine()                                IFTRACE(DebugTraceFn("File %s, Line %i  \n",__FILE__,__LINE__))
#define DebugTraceProblems(sz, rgprob)                  IFTRACE(DebugTraceProblemsFn(sz, rgprob))

#define TraceSz(psz)                                    IFTRACE(DebugTraceFn("~" psz))
#define TraceSz1(psz,a1)                                IFTRACE(DebugTraceFn("~" psz,a1))
#define TraceSz2(psz,a1,a2)                             IFTRACE(DebugTraceFn("~" psz,a1,a2))
#define TraceSz3(psz,a1,a2,a3)                          IFTRACE(DebugTraceFn("~" psz,a1,a2,a3))
#define TraceSz4(psz,a1,a2,a3,a4)                       IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4))
#define TraceSz5(psz,a1,a2,a3,a4,a5)                    IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5))
#define TraceSz6(psz,a1,a2,a3,a4,a5,a6)                 IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6))
#define TraceSz7(psz,a1,a2,a3,a4,a5,a6,a7)              IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7))
#define TraceSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)           IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TraceSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)        IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

/* Debugging Functions ---------------------------------------------------- */

EXTERN_C_BEGIN

#ifdef WIN16
#define EXPORTDBG   __export
#else
#define EXPORTDBG
#endif

int EXPORTDBG __cdecl       DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
int EXPORTDBG __cdecl       DebugTraceFn(char *pszFormat, ...);
void EXPORTDBG __cdecl      DebugTraceProblemsFn(char *sz, void *rgprob);
char * EXPORTDBG __cdecl    SzDecodeScodeFn(SCODE sc);
char * EXPORTDBG __cdecl    SzDecodeUlPropTypeFn(unsigned long ulPropType);
char * EXPORTDBG __cdecl    SzDecodeUlPropTagFn(unsigned long ulPropTag);
unsigned long EXPORTDBG __cdecl UlPropTagFromSzFn(char *psz);
SCODE EXPORTDBG __cdecl     ScodeFromSzFn(char *psz);
void * EXPORTDBG __cdecl    DBGMEM_EncapsulateFn(void * pmalloc, char *pszSubsys, int fCheckOften);
void EXPORTDBG __cdecl      DBGMEM_ShutdownFn(void * pmalloc);
void EXPORTDBG __cdecl      DBGMEM_CheckMemFn(void * pmalloc, int fReportOrphans);
void EXPORTDBG __cdecl      DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv);
void EXPORTDBG __cdecl      DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt);
SCODE EXPORTDBG __cdecl     ScCheckScFn(SCODE, SCODE *, char *, char *, int);
void                        GetCallStack(DWORD *, int, int);
void *                      VMAlloc(ULONG);
void *                      VMAllocEx(ULONG, ULONG);
void *                      VMRealloc(void *, ULONG);
void *                      VMReallocEx(void *, ULONG, ULONG);
ULONG                       VMGetSize(void *);
ULONG                       VMGetSizeEx(void *, ULONG);
void                        VMFree(void *);
void                        VMFreeEx(void *, ULONG);

EXTERN_C_END

/*
 *  Debugging Macros -------------------------------------------------------
 *  
 *      SzDecodeScode           Returns the string name of an SCODE
 *      SzDecodeUlPropTag       Returns the string name of a property
 *                              tag
 *      UlPropTagFromSz         Given a property tag's name, returns
 *                              its value
 *      ScodeFromSz             Given an SCODE's name, returns its
 *                              value
 *  
 *      DBGMEM_Encapsulate      Given an IMalloc interface, adds heap-
 *                              checking functionality and returns a
 *                              wrapped interface
 *      DBGMEM_Shutdown         Undoes DBGMEM_Encapsulate, and prints
 *                              out information on any allocations made
 *                              since the interface was encapsulated
 *                              that have not yet been released.
 *      DBGMEM_CheckMem         Checks all memory allocated on the heap,
 *                              and optionally reports leaked blocks.
 *      DBGMEM_NoLeakDetect     Prevents a block from appearing on the leak
 *                              report.  Pass NULL for pv to inhibit leak
 *                              reports at all from this heap.
 */

#ifdef DEBUG

#define SzDecodeScode(_sc)              SzDecodeScodeFn(_sc)
#define SzDecodeUlPropType(_ulPropType) SzDecodeUlPropTypeFn(_ulPropType)
#define SzDecodeUlPropTag(_ulPropTag)   SzDecodeUlPropTagFn(_ulPropTag)
#define UlPropTagFromSz(_sz)            UlPropTagFromSzFn(_sz)
#define ScodeFromSz(_sz)                ScodeFromSzFn(_sz)
#define DBGMEM_Encapsulate(pm, psz, f)  DBGMEM_EncapsulateFn(pm, psz, f)
#define DBGMEM_Shutdown(pm)             DBGMEM_ShutdownFn(pm)
#define DBGMEM_CheckMem(pm, f)          DBGMEM_CheckMemFn(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)     DBGMEM_NoLeakDetectFn(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)     DBGMEM_SetFailureAtFn(pm, ul)

#else

#define SzDecodeScode(_sc)              (0)
#define SzDecodeUlPropType(_ulPropType) (0)
#define SzDecodeUlPropTag(_ulPropTag)   (0)
#define UlPropTagFromSz(_sz)            (0)
#define ScodeFromSz(_sz)                (0)

#if defined(__cplusplus) && !defined(CINTERFACE)
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
    ((pmalloc)->AddRef(), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
    ((pmalloc)->Release())
#else
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
    ((pmalloc)->lpVtbl->AddRef(pmalloc), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
    ((pmalloc)->lpVtbl->Release(pmalloc))
#endif
#define DBGMEM_CheckMem(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)

#endif

/*
 *  SCODE maps -------------------------------------------------------------
 *  
 *      ScCheckSc       Given an SCODE and method name, verifies
 *                      that the SCODE can legally be returned from
 *                      thet method. Prints out a debug string if
 *                      it cannot.
 *      HrCheckHr       As ScCheckSc, for functions that return
 *                      HRESULT.
 */

#if defined(DEBUG) && !defined(DOS)
#define ScCheckSc(sc,fn)                ScCheckScFn(sc,fn##_Scodes,#fn,__FILE__, __LINE__)
#define HrCheckHr(hr,fn)                HrCheckSc(GetScode(hr),fn)
#else
#define ScCheckSc(sc,fn)                (sc)
#define HrCheckHr(hr,fn)                (hr)
#endif

#define HrCheckSc(sc,fn)                ResultFromScode(ScCheckSc(sc,fn))

#if defined(DEBUG) && !defined(DOS)
extern SCODE Common_Scodes[];
extern SCODE MAPILogon_Scodes[];
extern SCODE MAPIAllocateBuffer_Scodes[];
extern SCODE MAPIAllocateMore_Scodes[];
extern SCODE MAPIFreeBuffer_Scodes[];

extern SCODE IUnknown_QueryInterface_Scodes[];
extern SCODE IUnknown_AddRef_Scodes[];
extern SCODE IUnknown_Release_Scodes[];
extern SCODE IUnknown_GetLastError_Scodes[];

extern SCODE IMAPIProp_CopyTo_Scodes[];
extern SCODE IMAPIProp_CopyProps_Scodes[];
extern SCODE IMAPIProp_DeleteProps_Scodes[];
extern SCODE IMAPIProp_GetIDsFromNames_Scodes[];
extern SCODE IMAPIProp_GetLastError_Scodes[];
extern SCODE IMAPIProp_GetNamesFromIDs_Scodes[];
extern SCODE IMAPIProp_GetPropList_Scodes[];
extern SCODE IMAPIProp_GetProps_Scodes[];
extern SCODE IMAPIProp_OpenProperty_Scodes[];
extern SCODE IMAPIProp_SetProps_Scodes[];
extern SCODE IMAPIProp_SaveChanges_Scodes[];

extern SCODE IStream_Read_Scodes[];
extern SCODE IStream_Write_Scodes[];
extern SCODE IStream_Seek_Scodes[];
extern SCODE IStream_SetSize_Scodes[];
extern SCODE IStream_Tell_Scodes[];
extern SCODE IStream_LockRegion_Scodes[];
extern SCODE IStream_UnlockRegion_Scodes[];
extern SCODE IStream_Clone_Scodes[];
extern SCODE IStream_CopyTo_Scodes[];
extern SCODE IStream_Revert_Scodes[];
extern SCODE IStream_Stat_Scodes[];
extern SCODE IStream_Commit_Scodes[];

extern SCODE IMAPITable_GetLastError_Scodes[];
extern SCODE IMAPITable_Advise_Scodes[];
extern SCODE IMAPITable_Unadvise_Scodes[];
extern SCODE IMAPITable_GetStatus_Scodes[];
extern SCODE IMAPITable_SetColumns_Scodes[];
extern SCODE IMAPITable_QueryColumns_Scodes[];
extern SCODE IMAPITable_GetRowCount_Scodes[];
extern SCODE IMAPITable_SeekRow_Scodes[];
extern SCODE IMAPITable_SeekRowApprox_Scodes[];
extern SCODE IMAPITable_QueryPosition_Scodes[];
extern SCODE IMAPITable_FindRow_Scodes[];
extern SCODE IMAPITable_Restrict_Scodes[];
extern SCODE IMAPITable_CreateBookmark_Scodes[];
extern SCODE IMAPITable_FreeBookmark_Scodes[];
extern SCODE IMAPITable_SortTable_Scodes[];
extern SCODE IMAPITable_QuerySortOrder_Scodes[];
extern SCODE IMAPITable_QueryRows_Scodes[];
extern SCODE IMAPITable_Abort_Scodes[];
extern SCODE IMAPITable_ExpandRow_Scodes[];
extern SCODE IMAPITable_CollapseRow_Scodes[];
extern SCODE IMAPITable_WaitForCompletion_Scodes[];
extern SCODE IMAPITable_GetCollapseState_Scodes[];
extern SCODE IMAPITable_SetCollapseState_Scodes[];

extern SCODE IMAPISession_LogOff_Scodes[];
extern SCODE IMAPISession_Release_Scodes[];
extern SCODE IMAPISession_GetLastError_Scodes[];
extern SCODE IMAPISession_GetMsgStoresTable_Scodes[];
extern SCODE IMAPISession_GetStatusTable_Scodes[];
extern SCODE IMAPISession_OpenMsgStore_Scodes[];
extern SCODE IMAPISession_OpenAddressBook_Scodes[];
extern SCODE IMAPISession_OpenEntry_Scodes[];
extern SCODE IMAPISession_OpenProfileSection_Scodes[];
extern SCODE IMAPISession_Advise_Scodes[];
extern SCODE IMAPISession_Unadvise_Scodes[];
extern SCODE IMAPISession_CompareEntryIDs_Scodes[];
extern SCODE IMAPISession_MessageOptions_Scodes[];
extern SCODE IMAPISession_QueryDefaultMessageOpt_Scodes[];
extern SCODE IMAPISession_EnumAdrTypes_Scodes[];
extern SCODE IMAPISession_QueryIdentity_Scodes[];
extern SCODE IMAPISession_OpenProfileSection_Scodes[];
extern SCODE IMAPISession_GetStatusTable_Scodes[];

extern SCODE IMsgStore_Advise_Scodes[] ;
extern SCODE IMsgStore_Unadvise_Scodes[] ;
extern SCODE IMsgStore_CompareEntryIDs_Scodes[] ;
extern SCODE IMsgStore_OpenEntry_Scodes[] ;
extern SCODE IMsgStore_SetReceiveFolder_Scodes[];
extern SCODE IMsgStore_GetReceiveFolder_Scodes[];
extern SCODE IMsgStore_GetReceiveFolderTable_Scodes[];
extern SCODE IMsgStore_StoreLogoff_Scodes[];
extern SCODE IMsgStore_AbortSubmit_Scodes[];
extern SCODE IMsgStore_GetOutgoingQueue_Scodes[] ;
extern SCODE IMsgStore_SetLockState_Scodes[] ;
extern SCODE IMsgStore_FinishedMsg_Scodes[] ;
extern SCODE IMsgStore_NotifyNewMail_Scodes[];

extern SCODE IMAPIFolder_GetContentsTable_Scodes[];
extern SCODE IMAPIFolder_GetHierarchyTable_Scodes[];
extern SCODE IMAPIFolder_SaveContentsSort_Scodes[];
extern SCODE IMAPIFolder_OpenEntry_Scodes[];
extern SCODE IMAPIFolder_CreateMessage_Scodes[];
extern SCODE IMAPIFolder_CopyMessages_Scodes[];
extern SCODE IMAPIFolder_DeleteMessages_Scodes[];
extern SCODE IMAPIFolder_CreateFolder_Scodes[];
extern SCODE IMAPIFolder_CopyFolder_Scodes[];
extern SCODE IMAPIFolder_DeleteFolder_Scodes[];
extern SCODE IMAPIFolder_SetSearchCriteria_Scodes[];
extern SCODE IMAPIFolder_GetSearchCriteria_Scodes[];
extern SCODE IMAPIFolder_SetReadFlags_Scodes[];
extern SCODE IMAPIFolder_GetMessageStatus_Scodes[];
extern SCODE IMAPIFolder_SetMessageStatus_Scodes[];
extern SCODE IMAPIFolder_EmptyFolder_Scodes[];

extern SCODE IMessage_SaveChanges_Scodes[];
extern SCODE IMessage_GetAttachmentTable_Scodes[];
extern SCODE IMessage_OpenAttach_Scodes[];
extern SCODE IMessage_CreateAttach_Scodes[];
extern SCODE IMessage_DeleteAttach_Scodes[];
extern SCODE IMessage_GetRecipientTable_Scodes[];
extern SCODE IMessage_ModifyRecipients_Scodes[];
extern SCODE IMessage_SubmitMessage_Scodes[];
extern SCODE IMessage_SetReadFlag_Scodes[];

extern SCODE IAttach_SaveChanges_Scodes[];

extern SCODE IAddrBook_OpenEntry_Scodes[];
extern SCODE IAddrBook_CompareEntryIDs_Scodes[];
extern SCODE IAddrBook_CreateOneOff_Scodes[];
extern SCODE IAddrBook_ResolveName_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_Details_Scodes[];
extern SCODE IAddrBook_RecipOptions_Scodes[];
extern SCODE IAddrBook_QueryDefaultRecipOpt_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_ButtonPress_Scodes[];

extern SCODE IABContainer_GetContentsTable_Scodes[];
extern SCODE IABContainer_GetHierarchyTable_Scodes[];

extern SCODE INotifObj_ChangeEvMask_Scodes[];

extern SCODE IMAPIStatus_ChangePassword_Scodes[];
extern SCODE IMAPIStatus_FlushQueues_Scodes[];
extern SCODE IMAPIStatus_SettingsDialog_Scodes[];
extern SCODE IMAPIStatus_ValidateState_Scodes[];

extern SCODE IMSProvider_Logon_Scodes[];
extern SCODE IMSProvider_Deinit_Scodes[];
extern SCODE IMSProvider_Init_Scodes[];
extern SCODE IMSProvider_SpoolerLogon_Scodes[];
extern SCODE IMSProvider_Shutdown_Scodes[];

extern SCODE SMAPI_MAPILogon_Scodes[];
extern SCODE SMAPI_MAPILogoff_Scodes[];
extern SCODE SMAPI_MAPIFreeBuffer_Scodes[];
extern SCODE SMAPI_MAPISendMail_Scodes[];
extern SCODE SMAPI_MAPISendDocuments_Scodes[];
extern SCODE SMAPI_MAPIFindNext_Scodes[];
extern SCODE SMAPI_MAPIReadMail_Scodes[];
extern SCODE SMAPI_MAPISaveMail_Scodes[];
extern SCODE SMAPI_MAPIDeleteMail_Scodes[];
extern SCODE SMAPI_MAPIAddress_Scodes[];
extern SCODE SMAPI_MAPIResolveName_Scodes[];
extern SCODE SMAPI_MAPIDetails_Scodes[];

extern SCODE IMSLogon_OpenEntry_Scodes[];
extern SCODE IMSLogon_OpenStatusEntry_Scodes[];
extern SCODE IMSLogon_CompareEntryIDs_Scodes[];
extern SCODE IMSLogon_Advise_Scodes[];
extern SCODE IMSLogon_Unadvise_Scodes[];
extern SCODE IMSLogon_Logoff_Scodes[];
#endif

/* ------------------------------------------------------------------------ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\inetprop.h ===
#ifndef _INETPROP_H
#define _INETPROP_H

//---[ INETPROP.H ]--------------------------------------------------------
//
//  Definitions used by the the Inet transports, address books
//  and other Inet providers for service entry calls.
//
//  $$REVIEW This was stolen from Blade's MSFS.H (stolen from somewhere else)
//
//  The following INET-defined properties are settable in service entry
//  calls.  They are grouped by function. I've tried to maintain as much compatibility
//  with the Blade proptags, just to keep things easy.
//
//-------------------------------------------------------------------------

// $$REVIEW: What is this RAS_MaxEntryName doing in here?

#ifdef WIN32
#include <ras.h>
#else
#define RAS_MaxEntryName    20
#endif

#define MAIL_PROP_COUNT     42   // Not including the sess one.
#define NEWS_PROP_COUNT     19   // Not including the sess one.

//---[ Generic Connection Properties ]-------------------------------------
#define PR_CFG_SERVER_PATH              PROP_TAG (PT_TSTRING,   0x6600)
#define PR_CFG_CONN_TYPE                PROP_TAG (PT_LONG,      0x6601)
#define PR_CFG_SESSION_LOG              PROP_TAG (PT_LONG, 		0x6602)
#define PR_CFG_SESSION_LOG_FILE         PROP_TAG (PT_TSTRING,   0x6603)
#define PR_CFG_SESSION_LOG_FILTER_INDEX	PROP_TAG (PT_LONG,		0x6604)

//---[ IMail Connection Properties ]---------------------------------------
#define PR_CFG_EMAIL_ADDRESS            PROP_TAG (PT_TSTRING,   0x6605)
#define PR_CFG_EMAIL_ACCOUNT            PROP_TAG (PT_TSTRING,   0x6606)
#define PR_CFG_EMAIL_DISPLAY_NAME       PROP_TAG (PT_TSTRING,   0x6607)
//#define PR_CFG_PASSWORD                 PROP_TAG (PT_TSTRING,   0x6608)
#define PR_CFG_PASSWORD                 PROP_TAG (PT_TSTRING,   PROP_ID_SECURE_MIN)
#define PR_CFG_REMEMBER                 PROP_TAG (PT_BOOLEAN,   0x6610)
#define PR_CFG_OUTBOUND_MAIL_HOST       PROP_TAG (PT_TSTRING,   0x6611)

//---[ INews Connection Properties ]---------------------------------------
#define PR_CFG_NEWS_EMAIL_ADDRESS		PROP_TAG (PT_TSTRING,	0x6600)
#define PR_CFG_NEWS_DISPLAY_NAME		PROP_TAG (PT_TSTRING,	0x6601)
#define PR_CFG_NEWS_SERVER_NAME			PROP_TAG (PT_TSTRING,	0x6610)
#define PR_CFG_CONNECTION_TYPE			PROP_TAG (PT_LONG,		0x6603)
#define PR_CFG_CONNECTION_PROFILE		PROP_TAG (PT_TSTRING,	0x6604)

//---[ Advanced Properties ]-----------------------------------------------
 
#define PR_CFG_BODY_FORMAT              PROP_TAG (PT_LONG,      0x6620)
#define PR_CFG_TEXT_CHAR_SET            PROP_TAG (PT_TSTRING,   0x6621)
#define PR_CFG_MIME_CHAR_SET            PROP_TAG (PT_TSTRING,   0x6622)
#define PR_CFG_ENCODING_MINIMUM         PROP_TAG (PT_LONG,      0x6623)
#define PR_CFG_ENCODE_LINES             PROP_TAG (PT_BOOLEAN,   0x6624)
 
//---[ Remote Config Properties ]------------------------------------------

#define PR_CFG_SESSION_START_TYPE       PROP_TAG (PT_LONG,      0x6630)
#define PR_CFG_RNA_PROFILE              PROP_TAG (PT_TSTRING,   0x6631)
#define PR_CFG_RNA_PROFILE_ALWAYS       PROP_TAG (PT_BOOLEAN,   0x6632)
#define PR_CFG_RNA_CONFIRM              PROP_TAG (PT_LONG,      0x6633)
#define PR_CFG_REMOTE_CONNECT_TIMEOUT	PROP_TAG (PT_LONG,		0x6634)
#define PR_CFG_REMOTE_USERNAME			PROP_TAG (PT_TSTRING,	0x6635)
//#define PR_CFG_REMOTE_PASSWORD			PROP_TAG (PT_TSTRING,	0x6636)
#define PR_CFG_REMOTE_PASSWORD		PROP_TAG (PT_TSTRING,	PROP_ID_SECURE_MIN+1)

#define PR_CFG_NEWS_REMOTE_USERNAME		PROP_TAG (PT_TSTRING,	0x6620)
#define PR_CFG_NEWS_REMOTE_PASSWORD		PROP_TAG (PT_TSTRING, 	0x6621)   

//---[ Generic Delivery Options ]------------------------------------------

#define PR_CFG_DELIVERY_OPTIONS         PROP_TAG (PT_LONG,      0x6640)
#define PR_CFG_MSG_CHECK_WAIT           PROP_TAG (PT_LONG,      0x6641)

//---[ News Delivery Options ]---------------------------------------------

#define PR_CFG_NEW_GROUP_NOTIFY         PROP_TAG (PT_BOOLEAN,   0x6642)
#define PR_CFG_DEAD_GROUP_NOTIFY        PROP_TAG (PT_BOOLEAN,   0x6643)
#define PR_CFG_NEW_MESSAGE_NOTIFY       PROP_TAG (PT_BOOLEAN,   0x6644)
 
//---[ Other data ]--------------------------------------------------------

#define PR_CFG_SMTP_PORT                PROP_TAG (PT_LONG,   	0x6650)
#define PR_CFG_POP3_PORT                PROP_TAG (PT_LONG,   	0x6651)

#define PR_CFG_SMTP_TIMEOUT_CONNECT     PROP_TAG (PT_LONG,   	0x6660)
#define PR_CFG_SMTP_TIMEOUT_HELO        PROP_TAG (PT_LONG,   	0x6661)
#define PR_CFG_SMTP_TIMEOUT_MAILFROM    PROP_TAG (PT_LONG,   	0x6662)
#define PR_CFG_SMTP_TIMEOUT_RCPT        PROP_TAG (PT_LONG,   	0x6663)
#define PR_CFG_SMTP_TIMEOUT_DATAINIT    PROP_TAG (PT_LONG,   	0x6664)
#define PR_CFG_SMTP_TIMEOUT_DATABLOK    PROP_TAG (PT_LONG,   	0x6665)
#define PR_CFG_SMTP_TIMEOUT_RSET        PROP_TAG (PT_LONG,   	0x6666)
#define PR_CFG_SMTP_TIMEOUT_QUIT        PROP_TAG (PT_LONG,   	0x6667)
#define PR_CFG_SMTP_TIMEOUT_CLOSE       PROP_TAG (PT_LONG,   	0x6668)
#define PR_CFG_POP3_TIMEOUT_CONNECT     PROP_TAG (PT_LONG,   	0x6669)
#define PR_CFG_POP3_TIMEOUT_SEND        PROP_TAG (PT_LONG,   	0x6670)
#define PR_CFG_POP3_TIMEOUT_RECEIVE     PROP_TAG (PT_LONG,   	0x6671)
#define PR_CFG_SMTP_TIMEOUT_DATAACPT    PROP_TAG (PT_LONG,   	0x6672)

//---[ Remote Header Cache Props ]-----------------------------------------

#define PR_CFG_REMOTE_CACHE_TIMEOUT		PROP_TAG (PT_LONG,		0x6673)
#define PR_CFG_REMOTE_CACHE_NAME		PROP_TAG (PT_TSTRING,	0x6674)

//---[ INews PST Properties ]----------------------------------------------
#define PR_CFG_PST_PATH                 PROP_TAG (PT_TSTRING,   0x6680)

//---[ IMail Message Class String ]----------------------------------------

// The strings themselves are defined in mapiopt.h

extern CHAR lpstrMsgClassRFC822[];
extern CHAR lpstrMsgClassRFCMIME[];

#endif // _INETPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mapicode.h ===
/*
 *  M A P I C O D E . H
 *
 *  Status Codes returned by MAPI routines
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPICODE_H
#define MAPICODE_H

/* Define S_OK and ITF_* */

#ifdef WIN32
#include <objerror.h>
#endif

/*
 *  MAPI Status codes follow the style of OLE 2.0 sCodes as defined in the
 *  OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *  or objerror.h (Windows NT 3.5 and Windows 4.0).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *          0x0 - FACILITY_NULL     generally useful errors ([SE]_*)
 *          0x1 - FACILITY_RPC      remote procedure call errors (RPC_E_*)
 *          0x2 - FACILITY_DISPATCH late binding dispatch errors
 *          0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *          0x4 - FACILITY_ITF      interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *  On Windows NT 3.5 and Windows 4.0, scodes are 32-bit values
 *  laid out as follows:
 *  
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *  
 *   where
 *  
 *      S - Severity - indicates success/fail
 *  
 *          0 - Success
 *          1 - Fail (COERROR)
 *  
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *  
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *  
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *  
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *  
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *  
 *      Code - is the facility's status code
 *  
 */




/*
 *  We can't use OLE 2.0 macros to build sCodes because the definition has
 *  changed and we wish to conform to the new definition.
 */
#define MAKE_MAPI_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_MAPI_E( err )  (MAKE_MAPI_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_MAPI_S( warn ) (MAKE_MAPI_SCODE( 0, FACILITY_ITF, warn ))

#ifdef  SUCCESS_SUCCESS
#undef  SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS     0L

/* General errors (used by more than one MAPI object) */

#define MAPI_E_CALL_FAILED                              E_FAIL
#define MAPI_E_NOT_ENOUGH_MEMORY                        E_OUTOFMEMORY
#define MAPI_E_INVALID_PARAMETER                        E_INVALIDARG
#define MAPI_E_INTERFACE_NOT_SUPPORTED                  E_NOINTERFACE
#define MAPI_E_NO_ACCESS                                E_ACCESSDENIED

#define MAPI_E_NO_SUPPORT                               MAKE_MAPI_E( 0x102 )
#define MAPI_E_BAD_CHARWIDTH                            MAKE_MAPI_E( 0x103 )
#define MAPI_E_STRING_TOO_LONG                          MAKE_MAPI_E( 0x105 )
#define MAPI_E_UNKNOWN_FLAGS                            MAKE_MAPI_E( 0x106 )
#define MAPI_E_INVALID_ENTRYID                          MAKE_MAPI_E( 0x107 )
#define MAPI_E_INVALID_OBJECT                           MAKE_MAPI_E( 0x108 )
#define MAPI_E_OBJECT_CHANGED                           MAKE_MAPI_E( 0x109 )
#define MAPI_E_OBJECT_DELETED                           MAKE_MAPI_E( 0x10A )
#define MAPI_E_BUSY                                     MAKE_MAPI_E( 0x10B )
#define MAPI_E_NOT_ENOUGH_DISK                          MAKE_MAPI_E( 0x10D )
#define MAPI_E_NOT_ENOUGH_RESOURCES                     MAKE_MAPI_E( 0x10E )
#define MAPI_E_NOT_FOUND                                MAKE_MAPI_E( 0x10F )
#define MAPI_E_VERSION                                  MAKE_MAPI_E( 0x110 )
#define MAPI_E_LOGON_FAILED                             MAKE_MAPI_E( 0x111 )
#define MAPI_E_SESSION_LIMIT                            MAKE_MAPI_E( 0x112 )
#define MAPI_E_USER_CANCEL                              MAKE_MAPI_E( 0x113 )
#define MAPI_E_UNABLE_TO_ABORT                          MAKE_MAPI_E( 0x114 )
#define MAPI_E_NETWORK_ERROR                            MAKE_MAPI_E( 0x115 )
#define MAPI_E_DISK_ERROR                               MAKE_MAPI_E( 0x116 )
#define MAPI_E_TOO_COMPLEX                              MAKE_MAPI_E( 0x117 )
#define MAPI_E_BAD_COLUMN                               MAKE_MAPI_E( 0x118 )
#define MAPI_E_EXTENDED_ERROR                           MAKE_MAPI_E( 0x119 )
#define MAPI_E_COMPUTED                                 MAKE_MAPI_E( 0x11A )
#define MAPI_E_CORRUPT_DATA                             MAKE_MAPI_E( 0x11B )
#define MAPI_E_UNCONFIGURED                             MAKE_MAPI_E( 0x11C )
#define MAPI_E_FAILONEPROVIDER                          MAKE_MAPI_E( 0x11D )

/* MAPI base function and status object specific errors and warnings */

#define MAPI_E_END_OF_SESSION                           MAKE_MAPI_E( 0x200 )
#define MAPI_E_UNKNOWN_ENTRYID                          MAKE_MAPI_E( 0x201 )
#define MAPI_E_MISSING_REQUIRED_COLUMN                  MAKE_MAPI_E( 0x202 )
#define MAPI_W_NO_SERVICE                               MAKE_MAPI_S( 0x203 )

/* Property specific errors and warnings */

#define MAPI_E_BAD_VALUE                                MAKE_MAPI_E( 0x301 )
#define MAPI_E_INVALID_TYPE                             MAKE_MAPI_E( 0x302 )
#define MAPI_E_TYPE_NO_SUPPORT                          MAKE_MAPI_E( 0x303 )
#define MAPI_E_UNEXPECTED_TYPE                          MAKE_MAPI_E( 0x304 )
#define MAPI_E_TOO_BIG                                  MAKE_MAPI_E( 0x305 )
#define MAPI_E_DECLINE_COPY                             MAKE_MAPI_E( 0x306 )
#define MAPI_E_UNEXPECTED_ID                            MAKE_MAPI_E( 0x307 )

#define MAPI_W_ERRORS_RETURNED                          MAKE_MAPI_S( 0x380 )

/* Table specific errors and warnings */

#define MAPI_E_UNABLE_TO_COMPLETE                       MAKE_MAPI_E( 0x400 )
#define MAPI_E_TIMEOUT                                  MAKE_MAPI_E( 0x401 )
#define MAPI_E_TABLE_EMPTY                              MAKE_MAPI_E( 0x402 )
#define MAPI_E_TABLE_TOO_BIG                            MAKE_MAPI_E( 0x403 )

#define MAPI_E_INVALID_BOOKMARK                         MAKE_MAPI_E( 0x405 )

#define MAPI_W_POSITION_CHANGED                         MAKE_MAPI_S( 0x481 )
#define MAPI_W_APPROX_COUNT                             MAKE_MAPI_S( 0x482 )

/* Transport specific errors and warnings */

#define MAPI_E_WAIT                                     MAKE_MAPI_E( 0x500 )
#define MAPI_E_CANCEL                                   MAKE_MAPI_E( 0x501 )
#define MAPI_E_NOT_ME                                   MAKE_MAPI_E( 0x502 )

#define MAPI_W_CANCEL_MESSAGE                           MAKE_MAPI_S( 0x580 )

/* Message Store, Folder, and Message specific errors and warnings */

#define MAPI_E_CORRUPT_STORE                            MAKE_MAPI_E( 0x600 )
#define MAPI_E_NOT_IN_QUEUE                             MAKE_MAPI_E( 0x601 )
#define MAPI_E_NO_SUPPRESS                              MAKE_MAPI_E( 0x602 )
#define MAPI_E_COLLISION                                MAKE_MAPI_E( 0x604 )
#define MAPI_E_NOT_INITIALIZED                          MAKE_MAPI_E( 0x605 )
#define MAPI_E_NON_STANDARD                             MAKE_MAPI_E( 0x606 )
#define MAPI_E_NO_RECIPIENTS                            MAKE_MAPI_E( 0x607 )
#define MAPI_E_SUBMITTED                                MAKE_MAPI_E( 0x608 )
#define MAPI_E_HAS_FOLDERS                              MAKE_MAPI_E( 0x609 )
#define MAPI_E_HAS_MESSAGES                             MAKE_MAPI_E( 0x60A )
#define MAPI_E_FOLDER_CYCLE                             MAKE_MAPI_E( 0x60B )

#define MAPI_W_PARTIAL_COMPLETION                       MAKE_MAPI_S( 0x680 )

/* Address Book specific errors and warnings */

#define MAPI_E_AMBIGUOUS_RECIP                          MAKE_MAPI_E( 0x700 )

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#define MakeResult(_s)  ResultFromScode(_s)
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef HR_SUCCEEDED
#define HR_SUCCEEDED(_hr) SUCCEEDED((SCODE)(_hr))
#define HR_FAILED(_hr) FAILED((SCODE)(_hr))
#endif

#endif  /* MAPICODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mapidefs.h ===
/*
 *  M A P I D E F S . H
 *
 *  Definitions used by MAPI clients and service providers.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIDEFS_H
#define MAPIDEFS_H

#ifdef WIN32    /* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Daytona; Chicago needs it */
#define _INC_OLE /* Chicago will include OLE1 without this */
#include <windows.h>
#endif
#ifndef _OLEERROR_H_
#include <objerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16) || defined (MAC)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM    1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (WIN32)
#define STDMAPIINITCALLTYPE     __cdecl
#else
#define STDMAPIINITCALLTYPE     STDMETHODCALLTYPE
#endif
#define STDINITMETHODIMP        HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type) type STDMAPIINITCALLTYPE
#endif

#ifdef  __cplusplus
extern "C" {
#endif

/* Simple data types */

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short      WCHAR;
#else
typedef wchar_t WCHAR;
#endif

#ifdef UNICODE
typedef WCHAR               TCHAR;
#else
typedef char                TCHAR;
#endif

typedef WCHAR FAR *         LPWSTR;
typedef const WCHAR FAR *   LPCWSTR;
typedef TCHAR FAR *         LPTSTR;
typedef const TCHAR FAR *   LPCTSTR;
typedef BYTE FAR *          LPBYTE;
typedef ULONG FAR *         LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef unsigned long   LHANDLE, FAR * LPLHANDLE;
#endif

#if defined(WIN32) && !defined(_WINNT_)
typedef struct {
    DWORD   LowPart;
    LONG    HighPart;
} LARGE_INTEGER;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *  This flag is used in many different MAPI calls to signify that
 *  the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY             ((ULONG) 0x00000001)

/*
 *  The following flags are used to indicate to the client what access
 *  level is permissible in the object. They appear in PR_ACCESS in
 *  message and folder objects as well as in contents and associated
 *  contents tables
 */

#define MAPI_ACCESS_MODIFY                  ((ULONG) 0x00000001)
#define MAPI_ACCESS_READ                    ((ULONG) 0x00000002)
#define MAPI_ACCESS_DELETE                  ((ULONG) 0x00000004)
#define MAPI_ACCESS_CREATE_HIERARCHY        ((ULONG) 0x00000008)
#define MAPI_ACCESS_CREATE_CONTENTS         ((ULONG) 0x00000010)
#define MAPI_ACCESS_CREATE_ASSOCIATED       ((ULONG) 0x00000020)

/*
 *  The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *  that strings passed through the interface are in Unicode (a 16-bit
 *  character set). The default is an 8-bit character set.
 *
 *  The value fMapiUnicode can be used as the 'normal' value for
 *  that bit, given the application's default character set.
 */

#define MAPI_UNICODE            ((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode            MAPI_UNICODE
#else
#define fMapiUnicode            0
#endif

/* successful HRESULT */
#define hrSuccess               0



/* Recipient types */
#ifndef MAPI_ORIG               /* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1     0x10000000  /* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4        recipient is a CMC authorizing user      */
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM          0x80
#define MAPI_NOTRECIP           0x40
#define MAPI_THISSESSION        0x20
#define MAPI_NOW                0x10
#define MAPI_NOTRESERVED        0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND           0x80

/* ENTRYID */
typedef struct
{
    BYTE    abFlags[4];
    BYTE    ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)       (offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)          (offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
    struct _ENTRYID_ ## _name \
{ \
    BYTE    abFlags[4]; \
    BYTE    ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
    BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)  (!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))


/* Object type */

#define MAPI_STORE      ((ULONG) 0x00000001)    /* Message Store */
#define MAPI_ADDRBOOK   ((ULONG) 0x00000002)    /* Address Book */
#define MAPI_FOLDER     ((ULONG) 0x00000003)    /* Folder */
#define MAPI_ABCONT     ((ULONG) 0x00000004)    /* Address Book Container */
#define MAPI_MESSAGE    ((ULONG) 0x00000005)    /* Message */
#define MAPI_MAILUSER   ((ULONG) 0x00000006)    /* Individual Recipient */
#define MAPI_ATTACH     ((ULONG) 0x00000007)    /* Attachment */
#define MAPI_DISTLIST   ((ULONG) 0x00000008)    /* Distribution List Recipient */
#define MAPI_PROFSECT   ((ULONG) 0x00000009)    /* Profile Section */
#define MAPI_STATUS     ((ULONG) 0x0000000A)    /* Status Object */
#define MAPI_SESSION    ((ULONG) 0x0000000B)    /* Session */
#define MAPI_FORMINFO   ((ULONG) 0x0000000C)    /* Form Information */

/* Property Types */

#define MV_FLAG         0x1000          /* Multi-value flag */

#define PT_UNSPECIFIED  ((ULONG)  0)    /* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL         ((ULONG)  1)    /* NULL property value */
#define PT_I2           ((ULONG)  2)    /* Signed 16-bit value */
#define PT_LONG         ((ULONG)  3)    /* Signed 32-bit value */
#define PT_R4           ((ULONG)  4)    /* 4-byte floating point */
#define PT_DOUBLE       ((ULONG)  5)    /* Floating point double */
#define PT_CURRENCY     ((ULONG)  6)    /* Signed 64-bit int (decimal w/    4 digits right of decimal pt) */
#define PT_APPTIME      ((ULONG)  7)    /* Application time */
#define PT_ERROR        ((ULONG) 10)    /* 32-bit error value */
#define PT_BOOLEAN      ((ULONG) 11)    /* 16-bit boolean (non-zero true) */
#define PT_OBJECT       ((ULONG) 13)    /* Embedded object in a property */
#define PT_I8           ((ULONG) 20)    /* 8-byte signed integer */
#define PT_STRING8      ((ULONG) 30)    /* Null terminated 8-bit character string */
#define PT_UNICODE      ((ULONG) 31)    /* Null terminated Unicode string */
#define PT_SYSTIME      ((ULONG) 64)    /* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define PT_CLSID        ((ULONG) 72)    /* OLE GUID */
#define PT_BINARY       ((ULONG) 258)   /* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define PT_SHORT    PT_I2
#define PT_I4       PT_LONG
#define PT_FLOAT    PT_R4
#define PT_R8       PT_DOUBLE
#define PT_LONGLONG PT_I8

/*
 *  The type of a MAPI-defined string property is indirected, so
 *  that it defaults to Unicode string on a Unicode platform and to
 *  String8 on an ANSI or DBCS platform.
 *
 *  Macros are defined here both for the property type, and for the
 *  field of the property value structure which should be
 *  dereferenced to obtain the string pointer.
 */

#ifdef  UNICODE
#define PT_TSTRING          PT_UNICODE
#define PT_MV_TSTRING       (MV_FLAG|PT_UNICODE)
#define LPSZ                lpszW
#define LPPSZ               lppszW
#define MVSZ                MVszW
#else
#define PT_TSTRING          PT_STRING8
#define PT_MV_TSTRING       (MV_FLAG|PT_STRING8)
#define LPSZ                lpszA
#define LPPSZ               lppszA
#define MVSZ                MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK          ((ULONG)0x0000FFFF) /* Mask for Property type */
#define PROP_TYPE(ulPropTag)    (((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)      (((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)   ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL            0
#define PROP_ID_INVALID         0xFFFF
#define PR_NULL                 PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType) \
                        (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define PT_MV_I2        (MV_FLAG|PT_I2)
#define PT_MV_LONG      (MV_FLAG|PT_LONG)
#define PT_MV_R4        (MV_FLAG|PT_R4)
#define PT_MV_DOUBLE    (MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY  (MV_FLAG|PT_CURRENCY)
#define PT_MV_APPTIME   (MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME   (MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8   (MV_FLAG|PT_STRING8)
#define PT_MV_BINARY    (MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE   (MV_FLAG|PT_UNICODE)
#define PT_MV_CLSID     (MV_FLAG|PT_CLSID)
#define PT_MV_I8        (MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define PT_MV_SHORT     PT_MV_I2
#define PT_MV_I4        PT_MV_LONG
#define PT_MV_FLOAT     PT_MV_R4
#define PT_MV_R8        PT_MV_DOUBLE
#define PT_MV_LONGLONG  PT_MV_I8

/*
 *  Property type reserved bits
 *
 *  MV_INSTANCE is used as a flag in table operations to request
 *  that a multi-valued property be presented as a single-valued
 *  property appearing in multiple rows.
 */

#define MV_INSTANCE     0x2000
#define MVI_FLAG        (MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)   ((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
    ULONG   cValues;
    ULONG   aulPropTag[MAPI_DIM];
} SPropTagArray, FAR * LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
    (offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
    (offsetof(SPropTagArray,aulPropTag) + \
    (UINT)((_lparray)->cValues)*sizeof(ULONG))
/*  SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue  SPropValue;

#if !defined(VB_VERSION) && !defined(_OLEAUTO_H_)
/* Don't redefine CURRENCY if Visual Basic or
OLE automation headers are included already */
typedef struct
{
    LONG Lo;
    LONG Hi;
} CURRENCY;
#endif

typedef struct _SBinary
{
    ULONG       cb;
    LPBYTE      lpb;
} SBinary, FAR *LPSBinary;

typedef struct _SShortArray
{
    ULONG       cValues;
    short int   FAR *lpi;
} SShortArray;

typedef struct _SGuidArray
{
    ULONG       cValues;
    GUID        FAR *lpguid;
} SGuidArray;

typedef struct _SRealArray
{
    ULONG       cValues;
    float       FAR *lpflt;
} SRealArray;

typedef struct _SLongArray
{
    ULONG       cValues;
    LONG        FAR *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
    ULONG       cValues;
    LARGE_INTEGER   FAR *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
    ULONG       cValues;
    FILETIME    FAR *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
    ULONG       cValues;
    double      FAR *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
    ULONG       cValues;
    CURRENCY    FAR *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
    ULONG       cValues;
    SBinary     FAR *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
    ULONG       cValues;
    double      FAR *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
    ULONG       cValues;
    LPWSTR      FAR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
    ULONG       cValues;
    LPSTR       FAR *lppszA;
} SLPSTRArray;

typedef union _PV
{
    short int           i;          /* case PT_I2 */
    LONG                l;          /* case PT_LONG */
    ULONG               ul;         /* alias for PT_LONG */
    float               flt;        /* case PT_R4 */
    double              dbl;        /* case PT_DOUBLE */
    unsigned short int  b;          /* case PT_BOOLEAN */
    CURRENCY            cur;        /* case PT_CURRENCY */
    double              at;         /* case PT_APPTIME */
    FILETIME            ft;         /* case PT_SYSTIME */
    LPSTR               lpszA;      /* case PT_STRING8 */
    SBinary             bin;        /* case PT_BINARY */
    LPWSTR              lpszW;      /* case PT_UNICODE */
    LPGUID              lpguid;     /* case PT_CLSID */
    LARGE_INTEGER       li;         /* case PT_I8 */
    SShortArray         MVi;        /* case PT_MV_I2 */
    SLongArray          MVl;        /* case PT_MV_LONG */
    SRealArray          MVflt;      /* case PT_MV_R4 */
    SDoubleArray        MVdbl;      /* case PT_MV_DOUBLE */
    SCurrencyArray      MVcur;      /* case PT_MV_CURRENCY */
    SAppTimeArray       MVat;       /* case PT_MV_APPTIME */
    SDateTimeArray      MVft;       /* case PT_MV_SYSTIME */
    SBinaryArray        MVbin;      /* case PT_MV_BINARY */
    SLPSTRArray         MVszA;      /* case PT_MV_STRING8 */
    SWStringArray       MVszW;      /* case PT_MV_UNICODE */
    SGuidArray          MVguid;     /* case PT_MV_CLSID */
    SLargeIntegerArray  MVli;       /* case PT_MV_I8 */
    SCODE               err;        /* case PT_ERROR */
    LONG                x;          /* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
    ULONG       ulPropTag;
    ULONG       dwAlignPad;
    union _PV   Value;
} SPropValue, FAR * LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
    ULONG   ulIndex;
    ULONG   ulPropTag;
    SCODE   scode;
} SPropProblem, FAR * LPSPropProblem;

typedef struct _SPropProblemArray
{
    ULONG           cProblem;
    SPropProblem    aProblem[MAPI_DIM];
} SPropProblemArray, FAR * LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
    (offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
    (offsetof(SPropProblemArray,aProblem) + \
    (UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
    ULONG           cProblem; \
    SPropProblem    aProblem[_cprob]; \
} _name

/*
 *  ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *  FLATENTRYLIST
 *  MTSID
 *  FLATMTSIDLIST
 */

typedef struct {
    ULONG cb;
    BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
    ULONG       cEntries;
    ULONG       cbEntries;
    BYTE        abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
    ULONG       cb;
    BYTE        ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
    ULONG       cMTSIDs;
    ULONG       cbMTSIDs;
    BYTE        abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)     (offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)   (offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb) (offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)         (offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)       (offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
    ULONG           ulReserved1;    /* Never used */
    ULONG           cValues;
    LPSPropValue    rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
    ULONG           cEntries;
    ADRENTRY        aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
    (offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
    (offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
    ULONG           cEntries; \
    ADRENTRY        aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
    ULONG           ulAdrEntryPad;  /* Pad so SRow's can map to ADRENTRY's */
    ULONG           cValues;        /* Count of property values */
    LPSPropValue    lpProps;        /* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
    ULONG           cRows;          /* Count of rows */
    SRow            aRow[MAPI_DIM]; /* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define CbNewSRowSet(_crow)     (offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)    (offsetof(SRowSet,aRow) + \
                                    (UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
    ULONG           cRows; \
    SRow            aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
    ULONG           cbSize,
    LPVOID FAR *    lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
    ULONG           cbSize,
    LPVOID          lpObject,
    LPVOID FAR *    lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
    LPVOID          lpBuffer
);

typedef ALLOCATEBUFFER FAR *LPALLOCATEBUFFER;
typedef ALLOCATEMORE FAR *  LPALLOCATEMORE;
typedef FREEBUFFER FAR *    LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface;            \
        struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)              MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
        STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
        typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)                                    \
    MAPIMETHOD(QueryInterface)                                          \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;                 \
    MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;                            \
    MAPIMETHOD_(ULONG,Release) (THIS) IPURE;                            \

#undef  IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,       LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,     LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,        LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,         LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,       LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,    LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,       LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,       LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,     LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,      LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,       LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,       LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,  LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,   LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,  LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
    ULONG   ulVersion;
    LPTSTR  lpszError;
    LPTSTR  lpszComponent;
    ULONG   ulLowLevelError;
    ULONG   ulContext;

} MAPIERROR, FAR * LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *  Notification event types. The event types can be combined in a bitmask
 *  for filtering. Each one has a parameter structure associated with it:
 *
 *      fnevCriticalError       ERROR_NOTIFICATION
 *      fnevNewMail             NEWMAIL_NOTIFICATION
 *      fnevObjectCreated       OBJECT_NOTIFICATION
 *      fnevObjectDeleted       OBJECT_NOTIFICATION
 *      fnevObjectModified      OBJECT_NOTIFICATION
 *      fnevObjectCopied        OBJECT_NOTIFICATION
 *      fnevSearchComplete      OBJECT_NOTIFICATION
 *      fnevTableModified       TABLE_NOTIFICATION
 *      fnevStatusObjectModified ?
 *
 *      fnevExtended            EXTENDED_NOTIFICATION
 */

#define fnevCriticalError           ((ULONG) 0x00000001)
#define fnevNewMail                 ((ULONG) 0x00000002)
#define fnevObjectCreated           ((ULONG) 0x00000004)
#define fnevObjectDeleted           ((ULONG) 0x00000008)
#define fnevObjectModified          ((ULONG) 0x00000010)
#define fnevObjectMoved             ((ULONG) 0x00000020)
#define fnevObjectCopied            ((ULONG) 0x00000040)
#define fnevSearchComplete          ((ULONG) 0x00000080)
#define fnevTableModified           ((ULONG) 0x00000100)
#define fnevStatusObjectModified    ((ULONG) 0x00000200)
#define fnevReservedForMapi         ((ULONG) 0x40000000)
#define fnevExtended                ((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED       1
#define TABLE_ERROR         2
#define TABLE_ROW_ADDED     3
#define TABLE_ROW_DELETED   4
#define TABLE_ROW_MODIFIED  5
#define TABLE_SORT_DONE     6
#define TABLE_RESTRICT_DONE 7
#define TABLE_SETCOL_DONE   8
#define TABLE_RELOAD        9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;
    SCODE       scode;
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPMAPIERROR lpMAPIError;        /* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;          /* identifies the new message */
    ULONG       cbParentID;
    LPENTRYID   lpParentID;         /* identifies the folder it lives in */
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPTSTR      lpszMessageClass;   /* message class (UNICODE or string8) */
    ULONG       ulMessageFlags;     /* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
    ULONG               cbEntryID;
    LPENTRYID           lpEntryID;      /* EntryID of object */
    ULONG               ulObjType;      /* Type of object */
    ULONG               cbParentID;
    LPENTRYID           lpParentID;     /* EntryID of parent object */
    ULONG               cbOldID;
    LPENTRYID           lpOldID;        /* EntryID of old object */
    ULONG               cbOldParentID;
    LPENTRYID           lpOldParentID;  /* EntryID of old parent */
    LPSPropTagArray     lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
    ULONG               ulTableEvent;   /* Identifies WHICH table event */
    HRESULT             hResult;        /* Value for TABLE_ERROR */
    SPropValue          propIndex;      /* This row's "index property" */
    SPropValue          propPrior;      /* Preceding row's "index property" */
    SRow                row;            /* New data of added/modified row */
    ULONG               ulPad;          /* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
    ULONG       ulEvent;                    /* extended event code */
    ULONG       cb;                         /* size of event parameters */
    LPBYTE      pbEventParameters;          /* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
    ULONG           cbEntryID;
    LPENTRYID       lpEntryID;
    ULONG           cValues;
    LPSPropValue    lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
    ULONG   ulEventType;        /* notification type, i.e. fnevSomething */
    ULONG   ulAlignPad;         /* Force to 8-byte boundary */
    union
    {
        ERROR_NOTIFICATION          err;
        NEWMAIL_NOTIFICATION        newmail;
        OBJECT_NOTIFICATION         obj;
        TABLE_NOTIFICATION          tab;
        EXTENDED_NOTIFICATION       ext;
        STATUS_OBJECT_NOTIFICATION  statobj;
    } info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)                             \
    MAPIMETHOD_(ULONG, OnNotify)                                        \
        (THIS_  ULONG                       cNotif,                     \
                LPNOTIFICATION              lpNotifications) IPURE;     \

#undef       INTERFACE
#define      INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
    LPVOID          lpvContext,
    ULONG           cNotification,
    LPNOTIFICATION  lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *  Message name for the 16-bit MAPI notififcation engine.
 *  This can be used in 16-bit applications to force processing
 *  of notification callbacks.
 */

#ifdef  WIN16
#define szMAPINotificationMsg "MAPI Notify window message"
#endif


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL      ((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)                               \
    MAPIMETHOD(Progress)                                                \
        (THIS_  ULONG                       ulValue,                    \
                ULONG                       ulCount,                    \
                ULONG                       ulTotal) IPURE;             \
    MAPIMETHOD(GetFlags)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(GetMax)                                                  \
        (THIS_  ULONG FAR *                 lpulMax) IPURE;             \
    MAPIMETHOD(GetMin)                                                  \
        (THIS_  ULONG FAR *                 lpulMin) IPURE;             \
    MAPIMETHOD(SetLimits)                                               \
        (THIS_  LPULONG                     lpulMin,                    \
                LPULONG                     lpulMax,                    \
                LPULONG                     lpulFlags) IPURE;           \

#undef      INTERFACE
#define     INTERFACE   IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION      0x00000000L

/* GetPropList */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY      ((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE     ((ULONG) 0x00000002)
#define FORCE_SAVE              ((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
#define MAPI_CREATE             ((ULONG) 0x00000002)
#define STREAM_APPEND           ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE               ((ULONG) 0x00000001)
#define MAPI_NOREPLACE          ((ULONG) 0x00000002)
#define MAPI_DECLINE_OK         ((ULONG) 0x00000004)

#ifndef MAPI_DIALOG             /* also defined in mapi.h */
#define MAPI_DIALOG             ((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT        /* also defined in mapi.h */
#define MAPI_USE_DEFAULT        0x00000040  /* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/****** MAPI_CREATE             ((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS         ((ULONG) 0x00000001)
#define MAPI_NO_IDS             ((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID                 0
#define MNID_STRING             1
typedef struct _MAPINAMEID
{
    LPGUID lpguid;
    ULONG ulKind;
    union {
        LONG lID;
        LPWSTR lpwstrName;
    } Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)                                   \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(SaveChanges)                                             \
        (THIS_ ULONG                        ulFlags) IPURE;             \
    MAPIMETHOD(GetProps)                                                \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppPropArray) IPURE;        \
    MAPIMETHOD(GetPropList)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTagArray) IPURE;     \
    MAPIMETHOD(OpenProperty)                                            \
        (THIS_  ULONG                       ulPropTag,                  \
                LPCIID                      lpiid,                      \
                ULONG                       ulInterfaceOptions,         \
                ULONG                       ulFlags,                    \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetProps)                                                \
        (THIS_  ULONG                       cValues,                    \
                LPSPropValue                lpPropArray,                \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DeleteProps)                                             \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyTo)                                                  \
        (THIS_  ULONG                       ciidExclude,                \
                LPCIID                      rgiidExclude,               \
                LPSPropTagArray             lpExcludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyProps)                                               \
        (THIS_  LPSPropTagArray             lpIncludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(GetNamesFromIDs)                                         \
        (THIS_  LPSPropTagArray FAR *       lppPropTags,                \
                LPGUID                      lpPropSetGuid,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcPropNames,               \
                LPMAPINAMEID FAR * FAR *    lpppPropNames) IPURE;       \
    MAPIMETHOD(GetIDsFromNames)                                         \
        (THIS_  ULONG                       cPropNames,                 \
                LPMAPINAMEID FAR *          lppPropNames,               \
                ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTags) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE            ((ULONG) 0)
#define TBLSTAT_QCHANGED            ((ULONG) 7)
#define TBLSTAT_SORTING             ((ULONG) 9)
#define TBLSTAT_SORT_ERROR          ((ULONG) 10)
#define TBLSTAT_SETTING_COLS        ((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR        ((ULONG) 13)
#define TBLSTAT_RESTRICTING         ((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR      ((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT            ((ULONG) 0)
#define TBLTYPE_KEYSET              ((ULONG) 1)
#define TBLTYPE_DYNAMIC             ((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND       ((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND      ((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE      ((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
    ULONG   ulPropTag;          /* Column to sort on */
    ULONG   ulOrder;            /* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
    ULONG           cSorts;     /* Number of sort columns in aSort below*/
    ULONG           cCategories;    /* 0 for non-categorized, up to cSorts */
    ULONG           cExpanded;      /* 0 if no categories start expanded, */
                                    /*      up to cExpanded */
    SSortOrder      aSort[MAPI_DIM];    /* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
    (offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
    (offsetof(SSortOrderSet,aSort) + \
    (UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
    ULONG           cSorts;         \
    ULONG           cCategories;    \
    ULONG           cExpanded;      \
    SSortOrder      aSort[_csort];  \
} _name

typedef ULONG       BOOKMARK;

#define BOOKMARK_BEGINNING  ((BOOKMARK) 0)      /* Before first row */
#define BOOKMARK_CURRENT    ((BOOKMARK) 1)      /* Before current row */
#define BOOKMARK_END        ((BOOKMARK) 2)      /* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING       ((ULONG) 0x00000000)
#define FL_SUBSTRING        ((ULONG) 0x00000001)
#define FL_PREFIX           ((ULONG) 0x00000002)

#define FL_IGNORECASE       ((ULONG) 0x00010000)
#define FL_IGNORENONSPACE   ((ULONG) 0x00020000)
#define FL_LOOSE            ((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction    FAR * LPSRestriction;

/* Restriction types */

#define RES_AND             ((ULONG) 0x00000000)
#define RES_OR              ((ULONG) 0x00000001)
#define RES_NOT             ((ULONG) 0x00000002)
#define RES_CONTENT         ((ULONG) 0x00000003)
#define RES_PROPERTY        ((ULONG) 0x00000004)
#define RES_COMPAREPROPS    ((ULONG) 0x00000005)
#define RES_BITMASK         ((ULONG) 0x00000006)
#define RES_SIZE            ((ULONG) 0x00000007)
#define RES_EXIST           ((ULONG) 0x00000008)
#define RES_SUBRESTRICTION  ((ULONG) 0x00000009)
#define RES_COMMENT         ((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT        ((ULONG) 0)     /* <  */
#define RELOP_LE        ((ULONG) 1)     /* <= */
#define RELOP_GT        ((ULONG) 2)     /* >  */
#define RELOP_GE        ((ULONG) 3)     /* >= */
#define RELOP_EQ        ((ULONG) 4)     /* == */
#define RELOP_NE        ((ULONG) 5)     /* != */
#define RELOP_RE        ((ULONG) 6)     /* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ     ((ULONG) 0)     /* ==0 */
#define BMR_NEZ     ((ULONG) 1)     /* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
    ULONG           ulReserved;
    LPSRestriction  lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
    ULONG           ulFuzzyLevel;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
    ULONG           relBMR;
    ULONG           ulPropTag;
    ULONG           ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
    ULONG           relop;
    ULONG           ulPropTag1;
    ULONG           ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    ULONG           cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
    ULONG           ulReserved1;
    ULONG           ulPropTag;
    ULONG           ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
    ULONG           ulSubObject;
    LPSRestriction  lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
    ULONG           cValues; /* # of properties in lpProp */
    LPSRestriction  lpRes;
    LPSPropValue    lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
    ULONG   rt;         /* Restriction type */
    union
    {
        SComparePropsRestriction    resCompareProps;    /* first */
        SAndRestriction             resAnd;
        SOrRestriction              resOr;
        SNotRestriction             resNot;
        SContentRestriction         resContent;
        SPropertyRestriction        resProperty;
        SBitMaskRestriction         resBitMask;
        SSizeRestriction            resSize;
        SExistRestriction           resExist;
        SSubRestriction             resSub;
        SCommentRestriction         resComment;
    } res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS     ((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW            ((ULONG) 1)
#define TBL_EMPTY_CATEGORY      ((ULONG) 2)
#define TBL_EXPANDED_CATEGORY   ((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY  ((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT          ((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC           ((ULONG) 0x00000001)
#define TBL_BATCH           ((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD        ((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE       ((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)                                  \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(GetStatus)                                               \
        (THIS_  ULONG FAR *                 lpulTableStatus,            \
                ULONG FAR *                 lpulTableType) IPURE;       \
    MAPIMETHOD(SetColumns)                                              \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QueryColumns)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lpPropTagArray) IPURE;      \
    MAPIMETHOD(GetRowCount)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulCount) IPURE;           \
    MAPIMETHOD(SeekRow)                                                 \
        (THIS_  BOOKMARK                    bkOrigin,                   \
                LONG                        lRowCount,                  \
                LONG FAR *                  lplRowsSought) IPURE;       \
    MAPIMETHOD(SeekRowApprox)                                           \
        (THIS_  ULONG                       ulNumerator,                \
                ULONG                       ulDenominator) IPURE;       \
    MAPIMETHOD(QueryPosition)                                           \
        (THIS_  ULONG FAR *                 lpulRow,                    \
                ULONG FAR *                 lpulNumerator,              \
                ULONG FAR *                 lpulDenominator) IPURE;     \
    MAPIMETHOD(FindRow)                                                 \
        (THIS_  LPSRestriction              lpRestriction,              \
                BOOKMARK                    bkOrigin,                   \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(Restrict)                                                \
        (THIS_  LPSRestriction              lpRestriction,              \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateBookmark)                                          \
        (THIS_  BOOKMARK FAR *              lpbkPosition) IPURE;        \
    MAPIMETHOD(FreeBookmark)                                            \
        (THIS_  BOOKMARK                    bkPosition) IPURE;          \
    MAPIMETHOD(SortTable)                                               \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QuerySortOrder)                                          \
        (THIS_  LPSSortOrderSet FAR *       lppSortCriteria) IPURE;     \
    MAPIMETHOD(QueryRows)                                               \
        (THIS_  LONG                        lRowCount,                  \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows) IPURE;             \
    MAPIMETHOD(Abort) (THIS) IPURE;                                     \
    MAPIMETHOD(ExpandRow)                                               \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulRowCount,                 \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows,                    \
                ULONG FAR *                 lpulMoreRows) IPURE;        \
    MAPIMETHOD(CollapseRow)                                             \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulRowCount) IPURE;        \
    MAPIMETHOD(WaitForCompletion)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulTimeout,                  \
                ULONG FAR *                 lpulTableStatus) IPURE;     \
    MAPIMETHOD(GetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbInstanceKey,              \
                LPBYTE                      lpbInstanceKey,             \
                ULONG FAR *                 lpcbCollapseState,          \
                LPBYTE FAR *                lppbCollapseState) IPURE;   \
    MAPIMETHOD(SetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbCollapseState,            \
                LPBYTE                      pbCollapseState,            \
                BOOKMARK FAR *              lpbkLocation) IPURE;        \

#undef       INTERFACE
#define      INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{   0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
    0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER     ((ULONG) 33)    /* Message Store */
#define MAPI_AB                 ((ULONG) 34)    /* Address Book */
#define MAPI_AB_PROVIDER        ((ULONG) 35)    /* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER ((ULONG) 36)    /* Transport Provider */
#define MAPI_SPOOLER            ((ULONG) 37)    /* Message Spooler */
#define MAPI_PROFILE_PROVIDER   ((ULONG) 38)    /* Profile Provider */
#define MAPI_SUBSYSTEM          ((ULONG) 39)    /* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER      ((ULONG) 40)    /* Spooler Hook */

#define STATUS_VALIDATE_STATE   ((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG  ((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD  ((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES     ((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND ((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE    ((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY ((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE     ((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST   ((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE ((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION     ((ULONG) 0x00000080)
#define STATUS_OWN_STORE        ((ULONG) 0x00000100)
/****** HOOK_INBOUND            ((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND           ((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE    ((ULONG) 0x00000800)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define STATUS_AVAILABLE        ((ULONG) 0x00000001)
#define STATUS_OFFLINE          ((ULONG) 0x00000002)
#define STATUS_FAILURE          ((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED  ((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE   ((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH    ((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED ((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE  ((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH   ((ULONG) 0x00400000)
#define STATUS_REMOTE_ACCESS    ((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI                 ((ULONG) 0x00000001)
#define REFRESH_XP_HEADER_CACHE     ((ULONG) 0x00010000)
#define PROCESS_XP_HEADER_CACHE     ((ULONG) 0x00020000)
#define FORCE_XP_CONNECT            ((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT         ((ULONG) 0x00080000)
#define CONFIG_CHANGED              ((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION   ((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI          ((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY     ((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD        ((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD      ((ULONG) 0x00000004)
#define FLUSH_FORCE         ((ULONG) 0x00000008)
#define FLUSH_NO_UI         ((ULONG) 0x00000010)

#define MAPI_IMAPISTATUS_METHODS(IPURE)                                 \
    MAPIMETHOD(ValidateState)                                           \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SettingsDialog)                                          \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ChangePassword)                                          \
        (THIS_  LPTSTR                      lpOldPass,                  \
                LPTSTR                      lpNewPass,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(FlushQueues)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbTargetTransport,          \
                LPENTRYID                   lpTargetTransport,          \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPISTATUS_METHODS(PURE)
};

/* IMAPIContainer Interface ------------------------------------------------ */

/* Flags for OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
#define MAPI_BEST_ACCESS        ((ULONG) 0x00000010)

/* GetContentsTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */

/* GetHierarchyTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define CONVENIENT_DEPTH        ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* GetSearchCriteria */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define SEARCH_RUNNING          ((ULONG) 0x00000001)
#define SEARCH_REBUILD          ((ULONG) 0x00000002)
#define SEARCH_RECURSIVE        ((ULONG) 0x00000004)
#define SEARCH_FOREGROUND       ((ULONG) 0x00000008)

/* SetSearchCriteria */
#define STOP_SEARCH             ((ULONG) 0x00000001)
#define RESTART_SEARCH          ((ULONG) 0x00000002)
#define RECURSIVE_SEARCH        ((ULONG) 0x00000004)
#define SHALLOW_SEARCH          ((ULONG) 0x00000008)
#define FOREGROUND_SEARCH       ((ULONG) 0x00000010)
#define BACKGROUND_SEARCH       ((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE)                              \
    MAPIMETHOD(GetContentsTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(GetHierarchyTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetSearchCriteria)                                       \
        (THIS_  LPSRestriction              lpRestriction,              \
                LPENTRYLIST                 lpContainerList,            \
                ULONG                       ulSearchFlags) IPURE;       \
    MAPIMETHOD(GetSearchCriteria)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRestriction FAR *        lppRestriction,             \
                LPENTRYLIST FAR *           lppContainerList,           \
                ULONG FAR *                 lpulSearchState)IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMAPIContainer
DECLARE_MAPI_INTERFACE_(IMAPIContainer, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
};

/* IABContainer Interface -------------------------------------------------- */

/*
 *  IABContainer PR_CONTAINER_FLAGS values
 *  If AB_UNMODIFIABLE and AB_MODIFIABLE are both set, it means the container
 *  doesn't know if it's modifiable or not, and the client should
 *  try to modify the contents but we won't expect it to work.
 *  If the AB_RECIPIENTS flag is set and neither AB_MODIFIABLE or AB_UNMODIFIABLE
 *  bits are set, it is an error.
 */

typedef struct _flaglist
{
    ULONG cFlags;
    ULONG ulFlag[MAPI_DIM];
} FlagList, FAR * LPFlagList;


/*
 *  Container flags
 */
#define AB_RECIPIENTS           ((ULONG) 0x00000001)
#define AB_SUBCONTAINERS        ((ULONG) 0x00000002)
#define AB_MODIFIABLE           ((ULONG) 0x00000004)
#define AB_UNMODIFIABLE         ((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN         ((ULONG) 0x00000010)

/* CreateEntry() */

#define CREATE_CHECK_DUP_STRICT ((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE  ((ULONG) 0x00000002)
#define CREATE_REPLACE          ((ULONG) 0x00000004)

/* ResolveNames() - ulFlags */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* ResolveNames() - rgulFlags */
#define MAPI_UNRESOLVED         ((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS          ((ULONG) 0x00000001)
#define MAPI_RESOLVED           ((ULONG) 0x00000002)


#define MAPI_IABCONTAINER_METHODS(IPURE)                                \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABContainer
DECLARE_MAPI_INTERFACE_(IABContainer, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IABCONTAINER_METHODS(PURE)
};

/* IMailUser Interface ----------------------------------------------------- */

/* Values of PR_NDR_DIAG_CODE */

#define MAPI_DIAG(_code)    ((LONG) _code)

#define MAPI_DIAG_NO_DIAGNOSTIC                     MAPI_DIAG( -1 )
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED              MAPI_DIAG( 0 )
#define MAPI_DIAG_OR_NAME_AMBIGUOUS                 MAPI_DIAG( 1 )
#define MAPI_DIAG_MTS_CONGESTED                     MAPI_DIAG( 2 )
#define MAPI_DIAG_LOOP_DETECTED                     MAPI_DIAG( 3 )
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE             MAPI_DIAG( 4 )
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED              MAPI_DIAG( 5 )
#define MAPI_DIAG_EITS_UNSUPPORTED                  MAPI_DIAG( 6 )
#define MAPI_DIAG_CONTENT_TOO_LONG                  MAPI_DIAG( 7 )
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT            MAPI_DIAG( 8 )
#define MAPI_DIAG_PROHIBITED_TO_CONVERT             MAPI_DIAG( 9 )
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED           MAPI_DIAG( 10 )
#define MAPI_DIAG_PARAMETERS_INVALID                MAPI_DIAG( 11 )
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR           MAPI_DIAG( 12 )
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD         MAPI_DIAG( 13 )
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD         MAPI_DIAG( 14 )
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED          MAPI_DIAG( 15 )
#define MAPI_DIAG_TOO_MANY_RECIPIENTS               MAPI_DIAG( 16 )
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT            MAPI_DIAG( 17 )
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED         MAPI_DIAG( 18 )
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB            MAPI_DIAG( 19 )
#define MAPI_DIAG_LINE_TOO_LONG                     MAPI_DIAG( 20 )
#define MAPI_DIAG_PAGE_TOO_LONG                     MAPI_DIAG( 21 )
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST             MAPI_DIAG( 22 )
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST           MAPI_DIAG( 23 )
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST         MAPI_DIAG( 24 )
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES              MAPI_DIAG( 25 )
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED           MAPI_DIAG( 26 )
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED         MAPI_DIAG( 27 )
#define MAPI_DIAG_EXPANSION_PROHIBITED              MAPI_DIAG( 28 )
#define MAPI_DIAG_SUBMISSION_PROHIBITED             MAPI_DIAG( 29 )
#define MAPI_DIAG_EXPANSION_FAILED                  MAPI_DIAG( 30 )
#define MAPI_DIAG_RENDITION_UNSUPPORTED             MAPI_DIAG( 31 )
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT            MAPI_DIAG( 32 )
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD         MAPI_DIAG( 33 )
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE           MAPI_DIAG( 34 )
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN            MAPI_DIAG( 35 )
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED           MAPI_DIAG( 36 )
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED         MAPI_DIAG( 37 )
#define MAPI_DIAG_MAIL_REFUSED                      MAPI_DIAG( 38 )
#define MAPI_DIAG_MAIL_UNCLAIMED                    MAPI_DIAG( 39 )
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED              MAPI_DIAG( 40 )
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING         MAPI_DIAG( 41 )
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED           MAPI_DIAG( 42 )
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN          MAPI_DIAG( 43 )
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED          MAPI_DIAG( 44 )
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB            MAPI_DIAG( 45 )
#define MAPI_DIAG_SECURE_MESSAGING_ERROR            MAPI_DIAG( 46 )
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE            MAPI_DIAG( 47 )


#define MAPI_IMAILUSER_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IMailUser
DECLARE_MAPI_INTERFACE_(IMailUser, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAILUSER_METHODS(PURE)
};

/* IDistList Interface ----------------------------------------------------- */

#define MAPI_IDISTLIST_METHODS(IPURE)                                   \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IDistList
DECLARE_MAPI_INTERFACE_(IDistList, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IDISTLIST_METHODS(PURE)
};

/* IMAPIFolder Interface --------------------------------------------------- */

/* IMAPIFolder folder type (enum) */

#define FOLDER_ROOT             ((ULONG) 0x00000000)
#define FOLDER_GENERIC          ((ULONG) 0x00000001)
#define FOLDER_SEARCH           ((ULONG) 0x00000002)

/* CreateMessage */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */

/* CopyMessages */

#define MESSAGE_MOVE            ((ULONG) 0x00000001)
#define MESSAGE_DIALOG          ((ULONG) 0x00000002)
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */

/* CreateFolder */

#define OPEN_IF_EXISTS          ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* DeleteFolder */

#define DEL_MESSAGES            ((ULONG) 0x00000001)
#define FOLDER_DIALOG           ((ULONG) 0x00000002)
#define DEL_FOLDERS             ((ULONG) 0x00000004)

/* EmptyFolder */
#define DEL_ASSOCIATED          ((ULONG) 0x00000008)

/* CopyFolder */

#define FOLDER_MOVE             ((ULONG) 0x00000001)
/****** FOLDER_DIALOG           ((ULONG) 0x00000002) above */
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */
#define COPY_SUBFOLDERS         ((ULONG) 0x00000010)
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */


/* SetReadFlags */

/****** SUPPRESS_RECEIPT        ((ULONG) 0x00000001) below */
/****** MESSAGE_DIALOG          ((ULONG) 0x00000002) above */
/****** CLEAR_READ_FLAG         ((ULONG) 0x00000004) below */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
#define GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010)


/* GetMessageStatus */

#define MSGSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED        ((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED     ((ULONG) 0x00000008)

/* Bits for remote message status */

#define MSGSTATUS_REMOTE_DOWNLOAD   ((ULONG) 0x00001000)
#define MSGSTATUS_REMOTE_DELETE     ((ULONG) 0x00002000)

/* SaveContentsSort */

#define RECURSIVE_SORT          ((ULONG) 0x00000002)

/* PR_STATUS property */

#define FLDSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED        ((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED     ((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE)                                 \
    MAPIMETHOD(CreateMessage)                                           \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMESSAGE FAR *             lppMessage) IPURE;          \
    MAPIMETHOD(CopyMessages)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteMessages)                                          \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateFolder)                                            \
        (THIS_  ULONG                       ulFolderType,               \
                LPTSTR                      lpszFolderName,             \
                LPTSTR                      lpszFolderComment,          \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMAPIFOLDER FAR *          lppFolder) IPURE;           \
    MAPIMETHOD(CopyFolder)                                              \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                LPTSTR                      lpszNewFolderName,          \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteFolder)                                            \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlags)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulMessageStatus) IPURE;   \
    MAPIMETHOD(SetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulNewStatus,                \
                ULONG                       ulNewStatusMask,            \
                ULONG FAR *                 lpulOldStatus) IPURE;       \
    MAPIMETHOD(SaveContentsSort)                                        \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(EmptyFolder)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIFolder
DECLARE_MAPI_INTERFACE_(IMAPIFolder, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IMAPIFOLDER_METHODS(PURE)
};

/* IMsgStore Interface ----------------------------------------------------- */

/*  PR_STORE_SUPPORT_MASK bits */
#define STORE_ENTRYID_UNIQUE    ((ULONG) 0x00000001)
#define STORE_READONLY          ((ULONG) 0x00000002)
#define STORE_SEARCH_OK         ((ULONG) 0x00000004)
#define STORE_MODIFY_OK         ((ULONG) 0x00000008)
#define STORE_CREATE_OK         ((ULONG) 0x00000010)
#define STORE_ATTACH_OK         ((ULONG) 0x00000020)
#define STORE_OLE_OK            ((ULONG) 0x00000040)
#define STORE_SUBMIT_OK         ((ULONG) 0x00000080)
#define STORE_NOTIFY_OK         ((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK       ((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK     ((ULONG) 0x00000400)
#define STORE_RTF_OK            ((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK    ((ULONG) 0x00001000)
#define STORE_SORT_OK           ((ULONG) 0x00002000)


/* OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */

/* SetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolderTable() */

/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* StoreLogoff() */

#define LOGOFF_NO_WAIT          ((ULONG) 0x00000001)
#define LOGOFF_ORDERLY          ((ULONG) 0x00000002)
#define LOGOFF_PURGE            ((ULONG) 0x00000004)
#define LOGOFF_ABORT            ((ULONG) 0x00000008)
#define LOGOFF_QUIET            ((ULONG) 0x00000010)

#define LOGOFF_COMPLETE         ((ULONG) 0x00010000)
#define LOGOFF_INBOUND          ((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND         ((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE   ((ULONG) 0x00080000)

/* SetLockState() */

#define MSG_LOCKED              ((ULONG) 0x00000001)
#define MSG_UNLOCKED            ((ULONG) 0x00000000)

/* Flag bits for PR_VALID_FOLDER_MASK */

#define FOLDER_IPM_SUBTREE_VALID        ((ULONG) 0x00000001)
#define FOLDER_IPM_INBOX_VALID          ((ULONG) 0x00000002)
#define FOLDER_IPM_OUTBOX_VALID         ((ULONG) 0x00000004)
#define FOLDER_IPM_WASTEBASKET_VALID    ((ULONG) 0x00000008)
#define FOLDER_IPM_SENTMAIL_VALID       ((ULONG) 0x00000010)
#define FOLDER_VIEWS_VALID              ((ULONG) 0x00000020)
#define FOLDER_COMMON_VIEWS_VALID       ((ULONG) 0x00000040)
#define FOLDER_FINDER_VALID             ((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE)                                   \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID,                 \
                LPTSTR FAR *                lppszExplicitClass) IPURE;  \
    MAPIMETHOD(GetReceiveFolderTable)                                   \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(StoreLogoff)                                             \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(AbortSubmit)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetOutgoingQueue)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(SetLockState)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG                       ulLockState) IPURE;         \
    MAPIMETHOD(FinishedMsg)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(NotifyNewMail)                                           \
        (THIS_  LPNOTIFICATION              lpNotification) IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMsgStore
DECLARE_MAPI_INTERFACE_(IMsgStore, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMSGSTORE_METHODS(PURE)
};

/* IMessage Interface ------------------------------------------------------ */

/* SubmitMessage */

#define FORCE_SUBMIT                ((ULONG) 0x00000001)

/* Flags defined in PR_MESSAGE_FLAGS */

#define MSGFLAG_READ            ((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED      ((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT          ((ULONG) 0x00000004)
#define MSGFLAG_UNSENT          ((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH       ((ULONG) 0x00000010)
#define MSGFLAG_FROMME          ((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED      ((ULONG) 0x00000040)
#define MSGFLAG_RESEND          ((ULONG) 0x00000080)

/* Flags defined in PR_SUBMIT_FLAGS */

#define SUBMITFLAG_LOCKED       ((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS   ((ULONG) 0x00000002)

/* GetAttachmentTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetRecipientTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* ModifyRecipients */

/* ((ULONG) 0x00000001 is not a valid flag on ModifyRecipients. */
#define MODRECIP_ADD            ((ULONG) 0x00000002)
#define MODRECIP_MODIFY         ((ULONG) 0x00000004)
#define MODRECIP_REMOVE         ((ULONG) 0x00000008)

/* SetReadFlag */

#define SUPPRESS_RECEIPT        ((ULONG) 0x00000001)
#define CLEAR_READ_FLAG         ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010) above */

/* DeleteAttach */

#define ATTACH_DIALOG           ((ULONG) 0x00000001)

/* PR_SECURITY values */
#define SECURITY_SIGNED         ((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED      ((ULONG) 0x00000002)

/* PR_PRIORITY values */
#define PRIO_URGENT             ((long)  1)
#define PRIO_NORMAL             ((long)  0)
#define PRIO_NONURGENT          ((long) -1)

/* PR_SENSITIVITY values */
#define SENSITIVITY_NONE                    ((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL                ((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE                 ((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL    ((ULONG) 0x00000003)

/* PR_IMPORTANCE values */
#define IMPORTANCE_LOW          ((long) 0)
#define IMPORTANCE_NORMAL       ((long) 1)
#define IMPORTANCE_HIGH         ((long) 2)

#define MAPI_IMESSAGE_METHODS(IPURE)                                    \
    MAPIMETHOD(GetAttachmentTable)                                      \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenAttach)                                              \
        (THIS_  ULONG                       ulAttachmentNum,            \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(CreateAttach)                                            \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulAttachmentNum,          \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(DeleteAttach)                                            \
        (THIS_  ULONG                       ulAttachmentNum,            \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetRecipientTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(ModifyRecipients)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPADRLIST                   lpMods) IPURE;              \
    MAPIMETHOD(SubmitMessage)                                           \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlag)                                             \
        (THIS_  ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMessage
DECLARE_MAPI_INTERFACE_(IMessage, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMESSAGE_METHODS(PURE)
};

/* IAttach Interface ------------------------------------------------------- */

/* IAttach attachment methods: PR_ATTACH_METHOD values */

#define NO_ATTACHMENT           ((ULONG) 0x00000000)
#define ATTACH_BY_VALUE         ((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE     ((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE   ((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY      ((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG     ((ULONG) 0x00000005)
#define ATTACH_OLE              ((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IAttach
DECLARE_MAPI_INTERFACE_(IAttach, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IATTACH_METHODS(PURE)
};

/* --------------------------------- */
/* Address Book interface definition */

/* ADRPARM ulFlags - top 4 bits used for versioning */

#define GET_ADRPARM_VERSION(ulFlags)  (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags, ulVersion)  (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

/*  Current versions of ADRPARM  */
#define ADRPARM_HELP_CTX        ((ULONG) 0x00000000)


/*  ulFlags   - bit fields */
#define DIALOG_MODAL            ((ULONG) 0x00000001)
#define DIALOG_SDI              ((ULONG) 0x00000002)
#define DIALOG_OPTIONS          ((ULONG) 0x00000004)
#define ADDRESS_ONE             ((ULONG) 0x00000008)
#define AB_SELECTONLY           ((ULONG) 0x00000010)
#define AB_RESOLVE              ((ULONG) 0x00000020)

/* --------------------------------- */
/*  PR_DISPLAY_TYPEs                 */
/*
 *  These standard display types are
 *  by default handled by MAPI.
 *  They have default icons associated
 *  with them.
 */

/*  For address book contents tables */
#define DT_MAILUSER         ((ULONG) 0x00000000)
#define DT_DISTLIST         ((ULONG) 0x00000001)
#define DT_FORUM            ((ULONG) 0x00000002)
#define DT_AGENT            ((ULONG) 0x00000003)
#define DT_ORGANIZATION     ((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST ((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER  ((ULONG) 0x00000006)

/*  For address book hierarchy tables */
#define DT_MODIFIABLE       ((ULONG) 0x00010000)
#define DT_GLOBAL           ((ULONG) 0x00020000)
#define DT_LOCAL            ((ULONG) 0x00030000)
#define DT_WAN              ((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC     ((ULONG) 0x00050000)

/*  For folder hierarchy tables */
#define DT_FOLDER           ((ULONG) 0x01000000)
#define DT_FOLDER_LINK      ((ULONG) 0x02000000)

/*  Accelerator callback for DIALOG_SDI form of AB UI */
typedef BOOL (STDMETHODCALLTYPE ACCELERATEABSDI)(ULONG ulUIParam,
                                                LPVOID lpvmsg);
typedef ACCELERATEABSDI FAR * LPFNABSDI;

/*  Callback to application telling it that the DIALOG_SDI form of the */
/*  AB UI has been dismissed.  This is so that the above LPFNABSDI     */
/*  function doesn't keep being called.                                */
typedef void (STDMETHODCALLTYPE DISMISSMODELESS)(ULONG ulUIParam,
                                                LPVOID lpvContext);
typedef DISMISSMODELESS FAR * LPFNDISMISS;

/*
 * Prototype for the client function hooked to an optional button on
 * the address book dialog
 */

typedef SCODE (STDMETHODCALLTYPE FAR * LPFNBUTTON)(
    ULONG               ulUIParam,
    LPVOID              lpvContext,
    ULONG               cbEntryID,
    LPENTRYID           lpSelection,
    ULONG               ulFlags
);


/* Parameters for the address book dialog */
typedef struct _ADRPARM
{
    ULONG           cbABContEntryID;
    LPENTRYID       lpABContEntryID;
    ULONG           ulFlags;

    LPVOID          lpReserved;
    ULONG           ulHelpContext;
    LPTSTR          lpszHelpFileName;

    LPFNABSDI       lpfnABSDI;
    LPFNDISMISS     lpfnDismiss;
    LPVOID          lpvDismissContext;
    LPTSTR          lpszCaption;
    LPTSTR          lpszNewEntryTitle;
    LPTSTR          lpszDestWellsTitle;
    ULONG           cDestFields;
    ULONG           nDestFieldFocus;
    LPTSTR FAR *    lppszDestTitles;
    ULONG FAR *     lpulDestComps;
    LPSRestriction  lpContRestriction;
    LPSRestriction  lpHierRestriction;
} ADRPARM, FAR * LPADRPARM;


/* ------------ */
/* Random flags */

/* Flag for deferred error */
#define MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008)

/* Flag for creating and using Folder Associated Information Messages */
#define MAPI_ASSOCIATED         ((ULONG) 0x00000040)

/* Flags for OpenMessageStore() */

#define MDB_NO_DIALOG           ((ULONG) 0x00000001)
#define MDB_WRITE               ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) above */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */
#define MDB_TEMPORARY           ((ULONG) 0x00000020)
#define MDB_NO_MAIL             ((ULONG) 0x00000080)

/* Flags for OpenAddressBook */

#define AB_NO_DIALOG            ((ULONG) 0x00000001)

/* IMAPIControl Interface -------------------------------------------------- */

/* Interface used in controls (particularly the button) defined by */
/* Display Tables. */

/*  Flags for GetState */

#define  MAPI_ENABLED       ((ULONG) 0x00000000)
#define  MAPI_DISABLED      ((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE)                                \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Activate)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulUIParam) IPURE;           \
    MAPIMETHOD(GetState)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulState) IPURE;           \

#undef       INTERFACE
#define      INTERFACE  IMAPIControl
DECLARE_MAPI_INTERFACE_(IMAPIControl, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPICONTROL_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIControl, LPMAPICONTROL);

/* Display Tables ---------------------------------------------------------- */

/* Flags used in display tables - that is, PR_CONTROL_FLAGS */

#define DT_MULTILINE        ((ULONG) 0x00000001)
#define DT_EDITABLE         ((ULONG) 0x00000002)
#define DT_REQUIRED         ((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE    ((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT    ((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS      ((ULONG) 0x00000020)
#define DT_SET_SELECTION    ((ULONG) 0x00000040)

/* Display Table structures */

#define DTCT_LABEL          ((ULONG) 0x00000000)
#define DTCT_EDIT           ((ULONG) 0x00000001)
#define DTCT_LBX            ((ULONG) 0x00000002)
#define DTCT_COMBOBOX       ((ULONG) 0x00000003)
#define DTCT_DDLBX          ((ULONG) 0x00000004)
#define DTCT_CHECKBOX       ((ULONG) 0x00000005)
#define DTCT_GROUPBOX       ((ULONG) 0x00000006)
#define DTCT_BUTTON         ((ULONG) 0x00000007)
#define DTCT_PAGE           ((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON    ((ULONG) 0x00000009)
#define DTCT_INKEDIT        ((ULONG) 0x0000000A)
#define DTCT_MVLISTBOX      ((ULONG) 0x0000000B)
#define DTCT_MVDDLBX        ((ULONG) 0x0000000C)

/* Labels */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLLABEL
{
    ULONG ulbLpszLabelName;
    ULONG ulFlags;
} DTBLLABEL, FAR * LPDTBLLABEL;
#define SizedDtblLabel(n,u) \
struct _DTBLLABEL_ ## u \
{ \
    DTBLLABEL   dtbllabel; \
    TCHAR       lpszLabelName[n]; \
} u


/*  Simple Text Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLEDIT
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPropTag;
} DTBLEDIT, FAR * LPDTBLEDIT;
#define SizedDtblEdit(n,u) \
struct _DTBLEDIT_ ## u \
{ \
    DTBLEDIT    dtbledit; \
    TCHAR       lpszCharsAllowed[n]; \
} u

/*  Ink Aware Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLINKEDIT
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulTextPropTag;
    ULONG ulInkDataPropTag;
} DTBLINKEDIT, FAR * LPDTBLINKEDIT;
#define SizedDtblInkEdit(n,u) \
struct _DTBLINKEDIT_ ## u \
{ \
    DTBLINKEDIT dtblinkedit; \
    TCHAR       lpszCharsAllowed[n]; \
} u


/*  List Box  */
/* Valid ulFlags:
 */
#define MAPI_NO_HBAR        ((ULONG) 0x00000001)
#define MAPI_NO_VBAR        ((ULONG) 0x00000002)

typedef struct _DTBLLBX
{
    ULONG ulFlags;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLLBX, FAR * LPDTBLLBX;


/*  Combo Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCOMBOBOX
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPRPropertyName;
    ULONG ulPRTableName;
} DTBLCOMBOBOX, FAR * LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) \
struct _DTBLCOMBOBOX_ ## u \
{ \
    DTBLCOMBOBOX    dtblcombobox; \
    TCHAR           lpszCharsAllowed[n]; \
} u


/*  Drop Down   */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLDDLBX
{
    ULONG ulFlags;
    ULONG ulPRDisplayProperty;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLDDLBX, FAR * LPDTBLDDLBX;


/*  Check Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCHECKBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRPropertyName;
} DTBLCHECKBOX, FAR * LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) \
struct _DTBLCHECKBOX_ ## u \
{ \
    DTBLCHECKBOX    dtblcheckbox; \
    TCHAR       lpszLabel[n]; \
} u



/*  Group Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLGROUPBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
} DTBLGROUPBOX, FAR * LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) \
struct _DTBLGROUPBOX_ ## u \
{ \
    DTBLGROUPBOX    dtblgroupbox; \
    TCHAR           lpszLabel[n]; \
} u

/*  Button control   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRControl;
} DTBLBUTTON, FAR * LPDTBLBUTTON;
#define SizedDtblButton(n,u) \
struct _DTBLBUTTON_ ## u \
{ \
    DTBLBUTTON  dtblbutton; \
    TCHAR       lpszLabel[n]; \
} u

/*  Pages   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLPAGE
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulbLpszComponent;
    ULONG ulContext;
} DTBLPAGE, FAR * LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) \
struct _DTBLPAGE_ ## u \
{ \
    DTBLPAGE    dtblpage; \
    TCHAR       lpszLabel[n]; \
    TCHAR       lpszComponent[n1]; \
} u

/*  Radio button   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLRADIOBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulcButtons;
    ULONG ulPropTag;
    long lReturnValue;
} DTBLRADIOBUTTON, FAR * LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) \
struct _DTBLRADIOBUTTON_ ## u \
{ \
    DTBLRADIOBUTTON dtblradiobutton; \
    TCHAR           lpszLabel[n]; \
} u


/*  MultiValued listbox */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVLISTBOX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVLISTBOX, FAR * LPDTBLMVLISTBOX;


/*  MultiValued dropdown */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVDDLBX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVDDLBX, FAR * LPDTBLMVDDLBX;





/* IProviderAdmin Interface ---------------------------------------------- */

/* Flags for ConfigureMsgService */

#define UI_SERVICE                  0x00000002
#define SERVICE_UI_ALWAYS           0x00000002      /* Duplicate UI_SERVICE for consistency and compatibility */
#define SERVICE_UI_ALLOWED          0x00000010
#define UI_CURRENT_PROVIDER_FIRST   0x00000004
/* MSG_SERVICE_UI_READ_ONLY         0x00000008 - in MAPISPI.H */

/* GetProviderTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define MAPI_IPROVIDERADMIN_METHODS(IPURE)                              \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetProviderTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateProvider)                                          \
        (THIS_  LPTSTR                      lpszProvider,               \
                ULONG                       cValues,                    \
                LPSPropValue                lpProps,                    \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                MAPIUID FAR *               lpUID) IPURE;               \
    MAPIMETHOD(DeleteProvider)                                          \
        (THIS_  LPMAPIUID                   lpUID) IPURE;               \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \


#undef       INTERFACE
#define      INTERFACE  IProviderAdmin
DECLARE_MAPI_INTERFACE_(IProviderAdmin, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IPROVIDERADMIN_METHODS(PURE)
};



#ifdef  __cplusplus
}       /*  extern "C" */
#endif

#endif /* MAPIDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mapiguid.h ===
/*
 *  M A P I G U I D . H
 *
 *  Master definitions of all GUID's for MAPI.
 *
 *  When included without INITGUID defined, this header file
 *  defines symbols that reference IIDs elsewhere.
 *
 *  When included with INITGUID defined and a "USES_IID_I..."
 *  statement for each IID used by the subsystem, it generates the
 *  bytes for those actual IIDs into the associated object file.
 *
 *  This range of 256 GUIDs reserved by OLE for MAPI use October 5, 1992.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

/*
 *  List of GUIDS allocated by MAPI
 *  
 *  0x00020300  IID_IMAPISession
 *  0x00020301  IID_IMAPITable
 *  0x00020302  IID_IMAPIAdviseSink
 *  0x00020303  IID_IMAPIProp
 *  0x00020304  IID_IProfSect
 *  0x00020305  IID_IMAPIStatus
 *  0x00020306  IID_IMsgStore
 *  0x00020307  IID_IMessage
 *  0x00020308  IID_IAttachment
 *  0x00020309  IID_IAddrBook
 *  0x0002030A  IID_IMailUser
 *  0x0002030B  IID_IMAPIContainer
 *  0x0002030C  IID_IMAPIFolder
 *  0x0002030D  IID_IABContainer
 *  0x0002030E  IID_IDistList
 *  0x0002030F  IID_IMAPISup
 *  0x00020310  IID_IMSProvider
 *  0x00020311  IID_IABProvider
 *  0x00020312  IID_IXPProvider
 *  0x00020313  IID_IMSLogon
 *  0x00020314  IID_IABLogon
 *  0x00020315  IID_IXPLogon
 *  0x00020316  IID_IMAPITableData
 *  0x00020317  IID_IMAPISpoolerInit
 *  0x00020318  IID_IMAPISpoolerSession
 *  0x00020319  IID_ITNEF
 *  0x0002031A  IID_IMAPIPropData
 *  0x0002031B  IID_IMAPIControl
 *  0x0002031C  IID_IProfAdmin
 *  0x0002031D  IID_IMsgServiceAdmin
 *  0x0002031E  IID_IMAPISpoolerService
 *  0x0002031F  IID_IMAPIProgress
 *  0x00020320  IID_ISpoolerHook
 *  0x00020321  IID_IMAPIViewContext
 *  0x00020322  IID_IMAPIFormMgr
 *  0x00020323  IID_IEnumMAPIFormProp
 *  0x00020324  IID_IMAPIFormInfo
 *  0x00020325  IID_IProviderAdmin
 *  0x00020327  IID_IMAPIForm
 *  0x00020328  PS_MAPI
 *  0x00020329  PS_PUBLIC_STRINGS
 *  0x0002032A  IID_IPersistMessage
 *  0x0002032B  IID_IMAPIViewAdviseSink
 *  0x0002032C  IID_IStreamDocfile
 *  0x0002032D  IID_IMAPIFormProp
 *  0x0002032E  IID_IMAPIFormContainer
 *  0x0002032F  IID_IMAPIFormAdviseSink
 *  0x00020330  IID_IStreamTnef
 *  0x00020370  IID_IMAPIMessageSite
 *  
 *  The remaining GUIDs from 0x00020300 to 0x000203FF are reserved by
 *  MAPI for future use.  The current maximum used by MAPI is 0x00020370
 *
 */

#ifndef MAPIGUID_H
#ifdef  INITGUID
#define MAPIGUID_H
#endif

/* Derive from IUnknown */
#if !defined(INITGUID) || defined(USES_IID_IMAPISession)
DEFINE_OLEGUID(IID_IMAPISession,    0x00020300, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPITable)
DEFINE_OLEGUID(IID_IMAPITable,      0x00020301, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIAdviseSink)
DEFINE_OLEGUID(IID_IMAPIAdviseSink, 0x00020302, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIControl)
DEFINE_OLEGUID(IID_IMAPIControl,    0x0002031B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfAdmin)
DEFINE_OLEGUID(IID_IProfAdmin,      0x0002031C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgServiceAdmin)
DEFINE_OLEGUID(IID_IMsgServiceAdmin,0x0002031D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProviderAdmin)
DEFINE_OLEGUID(IID_IProviderAdmin,  0x00020325, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIProgress)
DEFINE_OLEGUID(IID_IMAPIProgress,   0x0002031F, 0, 0);
#endif

/* MAPIProp or derive from MAPIProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIProp)
DEFINE_OLEGUID(IID_IMAPIProp,       0x00020303, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfSect)
DEFINE_OLEGUID(IID_IProfSect,       0x00020304, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIStatus)
DEFINE_OLEGUID(IID_IMAPIStatus,         0x00020305, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgStore)
DEFINE_OLEGUID(IID_IMsgStore,       0x00020306, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMessage)
DEFINE_OLEGUID(IID_IMessage,        0x00020307, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAttachment)
DEFINE_OLEGUID(IID_IAttachment,     0x00020308, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAddrBook)
DEFINE_OLEGUID(IID_IAddrBook,       0x00020309, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMailUser)
DEFINE_OLEGUID(IID_IMailUser,       0x0002030A, 0, 0);
#endif

/* MAPIContainer or derive from MAPIContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIContainer)
DEFINE_OLEGUID(IID_IMAPIContainer,  0x0002030B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFolder)
DEFINE_OLEGUID(IID_IMAPIFolder,     0x0002030C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABContainer)
DEFINE_OLEGUID(IID_IABContainer,    0x0002030D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IDistList)
DEFINE_OLEGUID(IID_IDistList,       0x0002030E, 0, 0);
#endif

/* MAPI Support Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISup)
DEFINE_OLEGUID(IID_IMAPISup,        0x0002030F, 0, 0);
#endif

/* Provider INIT objects */
#if !defined(INITGUID) || defined(USES_IID_IMSProvider)
DEFINE_OLEGUID(IID_IMSProvider,     0x00020310, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABProvider)
DEFINE_OLEGUID(IID_IABProvider,     0x00020311, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPProvider)
DEFINE_OLEGUID(IID_IXPProvider,     0x00020312, 0, 0);
#endif

/* Provider LOGON Objects */
#if !defined(INITGUID) || defined(USES_IID_IMSLogon)
DEFINE_OLEGUID(IID_IMSLogon,        0x00020313, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABLogon)
DEFINE_OLEGUID(IID_IABLogon,        0x00020314, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPLogon)
DEFINE_OLEGUID(IID_IXPLogon,        0x00020315, 0, 0);
#endif

/* IMAPITable-in-memory Table Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPITableData)
DEFINE_OLEGUID(IID_IMAPITableData,  0x00020316, 0, 0);
#endif

/* MAPI Spooler Init Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerInit)
DEFINE_OLEGUID(IID_IMAPISpoolerInit,    0x00020317, 0, 0);
#endif

/* MAPI Spooler Session Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerSession)
DEFINE_OLEGUID(IID_IMAPISpoolerSession, 0x00020318, 0, 0);
#endif

/* MAPI TNEF Object Interface */
#if !defined(INITGUID) || defined(USES_IID_ITNEF)
DEFINE_OLEGUID(IID_ITNEF,           0x00020319, 0, 0);
#endif

/* IMAPIProp-in-memory Property Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPIPropData)
DEFINE_OLEGUID(IID_IMAPIPropData,   0x0002031A, 0, 0);
#endif

/* MAPI Spooler Hook Object */
#if !defined(INITGUID) || defined(USES_IID_ISpoolerHook)
DEFINE_OLEGUID(IID_ISpoolerHook,    0x00020320, 0, 0);
#endif

/* MAPI Spooler Service Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerService)
DEFINE_OLEGUID(IID_IMAPISpoolerService, 0x0002031E, 0, 0);
#endif

/* MAPI forms, form manager, etc. */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewContext)
DEFINE_OLEGUID(IID_IMAPIViewContext,    0x00020321, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormMgr)
DEFINE_OLEGUID(IID_IMAPIFormMgr,    0x00020322, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IEnumMAPIFormProp)
DEFINE_OLEGUID(IID_IEnumMAPIFormProp,   0x00020323, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormInfo)
DEFINE_OLEGUID(IID_IMAPIFormInfo,   0x00020324, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIForm)
DEFINE_OLEGUID(IID_IMAPIForm,   0x00020327, 0, 0);
#endif


/* Well known guids for name<->id mappings */

/*  The name of MAPI's property set  */
#if !defined(INITGUID) || defined(USES_PS_MAPI)
DEFINE_OLEGUID(PS_MAPI, 0x00020328, 0, 0);
#endif

/*  The name of the set of public strings  */
#if !defined(INITGUID) || defined(USES_PS_PUBLIC_STRINGS)
DEFINE_OLEGUID(PS_PUBLIC_STRINGS,   0x00020329, 0, 0);
#endif

/* MAPI forms, form manager, (cont) */
#if !defined(INITGUID) || defined(USES_IID_IPersistMessage)
DEFINE_OLEGUID(IID_IPersistMessage, 0x0002032A, 0, 0);
#endif

/* IMAPIViewAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewAdviseSink)
DEFINE_OLEGUID(IID_IMAPIViewAdviseSink, 0x0002032B, 0, 0);
#endif

/* Message Store OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamDocfile)
DEFINE_OLEGUID(IID_IStreamDocfile, 0x0002032C, 0, 0);
#endif

/* IMAPIFormProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormProp)
DEFINE_OLEGUID(IID_IMAPIFormProp,   0x0002032D, 0, 0);
#endif

/* IMAPIFormContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormContainer)
DEFINE_OLEGUID(IID_IMAPIFormContainer, 0x0002032E, 0, 0);
#endif

/* IMAPIFormAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormAdviseSink)
DEFINE_OLEGUID(IID_IMAPIFormAdviseSink, 0x0002032F, 0, 0);
#endif

/* TNEF OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamTnef)
DEFINE_OLEGUID(IID_IStreamTnef, 0x00020330, 0, 0);
#endif

/* IMAPIMessageSite */
#if !defined(INITGUID) || defined(USES_IID_IMAPIMessageSite)
DEFINE_OLEGUID(IID_IMAPIMessageSite, 0x00020370, 0, 0);
#endif

#endif  /* MAPIGUID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mapinls.h ===
/*
 *  M A P I N L S . H
 *
 *  Internationalization Support Utilities
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPINLS_H_
#define _MAPINLS_H_

#ifdef __cplusplus
extern "C" {
#endif

/* We don't want to include windows.h in case that conflicts with an */
/* earlier inclusion of compobj.h */

#if !defined(WINAPI)
    #if defined(WIN32) && (_MSC_VER >= 800)
        #define WINAPI              __stdcall
    #elif defined(WIN16)
        #define WINAPI              _far _pascal
    #else
        #define WINAPI              _far _pascal
    #endif
#endif

#if defined(DOS) || defined(MAC)
#include <string.h>
#endif

#ifndef FAR
#define FAR
#endif

typedef unsigned char                   BYTE;
typedef unsigned short                  WORD;
typedef unsigned long                   DWORD;
typedef unsigned int                    UINT;
typedef int                             BOOL;

#ifndef __CHAR_DEFINED__
typedef char                            CHAR;
#endif

#ifdef UNICODE
typedef WCHAR                           TCHAR;
#else
typedef char                            TCHAR;
#endif

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short                  WCHAR;
#else
typedef wchar_t WCHAR;
#endif

typedef WCHAR FAR *                     LPWSTR;
typedef const WCHAR FAR *               LPCWSTR;
typedef CHAR FAR *                      LPSTR;
typedef const CHAR FAR *                LPCSTR;
typedef TCHAR FAR *                     LPTSTR;
typedef const TCHAR FAR *               LPCTSTR;
typedef DWORD                           LCID;
typedef const void FAR *                LPCVOID;

#ifndef LPOLESTR
#ifndef WIN32

#define LPOLESTR        LPSTR
#define LPCOLESTR       LPCSTR
#define OLECHAR         char
#define OLESTR(str) str

#else  /* Win32 */

#define LPOLESTR        LPWSTR
#define LPCOLESTR       LPCWSTR
#define OLECHAR         WCHAR
#define OLESTR(str)     L##str

#endif /* !WIN32 */
#endif /* LPOLESTR */

#define NORM_IGNORECASE                 0x00000001     /* ignore case */
#define NORM_IGNORENONSPACE             0x00000002     /* ignore diacritics */
#define NORM_IGNORESYMBOLS              0x00000004     /* ignore symbols */
#define NORM_IGNOREKANATYPE             0x00010000     /* ignore kanatype */
#define NORM_IGNOREWIDTH                0x00020000     /* ignore width */

#if defined(WIN16)

#define lstrcpyA                        lstrcpy
#define lstrlenA                        lstrlen
#define lstrcmpA                        lstrcmp
#define lstrcmpiA                       lstrcmpi
#define LoadStringA                     LoadString
#define IsBadStringPtrA(a1, a2)         IsBadStringPtr(a1, a2)
#define wvsprintfA                      wvsprintf
#define MessageBoxA                     MessageBox
#define GetModuleHandleA                GetModuleHandle
#define CreateWindowA                   CreateWindow
#define RegisterClassA                  RegisterClass
#define CharToOemBuff                   AnsiToOemBuff
#define CharToOem                       AnsiToOem
#define CharUpperBuff                   AnsiUpperBuff
#define CharUpper                       AnsiUpper

#elif defined(DOS) || defined(MAC)

#define IsBadReadPtr(lp, cb)            (FALSE)
#define IsBadWritePtr(lp, cb)           (FALSE)
#define IsBadHugeReadPtr(lp, cb)        (FALSE)
#define IsBadHugeWritePtr(lp, cb)       (FALSE)
#define IsBadCodePtr(lpfn)              (FALSE)
#define IsBadStringPtr(lpsz, cchMax)    (FALSE)
#define IsBadStringPtrA(lpsz, cchMax)   (FALSE)

#if defined(DOS)

#define lstrcpyA                        strcpy
#define lstrlenA                        strlen
#define lstrcmpA                        strcmp
#define lstrcmp                         strcmp
#define lstrcmpi                        strcmpi
#define lstrcpy                         strcpy
#define lstrcat                         strcat
#define lstrlen                         strlen
#define wsprintf                        sprintf

#endif
#endif

#if defined(DOS) || defined(WIN16)
#define TEXT(x)     x
#endif

#define CP_ACP      0       /* default to ANSI code page */
#define CP_OEMCP    1       /* default to OEM  code page */

LCID    WINAPI  MNLS_GetUserDefaultLCID(void);
UINT    WINAPI  MNLS_GetACP(void);
int     WINAPI  MNLS_CompareStringA(LCID Locale, DWORD dwCmpFlags,
                    LPCSTR lpString1, int cchCount1, LPCSTR lpString2,
                    int cchCount2);
int     WINAPI  MNLS_CompareStringW(LCID Locale, DWORD dwCmpFlags,
                    LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2,
                    int cchCount2);
int     WINAPI  MNLS_MultiByteToWideChar(UINT uCodePage, DWORD dwFlags,
                    LPCSTR lpMultiByteStr, int cchMultiByte,
                    LPWSTR lpWideCharStr, int cchWideChar);
int     WINAPI  MNLS_WideCharToMultiByte(UINT uCodePage, DWORD dwFlags,
                    LPCWSTR lpWideCharStr, int cchWideChar,
                    LPSTR lpMultiByteStr, int cchMultiByte,
                    LPCSTR lpDefaultChar, BOOL FAR *lpfUsedDefaultChar);
int     WINAPI  MNLS_lstrlenW(LPCWSTR lpString);
int     WINAPI  MNLS_lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
LPWSTR  WINAPI  MNLS_lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
BOOL    WINAPI  MNLS_IsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);

#if defined(WIN32) && !defined(NT) && !defined(CHICAGO) && !defined(_MAC)
#define NT
#endif

#if !defined(NT) && !defined(CHICAGO)
#define GetUserDefaultLCID      MNLS_GetUserDefaultLCID
#define GetACP                  MNLS_GetACP
#define MultiByteToWideChar     MNLS_MultiByteToWideChar
#define WideCharToMultiByte     MNLS_WideCharToMultiByte
#define CompareStringA          MNLS_CompareStringA
#endif

#if !defined(NT)
#define lstrlenW                MNLS_lstrlenW
#define lstrcmpW                MNLS_lstrcmpW
#define lstrcpyW                MNLS_lstrcpyW
#define CompareStringW          MNLS_CompareStringW

#if defined(WIN16) || defined(CHICAGO)
#define IsBadStringPtrW         MNLS_IsBadStringPtrW
#elif defined(MAC)
#define IsBadStringPtrW(lpsz, cchMax)           (FALSE)
#else
#define IsBadStringPtrW         (FALSE)
#endif

#endif

#ifdef __cplusplus
}
#endif

#endif /* _MAPINLS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mapispi.h ===
/*
 *  M A P I S P I . H
 *
 *  Defines the calls and structures exchanged between MAPI or the spooler
 *  and the MAPI service providers
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPISPI_H
#define MAPISPI_H
/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*  The MAPI SPI has a version number.  MAPIX.DLL knows and supports
 *  one or more versions of the SPI.  Each provider supports one or
 *  more versions of the SPI.  Checks are performed in both MAPIX.DLL
 *  and in the provider to ensure that they agree to use exactly one
 *  version of the MAPI SPI.
 *
 *  The SPI version number is composed of a major (8-bit) version,
 *  minor (8-bit) version, and micro (16-bit) version.  The first
 *  retail ship of MAPI 1.0 is expected to be version 1.0.0.
 *  The major version number changes rarely.
 *  The minor version number changes opon each retail ship of
 *  MAPI if the SPI has been modified.
 *  The micro version number changes internally at Microsoft
 *  during development of MAPI.
 *
 *  The version of the SPI documented by this set of header files
 *  is ALWAYS known as "CURRENT_SPI_VERSION".  If you write a
 *  service provider, and get a new set of header files, and update
 *  your code to the new interface, you'll be at the "current" version.
 */
#define CURRENT_SPI_VERSION 0x00010010L

/*  Here are some well-known SPI version numbers:
 *  (These will eventually be useful for provider-writers who
 *  might choose to make provider DLLs that support more than
 *  one version of the MAPI SPI.
 */
#define PDK1_SPI_VERSION    0x00010000L /* 0.1.0  MAPI PDK1 Spring 1993 */

#define PDK2_SPI_VERSION    0x00010008L /* 0.1.8  MAPI PDK2 Spring 1994 */

#define PDK3_SPI_VERSION    0x00010010L /* 0.1.16 MAPI PDK3 Fall 1994   */

/*
 *  Maximum length of profile names and passwords.
 */
#define cchProfileNameMax   64
#define cchProfilePassMax   64

/*
 * Forward declaration of interface pointers specific to the service
 * provider interface.
 */
DECLARE_MAPI_INTERFACE_PTR(IMAPISupport, LPMAPISUP);

/* IMAPISupport Interface -------------------------------------------------- */

/* Notification key structure for the MAPI notification engine */

typedef struct
{
    ULONG       cb;             /* How big the key is */
    BYTE        ab[MAPI_DIM];   /* Key contents */
} NOTIFKEY, FAR * LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb)      (offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey)      (offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb, _name) \
    struct _NOTIFKEY_ ## _name \
{ \
    ULONG       cb; \
    BYTE        ab[_cb]; \
} _name


/* For Subscribe() */

#define NOTIFY_SYNC             ((ULONG) 0x40000000)

/* For Notify() */

#define NOTIFY_CANCELED         ((ULONG) 0x80000000)


/* From the Notification Callback function (well, this is really a ulResult) */

#define CALLBACK_DISCONTINUE    ((ULONG) 0x80000000)

/* For Transport's SpoolerNotify() */

#define NOTIFY_NEWMAIL          ((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND      ((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED     ((ULONG) 0x00000004)
#define NOTIFY_CRITSEC          ((ULONG) 0x00001000)
#define NOTIFY_NONCRIT          ((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE    ((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR   ((ULONG) 0x10000000)

/* For Message Store's SpoolerNotify() */

#define NOTIFY_NEWMAIL_RECEIVED ((ULONG) 0x20000000)

/* For ModifyStatusRow() */

#define STATUSROW_UPDATE        ((ULONG) 0x10000000)

/* For IStorageFromStream() */

#define STGSTRM_RESET           ((ULONG) 0x00000000)
#define STGSTRM_CURRENT         ((ULONG) 0x10000000)
#define STGSTRM_MODIFY          ((ULONG) 0x00000002)
#define STGSTRM_CREATE          ((ULONG) 0x00001000)

/* For GetOneOffTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/* For CreateOneOff() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/* For ReadReceipt() */
#define MAPI_NON_READ           ((ULONG) 0x00000001)

/* For DoConfigPropSheet() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/* Preprocessor calls: */

/* PreprocessMessage, first ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE PREPROCESSMESSAGE)(
                    LPMESSAGE lpMessage,
                    LPADRBOOK lpAdrBook,
                    LPMAPIFOLDER lpFolder,
                    LPALLOCATEBUFFER AllocateBuffer,
                    LPALLOCATEMORE AllocateMore,
                    LPFREEBUFFER FreeBuffer,
                    ULONG FAR *lpcOutbound,
                    LPMESSAGE FAR * FAR *lpppMessage,
                    LPADRLIST FAR *lppRecipList);

/* RemovePreprocessInfo, second ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE REMOVEPREPROCESSINFO)(LPMESSAGE lpMessage);

/* Function pointer for GetReleaseInfo */

#define MAPI_IMAPISUPPORT_METHODS1(IPURE)                               \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetMemAllocRoutines)                                     \
        (THIS_  LPALLOCATEBUFFER FAR *      lpAllocateBuffer,           \
                LPALLOCATEMORE FAR *        lpAllocateMore,             \
                LPFREEBUFFER FAR *          lpFreeBuffer) IPURE;        \
    MAPIMETHOD(Subscribe)                                               \
        (THIS_  LPNOTIFKEY                  lpKey,                      \
                ULONG                       ulEventMask,                \
                ULONG                       ulFlags,                    \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unsubscribe)                                             \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(Notify)                                                  \
        (THIS_  LPNOTIFKEY                  lpKey,                      \
                ULONG                       cNotification,              \
                LPNOTIFICATION              lpNotifications,            \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(ModifyStatusRow)                                         \
        (THIS_  ULONG                       cValues,                    \
                LPSPropValue                lpColumnVals,               \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUid,                      \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfileObj) IPURE;       \
    MAPIMETHOD(RegisterPreprocessor)                                    \
        (THIS_  LPMAPIUID                   lpMuid,                     \
                LPTSTR                      lpszAdrType,                \
                LPTSTR                      lpszDLLName,                \
                LPSTR   /* String8! */      lpszPreprocess,             \
                LPSTR   /* String8! */      lpszRemovePreprocessInfo,   \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(NewUID)                                                  \
        (THIS_  LPMAPIUID                   lpMuid) IPURE;              \
    MAPIMETHOD(MakeInvalid)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPVOID                      lpObject,                   \
                ULONG                       ulRefCount,                 \
                ULONG                       cMethods) IPURE;            \

#define MAPI_IMAPISUPPORT_METHODS2(IPURE)                               \
    MAPIMETHOD(SpoolerYield)                                            \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SpoolerNotify)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPVOID                      lpvData) IPURE;             \
    MAPIMETHOD(CreateOneOff)                                            \
        (THIS_  LPTSTR                      lpszName,                   \
                LPTSTR                      lpszAdrType,                \
                LPTSTR                      lpszAddress,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(SetProviderUID)                                          \
        (THIS_  LPMAPIUID                   lpProviderID,               \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntry1,                   \
                LPENTRYID                   lpEntry1,                   \
                ULONG                       cbEntry2,                   \
                LPENTRYID                   lpEntry2,                   \
                ULONG                       ulCompareFlags,             \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(OpenTemplateID)                                          \
        (THIS_  ULONG                       cbTemplateID,               \
                LPENTRYID                   lpTemplateID,               \
                ULONG                       ulTemplateFlags,            \
                LPMAPIPROP                  lpMAPIPropData,             \
                LPCIID                      lpInterface,                \
                LPMAPIPROP FAR *            lppMAPIPropNew,             \
                LPMAPIPROP                  lpMAPIPropSibling) IPURE;   \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulOpenFlags,                \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(GetOneOffTable)                                          \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(Address)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPADRPARM                   lpAdrParms,                 \
                LPADRLIST FAR *             lppAdrList) IPURE;          \
    MAPIMETHOD(Details)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPFNDISMISS                 lpfnDismiss,                \
                LPVOID                      lpvDismissContext,          \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPFNBUTTON                  lpfButtonCallback,          \
                LPVOID                      lpvButtonContext,           \
                LPTSTR                      lpszButtonText,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(NewEntry)                                                \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       cbEIDContainer,             \
                LPENTRYID                   lpEIDContainer,             \
                ULONG                       cbEIDNewEntryTpl,           \
                LPENTRYID                   lpEIDNewEntryTpl,           \
                ULONG FAR *                 lpcbEIDNewEntry,            \
                LPENTRYID FAR *             lppEIDNewEntry) IPURE;      \
    MAPIMETHOD(DoConfigPropsheet)                                       \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszTitle,                  \
                LPMAPITABLE                 lpDisplayTable,             \
                LPMAPIPROP                  lpCOnfigData,               \
                ULONG                       ulTopPage) IPURE;           \
    MAPIMETHOD(CopyMessages)                                            \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcFolder,                \
                LPENTRYLIST                 lpMsgList,                  \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestFolder,               \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CopyFolder)                                              \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcFolder,                \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestFolder,               \
                LPTSTR                      lszNewFolderName,           \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \

#define MAPI_IMAPISUPPORT_METHODS3(IPURE)                               \
    MAPIMETHOD(DoCopyTo)                                                \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcObj,                   \
                ULONG                       ciidExclude,                \
                LPCIID                      rgiidExclude,               \
                LPSPropTagArray             lpExcludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DoCopyProps)                                             \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcObj,                   \
                LPSPropTagArray             lpIncludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DoProgressDialog)                                        \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPMAPIPROGRESS FAR *        lppProgress) IPURE;         \
    MAPIMETHOD(ReadReceipt)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpReadMessage,              \
                LPMESSAGE FAR *             lppEmptyMessage) IPURE;     \
    MAPIMETHOD(PrepareSubmit)                                           \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(ExpandRecips)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(UpdatePAB)                                               \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage) IPURE;           \
    MAPIMETHOD(DoSentMail)                                              \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage) IPURE;           \
    MAPIMETHOD(OpenAddressBook)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPADRBOOK FAR *             lppAdrBook) IPURE;          \
    MAPIMETHOD(Preprocess)                                              \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(CompleteMsg)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(StoreLogoffTransports)                                   \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(StatusRecips)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                LPADRLIST                   lpRecipList) IPURE;         \
    MAPIMETHOD(WrapStoreEntryID)                                        \
        (THIS_  ULONG                       cbOrigEntry,                \
                LPENTRYID                   lpOrigEntry,                \
                ULONG FAR *                 lpcbWrappedEntry,           \
                LPENTRYID FAR *             lppWrappedEntry) IPURE;     \
    MAPIMETHOD(ModifyProfile)                                           \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(IStorageFromStream)                                      \
        (THIS_  LPUNKNOWN                   lpUnkIn,                    \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPSTORAGE FAR *             lppStorageOut) IPURE;       \
    MAPIMETHOD(GetSvcConfigSupportObj)                                  \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPISUP FAR *             lppSvcSupport) IPURE;       \

#undef       INTERFACE
#define      INTERFACE  IMAPISupport
DECLARE_MAPI_INTERFACE_(IMAPISupport, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPISUPPORT_METHODS1(PURE)
    MAPI_IMAPISUPPORT_METHODS2(PURE)
    MAPI_IMAPISUPPORT_METHODS3(PURE)
};


/********************************************************************/
/*                                                                  */
/*                          ADDRESS BOOK SPI                        */
/*                                                                  */
/********************************************************************/

/* Address Book Provider ------------------------------------------------- */

/* OpenTemplateID() */
#define FILL_ENTRY              ((ULONG) 0x00000001)

/* For Logon() */

/*#define AB_NO_DIALOG          ((ULONG) 0x00000001) in mapidefs.h */
/*#define MAPI_UNICODE          ((ULONG) 0x80000000) in mapidefs.h */



DECLARE_MAPI_INTERFACE_PTR(IABProvider, LPABPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IABLogon,    LPABLOGON);

#define MAPI_IABPROVIDER_METHODS(IPURE)                                 \
    MAPIMETHOD(Shutdown)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(Logon)                                                   \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulpcbSecurity,            \
                LPBYTE FAR *                lppbSecurity,               \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPABLOGON FAR *             lppABLogon) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABProvider
DECLARE_MAPI_INTERFACE_(IABProvider, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABPROVIDER_METHODS(PURE)
};

/* For GetOneOffTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IABLOGON_METHODS(IPURE)                                    \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Logoff)                                                  \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                       lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
    MAPIMETHOD(OpenTemplateID)                                          \
        (THIS_  ULONG                       cbTemplateID,               \
                LPENTRYID                   lpTemplateID,               \
                ULONG                       ulTemplateFlags,            \
                LPMAPIPROP                  lpMAPIPropData,             \
                LPCIID                       lpInterface,                \
                LPMAPIPROP FAR *            lppMAPIPropNew,             \
                LPMAPIPROP                  lpMAPIPropSibling) IPURE;   \
    MAPIMETHOD(GetOneOffTable)                                          \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(PrepareRecips)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray             lpPropTagArray,             \
                LPADRLIST                   lpRecipList) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IABLogon
DECLARE_MAPI_INTERFACE_(IABLogon, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABLOGON_METHODS(PURE)
};

typedef HRESULT (STDMAPIINITCALLTYPE ABPROVIDERINIT)(
    HINSTANCE           hInstance,
    LPMALLOC            lpMalloc,
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPALLOCATEMORE      lpAllocateMore,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    ULONG               ulMAPIVer,
    ULONG FAR *         lpulProviderVer,
    LPABPROVIDER FAR *  lppABProvider
);

ABPROVIDERINIT ABProviderInit;



/********************************************************************/
/*                                                                  */
/*                          TRANSPORT SPI                           */
/*                                                                  */
/********************************************************************/

/* For DeinitTransport */

#define DEINIT_NORMAL               ((ULONG) 0x00000001)
#define DEINIT_HURRY                ((ULONG) 0x80000000)

/* For TransportLogon */

/* Flags that the Spooler may pass to the transport: */

#define LOGON_NO_DIALOG             ((ULONG) 0x00000001)
#define LOGON_NO_CONNECT            ((ULONG) 0x00000004)
#define LOGON_NO_INBOUND            ((ULONG) 0x00000008)
#define LOGON_NO_OUTBOUND           ((ULONG) 0x00000010)
/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* Flags that the transport may pass to the Spooler: */

#define LOGON_SP_IDLE               ((ULONG) 0x00010000)
#define LOGON_SP_POLL               ((ULONG) 0x00020000)
#define LOGON_SP_RESOLVE            ((ULONG) 0x00040000)


DECLARE_MAPI_INTERFACE_PTR(IXPProvider, LPXPPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IXPLogon, LPXPLOGON);

#define MAPI_IXPPROVIDER_METHODS(IPURE)                                 \
    MAPIMETHOD(Shutdown)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(TransportLogon)                                          \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG FAR *                 lpulFlags,                  \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPXPLOGON FAR *             lppXPLogon) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IXPProvider
DECLARE_MAPI_INTERFACE_(IXPProvider, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IXPPROVIDER_METHODS(PURE)
};

/* OptionData returned from call to RegisterOptions */

#define OPTION_TYPE_RECIPIENT       ((ULONG) 0x00000001)
#define OPTION_TYPE_MESSAGE         ((ULONG) 0x00000002)

typedef struct _OPTIONDATA
{
    ULONG           ulFlags;        /* MAPI_RECIPIENT, MAPI_MESSAGE */
    LPGUID          lpRecipGUID;    /* Same as returned by AddressTypes() */
    LPTSTR          lpszAdrType;    /* Same as returned by AddressTypes() */
    LPTSTR          lpszDLLName;    /* Options DLL */
    ULONG           ulOrdinal;      /* Ordinal in that DLL */
    ULONG           cbOptionsData;  /* Count of bytes in lpbOptionsData */
    LPBYTE          lpbOptionsData; /* Providers per [recip|message] option data */
    ULONG           cOptionsProps;  /* Count of Options default prop values */
    LPSPropValue    lpOptionsProps; /* Default Options property values */
} OPTIONDATA, FAR *LPOPTIONDATA;

typedef SCODE (STDMAPIINITCALLTYPE OPTIONCALLBACK)(
            HINSTANCE           hInst,
            LPMALLOC            lpMalloc,
            ULONG               ulFlags,
            ULONG               cbOptionData,
            LPBYTE              lpbOptionData,
            LPMAPISUP           lpMAPISup,
            LPMAPIPROP          lpDataSource,
            LPMAPIPROP FAR *    lppWrappedSource,
            LPMAPIERROR FAR *   lppMAPIError);

/* For XP_AddressTypes */

/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterRecipOptions */

/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterMessageOptions */

/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* For TransportNotify */

#define NOTIFY_ABORT_DEFERRED       ((ULONG) 0x40000000)
#define NOTIFY_CANCEL_MESSAGE       ((ULONG) 0x80000000)
#define NOTIFY_BEGIN_INBOUND        ((ULONG) 0x00000001)
#define NOTIFY_END_INBOUND          ((ULONG) 0x00010000)
#define NOTIFY_BEGIN_OUTBOUND       ((ULONG) 0x00000002)
#define NOTIFY_END_OUTBOUND         ((ULONG) 0x00020000)
#define NOTIFY_BEGIN_INBOUND_FLUSH  ((ULONG) 0x00000004)
#define NOTIFY_END_INBOUND_FLUSH    ((ULONG) 0x00040000)
#define NOTIFY_BEGIN_OUTBOUND_FLUSH ((ULONG) 0x00000008)
#define NOTIFY_END_OUTBOUND_FLUSH   ((ULONG) 0x00080000)

/* For TransportLogoff */

#define LOGOFF_NORMAL               ((ULONG) 0x00000001)
#define LOGOFF_HURRY                ((ULONG) 0x80000000)

/* For SubmitMessage */

#define BEGIN_DEFERRED              ((ULONG) 0x00000001)

/* For EndMessage */

/* Flags that the Spooler may pass to the Transport: */

/* Flags that the transport may pass to the Spooler: */

#define END_RESEND_NOW              ((ULONG) 0x00010000)
#define END_RESEND_LATER            ((ULONG) 0x00020000)
#define END_DONT_RESEND             ((ULONG) 0x00040000)

#define MAPI_IXPLOGON_METHODS(IPURE)                                    \
    MAPIMETHOD(AddressTypes)                                            \
        (THIS_  ULONG FAR *                 lpulFlags,                  \
                ULONG FAR *                 lpcAdrType,                 \
                LPTSTR FAR * FAR *          lpppAdrTypeArray,           \
                ULONG FAR *                 lpcMAPIUID,                 \
                LPMAPIUID FAR * FAR *       lpppUIDArray) IPURE;        \
    MAPIMETHOD(RegisterOptions)                                         \
        (THIS_  ULONG FAR *                 lpulFlags,                  \
                ULONG FAR *                 lpcOptions,                 \
                LPOPTIONDATA FAR *          lppOptions) IPURE;          \
    MAPIMETHOD(TransportNotify)                                         \
        (THIS_  ULONG FAR *                 lpulFlags,                  \
                LPVOID FAR *                lppvData) IPURE;            \
    MAPIMETHOD(Idle)                                                    \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(TransportLogoff)                                         \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SubmitMessage)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulMsgRef,                 \
                ULONG FAR *                 lpulReturnParm) IPURE;      \
    MAPIMETHOD(EndMessage)                                              \
        (THIS_  ULONG                       ulMsgRef,                   \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(Poll)                                                    \
        (THIS_  ULONG FAR *                 lpulIncoming) IPURE;        \
    MAPIMETHOD(StartMessage)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulMsgRef) IPURE;          \
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
    MAPIMETHOD(ValidateState)                                           \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(FlushQueues)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbTargetTransport,          \
                LPENTRYID                   lpTargetTransport,          \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IXPLogon
DECLARE_MAPI_INTERFACE_(IXPLogon, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IXPLOGON_METHODS(PURE)
};


/* Transport Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE XPPROVIDERINIT)(
    HINSTANCE           hInstance,
    LPMALLOC            lpMalloc,
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPALLOCATEMORE      lpAllocateMore,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    ULONG               ulMAPIVer,
    ULONG FAR *         lpulProviderVer,
    LPXPPROVIDER FAR *  lppXPProvider);

XPPROVIDERINIT XPProviderInit;

/********************************************************************/
/*                                                                  */
/*                          MESSAGE STORE SPI                       */
/*                                                                  */
/********************************************************************/

/* Flags and enums */

/* For Logon() */

/*#define MAPI_UNICODE          ((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG         ((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE             ((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) in mapidefs.h */
/*#define MDB_TEMPORARY         ((ULONG) 0x00000020) in mapidefs.h */
/*#define MDB_NO_MAIL           ((ULONG) 0x00000080) in mapidefs.h */

/* For SpoolerLogon() */

/*#define MAPI_UNICODE          ((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG         ((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE             ((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) in mapidefs.h */

/* GetCredentials, SetCredentials */

#define LOGON_SP_TRANSPORT      ((ULONG) 0x00000001)
#define LOGON_SP_PROMPT         ((ULONG) 0x00000002)
#define LOGON_SP_NEWPW          ((ULONG) 0x00000004)
#define LOGON_CHANGED           ((ULONG) 0x00000008)

/* CopyMessages */

#define MESSAGE_NOMARK          ((ULONG) 0x00000008)

/* DoMCDialog */

#define DIALOG_FOLDER           ((ULONG) 0x00000001)
#define DIALOG_MESSAGE          ((ULONG) 0x00000002)
#define DIALOG_PROP             ((ULONG) 0x00000004)
#define DIALOG_ATTACH           ((ULONG) 0x00000008)

#define DIALOG_MOVE             ((ULONG) 0x00000010)
#define DIALOG_COPY             ((ULONG) 0x00000020)
#define DIALOG_DELETE           ((ULONG) 0x00000040)

#define DIALOG_ALLOW_CANCEL     ((ULONG) 0x00000080)
#define DIALOG_CONFIRM_CANCEL   ((ULONG) 0x00000100)

/* ExpandRecips */

#define NEEDS_PREPROCESSING     ((ULONG) 0x00000001)

/* PrepareSubmit */

#define CHECK_SENDER            ((ULONG) 0x00000001)
#define NON_STANDARD            ((ULONG) 0x00010000)


DECLARE_MAPI_INTERFACE_PTR(IMSLogon, LPMSLOGON);
DECLARE_MAPI_INTERFACE_PTR(IMSProvider, LPMSPROVIDER);

/* Message Store Provider Interface (IMSPROVIDER) */

#define MAPI_IMSPROVIDER_METHODS(IPURE)                                 \
    MAPIMETHOD(Shutdown)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(Logon)                                                   \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                LPCIID                      lpInterface,                \
                ULONG FAR *                 lpcbSpoolSecurity,          \
                LPBYTE FAR *                lppbSpoolSecurity,          \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPMSLOGON FAR *             lppMSLogon,                 \
                LPMDB FAR *                 lppMDB) IPURE;              \
    MAPIMETHOD(SpoolerLogon)                                            \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                LPCIID                      lpInterface,                \
                ULONG                       cbSpoolSecurity,            \
                LPBYTE                      lpbSpoolSecurity,           \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPMSLOGON FAR *             lppMSLogon,                 \
                LPMDB FAR *                 lppMDB) IPURE;              \
    MAPIMETHOD(CompareStoreIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IMSProvider
DECLARE_MAPI_INTERFACE_(IMSProvider, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMSPROVIDER_METHODS(PURE)
};

/* The MSLOGON object is returned by the Logon() method of the
 * MSPROVIDER interface.  This object is for use by MAPIX.DLL.
 */
#define MAPI_IMSLOGON_METHODS(IPURE)                                    \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Logoff)                                                  \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPVOID FAR *                lppEntry) IPURE;            \

#undef       INTERFACE
#define      INTERFACE  IMSLogon
DECLARE_MAPI_INTERFACE_(IMSLogon, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMSLOGON_METHODS(PURE)
};

/* Message Store Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE MSPROVIDERINIT)(
    HINSTANCE               hInstance,
    LPMALLOC                lpMalloc,           /* AddRef() if you keep it */
    LPALLOCATEBUFFER        lpAllocateBuffer,   /* -> AllocateBuffer */
    LPALLOCATEMORE          lpAllocateMore,     /* -> AllocateMore   */
    LPFREEBUFFER            lpFreeBuffer,       /* -> FreeBuffer     */
    ULONG                   ulFlags,
    ULONG                   ulMAPIVer,
    ULONG FAR *             lpulProviderVer,
    LPMSPROVIDER FAR *      lppMSProvider
);

MSPROVIDERINIT MSProviderInit;


/********************************************************************/
/*                                                                  */
/*                    MESSAGE SERVICE CONFIGURATION                 */
/*                                                                  */
/********************************************************************/

/* Flags for service configuration entry point */

/* #define UI_SERVICE                0x00000002 */
/* #define UI_CURRENT_PROVIDER_FIRST 0x00000004 */
#define MSG_SERVICE_UI_READ_ONLY     0x00000008 /* display parameters only */

/* Contexts for service configuration entry point */

#define MSG_SERVICE_INSTALL         0x00000001
#define MSG_SERVICE_CREATE          0x00000002
#define MSG_SERVICE_CONFIGURE       0x00000003
#define MSG_SERVICE_DELETE          0x00000004
#define MSG_SERVICE_UNINSTALL       0x00000005
#define MSG_SERVICE_PROVIDER_CREATE 0x00000006
#define MSG_SERVICE_PROVIDER_DELETE 0x00000007

/* Prototype for service configuration entry point */

typedef HRESULT (STDAPICALLTYPE MSGSERVICEENTRY)(
    HINSTANCE       hInstance,
    LPMALLOC        lpMalloc,
    LPMAPISUP       lpMAPISup,
    ULONG           ulUIParam,
    ULONG           ulFlags,
    ULONG           ulContext,
    ULONG           cValues,
    LPSPropValue    lpProps,
    LPPROVIDERADMIN lpProviderAdmin,
    LPMAPIERROR FAR *lppMapiError
);
typedef MSGSERVICEENTRY FAR *LPMSGSERVICEENTRY;


#ifdef __cplusplus
}
#endif

#endif /* MAPISPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mapitags.h ===
/*
 *  M A P I T A G S . H
 *
 *  Property tag definitions for standard properties of MAPI
 *  objects.
 *
 *  The following ranges should be used for all property IDs. Note that
 *  property IDs for objects other than messages and recipients should
 *  all fall in the range 0x3000 to 0x3FFF:
 *
 *  From    To      Kind of property
--------------------------------
 *  0001    0BFF    MAPI_defined envelope property
 *  0C00    0DFF    MAPI_defined per-recipient property
 *  0E00    0FFF    MAPI_defined non-transmittable property
 *  1000    2FFF    MAPI_defined message content property
 *
 *  3000    3FFF    MAPI_defined property (usually not message or recipient)
 *
 *  4000    57FF    Transport-defined envelope property
 *  5800    5FFF    Transport-defined per-recipient property
 *  6000    65FF    User-defined non-transmittable property
 *  6600    67FF    Provider-defined internal non-transmittable property
 *  6800    7BFF    Message class-defined content property
 *  7C00    7FFF    Message class-defined non-transmittable
 *                  property
 *
 *  8000    FFFE    User-defined Name-to-id mapped property
 *
 *  The 3000-3FFF range is further subdivided as follows:
 *
 *  From    To      Kind of property
--------------------------------
 *  3000    33FF    Common property such as display name, entry ID
 *  3400    35FF    Message store object
 *  3600    36FF    Folder or AB container
 *  3700    38FF    Attachment
 *  3900    39FF    Address book object
 *  3A00    3BFF    Mail user
 *  3C00    3CFF    Distribution list
 *  3D00    3DFF    Profile section
 *  3E00    3FFF    Status object
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPITAGS_H
#define MAPITAGS_H

/* Determine if a property is transmittable. */

#define FIsTransmittable(ulPropTag) \
    ((PROP_ID (ulPropTag) <  (ULONG)0x0E00) || \
    (PROP_ID (ulPropTag)  >= (ULONG)0x8000) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x1000) && (PROP_ID (ulPropTag) < (ULONG)0x6000)) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x6800) && (PROP_ID (ulPropTag) < (ULONG)0x7C00)))

/*
 *  Message envelope properties
 */

#define PR_ACKNOWLEDGEMENT_MODE                     PROP_TAG( PT_LONG,      0x0001)
#define PR_ALTERNATE_RECIPIENT_ALLOWED              PROP_TAG( PT_BOOLEAN,   0x0002)
#define PR_AUTHORIZING_USERS                        PROP_TAG( PT_BINARY,    0x0003)
#define PR_AUTO_FORWARD_COMMENT                     PROP_TAG( PT_TSTRING,   0x0004)
#define PR_AUTO_FORWARD_COMMENT_W                   PROP_TAG( PT_UNICODE,   0x0004)
#define PR_AUTO_FORWARD_COMMENT_A                   PROP_TAG( PT_STRING8,   0x0004)
#define PR_AUTO_FORWARDED                           PROP_TAG( PT_BOOLEAN,   0x0005)
#define PR_CONTENT_CONFIDENTIALITY_ALGORITHM_ID     PROP_TAG( PT_BINARY,    0x0006)
#define PR_CONTENT_CORRELATOR                       PROP_TAG( PT_BINARY,    0x0007)
#define PR_CONTENT_IDENTIFIER                       PROP_TAG( PT_TSTRING,   0x0008)
#define PR_CONTENT_IDENTIFIER_W                     PROP_TAG( PT_UNICODE,   0x0008)
#define PR_CONTENT_IDENTIFIER_A                     PROP_TAG( PT_STRING8,   0x0008)
#define PR_CONTENT_LENGTH                           PROP_TAG( PT_LONG,      0x0009)
#define PR_CONTENT_RETURN_REQUESTED                 PROP_TAG( PT_BOOLEAN,   0x000A)



#define PR_CONVERSATION_KEY                         PROP_TAG( PT_BINARY,    0x000B)

#define PR_CONVERSION_EITS                          PROP_TAG( PT_BINARY,    0x000C)
#define PR_CONVERSION_WITH_LOSS_PROHIBITED          PROP_TAG( PT_BOOLEAN,   0x000D)
#define PR_CONVERTED_EITS                           PROP_TAG( PT_BINARY,    0x000E)
#define PR_DEFERRED_DELIVERY_TIME                   PROP_TAG( PT_SYSTIME,   0x000F)
#define PR_DELIVER_TIME                             PROP_TAG( PT_SYSTIME,   0x0010)
#define PR_DISCARD_REASON                           PROP_TAG( PT_LONG,      0x0011)
#define PR_DISCLOSURE_OF_RECIPIENTS                 PROP_TAG( PT_BOOLEAN,   0x0012)
#define PR_DL_EXPANSION_HISTORY                     PROP_TAG( PT_BINARY,    0x0013)
#define PR_DL_EXPANSION_PROHIBITED                  PROP_TAG( PT_BOOLEAN,   0x0014)
#define PR_EXPIRY_TIME                              PROP_TAG( PT_SYSTIME,   0x0015)
#define PR_IMPLICIT_CONVERSION_PROHIBITED           PROP_TAG( PT_BOOLEAN,   0x0016)
#define PR_IMPORTANCE                               PROP_TAG( PT_LONG,      0x0017)
#define PR_IPM_ID                                   PROP_TAG( PT_BINARY,    0x0018)
#define PR_LATEST_DELIVERY_TIME                     PROP_TAG( PT_SYSTIME,   0x0019)
#define PR_MESSAGE_CLASS                            PROP_TAG( PT_TSTRING,   0x001A)
#define PR_MESSAGE_CLASS_W                          PROP_TAG( PT_UNICODE,   0x001A)
#define PR_MESSAGE_CLASS_A                          PROP_TAG( PT_STRING8,   0x001A)
#define PR_MESSAGE_DELIVERY_ID                      PROP_TAG( PT_BINARY,    0x001B)





#define PR_MESSAGE_SECURITY_LABEL                   PROP_TAG( PT_BINARY,    0x001E)
#define PR_OBSOLETED_IPMS                           PROP_TAG( PT_BINARY,    0x001F)
#define PR_ORIGINALLY_INTENDED_RECIPIENT_NAME       PROP_TAG( PT_BINARY,    0x0020)
#define PR_ORIGINAL_EITS                            PROP_TAG( PT_BINARY,    0x0021)
#define PR_ORIGINATOR_CERTIFICATE                   PROP_TAG( PT_BINARY,    0x0022)
#define PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED     PROP_TAG( PT_BOOLEAN,   0x0023)
#define PR_ORIGINATOR_RETURN_ADDRESS                PROP_TAG( PT_BINARY,    0x0024)



#define PR_PARENT_KEY                               PROP_TAG( PT_BINARY,    0x0025)
#define PR_PRIORITY                                 PROP_TAG( PT_LONG,      0x0026)



#define PR_ORIGIN_CHECK                             PROP_TAG( PT_BINARY,    0x0027)
#define PR_PROOF_OF_SUBMISSION_REQUESTED            PROP_TAG( PT_BOOLEAN,   0x0028)
#define PR_READ_RECEIPT_REQUESTED                   PROP_TAG( PT_BOOLEAN,   0x0029)
#define PR_RECEIPT_TIME                             PROP_TAG( PT_SYSTIME,   0x002A)
#define PR_RECIPIENT_REASSIGNMENT_PROHIBITED        PROP_TAG( PT_BOOLEAN,   0x002B)
#define PR_REDIRECTION_HISTORY                      PROP_TAG( PT_BINARY,    0x002C)
#define PR_RELATED_IPMS                             PROP_TAG( PT_BINARY,    0x002D)

#define PR_LANGUAGES                                PROP_TAG( PT_TSTRING,   0x002F)
#define PR_LANGUAGES_W                              PROP_TAG( PT_UNICODE,   0x002F)
#define PR_LANGUAGES_A                              PROP_TAG( PT_STRING8,   0x002F)
#define PR_REPLY_TIME                               PROP_TAG( PT_SYSTIME,   0x0030)
#define PR_REPORT_TAG                               PROP_TAG( PT_BINARY,    0x0031)
#define PR_REPORT_TIME                              PROP_TAG( PT_SYSTIME,   0x0032)
#define PR_RETURNED_IPM                             PROP_TAG( PT_BOOLEAN,   0x0033)
#define PR_SECURITY                                 PROP_TAG( PT_LONG,      0x0034)
#define PR_INCOMPLETE_COPY                          PROP_TAG( PT_BOOLEAN,   0x0035)
#define PR_SENSITIVITY                              PROP_TAG( PT_LONG,      0x0036)
#define PR_SUBJECT                                  PROP_TAG( PT_TSTRING,   0x0037)
#define PR_SUBJECT_W                                PROP_TAG( PT_UNICODE,   0x0037)
#define PR_SUBJECT_A                                PROP_TAG( PT_STRING8,   0x0037)
#define PR_SUBJECT_IPM                              PROP_TAG( PT_BINARY,    0x0038)
#define PR_CLIENT_SUBMIT_TIME                       PROP_TAG( PT_SYSTIME,   0x0039)
#define PR_REPORT_NAME                              PROP_TAG( PT_TSTRING,   0x003A)
#define PR_REPORT_NAME_W                            PROP_TAG( PT_UNICODE,   0x003A)
#define PR_REPORT_NAME_A                            PROP_TAG( PT_STRING8,   0x003A)
#define PR_SENT_REPRESENTING_SEARCH_KEY             PROP_TAG( PT_BINARY,    0x003B)
#define PR_X400_CONTENT_TYPE                        PROP_TAG( PT_BINARY,    0x003C)
#define PR_NON_RECEIPT_REASON                       PROP_TAG( PT_LONG,      0x003E)
#define PR_RECEIVED_BY_ENTRYID                      PROP_TAG( PT_BINARY,    0x003F)
#define PR_RECEIVED_BY_NAME                         PROP_TAG( PT_TSTRING,   0x0040)
#define PR_RECEIVED_BY_NAME_W                       PROP_TAG( PT_UNICODE,   0x0040)
#define PR_RECEIVED_BY_NAME_A                       PROP_TAG( PT_STRING8,   0x0040)
#define PR_SENT_REPRESENTING_ENTRYID                PROP_TAG( PT_BINARY,    0x0041)
#define PR_SENT_REPRESENTING_NAME                   PROP_TAG( PT_TSTRING,   0x0042)
#define PR_SENT_REPRESENTING_NAME_W                 PROP_TAG( PT_UNICODE,   0x0042)
#define PR_SENT_REPRESENTING_NAME_A                 PROP_TAG( PT_STRING8,   0x0042)
#define PR_RCVD_REPRESENTING_ENTRYID                PROP_TAG( PT_BINARY,    0x0043)
#define PR_RCVD_REPRESENTING_NAME                   PROP_TAG( PT_TSTRING,   0x0044)
#define PR_RCVD_REPRESENTING_NAME_W                 PROP_TAG( PT_UNICODE,   0x0044)
#define PR_RCVD_REPRESENTING_NAME_A                 PROP_TAG( PT_STRING8,   0x0044)
#define PR_REPORT_ENTRYID                           PROP_TAG( PT_BINARY,    0x0045)
#define PR_READ_RECEIPT_ENTRYID                     PROP_TAG( PT_BINARY,    0x0046)
#define PR_MESSAGE_SUBMISSION_ID                    PROP_TAG( PT_BINARY,    0x0047)
#define PR_PROVIDER_SUBMIT_TIME                     PROP_TAG( PT_SYSTIME,   0x0048)
#define PR_ORIGINAL_SUBJECT                         PROP_TAG( PT_TSTRING,   0x0049)
#define PR_ORIGINAL_SUBJECT_W                       PROP_TAG( PT_UNICODE,   0x0049)
#define PR_ORIGINAL_SUBJECT_A                       PROP_TAG( PT_STRING8,   0x0049)
#define PR_DISC_VAL                                 PROP_TAG( PT_BOOLEAN,   0x004A)
#define PR_ORIG_MESSAGE_CLASS                       PROP_TAG( PT_TSTRING,   0x004B)
#define PR_ORIG_MESSAGE_CLASS_W                     PROP_TAG( PT_UNICODE,   0x004B)
#define PR_ORIG_MESSAGE_CLASS_A                     PROP_TAG( PT_STRING8,   0x004B)
#define PR_ORIGINAL_AUTHOR_ENTRYID                  PROP_TAG( PT_BINARY,    0x004C)
#define PR_ORIGINAL_AUTHOR_NAME                     PROP_TAG( PT_TSTRING,   0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_W                   PROP_TAG( PT_UNICODE,   0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_A                   PROP_TAG( PT_STRING8,   0x004D)
#define PR_ORIGINAL_SUBMIT_TIME                     PROP_TAG( PT_SYSTIME,   0x004E)
#define PR_REPLY_RECIPIENT_ENTRIES                  PROP_TAG( PT_BINARY,    0x004F)
#define PR_REPLY_RECIPIENT_NAMES                    PROP_TAG( PT_TSTRING,   0x0050)
#define PR_REPLY_RECIPIENT_NAMES_W                  PROP_TAG( PT_UNICODE,   0x0050)
#define PR_REPLY_RECIPIENT_NAMES_A                  PROP_TAG( PT_STRING8,   0x0050)

#define PR_RECEIVED_BY_SEARCH_KEY                   PROP_TAG( PT_BINARY,    0x0051)
#define PR_RCVD_REPRESENTING_SEARCH_KEY             PROP_TAG( PT_BINARY,    0x0052)
#define PR_READ_RECEIPT_SEARCH_KEY                  PROP_TAG( PT_BINARY,    0x0053)
#define PR_REPORT_SEARCH_KEY                        PROP_TAG( PT_BINARY,    0x0054)
#define PR_ORIGINAL_DELIVERY_TIME                   PROP_TAG( PT_SYSTIME,   0x0055)
#define PR_ORIGINAL_AUTHOR_SEARCH_KEY               PROP_TAG( PT_BINARY,    0x0056)

#define PR_MESSAGE_TO_ME                            PROP_TAG( PT_BOOLEAN,   0x0057)
#define PR_MESSAGE_CC_ME                            PROP_TAG( PT_BOOLEAN,   0x0058)
#define PR_MESSAGE_RECIP_ME                         PROP_TAG( PT_BOOLEAN,   0x0059)

#define PR_ORIGINAL_SENDER_NAME                     PROP_TAG( PT_TSTRING,   0x005A)
#define PR_ORIGINAL_SENDER_NAME_W                   PROP_TAG( PT_UNICODE,   0x005A)
#define PR_ORIGINAL_SENDER_NAME_A                   PROP_TAG( PT_STRING8,   0x005A)
#define PR_ORIGINAL_SENDER_ENTRYID                  PROP_TAG( PT_BINARY,    0x005B)
#define PR_ORIGINAL_SENDER_SEARCH_KEY               PROP_TAG( PT_BINARY,    0x005C)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME          PROP_TAG( PT_TSTRING,   0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_W        PROP_TAG( PT_UNICODE,   0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_A        PROP_TAG( PT_STRING8,   0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_ENTRYID       PROP_TAG( PT_BINARY,    0x005E)
#define PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY    PROP_TAG( PT_BINARY,    0x005F)

#define PR_START_DATE                               PROP_TAG( PT_SYSTIME,   0x0060)
#define PR_END_DATE                                 PROP_TAG( PT_SYSTIME,   0x0061)
#define PR_OWNER_APPT_ID                            PROP_TAG( PT_LONG,      0x0062)
#define PR_RESPONSE_REQUESTED                       PROP_TAG( PT_BOOLEAN,   0x0063)

#define PR_SENT_REPRESENTING_ADDRTYPE               PROP_TAG( PT_TSTRING,   0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_W             PROP_TAG( PT_UNICODE,   0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_A             PROP_TAG( PT_STRING8,   0x0064)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS          PROP_TAG( PT_TSTRING,   0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_W        PROP_TAG( PT_UNICODE,   0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_A        PROP_TAG( PT_STRING8,   0x0065)

#define PR_ORIGINAL_SENDER_ADDRTYPE                 PROP_TAG( PT_TSTRING,   0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_W               PROP_TAG( PT_UNICODE,   0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_A               PROP_TAG( PT_STRING8,   0x0066)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS            PROP_TAG( PT_TSTRING,   0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_W          PROP_TAG( PT_UNICODE,   0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_A          PROP_TAG( PT_STRING8,   0x0067)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE      PROP_TAG( PT_TSTRING,   0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_W    PROP_TAG( PT_UNICODE,   0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_A    PROP_TAG( PT_STRING8,   0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS PROP_TAG( PT_TSTRING,   0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_W   PROP_TAG( PT_UNICODE,   0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_A   PROP_TAG( PT_STRING8,   0x0069)

#define PR_CONVERSATION_TOPIC                       PROP_TAG( PT_TSTRING,   0x0070)
#define PR_CONVERSATION_TOPIC_W                     PROP_TAG( PT_UNICODE,   0x0070)
#define PR_CONVERSATION_TOPIC_A                     PROP_TAG( PT_STRING8,   0x0070)
#define PR_CONVERSATION_INDEX                       PROP_TAG( PT_BINARY,    0x0071)


/*
 *  Message content properties
 */

#define PR_BODY                                     PROP_TAG( PT_TSTRING,   0x1000)
#define PR_BODY_W                                   PROP_TAG( PT_UNICODE,   0x1000)
#define PR_BODY_A                                   PROP_TAG( PT_STRING8,   0x1000)
#define PR_REPORT_TEXT                              PROP_TAG( PT_TSTRING,   0x1001)
#define PR_REPORT_TEXT_W                            PROP_TAG( PT_UNICODE,   0x1001)
#define PR_REPORT_TEXT_A                            PROP_TAG( PT_STRING8,   0x1001)
#define PR_ORIGINATOR_AND_DL_EXPANSION_HISTORY      PROP_TAG( PT_BINARY,    0x1002)
#define PR_REPORTING_DL_NAME                        PROP_TAG( PT_BINARY,    0x1003)
#define PR_REPORTING_MTA_CERTIFICATE                PROP_TAG( PT_BINARY,    0x1004)

/*  Removed PR_REPORT_ORIGIN_AUTHENTICATION_CHECK with DCR 3865, use PR_ORIGIN_CHECK */

#define PR_RTF_SYNC_BODY_CRC                        PROP_TAG( PT_LONG,      0x1006)
#define PR_RTF_SYNC_BODY_COUNT                      PROP_TAG( PT_LONG,      0x1007)
#define PR_RTF_SYNC_BODY_TAG                        PROP_TAG( PT_TSTRING,   0x1008)
#define PR_RTF_SYNC_BODY_TAG_W                      PROP_TAG( PT_UNICODE,   0x1008)
#define PR_RTF_SYNC_BODY_TAG_A                      PROP_TAG( PT_STRING8,   0x1008)
#define PR_RTF_COMPRESSED                           PROP_TAG( PT_BINARY,    0x1009)
#define PR_RTF_SYNC_PREFIX_COUNT                    PROP_TAG( PT_LONG,      0x1010)
#define PR_RTF_SYNC_TRAILING_COUNT                  PROP_TAG( PT_LONG,      0x1011)
#define PR_ORIGINALLY_INTENDED_RECIP_ENTRYID        PROP_TAG( PT_BINARY,    0x1012)
#define PR_PREPROCESS                               PROP_TAG( PT_BINARY,    0x1013)

/*
 *  Message recipient properties
 */

#define PR_CONTENT_INTEGRITY_CHECK                  PROP_TAG( PT_BINARY,    0x0C00)
#define PR_EXPLICIT_CONVERSION                      PROP_TAG( PT_LONG,      0x0C01)
#define PR_IPM_RETURN_REQUESTED                     PROP_TAG( PT_BOOLEAN,   0x0C02)
#define PR_MESSAGE_TOKEN                            PROP_TAG( PT_BINARY,    0x0C03)
#define PR_NDR_REASON_CODE                          PROP_TAG( PT_LONG,      0x0C04)
#define PR_NDR_DIAG_CODE                            PROP_TAG( PT_LONG,      0x0C05)
#define PR_NON_RECEIPT_NOTIFICATION_REQUESTED       PROP_TAG( PT_BOOLEAN,   0x0C06)

#define PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED PROP_TAG( PT_BOOLEAN,   0x0C08)
#define PR_ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT PROP_TAG( PT_BINARY,    0x0C09)
#define PR_PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY    PROP_TAG( PT_BOOLEAN,   0x0C0A)
#define PR_PHYSICAL_DELIVERY_MODE                   PROP_TAG( PT_LONG,      0x0C0B)
#define PR_PHYSICAL_DELIVERY_REPORT_REQUEST         PROP_TAG( PT_LONG,      0x0C0C)
#define PR_PHYSICAL_FORWARDING_ADDRESS              PROP_TAG( PT_BINARY,    0x0C0D)
#define PR_PHYSICAL_FORWARDING_ADDRESS_REQUESTED    PROP_TAG( PT_BOOLEAN,   0x0C0E)
#define PR_PHYSICAL_FORWARDING_PROHIBITED           PROP_TAG( PT_BOOLEAN,   0x0C0F)
#define PR_PHYSICAL_RENDITION_ATTRIBUTES            PROP_TAG( PT_BINARY,    0x0C10)
#define PR_PROOF_OF_DELIVERY                        PROP_TAG( PT_BINARY,    0x0C11)
#define PR_PROOF_OF_DELIVERY_REQUESTED              PROP_TAG( PT_BOOLEAN,   0x0C12)
#define PR_RECIPIENT_CERTIFICATE                    PROP_TAG( PT_BINARY,    0x0C13)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE              PROP_TAG( PT_TSTRING,   0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_W            PROP_TAG( PT_UNICODE,   0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_A            PROP_TAG( PT_STRING8,   0x0C14)
#define PR_RECIPIENT_TYPE                           PROP_TAG( PT_LONG,      0x0C15)
#define PR_REGISTERED_MAIL_TYPE                     PROP_TAG( PT_LONG,      0x0C16)
#define PR_REPLY_REQUESTED                          PROP_TAG( PT_BOOLEAN,   0x0C17)
#define PR_REQUESTED_DELIVERY_METHOD                PROP_TAG( PT_LONG,      0x0C18)
#define PR_SENDER_ENTRYID                           PROP_TAG( PT_BINARY,    0x0C19)
#define PR_SENDER_NAME                              PROP_TAG( PT_TSTRING,   0x0C1A)
#define PR_SENDER_NAME_W                            PROP_TAG( PT_UNICODE,   0x0C1A)
#define PR_SENDER_NAME_A                            PROP_TAG( PT_STRING8,   0x0C1A)
#define PR_SUPPLEMENTARY_INFO                       PROP_TAG( PT_TSTRING,   0x0C1B)
#define PR_SUPPLEMENTARY_INFO_W                     PROP_TAG( PT_UNICODE,   0x0C1B)
#define PR_SUPPLEMENTARY_INFO_A                     PROP_TAG( PT_STRING8,   0x0C1B)
#define PR_TYPE_OF_MTS_USER                         PROP_TAG( PT_LONG,      0x0C1C)
#define PR_SENDER_SEARCH_KEY                        PROP_TAG( PT_BINARY,    0x0C1D)
#define PR_SENDER_ADDRTYPE                          PROP_TAG( PT_TSTRING,   0x0C1E)
#define PR_SENDER_ADDRTYPE_W                        PROP_TAG( PT_UNICODE,   0x0C1E)
#define PR_SENDER_ADDRTYPE_A                        PROP_TAG( PT_STRING8,   0x0C1E)
#define PR_SENDER_EMAIL_ADDRESS                     PROP_TAG( PT_TSTRING,   0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_W                   PROP_TAG( PT_UNICODE,   0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_A                   PROP_TAG( PT_STRING8,   0x0C1F)

/*
 *  Message non-transmittable properties
 */

/*
 * The two tags, PR_MESSAGE_RECIPIENTS and PR_MESSAGE_ATTACHMENTS,
 * are to be used in the exclude list passed to
 * IMessage::CopyTo when the caller wants either the recipients or attachments
 * of the message to not get copied.  It is also used in the ProblemArray
 * return from IMessage::CopyTo when an error is encountered copying them
 */

#define PR_CURRENT_VERSION                          PROP_TAG( PT_I8,        0x0E00)
#define PR_DELETE_AFTER_SUBMIT                      PROP_TAG( PT_BOOLEAN,   0x0E01)
#define PR_DISPLAY_BCC                              PROP_TAG( PT_TSTRING,   0x0E02)
#define PR_DISPLAY_BCC_W                            PROP_TAG( PT_UNICODE,   0x0E02)
#define PR_DISPLAY_BCC_A                            PROP_TAG( PT_STRING8,   0x0E02)
#define PR_DISPLAY_CC                               PROP_TAG( PT_TSTRING,   0x0E03)
#define PR_DISPLAY_CC_W                             PROP_TAG( PT_UNICODE,   0x0E03)
#define PR_DISPLAY_CC_A                             PROP_TAG( PT_STRING8,   0x0E03)
#define PR_DISPLAY_TO                               PROP_TAG( PT_TSTRING,   0x0E04)
#define PR_DISPLAY_TO_W                             PROP_TAG( PT_UNICODE,   0x0E04)
#define PR_DISPLAY_TO_A                             PROP_TAG( PT_STRING8,   0x0E04)
#define PR_PARENT_DISPLAY                           PROP_TAG( PT_TSTRING,   0x0E05)
#define PR_PARENT_DISPLAY_W                         PROP_TAG( PT_UNICODE,   0x0E05)
#define PR_PARENT_DISPLAY_A                         PROP_TAG( PT_STRING8,   0x0E05)
#define PR_MESSAGE_DELIVERY_TIME                    PROP_TAG( PT_SYSTIME,   0x0E06)
#define PR_MESSAGE_FLAGS                            PROP_TAG( PT_LONG,      0x0E07)
#define PR_MESSAGE_SIZE                             PROP_TAG( PT_LONG,      0x0E08)
#define PR_PARENT_ENTRYID                           PROP_TAG( PT_BINARY,    0x0E09)
#define PR_SENTMAIL_ENTRYID                         PROP_TAG( PT_BINARY,    0x0E0A)
#define PR_CORRELATE                                PROP_TAG( PT_BOOLEAN,   0x0E0C)
#define PR_CORRELATE_MTSID                          PROP_TAG( PT_BINARY,    0x0E0D)
#define PR_DISCRETE_VALUES                          PROP_TAG( PT_BOOLEAN,   0x0E0E)
#define PR_RESPONSIBILITY                           PROP_TAG( PT_BOOLEAN,   0x0E0F)
#define PR_SPOOLER_STATUS                           PROP_TAG( PT_LONG,      0x0E10)
#define PR_TRANSPORT_STATUS                         PROP_TAG( PT_LONG,      0x0E11)
#define PR_MESSAGE_RECIPIENTS                       PROP_TAG( PT_OBJECT,    0x0E12)
#define PR_MESSAGE_ATTACHMENTS                      PROP_TAG( PT_OBJECT,    0x0E13)
#define PR_SUBMIT_FLAGS                             PROP_TAG( PT_LONG,      0x0E14)
#define PR_RECIPIENT_STATUS                         PROP_TAG( PT_LONG,      0x0E15)
#define PR_TRANSPORT_KEY                            PROP_TAG( PT_LONG,      0x0E16)
#define PR_MSG_STATUS                               PROP_TAG( PT_LONG,      0x0E17)
#define PR_MESSAGE_DOWNLOAD_TIME                    PROP_TAG( PT_LONG,      0x0E18)
#define PR_CREATION_VERSION                         PROP_TAG( PT_I8,        0x0E19)
#define PR_MODIFY_VERSION                           PROP_TAG( PT_I8,        0x0E1A)
#define PR_HASATTACH                                PROP_TAG( PT_BOOLEAN,   0x0E1B)
#define PR_BODY_CRC                                 PROP_TAG( PT_LONG,      0x0E1C)
#define PR_NORMALIZED_SUBJECT                       PROP_TAG( PT_TSTRING,   0x0E1D)
#define PR_NORMALIZED_SUBJECT_W                     PROP_TAG( PT_UNICODE,   0x0E1D)
#define PR_NORMALIZED_SUBJECT_A                     PROP_TAG( PT_STRING8,   0x0E1D)
#define PR_RTF_IN_SYNC                              PROP_TAG( PT_BOOLEAN,   0x0E1F)
#define PR_ATTACH_SIZE                              PROP_TAG( PT_LONG,      0x0E20)
#define PR_ATTACH_NUM                               PROP_TAG( PT_LONG,      0x0E21)
#define PR_ORIGINAL_DISPLAY_BCC                     PROP_TAG( PT_TSTRING,   0x0E22)
#define PR_ORIGINAL_DISPLAY_BCC_W                   PROP_TAG( PT_UNICODE,   0x0E22)
#define PR_ORIGINAL_DISPLAY_BCC_A                   PROP_TAG( PT_STRING8,   0x0E22)
#define PR_ORIGINAL_DISPLAY_CC                      PROP_TAG( PT_TSTRING,   0x0E23)
#define PR_ORIGINAL_DISPLAY_CC_W                    PROP_TAG( PT_UNICODE,   0x0E23)
#define PR_ORIGINAL_DISPLAY_CC_A                    PROP_TAG( PT_STRING8,   0x0E23)
#define PR_ORIGINAL_DISPLAY_TO                      PROP_TAG( PT_TSTRING,   0x0E24)
#define PR_ORIGINAL_DISPLAY_TO_W                    PROP_TAG( PT_UNICODE,   0x0E24)
#define PR_ORIGINAL_DISPLAY_TO_A                    PROP_TAG( PT_STRING8,   0x0E24)
#define PR_ORIGINATING_MTA_CERTIFICATE              PROP_TAG( PT_BINARY,    0x0E25)
#define PR_PROOF_OF_SUBMISSION                      PROP_TAG( PT_BINARY,    0x0E26)


/*
 * The range of non-message and non-recipient property IDs (0x3000 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    32FF    MAPI_defined common property
 *  3200    33FF    MAPI_defined form property
 *  3400    35FF    MAPI_defined message store property
 *  3600    36FF    MAPI_defined Folder or AB Container property
 *  3700    38FF    MAPI_defined attachment property
 *  3900    39FF    MAPI_defined address book property
 *  3A00    3BFF    MAPI_defined mailuser property
 *  3C00    3CFF    MAPI_defined DistList property
 *  3D00    3DFF    MAPI_defined Profile Section property
 *  3E00    3EFF    MAPI_defined Status property
 *  3F00    3FFF    MAPI_defined display table property
 */

/*
 *  Properties common to numerous MAPI objects.
 *
 *  Those properties that can appear on messages are in the
 *  non-transmittable range for messages. They start at the high
 *  end of that range and work down.
 *
 *  Properties that never appear on messages are defined in the common
 *  property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 * -- these ids are in the non-transmittable range
 */

#define PR_ENTRYID                                  PROP_TAG( PT_BINARY,    0x0FFF)
#define PR_OBJECT_TYPE                              PROP_TAG( PT_LONG,      0x0FFE)
#define PR_ICON                                     PROP_TAG( PT_BINARY,    0x0FFD)
#define PR_MINI_ICON                                PROP_TAG( PT_BINARY,    0x0FFC)
#define PR_STORE_ENTRYID                            PROP_TAG( PT_BINARY,    0x0FFB)
#define PR_STORE_RECORD_KEY                         PROP_TAG( PT_BINARY,    0x0FFA)
#define PR_RECORD_KEY                               PROP_TAG( PT_BINARY,    0x0FF9)
#define PR_MAPPING_SIGNATURE                        PROP_TAG( PT_BINARY,    0x0FF8)
#define PR_ACCESS_LEVEL                             PROP_TAG( PT_LONG,      0x0FF7)
#define PR_INSTANCE_KEY                             PROP_TAG( PT_BINARY,    0x0FF6)
#define PR_ROW_TYPE                                 PROP_TAG( PT_LONG,      0x0FF5)
#define PR_ACCESS                                   PROP_TAG( PT_LONG,      0x0FF4)

/*
 * properties that are common to multiple objects (usually not including message objects)
 * -- these ids are in the transmittable range
 */

#define PR_ROWID                                    PROP_TAG( PT_LONG,      0x3000)
#define PR_DISPLAY_NAME                             PROP_TAG( PT_TSTRING,   0x3001)
#define PR_DISPLAY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3001)
#define PR_DISPLAY_NAME_A                           PROP_TAG( PT_STRING8,   0x3001)
#define PR_ADDRTYPE                                 PROP_TAG( PT_TSTRING,   0x3002)
#define PR_ADDRTYPE_W                               PROP_TAG( PT_UNICODE,   0x3002)
#define PR_ADDRTYPE_A                               PROP_TAG( PT_STRING8,   0x3002)
#define PR_EMAIL_ADDRESS                            PROP_TAG( PT_TSTRING,   0x3003)
#define PR_EMAIL_ADDRESS_W                          PROP_TAG( PT_UNICODE,   0x3003)
#define PR_EMAIL_ADDRESS_A                          PROP_TAG( PT_STRING8,   0x3003)
#define PR_COMMENT                                  PROP_TAG( PT_TSTRING,   0x3004)
#define PR_COMMENT_W                                PROP_TAG( PT_UNICODE,   0x3004)
#define PR_COMMENT_A                                PROP_TAG( PT_STRING8,   0x3004)
#define PR_DEPTH                                    PROP_TAG( PT_LONG,      0x3005)
#define PR_PROVIDER_DISPLAY                         PROP_TAG( PT_TSTRING,   0x3006)
#define PR_PROVIDER_DISPLAY_W                       PROP_TAG( PT_UNICODE,   0x3006)
#define PR_PROVIDER_DISPLAY_A                       PROP_TAG( PT_STRING8,   0x3006)
#define PR_CREATION_TIME                            PROP_TAG( PT_SYSTIME,   0x3007)
#define PR_LAST_MODIFICATION_TIME                   PROP_TAG( PT_SYSTIME,   0x3008)
#define PR_RESOURCE_FLAGS                           PROP_TAG( PT_LONG,      0x3009)
#define PR_PROVIDER_DLL_NAME                        PROP_TAG( PT_TSTRING,   0x300A)
#define PR_PROVIDER_DLL_NAME_W                      PROP_TAG( PT_UNICODE,   0x300A)
#define PR_PROVIDER_DLL_NAME_A                      PROP_TAG( PT_STRING8,   0x300A)
#define PR_SEARCH_KEY                               PROP_TAG( PT_BINARY,    0x300B)
#define PR_PROVIDER_UID                             PROP_TAG( PT_BINARY,    0x300C)
#define PR_PROVIDER_ORDINAL                         PROP_TAG( PT_LONG,      0x300D)

/*
 *  MAPI Form properties
 */
#define PR_FORM_VERSION                             PROP_TAG(PT_TSTRING,    0x3301)
#define PR_FORM_VERSION_W                           PROP_TAG(PT_UNICODE,    0x3301)
#define PR_FORM_VERSION_A                           PROP_TAG(PT_STRING8,    0x3301)
#define PR_FORM_CLSID                               PROP_TAG(PT_CLSID,      0x3302)
#define PR_FORM_CONTACT_NAME                        PROP_TAG(PT_TSTRING,    0x3303)
#define PR_FORM_CONTACT_NAME_W                      PROP_TAG(PT_UNICODE,    0x3303)
#define PR_FORM_CONTACT_NAME_A                      PROP_TAG(PT_STRING8,    0x3303)
#define PR_FORM_CATEGORY                            PROP_TAG(PT_TSTRING,    0x3304)
#define PR_FORM_CATEGORY_W                          PROP_TAG(PT_UNICODE,    0x3304)
#define PR_FORM_CATEGORY_A                          PROP_TAG(PT_STRING8,    0x3304)
#define PR_FORM_CATEGORY_SUB                        PROP_TAG(PT_TSTRING,    0x3305)
#define PR_FORM_CATEGORY_SUB_W                      PROP_TAG(PT_UNICODE,    0x3305)
#define PR_FORM_CATEGORY_SUB_A                      PROP_TAG(PT_STRING8,    0x3305)
#define PR_FORM_HOST_MAP                            PROP_TAG(PT_MV_LONG,    0x3306)
#define PR_FORM_HIDDEN                              PROP_TAG(PT_BOOLEAN,    0x3307)
#define PR_FORM_DESIGNER_NAME                       PROP_TAG(PT_TSTRING,    0x3308)
#define PR_FORM_DESIGNER_NAME_W                     PROP_TAG(PT_UNICODE,    0x3308)
#define PR_FORM_DESIGNER_NAME_A                     PROP_TAG(PT_STRING8,    0x3308)
#define PR_FORM_DESIGNER_GUID                       PROP_TAG(PT_CLSID,      0x3309)
#define PR_FORM_MESSAGE_BEHAVIOR                    PROP_TAG(PT_LONG,       0x330A)

/*
 *  Message store properties
 */

#define PR_DEFAULT_STORE                            PROP_TAG( PT_BOOLEAN,   0x3400)
#define PR_STORE_SUPPORT_MASK                       PROP_TAG( PT_LONG,      0x340D)

#define PR_IPM_SUBTREE_SEARCH_KEY                   PROP_TAG( PT_BINARY,    0x3410)
#define PR_IPM_OUTBOX_SEARCH_KEY                    PROP_TAG( PT_BINARY,    0x3411)
#define PR_IPM_WASTEBASKET_SEARCH_KEY               PROP_TAG( PT_BINARY,    0x3412)
#define PR_IPM_SENTMAIL_SEARCH_KEY                  PROP_TAG( PT_BINARY,    0x3413)
#define PR_MDB_PROVIDER                             PROP_TAG( PT_BINARY,    0x3414)
#define PR_RECEIVE_FOLDER_SETTINGS                  PROP_TAG( PT_OBJECT,    0x3415)

#define PR_VALID_FOLDER_MASK                        PROP_TAG( PT_LONG,      0x35DF)
#define PR_IPM_SUBTREE_ENTRYID                      PROP_TAG( PT_BINARY,    0x35E0)

#define PR_IPM_OUTBOX_ENTRYID                       PROP_TAG( PT_BINARY,    0x35E2)
#define PR_IPM_WASTEBASKET_ENTRYID                  PROP_TAG( PT_BINARY,    0x35E3)
#define PR_IPM_SENTMAIL_ENTRYID                     PROP_TAG( PT_BINARY,    0x35E4)
#define PR_VIEWS_ENTRYID                            PROP_TAG( PT_BINARY,    0x35E5)
#define PR_COMMON_VIEWS_ENTRYID                     PROP_TAG( PT_BINARY,    0x35E6)
#define PR_FINDER_ENTRYID                           PROP_TAG( PT_BINARY,    0x35E7)

/* Proptags 35E8-35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *  Folder and AB Container properties
 */

#define PR_CONTAINER_FLAGS                          PROP_TAG( PT_LONG,      0x3600)
#define PR_FOLDER_TYPE                              PROP_TAG( PT_LONG,      0x3601)
#define PR_CONTENT_COUNT                            PROP_TAG( PT_LONG,      0x3602)
#define PR_CONTENT_UNREAD                           PROP_TAG( PT_LONG,      0x3603)
#define PR_CREATE_TEMPLATES                         PROP_TAG( PT_OBJECT,    0x3604)
#define PR_DETAILS_TABLE                            PROP_TAG( PT_OBJECT,    0x3605)
#define PR_SEARCH                                   PROP_TAG( PT_OBJECT,    0x3607)
#define PR_SELECTABLE                               PROP_TAG( PT_BOOLEAN,   0x3609)
#define PR_SUBFOLDERS                               PROP_TAG( PT_BOOLEAN,   0x360a)
#define PR_STATUS                                   PROP_TAG( PT_LONG,      0x360b)
#define PR_ANR                                      PROP_TAG( PT_TSTRING,   0x360c)
#define PR_ANR_W                                    PROP_TAG( PT_UNICODE,   0x360c)
#define PR_ANR_A                                    PROP_TAG( PT_STRING8,   0x360c)
#define PR_CONTENTS_SORT_ORDER                      PROP_TAG( PT_MV_LONG,   0x360d)
#define PR_CONTAINER_HIERARCHY                      PROP_TAG( PT_OBJECT,    0x360e)
#define PR_CONTAINER_CONTENTS                       PROP_TAG( PT_OBJECT,    0x360f)
#define PR_FOLDER_ASSOCIATED_CONTENTS               PROP_TAG( PT_OBJECT,    0x3610)
#define PR_DEF_CREATE_DL                            PROP_TAG( PT_BINARY,    0x3611)
#define PR_DEF_CREATE_MAILUSER                      PROP_TAG( PT_BINARY,    0x3612)
#define PR_CONTAINER_CLASS                          PROP_TAG( PT_TSTRING,   0x3613)
#define PR_CONTAINER_CLASS_W                        PROP_TAG( PT_UNICODE,   0x3613)
#define PR_CONTAINER_CLASS_A                        PROP_TAG( PT_STRING8,   0x3613)
#define PR_CONTAINER_MODIFY_VERSION                 PROP_TAG( PT_I8,        0x3614)
#define PR_AB_PROVIDER_ID                           PROP_TAG( PT_BINARY,    0x3615)
/* Don't use 36FE and 36FF */

/*
 *  Attachment properties
 */

#define PR_ATTACHMENT_X400_PARAMETERS               PROP_TAG( PT_BINARY,    0x3700)
#define PR_ATTACH_DATA_OBJ                          PROP_TAG( PT_OBJECT,    0x3701)
#define PR_ATTACH_DATA_BIN                          PROP_TAG( PT_BINARY,    0x3701)
#define PR_ATTACH_ENCODING                          PROP_TAG( PT_BINARY,    0x3702)
#define PR_ATTACH_EXTENSION                         PROP_TAG( PT_TSTRING,   0x3703)
#define PR_ATTACH_EXTENSION_W                       PROP_TAG( PT_UNICODE,   0x3703)
#define PR_ATTACH_EXTENSION_A                       PROP_TAG( PT_STRING8,   0x3703)
#define PR_ATTACH_FILENAME                          PROP_TAG( PT_TSTRING,   0x3704)
#define PR_ATTACH_FILENAME_W                        PROP_TAG( PT_UNICODE,   0x3704)
#define PR_ATTACH_FILENAME_A                        PROP_TAG( PT_STRING8,   0x3704)
#define PR_ATTACH_METHOD                            PROP_TAG( PT_LONG,      0x3705)
#define PR_ATTACH_LONG_FILENAME                     PROP_TAG( PT_TSTRING,   0x3707)
#define PR_ATTACH_LONG_FILENAME_W                   PROP_TAG( PT_UNICODE,   0x3707)
#define PR_ATTACH_LONG_FILENAME_A                   PROP_TAG( PT_STRING8,   0x3707)
#define PR_ATTACH_PATHNAME                          PROP_TAG( PT_TSTRING,   0x3708)
#define PR_ATTACH_PATHNAME_W                        PROP_TAG( PT_UNICODE,   0x3708)
#define PR_ATTACH_PATHNAME_A                        PROP_TAG( PT_STRING8,   0x3708)
#define PR_ATTACH_RENDERING                         PROP_TAG( PT_BINARY,    0x3709)
#define PR_ATTACH_TAG                               PROP_TAG( PT_BINARY,    0x370A)
#define PR_RENDERING_POSITION                       PROP_TAG( PT_LONG,      0x370B)
#define PR_ATTACH_TRANSPORT_NAME                    PROP_TAG( PT_TSTRING,   0x370C)
#define PR_ATTACH_TRANSPORT_NAME_W                  PROP_TAG( PT_UNICODE,   0x370C)
#define PR_ATTACH_TRANSPORT_NAME_A                  PROP_TAG( PT_STRING8,   0x370C)

/*
 *  AB Object properties
 */

#define PR_DISPLAY_TYPE                             PROP_TAG( PT_LONG,      0x3900)
#define PR_TEMPLATEID                               PROP_TAG( PT_BINARY,    0x3902)
#define PR_CAPABILITIES_TABLE                       PROP_TAG( PT_OBJECT,    0x3903)
#define PR_PRIMARY_CAPABILITY                       PROP_TAG( PT_BINARY,    0x3904)

/*
 *  Mail user properties
 */

#define PR_ACCOUNT                                  PROP_TAG( PT_TSTRING,   0x3A00)
#define PR_ACCOUNT_W                                PROP_TAG( PT_UNICODE,   0x3A00)
#define PR_ACCOUNT_A                                PROP_TAG( PT_STRING8,   0x3A00)
#define PR_ALTERNATE_RECIPIENT                      PROP_TAG( PT_BINARY,    0x3A01)
#define PR_CALLBACK_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A02)
#define PR_CONVERSION_PROHIBITED                    PROP_TAG( PT_BOOLEAN,   0x3A03)
#define PR_DISCLOSE_RECIPIENTS                      PROP_TAG( PT_BOOLEAN,   0x3A04)
#define PR_GENERATION                               PROP_TAG( PT_TSTRING,   0x3A05)
#define PR_GENERATION_W                             PROP_TAG( PT_UNICODE,   0x3A05)
#define PR_GENERATION_A                             PROP_TAG( PT_STRING8,   0x3A05)
#define PR_GIVEN_NAME                               PROP_TAG( PT_TSTRING,   0x3A06)
#define PR_GIVEN_NAME_W                             PROP_TAG( PT_UNICODE,   0x3A06)
#define PR_GIVEN_NAME_A                             PROP_TAG( PT_STRING8,   0x3A06)
#define PR_GOVERNMENT_ID_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A07)
#define PR_BUSINESS_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A08)
#define PR_OFFICE_TELEPHONE_NUMBER                  PR_BUSINESS_TELEPHONE_NUMBER
#define PR_OFFICE_TELEPHONE_NUMBER_W                PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OFFICE_TELEPHONE_NUMBER_A                PR_BUSINESS_TELEPHONE_NUMBER_A
#define PR_HOME_TELEPHONE_NUMBER                    PROP_TAG( PT_TSTRING,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_W                  PROP_TAG( PT_UNICODE,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_A                  PROP_TAG( PT_STRING8,   0x3A09)
#define PR_INITIALS                                 PROP_TAG( PT_TSTRING,   0x3A0A)
#define PR_INITIALS_W                               PROP_TAG( PT_UNICODE,   0x3A0A)
#define PR_INITIALS_A                               PROP_TAG( PT_STRING8,   0x3A0A)
#define PR_KEYWORD                                  PROP_TAG( PT_TSTRING,   0x3A0B)
#define PR_KEYWORD_W                                PROP_TAG( PT_UNICODE,   0x3A0B)
#define PR_KEYWORD_A                                PROP_TAG( PT_STRING8,   0x3A0B)
#define PR_LANGUAGE                                 PROP_TAG( PT_TSTRING,   0x3A0C)
#define PR_LANGUAGE_W                               PROP_TAG( PT_UNICODE,   0x3A0C)
#define PR_LANGUAGE_A                               PROP_TAG( PT_STRING8,   0x3A0C)
#define PR_LOCATION                                 PROP_TAG( PT_TSTRING,   0x3A0D)
#define PR_LOCATION_W                               PROP_TAG( PT_UNICODE,   0x3A0D)
#define PR_LOCATION_A                               PROP_TAG( PT_STRING8,   0x3A0D)
#define PR_MAIL_PERMISSION                          PROP_TAG( PT_BOOLEAN,   0x3A0E)
#define PR_MHS_COMMON_NAME                          PROP_TAG( PT_TSTRING,   0x3A0F)
#define PR_MHS_COMMON_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A0F)
#define PR_MHS_COMMON_NAME_A                        PROP_TAG( PT_STRING8,   0x3A0F)
#define PR_ORGANIZATIONAL_ID_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A10)
#define PR_SURNAME                                  PROP_TAG( PT_TSTRING,   0x3A11)
#define PR_SURNAME_W                                PROP_TAG( PT_UNICODE,   0x3A11)
#define PR_SURNAME_A                                PROP_TAG( PT_STRING8,   0x3A11)
#define PR_ORIGINAL_ENTRYID                         PROP_TAG( PT_BINARY,    0x3A12)
#define PR_ORIGINAL_DISPLAY_NAME                    PROP_TAG( PT_TSTRING,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_W                  PROP_TAG( PT_UNICODE,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_A                  PROP_TAG( PT_STRING8,   0x3A13)
#define PR_ORIGINAL_SEARCH_KEY                      PROP_TAG( PT_BINARY,    0x3A14)
#define PR_POSTAL_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A15)
#define PR_POSTAL_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A15)
#define PR_POSTAL_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A15)
#define PR_COMPANY_NAME                             PROP_TAG( PT_TSTRING,   0x3A16)
#define PR_COMPANY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3A16)
#define PR_COMPANY_NAME_A                           PROP_TAG( PT_STRING8,   0x3A16)
#define PR_TITLE                                    PROP_TAG( PT_TSTRING,   0x3A17)
#define PR_TITLE_W                                  PROP_TAG( PT_UNICODE,   0x3A17)
#define PR_TITLE_A                                  PROP_TAG( PT_STRING8,   0x3A17)
#define PR_DEPARTMENT_NAME                          PROP_TAG( PT_TSTRING,   0x3A18)
#define PR_DEPARTMENT_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A18)
#define PR_DEPARTMENT_NAME_A                        PROP_TAG( PT_STRING8,   0x3A18)
#define PR_OFFICE_LOCATION                          PROP_TAG( PT_TSTRING,   0x3A19)
#define PR_OFFICE_LOCATION_W                        PROP_TAG( PT_UNICODE,   0x3A19)
#define PR_OFFICE_LOCATION_A                        PROP_TAG( PT_STRING8,   0x3A19)
#define PR_PRIMARY_TELEPHONE_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A1A)
#define PR_BUSINESS2_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A1B)
#define PR_OFFICE2_TELEPHONE_NUMBER                 PR_BUSINESS2_TELEPHONE_NUMBER
#define PR_OFFICE2_TELEPHONE_NUMBER_W               PR_BUSINESS2_TELEPHONE_NUMBER_W
#define PR_OFFICE2_TELEPHONE_NUMBER_A               PR_BUSINESS2_TELEPHONE_NUMBER_A
#define PR_MOBILE_TELEPHONE_NUMBER                  PROP_TAG( PT_TSTRING,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_W                PROP_TAG( PT_UNICODE,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_A                PROP_TAG( PT_STRING8,   0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER                PR_MOBILE_TELEPHONE_NUMBER
#define PR_CELLULAR_TELEPHONE_NUMBER_W              PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_CELLULAR_TELEPHONE_NUMBER_A              PR_MOBILE_TELEPHONE_NUMBER_A
#define PR_RADIO_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1D)
#define PR_CAR_TELEPHONE_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A1E)
#define PR_OTHER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1F)
#define PR_TRANSMITABLE_DISPLAY_NAME                PROP_TAG( PT_TSTRING,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_W              PROP_TAG( PT_UNICODE,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_A              PROP_TAG( PT_STRING8,   0x3A20)
#define PR_PAGER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A21)
#define PR_BEEPER_TELEPHONE_NUMBER                  PR_PAGER_TELEPHONE_NUMBER
#define PR_BEEPER_TELEPHONE_NUMBER_W                PR_PAGER_TELEPHONE_NUMBER_W
#define PR_BEEPER_TELEPHONE_NUMBER_A                PR_PAGER_TELEPHONE_NUMBER_A
#define PR_USER_CERTIFICATE                         PROP_TAG( PT_BINARY,    0x3A22)
#define PR_PRIMARY_FAX_NUMBER                       PROP_TAG( PT_TSTRING,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_W                     PROP_TAG( PT_UNICODE,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_A                     PROP_TAG( PT_STRING8,   0x3A23)
#define PR_BUSINESS_FAX_NUMBER                      PROP_TAG( PT_TSTRING,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_W                    PROP_TAG( PT_UNICODE,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_A                    PROP_TAG( PT_STRING8,   0x3A24)
#define PR_HOME_FAX_NUMBER                          PROP_TAG( PT_TSTRING,   0x3A25)
#define PR_HOME_FAX_NUMBER_W                        PROP_TAG( PT_UNICODE,   0x3A25)
#define PR_HOME_FAX_NUMBER_A                        PROP_TAG( PT_STRING8,   0x3A25)
#define PR_COUNTRY                                  PROP_TAG( PT_TSTRING,   0x3A26)
#define PR_COUNTRY_W                                PROP_TAG( PT_UNICODE,   0x3A26)
#define PR_COUNTRY_A                                PROP_TAG( PT_STRING8,   0x3A26)
#define PR_LOCALITY                                 PROP_TAG( PT_TSTRING,   0x3A27)
#define PR_LOCALITY_W                               PROP_TAG( PT_UNICODE,   0x3A27)
#define PR_LOCALITY_A                               PROP_TAG( PT_STRING8,   0x3A27)
#define PR_STATE_OR_PROVINCE                        PROP_TAG( PT_TSTRING,   0x3A28)
#define PR_STATE_OR_PROVINCE_W                      PROP_TAG( PT_UNICODE,   0x3A28)
#define PR_STATE_OR_PROVINCE_A                      PROP_TAG( PT_STRING8,   0x3A28)
#define PR_STREET_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A29)
#define PR_STREET_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A29)
#define PR_STREET_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A29)
#define PR_POSTAL_CODE                              PROP_TAG( PT_TSTRING,   0x3A2A)
#define PR_POSTAL_CODE_W                            PROP_TAG( PT_UNICODE,   0x3A2A)
#define PR_POSTAL_CODE_A                            PROP_TAG( PT_STRING8,   0x3A2A)
#define PR_POST_OFFICE_BOX                          PROP_TAG( PT_TSTRING,   0x3A2B)
#define PR_POST_OFFICE_BOX_W                        PROP_TAG( PT_UNICODE,   0x3A2B)
#define PR_POST_OFFICE_BOX_A                        PROP_TAG( PT_STRING8,   0x3A2B)
#define PR_TELEX_NUMBER                             PROP_TAG( PT_TSTRING,   0x3A2C)
#define PR_TELEX_NUMBER_W                           PROP_TAG( PT_UNICODE,   0x3A2C)
#define PR_TELEX_NUMBER_A                           PROP_TAG( PT_STRING8,   0x3A2C)
#define PR_ISDN_NUMBER                              PROP_TAG( PT_TSTRING,   0x3A2D)
#define PR_ISDN_NUMBER_W                            PROP_TAG( PT_UNICODE,   0x3A2D)
#define PR_ISDN_NUMBER_A                            PROP_TAG( PT_STRING8,   0x3A2D)
#define PR_ASSISTANT_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A2E)
#define PR_HOME2_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A2F)
#define PR_ASSISTANT                                PROP_TAG( PT_TSTRING,   0x3A30)
#define PR_ASSISTANT_W                              PROP_TAG( PT_UNICODE,   0x3A30)
#define PR_ASSISTANT_A                              PROP_TAG( PT_STRING8,   0x3A30)

/*
 *  Profile section properties
 */

#define PR_STORE_PROVIDERS                          PROP_TAG( PT_BINARY,    0x3D00)
#define PR_AB_PROVIDERS                             PROP_TAG( PT_BINARY,    0x3D01)
#define PR_TRANSPORT_PROVIDERS                      PROP_TAG( PT_BINARY,    0x3D02)

#define PR_DEFAULT_PROFILE                          PROP_TAG( PT_BOOLEAN,   0x3D04)
#define PR_AB_SEARCH_PATH                           PROP_TAG( PT_MV_BINARY, 0x3D05)
#define PR_AB_DEFAULT_DIR                           PROP_TAG( PT_BINARY,    0x3D06)
#define PR_AB_DEFAULT_PAB                           PROP_TAG( PT_BINARY,    0x3D07)
#define PR_FILTERING_HOOKS                          PROP_TAG( PT_BINARY,    0x3D08)
#define PR_SERVICE_NAME                             PROP_TAG( PT_TSTRING,   0x3D09)
#define PR_SERVICE_NAME_W                           PROP_TAG( PT_UNICODE,   0x3D09)
#define PR_SERVICE_NAME_A                           PROP_TAG( PT_STRING8,   0x3D09)
#define PR_SERVICE_DLL_NAME                         PROP_TAG( PT_TSTRING,   0x3D0A)
#define PR_SERVICE_DLL_NAME_W                       PROP_TAG( PT_UNICODE,   0x3D0A)
#define PR_SERVICE_DLL_NAME_A                       PROP_TAG( PT_STRING8,   0x3D0A)
#define PR_SERVICE_ENTRY_NAME                       PROP_TAG( PT_STRING8,   0x3D0B)
#define PR_SERVICE_UID                              PROP_TAG( PT_BINARY,    0x3D0C)
#define PR_SERVICE_EXTRA_UIDS                       PROP_TAG( PT_BINARY,    0x3D0D)
#define PR_SERVICES                                 PROP_TAG( PT_BINARY,    0x3D0E)
#define PR_SERVICE_SUPPORT_FILES                    PROP_TAG( PT_MV_TSTRING, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_W                  PROP_TAG( PT_MV_UNICODE, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_A                  PROP_TAG( PT_MV_STRING8, 0x3D0F)
#define PR_SERVICE_DELETE_FILES                     PROP_TAG( PT_MV_TSTRING, 0x3D10)
#define PR_SERVICE_DELETE_FILES_W                   PROP_TAG( PT_MV_UNICODE, 0x3D10)
#define PR_SERVICE_DELETE_FILES_A                   PROP_TAG( PT_MV_STRING8, 0x3D10)
// #define PR_AB_SEARCH_PATH_FLAGS                      PROP_TAG( PT_LONG,      0x3D11)

/*
 *  Status object properties
 */

#define PR_IDENTITY_DISPLAY                         PROP_TAG( PT_TSTRING,   0x3E00)
#define PR_IDENTITY_DISPLAY_W                       PROP_TAG( PT_UNICODE,   0x3E00)
#define PR_IDENTITY_DISPLAY_A                       PROP_TAG( PT_STRING8,   0x3E00)
#define PR_IDENTITY_ENTRYID                         PROP_TAG( PT_BINARY,    0x3E01)
#define PR_RESOURCE_METHODS                         PROP_TAG( PT_LONG,      0x3E02)
#define PR_RESOURCE_TYPE                            PROP_TAG( PT_LONG,      0x3E03)
#define PR_STATUS_CODE                              PROP_TAG( PT_LONG,      0x3E04)
#define PR_IDENTITY_SEARCH_KEY                      PROP_TAG( PT_BINARY,    0x3E05)
#define PR_OWN_STORE_ENTRYID                        PROP_TAG( PT_BINARY,    0x3E06)
#define PR_RESOURCE_PATH                            PROP_TAG( PT_TSTRING,   0x3E07)
#define PR_RESOURCE_PATH_W                          PROP_TAG( PT_UNICODE,   0x3E07)
#define PR_RESOURCE_PATH_A                          PROP_TAG( PT_STRING8,   0x3E07)
#define PR_STATUS_STRING                            PROP_TAG( PT_TSTRING,   0x3E08)
#define PR_STATUS_STRING_W                          PROP_TAG( PT_UNICODE,   0x3E08)
#define PR_STATUS_STRING_A                          PROP_TAG( PT_STRING8,   0x3E08)
#define PR_X400_DEFERRED_DELIVERY_CANCEL            PROP_TAG( PT_BOOLEAN,   0x3E09)
#define PR_HEADER_FOLDER_ENTRYID                    PROP_TAG( PT_BINARY,    0x3E0A)
#define PR_REMOTE_PROGRESS                          PROP_TAG( PT_LONG,      0x3E0B)
#define PR_REMOTE_PROGRESS_TEXT                     PROP_TAG( PT_TSTRING,   0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_W                   PROP_TAG( PT_UNICODE,   0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_A                   PROP_TAG( PT_STRING8,   0x3E0C)
#define PR_REMOTE_VALIDATE_OK                       PROP_TAG( PT_BOOLEAN,   0x3E0D)

/*
 * Display table properties
 */

#define PR_CONTROL_FLAGS                            PROP_TAG( PT_LONG,      0x3F00)
#define PR_CONTROL_STRUCTURE                        PROP_TAG( PT_BINARY,    0x3F01)
#define PR_CONTROL_TYPE                             PROP_TAG( PT_LONG,      0x3F02)
#define PR_DELTAX                                   PROP_TAG( PT_LONG,      0x3F03)
#define PR_DELTAY                                   PROP_TAG( PT_LONG,      0x3F04)
#define PR_XPOS                                     PROP_TAG( PT_LONG,      0x3F05)
#define PR_YPOS                                     PROP_TAG( PT_LONG,      0x3F06)
#define PR_CONTROL_ID                               PROP_TAG( PT_BINARY,    0x3F07)
#define PR_INITIAL_DETAILS_PANE                     PROP_TAG( PT_LONG,      0x3F08)

/*
 * Secure property id range
 */

#define PROP_ID_SECURE_MIN                          0x67F0
#define PROP_ID_SECURE_MAX                          0x67FF


#endif  /* MAPITAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mapiutil.h ===
/*
 *  M A P I U T I L . H
 *
 *  Definitions and prototypes for utility functions provided by MAPI
 *  in MAPIU[xx].DLL.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPIUTIL_H_
#define _MAPIUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIX_H
#include <mapix.h>
#endif

#ifdef WIN16
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/* IMAPITable in memory */

/* ITableData Interface ---------------------------------------------------- */

DECLARE_MAPI_INTERFACE_PTR(ITableData, LPTABLEDATA);

typedef void (STDAPICALLTYPE CALLERRELEASE)(
    ULONG       ulCallerData,
    LPTABLEDATA lpTblData,
    LPMAPITABLE lpVue
);

#define MAPI_ITABLEDATA_METHODS(IPURE)                                  \
    MAPIMETHOD(HrGetView)                                               \
        (THIS_  LPSSortOrderSet             lpSSortOrderSet,            \
                CALLERRELEASE FAR *         lpfCallerRelease,           \
                ULONG                       ulCallerData,               \
                LPMAPITABLE FAR *           lppMAPITable) IPURE;        \
    MAPIMETHOD(HrModifyRow)                                             \
        (THIS_  LPSRow) IPURE;                                          \
    MAPIMETHOD(HrDeleteRow)                                             \
        (THIS_  LPSPropValue                lpSPropValue) IPURE;        \
    MAPIMETHOD(HrQueryRow)                                              \
        (THIS_  LPSPropValue                lpsPropValue,               \
                LPSRow FAR *                lppSRow,                    \
                ULONG FAR *                 lpuliRow) IPURE;            \
    MAPIMETHOD(HrEnumRow)                                               \
        (THIS_  ULONG                       ulRowNumber,                \
                LPSRow FAR *                lppSRow) IPURE;             \
    MAPIMETHOD(HrNotify)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cValues,                    \
                LPSPropValue                lpSPropValue) IPURE;        \
    MAPIMETHOD(HrInsertRow)                                             \
        (THIS_  ULONG                       uliRow,                     \
                LPSRow                      lpSRow) IPURE;              \
    MAPIMETHOD(HrModifyRows)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet                   lpSRowSet) IPURE;           \
    MAPIMETHOD(HrDeleteRows)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet                   lprowsetToDelete,           \
                ULONG FAR *                 cRowsDeleted) IPURE;        \

#undef       INTERFACE
#define      INTERFACE  ITableData
DECLARE_MAPI_INTERFACE_(ITableData, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_ITABLEDATA_METHODS(PURE)
};


/* Entry Point for in memory ITable */


/*  CreateTable()
 *      Creates the internal memory structures and object handle
 *      to bring a new table into existence.
 *
 *  lpInterface
 *      Interface ID of the TableData object (IID_IMAPITableData)
 *
 *  lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *      Function addresses are provided by the caller so that
 *      this DLL allocates/frees memory appropriately.
 *  lpvReserved
 *      Reserved.  Should be NULL.
 *  ulTableType
 *      TBLTYPE_DYNAMIC, etc.  Visible to the calling application
 *      as part of the GetStatus return data on its views
 *  ulPropTagIndexColumn
 *      Index column for use when changing the data
 *  lpSPropTagArrayColumns
 *      Column proptags for the minimum set of columns in the table
 *  lppTableData
 *      Address of the pointer which will receive the TableData object
 */

STDAPI_(SCODE)
CreateTable( LPCIID                 lpInterface,
             ALLOCATEBUFFER FAR *   lpAllocateBuffer,
             ALLOCATEMORE FAR *     lpAllocateMore,
             FREEBUFFER FAR *       lpFreeBuffer,
             LPVOID                 lpvReserved,
             ULONG                  ulTableType,
             ULONG                  ulPropTagIndexColumn,
             LPSPropTagArray        lpSPropTagArrayColumns,
             LPTABLEDATA FAR *      lppTableData );

/*  HrGetView()
 *      This function obtains a new view on the underlying data
 *      which supports the IMAPITable interface.  All rows and columns
 *      of the underlying table data are initially visible
 *  lpSSortOrderSet
 *      if specified, results in the view being sorted
 *  lpfCallerRelease
 *      pointer to a routine to be called when the view is released, or
 *      NULL.
 *  ulCallerData
 *      arbitrary data the caller wants saved with this view and returned in
 *      the Release callback.
 */

/*  HrModifyRows()
 *      Add or modify a set of rows in the table data
 *  ulFlags
 *      Must be zero
 *  lpSRowSet
 *      Each row in the row set contains all the properties for one row
 *      in the table.  One of the properties must be the index column.  Any
 *      row in the table with the same value for its index column is
 *      replaced, or if there is no current row with that value the
 *      row is added.
 *      Each row in LPSRowSet MUST have a unique Index column!
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */

/*  HrModifyRow()
 *      Add or modify one row in the table
 *  lpSRow
 *      This row contains all the properties for one row in the table.
 *      One of the properties must be the index column.  Any row in
 *      the table with the same value for its index column is
 *      replaced, or if there is no current row with that value the
 *      row is added
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */

/*  HrDeleteRows()
 *      Delete a row in the table.
 *  ulFlags
 *      TAD_ALL_ROWS - Causes all rows in the table to be deleted
 *                     lpSRowSet is ignored in this case.
 *  lpSRowSet
 *      Each row in the row set contains all the properties for one row
 *      in the table.  One of the properties must be the index column.  Any
 *      row in the table with the same value for its index column is
 *      deleted.
 *      Each row in LPSRowSet MUST have a unique Index column!
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */
#define TAD_ALL_ROWS    1

/*  HrDeleteRow()
 *      Delete a row in the table.
 *  lpSPropValue
 *      This property value specifies the row which has this value
 *      for its index column
 */

/*  HrQueryRow()
 *      Returns the values of a specified row in the table
 *  lpSPropValue
 *      This property value specifies the row which has this value
 *      for its index column
 *  lppSRow
 *      Address of where to return a pointer to an SRow
 *  lpuliRow
 *    Address of where to return the row number. This can be NULL
 *    if the row number is not required.
 *
 */

/*  HrEnumRow()
 *      Returns the values of a specific (numbered) row in the table
 *  ulRowNumber
 *      Indicates row number 0 to n-1
 *  lppSRow
 *      Address of where to return a pointer to a SRow
 */

/*  HrInsertRow()
 *      Inserts a row into the table.
 *  uliRow
 *      The row number before which this row will be inserted into the table.
 *      Row numbers can be from 0 to n where o to n-1 result in row insertion
 *    a row number of n results in the row being appended to the table.
 *  lpSRow
 *      This row contains all the properties for one row in the table.
 *      One of the properties must be the index column.  Any row in
 *      the table with the same value for its index column is
 *      replaced, or if there is no current row with that value the
 *      row is added
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */


/* IMAPIProp in memory */

/* IPropData Interface ---------------------------------------------------- */


#define MAPI_IPROPDATA_METHODS(IPURE)                                   \
    MAPIMETHOD(HrSetObjAccess)                                          \
        (THIS_  ULONG                       ulAccess) IPURE;            \
    MAPIMETHOD(HrSetPropAccess)                                         \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG FAR *                 rgulAccess) IPURE;          \
    MAPIMETHOD(HrGetPropAccess)                                         \
        (THIS_  LPSPropTagArray FAR *       lppPropTagArray,            \
                ULONG FAR * FAR *           lprgulAccess) IPURE;        \
    MAPIMETHOD(HrAddObjProps)                                           \
        (THIS_  LPSPropTagArray             lppPropTagArray,            \
                LPSPropProblemArray FAR *   lprgulAccess) IPURE;


#undef       INTERFACE
#define      INTERFACE  IPropData
DECLARE_MAPI_INTERFACE_(IPropData, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IPROPDATA_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPropData, LPPROPDATA);


/* Entry Point for in memory IMAPIProp */


/*  CreateIProp()
 *      Creates the internal memory structures and object handle
 *      to bring a new property interface into existance.
 *
 *  lpInterface
 *      Interface ID of the TableData object (IID_IMAPIPropData)
 *
 *  lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *      Function addresses are provided by the caller so that
 *      this DLL allocates/frees memory appropriately.
 *  lppPropData
 *      Address of the pointer which will receive the IPropData object
 *  lpvReserved
 *      Reserved.  Should be NULL.
 */

STDAPI_(SCODE)
CreateIProp( LPCIID                 lpInterface,
             ALLOCATEBUFFER FAR *   lpAllocateBuffer,
             ALLOCATEMORE FAR *     lpAllocateMore,
             FREEBUFFER FAR *       lpFreeBuffer,
             LPVOID                 lpvReserved,
             LPPROPDATA FAR *       lppPropData );

/*
 *  Defines for prop/obj access
 */
#define IPROP_READONLY      ((ULONG) 0x00000001)
#define IPROP_READWRITE     ((ULONG) 0x00000002)
#define IPROP_CLEAN         ((ULONG) 0x00010000)
#define IPROP_DIRTY         ((ULONG) 0x00020000)

/*
 -  HrSetPropAccess
 -
 *  Sets access right attributes on a per-property basis.  By default,
 *  all properties are read/write.
 *
 */

/*
 -  HrSetObjAccess
 -
 *  Sets access rights for the object itself.  By default, the object has
 *  read/write access.
 *
 */


/* IDLE Engine */

#ifndef NOIDLEENGINE

/* Idle time scheduler */

/*
 *  PRI
 *
 *  Priority.  Idle function priority where 0 is the priority of
 *  a "user event" (mouse click, WM_PAINT, etc).  Idle routines
 *  can have priorities greater than or less than 0, but not
 *  equal to 0.  Priorities greater than zero are background
 *  tasks that have a higher priority than user events and are
 *  dispatched as part of the standard message pump loop.  Priorities
 *  less than zero are idle tasks that only run during message pump
 *  idle time.  The priorities are sorted and the one with the higher
 *  value runs first.  For negative priorities, for example, -3 is
 *  higher than -5.  Within a priority level, the functions are called
 *  round-robin.
 *
 *  Example priorities (subject to change):
 *
 *  Foreground submission        1
 *  Power Edit char insertion   -1
 *  Autoscrolling               -1
 *  Background redraw           -2
 *  Misc FW fixups              -2
 *  Clock                       -2
 *  Download new mail           -3
 *  Background submission       -4
 *  Poll for MTA back up        -4
 *  Poll for new mail           -4
 *  ISAM buffer flush           -5
 *  MS compaction               -6
 *
 */

#define PRILOWEST   -32768
#define PRIHIGHEST  32767
#define PRIUSER     0

/*
 *  SCH
 *
 *  Idle Scheduler state.  This is the state of the system when the
 *  idle routine dispatcher, FDoNextIdleTask() is called.
 *  This is a combined bit mask consisting of individual fsch's.
 *  Listed below are the possible bit flags.
 *
 *      fschUserEvent   - FDoNextIdleTask() is being called while in
 *                        the user event loop, i.e. not during idle
 *                        time.  This is to allow background routines
 *                        to run that have a higher priority than user
 *                        events.
 */

#define SCHNULL         ((USHORT) 0x0000)
#define FSCHUSEREVENT   ((USHORT) 0x0008)

/*
 *  IRO
 *
 *  Idle routine options.  This is a combined bit mask consisting of
 *  individual firo's.  Listed below are the possible bit flags.
 *
 *      The following two flags are considered mutually exclusive:
 *      If neither of the flags are specified, the default action
 *      is to ignore the time parameter of the idle function and
 *      call it as often as possible if firoPerBlock is not set;
 *      otherwise call it one time only during the idle block
 *      once the time constraint has been set.  Note that firoInterval
 *      is incompatible with firoPerBlock.
 *
 *      firoWait        - time given is minimum idle time before calling
 *                        for the first time in the block of idle time,
 *                        afterwhich call as often as possible.
 *      firoInterval    - time given is minimum interval between each
 *                        successive call
 *
 *      firoPerBlock    - called only once per contiguous block of idle
 *                        time
 *
 *      firoDisabled    - initially disabled when registered, the
 *                        default is to enable the function when registered.
 *      firoOnceOnly    - called only one time by the scheduler and then
 *                        deregistered automatically.
 */

#define IRONULL         ((USHORT) 0x0000)
#define FIROWAIT        ((USHORT) 0x0001)
#define FIROINTERVAL    ((USHORT) 0x0002)
#define FIROPERBLOCK    ((USHORT) 0x0004)
#define FIRODISABLED    ((USHORT) 0x0020)
#define FIROONCEONLY    ((USHORT) 0x0040)

/*
 *  CSEC
 *
 *  Hundreths of a second.  Used in specifying idle function parameters.
 *  Each idle function has a time associated with it.  This time can
 *  represent the minimum length of user idle time that must elapse
 *  before the function is called, after which it is called as often as
 *  possible (firoWait option).  Alternatively, the time can represent
 *  the minimum interval between calls to the function (firoInterval
 *  option).  Finally, the time can be ignored, in which case the
 *  function will be called as often as possible.
 *
 */

#define csecNull            ((ULONG) 0x00000000)

/*
 *  IRC
 *
 *  Idle routine change options.  This is a combined bit mask consisting of
 *  individual firc's.  Listed below are the possible bit flags.
 *
 */

#define IRCNULL         ((USHORT) 0x0000)
#define FIRCPFN         ((USHORT) 0x0001)   /* change function pointer */
#define FIRCPV          ((USHORT) 0x0002)   /* change parameter block  */
#define FIRCPRI         ((USHORT) 0x0004)   /* change priority         */
#define FIRCCSEC        ((USHORT) 0x0008)   /* change time             */
#define FIRCIRO         ((USHORT) 0x0010)   /* change routine options  */

/*
 *  Type definition for idle functions.  An idle function takes one
 *  parameter, an PV, and returns a BOOL value.
 */

typedef BOOL (STDAPICALLTYPE FNIDLE) (LPVOID);
typedef FNIDLE          *PFNIDLE;

/*
 *  FTG
 *
 *  Function Tag.  Used to identify a registered idle function.
 *
 */

typedef void far *FTG, **PFTG;
#define FTGNULL         ((FTG) NULL)

/*
 *
 *  What follows is declarations for the idle engine functions in mapiu.dll,
 *  with some description of each function
 *
 */

/*
 -  Idle_InitDLL
 -
 *  Purpose:
 *      Initialises the idle engine
 *      If the initialisation succeded, returns 0, else returns -1
 *
 *  Arguments:
 *      pMemAlloc   Pointer to memory allocator to be used by the DLL for
 *                  maintaining it's data structures of registered callbacks.
 *                  Only the first such memory allocator is accepted. Multiple
 *                  calls to Idle_InitDLL result in the first call returning
 *                  success and subsequent calls failing.
 */

STDAPI_(LONG)
Idle_InitDLL (LPMALLOC pMemAlloc);

STDAPI_(VOID)
Idle_DeInitDLL (VOID);

STDAPI_(VOID)
InstallFilterHook (BOOL);


/*
 *  FtgRegisterIdleRoutine
 *
 *  Purpose:
 *      Registers the function pfn of type PFNIDLE, i.e., (BOOL (*)(LPVOID))
 *      as an idle function.  Resorts the idle table based on the priority of
 *      the newly registered routine.
 *
 *      It will be called with the parameter pv by the scheduler
 *      FDoNextIdleTask().  The function has initial priority priIdle,
 *      associated time csecIdle, and options iroIdle.
 *
 *  Arguments:
 *      pfnIdle     Pointer to the idle loop routine.  The routine
 *                  will be called with the argument pvIdleParam (which
 *                  is initially given at registration) and must return a
 *                  BOOL. The function should always return FALSE
 *                  unless the idle routine is being called via
 *                  IdleExit() instead of the scheduler FDoNextIdleTask().
 *                  In this case, the global flag fIdleExit will be set
 *                  and the idle function should return TRUE if it
 *                  is ready to quit the application; else it should
 *                  return FALSE.  IdleExit() will repeatedly call the
 *                  idle function until it returns TRUE.
 *
 *      pvIdleParam Every time the idle function is called, this value
 *                  is passed as the idle function's parameter.  The
 *                  routine can use this as a pointer to a state buffer
 *                  for length operations.  This pointer can be changed
 *                  via a call to ChangeIdleRoutine().
 *
 *      priIdle     Initial priority of the idle routine.  This can be
 *                  changed via a call to ChangeIdleRoutine().
 *
 *      csecIdle    Initial time value associated with idle routine.
 *                  This can be changed via ChangeIdleRoutine().
 *
 *      iroIdle     Initial options associated with idle routine.  This
 *                  can be changed via ChangeIdleRoutine().
 *
 *  Returns:
 *      FTG identifying the routine.
 *      If the function could not be registered, perhaps due to
 *      memory problems, then ftgNull is returned.
 *
 */

STDAPI_(FTG)
FtgRegisterIdleRoutine (PFNIDLE pfnIdle, LPVOID pvIdleParam,
    short priIdle, ULONG csecIdle, USHORT iroIdle);

/*
 *  DeregisterIdleRoutine
 *
 *  Purpose:
 *      Removes the given routine from the list of idle routines.
 *      The routine will not be called again.  It is the responsibility
 *      of the caller to clean up any data structures pointed to by the
 *      pvIdleParam parameter; this routine does not free the block.
 *
 *      An idle routine is only deregistered if it is not currently
 *      active.  Thus if an idle routine directly or indirectly calls
 *      DeregisterIdleRoutine(), then the flag fDeregister is set, and
 *      the idle routine will be deregistered after it finishes.
 *      There are no checks made to make sure that the idle routine is in
 *      an exitable state.
 *
 *  Parameters:
 *      ftg     Identifies the routine to deregister.
 *
 *  Returns:
 *      void
 *
 */

STDAPI_(void)
DeregisterIdleRoutine (FTG ftg);

/*
 *  EnableIdleRoutine
 *
 *  Purpose:
 *      Enables or disables an idle routine.  Disabled routines are
 *      not called during the idle loop.
 *
 *  Parameters:
 *      ftg         Identifies the idle routine to be disabled.
 *      fEnable     TRUE if routine should be enabled, FALSE if
 *                  routine should be disabled.
 *
 *  Returns:
 *      void
 *
 */

STDAPI_(void)
EnableIdleRoutine (FTG ftg, BOOL fEnable);

/*
 *  ChangeIdleRoutine
 *
 *  Purpose:
 *      Changes some or all of the characteristics of the given idle
 *      function.  The changes to make are indicated with flags in the
 *      ircIdle parameter.  If the priority of an idle function is
 *      changed, the pInst->pftgIdle table is re-sorted.
 *
 *  Arguments:
 *      ftg         Identifies the routine to change
 *      pfnIdle     New idle function to call
 *      pvIdleParam New parameter block to use
 *      priIdle     New priority for idle function
 *      csecIdle    New time value for idle function
 *      iroIdle     New options for idle function
 *      ircIdle     Change options
 *
 *  Returns:
 *      void
 *
 */

STDAPI_(void)
ChangeIdleRoutine (FTG ftg, PFNIDLE pfnIdle, LPVOID pvIdleParam,
    short priIdle, ULONG csecIdle, USHORT iroIdle, USHORT ircIdle);

/*
 *  FDoNextIdleTask
 *
 *  Purpose:
 *      Calls the highest priority, registered, enabled, "eligible",
 *      idle routine.  Eligibility is determined by calling,
 *      FEligibleIdle()
 *      If all enabled routines of the highest priority level are not
 *      "eligible" at this time, the routines that are one notch lower
 *      in priority are checked next.  This continues until either a
 *      routine is actually run, or no routines are left to run.
 *      Routines of equal priority are called in a round-robin fashion.
 *      If an idle routine is actually dispatched, the function returns
 *      TRUE; else FALSE.
 *
 *  Returns:
 *      TRUE if an eligible routine is dispatched; else FALSE.
 *
 */

STDAPI_(BOOL) FDoNextIdleTask (void);

/*
 *  FIsIdleExit
 *
 *  Purpose:
 *      Returns state of fIdleExit flag, which is TRUE while
 *      IdleExit() is being called, so that idle routines can
 *      check the flag.  See IdleExit() for description of flag
 *
 *  Arguments:
 *      void
 *
 *  Returns:
 *      State of the fIdleExit flag.
 *
 */

STDAPI_(BOOL)
FIsIdleExit (void);

#ifdef  DEBUG

/*
 *  DumpIdleTable
 *
 *  Purpose:
 *      Used for debugging only.  Writes information in the PGD(hftgIdle)
 *      table to COM1.
 *
 *  Parameters:
 *      none
 *
 *  Returns:
 *      void
 *
 */

STDAPI_(void)
DumpIdleTable (void);

#endif

#endif  /* ! NOIDLEENGINE */


/* IMalloc Utilities */

STDAPI_(LPMALLOC) MAPIGetDefaultMalloc();


/* StreamOnFile (SOF) */

/*
 *  Methods and #define's for implementing an OLE 2.0 storage stream
 *  (as defined in the OLE 2.0 specs) on top of a system file.
 */

#define SOF_UNIQUEFILENAME  ((ULONG) 0x80000000)

STDMETHODIMP OpenStreamOnFile(
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    LPTSTR              szFileName,
    LPTSTR              szPrefix,
    LPSTREAM FAR *      lppStream);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENSTREAMONFILE) (
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    LPTSTR              szFileName,
    LPTSTR              szPrefix,
    LPSTREAM FAR *      lppStream);

#ifdef  WIN32
#define OPENSTREAMONFILE "OpenStreamOnFile"
#endif
#ifdef  WIN16
#define OPENSTREAMONFILE "_OPENSTREAMONFILE"
#endif


/* Property interface utilities */

/*
 *  Copies a single SPropValue from Src to Dest.  Handles all the various
 *  types of properties and will link its allocations given the master
 *  allocation object and an allocate more function.
 */
STDAPI_(SCODE)
PropCopyMore( LPSPropValue      lpSPropValueDest,
              LPSPropValue      lpSPropValueSrc,
              ALLOCATEMORE *    lpfAllocMore,
              LPVOID            lpvObject );

/*
 *  Returns the size in bytes of structure at lpSPropValue, including the
 *  Value.
 */
STDAPI_(ULONG)
UlPropSize( LPSPropValue    lpSPropValue );


STDAPI_(BOOL)
FEqualNames( LPMAPINAMEID lpName1, LPMAPINAMEID lpName2 );

#if defined(WIN32) && !defined(NT) && !defined(CHICAGO) && !defined(_MAC)
#define NT
#endif

STDAPI_(void)
GetInstance(LPSPropValue pvalMv, LPSPropValue pvalSv, ULONG uliInst);

STDAPI_(BOOL)
FRKFindSubpb( LPSPropValue lpSPropValueDst, LPSPropValue lpsPropValueSrc );

extern char rgchCsds[];
extern char rgchCids[];
extern char rgchCsdi[];
extern char rgchCidi[];

STDAPI_(BOOL)
FRKFindSubpsz( LPSPropValue lpSPropValueDst, LPSPropValue lpsPropValueSrc,
        ULONG ulFuzzyLevel );

STDAPI_(BOOL)
FPropContainsProp( LPSPropValue lpSPropValueDst,
                   LPSPropValue lpSPropValueSrc,
                   ULONG        ulFuzzyLevel );

STDAPI_(BOOL)
FPropCompareProp( LPSPropValue  lpSPropValue1,
                  ULONG         ulRelOp,
                  LPSPropValue  lpSPropValue2 );

STDAPI_(LONG)
LPropCompareProp( LPSPropValue  lpSPropValueA,
                  LPSPropValue  lpSPropValueB );

STDAPI_(HRESULT)
HrAddColumns(   LPMAPITABLE         lptbl,
                LPSPropTagArray     lpproptagColumnsNew,
                LPALLOCATEBUFFER    lpAllocateBuffer,
                LPFREEBUFFER        lpFreeBuffer);

STDAPI_(HRESULT)
HrAddColumnsEx( LPMAPITABLE         lptbl,
                LPSPropTagArray     lpproptagColumnsNew,
                LPALLOCATEBUFFER    lpAllocateBuffer,
                LPFREEBUFFER        lpFreeBuffer,
                void                (FAR *lpfnFilterColumns)(LPSPropTagArray ptaga));


/* Notification utilities */

/*
 *  Function that creates an advise sink object given a notification
 *  callback function and context.
 */

STDAPI
HrAllocAdviseSink( LPNOTIFCALLBACK lpfnCallback,
                   LPVOID lpvContext,
                   LPMAPIADVISESINK FAR *lppAdviseSink );


/*
 *  Wraps an existing advise sink with another one which guarantees
 *  that the original advise sink will be called in the thread on
 *  which it was created.
 */

STDAPI
HrThisThreadAdviseSink( LPMAPIADVISESINK lpAdviseSink,
                        LPMAPIADVISESINK FAR *lppAdviseSink);

/*
 *  Structure and functions for maintaining a list of advise sinks,
 *  together with the keys used to release them.
 */

typedef struct
{
    LPMAPIADVISESINK    lpAdvise;
    ULONG               ulConnection;
    ULONG               ulType;
    LPUNKNOWN           lpParent;
} ADVISEITEM, FAR *LPADVISEITEM;

typedef struct
{
    ULONG               cItemsMac;
    ULONG               cItemsMax;
    LPMALLOC            pmalloc;
    #if defined(WIN32) && !defined(MAC)
    CRITICAL_SECTION    cs;
    #endif
    ADVISEITEM          rgItems[1];
} ADVISELIST, FAR *LPADVISELIST;

#define CbNewADVISELIST(_citems) \
    (offsetof(ADVISELIST, rgItems) + (_citems) * sizeof(ADVISEITEM))
#define CbADVISELIST(_plist) \
    (offsetof(ADVISELIST, rgItems) + (_plist)->cItemsMax * sizeof(ADVISEITEM))


STDAPI_(SCODE)
ScAddAdviseList(    LPMALLOC pmalloc,
                    LPADVISELIST FAR *lppList,
                    LPMAPIADVISESINK lpAdvise,
                    ULONG ulConnection,
                    ULONG ulType,
                    LPUNKNOWN lpParent);
STDAPI_(SCODE)
ScDelAdviseList(    LPADVISELIST lpList,
                    ULONG ulConnection);
STDAPI_(SCODE)
ScFindAdviseList(   LPADVISELIST lpList,
                    ULONG ulConnection,
                    LPADVISEITEM FAR *lppItem);
STDAPI_(void)
DestroyAdviseList(  LPADVISELIST FAR *lppList);


/* Service Provider Utilities */

/*
 *  Structures and utility function for building a display table
 *  from resources.
 */

typedef struct {
    ULONG           ulCtlType;          /* DTCT_LABEL, etc. */
    ULONG           ulCtlFlags;         /* DT_REQUIRED, etc. */
    LPBYTE          lpbNotif;           /*  pointer to notification data */
    ULONG           cbNotif;            /* count of bytes of notification data */
    LPTSTR          lpszFilter;         /* character filter for edit/combobox */
    ULONG           ulItemID;           /* to validate parallel dlg template entry */
    union {                             /* ulCtlType discriminates */
        LPVOID          lpv;            /* Initialize this to avoid warnings */
        LPDTBLLABEL     lplabel;
        LPDTBLEDIT      lpedit;
        LPDTBLLBX       lplbx;
        LPDTBLCOMBOBOX  lpcombobox;
        LPDTBLDDLBX     lpddlbx;
        LPDTBLCHECKBOX  lpcheckbox;
        LPDTBLGROUPBOX  lpgroupbox;
        LPDTBLBUTTON    lpbutton;
        LPDTBLRADIOBUTTON lpradiobutton;
        LPDTBLINKEDIT   lpinkedit;
        LPDTBLMVLISTBOX lpmvlbx;
        LPDTBLMVDDLBX   lpmvddlbx;
        LPDTBLPAGE      lppage;
    } ctl;
} DTCTL, FAR *LPDTCTL;

typedef struct {
    ULONG           cctl;
    LPTSTR          lpszResourceName;   /* as usual, may be an integer ID */
    union {                             /* as usual, may be an integer ID */
        LPTSTR          lpszComponent;
        ULONG           ulItemID;
    };
    LPDTCTL         lpctl;
} DTPAGE, FAR *LPDTPAGE;



STDAPI
BuildDisplayTable(  LPALLOCATEBUFFER    lpAllocateBuffer,
                    LPALLOCATEMORE      lpAllocateMore,
                    LPFREEBUFFER        lpFreeBuffer,
                    LPMALLOC            lpMalloc,
                    HINSTANCE           hInstance,
                    UINT                cPages,
                    LPDTPAGE            lpPage,
                    ULONG               ulFlags,
                    LPMAPITABLE *       lppTable,
                    LPTABLEDATA *       lppTblData );


/*
 *  Function that initializes a progress indicator object. If an
 *  original indicator object is suppiiied, it is wrapped and the
 *  new object forwards update calls to the original.
 */

STDAPI
WrapProgress(   LPMAPIPROGRESS lpProgressOrig,
                ULONG ulMin,
                ULONG ulMax,
                ULONG ulFlags,
                LPMAPIPROGRESS FAR *lppProgress );


/* MAPI structure validation/copy utilities */

/*
 *  Validate, copy, and adjust pointers in MAPI structures:
 *      notification
 *      property value array
 *      option data
 */

STDAPI_(SCODE)
ScCountNotifications(int cntf, LPNOTIFICATION rgntf,
        ULONG FAR *pcb);

STDAPI_(SCODE)
ScCopyNotifications(int cntf, LPNOTIFICATION rgntf, LPVOID pvDst,
        ULONG FAR *pcb);

STDAPI_(SCODE)
ScRelocNotifications(int cntf, LPNOTIFICATION rgntf,
        LPVOID pvBaseOld, LPVOID pvBaseNew, ULONG FAR *pcb);

#ifdef MAPISPI_H

STDAPI_(SCODE)
ScCountOptionData(LPOPTIONDATA lpOption, ULONG FAR *pcb);

STDAPI_(SCODE)
ScCopyOptionData(LPOPTIONDATA lpOption, LPVOID pvDst, ULONG FAR *pcb);

STDAPI_(SCODE)
ScRelocOptionData(LPOPTIONDATA lpOption,
        LPVOID pvBaseOld, LPVOID pvBaseNew, ULONG FAR *pcb);

#endif  /* MAPISPI_H */

STDAPI_(SCODE)
ScCountProps(int cprop, LPSPropValue rgprop, ULONG FAR *pcb);

STDAPI_(LPSPropValue)
LpValFindProp(ULONG ulPropTag, ULONG cprop, LPSPropValue rgprop);

STDAPI_(SCODE)
ScCopyProps(int cprop, LPSPropValue rgprop, LPVOID pvDst,
        ULONG FAR *pcb);

STDAPI_(SCODE)
ScRelocProps(int cprop, LPSPropValue rgprop,
        LPVOID pvBaseOld, LPVOID pvBaseNew, ULONG FAR *pcb);

STDAPI_(SCODE)
ScDupPropset(int cprop, LPSPropValue rgprop,
        LPALLOCATEBUFFER lpAllocateBuffer, LPSPropValue FAR *prgprop);


/* General utility functions */

/* Related to the OLE Component object model */

STDAPI_(ULONG)          UlAddRef(LPVOID punk);
STDAPI_(ULONG)          UlRelease(LPVOID punk);

/* Related to the MAPI interface */

STDAPI                  HrGetOneProp(LPMAPIPROP pmp, ULONG ulPropTag,
                        LPSPropValue FAR *ppprop);
STDAPI                  HrSetOneProp(LPMAPIPROP pmp, LPSPropValue pprop);
STDAPI_(BOOL)           FPropExists(LPMAPIPROP pobj, ULONG ulPropTag);
STDAPI_(LPSPropValue)   PpropFindProp(LPSPropValue rgprop, ULONG cprop, ULONG ulPropTag);
STDAPI_(void)           FreePadrlist(LPADRLIST padrlist);
STDAPI_(void)           FreeProws(LPSRowSet prows);
STDAPI                  HrQueryAllRows(LPMAPITABLE ptable, 
                        LPSPropTagArray ptaga, LPSRestriction pres,
                        LPSSortOrderSet psos, LONG crowsMax,
                        LPSRowSet FAR *pprows);

/* Create or validate the IPM folder tree in a message store */

#define MAPI_FORCE_CREATE   1
#define MAPI_FULL_IPM_TREE  2

STDAPI                  HrValidateIPMSubtree(LPMDB pmdb, ULONG ulFlags,
                        ULONG FAR *pcValues, LPSPropValue FAR *prgprop,
                        LPMAPIERROR FAR *pperr);

/* Encoding and decoding strings */

STDAPI_(BOOL)           FBinFromHex(LPTSTR sz, LPBYTE pb);
STDAPI_(SCODE)          ScBinFromHexBounded(LPTSTR sz, LPBYTE pb, ULONG cb);
STDAPI_(void)           HexFromBin(LPBYTE pb, int cb, LPTSTR sz);
STDAPI_(ULONG)          UlFromSzHex(LPCTSTR sz);
STDAPI_(void)           EncodeID(LPBYTE, ULONG, LPTSTR);
STDAPI_(BOOL)           FDecodeID(LPTSTR, LPBYTE, ULONG *);
STDAPI_(ULONG)          CchOfEncoding(ULONG);
STDAPI_(ULONG)          CbOfEncoded(LPTSTR);
STDAPI_(int)            CchEncodedLine(int);

/* Encoding and decoding entry IDs */
STDAPI                  HrEntryIDFromSz(LPTSTR sz, ULONG FAR *pcb,
                        LPENTRYID FAR *ppentry);
STDAPI                  HrSzFromEntryID(ULONG cb, LPENTRYID pentry,
                        LPTSTR FAR *psz);
STDAPI                  HrComposeEID(LPMAPISESSION psession,
                        ULONG cbStoreSearchKey, LPBYTE pStoreSearchKey,
                        ULONG cbMsgEID, LPENTRYID pMsgEID,
                        ULONG FAR *pcbEID, LPENTRYID FAR *ppEID);
STDAPI                  HrDecomposeEID(LPMAPISESSION psession,
                        ULONG cbEID, LPENTRYID pEID,
                        ULONG FAR *pcbStoreEID, LPENTRYID FAR *ppStoreEID,
                        ULONG FAR *pcbMsgEID, LPENTRYID FAR *ppMsgEID);
STDAPI                  HrComposeMsgID(LPMAPISESSION psession,
                        ULONG cbStoreSearchKey, LPBYTE pStoreSearchKey,
                        ULONG cbMsgEID, LPENTRYID pMsgEID,
                        LPTSTR FAR *pszMsgID);
STDAPI                  HrDecomposeMsgID(LPMAPISESSION psession,
                        LPTSTR szMsgID,
                        ULONG FAR *pcbStoreEID, LPENTRYID FAR *ppStoreEID,
                        ULONG FAR *pcbMsgEID, LPENTRYID FAR *ppMsgEID);

/* C runtime substitutes */

typedef int (__cdecl FNSGNCMP)(const void FAR *pv1, const void FAR *pv2);
typedef FNSGNCMP FAR *PFNSGNCMP;

STDAPI_(LPTSTR)         SzFindCh(LPCTSTR sz, USHORT ch);            /* strchr */
STDAPI_(LPTSTR)         SzFindLastCh(LPCTSTR sz, USHORT ch);        /* strrchr */
STDAPI_(LPTSTR)         SzFindSz(LPCTSTR sz, LPCTSTR szKey);
STDAPI_(unsigned int)   UFromSz(LPCTSTR sz);                        /* atoi */
STDAPI_(void)           ShellSort(LPVOID pv, UINT cv,           /* qsort */
                        LPVOID pvT, UINT cb, PFNSGNCMP fpCmp);

FNSGNCMP                SgnCmpPadrentryByType;

STDAPI_(SCODE)          ScUNCFromLocalPath(LPSTR szLocal, LPSTR szUNC,
                        UINT cchUNC);
STDAPI_(SCODE)          ScLocalPathFromUNC(LPSTR szUNC, LPSTR szLocal,
                        UINT cchLocal);

/* 64-bit arithmetic with times */

STDAPI_(FILETIME)       FtAddFt(FILETIME Addend1, FILETIME Addend2);
STDAPI_(FILETIME)       FtMulDwDw(DWORD Multiplicand, DWORD Multiplier);
STDAPI_(FILETIME)       FtMulDw(DWORD Multiplier, FILETIME Multiplicand);
STDAPI_(FILETIME)       FtSubFt(FILETIME Minuend, FILETIME Subtrahend);
STDAPI_(FILETIME)       FtNegFt(FILETIME ft);


STDAPI WrapStoreEntryID (ULONG ulFlags, LPTSTR szDLLName, ULONG cbOrigEntry,
    LPENTRYID lpOrigEntry, ULONG *lpcbWrappedEntry, LPENTRYID *lppWrappedEntry);

/* RTF Sync Utilities */

#define RTF_SYNC_RTF_CHANGED    ((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED   ((ULONG) 0x00000002)

STDAPI_(HRESULT)
RTFSync (LPMESSAGE lpMessage, ULONG ulFlags, BOOL FAR * lpfMessageUpdated);

STDAPI_(HRESULT)
WrapCompressedRTFStream (LPSTREAM lpCompressedRTFStream,
        ULONG ulFlags, LPSTREAM FAR * lpUncompressedRTFStream);

/* Storage on Stream */

#if defined(WIN32) || defined(WIN16)
STDAPI_(HRESULT)
HrIStorageFromStream (LPUNKNOWN lpUnkIn,
    LPCIID lpInterface, ULONG ulFlags, LPSTORAGE FAR * lppStorageOut);
#endif


#ifdef __cplusplus
}
#endif

#endif /* _MAPIUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mspab.h ===
/*
 *  M S P A B . H
 *  
 *  Public definitions for the Microsoft Personal Address Book
 *  
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

/*
 *  Microsoft Personal Address Book Provider ID
 *  -------------------------------------------
 */

#define PAB_PROVIDER_ID     \
{                           \
    0xB5, 0x3b, 0xc2, 0xc0, \
    0x2c, 0x77, 0x10, 0x1a, \
    0xa1, 0xbc, 0x08, 0x00, \
    0x2b, 0x2a, 0x56, 0xc2  \
}


/*
 *  Messaging Service Properties
 *  ----------------------------
 *
 *  The following properties are required to completely configure
 *  the Microsoft Personal Address Book messaging service with
 *  IMsgServiceAdmin::ConfigureMsgService() if UI is not requested
 *  by passing the UI_SERVICE flag.
 */

/*
 *      Fully qualified pathname of .PAB file to use
 */
#define     PR_PAB_PATH                     PROP_TAG( PT_TSTRING,   0x6600 )
#define     PR_PAB_PATH_W                   PROP_TAG( PT_UNICODE,   0x6600 )
#define     PR_PAB_PATH_A                   PROP_TAG( PT_STRING8,   0x6600 )

/*
 *  The following additional properties may also be passed to
 *  customize the configuration.
 */

/*
 *      PR_DISPLAY_NAME
 *          The display name to be used for the PAB in the address
 *          book hierarchy.
 *
 *      PR_COMMENT
 *          A comment to be associated with the PAB.
 *
 *      PR_PAB_DET_DIR_VIEW_BY
 *          Determines how names of entries in the PAB with separate first
 *          and last names are displayed.
 *
 *          Possible values are:
 *
 *          PAB_DIR_VIEW_FIRST_THEN_LAST    First name followed by last name
 *          (default)                       (e.g. "Dave Olsen").
 *
 *          PAB_DIR_VIEW_LAST_THEN_FIRST    Last name followed by separator
 *                                          followed by first name
 *                                          (e.g. "Olsen, Dave").
 *
 *      PR_PAB_SORT_ORDER
 *          Determines order in which entries in the PAB are displayed.
 *          The value is a binary which is a SSortOrderSet.  The default
 *          sort order is ascending by PR_DISPLAY_NAME.
 */
#define     PR_PAB_DET_DIR_VIEW_BY          PROP_TAG( PT_LONG,      0x6601 )
#define     PR_PAB_DIR_SORT_ORDER           PROP_TAG( PT_BINARY,    0x6603 )

#define     PAB_DIR_VIEW_FIRST_THEN_LAST    0
#define     PAB_DIR_VIEW_LAST_THEN_FIRST    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mapix.h ===
/*
 *  M A P I X . H
 *  
 *  Definitions of objects/flags, etc used by Extended MAPI.
 *  
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIX_H
#define MAPIX_H

/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#ifdef  __cplusplus
extern "C" {
#endif  

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/* Forward interface declarations */

DECLARE_MAPI_INTERFACE_PTR(IProfAdmin,          LPPROFADMIN);
DECLARE_MAPI_INTERFACE_PTR(IMsgServiceAdmin,    LPSERVICEADMIN);

/* ------------------------------------------------------ */
/* shared with simple mapi */

typedef ULONG       FLAGS;

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI                 */
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session         */
#define MAPI_ALLOW_OTHERS       0x00000008  /* Make this a shared session       */
#define MAPI_EXPLICIT_PROFILE   0x00000010  /* Don't use default profile        */
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon              */
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return       */
#define MAPI_SERVICE_UI_ALWAYS  0x00002000  /* Do logon UI in all providers     */
#define MAPI_NO_MAIL            0x00008000  /* Do not activate transports       */
#define MAPI_NT_SERVICE         0x00010000  /* Allow logon from an NT service   */
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI        0x00020000  /* Display password UI only         */
#endif
#define MAPI_TIMEOUT_SHORT      0x00100000  /* Minimal wait for logon resources */

#define MAPI_SIMPLE_DEFAULT (MAPI_LOGON_UI | MAPI_FORCE_DOWNLOAD | MAPI_ALLOW_OTHERS)
#define MAPI_SIMPLE_EXPLICIT (MAPI_NEW_SESSION | MAPI_FORCE_DOWNLOAD | MAPI_EXPLICIT_PROFILE)

/* Structure passed to MAPIInitialize(), and its ulFlags values */

typedef struct
{
    ULONG           ulVersion;
    ULONG           ulFlags;
} MAPIINIT_0, FAR *LPMAPIINIT_0;

typedef MAPIINIT_0 MAPIINIT;
typedef MAPIINIT FAR *LPMAPIINIT;

#define MAPI_INIT_VERSION               0

#define MAPI_MULTITHREAD_NOTIFICATIONS  0x00000001
/* #define MAPI_NT_SERVICE              0x00010000  Use from NT service */

/* MAPI base functions */

typedef HRESULT (STDAPICALLTYPE MAPIINITIALIZE)(
    LPVOID          lpvReserved
);
typedef MAPIINITIALIZE FAR *LPMAPIINITIALIZE;

typedef void (STDAPICALLTYPE MAPIUNINITIALIZE)(void);
typedef MAPIUNINITIALIZE FAR *LPMAPIUNINITIALIZE;

MAPIINITIALIZE      MAPIInitialize;
MAPIUNINITIALIZE    MAPIUninitialize;

#ifndef MAPILogon

typedef ULONG (FAR PASCAL MAPILOGONA)(
    ULONG ulUIParam,
    LPSTR lpszProfileName,
    LPSTR lpszPassword,
    FLAGS flFlags,
    ULONG ulReserved,
    LPLHANDLE lplhSession
);
typedef MAPILOGONA FAR *LPMAPILOGONA;

typedef ULONG (FAR PASCAL MAPILOGONW)(
    ULONG ulUIParam,
    LPWSTR lpszProfileName,
    LPWSTR lpszPassword,
    FLAGS flFlags,
    ULONG ulReserved,
    LPLHANDLE lplhSession
);
typedef MAPILOGONW FAR *LPMAPILOGONW;

MAPILOGONA MAPILogonA;
MAPILOGONW MAPILogonW;

#ifdef UNICODE
#define MAPILogon MAPILogonW
#else
#define MAPILogon MAPILogonA
#endif

#endif  /* MAPILogon */

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEBUFFER)(
    ULONG           cbSize,
    LPVOID FAR *    lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEMORE)(
    ULONG           cbSize,
    LPVOID          lpObject,
    LPVOID FAR *    lppBuffer
);

typedef ULONG (STDAPICALLTYPE MAPIFREEBUFFER)(
    LPVOID          lpBuffer
);

typedef MAPIALLOCATEBUFFER FAR  *LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE FAR    *LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER FAR      *LPMAPIFREEBUFFER;

MAPIALLOCATEBUFFER MAPIAllocateBuffer;
MAPIALLOCATEMORE MAPIAllocateMore;
MAPIFREEBUFFER MAPIFreeBuffer;

typedef HRESULT (STDMETHODCALLTYPE MAPIADMINPROFILES)(
    ULONG ulFlags,
    LPPROFADMIN FAR *lppProfAdmin
);

typedef MAPIADMINPROFILES FAR *LPMAPIADMINPROFILES;

MAPIADMINPROFILES MAPIAdminProfiles;

/* IMAPISession Interface -------------------------------------------------- */

/* Flags for OpenEntry and others */

/*#define MAPI_MODIFY               ((ULONG) 0x00000001) */

/* Flags for Logoff */

#define MAPI_LOGOFF_SHARED      0x00000001  /* Close all shared sessions    */
#define MAPI_LOGOFF_UI          0x00000002  /* It's OK to present UI        */

/* Flags for SetDefaultStore. They are mutually exclusive. */

#define MAPI_DEFAULT_STORE          0x00000001  /* for incoming messages */
#define MAPI_SIMPLE_STORE_TEMPORARY 0x00000002  /* for simple MAPI and CMC */
#define MAPI_SIMPLE_STORE_PERMANENT 0x00000003  /* for simple MAPI and CMC */

/* Flags for ShowForm. */

#define MAPI_POST_MESSAGE       0x00000001  /* Selects post/send semantics */
#define MAPI_NEW_MESSAGE        0x00000002  /* Governs copying during submission */

/*  MessageOptions */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  QueryDefaultMessageOpt */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IMAPISESSION_METHODS(IPURE)                                \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetMsgStoresTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenMsgStore)                                            \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMDB FAR *                 lppMDB) IPURE;              \
    MAPIMETHOD(OpenAddressBook)                                         \
        (THIS_  ULONG                       ulUIParam,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPADRBOOK FAR *             lppAdrBook) IPURE;          \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \
    MAPIMETHOD(GetStatusTable)                                          \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;  \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(MessageOptions)                                          \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszAdrType,                \
                LPMESSAGE                   lpMessage) IPURE;           \
    MAPIMETHOD(QueryDefaultMessageOpt)                                  \
        (THIS_  LPTSTR                      lpszAdrType,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppOptions) IPURE;          \
    MAPIMETHOD(EnumAdrTypes)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcAdrTypes,                \
                LPTSTR FAR * FAR *          lpppszAdrTypes) IPURE;      \
    MAPIMETHOD(QueryIdentity)                                           \
        (THIS_  ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(Logoff)                                                  \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       ulReserved) IPURE;          \
    MAPIMETHOD(SetDefaultStore)                                         \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(AdminServices)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSERVICEADMIN FAR *        lppServiceAdmin) IPURE;     \
    MAPIMETHOD(ShowForm)                                                \
        (THIS_  ULONG                       ulUIParam,                  \
                LPMDB                       lpMsgStore,                 \
                LPMAPIFOLDER                lpParentFolder,             \
                LPCIID                      lpInterface,                \
                ULONG                       ulMessageToken,             \
                LPMESSAGE                   lpMessageSent,              \
                ULONG                       ulFlags,                    \
                ULONG                       ulMessageStatus,            \
                ULONG                       ulMessageFlags,             \
                ULONG                       ulAccess,                   \
                LPSTR                       lpszMessageClass) IPURE;    \
    MAPIMETHOD(PrepareForm)                                             \
        (THIS_  LPCIID                      lpInterface,                \
                LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulMessageToken) IPURE;    \


#undef       INTERFACE
#define      INTERFACE  IMAPISession
DECLARE_MAPI_INTERFACE_(IMAPISession, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPISESSION_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPISession, LPMAPISESSION);

/* IAddrBook Interface ----------------------------------------------------- */

/*  RecipOptions */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  QueryDefaultRecipOpt */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  GetSearchPath */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */


#define MAPI_IADDRBOOK_METHODS(IPURE)                                   \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;  \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(CreateOneOff)                                            \
        (THIS_  LPTSTR                      lpszName,                   \
                LPTSTR                      lpszAdrType,                \
                LPTSTR                      lpszAddress,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(NewEntry)                                                \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       cbEIDContainer,             \
                LPENTRYID                   lpEIDContainer,             \
                ULONG                       cbEIDNewEntryTpl,           \
                LPENTRYID                   lpEIDNewEntryTpl,           \
                ULONG FAR *                 lpcbEIDNewEntry,            \
                LPENTRYID FAR *             lppEIDNewEntry) IPURE;      \
    MAPIMETHOD(ResolveName)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszNewEntryTitle,          \
                LPADRLIST                   lpAdrList) IPURE;           \
    MAPIMETHOD(Address)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPADRPARM                   lpAdrParms,                 \
                LPADRLIST FAR *             lppAdrList) IPURE;          \
    MAPIMETHOD(Details)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPFNDISMISS                 lpfnDismiss,                \
                LPVOID                      lpvDismissContext,          \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPFNBUTTON                  lpfButtonCallback,          \
                LPVOID                      lpvButtonContext,           \
                LPTSTR                      lpszButtonText,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(RecipOptions)                                            \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPADRENTRY                  lpRecip) IPURE;             \
    MAPIMETHOD(QueryDefaultRecipOpt)                                    \
        (THIS_  LPTSTR                      lpszAdrType,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppOptions) IPURE;          \
    MAPIMETHOD(GetPAB)                                                  \
        (THIS_  ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(SetPAB)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetDefaultDir)                                           \
        (THIS_  ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(SetDefaultDir)                                           \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetSearchPath)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppSearchPath) IPURE;       \
    MAPIMETHOD(SetSearchPath)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet                   lpSearchPath) IPURE;        \
    MAPIMETHOD(PrepareRecips)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray             lpPropTagArray,             \
                LPADRLIST                   lpRecipList) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook, IMAPIProp)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook, LPADRBOOK);

/* IProfAdmin Interface ---------------------------------------------------- */

/* Flags for CreateProfile */
#define MAPI_DEFAULT_SERVICES           0x00000001

/* GetProfileTable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IPROFADMIN_METHODS(IPURE)                                  \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetProfileTable)                                         \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateProfile)                                           \
        (THIS_  LPTSTR                      lpszProfileName,            \
                LPTSTR                      lpszPassword,               \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteProfile)                                           \
        (THIS_  LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ChangeProfilePassword)                                   \
        (THIS_  LPTSTR                      lpszProfileName,            \
                LPTSTR                      lpszOldPassword,            \
                LPTSTR                      lpszNewPassword,            \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CopyProfile)                                             \
        (THIS_  LPTSTR                      lpszOldProfileName,         \
                LPTSTR                      lpszOldPassword,            \
                LPTSTR                      lpszNewProfileName,         \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(RenameProfile)                                           \
        (THIS_  LPTSTR                      lpszOldProfileName,         \
                LPTSTR                      lpszOldPassword,            \
                LPTSTR                      lpszNewProfileName,         \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetDefaultProfile)                                       \
        (THIS_  LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(AdminServices)                                           \
        (THIS_  LPTSTR                      lpszProfileName,            \
                LPTSTR                      lpszPassword,               \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPSERVICEADMIN FAR *        lppServiceAdmin) IPURE;     \


#undef       INTERFACE
#define      INTERFACE  IProfAdmin
DECLARE_MAPI_INTERFACE_(IProfAdmin, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IPROFADMIN_METHODS(PURE)
};

/* IMsgServiceAdmin Interface ---------------------------------------------- */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define SERVICE_DEFAULT_STORE       0x00000001
#define SERVICE_SINGLE_COPY         0x00000002
#define SERVICE_CREATE_WITH_STORE   0x00000004
#define SERVICE_PRIMARY_IDENTITY    0x00000008
#define SERVICE_NO_PRIMARY_IDENTITY 0x00000020

/*  GetMsgServiceTable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  GetProviderTable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IMSGSERVICEADMIN_METHODS(IPURE)                            \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetMsgServiceTable)                                      \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateMsgService)                                        \
        (THIS_  LPTSTR                      lpszService,                \
                LPTSTR                      lpszDisplayName,            \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteMsgService)                                        \
        (THIS_  LPMAPIUID                   lpUID) IPURE;               \
    MAPIMETHOD(CopyMsgService)                                          \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPTSTR                      lpszDisplayName,            \
                LPCIID                      lpInterfaceToCopy,          \
                LPCIID                      lpInterfaceDst,             \
                LPVOID                      lpObjectDst,                \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(RenameMsgService)                                        \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszDisplayName) IPURE;     \
    MAPIMETHOD(ConfigureMsgService)                                     \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       cValues,                    \
                LPSPropValue                lpProps) IPURE;             \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \
    MAPIMETHOD(MsgServiceTransportOrder)                                \
        (THIS_  ULONG                       cUID,                       \
                LPMAPIUID                   lpUIDList,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(AdminProviders)                                          \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulFlags,                    \
                LPPROVIDERADMIN FAR *       lppProviderAdmin) IPURE;    \
    MAPIMETHOD(SetPrimaryIdentity)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetProviderTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \


#undef       INTERFACE
#define      INTERFACE  IMsgServiceAdmin
DECLARE_MAPI_INTERFACE_(IMsgServiceAdmin, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMSGSERVICEADMIN_METHODS(PURE)
};

#ifdef  __cplusplus
}       /*  extern "C" */
#endif  

#endif /* MAPIX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mapiwin.h ===
/*
 *  M A P I W I N . H
 *
 *  Definitions used by the MAPI Development Team to aid in
 *  developing single-source service providers that run on
 *  both WIN32 and WIN16 platforms.
 *  There are three sections.
 *
 *  The first section defines how to call something that
 *  is available by different methods in WIN16 vs. WIN32.
 *  As such, they are totally new mechanisms.
 *
 *  The second section establishes things that are available
 *  AS-IS in one environment but we have to define for the
 *  other environment.
 *
 *  The third section simply defines a few conventions
 *  (simplifications) for common operations.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

/*
 *  Routines are included in the first section to manage per-instance
 *  global variables for DLLs. They assume that all of the DLL's
 *  per-instance global variables live in a single block of memory.
 *  Functions are provided to install and retrieve the correct block of
 *  memory for the current instance.
 *
 *  There are only two functions:
 *
 *      PvGetInstanceGlobals    Call this to get the address of the
 *                              per-instance globals structure.
 *      ScSetinstanceGlobals    Call this to install the
 *                              per-instance globals structure. It
 *                              may fail if the number of instances
 *                              exceeds a certain limit.
 *
 *  The caller is free to choose the name, size, and allocation
 *  method of the per-instance global variables structure.
 *
 *  The WIN32 implementation uses a pointer in the DLL's data
 *  segment. This assumes that the DLL gets a separate instance
 *  of the default data segment per calling process.
 *
 *  The WIN16 implementation uses a fixed array of pointers and a
 *  matching fixed array of keys unique to the calling process.
 */

/*
 *  The second section consists largely of Win32 file I/O functions
 *  that are not supported under Win16. These functions are
 *  implemented in mapiwin.c, using DOS calls. Most have limitations
 *  relative to their Win32 counterparts, which are spelled out in
 *  the comments to the source code.
 */

#ifndef __MAPIWIN_H__
#define __MAPIWIN_H__

#include "mapinls.h"

#ifdef __cplusplus
extern "C" {
#endif


/********************************/
/*  Our conventions for things  */
/*  we choose to do differently */
/*  on WIN16 vs. WIN32.         */
/********************************/

#ifdef  WIN16

#define MULDIV(x,y,z)               MulDiv32(x,y,z)
#define IsBadReadPtr(lp,cb)         FBadReadPtr(lp,cb)

#define cInstMax                    50
LPVOID FAR PASCAL   PvGetInstanceGlobals(void);
LONG FAR PASCAL     ScSetInstanceGlobals(LPVOID pv);
LONG FAR PASCAL     ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid);
LPVOID FAR PASCAL   PvGetVerifyInstanceGlobals(DWORD dwPid);
LPVOID FAR PASCAL   PvSlowGetInstanceGlobals(DWORD dwPid);
BOOL __export FAR PASCAL FCleanupInstanceGlobals(WORD, DWORD);

#elif defined(MAC)  /* !WIN16 */

#define MULDIV(x,y,z)               MulDiv(x,y,z)

LPVOID FAR PASCAL   PvGetInstanceGlobals(WORD wDataSet);
LONG FAR PASCAL     ScSetInstanceGlobals(LPVOID pv, WORD wDataSet);
LONG FAR PASCAL     ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid,
                        WORD wDataSet);
LPVOID FAR PASCAL   PvGetVerifyInstanceGlobals(DWORD dwPid, DWORD wDataSet);
LPVOID FAR PASCAL   PvSlowGetInstanceGlobals(DWORD dwPid, DWORD wDataSet);
BOOL FAR PASCAL     FCleanupInstanceGlobals(WORD, DWORD);

#else   /* !WIN16 */

#define MULDIV(x,y,z)               MulDiv(x,y,z)

extern LPVOID pinstX;
#define PvGetInstanceGlobals()                  pinstX
#define ScSetInstanceGlobals(_pv)               (pinstX = _pv, 0)
#define PvGetVerifyInstanceGlobals(_pid)        pinstX
#define ScSetVerifyInstanceGlobals(_pv,_pid)    (pinstX = _pv, 0)
#define PvSlowGetInstanceGlobals(_pid)          pinstX

#endif  /* WIN16 */

#if defined(CHICAGO)
#define szMAPIDLLSuffix     "32"
#elif defined(WIN32) && !defined(MAC)
#define szMAPIDLLSuffix     "32"
#elif defined(WIN16) || defined(DOS) || defined(MAC)
#define szMAPIDLLSuffix     ""
#else
#error "Don't know the suffix for DLLs on this platform"
#endif

/********************************/
/*  Things missing from one     */
/*  system-provided environment */
/*  or the other.               */
/********************************/

#if !defined(WIN32) 
#define ZeroMemory(pb,cb)           memset((pb),0,(cb))
#define FillMemory(pb,cb,b)         memset((pb),(b),(cb))
#define CopyMemory(pbDst,pbSrc,cb)  do                              \
                                    {                               \
                                        size_t _cb = (size_t)(cb);  \
                                        if (_cb)                    \
                                            memcpy(pbDst,pbSrc,_cb);\
                                    } while (FALSE)
#define MoveMemory(pbDst,pbSrc,cb)  memmove((pbDst),(pbSrc),(cb))
#endif

#if defined(WIN16) || defined(MAC)

#ifndef MAC
#include <error.h>              /*  for GetLastError() */
#endif

typedef int                 INT;
typedef unsigned long       ULONG;
typedef short               SHORT;
typedef unsigned short      USHORT;
typedef double              LONGLONG;
typedef double              DWORDLONG;
typedef unsigned char       UCHAR;
typedef unsigned char FAR*  PUCHAR;
typedef int                 BOOL;


#ifndef MAC
typedef char                BOOLEAN;

#ifndef _FILETIME_
#define _FILETIME_
typedef struct tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif      /* _FILETIME */

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, FAR *LPSYSTEMTIME;

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    CHAR StandardName[ 32 ];        /* was WCHAR */
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    CHAR DaylightName[ 32 ];        /* was WCHAR */
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, FAR *LPTIME_ZONE_INFORMATION;


#define TEXT(quote)     quote


#define APIENTRY        WINAPI

#define SetForegroundWindow         SetActiveWindow

#define wsprintfA                   wsprintf
#define GetWindowsDirectoryA        GetWindowsDirectory
#define GetSystemDirectoryA         GetSystemDirectory
#define GetPrivateProfileStringA    GetPrivateProfileString
#define GetPrivateProfileIntA       GetPrivateProfileInt
#define GetProfileStringA           GetProfileString
#define GetModuleFileNameA          GetModuleFileName
#define CharUpperBuffA              CharUpperBuff
#define LoadLibraryA                LoadLibrary
#define lstrcatA                    lstrcat
#define RegisterWindowMessageA      RegisterWindowMessage
#define MAKEINTRESOURCEA            MAKEINTRESOURCE

#define WNDCLASSA                   WNDCLASS                                    

#endif  /* !MAC */

/* Synchronization */
#define InterlockedIncrement(plong) (++(*(plong)))
#define InterlockedDecrement(plong) (--(*(plong)))

#ifndef CreateMutex
#define CreateMutexA    CreateMutex
#define CreateMutexW    CreateMutex
#define CreateMutex(pv, bool, sz)   (INVALID_HANDLE_VALUE)
#endif

#define WaitForSingleObject(hObj, dw)   ((void)0)
#define ReleaseMutex(hObj)              ((BOOL)1)
#define CloseMutexHandle(hObj)          TRUE

#define CRITICAL_SECTION            ULONG
#define InitializeCriticalSection(_pcs) ((void)0)
#define DeleteCriticalSection(_pcs)     ((void)0)
#define EnterCriticalSection(_pcs)      ((void)0)
#define LeaveCriticalSection(_pcs)      ((void)0)

#define MAX_PATH                    260

#ifndef MAC
/*
 *  File Access Modes
 *
 *  The possible combination of file access modes as passed into
 *  the CreateFile() api map to OpenFile() as follows:
 *
 *   GENERIC_READ                       OPEN_ACCESS_READONLY
 *   GENERIC_WRITE                      OPEN_ACCESS_WRITEONLY
 *   GENERIC_READ | GENERIC_WRITE       OPEN_ACCESS_READWRITE
 *
 *   0                                  OPEN_SHARE_DENYREADWRITE
 *   FILE_SHARE_READ                    OPEN_SHARE_DENYWRITE
 *   FILE_SHARE_WRITE                   OPEN_SHARE_DENYREAD
 *   FILE_SHARE_READ | FILE_SHARE_WRITE OPEN_SHARE_DENYNONE
 *
 *  Due to the mappings we cannot pass them through directly,
 *  so we will have to use a conversion within APIs that test
 *  these bits.  It would be best to use the WIN32 #defines
 *  for these flags and convert as needed in the APIs.
 */
#define GENERIC_READ                (0x80000000) /* from WINNT.H */
#define GENERIC_WRITE               (0x40000000) /* from WINNT.H */
#define FILE_SHARE_READ             (0x00000001) /* from WINNT.H */
#define FILE_SHARE_WRITE            (0x00000002) /* from WINNT.H */
#endif  /* MAC */

#define FILE_FLAG_SEQUENTIAL_SCAN   0x08000000

#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5

#ifndef MAC
#define INVALID_HANDLE_VALUE        ((HANDLE)(-1))
#define DELETE                      0x00010000L

#define FILE_BEGIN                  0
#define FILE_CURRENT                1
#define FILE_END                    2
#endif

#define FILE_ATTRIBUTE_READONLY         0x00000001
#define FILE_ATTRIBUTE_HIDDEN           0x00000002
#define FILE_ATTRIBUTE_SYSTEM           0x00000004
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020
#define FILE_ATTRIBUTE_NORMAL           0x00000080
#define FILE_ATTRIBUTE_TEMPORARY        0x00000100

#define FILE_FLAG_WRITE_THROUGH     0x80000000
#define FILE_FLAG_RANDOM_ACCESS     0x10000000

#ifndef MAC
typedef struct _WIN32_FIND_DATA {
    DWORD       dwFileAttributes;
    FILETIME    ftCreationTime;
    FILETIME    ftLastAccessTime;
    FILETIME    ftLastWriteTime;
    DWORD       nFileSizeHigh;
    DWORD       nFileSizeLow;
    DWORD       dwReserved0;
    DWORD       dwReserved1;
    CHAR        cFileName[ MAX_PATH ];
    CHAR        cAlternateFileName[ 16 ];
} WIN32_FIND_DATA, *PWIN32_FIND_DATA, *LPWIN32_FIND_DATA;

#define TIME_ZONE_ID_INVALID        0xFFFFFFFF
#endif
#define TIME_ZONE_ID_UNKNOWN        0
#define TIME_ZONE_ID_STANDARD       1
#define TIME_ZONE_ID_DAYLIGHT       2



DWORD WINAPI    GetLastError(void);
DWORD WINAPI    GetFileAttributes(LPCSTR lpFileName);
DWORD WINAPI    GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
BOOL WINAPI     GetFileTime(HANDLE hFile, FILETIME FAR *lpftCreation,
                FILETIME FAR *lpftLastAccess, FILETIME FAR *lpftLastWrite);
#ifndef MAC
HANDLE WINAPI   CreateFile(LPCSTR lpFileName, DWORD dwDesiredAccess,
                DWORD dwShareMode, LPVOID lpSecurityAttributes,
                DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
                HANDLE hTemplateFile);
BOOL WINAPI     ReadFile(HANDLE hFile, LPVOID lpBuffer,
                DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead,
                LPVOID lpOverlapped);
BOOL WINAPI     WriteFile(HANDLE hFile, LPCVOID lpBuffer,
                DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten,
                LPVOID lpOverlapped);
#endif
DWORD WINAPI    SetFilePointer(HANDLE hFile, LONG lDistanceToMove,
                LONG FAR *lpDistanceToMoveHigh, DWORD dwMoveMethod);
BOOL WINAPI     SetEndOfFile(HANDLE hFile);
BOOL WINAPI     CloseHandle(HANDLE hObject);
DWORD WINAPI    GetTempPath(DWORD nBufferLength, LPSTR lpBuffer);
UINT WINAPI     GetTempFileName32 (LPCSTR lpPathName, LPCSTR lpPrefixString,
                UINT uUnique, LPSTR lpTempFileName);
BOOL WINAPI     DeleteFile(LPCSTR lpFileName);
#ifndef MAC
BOOL WINAPI     CreateDirectory(LPCSTR lpPathName, LPVOID lpSecurityAttributes);
#endif
BOOL WINAPI     RemoveDirectory(LPCSTR lpPathName);
BOOL WINAPI     CopyFile(LPCSTR szSrc, LPCSTR szDst, BOOL fFailIfExists);
BOOL WINAPI     MoveFile(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
HANDLE WINAPI   FindFirstFile(LPCSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);
BOOL WINAPI     FindNextFile(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData);
BOOL WINAPI     FindClose(HANDLE hFindFile);
DWORD WINAPI    GetFullPathName(LPCSTR lpFileName, DWORD nBufferLength,
                LPSTR lpBuffer, LPSTR *lpFilePart);
void WINAPI     Sleep(DWORD dwMilliseconds);
LONG WINAPI     CompareFileTime(const FILETIME FAR *, const FILETIME FAR *);
BOOL WINAPI     LocalFileTimeToFileTime(const FILETIME FAR *, FILETIME FAR *);
BOOL WINAPI     FileTimeToLocalFileTime(const FILETIME FAR *, FILETIME FAR *);
BOOL WINAPI     FileTimeToSystemTime(const FILETIME FAR *, SYSTEMTIME FAR *);
BOOL WINAPI     SystemTimeToFileTime(const SYSTEMTIME FAR *, FILETIME FAR *);
void WINAPI     GetSystemTime(SYSTEMTIME FAR *);
void WINAPI     GetLocalTime(SYSTEMTIME FAR *);
BOOL WINAPI     FileTimeToDosDateTime(const FILETIME FAR * lpFileTime,
                WORD FAR *lpFatDate, WORD FAR *lpFatTime);
BOOL WINAPI     DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime,
                FILETIME FAR * lpFileTime);
DWORD WINAPI    GetTimeZoneInformation(
                LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
BOOL WINAPI     SetTimeZoneInformation(
                const TIME_ZONE_INFORMATION FAR *lpTimeZoneInformation);

DWORD WINAPI    GetCurrentProcessId(void);
long WINAPI     MulDiv32(long, long, long);
#ifndef MAC
BOOL WINAPI     FBadReadPtr(const void FAR* lp, UINT cb);
#endif

#else   /* !WIN16 */

/* Remaps GetTempFileName32() to the real 32bit version */

#define GetTempFileName32(_szPath,_szPfx,_n,_lpbuf) GetTempFileName(_szPath,_szPfx,_n,_lpbuf)

#define CloseMutexHandle    CloseHandle

#endif  /* !WIN16 */


#ifdef MAC
#define CRITICAL_SECTION            ULONG
#define InitializeCriticalSection(_pcs) ((void)0)
#define DeleteCriticalSection(_pcs)     ((void)0)
#define EnterCriticalSection(_pcs)      ((void)0)
#define LeaveCriticalSection(_pcs)      ((void)0)
#endif

/********************************/
/*  Our private conventions     */
/*  (common to WIN16/WIN32)     */
/********************************/

#define Cbtszsize(_a)   ((lstrlen(_a)+1)*sizeof(TCHAR))
#define CbtszsizeA(_a)  ((lstrlenA(_a) + 1))
#define CbtszsizeW(_a)  ((lstrlenW(_a) + 1) * sizeof(WCHAR))
#define HexCchOf(_s)    (sizeof(_s)*2+1)
#define HexSizeOf(_s)   (HexCchOf(_s)*sizeof(TCHAR))

BOOL WINAPI IsBadBoundedStringPtr(const void FAR* lpsz, UINT cchMax);

/* FUTURE - obsolete. OLE2 no longer contains these */
#define GetSCode                    GetScode
#define ReportResult(_a,_b,_c,_d)   ResultFromScode(_b)

#ifdef __cplusplus
}
#endif

#endif /* __MAPIWIN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\msfs.h ===
#if !defined( _MSFS_H )
#define _MSFS_H

/*
 *  M S F S . H
 *
 *
 *  Copyright Microsoft Corporation 1993-1995, All Rights Reserved
 *
 *
 *  Definitions used by the the Microsoft Mail transport, address book
 *  and shared folder service providers.  CFG properties are programatically 
 *  configurable via calls to ConfigureMsgService().  
 *
 *  The following MSFS defined properties are configurable via ConfigureMsgService()
 *  calls.  They are grouped by function.
 *
 *  C o n n e c t i o n   P r o p e r t i e s
 *
 *  PR_CFG_SERVER_PATH
 *      --  The path to the users post office.  Mapped network drives, UNC and NETWARE paths
 *          are acceptable.  NETWARE paths of the type NWServer/share:dir\dir1 are converted to 
 *          UNC paths of the type \\NWServer\share\dir\dir1. 
 *          $REVIEW: If no path is specified, the path will default to the path found in MAIL.DAT
 *                   or if MAIL.DAT is not found to m:
 *
 *  PR_CFG_MAILBOX
 *      --  The users mailbox name.  eg. in a NET/PO/USER address,
 *          this is USER.  The maximum mailbox name is 10 characters.
 *
 *  PR_CFG_PASSWORD
 *      --  The users mailbox password.  The maximum password is 8 characters.
 *
 *  PR_CFG_REMEMBER
 *      --  A boolean value indicating whether the users password is
 *          to be remembered in the profile or not.
 *
 *  PR_CFG_CONN_TYPE
 *      --  The connection type.  This may be one of CFG_CONN_LAN,
 *          CFG_CONN_REMOTE, CFG_CONN_OFFLINE as defined below.
 *
 *  PR_CFG_SESSION_LOG
 *      --  A boolean value indicating whether session logging
 *          is/is not required.
 *
 *  PR_CFG_SESSION_LOG_FILE
 *      --  The path to the session log file.
 *
 *  D e l i v e r y   P r o p e r t i e s
 *
 *  PR_CFG_ENABLE_UPLOAD
 *      --  A boolean value which indicates whether mail in the outbox
 *          is sent.
 *
 *  PR_CFG_ENABLE_DOWNLOAD
 *      --  A boolean value which indicates whether mail in the server
 *          mailbag is downloaded.
 *
 *  PR_CFG_UPLOADTO
 *      --  A bit array which allows the user to indicate which addresses
 *          for which the transport is to attempt delivery.  This is useful
 *          in order to allow a user to specify that a transport only handle
 *          delivery for a subset of the addresses it can really process.
 *          When multiple transports are installed and the user wants a
 *          different transport to handle some specific address types they
 *          can use this bit array to specify that the MSMAIL transport
 *          only handle a specific set of addresses.
 *
 *          Possible values as defined below include:
 *
 *          CFG_UPLOADTO_PCMAIL     --  Local Post Office and External Post Office address types
 *          CFG_UPLOADTO_PROFS      --  PROFS address types
 *          CFG_UPLOADTO_SNADS      --  SNADS address types
 *          CFG_UPLOADTO_OV         --  OfficeVision address types
 *          CFG_UPLOADTO_MCI        --  MCI address types
 *          CFG_UPLOADTO_X400       --  X.400 address types
 *          CFG_UPLOADTO_FAX        --  FAX address types
 *          CFG_UPLOADTO_MHS        --  MHS address types
 *          CFG_UPLOADTO_SMTP       --  SMTP address types
 *          CFG_UPLOADTO_MACMAIL    --  MacMail address types
 *          CFG_UPLOADTO_ALL        --  All MSMAIL address types
 *
 *
 *  PR_CFG_NETBIOS_NTFY
 *      --  A boolean value which indicates whether a netbios notification
 *          is sent to a recipients transport when mail is delivered to
 *          their server inbox.
 *
 *  PR_CFG_SPOOLER_POLL
 *      --  The polling interval in minutes when the transport
 *          checks for new mail.  1 <= polling interval <= 9999
 *
 *  F a s t  L A N  P r o p e r t i e s
 *
 *  PR_CFG_LAN_HEADERS
 *      --  A boolean value which indicates whether the user wants to enable
 *          headers while working on the LAN.  Headers mode allows the user
 *          to download message headers and selectively choose which mail
 *          to download.
 *
 *  PR_CFG_LAN_LOCAL_AB
 *      --  A boolean value which indicates whether the user wants to use
 *          name resolution based on a local copy of the server address book
 *          rather than the server address book itself.
 *
 *  S l o w  L A N  P r o p e r t i e s
 *
 *  PR_CFG_RAS_HEADERS
 *      --  A boolean value which indicates whether the user wants to enable
 *          headers while working over a slow speed link.  Headers mode
 *          allows the user to download message headers and selectively
 *          choose which mail to download.
 *
 *  PR_CFG_RAS_LOCAL_AB
 *      --  A boolean value which indicates whether the user wants to use
 *          name resolution based on a local copy of the server address book
 *          rather than the server address book itself.
 *
 *  PR_CFG_RAS_INIT_ON_START
 *      --  A boolean value which indicates that a RAS connection should
 *          be established when the transport provider starts up.
 *
 *  PR_CFG_RAS_TERM_ON_HDRS
 *      --  A boolean value which indicates that a RAS connection should
 *          be automatically terminated when headers are finished downloading.
 *
 *  PR_CFG_RAS_TERM_ON_XFER
 *      --  A boolean value which indicates that a RAS connection should
 *          be automatically terminated after mail has finished being sent
 *          received.
 *
 *  PR_CFG_RAS_TERM_ON_EXIT
 *      --  A boolean value which indicates that a RAS connection should
 *          be automatically terminated when the provider is exited.
 *
 *  PR_CFG_RAS_PROFILE
 *      --  The name of the RAS profile that the transport will use by
 *          default to attempt the connection.
 *
 *  PR_CFG_RAS_RETRYATTEMPTS
 *      --  Number of times to attempt dial for connection.
 *          1 <= retry attempts <= 9999
 *
 *  PR_CFG_RAS_RETRYDELAY
 *      --  Delay between retry attempts in seconds.
 *          30 <= retry delay <= 9999
 *
 *  PR_CFG_RAS_CONFIRM
 *      --  A value which determines whether, on a RAS connection, the
 *          user should be prompted to select a RAS phonebook entry.
 *          Possible values as defined below include:
 *          CFG_ALWAYS      --  Always use the default RAS profile.
 *                              Never prompt the user.
 *          CFG_ASK_FIRST   --  Prompt the user to select a profile on the
 *                              first connection or after any error occurs.
 *          CFG_ASK_EVERY   --  Always prompt the user to select the RAS
 *                              profile.
 *
 *  S c h e d u l e d   S e s s i o n   P r o p e r t i e s 
 *
 *  PR_CFG_SCHED_SESS
 *      --  A property that contains information on scheduled sessions.  The
 *          maximum number of entries that may be stored is CFG_SS_MAX.  The
 *          information is stored in the data structure SchedSess.
 *          $REVIEW Probably want to flesh this out more.
 *
 */

#include <ras.h>
#include <mapitags.h>

/*
 * Connection Properties
 */
#define PR_CFG_SERVER_PATH              PROP_TAG (PT_STRING8,   0x6600)
#define PR_CFG_MAILBOX                  PROP_TAG (PT_STRING8,   0x6601)
// Password must be in the secure property range (See MAPITAGS.H)
#define PR_CFG_PASSWORD                 PROP_TAG (PT_STRING8,   PROP_ID_SECURE_MIN)
#define PR_CFG_CONN_TYPE                PROP_TAG (PT_LONG,      0x6603)
#define     CFG_CONN_LAN            0
#define     CFG_CONN_REMOTE         1
#define     CFG_CONN_OFFLINE        2
#define PR_CFG_SESSION_LOG              PROP_TAG (PT_BOOLEAN,   0x6604)
#define PR_CFG_SESSION_LOG_FILE         PROP_TAG (PT_STRING8,   0x6605)
#define PR_CFG_REMEMBER                 PROP_TAG (PT_BOOLEAN,   0x6606)

/*
 * Delivery Properties
 */

#define PR_CFG_ENABLE_UPLOAD            PROP_TAG (PT_BOOLEAN,   0x6620)
#define PR_CFG_ENABLE_DOWNLOAD          PROP_TAG (PT_BOOLEAN,   0x6621)
#define PR_CFG_UPLOADTO                 PROP_TAG (PT_LONG,      0x6622)
#define     CFG_UPLOADTO_PCMAIL     0x00000001
#define     CFG_UPLOADTO_PROFS      0x00000002
#define     CFG_UPLOADTO_SNADS      0x00000004
#define     CFG_UPLOADTO_MCI        0x00000008
#define     CFG_UPLOADTO_X400       0x00000010
#define     CFG_UPLOADTO_FAX        0x00000040
#define     CFG_UPLOADTO_MHS        0x00000080
#define     CFG_UPLOADTO_SMTP       0x00000100
#define     CFG_UPLOADTO_OV         0x00000800
#define     CFG_UPLOADTO_MACMAIL    0x00001000
#define     CFG_UPLOADTO_ALL        CFG_UPLOADTO_PCMAIL | CFG_UPLOADTO_PROFS | CFG_UPLOADTO_SNADS | \
                                    CFG_UPLOADTO_MCI | CFG_UPLOADTO_X400 | CFG_UPLOADTO_FAX | \
                                    CFG_UPLOADTO_MHS | CFG_UPLOADTO_SMTP | CFG_UPLOADTO_OV | \
                                    CFG_UPLOADTO_MACMAIL
#define PR_CFG_NETBIOS_NTFY             PROP_TAG (PT_BOOLEAN,   0x6623)
#define PR_CFG_SPOOLER_POLL             PROP_TAG (PT_STRING8,   0x6624)

/*
 * Fast LAN Properties
 */

#define PR_CFG_LAN_HEADERS              PROP_TAG (PT_BOOLEAN,   0x6630)
#define PR_CFG_LAN_LOCAL_AB             PROP_TAG (PT_BOOLEAN,   0x6631)

/*
 * Slow LAN Properties
 */

#define PR_CFG_RAS_HEADERS              PROP_TAG (PT_BOOLEAN,   0x6640)
#define PR_CFG_RAS_LOCAL_AB             PROP_TAG (PT_BOOLEAN,   0x6641)
#define PR_CFG_RAS_INIT_ON_START        PROP_TAG (PT_BOOLEAN,   0x6642)
#define PR_CFG_RAS_TERM_ON_HDRS         PROP_TAG (PT_BOOLEAN,   0x6643)
#define PR_CFG_RAS_TERM_ON_XFER         PROP_TAG (PT_BOOLEAN,   0x6644)
#define PR_CFG_RAS_TERM_ON_EXIT         PROP_TAG (PT_BOOLEAN,   0x6645)
#define PR_CFG_RAS_PROFILE              PROP_TAG (PT_STRING8,   0x6646)
#define PR_CFG_RAS_CONFIRM              PROP_TAG (PT_LONG,      0x6647)
#define     CFG_ALWAYS              0
#define     CFG_ASK_FIRST           1
#define     CFG_ASK_EVERY           2
#define PR_CFG_RAS_RETRYATTEMPTS        PROP_TAG (PT_STRING8,   0x6648)
#define PR_CFG_RAS_RETRYDELAY           PROP_TAG (PT_STRING8,   0x6649)


/*
 * Message Header Property
 */

#define PR_CFG_LOCAL_HEADER             PROP_TAG (PT_BOOLEAN,   0x6650)

/*
 * Scheduled Session Properties
 */
#define     CFG_SS_MAX          16
#define     CFG_SS_BASE_ID      0x6700
#define     CFG_SS_MAX_ID       CFG_SS_BASE_ID + CFG_SS_MAX - 1
#define SchedPropTag(n)         PROP_TAG (PT_BINARY, CFG_SS_BASE_ID+(n))
#define PR_CFG_SCHED_SESS       SchedPropTag(0)

typedef struct SchedSess {
    USHORT          sSessType;
    USHORT          sDayMask;
    FILETIME        ftTime;         // sched time
    FILETIME        ftStart;        // start time
    ULONG           ulFlags;        // flags and task list
    TCHAR           szPhoneEntry[RAS_MaxEntryName+1];

} SCHEDSESS, FAR *LPSCHEDSESS;

// Day bits
#define     CFG_SS_SUN  0x0001
#define     CFG_SS_MON  0x0002
#define     CFG_SS_TUE  0x0004
#define     CFG_SS_WED  0x0008
#define     CFG_SS_THU  0x0010
#define     CFG_SS_FRI  0x0020
#define     CFG_SS_SAT  0x0040

#define IsDayChecked(sDayMask, nDay)  ( (sDayMask) & (1<<(nDay)) )

// Session types
#define     CFG_SS_EVERY    0
#define     CFG_SS_WEEKLY   1
#define     CFG_SS_ONCE     2
#define     CFG_SS_NULLTYPE 3

// Property range identifiers; useful for asserting
#define PR_CFG_MIN              PROP_TAG (PT_STRING8,   0x6600)
#define PR_CFG_MAX              SchedPropTag(CFG_SS_MAX-1)

// Shared Folder Service Provider Properties

// PR_ASSIGNED_ACCESS - MAPI Access rights given to users other than the owner of the folder
//                      This property can be retrieved and set. The following MAPI access flags
//                      are valid: 
//                          MAPI_ACCESS_READ
//                          (MAPI_ACCESS_CREATE_HIERARCHY | MAPI_ACCESS_CREATE_CONTENTS)
//                          MAPI_ACCESS_DELETE
//  
#define PR_ASSIGNED_ACCESS  PROP_TAG(PT_LONG, 0x66ff)

// SFSP_ACCESS_OWNER -  This flag is returned when PR_ASSIGNED_ACCESS is retrieved by the owner
//                      of the folder. It can not be set.
#define SFSP_ACCESS_OWNER   0x8000


// Unique Provider Identifiers
//
#define MSFS_UID_ABPROVIDER     { 0x00,0x60,0x94,0x64,0x60,0x41,0xb8,0x01, \
                                  0x08,0x00,0x2b,0x2b,0x8a,0x29,0x00,0x00 }

#define MSFS_UID_SFPROVIDER     { 0x00,0xff,0xb8,0x64,0x60,0x41,0xb8,0x01, \
                                  0x08,0x00,0x2b,0x2b,0x8a,0x29,0x00,0x00 }
                                                                            

#endif // _MSFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\trialoc\stdatl.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\trialoc\debug.cpp ===
//
//
//
#include "stdafx.h"

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "trialoc"
#define SZ_MODULE           "trialoc"
#define DECLARE_DEBUG
#include "..\inc\debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\mapi\inc\mspst.h ===
/*
 *  M S P S T . H
 *  
 *  This file lists internal properties of the Microsoft Personal
 *  Information Store
 *  
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MSPST_H_
#define _MSPST_H_


/*  The following is a list of properties that may be passed in
    as the properties in the array of SPropValue structure on the
    MsgServiceConfigure function.
    
    Creating a PST profile section through CreateMsgService.
    The creation of the actual PST file is a two step process.  First the
    client should call CreateMsgService to setup the profile section and then
    ConfigureMsgService to create the PST file.
    The CreateMsgService call will setup the PR_DISPLAY_NAME property in the
    profile section to be used on the PST when it is created.

    Configuring an PST file through ConfigureMsgService.
    The configuration of an PST can take two forms, either configuring an
    existing PST or creating a new PST.  The Microsoft Personal Information
    Store provider will try to find the necessary properties by first looking
    in the array of SPropValue structures provided by the client and then in the
    profile section, except for PR_PST_PW_SZ_OLD for which it will only look
    in the array of properties.

    The Microsoft PST provider will try to open the file specified by the
    PR_PST_PATH property, using the password given in the PR_PST_PW_SZ_OLD
    property.  If it finds a file and it recognizes it as a PST
    file, it will start the configuration routine.  Otherwise it will start the
    creation routine.

    The configuration routine will look for the PR_DISPLAY_NAME_A and
    PR_COMMENT_A properties and set them in the message store object.  Then it
    will look for the PR_PST_REMEMBER_PW property to decide if it should
    remember the password in the profile. (If not found then it will defaut to
    the current status of the profile password.)  Then if it is supposed to
    use UI, it will display the configuration property sheet to the user.  After
    all has succeeded, it will update the profile.

    The creation routine will follow one of two paths to get the PR_PST_PATH
    property.  If it is supposed to use UI it will always display the file open
    dialog to confirm the path passed in or allow the user to change it.  If
    the user chooses an existing file and it recognizes it as an PST it will
    drop back to the configuration routine.  If the user chooses an existing
    file and it is not recognized as an PST file, the user will be given the
    option of choosing another file or  creating a new PST in its place, in
    which case is will continue with the create routine.  If the user chooses
    a new file it will continue with the create routine.  If the routine is not
    allowed to use UI, then the routine will create a file at the given path
    even if another file exists there.

    Once it decides to continue with the creation process it will get the
    PR_DISPLAY_NAME, PR_COMMENT, PR_PST_ENCRYPTION, and PR_PST_SZ_PW_NEW
    properties.  If it is supposed to use UI, it will use these to initialize
    the creation dialog and get any changes the user want.  Then it will create
    a new file and update the profile.
    
    PR_DISPLAY_NAME_A   display name for the PST service
    PR_COMMENT_A        comment to the place on the PST store object
    PR_PST_PATH         location the store to create or configure
    PR_PST_REMEMBER_PW  whether or not the remember the password in the profile
    PR_PST_ENCRYPTION   encryption level at which to create the file
    PR_PST_PW_SZ_OLD    password of the PST being configured
    PR_PST_PW_SZ_NEW    password to use for future access to the PST
*/

#define PST_EXTERN_PROPID_BASE          (0x6700)
#define PR_PST_PATH                     PROP_TAG(PT_STRING8, PST_EXTERN_PROPID_BASE + 0)
#define PR_PST_REMEMBER_PW              PROP_TAG(PT_BOOLEAN, PST_EXTERN_PROPID_BASE + 1)
#define PR_PST_ENCRYPTION               PROP_TAG(PT_LONG, PST_EXTERN_PROPID_BASE + 2)
#define PR_PST_PW_SZ_OLD                PROP_TAG(PT_STRING8, PST_EXTERN_PROPID_BASE + 3)
#define PR_PST_PW_SZ_NEW                PROP_TAG(PT_STRING8, PST_EXTERN_PROPID_BASE + 4)
    
#define PSTF_NO_ENCRYPTION              ((DWORD)0x80000000)
#define PSTF_COMPRESSABLE_ENCRYPTION    ((DWORD)0x40000000)
#define PSTF_BEST_ENCRYPTION            ((DWORD)0x20000000)

/*
 *  PR_MDB_PROVIDER is the GUID that represent the Microsoft Personal
 *  Information Store.  This guid is available as a property in the stores
 *  table and on the message store and status objects.
 */
#define MSPST_UID_PROVIDER  {   0x4e, 0x49, 0x54, 0x41, \
                                0xf9, 0xbf, 0xb8, 0x01, \
                                0x00, 0xaa, 0x00, 0x37, \
                                0xd9, 0x6e, 0x00, 0x00 }

#endif  /* _MSPST_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\trialoc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by icwhelp.rc
//
#define IDS_PROJNAME                    100

#define IDR_TRIALEND                    1036

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         603
#define _APS_NEXT_SYMED_VALUE           1044
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\trialoc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED_)
#define AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

// Includes
#include <atlcom.h>
#include <atlctl.h>

#include <ccstock.h>

#include "trialoc.h"

#include "resource.h"

// Common global include for ICWHELP

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\trialoc\trialend.cpp ===
// TrialEnd.cpp : Implementation of CTrialEnd
#include "stdafx.h"
#include "trialoc.h"
#include "TrialEnd.h"

static const TCHAR cszKeyIcwRmind[] = TEXT("Software\\Microsoft\\Internet Connection Wizard\\IcwRmind");
static const TCHAR cszTrialConverted[] = TEXT("TrialConverted");

/////////////////////////////////////////////////////////////////////////////
// CTrialEnd


HRESULT CTrialEnd::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

STDMETHODIMP CTrialEnd::CleanupTrialReminder(BOOL * pbRetVal)
{
    HKEY    hkey;
    DWORD   dwValue = 1;
                
    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                      cszKeyIcwRmind,
                      0,
                      KEY_ALL_ACCESS,
                      &hkey) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkey,
                      cszTrialConverted,
                      0,
                      REG_DWORD,
                      (LPBYTE) &dwValue,
                      sizeof(DWORD));                              

        RegCloseKey(hkey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\trialoc\trialend.h ===
// TrialEnd.h : Declaration of the CTrialEnd

#ifndef __TRIALEND_H_
#define __TRIALEND_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CTrialEnd
class ATL_NO_VTABLE CTrialEnd :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTrialEnd,&CLSID_TrialEnd>,
	public CComControl<CTrialEnd>,
	public IDispatchImpl<ITrialEnd, &IID_ITrialEnd, &LIBID_TRIALOCLib>,
	public IPersistStreamInitImpl<CTrialEnd>,
	public IOleControlImpl<CTrialEnd>,
	public IOleObjectImpl<CTrialEnd>,
	public IOleInPlaceActiveObjectImpl<CTrialEnd>,
	public IViewObjectExImpl<CTrialEnd>,
	public IOleInPlaceObjectWindowlessImpl<CTrialEnd>,
    public IObjectSafetyImpl<CTrialEnd>
{
public:
	CTrialEnd()
	{
 
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TRIALEND)

BEGIN_COM_MAP(CTrialEnd) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITrialEnd)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CTrialEnd)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CTrialEnd)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = 0;
		return S_OK;
	}

// ITrialEnd
public:
	STDMETHOD(CleanupTrialReminder)(/*[out,revtal]*/ BOOL *pbRetVal);
	HRESULT OnDraw(ATL_DRAWINFO& di);

};

#endif //__TRIALEND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\trialoc\trialoc.cpp ===
// trialoc.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL, 
//        run nmake -f trialocps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"
#include "trialoc.h"

#include "trialoc_i.c"
#include "trialend.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_TrialEnd, CTrialEnd)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\common.inc ===
SOURCES_USED=$(ROOT)\common.inc

!if $(ALPHA)
MSC_WARNING_LEVEL = /W3 /WX
!endif

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL = /W4 /WX
!endif

C_DEFINES = \
    /D_WCTYPE_INLINE_DEFINED \
    /DSTRICT

!if !$(FREEBUILD)
USE_RTTI=1
MSC_OPTIMIZATION=/Od
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /zm /zff /zgf
LINKER_NOICF=1      # ICF is s-l-o-w
!else
MSC_OPTIMIZATION=/Oxs
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /ox /oe /zm /zff /zgf
!endif

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob1 /Oi

NOT_LEAN_AND_MEAN=1

USE_NOLIBS=1
UMTYPE=windows

# Use NT 4.0/Win95 functionality only

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00

!ifdef WIN16

# Win 16 Specific Environment.
!ifndef __MSVC_ENV__
__WATCOM_ENV__=1
!endif
C_DEFINES = $(C_DEFINES) /DINC_WIN16X /DWRAP_RECTL /DFULL_DEBUG

FULL_DEBUG=1

!endif

NO_NTDLL=1

CHECKED_ALT_DIR=1

#
# The IE build lab sets this flag for debug builds so we get full debug
#   on IE drops. The NT build lab wants debug lite builds and therefore
#   does not set it.
#
!ifdef MSHTML_FULL_DEBUG
!message MSHTML_FULL_DEBUG was defined. Building full debug.
FULL_DEBUG=1
!endif

# By default, don't generate a .bsc file
NO_BROWSER_FILE=1

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) /DPRODUCT_PROF
!endif

!ifdef USE_PERFTEST
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFTEST
!endif

!ifdef USE_PERFBUG
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFBUG
!endif

!ifdef USE_PERFTAGS
!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) /DPERFTAGS
!message PERFTAGS was defined
!endif
!endif

!ifdef USE_MSHTML_INCREMENTAL_LINKING
!if !$(FREEBUILD) && $(USE_MSHTML_INCREMENTAL_LINKING)
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
NTDBGFILES=1
!undef USE_MAPSYM
USE_INCREMENTAL_LINKING=1
LINKER_FLAGS=$(LINKER_FLAGS) -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
TARGETPDB=TDC
!message USE_MSHTML_INCREMENTAL_LINKING was defined
!message $(TARGETPDB) was defined
!endif
!else
# Compatibility with existing usage before use_mshtml_incremental_linking
!ifdef USE_INCREMENTAL_LINKING
!message DOING IT THE OLD WAY
LINKER_FLAGS = -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
!else
USE_MAPSYM=1
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\trialoc\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..

#
# Cross-compiler macros for unique naming
#

MAJORCOMP       = ie4
MINORCOMP       = trialoc


#
# Defines for common.inc
#

TARGET_BOTH     = 1

#
# Include our common makefile
#

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\trialoc


PASS0_HEADERDIR   = $(O)
PASS0_SOURCEDIR   = $(O)
MIDL_TLBDIR       = $(O)
MIDL_UUIDDIR      = $(O)

#
# Common settings required by build.exe and makefile.def
#

#WINVER_VERSION  = 0x400
TARGETNAME      = trialoc
TARGETPATH      = obj
TARGETTYPE      = DYNLINK
TARGETLIBS      = $(LIBRARY_PATH)\gdi32.lib             \
                  $(LIBRARY_PATH)\kernel32.lib          \
                  $(LIBRARY_PATH)\user32.lib            \
                  $(LIBRARY_PATH)\advapi32.lib          \
                  $(LIBRARY_PATH)\shell32.lib           \
                  $(LIBRARY_PATH)\uuid.lib              \
                  $(LIBRARY_PATH)\ole32.lib             \
                  $(LIBRARY_PATH)\oleaut32.lib          \
                  $(SDK_LIB_PATH)\version.lib           \
!if defined(NOT_UNICODE)
                  $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib    \
!else
                  $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib    \
!endif

PRECOMPILED_CXX = 1
USE_STATIC_ATL  = 1
USE_MSVCRT      = 1

DLLDEF          = ..\trialoc.def
DLLBASE         = 0x63A00000
DLLENTRY        = DllMain

#
# List of sources
#

SOURCES =                       \
            ..\trialoc.rc       \
            ..\trialoc.idl      \
            ..\debug.cpp        \
            ..\trialoc.cpp      \
            ..\trialend.cpp     \
            ..\stdatl.cpp

PRECOMPILED_INCLUDE = ..\stdafx.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TDC.rc
//
#define IDS_PROJNAME    100
#define IDR_TDCCtl  101
#define IDR_SimpleTabularData   102
#define IDI_TDCICON 203

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\notify.h ===
//+-----------------------------------------------------------------------
//
//  TDC / STD Notifications
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       Notify.h
//
//  Contents:   Declaration of the CEventBroker class.
//              This class translates internal TDC / STD events into
//              appropriate notifications for the external world.
//
//------------------------------------------------------------------------

#include "msdatsrc.h"

template <class T> class CMyBindStatusCallback;
class CTDCCtl;

interface DATASRCListener : public IUnknown
{
    STDMETHOD(datasrcChanged)(BSTR bstrQualifier, BOOL fDataAvail);
};

//------------------------------------------------------------------------
//
//  CEventBroker
//
//  This class translates internal STD / TDC events into appropriate
//  notifications for the outside world.
//
//------------------------------------------------------------------------

class CEventBroker
{
public:
    STDMETHOD_(ULONG,AddRef)    (THIS);
    STDMETHOD_(ULONG,Release)   (THIS);
// ;begin_internal
    STDMETHOD(SetDATASRCListener)(DATASRCListener *);
// ;end_internal
    STDMETHOD(SetDataSourceListener)(DataSourceListener *);
    STDMETHOD(SetSTDEvents)(OLEDBSimpleProviderListener *);
    inline DataSourceListener *GetDataSourceListener();
    inline DATASRCListener *GetDATASRCListener();
    inline OLEDBSimpleProviderListener *GetSTDEvents();

    CEventBroker(CTDCCtl *pReadyStateControl);
    ~CEventBroker();

    STDMETHOD(aboutToChangeCell)(LONG iRow, LONG iCol);
    STDMETHOD(cellChanged)(LONG iRow, LONG iCol);
    STDMETHOD(aboutToDeleteRows)(LONG iRowStart, LONG iRowCount);
    STDMETHOD(deletedRows)(LONG iRowStart, LONG iRowCount);
    STDMETHOD(aboutToInsertRows)(LONG iRowStart, LONG iRowCount);
    STDMETHOD(insertedRows)(LONG iRowStart, LONG iRowCount);
    STDMETHOD(rowsAvailable)(LONG iRowStart, LONG iRowCount);

    STDMETHOD(RowChanged)(LONG iRow);
    STDMETHOD(ColChanged)(LONG iCol);
// ;begin_internal
#ifdef NEVER
    STDMETHOD(DeletedCols)(LONG iColStart, LONG iColCount);
    STDMETHOD(InsertedCols)(LONG iColStart, LONG iColCount);
#endif
// ;end_internal
    STDMETHOD(STDLoadStarted)(CComObject<CMyBindStatusCallback<CTDCCtl> > *pBSC,
                              boolean fAppending);
    STDMETHOD(STDLoadCompleted)();
    STDMETHOD(STDLoadStopped)();
    STDMETHOD(STDLoadedHeader)();
    STDMETHOD(STDDataSetChanged)();

    STDMETHOD(GetReadyState)(LONG *plReadyState);
    STDMETHOD(UpdateReadyState)(LONG lReadyState);    
    CMyBindStatusCallback<CTDCCtl> *m_pBSC;

private:
    ULONG                    m_cRef;         // interface reference count
    DataSourceListener      *m_pDataSourceListener;
// ;begin_internal
    DATASRCListener         *m_pDATASRCListener;
// ;end_internal
    OLEDBSimpleProviderListener *m_pSTDEvents;
    LONG                     m_lReadyState;
    CTDCCtl                  *m_pReadyStateControl;
};

inline DataSourceListener *CEventBroker::GetDataSourceListener()
{
    return m_pDataSourceListener;
}

// ;begin_internal
inline DATASRCListener *CEventBroker::GetDATASRCListener()
{
    return m_pDATASRCListener;
}
// ;end_internal

inline OLEDBSimpleProviderListener *CEventBroker::GetSTDEvents()
{
    return m_pSTDEvents;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\notify.cpp ===
//+-----------------------------------------------------------------------
//
//  TDC / STD Notifications
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       Notify.cpp
//
//  Contents:   Implementation of the CEventBroker class.
//              This class translates internal TDC / STD events into
//              appropriate notifications for the external world.
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include <simpdata.h>
#include "TDC.h"
#include <MLang.h>
#include "Notify.h"
#include "TDCParse.h"
#include "TDCArr.h"
#include "SimpData.h"
#include "TDCIds.h"
#include "TDCCtl.h"


//------------------------------------------------------------------------
//
//  Method:    CEventBroker()
//
//  Synopsis:  Class constructor
//
//  Arguments: None
//
//------------------------------------------------------------------------

CEventBroker::CEventBroker(CTDCCtl *pReadyStateControl)
{
    m_cRef = 1;
    m_pSTDEvents = NULL;
// ;begin_internal
    m_pDATASRCListener = NULL;
// ;end_internal
    m_pDataSourceListener = NULL;
    m_pBSC = NULL;

    //  Can't AddRef this control, since it has a ref on this object;
    //  would lead to circular refs & zombie objects.
    //
    m_pReadyStateControl = pReadyStateControl;

    // When we're born, we'd better be born READYSTATE_COMPLETE.
    // If and when a query starts, we can go READYSTATE_LOADED.
    m_lReadyState = READYSTATE_COMPLETE;
}

CEventBroker::~CEventBroker()
{

    SetDataSourceListener(NULL);
// ;begin_internal
    SetDATASRCListener(NULL);
// ;end_internal
    SetSTDEvents(NULL);
}

//+-----------------------------------------------------------------------
//
//  Method:    AddRef()
//
//  Synopsis:  Implements part of the standard IUnknown COM interface.
//               (Adds a reference to this COM object)
//
//  Arguments: None
//
//  Returns:   Number of references to this COM object.
//
//+-----------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEventBroker::AddRef ()
{
    return ++m_cRef;
}


//+-----------------------------------------------------------------------
//
//  Method:    Release()
//
//  Synopsis:  Implements part of the standard IUnknown COM interface.
//               (Removes a reference to this COM object)
//
//  Arguments: None
//
//  Returns:   Number of remaining references to this COM object.
//             0 if the COM object is no longer referenced.
//
//+-----------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEventBroker::Release ()
{
    ULONG retval;

    retval = --m_cRef;

    if (m_cRef == 0)
    {
        m_cRef = 0xffff;
        delete this;
    }

    return retval;
}

//------------------------------------------------------------------------
//
//  Method:    GetReadyState()
//
//  Synopsis:  Returns the current ReadyState in the supplied pointer.
//
//  Arguments: plReadyState    Pointer to space to hold ReadyState result
//
//  Returns:   S_OK indicating success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::GetReadyState(LONG *plReadyState)
{
    *plReadyState = m_lReadyState;
    return S_OK;
}

//------------------------------------------------------------------------
//
//  Method:    UpdateReadySTate()
//
//  Synopsis:  Update our ReadyState and FireOnChanged iif it changed
//
//  Arguments: lReadyState    new ReadyState
//
//  Returns:   S_OK indicating success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::UpdateReadyState(LONG lReadyState)
{
    // If we're actually stopping something, then fire READYSTATE_COMPLETE
    if (m_lReadyState != lReadyState)
    {
        m_lReadyState = lReadyState;
        if (m_pReadyStateControl != NULL)
        {
            m_pReadyStateControl->FireOnChanged(DISPID_READYSTATE);
            m_pReadyStateControl->FireOnReadyStateChanged();
        }
    }

    return S_OK;
}

//------------------------------------------------------------------------
//
//  Method:    SetDataSourceListener()
//
//  Synopsis:  Sets the COM object which should receive DATASRC
//             notification events.
//
//  Arguments: pDataSourceLIstener  Pointer to COM object to receive notification
//                               events, or NULL if no notifications to be sent.
//
//  Returns:   S_OK indicating success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::SetDataSourceListener(DataSourceListener *pDataSourceListener)
{
    // If we've changed/reset the data source listener, make sure we don't
    // think we've fired dataMemberChanged on it yet.
    ClearInterface(&m_pDataSourceListener);

    if (pDataSourceListener != NULL)
    {
        m_pDataSourceListener = pDataSourceListener;
        m_pDataSourceListener->AddRef();
    }
    return S_OK;
}

// ;begin_internal
//------------------------------------------------------------------------
//
//  Method:    SetDATASRCListener()
//
//  Synopsis:  Sets the COM object which should receive DATASRC
//             notification events.
//
//  Arguments: pDATASRCLIstener  Pointer to COM object to receive notification
//                               events, or NULL if no notifications to be sent.
//
//  Returns:   S_OK indicating success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::SetDATASRCListener(DATASRCListener *pDATASRCListener)
{
    // If we've changed/reset the data source listener, make sure we don't
    // think we've fired dataMemberChanged on it yet.
    ClearInterface(&m_pDATASRCListener);

    if (pDATASRCListener != NULL)
    {
        m_pDATASRCListener = pDATASRCListener;
        m_pDATASRCListener->AddRef();
    }
    return S_OK;
}
// ;end_internal

//------------------------------------------------------------------------
//
//  Method:    SetSTDEvents()
//
//  Synopsis:  Sets the COM object which should receive DATASRC
//             notification events.
//
//  Arguments: pSTDEvents     Pointer to COM object to receive notification
//                            events, or NULL if no notifications to be sent.
//
//  Returns:   S_OK indicating success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::SetSTDEvents(OLEDBSimpleProviderListener *pSTDEvents)
{
    ClearInterface(&m_pSTDEvents);

    if (pSTDEvents != NULL)
    {
        m_pSTDEvents = pSTDEvents;
        m_pSTDEvents->AddRef();
    }
    return S_OK;
}

//------------------------------------------------------------------------
//
//  Method:    aboutToChangeCell()
//
//  Synopsis:  Notifies anyone who wants to know that a particular cell
//             is about to change.
//
//  Arguments: iRow           Row number of the cell that has changed.
//             iCol           Column number of the cell that has changed.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::aboutToChangeCell(LONG iRow, LONG iCol)
{
    HRESULT hr = S_OK;

    _ASSERT(iRow >= 0);
    _ASSERT(iCol >= 1);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->aboutToChangeCell(iRow, iCol);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    CellChanged()
//
//  Synopsis:  Notifies anyone who wants to know that a particular cell
//             has changed.
//
//  Arguments: iRow           Row number of the cell that has changed.
//             iCol           Column number of the cell that has changed.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::cellChanged(LONG iRow, LONG iCol)
{
    HRESULT hr = S_OK;

    _ASSERT(iRow >= 0);
    _ASSERT(iCol >= 1);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->cellChanged(iRow, iCol);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    RowChanged()
//
//  Synopsis:  Notifies anyone who wants to know that a particular row
//             has changed.
//
//  Arguments: iRow           Number of the row that has changed.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::RowChanged(LONG iRow)
{
    HRESULT hr = S_OK;

    _ASSERT(iRow >= 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->cellChanged(iRow, -1);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    ColChanged()
//
//  Synopsis:  Notifies anyone who wants to know that a particular column
//             has changed.
//
//  Arguments: iCol           Number of the column that has changed.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::ColChanged(LONG iCol)
{
    HRESULT hr = S_OK;

    _ASSERT(iCol > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->cellChanged(-1, iCol);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    aboutToDeleteRows()
//
//  Synopsis:  Notifies anyone who wants to know that a some rows
//             have been deleted.
//
//  Arguments: iRowStart      Number of row on which deletion started.
//             iRowCount      Number of rows deleted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::aboutToDeleteRows(LONG iRowStart, LONG iRowCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iRowStart >= 0);
    _ASSERT(iRowCount > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->aboutToDeleteRows(iRowStart, iRowCount);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    deletedRows()
//
//  Synopsis:  Notifies anyone who wants to know that a some rows
//             have been deleted.
//
//  Arguments: iRowStart      Number of row on which deletion started.
//             iRowCount      Number of rows deleted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::deletedRows(LONG iRowStart, LONG iRowCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iRowStart >= 0);
    _ASSERT(iRowCount > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->deletedRows(iRowStart, iRowCount);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    aboutToInsertRows()
//
//  Synopsis:  Notifies anyone who wants to know that a some rows
//             have been inserted.
//
//  Arguments: iRowStart      Number of row on which insertion started.
//             iRowCount      Number of rows inserted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::aboutToInsertRows(LONG iRowStart, LONG iRowCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iRowStart >= 0);
    _ASSERT(iRowCount > 0);
    if (m_pSTDEvents != NULL)
            m_pSTDEvents->aboutToInsertRows(iRowStart, iRowCount);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    insertedRows()
//
//  Synopsis:  Notifies anyone who wants to know that a some rows
//             have been inserted.
//
//  Arguments: iRowStart      Number of row on which insertion started.
//             iRowCount      Number of rows inserted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::insertedRows(LONG iRowStart, LONG iRowCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iRowStart >= 0);
    _ASSERT(iRowCount > 0);
    if (m_pSTDEvents != NULL)
            m_pSTDEvents->insertedRows(iRowStart, iRowCount);
    return hr;
}


//------------------------------------------------------------------------
//
//  Method:    rowsAvailable()
//
//  Synopsis:  Notifies anyone who wants to know that a some rows
//             have arrived.  Although this is very similar to insertedRows
//             we want to preserve the distinction between rows that
//             arrive on the wire and an insert operation that might be
//             performed while some data is still downloading.
//
//  Arguments: iRowStart      Number of row on which insertion started.
//             iRowCount      Number of rows inserted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::rowsAvailable(LONG iRowStart, LONG iRowCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iRowStart >= 0);
    _ASSERT(iRowCount > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->rowsAvailable(iRowStart, iRowCount);
    return hr;
}

// ;begin_internal
#ifdef NEVER
//------------------------------------------------------------------------
//
//  Method:    DeletedCols()
//
//  Synopsis:  Notifies anyone who wants to know that a some columns
//             have been deleted.
//
//  Arguments: iColStart      Number of column on which deletion started.
//             iColCount      Number of columns deleted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::DeletedCols(LONG iColStart, LONG iColCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iColStart > 0);
    _ASSERT(iColCount > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->DeletedColumns(iColStart, iColCount);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    InsertedCols()
//
//  Synopsis:  Notifies anyone who wants to know that a some columns
//             have been inserted.
//
//  Arguments: iColStart      Number of column on which insertion started.
//             iColCount      Number of columns inserted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::InsertedCols(LONG iColStart, LONG iColCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iColStart > 0);
    _ASSERT(iColCount > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->InsertedColumns(iColStart, iColCount);
    return hr;
}
#endif
// ;end_internal

//------------------------------------------------------------------------
//
//  Method:    STDLoadStarted()
//
//  Synopsis:  Notifies anyone who wants to know that the STD control
//             has begun loading its data.
//
//  Arguments: pBSC      Pointer to data-retrieval object.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::STDLoadStarted(CComObject<CMyBindStatusCallback<CTDCCtl> > *pBSC, boolean fAppending)
{
    HRESULT hr = S_OK;

    m_pBSC = pBSC;
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    STDLoadCompleted()
//
//  Synopsis:  Notifies anyone who wants to know that the STD control
//             has loaded all of its data.
//             Note this function should be idempotent -- i.e. it may be
//             called more than once in synchronous cases, once when the
//             transfer actually completes, and again as soon as the event
//             sink is actually hooked up in order to fire the transferComplete
//             event.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::STDLoadCompleted()
{
    HRESULT hr = S_OK;

    m_pBSC = NULL;
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->transferComplete(OSPXFER_COMPLETE);
    UpdateReadyState(READYSTATE_COMPLETE);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    STDLoadStopped()
//
//  Synopsis:  Notifies anyone who wants to know that the STD control
//             has aborted the data load operation.
//
//  Arguments: OSPXFER giving reason for stop
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::STDLoadStopped()
{
    HRESULT hr = S_OK;

    if (m_pBSC && m_pBSC->m_spBinding)
    {
        hr = m_pBSC->m_spBinding->Abort();
        m_pBSC = NULL;
    }

    // Right now, any error results in not returning an STD object,
    // therefore we should not fire transfer complete.
    if (m_pSTDEvents)
        hr = m_pSTDEvents->transferComplete(OSPXFER_ABORT);

    UpdateReadyState(READYSTATE_COMPLETE);

    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    STDLoadedHeader()
//
//  Synopsis:  Notifies anyone who wants to know that the STD control
//             has loaded its header row.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::STDLoadedHeader()
{
    HRESULT hr = S_OK;

    hr = STDDataSetChanged();

    UpdateReadyState(READYSTATE_INTERACTIVE);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    STDSortFilterCompleted()
//
//  Synopsis:  Notifies anyone who wants to know that the STD control
//             has refiltered / resorted its data.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::STDDataSetChanged()
{
    HRESULT hr = S_OK;

    if (m_pDataSourceListener != NULL)
        hr = m_pDataSourceListener->dataMemberChanged(NULL);
// ;begin_internal
    if (m_pDATASRCListener != NULL)
        hr = m_pDATASRCListener->datasrcChanged(NULL, TRUE);
// ;end_internal
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\stdafx.h ===
// disable warning C4510: '__unnamed' : default constructor could not be generated
#pragma warning(disable : 4510)
// disable warning C4610: union '__unnamed' can never be instantiated - user defined constructor required
#pragma warning(disable : 4610)
// disable warning C4100: 'di' : unreferenced formal parameter
#pragma warning(disable : 4100)
// disable warning C4244: '=' : conversion from 'int' to 'unsigned short', possible loss of data
#pragma warning(disable : 4244)
// disable warning C4310: case truncates constant value (ATL gets this only on Alpha!)
#pragma warning(disable : 4310)
// disable warning C4505: 'HKeyFromCompoundString' : unreferenced local function has been removed
#pragma warning(disable : 4505)

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define STRICT 1
#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

// defaults for this project..
#define _WINDLL 1

#if defined(_UNICODE) || defined(UNICODE) || defined(OLE2ANSI)
#error The flags you have set will create a build that will \
       either not work on Win95 or not support Unicode.
#error
#endif

#include <atlbase.h>

// turn off ATL debugging, always
#undef _ATL_DEBUG_QI
// AddField messages can be so numerous, we have a separate flag
// for them..
#undef TDC_ATL_DEBUG_ADDFIELD
#ifdef _DEBUG
#define TDC_ATL_DEBUG
#endif

//#define MemAlloc(a) CoTaskMemAlloc((a))
//#define MemFree(a) CoTaskMemFree((a))
//#define MemRealloc(a,b) (((*(a) = CoTaskMemRealloc(*(a),(b))) ? S_OK : E_FAIL))

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

void ClearInterfaceFn(IUnknown ** ppUnk);

template <class PI>
inline void
ClearInterface(PI * ppI)
{
#ifdef _DEBUG
    IUnknown * pUnk = *ppI;
    _ASSERTE((void *) pUnk == (void *) *ppI);
#endif

    ClearInterfaceFn((IUnknown **) ppI);
}

#ifdef TDC_ATL_DEBUG
#define OutputDebugStringX(X) OutputDebugString(X)
#else
#define OutputDebugStringX(X)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\tdc.cpp ===
// TDC.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 or higher in order to build 
// this project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TDCps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <simpdata.h>
#include "TDCIds.h"
#include "TDC.h"
#include <MLang.h>

#define IID_DEFINED         // for now avoid a conflict with ATL
#include "TDC_i.c"
//#include "mlang_i.c"
#include "Notify.h"
#include "TDCParse.h"
#include "TDCArr.h"
#include "TDCCtl.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CTDCCtl, CTDCCtl)
//MM    OBJECT_ENTRY(CLSID_CSimpleTabularData, CSimpleTabularData)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
#if _WIN32_WINNT >= 0x0400
    UnRegisterTypeLib(LIBID_TDCLib, 1, 1, NULL, SYS_WIN32);
#endif
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\tarray.h ===
//+-----------------------------------------------------------------------
//
//  Template Array Implementation
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:      tarray.h
//
//  Contents:  Template for resizeable arrays.  Allows for the creation
//             and manipulation of arrays of any type.  Arrays can
//             be dynamically reallocated, and thus can "grow and shrink".
//             Constructors and destructors of array elements is
//             automatically handles, even when the size of the array is
//             changed.
//  Templates: TSTDArray
//
//------------------------------------------------------------------------

#ifndef _TARRAY_H_
#define _TARRAY_H_



//+-----------------------------------------------------------------------
//
//  Class:     TSTDArray
//
//  Synopsis:  Contains an array of "type".  Allows array to grow
//             dynamically.  During debug, can check bounds on indices.
//             Array is indexed 0 to _cArraySize-1.  _cArraySize holds
//               number of elements.
//
//  Methods:   Init          allocate memory for array
//             Passivate
//             []            allows indexing of array
//             GetSize       returns size of array
//             InsertElems   insert elements anywhere in array
//             DeleteElems   delete elements anywhere in array
//
//------------------------------------------------------------------------

template <class TYPE>
class TSTDArray
{
public:
    TSTDArray();
#if DBG == 1
    ~TSTDArray();
#endif
    HRESULT Init(const size_t cSize); // initialize data structures
    void Passivate();

    TYPE& operator[](const size_t iElement);
    const TYPE& operator[](const size_t iElement) const; // constant reference
    size_t GetSize() const { return _cArraySize; }

    HRESULT InsertElems(const size_t iElem, const size_t cElems);
    void DeleteElems(const size_t iElem, const size_t cElems);

private:
#if DBG == 1
    void IsValidObject() const;
#else
    void IsValidObject() const
        {   }
#endif

// All elements are packaged inside a class CElem.  This allows us to
//   overload the new operator so that we can manually invoke the
//   constructors.

    class CElem
    {
        friend TSTDArray;
    private:
        // Now we overload the new operator to allow placement argument
        void *operator new(size_t uSize, void *pv) { return pv; }

        // Internal data:
        TYPE _Element;       // actual element
    };

// Internal data:
    CElem *_paArray;        // pointer to actual data
    size_t _cArraySize;
    size_t _cAllocSize;     // the size of allocated object

#if DBG == 1
    // Ensure we call constructors and destructors right number of times.
    //   Used only as a check.
    size_t _cNumElems;
#endif
};


//+---------------------------------------------------------------------------
//
//  Member:     IsValidObject
//
//  Synopsis:   Validation method.  Checks that array structure is valid.
//              It is usefull to call this member function at the beginning
//              of each member function that uses the internal array to
//              ensure that the array is not corrupt before attempting to
//              modify it.
//

#if DBG == 1
template <class TYPE>
void
TSTDArray<TYPE>::IsValidObject() const
{
    _ASSERT("Must have valid this pointer" &&
           this );

    _ASSERT("Array has no memory" &&
           _paArray );

    _ASSERT("destructors called wrong number of times" &&
           (_cNumElems == _cArraySize) );
}
#endif


//+-----------------------------------------------------------------------
//
//  Constructor for TSTDArray
//
//  Synopsis:  Doesn't do anything.  Must call member function init to
//             actually initialize.  Only call init once.
//
//  Arguments: None.
//
//  Returns:   Nothing.
//

template <class TYPE>
TSTDArray<TYPE>::TSTDArray()
{
// We null the internal data, so that they are not actually used
// until the init member function is called.

    _paArray = 0;
    _cArraySize = 0;
    _cAllocSize = 0;

#if DBG == 1
    _cNumElems = 0;
#endif
}


//+-----------------------------------------------------------------------
//
//  Destructor for TSTDArray
//
//  Synopsis:  Must call member function passivate
//             to actually de-initialize.
//
//  Arguments: None.
//
//  Returns:   Nothing.
//

#if DBG == 1
template <class TYPE>
TSTDArray<TYPE>::~TSTDArray()
{
    _ASSERT("Passivate must be called first" &&
           !_paArray );

    _ASSERT("Destructors called wrong number of times" &&
           (_cNumElems == 0) );
}
#endif


//+-----------------------------------------------------------------------
//
//  Member:    Init
//
//  Synopsis:  Initializes the array abstract data type.  Allocates
//             memory for the array.  Also sets the cArraySize to
//             the number of elements.
//
//  Arguments: cSize    initial size of array (# of elements)
//
//  Returns:   Success if memory can be allocated for table.
//             Returns E_OUTOFMEMORY if can't get memory.
//

template <class TYPE>
HRESULT
TSTDArray<TYPE>::Init(const size_t cSize)
{
    HRESULT hr;

    _ASSERT(this);

    _ASSERT("Only call init once" &&
           !_paArray );

// Get memory:

    // 0 element array is made into 1 element array so that it functions
    //   normally.
    {
        //;begin_internal
        // BUGBUG:
        // MSVC 2.0 has a bug in it.  Evaluating the expression sizeof(CElem)
        //   seems to confuse it.  CElem is a class containing a variable
        //   whose size can only be calculated when the template containing it
        //   is instantiated.  In addition to this, CElem is a member of that
        //   template.  Placing the sizeof(CElem) expression within a more
        //   complicated expression is not possible.
        //;end_internal
        size_t uCElemSize;

        uCElemSize = sizeof(CElem);
        uCElemSize *= (cSize == 0 ? 1 : cSize);
        _paArray = (CElem *) CoTaskMemAlloc(uCElemSize);
    }
    if (!_paArray)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        CElem *pTemp;                   // index used to call constructors

        // We need to call the constructors manually for each element:
        for (pTemp = _paArray; pTemp < _paArray + cSize; pTemp++)
        {
            new (pTemp) CElem;
#if DBG == 1
            _cNumElems++;
#endif
        }

        _cArraySize = cSize;
        _cAllocSize = (cSize == 0 ? 1 : cSize);
        hr = S_OK;
    }

    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    Passivate
//
//  Synopsis:  Releases memory held in array.  Should be called before
//             the object is destroyed.  Should only be called once on an
//             object.
//
//  Arguments: None.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

template <class TYPE>
void
TSTDArray<TYPE>::Passivate()
{
    IsValidObject();

    _ASSERT("Only call Passivate once" &&
           _paArray );

    // We need to call the destructors manually for each element:

    {
        CElem *pTemp;                   // index used to call destructors

        for (pTemp = _paArray; pTemp < _paArray + _cArraySize; pTemp++)
        {
            pTemp->CElem::~CElem();
#if DBG == 1
            _cNumElems--;
#endif
        }
    }

    CoTaskMemFree(_paArray);

    _paArray = 0;         // make sure we don't call Passivate again
    _cArraySize = 0;
    _cAllocSize = 0;
}


//+-----------------------------------------------------------------------
//
//  Member:    operator[]
//
//  Synopsis:  Allows indexing of array's elements.  Use this to either
//             store an element in the array or read an element from
//             the array.  It is the user's responsibility to ensure
//             that the index is within the proper range, 0.._cArraySize-1.
//             During debugging, the index range is checked.
//
//  Arguments: iElement       Element index
//
//  Returns:   Reference to element.
//

template <class TYPE>
inline
TYPE&
TSTDArray<TYPE>::operator[](const size_t iElement)
{
    IsValidObject();

    _ASSERT("Index is out of range" &&
           (iElement < _cArraySize) );

    return _paArray[iElement]._Element;
}


//+-----------------------------------------------------------------------
//
//  Member:    operator[] const
//
//  Synopsis:  Same as previous [] operator, but returns a constant
//             reference so that it can't be used as an l-value.
//
//  Arguments: iElement       Element index
//
//  Returns:   Constant reference to element.
//

template <class TYPE>
inline
const TYPE&
TSTDArray<TYPE>::operator[](const size_t iElement) const
{
    IsValidObject(this);

    _ASSERT("Index is out of range" &&
           (iElement < _cArraySize) );

    return _paArray[iElement]._Element;
}


//+-----------------------------------------------------------------------
//
//  Member:    InsertElems
//
//  Synopsis:  Changes the size of the array by using MemRealloc().
//             Inserts a number of elements cElems into the array at
//             iElem.  This can be used to add new elements to the end of
//             the array by specifying iElem equal to _cArraySize.  It is
//             the responsibility of the user to make sure that iElem is
//             within the proper bounds of the array, although this will
//             be checked during debug mode.
//
//  Arguments: iElem       place to insert first element
//             cElems      number of new elements
//
//  Returns:   Returns success if elements can be added.
//             Returns E_OUTOFMEMORY if request cannot be met.
//             Array retains its old size if the request cannot be met.
//

template<class TYPE>
HRESULT
TSTDArray<TYPE>::InsertElems(const size_t iElem, const size_t cElems)
{
    HRESULT hr = S_OK;

    // Note that you can insert past the END of an array (appending to it):
    _ASSERT("iElem is too large" &&
           (iElem <= _cArraySize) );

    if (_cArraySize + cElems > _cAllocSize)
    {
        // Resize the current array we have:
        ULONG cAllocSize = _cAllocSize ? _cAllocSize : 8;
        CElem * paArray;                // new array

        // Double alloc size until it's big enough.  This will, I suppose, loop
        // forever if someone asks to allocate more than 2^31 elements.
        _ASSERT(_cArraySize + cElems < MAXLONG);
        while (_cArraySize + cElems > cAllocSize) cAllocSize <<= 1;

        paArray = (CElem *)CoTaskMemRealloc(_paArray, sizeof(CElem) * cAllocSize);

        if (!paArray)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        _paArray = paArray;
        _cAllocSize = cAllocSize;
    }


    IsValidObject();

    // Now we have to shift elements to allow space for the new elements:
    memmove(_paArray + iElem + cElems,      // dest
            _paArray + iElem,
            (_cArraySize - iElem) * sizeof(CElem));

    // Call constructors on all new elements:
    {
        CElem *pTemp;   // index used to call constructors

        for (pTemp = _paArray + iElem;
             pTemp < _paArray + iElem + cElems;
             pTemp++)
        {
            new (pTemp) CElem;
#if DBG == 1
            _cNumElems++;
#endif
        }
    }
    
    _cArraySize += cElems;

Error:
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    DeleteElems
//
//  Synopsis:  Deletes a number of elements cElems from the array at
//             iElem.  It is the responsibility of the user to make sure
//             that the region to be deleted is within the proper bounds
//             of the array, although this will be checked during
//             debug mode.
//
//  Arguments: iElem       place to delete first element
//             cElems      number of elements to delete
//
//  Returns:   Returns success.
//

template<class TYPE>
void
TSTDArray<TYPE>::DeleteElems(const size_t iElem, const size_t cElems)
{
    IsValidObject();

    _ASSERT("Region to delete is too large" &&
           (iElem+cElems-1 < _cArraySize) );


    // First we need to call destructors on elements:
    {
        CElem *pTemp;   // index used to call destructors

        for (pTemp = _paArray + iElem;
             pTemp < _paArray + iElem + cElems;
             pTemp++)
        {
            pTemp->CElem::~CElem();
#if DBG == 1
            _cNumElems--;
#endif
        }
    }

    // Now we need to shift the remaining elements in:
    memmove(_paArray + iElem,                // dest
            _paArray + iElem + cElems,
            (_cArraySize - (iElem + cElems)) * sizeof(CElem));

    _cArraySize -= cElems;
}


#endif  // _TARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\tdcarr.h ===
//+-----------------------------------------------------------------------
//
//  TDC Array
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCArr.h
//
//  Contents:   Declaration of the CTDCArr class.
//              This class forms the heart of the Tabular Data Control.
//              It provides the core 2D array of variant values, plus
//              a (possibly filtered/sorted) view of this data for
//              presentation through an ISimpleTabularData interface.
//
//------------------------------------------------------------------------

// ;begin_internal
#ifndef TDC_SKEL
// ;end_internal
#include "tarray.h"

//------------------------------------------------------------------------
//
//  CTDCCell
//
//  This class represents a cell value within the 2D TDC control
//
//------------------------------------------------------------------------

class CTDCCell : public VARIANT
{
public:
    CTDCCell()
    {
        VariantInit(this);
    }
    ~CTDCCell()
    {
        clear();
    }
    void clear()
    {
        VariantClear(this);
    }
};

//------------------------------------------------------------------------
//
//  TDCDateFmt
//
//  This enum represents the 6 meaningful ways to format dates
//
//------------------------------------------------------------------------
typedef enum
{
    TDCDF_NULL,
    TDCDF_DMY,
    TDCDF_DYM,
    TDCDF_MDY,
    TDCDF_MYD,
    TDCDF_YMD,
    TDCDF_YDM,
}
    TDCDateFmt;

//------------------------------------------------------------------------
//
//  CTDCColInfo
//
//  This class represents type/formatting information for a column
//
//------------------------------------------------------------------------

class CTDCColInfo
{
public:
    VARTYPE vtType;
    TDCDateFmt  datefmt;        //  Format string for dates

    CTDCColInfo()
    {
        vtType = VT_EMPTY;
    }
};
// ;begin_internal
#endif  // TDC_SKEL
// ;end_internal

//------------------------------------------------------------------------
//
//  CTDCSortCriterion
//
//  This class represents a sorting criterion (sort column and direction)
//
//------------------------------------------------------------------------

class CTDCSortCriterion
{
public:
    LONG    m_iSortCol;
    boolean m_fSortAscending;
    CTDCSortCriterion *m_pNext;

    CTDCSortCriterion()
    {
        m_pNext = NULL;
    }
    ~CTDCSortCriterion()
    {
        if (m_pNext != NULL)
            delete m_pNext;
    }
};

//------------------------------------------------------------------------
//
//  CTDCFilterNode
//
//  This class represents a tree node in a filter query.
//
//------------------------------------------------------------------------

class CTDCFilterNode
{
public:
    enum NODE_OP
    {
        NT_AND,
        NT_OR,
        NT_EQ,
        NT_NE,
        NT_LT,
        NT_GT,
        NT_LE,
        NT_GE,
        NT_ATOM,
        NT_NULL,
    };
    NODE_OP        m_type;
    CTDCFilterNode *m_pLeft;    // NT_AND ... NT_GE
    CTDCFilterNode *m_pRight;   // NT_AND ... NT_GE
    LONG           m_iCol;      // NT_ATOM, +ve column #, 0 means fixed value
    VARIANT        m_value;     // NT_ATOM, m_iCol == 0: optional fixed value
    VARTYPE        m_vt;        // NT_EQ ... NT_ATOM - type of comparison/atom
    boolean        m_fWildcard; // True for string literals with '*' wildcard

    CTDCFilterNode()
    {
        m_type = NT_NULL;
        m_pLeft = NULL;
        m_pRight = NULL;
        m_iCol = 0;
        m_vt = VT_EMPTY;
        VariantInit(&m_value);
    }
    ~CTDCFilterNode()
    {
        if (m_pLeft != NULL)
            delete m_pLeft;
        if (m_pRight != NULL)
            delete m_pRight;
        VariantClear(&m_value);
    }
};

class CEventBroker;

//------------------------------------------------------------------------
//
//  CTDCArr
//
//------------------------------------------------------------------------

class CTDCArr : public OLEDBSimpleProvider,
                public CTDCFieldSink
{
public:
    STDMETHOD(QueryInterface)   (REFIID, LPVOID FAR*);
    STDMETHOD_(ULONG,AddRef)    (THIS);
    STDMETHOD_(ULONG,Release)   (THIS);

    CTDCArr();
    STDMETHOD(Init)(CEventBroker *pEventBroker, IMultiLanguage *pML);

    //  CTDCFieldSink methods
    //
    STDMETHOD(AddField)(LPWCH pwch, DWORD dwSize);
    STDMETHOD(EOLN)();
    STDMETHOD(EOF)();

    //  TDC control methods
    //
    STDMETHOD(StartDataLoad)(boolean fUseHeader,
                             BSTR bstrSortExpr, BSTR bstrFilterExpr, LCID lcid,
                             CComObject<CMyBindStatusCallback<CTDCCtl> > *pBSC,
                             boolean fAppend, boolean fCaseSensitive);
    STDMETHOD(SetSortFilterCriteria)(BSTR bstrSortExpr, BSTR bstrFilterExpr,
                                    boolean fCaseSensitive);

    //  OLEDBSimpleProvider methods
    //
    STDMETHOD(getRowCount)(DBROWCOUNT *pcRows);
    STDMETHOD(getColumnCount)(DB_LORDINAL *pcCols);
    STDMETHOD(getRWStatus)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPRW *prwStatus);
    STDMETHOD(getVariant)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT *pVar);
    STDMETHOD(setVariant)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT Var);
    STDMETHOD(getLocale)(BSTR *pbstrLocale);
    STDMETHOD(deleteRows)(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted);
    STDMETHOD(insertRows)(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted);
    STDMETHOD(find) (DBROWCOUNT iRowStart, DB_LORDINAL iCol, VARIANT val,
            OSPFIND findFlags, OSPCOMP compType, DBROWCOUNT *piRowFound);
    STDMETHOD(addOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener);
    STDMETHOD(removeOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener);
    STDMETHOD(getEstimatedRows)(DBROWCOUNT *pcRows);    
    STDMETHOD(isAsync)(BOOL *pbAsync);
    STDMETHOD(stopTransfer)();
// ;begin_internal
    STDMETHOD(DeleteColumns)(DB_LORDINAL iCol, DB_LORDINAL cCols, DB_LORDINAL *pcColsDeleted);
    STDMETHOD(InsertColumns)(DB_LORDINAL iCol, DB_LORDINAL cCols, DB_LORDINAL *pcColsInserted);
// ;end_internal

    //  This member is used during a sort operation
    //
    int SortComp(LONG iRow1, LONG iRow2);

    enum LOAD_STATE
    {
        LS_UNINITIALISED,
        LS_LOADING_HEADER_UNAVAILABLE,
        LS_LOADING_HEADER_AVAILABLE,
        LS_LOADED,
    };
    LOAD_STATE  GetLoadState()  { return m_state; }
    void SetIsAsync(BOOL fAsync) { m_fAsync = fAsync; }
    CEventBroker    *m_pEventBroker;
    IMultiLanguage  *m_pML;

private:


    ULONG       m_cRef;         // interface reference count
    LOAD_STATE  m_state;
    LCID        m_lcid;         // Default user LCID
    LCID        m_lcidRead;     // User LCID corresponding to LANGUAGE property

    ~CTDCArr();

// ;begin_internal
#ifndef TDC_SKEL
// ;end_internal
    boolean     m_fSortFilterDisrupted;
    STDMETHOD(ApplySortFilterCriteria)();

    //  These members are used during a sort operation
    //
    CTDCSortCriterion   *m_pSortList;
    BSTR                m_bstrSortExpr;
    HRESULT CreateSortList(BSTR bstrSortCols);

    //  These members are used during a filter operation
    //
    CTDCFilterNode  *m_pFilterTree;
    BSTR            m_bstrFilterExpr;
    boolean EvalDataRow(LONG iRow, CTDCFilterNode *pNode);
    CTDCFilterNode *FilterParseComplex(LPWCH *ppwch, HRESULT *phr);
    CTDCFilterNode *FilterParseSimple(LPWCH *ppwch, HRESULT *phr);
    CTDCFilterNode *FilterParseAtom(LPWCH *ppwch, HRESULT *phr);
    LONG    m_fLastFilter;
// ;begin_internal
#endif // TDC_SKEL
// ;end_internal

    //  These members are used during a load
    //
    boolean m_fUseHeader;
    boolean m_fSkipRow;
    LONG    m_iCurrRow;
    LONG    m_iCurrCol;

    LONG    m_iDataRows;
    LONG    m_iFilterRows;
    LONG    m_iCols;
    boolean m_fCaseSensitive;

    BOOL    m_fAsync;                   // TRUE iff Async

    //  These methods and members form the internal array implementation
    //
    inline boolean fValidDataRow(LONG iRow);
    inline boolean fValidFilterRow(LONG iRow);
    inline boolean fValidCol(LONG iCol);
    inline boolean fValidDataCell(LONG iRow, LONG iCol);
    inline boolean fValidFilterCell(LONG iRow, LONG iCol);
    inline CTDCCell *GetDataCell(LONG iRow, LONG iCol);
    inline CTDCCell *GetFilterCell(LONG iRow, LONG iCol);
    inline CTDCColInfo *GetColInfo(LONG iCol);
    LONG CalcDataRows();
    LONG CalcFilterRows();
    LONG CalcCols();

    TSTDArray<TSTDArray<CTDCCell> *>   m_arrparrCells;
    TSTDArray<TSTDArray<CTDCCell> *>   m_arrparrFilter;
    TSTDArray<CTDCColInfo>             m_arrColInfo;

    //  Misc internal methods
    //
    LONG    FindCol(BSTR bstrColName);
    HRESULT GetVariantBSTR(VARIANT *pv, BSTR *pbstr, boolean *pfAllocated);
    void    RenumberColumnHeadings();
    HRESULT CreateNumberedColumnHeadings();
    HRESULT ParseColumnHeadings();
    HRESULT VariantFromBSTR(VARIANT *pv, BSTR bstr, CTDCColInfo *pColInfo, LCID);
    int VariantComp(VARIANT *pVar1, VARIANT *pVar2, VARTYPE type,
                    boolean fCaseSensitive);
    int InsertionSortHelper(int iRow);
};

inline boolean CTDCArr::fValidDataRow(LONG iRow)
{
    return iRow >= 0 && iRow <= m_iDataRows;
}

inline boolean CTDCArr::fValidFilterRow(LONG iRow)
{
    return iRow >= 0 && iRow <= m_iFilterRows;
}

inline boolean CTDCArr::fValidCol(LONG iCol)
{
    return iCol >= 1 && iCol <= m_iCols;
}

inline boolean CTDCArr::fValidDataCell(LONG iRow, LONG iCol)
{
    return fValidDataRow(iRow) && fValidCol(iCol);
}

inline boolean CTDCArr::fValidFilterCell(LONG iRow, LONG iCol)
{
    return fValidFilterRow(iRow) && fValidCol(iCol);
}

// ;begin_internal
#ifndef TDC_SKEL
// ;end_internal
inline CTDCCell *CTDCArr::GetDataCell(LONG iRow, LONG iCol)
{
    return &((*m_arrparrCells[iRow])[iCol - 1]);
}

inline CTDCColInfo *CTDCArr::GetColInfo(LONG iCol)
{
    return &m_arrColInfo[iCol - 1];
}

inline CTDCCell *CTDCArr::GetFilterCell(LONG iRow, LONG iCol)
{
    return &((*m_arrparrFilter[iRow])[iCol - 1]);
}
// ;begin_internal
#endif  // TDC_SKEL
// ;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\tdcids.h ===
#define DISPID_FIELDDELIM       1
#define DISPID_ROWDELIM         2
#define DISPID_TEXTQUALIFIER    3
#define DISPID_ESCAPECHAR       4
#define DISPID_USEHEADER        5
#define DISPID_SORTCOLUMN       6
#define DISPID_SORTASCENDING    7
#define DISPID_FILTERVALUE      8
#define DISPID_FILTERCRITERION  9
#define DISPID_FILTERCOLUMN     10
#define DISPID_CHARSET          11
#define DISPID_DATAURL          12
#define DISPID_SIMPLEPROVIDER   13
#define DISPID_LANGUAGE         14
#define DISPID_TIMER            15
#define DISPID_FILTER           16
#define DISPID_SORT             17
#define DISPID_APPENDDATA       18
#define DISPID_OSP              19
#define DISPID_CASESENSITIVE    20
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\tdcarr.cpp ===
//+-----------------------------------------------------------------------
//
//  Tabular Data Control Array
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCArr.cpp
//
//  Contents:   Implementation of the CTDCArr object.
//              This class forms the heart of the Tabular Data Control.
//              It provides the core 2D array of variant values, plus
//              a (possibly filtered/sorted) view of this data for
//              presentation through an ISimpleTabularData interface.
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include "wch.h"
#include <simpdata.h>
#include "TDC.h"
#include <MLang.h>
#include "Notify.h"
#include "TDCParse.h"
#include "TDCArr.h"
#include "TDCIds.h"

//------------------------------------------------------------------------
//
//  Function:  fWCHIsSpace()
//
//  Synopsis:  Indicates whether a WCHAR is considered a space character
//
//  Arguments: wch      Character to test
//
//  Returns:   TRUE/FALSE indicating whether the given character is
//             considered a space.
//
//------------------------------------------------------------------------

inline boolean fWCHIsSpace(WCHAR wch)
{
    return (wch == L' ' || wch == L'\t');
}


//------------------------------------------------------------------------
//
//  Function:  fWCHEatTest()
//
//  Synopsis:  Advances a string pointer over a given test character.
//
//  Arguments: ppwch      Pointer to string to test
//             wch        Match character
//
//  Returns:   TRUE indicating the character matched and the pointer has
//               been advanceed
//             FALSE indicating no match (character pointer left unchanged)
//
//------------------------------------------------------------------------

inline boolean fWCHEatTest(LPWCH *ppwch, WCHAR wch)
{
    if (**ppwch != wch)
        return FALSE;
    (*ppwch)++;
    return TRUE;
}


//------------------------------------------------------------------------
//
//  Function:  fWCHEatSpace()
//
//  Synopsis:  Advances a string pointer over white space.
//
//  Arguments: ppwch      String pointer.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

inline void fWCHEatSpace(LPWCH *ppwch)
{
    while (fWCHIsSpace(**ppwch))
        (*ppwch)++;
}


//------------------------------------------------------------------------
//
//  Method:    CTDCArr()
//
//  Synopsis:  Class constructor.  Due to the COM model, the
//             member function "Create" should be called to actually
//             initialise the STD data structures.
//
//  Arguments: None.
//
//------------------------------------------------------------------------

CTDCArr::CTDCArr() : m_cRef(1)
{
    m_pEventBroker = NULL;
    m_pSortList = NULL;
    m_bstrSortExpr = NULL;
    m_pFilterTree = NULL;
    m_bstrFilterExpr = NULL;
}

//------------------------------------------------------------------------
//
//  Member:    Init()
//
//  Synopsis:  Initialises the internal data.
//
//  Arguments: pEventBroker       Object to delegate notifications to.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::Init(CEventBroker *pEventBroker, IMultiLanguage *pML)
{
    HRESULT hr = S_OK;

    hr = m_arrparrCells.Init(0);
    if (SUCCEEDED(hr))
        hr = m_arrparrFilter.Init(0);
    if (SUCCEEDED(hr))
        hr = m_arrColInfo.Init(0);
    m_iFilterRows = CalcFilterRows();
    m_iDataRows = CalcDataRows();
    m_iCols = CalcCols();
    m_fLastFilter = FALSE;
    m_fSortFilterDisrupted = FALSE;
    m_state = LS_UNINITIALISED;
    m_lcid = GetUserDefaultLCID();
    m_lcidRead = m_lcid;
    _ASSERT(pEventBroker != NULL);

    m_pEventBroker = pEventBroker;
    m_pEventBroker->AddRef();           // better not be called with NULL

    m_pML = pML;
    m_pML->AddRef();

    m_fAsync = FALSE;                   // assume non-asynch for error cases
    return hr;
}


//------------------------------------------------------------------------
//
//  Member:    ~CTDCArr()
//
//  Synopsis:  Destructor for CTDCArr
//
//------------------------------------------------------------------------

CTDCArr::~CTDCArr()
{
    for (LONG iRow = CalcDataRows(); iRow >= 0; iRow--)
    {
        m_arrparrCells[iRow]->Passivate();
        delete m_arrparrCells[iRow];
    }
    m_arrparrCells.Passivate();
    m_arrparrFilter.Passivate();
    m_arrColInfo.Passivate();
    if (m_pSortList != NULL)
        delete m_pSortList;
    SysFreeString(m_bstrSortExpr);
    if (m_pFilterTree != NULL)
        delete m_pFilterTree;
    SysFreeString(m_bstrFilterExpr);

    if (m_pEventBroker)
    {
        m_pEventBroker->Release();
        m_pEventBroker = NULL;
    }

    ClearInterface(&m_pML);
}

LONG CTDCArr::CalcDataRows()
{
    return m_arrparrCells.GetSize() - 1;
}

LONG CTDCArr::CalcFilterRows()
{
    return m_arrparrFilter.GetSize() - 1;
}

LONG CTDCArr::CalcCols()
{
    return m_arrparrCells.GetSize() > 0
                ? m_arrparrCells[0]->GetSize() : 0;
}

//------------------------------------------------------------------------
//
//  Member:    GetRowCount()
//
//  Synopsis:  Retrieves the number of rows in the table.
//
//  Arguments: pcRows          pointer to number of rows    (OUT)
//
//  Returns:   S_OK to indicate success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::getRowCount(DBROWCOUNT *pcRows)
{
    *pcRows = m_iFilterRows;
    return S_OK;
}

//------------------------------------------------------------------------
//
//  Member:    GetColumnCount()
//
//  Synopsis:  Retrieves the number of column in the table.
//
//  Arguments: pcCols       pointer to number of columns (OUT)
//
//  Returns:   S_OK to indicate success.
//             E_UNEXPECTED if the table has not been loaded yet.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::getColumnCount(DB_LORDINAL *pcCols)
{
    *pcCols = m_iCols;
    return S_OK;
}

//------------------------------------------------------------------------
//
//  Member:    GetRWStatus()
//
//  Synopsis:  Gets the read/write status of a cell, row, column or the
//             entire array.  Since this implementation of STD can never
//             set the read/write status of a cell anywhere, all data
//             cells are presumed to have the default access and all
//             column heading cells are presumed to be read-only.  Therefore,
//             it is not necessary to keep track of this information in
//             individual cells, and this function need only return
//             the value OSPRW_DEFAULT.
//
//  Arguments: iRow            row index (-1 means all rows)
//             iCols           column index (-1 means all columns)
//             prwStatus       pointer to read/write status (OUT)
//
//  Returns:   S_OK if indices are correct (prwStatus set).
//             E_INVALIDARG if indices are out of bounds.
//             E_UNEXPECTED if the table has not been loaded yet.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::getRWStatus(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPRW *prwStatus)
{
    HRESULT hr  = S_OK;

    if ((fValidFilterRow(iRow) || iRow == -1) &&
        (fValidCol(iCol) || iCol == -1))
    {
        if (iRow == -1)
        {
            //  Should return READONLY if there is only a label row,
            //  but frameworks tend to get confused if they want to
            //  later insert data.
            //
//          *prwStatus = m_iDataRows > 0 ? OSPRW_MIXED : OSPRW_READONLY;
            *prwStatus = OSPRW_MIXED;
        }
        else if (iRow == 0)
            *prwStatus = OSPRW_READONLY;
        else
            *prwStatus = OSPRW_DEFAULT;
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

//------------------------------------------------------------------------
//
//  Member:    GetVariant()
//
//  Synopsis:  Retrieves a variant value for a cell.
//
//  Arguments: iRow            row index
//             iCols           column index
//             format          output format
//             pVar            pointer to storage for resulting value
//
//  Returns:   S_OK upon success (contents of pVar set).
//             E_INVALIDARG if indices are out of bounds.
//             E_UNEXPECTED if the table has not been loaded yet.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::getVariant(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT *pVar)
{
    HRESULT hr  = S_OK;

    if (fValidFilterCell(iRow, iCol))
    {
        CTDCCell    *pCell  = GetFilterCell(iRow, iCol);

        if (format == OSPFORMAT_RAW)
        {
            //  Copy the raw variant value
            //
            hr = VariantCopy(pVar, pCell);
        }
        else if (format == OSPFORMAT_FORMATTED || format == OSPFORMAT_HTML)
        {
            //  Construct a BSTR value representing the cell
            //
            if (pCell->vt == VT_BOOL)
            {
                //  For OLE DB spec compliance:
                //    VariantChangeTypeEx converts booleans in BSTR "0", "-1".
                //    This code yields BSTR "False", "True" instead.
                //
                VariantClear(pVar);
                pVar->vt = VT_BSTR;
                hr = VarBstrFromBool(pCell->boolVal, m_lcid, 0, &pVar->bstrVal);
            }
            else
            {
                hr = VariantChangeTypeEx(pVar, pCell, m_lcid, 0, VT_BSTR);
            }
            if (!SUCCEEDED(hr))
            {
                VariantClear(pVar);
                pVar->vt = VT_BSTR;
                pVar->bstrVal = SysAllocString(L"#Error");
            }
        }
        else
            hr = E_INVALIDARG;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

//------------------------------------------------------------------------
//
//  Member:    SetVariant()
//
//  Synopsis:  Sets a cell's variant value from a given variant value.
//             The given variant type is coerced into the column's
//             underlying type.
//
//  Arguments: iRow            row index
//             iCols           column index
//             format          output format
//             Var             value to be stored in the cell.
//
//  Returns:   S_OK upon success (contents of pVar set).
//             E_INVALIDARG if indices are out of bounds.
//             E_UNEXPECTED if the table has not been loaded yet.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::setVariant(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT Var)
{
    HRESULT hr;

    if (fValidFilterCell(iRow, iCol))
    {
        CTDCCell    *pCell  = GetFilterCell(iRow, iCol);
        CTDCColInfo *pColInfo   = GetColInfo(iCol);

        if (format == OSPFORMAT_RAW ||
            format == OSPFORMAT_FORMATTED || format == OSPFORMAT_HTML)
        {
            if (m_pEventBroker != NULL)
            {
                hr = m_pEventBroker->aboutToChangeCell(iRow, iCol);
                if (!SUCCEEDED(hr))
                    goto Cleanup;
            }

            if (Var.vt == pColInfo->vtType)
                hr = VariantCopy(pCell, &Var);
            else
            {
                //  For OLE DB spec compliance:
                //    VariantChangeTypeEx converts booleans in BSTR "0", "-1".
                //    This code yields BSTR "False", "True" instead.
                //
                if (Var.vt == VT_BOOL && pColInfo->vtType==VT_BSTR)
                {
                    VariantClear(pCell);
                    pCell->vt = VT_BSTR;
                    hr = VarBstrFromBool(Var.boolVal, m_lcid, 0, &pCell->bstrVal);
                }
                else
                    hr = VariantChangeTypeEx(pCell, &Var, m_lcid,
                                             0, pColInfo->vtType);
            }
            if (SUCCEEDED(hr) && m_pEventBroker != NULL)
                hr = m_pEventBroker->cellChanged(iRow, iCol);
            m_fSortFilterDisrupted = TRUE;
        }
        else
            hr = E_INVALIDARG;
    }
    else
        hr = E_INVALIDARG;

Cleanup:
    return hr;
}

//------------------------------------------------------------------------
//
//  Member:    GetLocale()
//
//  Synopsis:  Returns the locale of our data.
//
//  Arguments: Returns a BSTR, representing an RFC1766 form string for our
//             locale.  Note this may not necessarily match our LANGUAGE
//             param, if we had one, because teh string is canoncialized
//             by using MLang to convert it to an LCID and back to a string
//             again.
//
//  Returns:   S_OK to indicate success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::getLocale(BSTR *pbstrLocale)
{
    return m_pML->GetRfc1766FromLcid(m_lcid, pbstrLocale);
}


//+-----------------------------------------------------------------------
//
//  Member:    DeleteRows
//
//  Synopsis:  Used to delete rows from the table.  Bounds are checked
//             to make sure that the rows can all be deleted.  Label row
//             cannot be deleted.
//
//  Arguments: iRow            first row to delete
//             cRows           number of rows to delete
//             pcRowsDeleted   actual number of rows deleted (OUT)
//
//  Returns:   S_OK upon success, i.e. all rows could be deleted
//             E_INVALIDARG if cRows < 0 or any rows to be deleted
//               are out of bounds
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::deleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted)
{
    HRESULT hr;
    *pcRowsDeleted = 0;

    if (fValidFilterRow(iRow) && iRow > 0 && cRows >= 0 &&
        fValidFilterRow(iRow + cRows - 1))
    {
        if (m_pEventBroker != NULL)
        {
            hr = m_pEventBroker->aboutToDeleteRows(iRow, cRows);
            if (!SUCCEEDED(hr))
                goto Cleanup;
        }

        *pcRowsDeleted = cRows;
        hr = S_OK;
        if (cRows > 0)
        {
            //  Delete the rows from the array
            //
            m_arrparrFilter.DeleteElems(iRow, cRows);
            m_iFilterRows = CalcFilterRows();

            m_fSortFilterDisrupted = TRUE;
            //  Notify the event-handler of the deletion
            //
            if (m_pEventBroker != NULL)
                hr = m_pEventBroker->deletedRows(iRow, cRows);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    InsertRows()
//
//  Synopsis:  Allows for the insertion of new rows.  This can either be
//             used to insert new rows between existing rows, or to
//             append new rows to the end of the table.  Thus, to
//             insert new rows at the end of the table, a user would
//             specify the initial row as 1 greater than the current
//             row dimension.
//             Note that iRow is checked to ensure that it is within the
//             proper bounds (1..<current # of rows>+1).
//             User cannot delete column heading row.
//
//  Arguments: iRow            rows will be inserted *before* row 'iRow'
//             cRows           how many rows to insert
//             pcRowsInserted  actual number of rows inserted (OUT)
//
//  Returns:   S_OK upon success, i.e. all rows could be inserted.
//             E_INVALIDARG if row is out of allowed bounds.
//             It is possible that fewer than the requested rows were
//             inserted.  In this case, E_OUTOFMEMORY would be returned,
//             and the actual number of rows inserted would be set.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::insertRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted)
{
    HRESULT hr  = S_OK;
    TSTDArray<CTDCCell> **pRows = NULL;
    LONG    iTmpRow;

    //  Verify that the insertion row is within range
    //
    if (iRow < 1 || iRow > m_iFilterRows + 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (cRows <= 0)
    {
        if (cRows < 0)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

    //  Unless success is complete, assume 0 rows inserted.
    //
    *pcRowsInserted = 0;

    //  Allocate a temporary array of rows
    //
    pRows = new TSTDArray<CTDCCell>* [cRows];
    if (pRows == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    memset(pRows, '\0', sizeof(pRows[0]) * cRows);

    for (iTmpRow = 0; iTmpRow < cRows; iTmpRow++)
    {
        if ((pRows[iTmpRow] = new TSTDArray<CTDCCell>) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto CleanupTmpRows;
        }
        hr = pRows[iTmpRow]->InsertElems(0, m_iCols);
        if (!SUCCEEDED(hr))
            goto CleanupTmpRows;
    }


    //  Expand the Cell-Rows and Filter-Rows arrays to cope with the new rows.
    //
    _ASSERT(m_iFilterRows <= m_iDataRows);
    hr = m_arrparrCells.InsertElems(iRow, cRows);
    if (!SUCCEEDED(hr))
        goto CleanupTmpRows;
    hr = m_arrparrFilter.InsertElems(iRow, cRows);
    if (!SUCCEEDED(hr))
    {
        //  Undo the previous allocation
        //
        m_arrparrCells.DeleteElems(iRow, cRows);
        goto CleanupTmpRows;
    }

    if (m_pEventBroker != NULL)
    {
        hr = m_pEventBroker->aboutToInsertRows(iRow, cRows);
        if (FAILED(hr))
            goto CleanupTmpRows;
    }

    //  Copy across the row pointers
    //
    for (iTmpRow = 0; iTmpRow < cRows; iTmpRow++)
    {
        m_arrparrCells[iRow + iTmpRow] = pRows[iTmpRow];
        m_arrparrFilter[iRow + iTmpRow] = pRows[iTmpRow];
    }

    //  Return indicating success
    //
    *pcRowsInserted = cRows;
    m_iFilterRows = CalcFilterRows();;
    m_iDataRows = CalcDataRows();

    // Fire events:
    if (*pcRowsInserted != 0)
    {
        m_fSortFilterDisrupted = TRUE;
        if (m_pEventBroker != NULL)
            hr = m_pEventBroker->insertedRows(iRow, cRows);
    }
    goto Cleanup;

CleanupTmpRows:
    //  Free the memory associated with the tmp rows.
    //
    for (iTmpRow = 0; iTmpRow < cRows; iTmpRow++)
        if (pRows[iTmpRow] != NULL)
            delete pRows[iTmpRow];

Cleanup:
    if (pRows != NULL)
        delete pRows;
    return hr;
}

// ;begin_internal
//+-----------------------------------------------------------------------
//
//  Member:    DeleteColumns()
//
//  Synopsis:  Used to delete columns from the table.  Bounds are checked
//             to make sure that the columns can all be deleted.  Label
//             column cannot be deleted.
//
//  Arguments: iCol               first column to delete
//             cCols              number of columns to delete
//             pcColsDeleted      actual number of rows deleted (OUT)
//
//  Returns:   S_OK upon succes, i.e. all columns could be deleted
//             E_INVALIDARG if column is out of allowed bounds.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::DeleteColumns(DB_LORDINAL iCol, DB_LORDINAL cCols, DB_LORDINAL *pcColsDeleted)
{
    HRESULT hr;

    if (fValidCol(iCol) && iCol > 0 && cCols >= 0 &&
        fValidCol(iCol + cCols - 1))
    {
        *pcColsDeleted = cCols;
        hr = S_OK;
        if (cCols > 0)
        {
            for (LONG iRow = 0; iRow < m_iFilterRows; iRow++)
            {
                TSTDArray<CTDCCell> *pRow;

                pRow = m_arrparrCells[iRow];
                pRow->DeleteElems(iCol - 1, cCols);
            }
            m_arrColInfo.DeleteElems(iCol - 1, cCols);
            m_iCols = CalcCols();

            if (!m_fUseHeader)
                RenumberColumnHeadings();

            m_fSortFilterDisrupted = TRUE;

            //  Notify the event-handler of the deletion
            //
#ifdef NEVER
            if (m_pEventBroker != NULL)
                hr = m_pEventBroker->DeletedCols(iCol, cCols);
#endif
        }
        _ASSERT(m_arrColInfo.GetSize() == (ULONG) m_iCols);
    }
    else
    {
        hr = E_INVALIDARG;
        *pcColsDeleted = 0;
    }
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    InsertColumns()
//
//  Synopsis:  Allows for the insertion of new columns.  This can either be
//             used to insert new columns between existing columns, or to
//             append new columns to the end of the table.  Thus, to
//             insert new columns at the end of the table, a user would
//             specify the initial columns as 1 greater than the current
//             columns dimension.
//             Note that iColumn is checked to ensure that it is within the
//             proper bounds (1..<current # of cols>+1).
//
//  Arguments: iCol            columns will be inserted *before* row 'iCol'
//             cCols           how many columns to insert
//             pcColsInserted  actual number of columns inserted (OUT)
//
//  Returns:   S_OK upon success, i.e. all columns could be inserted.
//             E_INVALIDARG if column is out of allowed bounds.
//             It is possible that fewer than the requested columns were
//             inserted.  In this case, E_OUTOFMEMORY would be returned,
//             and the actual number of columns inserted would be set.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::InsertColumns(DB_LORDINAL iCol, DB_LORDINAL cCols, DB_LORDINAL *pcColsInserted)
{
    HRESULT hr  = S_OK;
    LONG iTmpRow;

    //  Verify that the insertion column is within range
    //
    if (iCol < 1 || iCol > m_iCols + 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (cCols <= 0)
    {
        if (cCols < 0)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

    //  Unless success is complete, assume 0 columns inserted.
    //
    *pcColsInserted = 0;

    for (iTmpRow = 0; iTmpRow <= m_iDataRows; iTmpRow++)
    {
        hr = m_arrparrCells[iTmpRow]->InsertElems(iCol, cCols);
        if (!SUCCEEDED(hr))
        {
            //  Undo the changes we've done
            //
            while (--iTmpRow >= 0)
                m_arrparrCells[iTmpRow]->DeleteElems(iCol, cCols);
            goto Cleanup;
        }
    }

    //  Return indicating success
    //
    *pcColsInserted = cCols;
    m_iCols = CalcCols();

    // Fire events:
    if (*pcColsInserted != 0)
    {
        m_fSortFilterDisrupted = TRUE;
#ifdef NEVER
        if (m_pEventBroker != NULL)
            hr = m_pEventBroker->InsertedCols(iCol, cCols);
#endif
    }

Cleanup:
    //  If we're using automatically numbered column headings and some
    //  columns were inserted, then renumber the columns.
    //
    if (*pcColsInserted > 0 && !m_fUseHeader)
        RenumberColumnHeadings();

    return hr;
}
// ;end_internal

//+-----------------------------------------------------------------------
//
//  Member:    Find()
//
//  Synopsis:  Searches for a row matching the specified criteria
//
//  Arguments: iRowStart       The starting row for the search
//             iCol            The column being tested
//             vTest           The value against which cells in the
//                               test column are tested
//             findFlags       Flags indicating whether to search up/down
//                               and whether comparisons are case sensitive.
//             compType        The comparison operator for matching (find a
//                             cell =, >=, <=, >, <, <> the test value)
//             piRowFound      The row with a matching cell [OUT]
//
//  Returns:   S_OK upon success, i.e. a row was found (piRowFound set).
//             E_FAIL upon failure, i.e. a row was not found.
//             E_INVALIDARG if starting row 'iRowStart' or test column 'iCol'
//               are out of bounds.
//             DISP_E_TYPEMISMATCH if the test value's type does not match
//               the test column's type.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::find(DBROWCOUNT iRowStart, DB_LORDINAL iCol, VARIANT vTest,
        OSPFIND findFlags, OSPCOMP compType, DBROWCOUNT *piRowFound)
{
    HRESULT hr = S_OK;
    boolean fUp = FALSE;
    boolean fCaseSensitive  = FALSE;
    LONG    iRow;

    *piRowFound = -1;

    //  Validate arguments
    //
    if (iRowStart < 1 || !fValidFilterRow(iRowStart) || !fValidCol(iCol))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (GetColInfo(iCol)->vtType != vTest.vt)
    {
        //  Search-value type does not match the underlying column type
        //  Fail as per spec.
        //
        hr = DISP_E_TYPEMISMATCH;
        goto Cleanup;
    }

    if ((findFlags & OSPFIND_UP) != 0)
        fUp = TRUE;
    if ((findFlags & OSPFIND_CASESENSITIVE) != 0)
        fCaseSensitive = TRUE;

    for (iRow = iRowStart;
         fUp ? iRow > 0 : iRow <= m_iFilterRows;
         fUp ? iRow-- : iRow++)
    {
        int         iCmp = VariantComp(GetFilterCell(iRow, iCol), &vTest, vTest.vt, fCaseSensitive);
        boolean     fFound  = FALSE;

        switch (compType)
        {
        case OSPCOMP_LT:    fFound = iCmp <  0; break;
        case OSPCOMP_LE:    fFound = iCmp <= 0; break;
        case OSPCOMP_GT:    fFound = iCmp >  0; break;
        case OSPCOMP_GE:    fFound = iCmp >= 0; break;
        case OSPCOMP_EQ:    fFound = iCmp == 0; break;
        case OSPCOMP_NE:    fFound = iCmp != 0; break;
        default:
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        if (fFound)
        {
            *piRowFound = iRow;
            hr = S_OK;
            goto Cleanup;
        }
    }

    hr = E_FAIL;

Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    addOLEDBSimpleProviderListener()
//
//  Synopsis:  Sets or clears a reference to the COM object which receives
//             notifications of cell changes, row/column insert/deletes etc.
//
//  Arguments: pEvent          Pointer to the COM object to receive
//                             notifications, or NULL if no notifications
//                             are to be sent.
//
//  Returns:   S_OK upon success.
//             Error code upon success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pSTDEvents)
{
    HRESULT hr = S_OK;

    if (m_pEventBroker == NULL)
        hr = E_FAIL;
    else
    {
        hr = m_pEventBroker->SetSTDEvents(pSTDEvents);
        // If the event sink has been added, and we're already loaded,
        // then fire transferComplete, because we probably couldn't before.
        if (LS_LOADED==m_state)
            m_pEventBroker->STDLoadCompleted();
    }
    return hr;
}

STDMETHODIMP
CTDCArr::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pSTDEvents)
{
    HRESULT hr = S_OK;

    if (m_pEventBroker && pSTDEvents==m_pEventBroker->GetSTDEvents())
        hr = m_pEventBroker->SetSTDEvents(NULL);
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    FindCol()
//
//  Synopsis:  Locate a column by name
//
//  Arguments: pwchColName        Name of column to locate
//
//  Returns:   +ve Column number upon success (column name matched)
//             0 upon failure (no column name matched)
//
//------------------------------------------------------------------------

LONG
CTDCArr::FindCol(LPWCH pwchColName)
{
    LONG iCol = 0;

    if (pwchColName != NULL)
    {
        for (iCol = m_iCols; iCol > 0; iCol--)
        {
            CTDCCell    *pCell  = GetDataCell(0, iCol);

            _ASSERT(pCell->vt == VT_BSTR);
            if (wch_icmp(pwchColName, pCell->bstrVal) == 0)
                break;
        }
    }
    return iCol;
}

class SortElt
{
public:
    CTDCArr *pInstance;
    int     iRow;
    TSTDArray<CTDCCell> *   parrRow;
};

//+-----------------------------------------------------------------------
//
//  Function:  CompareSort()
//
//  Synopsis:  Called by qsort() to order the rows of a table.
//
//  Arguments: pElt1, pElt1       pointers to elements to be compared
//
//  Returns:   -1 if the first element is less than the second element
//              0 if the first element equals the second element
//             +1 if the first element is greater than the second element
//
//------------------------------------------------------------------------

static int __cdecl
CompareSort(const void *pElt1, const void *pElt2)
{
    SortElt *pse1   = (SortElt *) pElt1;
    SortElt *pse2   = (SortElt *) pElt2;

    return pse1->pInstance->SortComp(pse1->iRow, pse2->iRow);
}

//+-----------------------------------------------------------------------
//
//  Function:  extract_num()
//
//  Synopsis:  Extracts the first non-negative number from the character
//             stream referenced by 'ppwch'.  Updates 'ppwch' to point
//             to the character following the digits found.
//
//  Arguments: ppwch      Pointer to null-terminated WCHAR string
//
//  Returns:   Non-negative number extracted upon success (pointer updated)
//             -1 upon failure (no digits found; pointer moved to end-of-string
//
//+-----------------------------------------------------------------------

static int
extract_num(WCHAR **ppwch)
{
    int retval  = 0;
    boolean fFoundDigits    = FALSE;

    if (*ppwch != NULL)
    {
        //  Skip over leading non-digits
        //
        while ((**ppwch) != 0 && ((**ppwch) < L'0' || (**ppwch) > L'9'))
            (*ppwch)++;

        //  Accumulate digits
        //
        fFoundDigits = *ppwch != 0;
        while ((**ppwch) >= L'0' && (**ppwch) <= L'9')
            retval = 10 * retval + *(*ppwch)++ - L'0';
    }

    return fFoundDigits ? retval : -1;
}


//+-----------------------------------------------------------------------
//
//  Member:    CreateNumberedColumnHeadings()
//
//  Synopsis:  Allocates cells for numbered column headings.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if there was insufficient memory to complete
//             the operation.
//
//------------------------------------------------------------------------

HRESULT CTDCArr::CreateNumberedColumnHeadings()
{
    HRESULT hr  = S_OK;
    LONG    iCol;

    iCol = m_iCols;

    //  Allocate a new row entry
    //
    hr = m_arrparrCells.InsertElems(0, 1);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    //  Allocate a new row of cells
    //
    m_arrparrCells[0] = new TSTDArray<CTDCCell>;
    if (m_arrparrCells[0] == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = m_arrparrCells[0]->InsertElems(0, iCol);

Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    RenumberColumnHeadings()
//
//  Synopsis:  Set the automatic name "Column<column-number>" for each column
//
//  Arguments: None.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

void CTDCArr::RenumberColumnHeadings()
{
    for (LONG iCol = m_iCols; iCol > 0; iCol--)
    {
        CTDCCell    *pCell  = GetDataCell(0, iCol);
        WCHAR       awchLabel[20];

        wch_cpy(awchLabel, L"Column");
        _ltow(iCol, &awchLabel[6], 10);

        pCell->clear();
        pCell->vt = VT_BSTR;
        pCell->bstrVal = SysAllocString(awchLabel);
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    ParseColumnHeadings()
//
//  Synopsis:  Extracts type information (if present) from column
//             headings, removes leadning
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if there was insufficient memory to complete
//             the operation.
//
//------------------------------------------------------------------------

HRESULT CTDCArr::ParseColumnHeadings()
{
    LPWCH   pwchIntType     = L"int";
    LPWCH   pwchFloatType   = L"float";
    LPWCH   pwchStringType  = L"string";
    LPWCH   pwchBooleanType = L"boolean";
    LPWCH   pwchDateType    = L"date";

    HRESULT hr  = S_OK;
    LONG    iCol;

    iCol = m_iCols;

    //  Allocate space for column type info
    //
    hr = m_arrColInfo.InsertElems(0, iCol);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    for (; iCol > 0; iCol--)
    {
        //  Column headings have the format:
        //      <column-name>[:<typename>[,<format>]]
        //
        CTDCColInfo *pColInfo   = GetColInfo(iCol);
        CTDCCell    *pCell      = GetDataCell(0, iCol);

        _ASSERT(pCell->vt == VT_BSTR);

        BSTR        bstr;
        LPWCH       pColon;

        bstr = pCell->bstrVal;
        pColInfo->vtType = VT_BSTR;     //  Default type for a column is BSTR
        pColon = wch_chr(bstr, L':');
        if (pColon != NULL)
        {
            WCHAR   *pwchFormat = NULL;
            LPWCH   pSpace;

            *pColon++ = 0;
            pSpace = wch_chr(pColon, L' ');

            if (pSpace != NULL)
            {
                *pSpace++ = '\0';
                pwchFormat = pSpace;
            }
            if (wch_icmp(pColon, pwchIntType) == 0)
                pColInfo->vtType = VT_I4;
            else if (wch_icmp(pColon, pwchFloatType) == 0)
                pColInfo->vtType = VT_R8;
            else if (wch_icmp(pColon, pwchStringType) == 0)
                pColInfo->vtType = VT_BSTR;
            else if (wch_icmp(pColon, pwchBooleanType) == 0)
                pColInfo->vtType = VT_BOOL;
            else if (wch_icmp(pColon, pwchDateType) == 0)
            {
                pColInfo->vtType = VT_DATE;

                TDCDateFmt  fmt = TDCDF_NULL;

                if (pwchFormat != NULL)
                {
                    int nPos    = 0;
                    int nDayPos = 0;
                    int nMonPos = 0;
                    int nYearPos= 0;

                    //  Convert the format string into an internal enum type
                    //  Find the relative positions of the letters 'D' 'M' 'Y'
                    //
                    for (; *pwchFormat != 0; nPos++, pwchFormat++)
                    {
                        switch (*pwchFormat)
                        {
                        case L'D':
                        case L'd':
                            nDayPos = nPos;
                            break;
                        case L'M':
                        case L'm':
                            nMonPos = nPos;
                            break;
                        case L'Y':
                        case L'y':
                            nYearPos = nPos;
                            break;
                        }
                    }
                    //  Compare the relative positions to work out the format
                    //
                    if (nDayPos < nMonPos && nMonPos < nYearPos)
                        fmt = TDCDF_DMY;
                    else if (nMonPos < nDayPos && nDayPos < nYearPos)
                        fmt = TDCDF_MDY;
                    else if (nDayPos < nYearPos && nYearPos < nMonPos)
                        fmt = TDCDF_DYM;
                    else if (nMonPos < nYearPos && nYearPos < nDayPos)
                        fmt = TDCDF_MYD;
                    else if (nYearPos < nMonPos && nMonPos < nDayPos)
                        fmt = TDCDF_YMD;
                    else if (nYearPos < nDayPos && nDayPos < nMonPos)
                        fmt = TDCDF_YDM;
                }
                pColInfo->datefmt = fmt;
            }
        }

        if (bstr != NULL)
        {
            //  Remove leading/trailing spaces from column name
            //
            LPWCH       pwch;
            LPWCH       pwchDest = NULL;
            LPWCH       pLastNonSpace = NULL;

            for (pwch = bstr; *pwch != 0; pwch++)
            {
                if (!fWCHIsSpace(*pwch))
                {
                    if (pwchDest == NULL)
                        pwchDest = bstr;
                    pLastNonSpace = pwchDest;
                }
                if (pwchDest != NULL)
                    *pwchDest++ = *pwch;
            }
            if (pLastNonSpace == NULL)
                bstr[0] = 0;        // all spaces!  Make it null string.
            else
                pLastNonSpace[1] = 0;
        }

        //  Copy the modified column header and free the original
        //
        pCell->bstrVal = SysAllocString(bstr);
        SysFreeString(bstr);

        if (pCell->bstrVal == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    VariantFromBSTR()
//
//  Synopsis:  Convert a BSTR value into a variant compatible with a
//             given column type.
//
//  Arguments: pVar       Pointer to resultant variant value
//             bstr       Source BSTR
//             pColInfo   Column information (type, format options etc).
//             lcid       Locale # for locale-specific conversion.
//
//  Returns:   S_OK upon success (pVar set)
//             OLE_E_CANTCONVERT if the given BSTR is badly formatted
//               (e.g. contains an invalid date value for a date conversion).
//             E_OUTOFMEMORY if insufficient memory is available for
//               a conversion.
//
//------------------------------------------------------------------------

HRESULT CTDCArr::VariantFromBSTR(VARIANT *pVar, BSTR bstr, CTDCColInfo *pColInfo, LCID lcid)
{
    HRESULT hr  = E_FAIL;

    VariantInit(pVar);
    switch (pColInfo->vtType)
    {
    case VT_DATE:
        if (pColInfo->datefmt != TDCDF_NULL)
        {
            //  Parse the date string according to specified format.
            //  First, find the three numeric components in the date.
            //
            USHORT  n1;
            USHORT  n2;
            USHORT  n3;
            WCHAR   *pwch   = bstr;
            SYSTEMTIME  st;

            n1 = (USHORT)extract_num(&pwch);
            n2 = (USHORT)extract_num(&pwch);
            n3 = (USHORT)extract_num(&pwch);

            memset(&st, '\0', sizeof(st));
            switch (pColInfo->datefmt)
            {
            case TDCDF_DMY:
                st.wDay = n1;
                st.wMonth = n2;
                st.wYear = n3;
                break;
            case TDCDF_MDY:
                st.wDay = n2;
                st.wMonth = n1;
                st.wYear = n3;
                break;
            case TDCDF_DYM:
                st.wDay = n1;
                st.wMonth = n3;
                st.wYear = n2;
                break;
            case TDCDF_MYD:
                st.wDay = n3;
                st.wMonth = n1;
                st.wYear = n2;
                break;
            case TDCDF_YMD:
                st.wDay = n3;
                st.wMonth = n2;
                st.wYear = n1;
                break;
            case TDCDF_YDM:
                st.wDay = n2;
                st.wMonth = n3;
                st.wYear = n1;
                break;
            }

            VariantClear(pVar);
            if (n1 >= 0 && n2 >= 0 && n3 >= 0 &&
                SystemTimeToVariantTime(&st, &pVar->date))
            {
                pVar->vt = VT_DATE;
                hr = S_OK;
            }
            else
                hr = OLE_E_CANTCONVERT;
        }
        else
        {
            //  No date format specified - just use the default conversion
            //
            VARIANT vSrc;

            VariantInit(&vSrc);
            vSrc.vt = VT_BSTR;
            vSrc.bstrVal = bstr;
            hr = VariantChangeTypeEx(pVar, &vSrc, lcid, 0, pColInfo->vtType);
        }
        break;
    case VT_BOOL:
    case VT_I4:
    case VT_R8:
    default:
        //
        //  Perform a standard conversion.
        //
        {
            VARIANT vSrc;

            VariantInit(&vSrc);
            vSrc.vt = VT_BSTR;
            vSrc.bstrVal = bstr;
            hr = VariantChangeTypeEx(pVar, &vSrc, lcid, 0, pColInfo->vtType);
        }
        break;
    case VT_BSTR:
        //
        //  Duplicate the BSTR
        //
        pVar->bstrVal = SysAllocString(bstr);
        if (bstr != NULL && pVar->bstrVal == NULL)
            hr = E_OUTOFMEMORY;
        else
        {
            pVar->vt = VT_BSTR;
            hr = S_OK;
        }
        break;
    }
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    VariantComp()
//
//  Synopsis:  Compares two variant values.
//
//  Arguments: pVar1            First variant value
//             pVar2            Second variant value
//             fCaseSensitive   TRUE if string comparisons should be
//                              case-sensitive, false if string comparisons
//                              should be case-insensitive.  Ignored if
//                              non-string data types are being compared.
//
//  Returns:   -1 if
//             OLE_E_CANTCONVERT if the given BSTR is badly formatted
//               (e.g. contains an invalid date value for a date conversion).
//             E_OUTOFMEMORY if insufficient memory is available for
//               a conversion.
//
//------------------------------------------------------------------------

int CTDCArr::VariantComp(VARIANT *pVar1, VARIANT *pVar2, VARTYPE type,
    boolean fCaseSensitive)
{
    int retval = 0;

    //  NULLs are lexically less than anything else
    //
    if (pVar1->vt == VT_NULL)
        retval = pVar2->vt == VT_NULL ? 0 : -1;
    else if (pVar2->vt == VT_NULL)
        retval = 1;
    else if (pVar1->vt != type)
    {
        //  Type-mismatches are lexically greater than anything else
        //
        retval = pVar2->vt == type ? 1 : 0;
    }
    else if (pVar2->vt != type)
    {
        //  Type-mismatches are lexically greater than anything else
        //
        retval = -1;
    }
    else
    {
        switch (type)
        {
        case VT_I4:
            retval = pVar1->lVal < pVar2->lVal
                ? -1
                : pVar1->lVal > pVar2->lVal
                    ? 1
                    : 0;
            break;
        case VT_R8:
            retval = pVar1->dblVal < pVar2->dblVal
                ? -1
                : pVar1->dblVal > pVar2->dblVal
                    ? 1
                    : 0;
            break;
        case VT_BSTR:
            retval = fCaseSensitive
                ? wch_cmp(pVar1->bstrVal, pVar2->bstrVal)
                : wch_icmp(pVar1->bstrVal, pVar2->bstrVal);
            break;
        case VT_BOOL:
            retval = pVar1->boolVal
                ? (pVar2->boolVal ? 0 : 1)
                : (pVar2->boolVal ? -1 : 0);
            break;
        case VT_DATE:
            retval = pVar1->date < pVar2->date
                ? -1
                : pVar1->date > pVar2->date
                    ? 1
                    : 0;
            break;
        default:
            retval = 0;     //  Unrecognised types are all lexically equal
            break;
        }
    }

    return retval;
}

//+-----------------------------------------------------------------------
//
//  Method:    CreateSortList()
//
//  Synopsis:  Creates a list of sort criteria from a text description.
//
//  Arguments: bstrSortCols          ';'-separted list of column names,
//                                   optionally prefixed with '+' (default)
//                                   or '-' indicating ascending or descending
//                                   sort order respectively for that column.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if insufficient memory is available for
//               the construction of sort criteria.
//
//  Side Effect:   Saves created list in m_pSortList
//
//+-----------------------------------------------------------------------

HRESULT CTDCArr::CreateSortList(BSTR bstrSortCols)
{
    HRESULT     hr = S_OK;

    if (m_pSortList != NULL)
    {
        delete m_pSortList;
        m_pSortList = NULL;
    }
    if (bstrSortCols != NULL)
    {
        WCHAR   *pwchEnd  = bstrSortCols;
        CTDCSortCriterion   **pLast = &m_pSortList;

        while (*pwchEnd != 0)
        {
            WCHAR   *pwchStart  = pwchEnd;
            boolean fSortAscending = TRUE;

            //  Discard leading white space and field-separators
            //
            while (*pwchStart == L';' || fWCHIsSpace(*pwchStart))
                pwchStart++;

            //  Strip off optional direction indicator + white space
            //
            if (*pwchStart == L'+' || *pwchStart == '-')
            {
                fSortAscending = *pwchStart++ == L'+';
                while (fWCHIsSpace(*pwchStart))
                    pwchStart++;
            }

            //  Find the field terminator.
            //  Strip out trailing white spaces.
            //
            for (pwchEnd = pwchStart; *pwchEnd != 0 && *pwchEnd != L';';)
                pwchEnd++;

            while (pwchStart < pwchEnd && fWCHIsSpace(pwchEnd[-1]))
                pwchEnd--;

            //  Ignore blank column names - this could be the result of
            //  a leading or trailing ';'.
            //
            if (pwchStart >= pwchEnd)
                continue;

            //  Find the column number from the column name
            //
            BSTR bstrColName = SysAllocStringLen(pwchStart, pwchEnd - pwchStart);

            if (bstrColName == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            LONG iCol = FindCol(bstrColName);
            SysFreeString(bstrColName);

            if (iCol > 0)
            {
                //  Allocate a node for this criterion
                //
                _ASSERT(*pLast == NULL);
                *pLast = new CTDCSortCriterion;
                if (*pLast == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                (*pLast)->m_fSortAscending = fSortAscending;
                (*pLast)->m_iSortCol = iCol;
                pLast = &(*pLast)->m_pNext;
            }
        }
    }

Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Method:    SortComp()
//
//  Synopsis:  Compares two rows using the elememts in the columns specified
//             by the current sort criteria.
//
//  Arguments: iRow1      Index of first row being compared
//             iRow2      Index of second row being compared
//
//  Returns:   -1 if first row should be sorted before the second row
//             0 if rows are equal
//             1 if first row should be sorted after the second row
//
//+-----------------------------------------------------------------------

int CTDCArr::SortComp(LONG iRow1, LONG iRow2)
{
    CTDCSortCriterion   *pCriterion;
    int     cmp = 0;

    for (pCriterion = m_pSortList;
         pCriterion != NULL && cmp == 0;
         pCriterion = pCriterion->m_pNext)
    {
        CTDCCell    *pCell1 = GetFilterCell(iRow1, pCriterion->m_iSortCol);
        CTDCCell    *pCell2 = GetFilterCell(iRow2, pCriterion->m_iSortCol);

        cmp = VariantComp(pCell1, pCell2, GetColInfo(pCriterion->m_iSortCol)->vtType,
                         m_fCaseSensitive);
        if (!pCriterion->m_fSortAscending)
            cmp = -cmp;
    }
    return cmp;
}

//+-----------------------------------------------------------------------
//
//  Method:    FilterParseComplex()
//
//  Synopsis:  Takes the text of a filter query, parses it and creates
//             a tree of CTDCFilterNode representing the query.
//
//  Arguments: phr: pointer to HRESULT value, set to indicate success/failure.
//
//             ppwchQuery:  This is a textual representation of a query.  The
//                          query language syntax is:
//
//               Query ::== Complex
//
//               Complex ::== Simple
//                       ::== Simple '&' Simple ( '&' Simple ... )
//                       ::== Simple '|' Simple ( '|' Simple ... )
//
//               Simple ::== '(' Complex ')'
//                      ::== Atom Relop Atom
//
//               Relop ::== '=' | '>' | '>=' | '<' | '<=' | '<>'
//
//               Atom ::== Bunch of characters up to a (, ), >, <, =, & or |
//                         If it's recognisable as field name, then it's
//                         treated as a field name.  Otherwise it's treated
//                         as a value.  Quotes (") are processed, and force
//                         the atom to be treated as a value.  Escape
//                         characters (\) are processed and allow the
//                         use of special characters within a field name.
//
//               Notes:
//               -----
//                  * The definition of 'Complex' expressly forbids mixing
//                    logical ANDs and ORs ('&' and '|') unless parentheses
//                    are used to clarify the query.  Something like:
//                          field1 > 2 & field3 = "lime" | field4 < 5
//                    is illegal, but:
//                          (field1 > 2 & field3 = "lime") | field4 < 5
//                    is fine.
//
//                  * It is illegal to attempt a comparison of two columns
//                    with different types.
//
//
//  Returns:   Pointer to parsed Filter Node upon success (*phr set to S_OK)
//             NULL upon failure (*phr set to an appropriate error code)
//
//+-----------------------------------------------------------------------

CTDCFilterNode *CTDCArr::FilterParseComplex(LPWCH *ppwchQuery, HRESULT *phr)
{
    *phr = S_OK;
    CTDCFilterNode  *retval;
    WCHAR   wchBoolOp   = 0;

    retval = FilterParseSimple(ppwchQuery, phr);

    //  Stop if there's an error, or we encounter a terminating ')' or '\0'
    //
    while (retval != NULL && **ppwchQuery != L')' && **ppwchQuery != 0)
    {
        //  Next character should be a matching logical connector ...
        //
        if (**ppwchQuery != L'&' && **ppwchQuery != L'|')
        {
            *phr = E_FAIL;
            break;
        }
        if (wchBoolOp == 0)
            wchBoolOp = **ppwchQuery;
        else if (wchBoolOp != **ppwchQuery)
        {
            *phr = E_FAIL;
            break;
        }
        (*ppwchQuery)++;
        CTDCFilterNode *pTmp = new CTDCFilterNode;
        if (pTmp == NULL)
        {
            *phr = E_OUTOFMEMORY;
            break;
        }
        pTmp->m_type = (wchBoolOp == L'&')
            ? CTDCFilterNode::NT_AND
            : CTDCFilterNode::NT_OR;
        pTmp->m_pLeft = retval;
        retval = pTmp;
        retval->m_pRight = FilterParseSimple(ppwchQuery, phr);
        if (retval->m_pRight == NULL)
            break;
    }
    if (!SUCCEEDED(*phr) && retval != NULL)
    {
        delete retval;
        retval = NULL;
    }
    return retval;
}

CTDCFilterNode *CTDCArr::FilterParseSimple(LPWCH *ppwch, HRESULT *phr)
{
    *phr = S_OK;
    CTDCFilterNode  *retval = NULL;

    fWCHEatSpace(ppwch);    //  Eat up white space

    if (fWCHEatTest(ppwch, L'('))
    {
        retval = FilterParseComplex(ppwch, phr);
        if (retval != NULL)
        {
            if (fWCHEatTest(ppwch, L')'))
                fWCHEatSpace(ppwch);    //  Eat up white space
            else
                *phr = E_FAIL;
        }
        goto Cleanup;
    }

    retval = FilterParseAtom(ppwch, phr);
    if (retval == NULL)
        goto Cleanup;

    {
        CTDCFilterNode *pTmp = new CTDCFilterNode;
        if (pTmp == NULL)
        {
            *phr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pTmp->m_pLeft = retval;
        retval = pTmp;
    }

    retval->m_vt = retval->m_pLeft->m_vt;

    //  Get the relational operator
    //
    if (fWCHEatTest(ppwch, L'='))
        retval->m_type = CTDCFilterNode::NT_EQ;
    else if (fWCHEatTest(ppwch, L'>'))
        retval->m_type = fWCHEatTest(ppwch, L'=')
            ? CTDCFilterNode::NT_GE
            : CTDCFilterNode::NT_GT;
    else if (fWCHEatTest(ppwch, L'<'))
        retval->m_type = fWCHEatTest(ppwch, L'=')
                ? CTDCFilterNode::NT_LE
                : fWCHEatTest(ppwch, L'>')
                    ? CTDCFilterNode::NT_NE
                    : CTDCFilterNode::NT_LT;
    else
    {
        *phr = E_FAIL;
        goto Cleanup;
    }

    retval->m_pRight = FilterParseAtom(ppwch, phr);
    if (retval->m_pRight == NULL)
        goto Cleanup;

    if (retval->m_pLeft->m_iCol <= 0 && retval->m_pRight->m_iCol <= 0)
    {
        //  At least one of the atoms being compared must be a column
        //
        //  This condition means we don't have to test for comparison
        //  of two wildcard values.
        //
        *phr = E_FAIL;
        goto Cleanup;
    }

    //  Check type compatibility of atoms
    //
    if (retval->m_pRight->m_vt != retval->m_vt)
    {
        CTDCFilterNode  *pSrc = retval->m_pRight;
        CTDCFilterNode  *pTarg= retval->m_pLeft;

        if (retval->m_pLeft->m_iCol > 0)
        {
            if (retval->m_pRight->m_iCol > 0)
            {
                //  Two columns of incompatible type - can't resolve
                //
                *phr = E_FAIL;
                goto Cleanup;
            }
            pSrc = retval->m_pLeft;
            pTarg = retval->m_pRight;
        }
        _ASSERT(pTarg->m_vt == VT_BSTR);
        _ASSERT(pTarg->m_iCol == 0);
        _ASSERT(pSrc->m_iCol > 0);
        CTDCColInfo *pColInfo = GetColInfo(pSrc->m_iCol);
        _ASSERT(pColInfo->vtType == pSrc->m_vt);
        VARIANT vtmp;
        VariantInit(&vtmp);
        *phr = VariantFromBSTR(&vtmp, pTarg->m_value.bstrVal, pColInfo, m_lcid);
        if (!SUCCEEDED(*phr))
            goto Cleanup;
        VariantClear(&pTarg->m_value);
        pTarg->m_value = vtmp;
        pTarg->m_vt = pSrc->m_vt;
        retval->m_vt = pSrc->m_vt;
    }

Cleanup:
    if (!SUCCEEDED(*phr) && retval != NULL)
    {
        delete retval;
        retval = NULL;
    }
    return retval;
}

CTDCFilterNode *CTDCArr::FilterParseAtom(LPOLESTR *ppwch, HRESULT *phr)
{
    *phr = S_OK;
    CTDCFilterNode  *retval = NULL;
    int nQuote  = 0;
    boolean fDone = FALSE;
    LPOLESTR   pwchDest;
    LPOLESTR   pwchLastStrip;

    fWCHEatSpace(ppwch);    //  Eat up white space

    OLECHAR   *pwchTmpBuf = new OLECHAR[wch_len(*ppwch) + 1];
    if (pwchTmpBuf == NULL)
    {
        *phr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pwchDest = pwchTmpBuf;
    pwchLastStrip = pwchTmpBuf;

    while (**ppwch != 0 && !fDone)
        switch (**ppwch)
        {
            case _T('\\'):
            //  Handle escape characters
            //
                if ((*pwchDest++ = *++(*ppwch)) != 0)
                {
                    (*ppwch)++;
                    pwchLastStrip = pwchDest;
                }
                break;
            case _T('"'):
            //  Quotes
            //
                (*ppwch)++;
                pwchLastStrip = pwchDest;
                nQuote++;
                break;
            case _T('>'):
            case _T('<'):
            case _T('='):
            case _T('('):
            case _T(')'):
            case _T('&'):
            case _T('|'):
                fDone = ((nQuote & 1) == 0);
                if (fDone)
                    break;

            default:
                *pwchDest++ = *(*ppwch)++;
        }

    //  Strip off trailing white space
    //
    while (pwchDest > pwchLastStrip && fWCHIsSpace(pwchDest[-1]))
        pwchDest--;
    *pwchDest = 0;

    if ((pwchDest == pwchTmpBuf && nQuote == 0) || (nQuote & 1))
    {
        //  Empty string or mismatched quote
        //
        *phr = E_FAIL;
        goto Cleanup;
    }

    retval = new CTDCFilterNode;
    if (retval == NULL)
    {
        *phr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    retval->m_type = CTDCFilterNode::NT_ATOM;
    retval->m_iCol = nQuote > 0 ? 0 : FindCol(pwchTmpBuf);
    if (retval->m_iCol == 0)
    {
        retval->m_vt = VT_BSTR;
        retval->m_value.vt = VT_BSTR;
        retval->m_value.bstrVal = SysAllocString(pwchTmpBuf);
        if (retval->m_value.bstrVal == NULL)
        {
            *phr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        retval->m_fWildcard = wch_chr(retval->m_value.bstrVal, _T('*')) != NULL;
    }
    else
    {
        retval->m_vt = GetColInfo(retval->m_iCol)->vtType;
        retval->m_fWildcard = FALSE;
    }

Cleanup:
    if (pwchTmpBuf != NULL)
        delete pwchTmpBuf;
    if (!SUCCEEDED(*phr) && retval != NULL)
    {
        delete retval;
        retval = NULL;
    }
    return retval;
}

//+-----------------------------------------------------------------------
//
//  Method:    EvalDataRow()
//
//  Synopsis:  Evaluates the given data row # against the filter query
//             represented by 'pNode'.
//
//  Arguments: iRow      The number of the row to evaluate.
//             pNode     A filter query to the row against.
//
//  Returns:   TRUE if the given row satisfies the filter query.
//             FALSE otherwise.
//
//+-----------------------------------------------------------------------

boolean CTDCArr::EvalDataRow(LONG iRow, CTDCFilterNode *pNode)
{
    boolean retval  = TRUE;
    VARIANT *pVar1;
    VARIANT *pVar2;

    _ASSERT(pNode != NULL);
    switch (pNode->m_type)
    {
    case CTDCFilterNode::NT_AND:
        retval = EvalDataRow(iRow, pNode->m_pLeft) &&
                 EvalDataRow(iRow, pNode->m_pRight);
        break;
    case CTDCFilterNode::NT_OR:
        retval = EvalDataRow(iRow, pNode->m_pLeft) ||
                 EvalDataRow(iRow, pNode->m_pRight);
        break;
    case CTDCFilterNode::NT_EQ:
    case CTDCFilterNode::NT_NE:
    case CTDCFilterNode::NT_LT:
    case CTDCFilterNode::NT_GT:
    case CTDCFilterNode::NT_LE:
    case CTDCFilterNode::NT_GE:
        pVar1 = &pNode->m_pLeft->m_value;
        pVar2 = &pNode->m_pRight->m_value;

        if (pNode->m_pLeft->m_iCol > 0)
            pVar1 = GetDataCell(iRow, pNode->m_pLeft->m_iCol);
        if (pNode->m_pRight->m_iCol > 0)
            pVar2 = GetDataCell(iRow, pNode->m_pRight->m_iCol);

        if ((pNode->m_pLeft->m_fWildcard || pNode->m_pRight->m_fWildcard) &&
            (pNode->m_type == CTDCFilterNode::NT_EQ ||
             pNode->m_type == CTDCFilterNode::NT_NE) &&
             pVar1->vt == VT_BSTR && pVar2->vt == VT_BSTR)
        {
            //  Wildcards are only meaningful in comparing strings
            //  for equlaity / inequality
            //
            VARIANT *pText;
            VARIANT *pPattern;

            if (pNode->m_pLeft->m_fWildcard)
            {
                pPattern = pVar1;
                pText = pVar2;
            }
            else
            {
                pText = pVar1;
                pPattern = pVar2;
            }

            retval = wch_wildcardMatch(pText->bstrVal, pPattern->bstrVal,
                                       m_fCaseSensitive)
                ? (pNode->m_type == CTDCFilterNode::NT_EQ)
                : (pNode->m_type == CTDCFilterNode::NT_NE);
        }
        else
        {
            int     cmp;

            cmp = VariantComp(pVar1, pVar2, pNode->m_vt, m_fCaseSensitive);

            switch (pNode->m_type)
            {
            case CTDCFilterNode::NT_LT:    retval = cmp <  0;  break;
            case CTDCFilterNode::NT_LE:    retval = cmp <= 0;  break;
            case CTDCFilterNode::NT_GT:    retval = cmp >  0;  break;
            case CTDCFilterNode::NT_GE:    retval = cmp >= 0;  break;
            case CTDCFilterNode::NT_EQ:    retval = cmp == 0;  break;
            case CTDCFilterNode::NT_NE:    retval = cmp != 0;  break;
            }
        }
        break;

    default:
        _ASSERT(FALSE);
    }
    return retval;
}

//+-----------------------------------------------------------------------
//
//  Method:    ApplySortFilterCriteria()
//
//  Synopsis:  Resets any filter and sorting criterion for the control to
//             the values specified.  Initiates sort/filter operations
//             if appropriate.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if there was insufficient memory to complete
//               the operation.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::ApplySortFilterCriteria()
{
    HRESULT hr  = S_OK;
    LONG iRow;

    if (!m_fSortFilterDisrupted ||
        m_state == LS_UNINITIALISED ||
        m_state == LS_LOADING_HEADER_UNAVAILABLE)
    {
        //  No change, or can't do anything yet.
        //
        goto Cleanup;
    }

    //  Discard the old parse trees
    //
    if (m_pSortList != NULL)
        delete m_pSortList;
    if (m_pFilterTree != NULL)
        delete m_pFilterTree;

    m_pSortList = NULL;
    m_pFilterTree = NULL;

    //  Discard old filtered rows
    //
    if (m_arrparrFilter.GetSize() > 0)
        m_arrparrFilter.DeleteElems(0, m_arrparrFilter.GetSize());

    //  Create an array of filter rows from the data rows
    //
    hr = m_arrparrFilter.InsertElems(0, m_iDataRows + 1);
    if (!SUCCEEDED(hr))
        goto Cleanup;
    for (iRow = 0; iRow <= m_iDataRows; iRow++)
        m_arrparrFilter[iRow] = m_arrparrCells[iRow];
    m_iFilterRows = CalcFilterRows();

    //  Create the filter parse tree
    //
    if (m_bstrFilterExpr != NULL)
    {
        LPWCH pwchQuery = m_bstrFilterExpr;

        m_pFilterTree = FilterParseComplex(&pwchQuery, &hr);
        if (hr == E_FAIL || (m_pFilterTree != NULL && *pwchQuery != 0))
        {
            //  Parse failed or there were unparsed characters left over.
            //  This gets treated as an 'include everything' filter.
            //
            if (m_pFilterTree != NULL)
            {
                delete m_pFilterTree;
                m_pFilterTree = NULL;
            }
            hr = S_OK;
        }
    }

    //  Filter the rows
    //
    if (m_pFilterTree != NULL)
    {
        LONG    iRowDest    = 1;

        for (iRow = 1; iRow <= m_iFilterRows; iRow++)
            if (EvalDataRow(iRow, m_pFilterTree))
                m_arrparrFilter[iRowDest++] = m_arrparrFilter[iRow];
        if (iRowDest < iRow)
            m_arrparrFilter.DeleteElems(iRowDest, iRow - iRowDest);
        m_iFilterRows = CalcFilterRows();
    }

    //  Create the sort list
    //
    hr = CreateSortList(m_bstrSortExpr);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    //  Sort the filtered rows
    //
    if (m_pSortList != NULL && m_iFilterRows > 0)
    {
        SortElt *pSortArr   = new SortElt[m_iFilterRows + 1];
        if (pSortArr == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        for (iRow = 0; iRow <= m_iFilterRows; iRow++)
        {
            pSortArr[iRow].pInstance = this;
            pSortArr[iRow].iRow = iRow;
            pSortArr[iRow].parrRow = m_arrparrFilter[iRow];
        }

        qsort((void *)&pSortArr[1], m_iFilterRows, sizeof(pSortArr[0]), CompareSort);

        for (iRow = 0; iRow <= m_iFilterRows; iRow++)
            m_arrparrFilter[iRow] = pSortArr[iRow].parrRow;

        delete pSortArr;

    }

    m_fSortFilterDisrupted = FALSE;

    if (m_state == LS_LOADING_HEADER_AVAILABLE && m_iDataRows > 0)
    {
        //  We've just parsed the sort/filter expressions - there
        //  was no data to sort/filter, so dont register a change.
    }
    else
    {
        //  Notify the event-broker of the changes
        //
        if (m_pEventBroker != NULL)
			hr = m_pEventBroker->STDDataSetChanged();
    }

Cleanup:
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Method:    SetSortFilterCriteria()
//
//  Synopsis:  Resets any filter and sorting criterion for the control to
//             the values specified.  Initiates sort/filter operations
//             if any the changes invalidate existing criteria.
//
//  Arguments: bstrSortExpr    List of columns for sorting ("" = no sorting)
//             bstrFilterExpr  Expression for filtering ("" = no filtering)
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if there was insufficient memory to complete
//               the operation.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::SetSortFilterCriteria(BSTR bstrSortExpr, BSTR bstrFilterExpr,
                              boolean fCaseSensitive)
{
    HRESULT hr  = S_OK;


    //  Check if we need to reparse the sort/filter criteria
    //

    if (wch_cmp(bstrSortExpr, m_bstrSortExpr) != 0 ||
        wch_cmp(bstrFilterExpr, m_bstrFilterExpr) != 0 ||
        fCaseSensitive != m_fCaseSensitive)
    {
        m_fSortFilterDisrupted = TRUE;
    }
    SysFreeString(m_bstrSortExpr);
    SysFreeString(m_bstrFilterExpr);
    m_bstrSortExpr = bstrSortExpr;
    m_bstrFilterExpr = bstrFilterExpr;
    m_fCaseSensitive = fCaseSensitive;

    //  If not loaded, leave it to the load process to apply any changes
    //
    if (m_state == LS_LOADED)
        hr = ApplySortFilterCriteria();
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Method:    CTDCCStartDataLoad()
//
//  Synopsis:  Preparation for a load operation via FieldSink routines below
//
//  Arguments: fUseHeader      TRUE if the first line of fields should
//                               be interpreted as column name/type info.
//             bstrSortExpr    Sort expression for ordering rows
//             bstrFilterExpr  Filter expression for including/excluding rows
//             lcidRead        Locale ID to use for interpreting locale-
//                               dependent data formats (date, number etc).
//             pBSC            COM object performing the data transfer
//             fAppend         Flag indicating whether the data should be
//                             appended to any existing data.
//
//  Returns:   S_OK indicating success.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::StartDataLoad(boolean fUseHeader, BSTR bstrSortExpr,
    BSTR bstrFilterExpr, LCID lcidRead,
    CComObject<CMyBindStatusCallback<CTDCCtl> > *pBSC,
    boolean fAppend, boolean fCaseSensitive)
{
    HRESULT hr  = S_OK;

    //  If we're asked to append to existing data AND
    //     - there isn't any OR
    //     - the previous load didn't load a header row
    //  then treat it as an initial load.
    //
    if (fAppend && m_state == LS_UNINITIALISED)
        fAppend = FALSE;

    if (fAppend)
    {
        if (m_state != LS_LOADED || m_iDataRows < 0)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        m_state = LS_LOADING_HEADER_AVAILABLE;
    }
    else
    {
        if (m_state != LS_UNINITIALISED ||
            m_iDataRows != -1 ||
            m_iFilterRows != -1 ||
            m_iCols != 0)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        m_state = LS_LOADING_HEADER_UNAVAILABLE;
        m_fSortFilterDisrupted = TRUE;
    }

    SetSortFilterCriteria(bstrSortExpr, bstrFilterExpr,
                         fCaseSensitive);

    m_fUseHeader = fUseHeader;
    m_fSkipRow = fAppend && fUseHeader;
    _ASSERT(m_iFilterRows == CalcFilterRows());
    _ASSERT(m_iDataRows == CalcDataRows());
    _ASSERT(m_iCols == CalcCols());
    m_iCurrRow = m_iDataRows + 1;
    m_iCurrCol = 1;
    m_lcidRead = lcidRead;
    if (m_pEventBroker != NULL)
    hr = m_pEventBroker->STDLoadStarted(pBSC, fAppend);

Cleanup:
    return hr;
}



//////////////////////////////////////////////////////////////////////////
//
//        CTDCFieldSink Methods - see comments in file TDCParse.h
//        ---------------------
//
//////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------
//
//  Method:    AddField()
//
//  Synopsis:  Adds a data cell to the growing cell grid.
//
//  Arguments: pwch         Wide-char string holding data for the cell
//             dwSize       # of significant bytes in 'pwch'
//
//  Returns:   S_OK indicating success.
//             E_OUTOFMEMORY if there was not enough memory to add the cell.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::AddField(LPWCH pwch, DWORD dwSize)
{
    _ASSERT(m_state == LS_LOADING_HEADER_UNAVAILABLE ||
            m_state == LS_LOADING_HEADER_AVAILABLE);

    HRESULT hr          = S_OK;
    LONG    nCols       = 0;
    BSTR    bstr        = NULL;

    if (m_fSkipRow)
        goto Cleanup;
#ifdef TDC_ATL_DEBUG_ADDFIELD
    ATLTRACE( _T("CTDCArr::AddField called: %d, %d\n"), m_iCurrRow, m_iCurrCol);
#endif

    if (m_iCurrRow > m_iDataRows && m_iCurrCol == 1)
    {
        TSTDArray<CTDCCell> *pRow;

        //  Need to insert a new row
        //
        _ASSERT(m_iCurrRow == m_iDataRows + 1);
        hr = m_arrparrCells.InsertElems(m_iCurrRow, 1);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        pRow = new TSTDArray<CTDCCell>;
        if (pRow == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        m_arrparrCells[m_iCurrRow] = pRow;
        if (m_iCurrRow > 0)
        {
            //  We've already read at least one row, so we know how
            //  many columns to insert for this row
            //
            hr = m_arrparrCells[m_iCurrRow]->InsertElems(0, m_iCols);
            if (!SUCCEEDED(hr))
                goto Cleanup;
        }
    }
    if (m_iCurrRow == 0)
    {
        //  This is the first row - we don't know how many columns there
        //  will be, so just insert a single cell for this new element.
        //
        _ASSERT(m_iCurrCol == m_iCols + 1);
        hr = m_arrparrCells[m_iCurrRow]->InsertElems(m_iCurrCol - 1, 1);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        m_iCols++;
    }

    if (m_iCurrCol <= m_iCols)
    {
        CTDCCell    *pCell  = GetDataCell(m_iCurrRow, m_iCurrCol);

        pCell->clear();
        pCell->vt = VT_BSTR;

        if (dwSize <= 0)
            pCell->bstrVal = NULL;
        else
        {
            pCell->bstrVal = SysAllocStringLen(pwch, dwSize);
            if (pCell->bstrVal == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        if (m_iCurrRow > 0)
        {
            CTDCColInfo *pColInfo = GetColInfo(m_iCurrCol);

            if (pColInfo->vtType != VT_BSTR)
            {
                VARIANT     v;
                HRESULT     hr;

                hr = VariantFromBSTR(&v, pCell->bstrVal, pColInfo, m_lcidRead);
                if (SUCCEEDED(hr))
                {
                    hr = VariantCopy(pCell, &v);
                    VariantClear(&v);
                }
                else
                {
                    //  Leave it as a BSTR
                    //
                    hr = S_OK;
                }
            }
        }
    }

    m_iCurrCol++;

Cleanup:
    return hr;
}

// InsertionSortHelper -
//  returns -1 if the candidate row < current filter array row
//           0 if the candidate row = current filter array row
//           1 if the candidate row > current filter array row

int
CTDCArr::InsertionSortHelper(int iRow)
{
    CTDCSortCriterion *pCriterion;
    int cmp = 0;

    for (pCriterion = m_pSortList; pCriterion != NULL;
         pCriterion = pCriterion->m_pNext)
    {
        CTDCCell    *pCell1 = GetDataCell(m_iDataRows, pCriterion->m_iSortCol);
        CTDCCell    *pCell2 = GetFilterCell(iRow, pCriterion->m_iSortCol);

        cmp = VariantComp(pCell1, pCell2,
                          GetColInfo(pCriterion->m_iSortCol)->vtType, m_fCaseSensitive);

        if (!pCriterion->m_fSortAscending)
            cmp = -cmp;

        // if < or >, we don't have to look at any further criterion
        if (cmp)
            break;
    }
    return cmp;
}

//+-----------------------------------------------------------------------
//
//  Method:    EOLN()
//
//  Synopsis:  Closes of the current row in the growing cell grid,
//               handling column headings if it's the first row.
//
//  Arguments: None.
//
//  Returns:   S_OK indicating success.
//             E_OUTOFMEMORY if insufficient memory is available for
//               a conversion.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::EOLN()
{
    ATLTRACE(_T("CTDCArr::EOLN called, row: %d\n"), m_iCurrRow);

    HRESULT hr  = S_OK;

    _ASSERT(m_state == LS_LOADING_HEADER_UNAVAILABLE ||
            m_state == LS_LOADING_HEADER_AVAILABLE);

    if (m_fSkipRow)
    {
        //  Appending to existing data; skip over the first (header) line
        m_fSkipRow = FALSE;
        goto Cleanup;
    }

    if (m_iCurrRow == 0)
    {
        //  The first row has been inserted - if m_fUseHeader indicates
        //  that the first row contains header information then parse
        //  it; otherwise, create some numbered column headings.
        //
        if (!m_fUseHeader)
        {
            hr = CreateNumberedColumnHeadings();
            if (!SUCCEEDED(hr))
                goto Cleanup;

            //  An extra row has been inserted - update the insertion
            //  row index for later insertion of new elements
            //
            m_iCurrRow++;

            //  Initialise each column heading as "Column<column#>"
            //
            RenumberColumnHeadings();
        }

        m_iDataRows++;
        m_iFilterRows++;
        _ASSERT(m_iDataRows == 0);
        _ASSERT(m_iFilterRows == 0);

        ParseColumnHeadings();

        m_state = LS_LOADING_HEADER_AVAILABLE;

        //  Insert the hedaer row into the list of filtered rows
        //
        hr = m_arrparrFilter.InsertElems(0, 1);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        m_arrparrFilter[0] = m_arrparrCells[0];

        //  Notify the event handler that the headers have been loaded
        //
        if (m_pEventBroker != NULL)
        {
            hr = m_pEventBroker->STDLoadedHeader();
            OutputDebugStringX(_T("TDCCtl: header loaded\n"));
            if (!SUCCEEDED(hr))
                goto Cleanup;
        }
    }

    if (m_iCurrRow > 0)
    {
        //  Convert uninitialised cells into their column's type.
        //
        LONG    iCol;

        for (iCol = m_iCurrCol; iCol < m_iCols; iCol++)
        {
            CTDCCell    *pCell    = GetDataCell(m_iCurrRow, iCol);

            //  This uninitialised VARIANT is assumed to be the result
            //  of specifying too few cells in a row.
            //
            _ASSERT(pCell->vt == VT_EMPTY);
            pCell->vt = VT_BSTR;
            pCell->bstrVal = NULL;

            CTDCColInfo *pColInfo = GetColInfo(iCol);

            if (pColInfo->vtType != VT_BSTR)
            {
                VARIANT     v;
                HRESULT     tmp_hr;

                tmp_hr = VariantFromBSTR(&v, pCell->bstrVal, pColInfo, m_lcidRead);
                if (SUCCEEDED(tmp_hr))
                {
                    hr = VariantCopy(pCell, &v);
                    VariantClear(&v);
                    if (!SUCCEEDED(hr))
                        goto Cleanup;
                }
                else
                {
                    //  Leave the cell as a BSTR
                    //
                }
            }
        }
        m_iDataRows++;
    }

    m_iCurrCol = 1;
    m_iCurrRow++;

    if (m_fSortFilterDisrupted)
    {
        //  This will have the side-effect of incorporating any new data rows
        //
        hr = ApplySortFilterCriteria();
        if (!SUCCEEDED(hr))
            goto Cleanup;
    }
    else if (m_iDataRows > 0 &&
        (m_pFilterTree == NULL || EvalDataRow(m_iDataRows, m_pFilterTree)))
    {
        //  The new row passed the filter criteria.
        //  Insert the new row into the filtered list
        //
        LONG iRowInsertedAt = m_iFilterRows + 1;

        //  at the correct insertion point according to the current
        //  sort criteria, if there is one.  We only need to do the search
        //  if this is not the first row, and if the candidate row is less
        //  than the last row.
        if (m_pSortList != NULL && m_iFilterRows != 0
            && InsertionSortHelper(m_iFilterRows) < 0)
        {
            // not at end, do traditional binary search.
            LONG lLow = 1;          // we don't use element zero!
            LONG lHigh = m_iFilterRows + 1;
            LONG lMid;

            while (lLow < lHigh)
            {
                lMid = (lLow + lHigh) / 2;
                // Note that InsertionSortHelper automatically flips the comparison
                // if m_fAscending flag is off.
                if (InsertionSortHelper(lMid) <= 0)
                {
                    lHigh = lMid;
                }
                else
                {
                    lLow = lMid + 1;
                }
            }
            iRowInsertedAt = lLow;
        }

        hr = m_arrparrFilter.InsertElems(iRowInsertedAt, 1);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        m_arrparrFilter[iRowInsertedAt] = m_arrparrCells[m_iDataRows];
        ++m_iFilterRows;

        //  Notify event handler of row insertion
        //
        if (m_pEventBroker != NULL)
            hr = m_pEventBroker->rowsAvailable(iRowInsertedAt, 1);

    }

Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Method:    EOF()
//
//  Synopsis:  Indicates no more cells will be added to the cell grid.
//             The column-heading cells are added unless it was indicated
//             that cell headings should be taken from the data read.
//             The cells in each column are converted to that column's
//             specified data type.
//
//  Arguments: None.
//
//  Returns:   S_OK indicating success.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::EOF()
{
    OutputDebugStringX(_T("CTDArr::EOF() called\n"));
    _ASSERT(m_state == LS_LOADING_HEADER_UNAVAILABLE ||
            m_state == LS_LOADING_HEADER_AVAILABLE);
    HRESULT hr = S_OK;

    if (m_iCurrCol > 1)
        EOLN();
    m_state = LS_LOADED;
    m_iFilterRows = CalcFilterRows();
    _ASSERT(m_iDataRows == CalcDataRows());
    _ASSERT(m_iCols == CalcCols());

    if (m_fSortFilterDisrupted)
    {
        hr = ApplySortFilterCriteria();
        if (!SUCCEEDED(hr))
            goto Cleanup;
    }
    if (m_pEventBroker != NULL)
        hr = m_pEventBroker->STDLoadCompleted();

Cleanup:
    return hr;
}

// GetEstimatedRows..
// We should really see if URLMon has a means of giving a byte count on the file
// we're downloading.  For now though..
STDMETHODIMP
CTDCArr::getEstimatedRows(DBROWCOUNT *pcRows)
{
    *pcRows = m_iFilterRows;
    if (m_state<LS_LOADED)
    {
        // Return twice number of rows, but be careful not to return 2 * 0.
        *pcRows = m_iFilterRows ? m_iFilterRows * 2 : -1;
    }
    return S_OK;
}

STDMETHODIMP
CTDCArr::isAsync(BOOL *pbAsync)
{
//    *pbAsync = m_fAsync;
    // The TDC always behaves as if it's Async.  Specifically, we always fire
    // TransferComplete, even if we have to buffer the notification until our
    // addOLEDBSimplerProviderListener is actually called.
    *pbAsync = TRUE;
    return S_OK;
}

STDMETHODIMP
CTDCArr::stopTransfer()
{
    HRESULT hr = S_OK;

    //  Force the load state into UNINITIALISED or LOADED ...
    //
    switch (m_state)
    {
    case LS_UNINITIALISED:
    case LS_LOADED:
        break;

    case LS_LOADING_HEADER_UNAVAILABLE:
        //  Free any allocated cell memory
        //
        if (m_arrparrFilter.GetSize() > 0)
            m_arrparrFilter.DeleteElems(0, m_arrparrFilter.GetSize());
        if (m_arrparrCells.GetSize() > 0)
            m_arrparrCells.DeleteElems(0, m_arrparrCells.GetSize());
        m_state = LS_UNINITIALISED;
        m_iFilterRows = CalcFilterRows();
        m_iDataRows = CalcDataRows();
        m_iCols = CalcCols();

        // If we stop the load before the header was parsed, we won't
        // have a dataset, but we still need to fire datasetchanged,
        // to let our customer know the query failed.
        if (m_pEventBroker != NULL)
            hr = m_pEventBroker->STDDataSetChanged();

        //
        // fall through to LOADING_HEADER_AVAILABLE!
        //

    case LS_LOADING_HEADER_AVAILABLE:
        m_state = LS_LOADED;            // mark us as finished now

        // LoadStopped will abort any transfer in progress, and fire
        // transferComplete with the OSPXFER_ABORT flag.
        if (m_pEventBroker != NULL)
            hr = m_pEventBroker->STDLoadStopped();
        break;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
//        Implementation of IUnknown COM interface.
//        -----------------------------------------
//
//////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------
//
//  Method:    QueryInterface()
//
//  Synopsis:  Implements part of the standard IUnknown COM interface.
//               (Returns a pointer to this COM object)
//
//  Arguments: riid          GUID to recognise
//             ppv           Pointer to this COM object [OUT]
//
//  Returns:   S_OK upon success.
//             E_NOINTERFACE if queried for an unrecognised interface.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::QueryInterface (REFIID riid, LPVOID * ppv)
{
    HRESULT hr;

    _ASSERTE(ppv != NULL);

    // This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown || riid == IID_OLEDBSimpleProvider)
    {
        *ppv = this;
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

#ifdef _ATL_DEBUG_QI
    AtlDumpIID(riid, _T("CTDCArr"), hr);
#endif
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Method:    AddRef()
//
//  Synopsis:  Implements part of the standard IUnknown COM interface.
//               (Adds a reference to this COM object)
//
//  Arguments: None
//
//  Returns:   Number of references to this COM object.
//
//+-----------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CTDCArr::AddRef ()
{
    return ++m_cRef;
}


//+-----------------------------------------------------------------------
//
//  Method:    Release()
//
//  Synopsis:  Implements part of the standard IUnknown COM interface.
//               (Removes a reference to this COM object)
//
//  Arguments: None
//
//  Returns:   Number of remaining references to this COM object.
//             0 if the COM object is no longer referenced.
//
//+-----------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CTDCArr::Release ()
{
    ULONG retval;

    m_cRef -= 1;
    retval = m_cRef;
    if (!m_cRef)
    {
        m_cRef = 0xffff;    //MM: Use this 'flag' for debug?
        delete this;
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\tdcparse.cpp ===
//------------------------------------------------------------------------
//
//  Tabular Data Control Parsing Module
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCParse.cpp
//
//  Contents:   Implementation of CTDCParse classes.
//
//------------------------------------------------------------------------


#include "stdafx.h"
#include <simpdata.h>
#include "TDC.h"
#include <MLang.h>
#include "Notify.h"
#include "TDCParse.h"
#include "TDCArr.h"
#include "locale.h"
#include "wch.h"

//#ifndef DISPID_AMBIENT_CODEPAGE
//#define DISPID_AMBIENT_CODEPAGE (-725)
//#endif

#define BYTE_ORDER_MARK 0xFEFF
#define REVERSE_BYTE_ORDER_MARK 0xFFFE

//------------------------------------------------------------------------
//
//  Function:   IsSpace()
//
//  Synopsis:   Returns TRUE if the given character is a space or tab character.
//
//  Arguments:  ch            Character to test.
//
//  Returns:    TRUE if 'ch' is a space or tab character.
//              FALSE otherwise.
//
//------------------------------------------------------------------------

inline boolean IsSpace(WCHAR ch)
{
    return (ch == L' ' || ch == L'\t');
}

//////////////////////////////////////////////////////////////////////////
//
//        CTDCTokenise Class - see comments in file TDCParse.h
//        ------------------
//////////////////////////////////////////////////////////////////////////


//------------------------------------------------------------------------
//
//  Method:     CTDCTokenise::Create()
//
//  Synopsis:   Initialise the CTDCTokenise object
//
//  Arguments:  pFieldSink         Object to send parsed fields to.
//              wchDelimField      \
//              wchDelimRow         |  Set of characters that control
//              wchQuote            |  the parsing of fields
//              wchEscape          /
//
//  Returns:    S_OK indicating success.
//
//------------------------------------------------------------------------

HRESULT CTDCUnify::InitTokenizer(CTDCFieldSink *pFieldSink, WCHAR wchDelimField,
                                 WCHAR wchDelimRow, WCHAR wchQuote, WCHAR wchEscape)
{
    _ASSERT(pFieldSink != NULL);
    m_pFieldSink = pFieldSink;
    m_wchDelimField = wchDelimField;
    m_wchDelimRow = wchDelimRow;
    m_wchQuote = wchQuote;
    m_wchEscape = wchEscape;
    m_ucParsed = 0;

    m_fIgnoreNextLF = FALSE;
    m_fIgnoreNextCR = FALSE;
    m_fIgnoreNextWhiteSpace = FALSE;
    m_fEscapeActive = FALSE;
    m_fQuoteActive = FALSE;
    m_fFoldWhiteSpace = FALSE;

    //  Ensure that the field and row delimiters are set.
    //
    if (m_wchDelimRow == 0)
        m_wchDelimRow = DEFAULT_ROW_DELIM[0];

    //  Remove conflicting delimiter values
    //
    if (m_wchDelimRow == m_wchDelimField)
        m_wchDelimRow = 0;
    if (m_wchQuote != 0)
    {
        if (m_wchQuote == m_wchDelimField || m_wchQuote == m_wchDelimRow)
            m_wchQuote = 0;
    }
    if (m_wchEscape != 0)
    {
        if (m_wchEscape == m_wchDelimField ||
            m_wchEscape == m_wchDelimRow ||
            m_wchEscape == m_wchQuote)
            m_wchEscape = 0;
    }

    m_fFoldCRLF = (m_wchDelimRow == L'\r' || m_wchDelimRow == L'\n');

    return S_OK;
}

//------------------------------------------------------------------------
//
//  Method:     CTDCTokenise::AddWcharBuffer()
//
//  Synopsis:   Takes a buffer of characters, breaks it up into fields
//              and passes them to the embedded CTDCFieldSink object
//              as fields.
//
//  Arguments:  pwch               Buffer containing characters to be parsed.
//              dwSize             Number of significant characters in 'pwch'
//                                  dwSize == 0 means "End-of-stream"
//
//  Returns:    S_OK upon success.
//              E_OUTOFMEMORY indicating insufficient memory to carry
//                out the parse operation.
//              Other misc error code upon failure.
//
//------------------------------------------------------------------------

HRESULT CTDCUnify::AddWcharBuffer(BOOL fLastData)
{

    OutputDebugStringX(_T("CTDCTokenise::AddWcharBuffer called\n"));

    _ASSERT(m_pFieldSink != NULL);

    HRESULT hr = S_OK;

    LPWCH   pwchCurr;   //  Next character to process
    LPWCH   pwchEnd;    //  End-of-buffer marker
    LPWCH   pwchDest;   //  Where to write next char processed
    LPWCH   pwchStart;  //  Beginning of current token

    pwchStart = &m_psWcharBuf[0];
    pwchCurr = pwchStart + m_ucParsed;
    pwchDest = pwchCurr;
    pwchEnd = &m_psWcharBuf[m_ucWcharBufCount];

    //  Read up to the next field boundary (field or row delimiter)
    //
    while (pwchCurr < pwchEnd)
    {
        if (m_fIgnoreNextLF)
        {
            //  We're expecting a LF to terminate a CR-LF sequence.
            //
            m_fIgnoreNextLF = FALSE;
            if (*pwchCurr == L'\n')
            {
                //  Found a LF - ignore it
                //
                pwchCurr++;
                continue;
            }

            //  Found something else - carry on ...
            //
        }

        if (m_fIgnoreNextCR)
        {
            //  We're expecting a CR to terminate a LF-CR sequence.
            //
            m_fIgnoreNextCR = FALSE;
            if (*pwchCurr == L'\r')
            {
                //  Found a CR - ignore it
                //
                pwchCurr++;
                continue;
            }

            //  Found something else - carry on ...
            //
        }

        if (m_fIgnoreNextWhiteSpace)
        {
            //  We're expecting the rest of a white-space sequence
            //
            if (IsSpace(*pwchCurr))
            {
                //  Found white-space - ignore it
                //
                pwchCurr++;
                continue;
            }
            m_fIgnoreNextWhiteSpace = FALSE;
        }

        //  Escape characters work, even in quoted strings
        //
        if (m_fEscapeActive)
        {
            *pwchDest++ = *pwchCurr++;
            m_fEscapeActive = FALSE;
            continue;
        }
        if (*pwchCurr == m_wchEscape)
        {
            pwchCurr++;
            m_fEscapeActive = TRUE;
            continue;
        }

        //  Quotes activate/deactivate Field/Row delimiters
        //
        if (*pwchCurr == m_wchQuote)
        {
            pwchCurr++;
            m_fQuoteActive = !m_fQuoteActive;
            continue;
        }

        if (m_fQuoteActive)
        {
            *pwchDest++ = *pwchCurr++;
            continue;
        }


        if (*pwchCurr == m_wchDelimField ||
            (m_fFoldWhiteSpace && IsSpace(*pwchCurr)))
        {
            hr = m_pFieldSink->AddField(pwchStart, pwchDest - pwchStart);
            if (!SUCCEEDED(hr))
                goto Cleanup;
            pwchCurr++;
            if (m_fFoldWhiteSpace && IsSpace(*pwchCurr))
                m_fIgnoreNextWhiteSpace = TRUE;
            pwchStart = &m_psWcharBuf[0];
            pwchDest = pwchStart;
            continue;
        }

        if (*pwchCurr == m_wchDelimRow ||
            (m_fFoldCRLF && (*pwchCurr == L'\r' || *pwchCurr == L'\n')))
        {
            hr = m_pFieldSink->AddField(pwchStart, pwchDest - pwchStart);
            if (!SUCCEEDED(hr))
                goto Cleanup;
            hr = m_pFieldSink->EOLN();
            if (!SUCCEEDED(hr))
                goto Cleanup;
            if (m_fFoldCRLF)
            {
                m_fIgnoreNextLF = (*pwchCurr == L'\r');
                m_fIgnoreNextCR = (*pwchCurr == L'\n');
            }
            pwchCurr++;
            pwchStart = &m_psWcharBuf[0];
            pwchDest = pwchStart;
            continue;
        }

        *pwchDest++ = *pwchCurr++;
    }
    
    m_ucWcharBufCount = pwchDest - pwchStart;
    m_ucParsed = pwchDest - pwchStart;  // amount we've already parsed

    // If this is the last data packet, and there's a fragment left,
    // parse it.
    if (m_ucWcharBufCount && fLastData)
    {
        hr = m_pFieldSink->AddField(pwchStart, m_ucParsed);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        m_ucParsed = 0;
        hr = m_pFieldSink->EOLN();
        return hr;
    }


Cleanup:
    return hr;
}




//////////////////////////////////////////////////////////////////////////
//
//        CTDCUnify Class - see comments in file TDCParse.h
//        ---------------
//////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::CTDCUnify()
//
//  Synopsis:   Constuctor
//
//------------------------------------------------------------------------

CTDCUnify::CTDCUnify()
{
    m_pML = NULL;
}

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::~CTDCUnify()
//
//  Synopsis:   Destructor
//
//------------------------------------------------------------------------

CTDCUnify::~CTDCUnify()
{
    delete [] m_psByteBuf;
    delete [] m_psWcharBuf;

    if (m_pML != NULL)
        m_pML->Release();
}

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::Create()
//
//  Synopsis:   Initialise the CTDCUnify object
//
//  Arguments:  pTokenise         Object to send converted buffers to.
//              nCodePage         Code page for ASCII->Unicode conversions
//              pML               MLANG COM object (used for conversions)
//
//  Returns:    S_OK to indicate success.
//
//------------------------------------------------------------------------

HRESULT CTDCUnify::Create(UINT nCodePage, UINT nAmbientCodePage, IMultiLanguage *pML)
{
    m_pML = pML;
    m_pML->AddRef();
    m_nCodePage = nCodePage;
    m_nAmbientCodePage = nAmbientCodePage;
    m_fDataMarkedUnicode = FALSE;
    m_fDataIsUnicode = FALSE;
    m_dwBytesProcessed = 0;
    m_fCanConvertToUnicode = 0;
    m_nUnicode = 0;
    m_fProcessedAllowDomainList = FALSE;

    m_dwConvertMode = 0;
    m_ucByteBufSize = 0;
    m_ucByteBufCount = 0;
    m_psByteBuf = NULL;

    m_ucWcharBufSize = 0;
    m_ucWcharBufCount = 0;
    m_psWcharBuf = NULL;

    if (m_nCodePage && S_OK != m_pML->IsConvertible(m_nCodePage, UNICODE_CP))
    {
        m_nCodePage = 0;
    }

    if (m_nAmbientCodePage && S_OK != m_pML->IsConvertible(m_nAmbientCodePage, UNICODE_CP))
    {
        m_nAmbientCodePage = 0;
    }

    return S_OK;
}

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::IsUnicode
//
//  Synopsis:   Determines if our text buffer is Unicode or not.  Should
//              only be called once on the FIRST text buffer.
//
//              Assume if the data is marked as Unicode, that it's correct.
//
//              The determination this routine makes will override any
//              single byte codepage the user may have specified.
//
//              
//  Arguments:  pBytes            Buffer containing characters to be converted.
//              dwSize            Number of significant characters in 'pBytes'
//
//  Returns:    Code page of text, or zero if not Unicode (UNICODE_CP,
//              UNICODE_REVERSE_CP, or 0)
//              
//
//------------------------------------------------------------------------
int
CTDCUnify::IsUnicode(BYTE * pBytes, DWORD dwSize)
{
    if (BYTE_ORDER_MARK == *(WCHAR *)pBytes)
        return UNICODE_CP;

    if (REVERSE_BYTE_ORDER_MARK == *(WCHAR *)pBytes)
        return UNICODE_REVERSE_CP;

    else return 0;
}

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::ConvertByteBuffer()
//
//  Synopsis:   Converts a byte-buffer into a wide-character stream
//              (applying unicode conversions if necessary) and passes
//              it to the embedded TDCTokenise object to be broken into
//              fields.
//
//  Arguments:  pBytes            Buffer containing characters to be converted.
//              dwSize            Number of significant characters in 'pBytes'
//                                  dwSize == 0 means "End-of-stream"
//
//  Returns:    S_OK upon success.
//              S_FALSE if not enough data has shown up yet to be useful
//              OLE_E_CANTCONVERT if a non-unicode buffer can't be
//                converted into unicode.
//              E_OUTOFMEMORY if there isn't enough memory to perform
//                a data conversion.
//
//------------------------------------------------------------------------

HRESULT CTDCUnify::ConvertByteBuffer(BYTE *pBytes, DWORD dwSize)
{
    OutputDebugStringX(_T("CTDCUnify::ConvertByteBuffer called\n"));

    _ASSERT(pBytes != NULL || dwSize == 0);

    HRESULT     hr = S_OK;
    UINT        ucBytes;
    UINT        ucWchars;

    // Is there enough space in Byte buffer for this packet?
    if (dwSize > (m_ucByteBufSize - m_ucByteBufCount))
    {
        // No, the current buffer is too small, make a new one.
        BYTE * psTemp = new BYTE[m_ucByteBufCount + dwSize];
        if (psTemp==NULL)
        {
            hr = E_OUTOFMEMORY;
            
            goto Done;
        }

        if (m_psByteBuf != NULL)        // if not first time
        {
            memmove(psTemp, m_psByteBuf, m_ucByteBufCount);
            delete [] m_psByteBuf;
        }
        m_ucByteBufSize = m_ucByteBufCount + dwSize;
        m_psByteBuf = psTemp;
    }

    // Append the new data to the old data.
    memmove(m_psByteBuf + m_ucByteBufCount, pBytes, dwSize);
    m_ucByteBufCount += dwSize;

    // Is there enough space in the Wchar buffer for the converted data?
    // We make a very conservative assumption here that N source buffer bytes
    // convert to N Wchar buffer chars (or 2*N bytes).  This will ensure that
    // our call to ConvertToUnicode will never not finish because there wasn't
    // enough room in the output buffer.
    if (m_ucByteBufCount > (m_ucWcharBufSize - m_ucWcharBufCount))
    {
        // The current buffer is too small, make a new one.
        WCHAR * psTemp = new WCHAR[m_ucWcharBufCount + m_ucByteBufCount];
        if (psTemp==NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Done;
        }

        if (m_psWcharBuf != NULL)       // if not first time
        {
            memmove(psTemp, m_psWcharBuf,
                    m_ucWcharBufCount*sizeof(WCHAR));
            delete [] m_psWcharBuf;
        }
        m_psWcharBuf = psTemp;
        m_ucWcharBufSize = m_ucWcharBufCount + m_ucByteBufCount;
    }

    if (0 == m_dwBytesProcessed)
    {
        // if we can't determine the codepage yet, try again later
        if (!DetermineCodePage(dwSize==0))
        {
            hr = S_FALSE;
            goto Done;
        }
    }

    // Convert as many source bytes as we can to Unicode chars
    ucBytes = m_ucByteBufCount;
    ucWchars = m_ucWcharBufSize - m_ucWcharBufCount;

    // ConvertStringToUnicode won't convert Unicode to Unicode for us.
    // So we'll do it ourselves.
    if (m_nUnicode)
    {
        _ASSERT( ucWchars * sizeof(WCHAR) >= ucBytes);

        // This might copy an odd extra byte
        memmove((BYTE *)(m_psWcharBuf + m_ucWcharBufCount), m_psByteBuf,
                ucBytes);

        // But we only count the number of complete WCHAR's we copied.
        ucWchars = ucBytes / sizeof(WCHAR); 
        ucBytes = ucWchars * sizeof(WCHAR);

        if (UNICODE_REVERSE_CP == m_nUnicode)
        {
            // need to byte swap
            BYTE *pByteSwap = (BYTE *)(m_psWcharBuf + m_ucWcharBufCount);
            BYTE bTemp;
            for (ULONG i = ucWchars; i != 0; i--)
            {
                // Well, OK, we've kind of hardwired WCHAR == 2 here, but ..
                bTemp = pByteSwap[0];
                pByteSwap[0] = pByteSwap[1];
                pByteSwap[1] = bTemp;
                pByteSwap += 2;
            }
        }

        // On first packet, need to remove Unicode signature.
        // Only need to look for 0xFFFE -- we already swapped bytes.
        if (0 == m_dwBytesProcessed && m_psWcharBuf[0] == BYTE_ORDER_MARK)
        {
            ucWchars--;
            memmove((BYTE *)m_psWcharBuf, (BYTE *)m_psWcharBuf+2,
                   ucWchars*sizeof(ucWchars));
        }
    }
    else
    {
        hr = m_pML->ConvertStringToUnicode(&m_dwConvertMode, m_nCodePage,
                                           (char *)m_psByteBuf, &ucBytes,
                                           m_psWcharBuf +m_ucWcharBufCount,
                                           &ucWchars);

        // Some character(s) failed conversion.  The best we can do is
        // attempt to skip the character that failed conversion.
        if (FAILED(hr))
        {
            // Did we come back around and try to unconvertable portion again?
            if (ucBytes==0)
            {
                // Yes, and it made no progress.  Skip a char to try to make
                // forward progress.
                ucBytes++;
            }
            // We can't return this error, or we won't look a the rest of the
            // file.
            hr = S_OK;
        }

    }

    // Move any leftover source characters to the start of the buffer.
    // These are probably split Unicode chars, lead bytes without trail
    // bytes, etc.
    m_ucByteBufCount -= ucBytes;
    memmove(m_psByteBuf, m_psByteBuf + ucBytes,
            m_ucByteBufCount);

    // The number of useful chars in the output buf is increased by the
    // number we managed to convert.
    m_ucWcharBufCount += ucWchars;
    m_dwBytesProcessed += ucWchars;

Done:
    return hr;
}


//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::DetermineCodePage()
//
//  Synopsis:   Figures out what codepage to use to read the data.
//              Sets m_nCodePage and m_nUnicode appropriately.
//
//  Arguments:  fForce      determine the answer, no matter what
//
//  Returns:    TRUE        the codepage is determined.
//              FALSE       not enough data yet to determine
//
//------------------------------------------------------------------------

BOOL
CTDCUnify::DetermineCodePage(BOOL fForce)
{
    DWORD   dwConvertMode = 0;
    HRESULT hr;
    UINT    ucBytes = m_ucByteBufCount;
    UINT    ucWchars = m_ucWcharBufSize - m_ucWcharBufCount;
    UINT    cpDetected;
    IMultiLanguage2 *pML2 = NULL;

    _ASSERT(m_dwBytesProcessed == 0 && m_pML);

    // First look for Unicode.  Assume it's not Unicode to start.
    m_nUnicode = 0;

    // Need at least 2 chars for Unicode signature (0xFFFE or 0xFEFF)
    if (m_ucByteBufCount > 1)
    {
        // If we detect Unicode, it overrides any user specified code page.
        m_nUnicode = IsUnicode(m_psByteBuf, m_ucByteBufCount);
        if (m_nUnicode)
        {
            m_nCodePage = m_nUnicode;
            return TRUE;
        }

        // It's not Unicode.  If the user specified a code page, use it.
        if (m_nCodePage)
        {
            return TRUE;
        }
    }

    // if we need an answer and user specified a code page, use it
    if (fForce && m_nCodePage)
    {
        return TRUE;
    }

    // At this point, we have to guess.  If we have enough input or if we
    // need an answer now, use MLang to do the guessing
    if (fForce || m_ucByteBufCount >= CODEPAGE_BYTE_THRESHOLD)
    {
        // First see if the auto-detect interface is available.
        hr = m_pML->QueryInterface(IID_IMultiLanguage2, (void**)&pML2);
        if (!hr && pML2)
        {
            DetectEncodingInfo info[N_DETECTENCODINGINFO];
            int nInfo = N_DETECTENCODINGINFO;

            // auto-detect
            hr = pML2->DetectInputCodepage(
                            MLDETECTCP_NONE,
                            CP_ACP,
                            (char *)m_psByteBuf,
                            (int*)&ucBytes,
                            info,
                            &nInfo);
            pML2->Release();

            if (!hr)
            {
                // if one of the returned codepages is "good enough", use it.
                for (int i=0; i<nInfo; ++i)
                {
                    if (info[i].nConfidence >= 90 && info[i].nDocPercent >= 90)
                    {
                        if (S_OK == m_pML->IsConvertible(info[i].nCodePage, UNICODE_CP))
                        {
                            m_nCodePage = info[i].nCodePage;
                            return TRUE;
                        }
                    }
                }
            }
        }
        
        // Try plain old MLang.
        // Ask MLang to convert the input using the"auto-detect" codepage.
        hr = m_pML->ConvertStringToUnicode(&dwConvertMode, CP_AUTO,
                                           (char *)m_psByteBuf, &ucBytes,
                                           m_psWcharBuf + m_ucWcharBufCount,
                                           &ucWchars);
        cpDetected = HIWORD(dwConvertMode);

        // if MLang detected a codepage, use it
        if (!hr && cpDetected != 0)
        {
            if (S_OK == m_pML->IsConvertible(cpDetected, UNICODE_CP))
            {
                m_nCodePage = cpDetected;
                return TRUE;
            }
        }
    }

    // guessing didn't work.  If we don't have to decide now, try again later
    if (!fForce)
    {
        return FALSE;
    }

    // if we have to decide and all else has failed, use the host page's
    // encoding.  If even that isn't available, use the machine's ASCII codepage.
    m_nCodePage = m_nAmbientCodePage ? m_nAmbientCodePage : GetACP();

    // and if this still isn't convertible to Unicode, use windows-1252
    if (m_nCodePage == 0 || S_OK != m_pML->IsConvertible(m_nCodePage, UNICODE_CP))
    {
        m_nCodePage = CP_1252;
    }

    return TRUE;
}


LPWCH SkipSpace(LPWCH pwchCurr)
{
    while (IsSpace(*pwchCurr)) pwchCurr++;
    return pwchCurr;
}

static
boolean IsEnd(WCHAR ch)
{
    return (ch == 0 || ch == L'\r' || ch == L'\n');
}

static
boolean IsBreak(WCHAR ch)
{
    return (ch == L';' || IsEnd(ch));
}

// Returns FALSE if names didn't match.
// Returns TRUE if they did.
// Sets *ppwchAdvance to terminator of the match name
BOOL
MatchName(LPWCH pwchMatchName, LPCWCH pwzHostName, LPWCH *ppwchAdvance)
{
    // match from right to left
    LPWCH pwchMatchRight = &pwchMatchName[0];
    LPCWCH pwchHostRight = &pwzHostName[0] + ocslen(pwzHostName) -1;
                     
    // handle empty match name
    if (IsBreak(*pwchMatchRight))
    {
        if (!IsEnd(*pwchMatchRight))    // be sure to advance (unless at end)
            ++ pwchMatchRight;
        *ppwchAdvance = pwchMatchRight;
        return FALSE;
    }
    
    // Find end of Match name.
    while (!IsBreak(*pwchMatchRight)) pwchMatchRight++;

    *ppwchAdvance = pwchMatchRight;     // return pointer to terminator

    pwchMatchRight--;

    while (IsSpace(*pwchMatchRight) && pwchMatchRight >= pwchMatchName)
        -- pwchMatchRight;              // ignore trailing whitespace

    // match full wildcard the easy way
    if (pwchMatchRight == pwchMatchName && pwchMatchRight[0] == '*')
        return TRUE;
    
    // match right-to-left, stop at mismatch or beginning of either string
    for (; pwchMatchRight>=pwchMatchName && pwchHostRight>=pwzHostName;
            --pwchMatchRight, --pwchHostRight)
    {
        if (*pwchMatchRight != *pwchHostRight || *pwchMatchRight == '*')
            break;
    }

    // it's a match if strings matched completely
    if (pwchMatchRight+1 == pwchMatchName  &&  pwchHostRight+1 == pwzHostName)
        return TRUE;

    // or if match name started with "*." and the rest matched a suffix of host name
    if (pwchMatchRight == pwchMatchName  &&  pwchMatchRight[0] == '*'  &&
        pwchMatchRight[1] == '.')
        return TRUE;

    // otherwise it's not a match
    return FALSE;
}

HRESULT
CTDCUnify::MatchAllowDomainList(LPCWSTR pwzURL)
{
    HRESULT hr = E_FAIL;                // assume failure
    LPWCH pwchCurr = &m_psWcharBuf[0];
    LPWCH pwchCurr2;
    int cchHostDoman = ocslen(pwzURL);

    // skip over white space
    pwchCurr = SkipSpace(pwchCurr);
    if (IsEnd(*pwchCurr))
        goto Cleanup;

    // must have the equal sign
    if (*pwchCurr++ != '=' || *pwchCurr == '\0')
        goto Cleanup;

    while (TRUE)
    {
        // skip over white space
        pwchCurr = SkipSpace(pwchCurr);

        if (IsEnd(*pwchCurr))           // terminate on \r, \n, \0
            break;

        if (IsBreak(*pwchCurr))         // Must be ';',
            pwchCurr++;                 // skip it.

        // skip over white space
        pwchCurr = SkipSpace(pwchCurr);

        if (MatchName(pwchCurr, pwzURL, &pwchCurr2))
        {
            hr = S_OK;
            break;
        }
        pwchCurr = pwchCurr2;
    }

Cleanup:
    while (!IsEnd(*pwchCurr))
        pwchCurr++;

    // Skip CRLF combos
    if (*pwchCurr == '\r' && pwchCurr[1] == '\n') pwchCurr++;

    // Eat the AllowDomain line so it doesn't screw up the data.
    m_ucWcharBufCount -= (ULONG)(pwchCurr+1 - m_psWcharBuf);
    memmove(m_psWcharBuf, pwchCurr+1, m_ucWcharBufCount*sizeof(WCHAR));

    m_fProcessedAllowDomainList = TRUE;

    return hr;
}

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::CheckForAllowDomainList
//
//  Synopsis:   Checks the beggining of the Wide Char buffer to see if it
//              contains the string "@!allow.domains".  This is used to
//              determine if this file has a list of domain names which are
//              allowed to access this file, even though the access may be
//              coming from another internet host.
//
//  Arguments:  uses CTDCUnify state variables for the Wide Char buffer:
//              m_psWcharBUf            the Wide char buffer
//              m_ucWcharBufCount       the # of chars in the wide char buf
//
//  Returns:    ALLOW_DOMAINLIST_NO             signature not found
//              ALLOW_DOMAINLIST_YES            signature was found
//              ALLOW_DOMAINLIST_DONTKNOW       don't have enough characters
//                                              to know for sure yet.
//
//------------------------------------------------------------------------

CTDCUnify::ALLOWDOMAINLIST
CTDCUnify::CheckForAllowDomainList()
{
    ULONG cAllowDomainLen = ocslen(ALLOW_DOMAIN_STRING);

    // Make sure we have a whole line.
    LPWCH pwchCurr = m_psWcharBuf;
    if (!pwchCurr)
        return ALLOW_DOMAINLIST_DONTKNOW;

    while (!IsEnd(*pwchCurr)) pwchCurr++;
    if (*pwchCurr == '\0')              // if buffer ended before line did
        return ALLOW_DOMAINLIST_DONTKNOW;

    if (0 == wch_incmp(m_psWcharBuf, ALLOW_DOMAIN_STRING, cAllowDomainLen))
    {
        // We matched equal and have the whole string.
        // Take the "@!allow.domains" out of the buffer..
        m_ucWcharBufCount -= cAllowDomainLen;
        memmove(m_psWcharBuf, &m_psWcharBuf[cAllowDomainLen],
                m_ucWcharBufCount*sizeof(WCHAR));
        return ALLOW_DOMAINLIST_YES;
    }

    // We didn't match equal, no point in looking any more.
    return ALLOW_DOMAINLIST_NO;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\tdcparse.h ===
//------------------------------------------------------------------------
//
//  Tabular Data Control Parse Module
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCParse.h
//
//  Contents:   Declaration of the TDC parser classes.
//
//  The intent of these classes once was to create a pipeline.
//
//
//          |
//          |       Wide-character stream
//          |       ~~~~~~~~~~~~~~~~~~~~~
//         \|/
//  ------------------------
//  | CTDCTokenise object  | Created with field & row delimiters, quote &
//  |   AddWcharBuffer()   |     escape characters
//  ------------------------
//          |
//          |       Stream of <field>, <eoln> and <eof> tokens
//          |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//         \|/
//  ------------------------
//  | CTDCFieldSink object | Abstract class, e.g. STD object created with
//  |   AddField()         |     sort/filter criteria & fUseHeader flag
//  |   EOLN()             |     to interpret the sequence of fields.
//  |   EOF()              |
//  ------------------------
//
//------------------------------------------------------------------------

#define DEFAULT_FIELD_DELIM L","
#define DEFAULT_ROW_DELIM   L"\n"
#define DEFAULT_QUOTE_CHAR  L"\""

#define UNICODE_CP          1200        // Win32's Unicode codepage
#define UNICODE_REVERSE_CP  1201        // Byte-swapped Unicode codepage
#define CP_1252             1252        // Ansi, Western Europe
#define CP_AUTO             50001       // cross language detection

// number of bytes for MLang to make a good guess for the codepage
// (this is a somewhat arbitrary number)
#define CODEPAGE_BYTE_THRESHOLD     (4096)
#define N_DETECTENCODINGINFO        (5)

#define ALLOW_DOMAIN_STRING L"@!allow_domains"

//------------------------------------------------------------------------
//
//  Class:  CTDCFieldSink
//
//  This class accumulates a sequence of <fields> and <eoln> tokens
//  into a 2-D array.
//
//  An admissible calling sequence on this object is:
//   * 0 or more calls to AddField() or EOLN()
//   * 1 call to EOF()
//
//------------------------------------------------------------------------

class CTDCFieldSink
{
public:
    STDMETHOD(AddField)(LPWCH pwch, DWORD dwSize) PURE;
    STDMETHOD(EOLN)() PURE;
    STDMETHOD(EOF)() PURE;
};

//------------------------------------------------------------------------
//
//  Class: CTDCUnify
//
//  This class takes a series of byte buffers and breaks them up into
//  UNICODE buffers.
//  The resulting buffers are passed to a CTDCTokenise object.
//
//  An admissible calling sequence on this object is:
//   * Exactly 1 call to Create()
//   * 0 or more calls to AddByteBuffer() with a non-zero-sized buffer
//   * Exactly 1 call to AddByteBuffer() with a zero-sized buffer
//
//  Calls to query the characteristics of the parsed data are allowed
//  after the call to Create(), but are only meaningful after a
//  reasonable amount of data has been collected.
//  
//
//  Caveats:
//  ~~~~~~~
//  The class characterises the input stream as ASCII/UNICODE/COMPOSITE
//  based on the buffer passed in the initial call to AddByteBuffer().
//  If this buffer is too small, the class may make an incorrect
//  characterisation.
//
//------------------------------------------------------------------------

class CTDCUnify
{
public:
    CTDCUnify();
    ~CTDCUnify();
    HRESULT Create(UINT nCodePage, UINT nAmbientCodePage, IMultiLanguage *pML);
    HRESULT ConvertByteBuffer(BYTE *pBytes, DWORD dwSize);
    HRESULT InitTokenizer(CTDCFieldSink *pFieldSink,
                          WCHAR wchDelimField,
                          WCHAR wchDelimRow,
                          WCHAR wchQuote,
                          WCHAR wchEscape);    
    HRESULT AddWcharBuffer(BOOL fAtEnd);
    int IsUnicode(BYTE * pBytes, DWORD dwSize);
    BOOL DetermineCodePage(BOOL fForce);
    enum ALLOWDOMAINLIST
    {
        ALLOW_DOMAINLIST_YES,
        ALLOW_DOMAINLIST_NO,
        ALLOW_DOMAINLIST_DONTKNOW
    };

    ALLOWDOMAINLIST CheckForAllowDomainList();
    HRESULT MatchAllowDomainList(LPCWSTR pwzURL);
    boolean ProcessedAllowDomainList() {return m_fProcessedAllowDomainList;}

private:
    CTDCFieldSink *m_pFieldSink;
    WCHAR m_wchDelimField;
    WCHAR m_wchDelimRow;
    WCHAR m_wchQuote;
    WCHAR m_wchEscape;
    WCHAR m_ucParsed;

    boolean m_fEscapeActive;
    boolean m_fQuoteActive;
    boolean m_fIgnoreNextLF;
    boolean m_fIgnoreNextCR;
    boolean m_fIgnoreNextWhiteSpace;
    boolean m_fFoldCRLF;
    boolean m_fFoldWhiteSpace;

    UINT            m_nUnicode;
    boolean         m_fDataMarkedUnicode;
    boolean         m_fDataIsUnicode;
    boolean         m_fCanConvertToUnicode;
    boolean         m_fProcessedAllowDomainList;
    DWORD           m_dwBytesProcessed;
    DWORD           m_dwConvertMode;
    UINT            m_nCodePage;
    UINT            m_nAmbientCodePage;

    BYTE            *m_psByteBuf;
    ULONG           m_ucByteBufSize;
    ULONG           m_ucByteBufCount;

    WCHAR           *m_psWcharBuf;
    ULONG           m_ucWcharBufSize;
    ULONG           m_ucWcharBufCount;

    IMultiLanguage *m_pML;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\tdcctl.cpp ===
//------------------------------------------------------------------------
//
//  Tabular Data Control
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCCtl.cpp
//
//  Contents:   Implementation of the CTDCCtl ActiveX control.
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include <simpdata.h>
#include "TDCIds.h"
#include "TDC.h"
#include <MLang.h>
#include "Notify.h"
#include "TDCParse.h"
#include "TDCArr.h"
#include "TDCCtl.h"
#include "locale.h"

//------------------------------------------------------------------------
//
//  Function:   EmptyBSTR()
//
//  Synopsis:   Indicates whether the given BSTR object represents an
//              empty string.
//
//  Arguments:  bstr     String to test
//
//  Returns:    TRUE if 'bstr' represents an empty string
//              FALSE otherwise.
//
//------------------------------------------------------------------------

inline boolean EmptyBSTR(BSTR bstr)
{
    return bstr == NULL || bstr[0] == 0;
}

void
ClearInterfaceFn(IUnknown ** ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}

// For some reason the standard definition of VARIANT_TRUE (0xffff) generates
// truncation warnings when assigned to a VARIANT_BOOL
#define TDCVARIANT_TRUE -1

//------------------------------------------------------------------------
//
//  Method:     CTDCCtl()
//
//  Synopsis:   Class constructor
//
//  Arguments:  None
//
//------------------------------------------------------------------------

CTDCCtl::CTDCCtl()
{
    m_cbstrFieldDelim = DEFAULT_FIELD_DELIM;
    m_cbstrRowDelim = DEFAULT_ROW_DELIM;
    m_cbstrQuoteChar = DEFAULT_QUOTE_CHAR;
    m_fUseHeader = FALSE;
    m_fSortAscending = TRUE;
    m_fAppendData = FALSE;
    m_pSTD = NULL;
    m_pArr = NULL;
    m_pUnify = NULL;
    m_pEventBroker = new CEventBroker(this);
    m_pDataSourceListener = NULL;
// ;begin_internal
    m_pDATASRCListener = NULL;
// ;end_internal
    m_pBSC = NULL;
    m_enumFilterCriterion = (OSPCOMP) 0;
    m_fDataURLChanged = FALSE;
    m_lTimer = 0;
    m_fCaseSensitive = TRUE;
    m_hrDownloadStatus = S_OK;
    m_fInReset = FALSE;

    //  Create an MLANG object
    //
    m_nCodePage = 0;                    // use default from host
    {
        HRESULT hr;

        m_pML = NULL;
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,
                              CLSCTX_INPROC_SERVER, IID_IMultiLanguage,
                              (void**) &m_pML);
        // Don't set the default Charset here.  Leave m_nCodepage set
        // to 0 to indicate default charset.  Later we'll try to query
        // our host's default charset, and failing that we'll use CP_ACP.
        _ASSERTE(SUCCEEDED(hr) && m_pML != NULL);
    }

    m_lcidRead = 0x0000;                // use default from host
}


//------------------------------------------------------------------------
//
//  Method:     ~CTDCCtl()
//
//  Synopsis:   Class destructor
//
//------------------------------------------------------------------------

CTDCCtl::~CTDCCtl()
{
    ULONG cRef = _ThreadModel::Decrement(&m_dwRef);

    ClearInterface(&m_pSTD);

    if (cRef ==0)
    {
        TimerOff();
        ReleaseTDCArr(FALSE);

        if (m_pEventBroker)
        {
            m_pEventBroker->Release();
            m_pEventBroker = NULL;
        }
        ClearInterface(&m_pDataSourceListener);
// ;begin_internal
        ClearInterface(&m_pDATASRCListener);
// ;end_internal
        ClearInterface(&m_pML);
    }
}

//------------------------------------------------------------------------
//
//  These set/get methods implement the control's properties,
//  copying values to and from class members.  They perform no
//  other processing apart from argument validation.
//
//------------------------------------------------------------------------

STDMETHODIMP CTDCCtl::get_ReadyState(LONG *plReadyState)
{
    HRESULT hr;

    if (m_pEventBroker == NULL)
    {
        // We must provide a ReadyState whether we want to or not, or our
        // host can never go COMPLETE.
        *plReadyState = READYSTATE_COMPLETE;
        hr = S_OK;
    }
    else
        hr = m_pEventBroker->GetReadyState(plReadyState);
    return hr;
}

STDMETHODIMP CTDCCtl::put_ReadyState(LONG lReadyState)
{
    // We don't allow setting of Ready State, but take advantage of a little
    // kludge here to update our container's impression of our readystate
    FireOnChanged(DISPID_READYSTATE);
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_FieldDelim(BSTR* pbstrFieldDelim)
{
    *pbstrFieldDelim = m_cbstrFieldDelim.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_FieldDelim(BSTR bstrFieldDelim)
{
    HRESULT hr = S_OK;

    if (bstrFieldDelim == NULL || bstrFieldDelim[0] == 0)
    {
        m_cbstrFieldDelim = DEFAULT_FIELD_DELIM;
        if (m_cbstrFieldDelim == NULL)
            hr = E_OUTOFMEMORY;
    }
    else
        m_cbstrFieldDelim = bstrFieldDelim;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_RowDelim(BSTR* pbstrRowDelim)
{
    *pbstrRowDelim = m_cbstrRowDelim.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_RowDelim(BSTR bstrRowDelim)
{
    HRESULT hr = S_OK;

    if (bstrRowDelim == NULL || bstrRowDelim[0] == 0)
    {
        m_cbstrRowDelim = DEFAULT_ROW_DELIM;
        if (m_cbstrRowDelim == NULL)
            hr = E_OUTOFMEMORY;
    }
    else
        m_cbstrRowDelim = bstrRowDelim;
    return hr;
}

STDMETHODIMP CTDCCtl::get_TextQualifier(BSTR* pbstrTextQualifier)
{
    *pbstrTextQualifier = m_cbstrQuoteChar.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_TextQualifier(BSTR bstrTextQualifier)
{
    m_cbstrQuoteChar = bstrTextQualifier;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_EscapeChar(BSTR* pbstrEscapeChar)
{
    *pbstrEscapeChar = m_cbstrEscapeChar.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_EscapeChar(BSTR bstrEscapeChar)
{
    m_cbstrEscapeChar = bstrEscapeChar;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_UseHeader(VARIANT_BOOL* pfUseHeader)
{
    *pfUseHeader = (VARIANT_BOOL)m_fUseHeader;
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_UseHeader(VARIANT_BOOL fUseHeader)
{
    m_fUseHeader = fUseHeader;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_SortColumn(BSTR* pbstrSortColumn)
{
    *pbstrSortColumn = m_cbstrSortColumn.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_SortColumn(BSTR bstrSortColumn)
{
    m_cbstrSortColumn = bstrSortColumn;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_SortAscending(VARIANT_BOOL* pfSortAscending)
{
    *pfSortAscending = m_fSortAscending ? TDCVARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_SortAscending(VARIANT_BOOL fSortAscending)
{
    m_fSortAscending = fSortAscending ? TRUE : FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_FilterValue(BSTR* pbstrFilterValue)
{
    *pbstrFilterValue = m_cbstrFilterValue.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_FilterValue(BSTR bstrFilterValue)
{
    m_cbstrFilterValue = bstrFilterValue;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_FilterCriterion(BSTR* pbstrFilterCriterion)
{
    HRESULT hr;
    WCHAR   *pwchCriterion;

    switch (m_enumFilterCriterion)
    {
    case OSPCOMP_EQ:    pwchCriterion = L"=";   break;
    case OSPCOMP_LT:    pwchCriterion = L"<";   break;
    case OSPCOMP_LE:    pwchCriterion = L"<=";  break;
    case OSPCOMP_GE:    pwchCriterion = L">=";  break;
    case OSPCOMP_GT:    pwchCriterion = L">";   break;
    case OSPCOMP_NE:    pwchCriterion = L"<>";  break;
    default:            pwchCriterion = L"??";  break;
    }
    *pbstrFilterCriterion = SysAllocString(pwchCriterion);
    hr = (*pbstrFilterCriterion == NULL) ? E_OUTOFMEMORY : S_OK;

    return hr;
}

STDMETHODIMP CTDCCtl::put_FilterCriterion(BSTR bstrFilterCriterion)
{
    m_enumFilterCriterion = (OSPCOMP) 0;
    if (bstrFilterCriterion != NULL)
    {
        switch (bstrFilterCriterion[0])
        {
        case L'<':
            if (bstrFilterCriterion[1] == 0)
                m_enumFilterCriterion = OSPCOMP_LT;
            else if (bstrFilterCriterion[2] == 0)
            {
                if (bstrFilterCriterion[1] == L'>')
                    m_enumFilterCriterion = OSPCOMP_NE;
                else if (bstrFilterCriterion[1] == L'=')
                    m_enumFilterCriterion = OSPCOMP_LE;
            }
            break;
        case L'>':
            if (bstrFilterCriterion[1] == 0)
                m_enumFilterCriterion = OSPCOMP_GT;
            else if (bstrFilterCriterion[1] == L'=' && bstrFilterCriterion[2] == 0)
                m_enumFilterCriterion = OSPCOMP_GE;
            break;
        case L'=':
            if (bstrFilterCriterion[1] == 0)
                m_enumFilterCriterion = OSPCOMP_EQ;
            break;
        }
    }

    //  Return SUCCESS, even on an invalid value; otherwise the
    //  frameworks using the control will panic and abandon all hope.
    //
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_FilterColumn(BSTR* pbstrFilterColumn)
{
    *pbstrFilterColumn = m_cbstrFilterColumn.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_FilterColumn(BSTR bstrFilterColumn)
{
    m_cbstrFilterColumn = bstrFilterColumn;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_CharSet(BSTR* pbstrCharSet)
{
    HRESULT hr = E_FAIL;

    *pbstrCharSet = NULL;

    if (m_pML != NULL)
    {
        MIMECPINFO  info;

        hr = m_pML->GetCodePageInfo(m_nCodePage, &info);
        if (SUCCEEDED(hr))
        {
            *pbstrCharSet = SysAllocString(info.wszWebCharset);
            if (*pbstrCharSet == NULL)
                hr = E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_CharSet(BSTR bstrCharSet)
{
    HRESULT hr = E_FAIL;

    if (m_pML != NULL)
    {
        MIMECSETINFO    info;

        hr = m_pML->GetCharsetInfo(bstrCharSet, &info);
        if (SUCCEEDED(hr))
        {
            m_nCodePage = info.uiInternetEncoding;
        }
    }
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_Language(BSTR* pbstrLanguage)
{
    if (m_pArr)
    {
        return m_pArr->getLocale(pbstrLanguage);
    }

    *pbstrLanguage = m_cbstrLanguage.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_Language_(LPWCH pwchLanguage)
{
    HRESULT hr  = S_OK;
    LCID    lcid;

    hr = m_pML->GetLcidFromRfc1766(&lcid, pwchLanguage);
    if (SUCCEEDED(hr))
    {
        m_cbstrLanguage = pwchLanguage;
        m_lcidRead = lcid;
    }
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_Language(BSTR bstrLanguage)
{
    return put_Language_(bstrLanguage);
}

STDMETHODIMP CTDCCtl::get_DataURL(BSTR* pbstrDataURL)
{
    *pbstrDataURL = m_cbstrDataURL.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_DataURL(BSTR bstrDataURL)
{
    HRESULT hr = S_OK;

    m_cbstrDataURL = bstrDataURL;
    m_fDataURLChanged = TRUE;
    return hr;
}

// ;begin_internal
#ifdef NEVER
STDMETHODIMP CTDCCtl::get_RefreshInterval(LONG* plTimer)
{
    *plTimer = m_lTimer;
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_RefreshInterval(LONG lTimer)
{
    m_lTimer = lTimer;
    if (m_lTimer > 0)
        TimerOn(m_lTimer * 1000);
    else
        TimerOff();
    return S_OK;
}
#endif
// ;end_internal

STDMETHODIMP CTDCCtl::get_Filter(BSTR* pbstrFilterExpr)
{
    *pbstrFilterExpr = m_cbstrFilterExpr.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_Filter(BSTR bstrFilterExpr)
{
    m_cbstrFilterExpr = bstrFilterExpr;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_Sort(BSTR* pbstrSortExpr)
{
    *pbstrSortExpr = m_cbstrSortExpr.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_Sort(BSTR bstrSortExpr)
{
    m_cbstrSortExpr = bstrSortExpr;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_AppendData(VARIANT_BOOL* pfAppendData)
{
    *pfAppendData = m_fAppendData ? TDCVARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_AppendData(VARIANT_BOOL fAppendData)
{
    m_fAppendData = fAppendData ? TRUE : FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_CaseSensitive(VARIANT_BOOL* pfCaseSensitive)
{
    *pfCaseSensitive = m_fCaseSensitive ? TDCVARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_CaseSensitive(VARIANT_BOOL fCaseSensitive)
{
    m_fCaseSensitive = fCaseSensitive ? TRUE : FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_OSP(OLEDBSimpleProviderX ** ppISTD)
{
    // Return an OSP if we have one, but don't create one on demand!
    // (Otherwise property bag load stuff will cause us to create an
    // OSP prematurely).
    *ppISTD = NULL;
    if (m_pSTD)
    {
        *ppISTD = (OLEDBSimpleProviderX *)m_pSTD;
    }
    return S_OK;
}


//------------------------------------------------------------------------
//
//  Method:    UpdateReadyState
//
//  Synopsis:  Vectors to the event brokers ReadyState, if there is one.
// ;begin_internal
//             Note, we have to be able to set our readystate and fire change
//             events on it, whether or not creation of the broker succeeded,
//             or we prevent our host container from reaching
//             READYSTATE_COMPLETE, which is not acceptable.  We therefore
//             have to duplicate some of the broker's work here.  This makes
//             me wonder whether the broker architecture was a good idea.
// ;end_internal
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             Error codes as per Reset() upon error.
//
//------------------------------------------------------------------------
void
CTDCCtl::UpdateReadyState(LONG lReadyState)
{
    if (m_pEventBroker)
        m_pEventBroker->UpdateReadyState(lReadyState);
    else
    {
        // We have no broker, but our host is still waiting for us to
        // go READYSTATE_COMPLETE.  We fire the OnChange here noting that
        // get_ReadyState with no broker will return COMPLETE.
        FireOnChanged(DISPID_READYSTATE);
        FireOnReadyStateChanged();
    }
}

//------------------------------------------------------------------------
//
//  Method:    _OnTimer()
//
//  Synopsis:  Handles an internal timer event by refreshing the control.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             Error codes as per Reset() upon error.
//
//------------------------------------------------------------------------

STDMETHODIMP CTDCCtl::_OnTimer()
{
    HRESULT hr = S_OK;

    if (m_pArr != NULL && m_pArr->GetLoadState() == CTDCArr::LS_LOADED)
    {
        m_fDataURLChanged = TRUE;
        hr = Reset();
    }

    return hr;
}


//------------------------------------------------------------------------
//
//  Method:    msDataSourceObject()
//
//  Synopsis:  Yields an ISimpleTabularData interface for this control.
//             If this is the first call, a load operation is initiated
//             reading data from the control's specified DataURL property.
//             An STD object is created to point to the control's embedded
//             TDCArr object.
//
//  Arguments: qualifier     Ignored - must be an empty BSTR.
//             ppUnk         Pointer to returned interface  [OUT]
//
//  Returns:   S_OK upon success.
//             E_INVALIDARG if 'qualifier' isn't an empty BSTR.
//             E_OUTOFMEMORY if non enough memory could be allocated to
//               complete the construction of the interface.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCCtl::msDataSourceObject(BSTR qualifier, IUnknown **ppUnk)
{
    HRESULT hr  = S_OK;

    *ppUnk = NULL;                      // NULL in case of failure

    if (!EmptyBSTR(qualifier))
    {
        hr = E_INVALIDARG;
        goto error;
    }

    // Was there a previous attempt to load this page that failed?
    // (Probably due to security or file not found or something).
    if (m_hrDownloadStatus)
    {
        hr = m_hrDownloadStatus;
        goto error;
    }

    if (m_pArr == NULL)
    {
        // We don't have a valid TDC to give back, probably have to try
        // downloading one.
        UpdateReadyState(READYSTATE_LOADED);
        hr = CreateTDCArr(FALSE);
        if (hr)
            goto error;
    }

    _ASSERTE(m_pArr != NULL);

    if (m_pSTD == NULL)
    {
        OutputDebugStringX(_T("Creating an STD COM object\n"));

        // fetch ISimpleTabularData interface pointer
        m_pArr->QueryInterface(IID_OLEDBSimpleProvider, (void**)&m_pSTD);
        _ASSERTE(m_pSTD != NULL);
    }

    // Return the STD if we have one, otherwise it stays NULL
    if (m_pSTD && m_pArr->GetLoadState() >= CTDCArr::LS_LOADING_HEADER_AVAILABLE)
    {
        *ppUnk = (OLEDBSimpleProviderX *) m_pSTD;
        m_pSTD->AddRef();           // We must AddRef the STD we return!
    }

cleanup:
    return hr;

error:
    UpdateReadyState(READYSTATE_COMPLETE);
    goto cleanup;
}

// Override IPersistPropertyBagImpl::Load
STDMETHODIMP
CTDCCtl::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    HRESULT hr;
    IUnknown *pSTD;

    // Find out our Ambient Charset.  We need to know this surprisingly
    // early in life.
    VARIANT varCodepage;
    // 0 means user didn't set one, so ask our container.
    VariantInit(&varCodepage);
    GetAmbientProperty(DISPID_AMBIENT_CODEPAGE, varCodepage);

    // Ultimate default is Latin-1
    m_nAmbientCodePage = (varCodepage.vt == VT_UI4)
                         ? (ULONG)varCodepage.lVal
                         : CP_1252;

    // ignore Unicode ambient codepage - we want to allow non-Unicode
    // data files from Unicode pages.  If the data file is Unicode,
    // we'll find out anyway when we see the Unicode signature.
    if (m_nAmbientCodePage == UNICODE_CP ||
        m_nAmbientCodePage == UNICODE_REVERSE_CP)
    {
        m_nAmbientCodePage = CP_1252;
    }

    // Do normal load
    // IPersistPropertyBagImpl<CTDCCtl>
    hr = IPersistPropertyBagImpl<CTDCCtl>::Load(pPropBag, pErrorLog);

    // and then start download, if we can
    (void)msDataSourceObject(NULL, &pSTD);

    // If we actually got an STD, we should release it.  This won't really
    // make it go away, since we still have the ref from the QI.  This is
    // a bit of a kludge that we should clean up later.
    ClearInterface(&pSTD);

    return hr;
}


//------------------------------------------------------------------------
//
//  Method:    CreateTDCArr()
//
//  Synopsis:  Creates the control's embedded TDCArr object.
//             Initiates a data download from the DataURL property.
//
//  Arguments: fAppend         Flag indicating whether data should be
//                             appended to an existing TDC object.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if non enough memory could be allocated to
//               complete the construction of the TDCArr object.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCCtl::CreateTDCArr(boolean fAppend)
{
    HRESULT hr  = S_OK;

    if (m_pEventBroker == NULL)
    {
        hr = E_FAIL;
        goto Error;
    }

    // Iff we're appending is m_pArr allowed to be non-null here.
    _ASSERT ((m_pArr != NULL) == !!fAppend);

    if (m_pArr == NULL)
    {
        m_pArr = new CTDCArr();
        if (m_pArr == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        hr = m_pArr->Init(m_pEventBroker, m_pML);
        if (FAILED(hr))
            goto Error;
    }

    hr = InitiateDataLoad(fAppend);
    if (hr)
        goto Error;

    // We decide something is not async if it finished loading during
    // the InitiateDataLoad call.
    m_pArr->SetIsAsync(!(m_pArr->GetLoadState()==CTDCArr::LS_LOADED));

Cleanup:
    return hr;

Error:
    if (!fAppend)
    {
        ClearInterface(&m_pArr);
    }
    goto Cleanup;
}

//------------------------------------------------------------------------
//
//  Method:    ReleaseTDCArr()
//
//  Synopsis:  Releases the control's embedded TDCArr object.
//             Releases the control's CTDCUnify and CTDCTokenise objects.
//             Releases the old event broker and re-creates it if replacing.
//
//  Arguments: fReplacingTDCArr   Flag indicating whether a new TDCArr object
//                                will be created.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//             E_OUTOFMEMORY if non enough memory could be allocated to
//               complete the construction of the new CEventBroker object.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCCtl::ReleaseTDCArr(boolean fReplacingTDCArr)
{
    HRESULT hr = S_OK;

    TerminateDataLoad(m_pBSC);

    //  Release the reference to the current TDCArr object
    //
    if (m_pArr != NULL)
    {
        m_pArr->Release();
        m_pArr = NULL;

        // Since we've shut down the CTDCArr object, we should release
        // it's OLEDBSimplerProviderListener sink.
        if (m_pEventBroker)
        {
            m_pEventBroker->SetSTDEvents(NULL);
        }

        if (fReplacingTDCArr)
        {
            // Release our previous Event Broker.
            if (m_pEventBroker)
            {
                m_pEventBroker->Release();
                m_pEventBroker = NULL;
            }

            //  Create a new event broker.
            m_pEventBroker = new CEventBroker(this);
            if (m_pEventBroker == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            // Set the DataSourceListener for the new event broker.
            m_pEventBroker->SetDataSourceListener(m_pDataSourceListener);

// ;begin_internal
            m_pEventBroker->SetDATASRCListener(m_pDATASRCListener);
// ;end_internal
        }
    }

Cleanup:
    return hr;
}

const IID IID_IDATASRCListener = {0x3050f380,0x98b5,0x11cf,{0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};
const IID IID_DataSourceListener = {0x7c0ffab2,0xcd84,0x11d0,{0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed}};

//------------------------------------------------------------------------
//
//  Method:    addDataSourceListener()
//
//  Synopsis:  Sets the COM object which should receive notification
//             events.
//
//  Arguments: pEvent        Pointer to COM object to receive notification
//                           events, or NULL if no notifications to be sent.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCCtl::addDataSourceListener(IUnknown *pListener)
{

    if (m_pEventBroker != NULL)
    {
        HRESULT hr = S_OK;
        IUnknown * pDatasrcListener;

        // Make sure this is the interface we expect
        hr = pListener->QueryInterface(IID_DataSourceListener,
                                       (void **)&pDatasrcListener);
        if (SUCCEEDED(hr))
        {
            m_pEventBroker->
                    SetDataSourceListener((DataSourceListener *)pDatasrcListener);

            // Clear any previous
            ClearInterface (&m_pDataSourceListener);
            // and remember the new.
            m_pDataSourceListener = (DataSourceListener *)pDatasrcListener;
        }
// ;begin_internal
        else
        {
            // The definition of this interface was changed from IDATASRCListener to
            // DataSourceListener.  To make sure we don't cause crashes, we QI to
            // determine which one we were handed.
            hr = pListener->QueryInterface(IID_IDATASRCListener,
                                           (void **)&pDatasrcListener);
            if (SUCCEEDED(hr))
            {
                m_pEventBroker->
                        SetDATASRCListener((DATASRCListener *) pDatasrcListener);

                // Clear any previous
                ClearInterface (&m_pDATASRCListener);
                // and remember the new.
                m_pDATASRCListener = (DATASRCListener *)pDatasrcListener;
            }
        }
// ;end_internal
        return hr;
    }
    else
        return E_FAIL;
}

//------------------------------------------------------------------------
//
//  Method:    Reset()
//
//  Synopsis:  Reset the control's filter/sort criteria.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP CTDCCtl::Reset()
{
    HRESULT hr  = S_OK;

    // The next query to msDataSourceObject should get a new STD
    ClearInterface(&m_pSTD);

    // Infinite recursive calls to Reset can occur if script code calls reset
    // from within the datasetchanged event.  This isn't a good idea.
    if (m_fInReset)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    m_fInReset = TRUE;

    // Clear any previous error
    m_hrDownloadStatus = S_OK;

    if (m_fDataURLChanged)
    {
        if (!m_fAppendData)
        {
            // Release previous TDC array with "replacing" flag.
            hr = ReleaseTDCArr(TRUE);
            if (!SUCCEEDED(hr))         // possible memory failure
                goto Cleanup;
        }

        // Read the new data into a TDC arry, appending if specified.
        hr = CreateTDCArr((BOOL)m_fAppendData);
    }
    else if (m_pArr != NULL)
    {
        // Re-apply the sort and filter criteria
        hr = m_pArr->SetSortFilterCriteria(bstrConstructSortExpr(),
                                           bstrConstructFilterExpr(),
                                           m_fCaseSensitive ? 1 : 0);
    }

    m_fInReset = FALSE;

Cleanup:
    return hr;
}


//------------------------------------------------------------------------
//
//  Method:    bstrConstructSortExpr()
//
//  Synopsis:  Constructs a sort expression from the Sort property or
//             (for backward compatibility) from the SortColumn/SortAscending
//             properties.
//
//             This method only exists to isolate backward-compatibility
//             with the old-fashioned sort properties.
//
//  Arguments: None.
//
//  Returns:   The constructed sort expression.
//
//  NB!  It is the caller's responsibility to free the string returned.
//
//------------------------------------------------------------------------

BSTR
CTDCCtl::bstrConstructSortExpr()
{
    BSTR    bstr = NULL;

    if (!EmptyBSTR(m_cbstrSortExpr))
        bstr = SysAllocString(m_cbstrSortExpr);
    else if (!EmptyBSTR(m_cbstrSortColumn))
    {
        //  Use the old-fashioned sort properties
        //  Construct a sort expression of the form:
        //     <SortColumn>  or
        //    -<SortColumn>
        //
        if (m_fSortAscending)
            bstr = SysAllocString(m_cbstrSortColumn);
        else
        {
            bstr = SysAllocStringLen(NULL, SysStringLen(m_cbstrSortColumn) + 1);
            if (bstr != NULL)
            {
                bstr[0] = L'-';
                wch_cpy(&bstr[1], m_cbstrSortColumn);
            }
        }
    }

    return bstr;
}

//------------------------------------------------------------------------
//
//  Method:    bstrConstructFilterExpr()
//
//  Synopsis:  Constructs a filter expression from the Filter property or
//             (for backward compatibility) from the FilterColumn/FilterValue/
//             FilterCriterion properties.
//
//             This method only exists to isolate backward-compatibility
//             with the old-fashioned filter properties.
//
//  Arguments: None.
//
//  Returns:   The constructed filter expression
//
//  NB!  It is the caller's responsibility to free the string returned.
//
//------------------------------------------------------------------------

BSTR
CTDCCtl::bstrConstructFilterExpr()
{
    BSTR    bstr = NULL;

    if (!EmptyBSTR(m_cbstrFilterExpr))
        bstr = SysAllocString(m_cbstrFilterExpr);
    else if (!EmptyBSTR(m_cbstrFilterColumn))
    {
        //  Use the old-fashioned filter properties
        //  Construct a sort expression of the form:
        //     <FilterColumn> <FilterCriterion> "<FilterValue>"
        //
        BSTR bstrFilterOp;
        HRESULT hr;

        hr = get_FilterCriterion(&bstrFilterOp);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        bstr = SysAllocStringLen(NULL,
                    SysStringLen(m_cbstrFilterColumn) +
                    SysStringLen(bstrFilterOp) +
                    1 +
                    SysStringLen(m_cbstrFilterValue) +
                    1);
        if (bstr != NULL)
        {
            DWORD pos = 0;

            wch_cpy(&bstr[pos], m_cbstrFilterColumn);
            pos = wch_len(bstr);
            wch_cpy(&bstr[pos], bstrFilterOp);
            pos = wch_len(bstr);
            bstr[pos++] = L'"';
            wch_cpy(&bstr[pos], m_cbstrFilterValue);
            pos = wch_len(bstr);
            bstr[pos++] = L'"';
            bstr[pos] = 0;
        }
        SysFreeString(bstrFilterOp);
    }
Cleanup:
    return bstr;
}

//------------------------------------------------------------------------
//
//  Method:    TerminateDataLoad()
//
//  Synopsis:  Stop the current data load operation.
//
//  Returns:   S_OK upon success.
//
//------------------------------------------------------------------------

STDMETHODIMP CTDCCtl::TerminateDataLoad(CMyBindStatusCallback<CTDCCtl> *pBSC)
{
    HRESULT hr  = S_OK;

    // if the termination isn't for the current download, ignore it (bug 104042)
    if (pBSC != m_pBSC)
        goto done;

    // Make sure if we call Reset() right away now, we don't re-download
    // the data.
    m_fDataURLChanged = FALSE;

    m_pBSC = NULL;      //  Block any outstanding OnData calls

    if (m_pEventBroker)
        m_pEventBroker->m_pBSC = NULL;  // kill all

    if (m_pUnify != NULL)
        delete m_pUnify;

    m_pUnify = NULL;

done:
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    InitiateDataLoad()
//
//  Synopsis:  Start loading data from the control's DataURL property.
//
//  Arguments: fAppend        Flag to indicate whether data should be
//                            appended to an existing TDCArr object.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if not enough memory could be allocated to
//               complete the download.
//
//------------------------------------------------------------------------

STDMETHODIMP CTDCCtl::InitiateDataLoad(boolean fAppend)
{
    HRESULT hr  = S_OK;

    WCHAR   wchFieldDelim = (!m_cbstrFieldDelim) ? 0 : m_cbstrFieldDelim[0];
    WCHAR   wchRowDelim   = (!m_cbstrRowDelim)   ? 0 : m_cbstrRowDelim[0];
    // Default quote char to double-quote, not NULL
    WCHAR   wchQuoteChar  = (!m_cbstrQuoteChar)  ? 0 : m_cbstrQuoteChar[0];
    WCHAR   wchEscapeChar = (!m_cbstrEscapeChar) ? 0 : m_cbstrEscapeChar[0];

    //
    // Default LCID
    //
    if (0==m_lcidRead)
    {
        hr = GetAmbientLocaleID(m_lcidRead);
        if (FAILED(hr))
        {
            // Ultimate default is US locale -- sort of Web global
            // language default.
            put_Language_(L"en-us");
        }
    }

    if (EmptyBSTR(m_cbstrDataURL))
    {
        hr = S_FALSE;                   // quiet failure
        goto Error;
    }

    OutputDebugStringX(_T("Initiating Data Download\n"));

    //  No data load should currently be in progress -
    //  This data load has been initiated on the construction of a new
    //  TDCArr object, or appending to an existing loaded TDCArr object.
    //  Any currently running data load would have been
    //  terminated by the call to ReleaseTDCArr().
    //

    _ASSERT(m_pUnify == NULL);
    _ASSERT(m_pBSC == NULL);


    m_hrDownloadStatus = S_OK;

    //  Create a pipeline of objects to process the URL data
    //
    //    CMyBindStatusCallback -> CTDCUnify -> CTDCTokenise -> CTDCArr
    //

    CComObject<CMyBindStatusCallback<CTDCCtl> >::CreateInstance(&m_pBSC);

    if (m_pBSC == NULL)
    {
        hr = E_FAIL;
        goto Error;
    }
    hr = m_pArr->StartDataLoad(m_fUseHeader ? TRUE : FALSE,
                               bstrConstructSortExpr(),
                               bstrConstructFilterExpr(),
                               m_lcidRead,
                               m_pBSC,
                               fAppend,
                               m_fCaseSensitive ? 1 : 0);
    if (!SUCCEEDED(hr))
        goto Error;

    m_pUnify = new CTDCUnify();
    if (m_pUnify == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    m_pUnify->Create(m_nCodePage, m_nAmbientCodePage, m_pML);

    // Init tokenizer
    m_pUnify->InitTokenizer(m_pArr, wchFieldDelim, wchRowDelim,
                            wchQuoteChar, wchEscapeChar);



    m_fSecurityChecked = FALSE;

    // Start (and maybe perform) actual download.
    // If we're within a Reset() call, always force a "reload" of the data
    // from the server -- i.e. turn on BINDF_GETNEWESTVERSION to make sure
    // sure the cache data isn't stale.
    hr = m_pBSC->StartAsyncDownload(this, OnData, m_cbstrDataURL, m_spClientSite, TRUE,
                                    m_fInReset == TRUE);
    if (FAILED(hr))
        goto Error;

    // m_hrDownloadStatus remembers the first (if any) error that occured during
    // the OnData callbacks.  Unlike an error returning from StartAsyncDownload,
    // this doesn't necessarily cause us to throw away the TDC array.
    hr = m_hrDownloadStatus;
    if (!SUCCEEDED(hr))
        m_pBSC = NULL;

Cleanup:
    return hr;

Error:
    TerminateDataLoad(m_pBSC);
    if (m_pEventBroker)
    {
        // Fire data set changed to indicate query failed,
        m_pEventBroker->STDDataSetChanged();
        // and go complete.
        UpdateReadyState(READYSTATE_COMPLETE);
    }
    goto Cleanup;
}

//------------------------------------------------------------------------
//
//  Method:    SecurityCheckDataURL(pszURL)
//
//  Synopsis:  Check that the data URL is within the same security zone
//             as the document that loaded the control.
//
//  Arguments: URL to check
//
//  Returns:   S_OK upon success.
//             E_INVALID if the security check failed or we failed to get
//               an interface that we needed
//
//------------------------------------------------------------------------


// ;begin_internal
// Wendy Richards(v-wendri) 6/6/97
// Copied this here because I couldn't link without it. The version
// of URLMON.LIB I have does not have this symbol exported
// ;end_internal

EXTERN_C const IID IID_IInternetHostSecurityManager;

#define MAX_SEC_ID 256

STDMETHODIMP CTDCCtl::SecurityCheckDataURL(LPOLESTR pszURL)
{
    CComQIPtr<IServiceProvider, &IID_IServiceProvider> pSP(m_spClientSite);
    CComPtr<IInternetSecurityManager> pSM;
    CComPtr<IInternetHostSecurityManager> pHSM;
    CComPtr<IMoniker> pMoniker;

    BYTE     bSecIDHost[MAX_SEC_ID], bSecIDURL[MAX_SEC_ID];
    DWORD    cbSecIDHost = MAX_SEC_ID, cbSecIDURL = MAX_SEC_ID;
    HRESULT  hr = E_FAIL;

    USES_CONVERSION;

    // If we're running under the timer, it's quite possible our ClientSite will
    // disappear out from under us.  We'll obviously fail the security check,
    // but things are shutting down anyway..
    if (pSP==NULL)
        goto Cleanup;

    hr = CoInternetCreateSecurityManager(pSP, &pSM, 0L);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pSP->QueryService(IID_IInternetHostSecurityManager,
                           IID_IInternetHostSecurityManager,
                           (LPVOID *)&pHSM);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pHSM->GetSecurityId(bSecIDHost, &cbSecIDHost, 0L);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pSM->GetSecurityId(OLE2W(pszURL), bSecIDURL, &cbSecIDURL, 0L);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    if (cbSecIDHost != cbSecIDURL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (memcmp(bSecIDHost, bSecIDURL, cbSecIDHost) != 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
#ifdef ATLTRACE
    LPOLESTR pszHostName = NULL;
    TCHAR *pszFailPass = hr ? _T("Failed") : _T("Passed");
    GetHostURL(m_spClientSite, &pszHostName);
    ATLTRACE(_T("CTDCCtl: %s security check on %S referencing %S\n"), pszFailPass,
             pszHostName, pszURL);
    bSecIDHost[cbSecIDHost] = 0;
    bSecIDURL[cbSecIDURL] = 0;
    ATLTRACE(_T("CTDCCtl: Security ID Host %d bytes: %s\n"), cbSecIDHost, bSecIDHost);
    ATLTRACE(_T("CTDCCtl: Security ID URL %d bytes: %s\n"), cbSecIDURL, bSecIDURL);
    CoTaskMemFree(pszHostName);
#endif
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    OnData()
//
//  Synopsis:  Accepts a chunk of data loaded from a URL and parses it.
//
//  Arguments: pBSC       The invoking data transfer object.
//             pBytes     Character buffer containing data.
//             dwSize     Count of the number of bytes in 'pBytes'.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

void CTDCCtl::OnData(CMyBindStatusCallback<CTDCCtl> *pBSC, BYTE *pBytes, DWORD dwSize)
{
    HRESULT hr = S_OK;
    CTDCUnify::ALLOWDOMAINLIST nAllowDomainList;

    if (pBSC != m_pBSC)
    {
        OutputDebugStringX(_T("OnData called from invalid callback object\n"));
        goto Cleanup;
    }

    //  Process this chunk of data
    //
    hr = m_pUnify->ConvertByteBuffer(pBytes, dwSize);

    if (hr == S_FALSE)
    {
        // not enough data has shown up yet, just keep going
        hr = S_OK;
        goto Cleanup;
    }

    if (hr)
        goto Error;

    if (!m_fSecurityChecked)
    {
        // this forces the code below to check the DataURL, unless the allow_domain
        // list needs checking and it passes.  In that case, we need only check
        // the protocols, not the whole URL.
        hr = E_FAIL;

        if (!m_pUnify->ProcessedAllowDomainList())
        {
            // Note that we MUST check for the allow domain list at the
            // front of every file, even if it's on the same host.  This
            // is to make sure if we always strip off the @!allow_domain line.
            nAllowDomainList = m_pUnify->CheckForAllowDomainList();

            switch (nAllowDomainList)
            {
                // Don't have enough chars to tell yet.
                case CTDCUnify::ALLOW_DOMAINLIST_DONTKNOW:
                    if (pBytes != NULL && dwSize != 0)
                    {
                        // Return without errors or arborting.
                        // Presumably the next data packet will bring more info.
                        return;
                    }
                    _ASSERT(FAILED(hr));
                    break;

                case CTDCUnify::ALLOW_DOMAINLIST_NO:
                    _ASSERT(FAILED(hr));
                    break;

                case CTDCUnify::ALLOW_DOMAINLIST_YES:
                    // The file is decorated.  Now check the domain list
                    // against our host domain name.
                    hr = SecurityMatchAllowDomainList();
#ifdef ATLTRACE
                    if (!hr) ATLTRACE(_T("CTDCCtl: @!allow_domain list matched."));
                    else ATLTRACE(_T("CTDCCtl: @!allow_domain list did not match"));
#endif
                    break;
            }
        }

        // Unless we passed the previous security check, we still have to
        // do the next one.
        if (FAILED(hr))
        {
            if (FAILED(hr = SecurityCheckDataURL(m_pBSC->m_pszURL)))
                goto Error;
        }
        else
        {
            hr = SecurityMatchProtocols(m_pBSC->m_pszURL);
            if (FAILED(hr))
                goto Error;
        }


        // Set m_fSecurityChecked only if it passes security.  This is in case for some
        // reason we get more callbacks before the StopTransfer takes affect.
        m_fSecurityChecked = TRUE;
    }

    if (pBytes != NULL && dwSize != 0)
    {
        OutputDebugStringX(_T("OnData called with data buffer\n"));

        // Normal case, we can process data!
        hr = m_pUnify->AddWcharBuffer(FALSE);

    }
    else if (pBytes == NULL || dwSize == 0)
    {
        OutputDebugStringX(_T("OnData called with empty (terminating) buffer\n"));

        //  No more data - trigger an EOF
        //
        hr = m_pUnify->AddWcharBuffer(TRUE); // last chance to parse any stragglers

        if (m_pArr!=NULL)
            hr = m_pArr->EOF();

        TerminateDataLoad(pBSC);
    }

Cleanup:
    //  Void fn - can't return an error code ...
    //
    if (SUCCEEDED(m_hrDownloadStatus))
        m_hrDownloadStatus = hr;
    return;

Error:
    // Security failure.
    // Abort the current download
    if (m_pBSC && m_pBSC->m_spBinding)
    {
        (void) m_pBSC->m_spBinding->Abort();
    }

    m_hrDownloadStatus = hr;

    // Notify data set changed for the abort
    if (m_pEventBroker != NULL)
    {
        hr = m_pEventBroker->STDDataSetChanged();
        // and go complete.
        UpdateReadyState(READYSTATE_COMPLETE);
    }
    goto Cleanup;
}

//
// Utility routine to get our
//
HRESULT
GetHostURL(IOleClientSite *pSite, LPOLESTR *ppszHostName)
{
    HRESULT hr;
    CComPtr<IMoniker> spMoniker;
    CComPtr<IBindCtx> spBindCtx;

    if (!pSite)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pSite->GetMoniker(OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_CONTAINER,
                           &spMoniker);
    if (FAILED(hr))
        goto Cleanup;

    hr = CreateBindCtx(0, &spBindCtx);
    if (FAILED(hr))
        goto Cleanup;

    hr = spMoniker->GetDisplayName(spBindCtx, NULL, ppszHostName);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

HRESULT
CTDCCtl::SecurityMatchProtocols(LPOLESTR pszURL)
{
    HRESULT hr = E_FAIL;

    LPOLESTR pszHostURL = NULL;
    LPWCH pszPostHostProtocol;
    LPWCH pszPostProtocol;

    if (FAILED(GetHostURL(m_spClientSite, &pszHostURL)))
        goto Cleanup;

    pszPostHostProtocol = wch_chr(pszHostURL, _T(':'));
    pszPostProtocol     = wch_chr(pszURL, _T(':'));
    if (!pszPostHostProtocol || !pszPostProtocol)
        goto Cleanup;
    else
    {
        int ccChars1 = pszPostHostProtocol - pszHostURL;
        int ccChars2 = pszPostProtocol - pszURL;
        if (ccChars1 != ccChars2)
            goto Cleanup;
        else if (wch_ncmp(pszHostURL, pszURL, ccChars1) != 0)
            goto Cleanup;
    }
    hr = S_OK;

Cleanup:
    if (pszHostURL)
        CoTaskMemFree(pszHostURL);

    return hr;
}

HRESULT
CTDCCtl::SecurityMatchAllowDomainList()
{
    HRESULT hr;
    WCHAR swzHostDomain[INTERNET_MAX_HOST_NAME_LENGTH];
    DWORD cchHostDomain = INTERNET_MAX_HOST_NAME_LENGTH;
    LPOLESTR pszHostName = NULL;

    hr = GetHostURL(m_spClientSite, &pszHostName);
    if (FAILED(hr))
        goto Cleanup;

    hr = CoInternetParseUrl(pszHostName, PARSE_DOMAIN, 0, swzHostDomain, cchHostDomain,
                            &cchHostDomain, 0);
    if (FAILED(hr))
        goto Cleanup;

    hr = m_pUnify->MatchAllowDomainList(swzHostDomain);

Cleanup:
    CoTaskMemFree(pszHostName);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\tdcctl.h ===
//+-----------------------------------------------------------------------
//
//  Tabular Data Control
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCCtl.h
//
//  Contents:   Declaration of the CTDCCtl ActiveX Control.
//
//------------------------------------------------------------------------


#include "resource.h"       // main symbols
#include <simpdata.h>
#include "wch.h"
#include <wininet.h>        // for INTERNET_MAX_URL_LENGTH

#pragma comment(lib, "wininet.lib")

#ifndef DISPID_AMBIENT_CODEPAGE
#define DISPID_AMBIENT_CODEPAGE (-725)
#endif

// Declare helper needed in IHttpNegotiateImpl
HRESULT
GetHostURL(IOleClientSite *pSite, LPOLESTR *ppszHostName);

//------------------------------------------------------------------------
//
//  Template:  CMyBindStatusCallback
//
//  Synopsis:  This is a temporary kludge to get around an ATL feature
//             while we're waiting for it to become official code.
//
//------------------------------------------------------------------------

template <class T>
class ATL_NO_VTABLE IServiceProviderImpl
{
    public:
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
        _ATL_DEBUG_ADDREF_RELEASE_IMPL(IServiceProviderImpl)

        STDMETHOD(QueryService) (REFGUID guidService,
                                 REFIID riid,
                                 void **ppvObject)
        {
            return S_OK;
        }

};

template <class T>
class ATL_NO_VTABLE IHttpNegotiateImpl
{
    public:
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
        _ATL_DEBUG_ADDREF_RELEASE_IMPL(IHttpNegotiateImpl)

        STDMETHOD(BeginningTransaction) (LPCWSTR szURL,
                                         LPCWSTR szHeaders,
                                         DWORD dwReserved,
                                         LPWSTR *pszAdditionalHeaders)
        {
            return S_OK;
        }

        STDMETHOD(OnResponse) (DWORD dwResponseCode,
                               LPCWSTR szResponseHeaders,
                               LPCWSTR szRequestHeaders,
                               LPWSTR *pszAdditionalRequestHeaders)
        {
            return S_OK;
        }

};


// IE5 85290:  mshtml needs a way to recognize the TDC from
// its IBindStatusCallback.  We define a dummy interface for this.

template <class T>
class ATL_NO_VTABLE IAmTheTDCImpl
{
    public:
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
        _ATL_DEBUG_ADDREF_RELEASE_IMPL(IAmTheTDCImpl)
};


template <class T>
class ATL_NO_VTABLE CMyBindStatusCallback :
    public CComObjectRootEx<T::_ThreadModel::ThreadModelNoCS>,
    public IBindStatusCallbackImpl<T>, public IHttpNegotiateImpl<T>, public IServiceProviderImpl<T>,
    public IAmTheTDCImpl<T>
{
    typedef void (T::*ATL_PDATAAVAILABLE)(CMyBindStatusCallback<T>* pbsc, BYTE* pBytes, DWORD dwSize);

    public:

        BEGIN_COM_MAP(CMyBindStatusCallback<T>)
                COM_INTERFACE_ENTRY_IID(IID_IBindStatusCallback, IBindStatusCallbackImpl<T>)
                COM_INTERFACE_ENTRY_IID(IID_IHttpNegotiate, IHttpNegotiateImpl<T>)
                COM_INTERFACE_ENTRY_IID(IID_IServiceProvider, IServiceProviderImpl<T>)
                COM_INTERFACE_ENTRY_IID(IID_IAmTheTDC, IAmTheTDCImpl<T>)
        END_COM_MAP()

        CMyBindStatusCallback()
        {
            m_pT = NULL;
            m_pFunc = NULL;
            m_fReload = FALSE;
        }
        ~CMyBindStatusCallback()
        {
            ATLTRACE(_T("~CMyBindStatusCallback\n"));
        }

        // IServiceProvider methods

        STDMETHOD(QueryService) (REFGUID guidService,
                                 REFIID riid,
                                 void **ppvObject)
        {
            // As it turns out, the service ID for IHttpNegotiate is the same
            // as it's IID (confusing).  This is the only service we support.
            if (IsEqualGUID(IID_IHttpNegotiate, guidService))
            {
                return ((IHttpNegotiate *)this)->QueryInterface(riid, ppvObject);
            }
            else return E_NOTIMPL;
        }

        //
        // IHttpNegotiate methods
        //

        STDMETHOD(BeginningTransaction) (LPCWSTR szURL,
                                         LPCWSTR szHeaders,
                                         DWORD dwReserved,
                                         LPWSTR *pszAdditionalHeaders)
        {
            HRESULT hr = S_OK;
            WCHAR swzHostScheme[INTERNET_MAX_URL_LENGTH];
            DWORD cchHostScheme = INTERNET_MAX_URL_LENGTH;
            WCHAR swzFileScheme[INTERNET_MAX_URL_LENGTH];
            DWORD cchFileScheme = INTERNET_MAX_URL_LENGTH;            

            LPOLESTR pszHostName;

            *pszAdditionalHeaders = NULL;

            hr = GetHostURL(m_spClientSite, &pszHostName);
            if (FAILED(hr))
                goto Cleanup;

            // PARSE_SCHEMA didn't work, so we'll just CANONICALIZE and then use the first N
            // characters of the URL
            hr = CoInternetParseUrl(pszHostName, PARSE_CANONICALIZE, 0, swzHostScheme, cchHostScheme,
                                    &cchHostScheme, 0);
            if (FAILED(hr))
                goto Cleanup;

            // Don't send a referer which isn't http: or https:, it's none
            // of the servers' business.  Further, don't send an https:
            // referer when requesting an http: file.
            if (0 != wch_incmp(swzHostScheme, L"https:", 6) &&
                0 != wch_incmp(swzHostScheme, L"http:", 5))
                goto Cleanup;

            if (0 == wch_incmp(swzHostScheme, L"https:", 6))
            {
                hr = CoInternetParseUrl(szURL, PARSE_CANONICALIZE, 0, swzFileScheme, cchFileScheme,
                                        &cchFileScheme, 0);
                if (0 == wch_incmp(swzFileScheme, L"http:", 65)) // don't send https: referer
                    goto Cleanup;                                // to an http: file.
            }

            // 3*sizeof(WCHAR) is for CR, LF, & '\0'
            *pszAdditionalHeaders = (WCHAR *)CoTaskMemAlloc(sizeof(L"Referer: ") +
                                                            ocslen(pszHostName)*sizeof(WCHAR) +
                                                            3*sizeof(WCHAR));
            if (NULL != *pszAdditionalHeaders)
            {
                ocscpy(*pszAdditionalHeaders, L"Referer: ");
                ocscpy(&((*pszAdditionalHeaders)[9]), pszHostName);
                ocscpy(&((*pszAdditionalHeaders)[9+ocslen(pszHostName)]), L"\r\n");
            }

Cleanup:
            CoTaskMemFree(pszHostName);
            return hr;
        }

        STDMETHOD(OnResponse) (DWORD dwResponseCode,
                               LPCWSTR szResponseHeaders,
                               LPCWSTR szRequestHeaders,
                               LPWSTR *pszAdditionalRequestHeaders)
        {
            return S_OK;
        }



        //
        // IBindStatusCallback methods
        //

        STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding)
        {
            ATLTRACE(_T("CMyBindStatusCallback::OnStartBinding\n"));
            m_spBinding = pBinding;
            return S_OK;
        }

        STDMETHOD(GetPriority)(LONG *pnPriority)
        {
            ATLTRACENOTIMPL(_T("CMyBindStatusCallback::GetPriority"));
        }

        STDMETHOD(OnLowResource)(DWORD reserved)
        {
            ATLTRACENOTIMPL(_T("CMyBindStatusCallback::OnLowResource"));
        }

        STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
        {
            if (BINDSTATUS_REDIRECTING == ulStatusCode && szStatusText != NULL)
            {
                ocscpy(m_pszURL, szStatusText);
            }
			return S_OK;
        }

        STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError)
        {
            //      ATLTRACE(_T("CMyBindStatusCallback::OnStopBinding\n"));
            (m_pT->*m_pFunc)(this, NULL, 0);
            m_spBinding.Release();
            m_spBindCtx.Release();
            m_spMoniker.Release();
            return S_OK;
        }

        STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
        {
            ATLTRACE(_T("CMyBindStatusCallback::GetBindInfo\n"));

            if (!pbindInfo || !pbindInfo->cbSize || !pgrfBINDF)
                return E_INVALIDARG;

            *pgrfBINDF = BINDF_ASYNCHRONOUS
                         | BINDF_ASYNCSTORAGE
                         ;
// ;begin_internal
#ifdef NEVER
            // I want DEBUG mode to NOT cache things!! -cfranks
            *pgrfBINDF |= BINDF_GETNEWESTVERSION
                          | BINDF_NOWRITECACHE
                          | BINDF_RESYNCHRONIZE
                          ;
#endif
// ;end_internal

#ifndef DISPID_AMBIENT_OFFLINE
#define DISPID_AMBIENT_OFFLINE          (-5501)
#endif
            // Get our offline property from container
            VARIANT var;
            VariantInit(&var);
            DWORD dwConnectedStateFlags;
            m_pT->GetAmbientProperty(DISPID_AMBIENT_OFFLINE, var);
            if (var.vt==VT_BOOL && var.boolVal)
            {
                if (!(InternetGetConnectedState(&dwConnectedStateFlags, 0)) &&
                    (0 == (dwConnectedStateFlags & INTERNET_CONNECTION_MODEM_BUSY)))
                {
                    ATLTRACE(_T("CMyBindStatusCallback::GetBindInfo OFFLINE\n"));
				   // We're not even dialed out to another connectoid
                    *pgrfBINDF |= BINDF_OFFLINEOPERATION;
                }
                else
                {
                    ATLTRACE(_T("CMyBindStatusCallback::GetBindInfo OFFLINE\n"));
                    *pgrfBINDF &= ~BINDF_OFFLINEOPERATION;                   
                }
            }

            // See if we should force a reload, iff we're not offline.
            if (!(*pgrfBINDF & BINDF_OFFLINEOPERATION) && m_fReload)
            {
                *pgrfBINDF |= BINDF_RESYNCHRONIZE|BINDF_PRAGMA_NO_CACHE;
            }

            ULONG cbSize = pbindInfo->cbSize;
            memset(pbindInfo, 0, cbSize);

            pbindInfo->cbSize = cbSize;
            pbindInfo->dwBindVerb = BINDVERB_GET;

            return S_OK;
        }

        STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
        {
            ATLTRACE(_T("CMyBindStatusCallback::OnDataAvailable\n"));
            HRESULT hr = S_OK;

            // Get the Stream passed
            if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
            {
                if (!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
                {
                    m_spStream = pstgmed->pstm;
                }
            }

            DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
            DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

            // If there is some data to be read then go ahead and read them
            if (m_spStream)
            {
                if (dwRead > 0)
                {
                    BYTE* pBytes = NULL;
                    ATLTRY(pBytes = new BYTE[dwRead + 1]);
                    if (pBytes == NULL)
                        return S_FALSE;
                    hr = m_spStream->Read(pBytes, dwRead, &dwActuallyRead);
                    if (SUCCEEDED(hr))
                    {
                        pBytes[dwActuallyRead] = 0;
                        if (dwActuallyRead>0)
                        {
                            (m_pT->*m_pFunc)(this, pBytes, dwActuallyRead);
                            m_dwTotalRead += dwActuallyRead;
                        }
                    }
                    delete[] pBytes;
                }
            }

            if (BSCF_LASTDATANOTIFICATION & grfBSCF)
                m_spStream.Release();
            return hr;
        }

        STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk)
        {
            ATLTRACENOTIMPL(_T("CMyBindStatusCallback::OnObjectAvailable"));
        }

        HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative)
        {
            m_dwTotalRead = 0;
            m_dwAvailableToRead = 0;
            HRESULT hr = S_OK;
            CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pUnkContainer);
            CComPtr<IBindHost> spBindHost;
            CComPtr<IStream> spStream;
            if (spServiceProvider)
                spServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&spBindHost);

            // We don't bother checking this QI, because the only failure mode is that our
            // BeginningNegotitation method won't be able able to properly add the referer string.
            (void)pUnkContainer->QueryInterface(IID_IOleClientSite, (void **)&m_spClientSite);

            if (spBindHost == NULL)
            {
                if (bRelative)
                    return E_NOINTERFACE;  // relative asked for, but no IBindHost
                hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
                if (SUCCEEDED(hr))
                    hr = CreateBindCtx(0, &m_spBindCtx);

                if (SUCCEEDED(hr))
                    hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), 0, 0L);
                else
                    m_spMoniker.Release();

                if (SUCCEEDED(hr))
                {
                    LPOLESTR pszTemp = NULL;
                    hr = m_spMoniker->GetDisplayName(m_spBindCtx, NULL, &pszTemp);
                    if (!hr && pszTemp != NULL)
                        ocscpy(m_pszURL, pszTemp);
                    CoTaskMemFree(pszTemp);

                    hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&spStream);
                }
            }
            else
            {
                hr = CreateBindCtx(0, &m_spBindCtx);
                if (SUCCEEDED(hr))
                    hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), 0, 0L);

                if (SUCCEEDED(hr))
                {
                    if (bRelative)
                        hr = spBindHost->CreateMoniker(bstrURL, m_spBindCtx, &m_spMoniker, 0);
                    else
                        hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
                }

                if (SUCCEEDED(hr))
                {
                    LPOLESTR pszTemp = NULL;
                    hr = m_spMoniker->GetDisplayName(m_spBindCtx, NULL, &pszTemp);
                    if (!hr && pszTemp != NULL)
                        ocscpy(m_pszURL, pszTemp);
                    CoTaskMemFree(pszTemp);
                    hr = spBindHost->MonikerBindToStorage(m_spMoniker, NULL, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), IID_IStream, (void**)&spStream);
                    ATLTRACE(_T("Bound"));
                }
            }
            return hr;
        }

        HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative,
                                   BOOL fReload)
        {
            m_pT = pT;
            m_pFunc = pFunc;
            m_fReload = fReload;        // force reload if TRUE
            return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative);
        }

        static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
        {
            CComObject<CMyBindStatusCallback<T> > *pbsc;
            HRESULT hRes = CComObject<CMyBindStatusCallback<T> >::CreateInstance(&pbsc);
            if (FAILED(hRes))
                return hRes;
            return pbsc->StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative, FALSE);
        }
        CComPtr<IMoniker> m_spMoniker;
        CComPtr<IBindCtx> m_spBindCtx;
        CComPtr<IBinding> m_spBinding;
        CComPtr<IStream> m_spStream;
        CComPtr<IOleClientSite> m_spClientSite;
        BOOL m_fReload;
        OLECHAR m_pszURL[INTERNET_MAX_URL_LENGTH];
        T* m_pT;
        ATL_PDATAAVAILABLE m_pFunc;
        DWORD m_dwTotalRead;
        DWORD m_dwAvailableToRead;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
// CTimer
template <class Derived, class T, const IID* piid>
class CTimer
{
public:

    CTimer()
    {
        m_bTimerOn = FALSE;
    }

    HRESULT TimerOn(DWORD dwTimerInterval)
    {
        Derived* pDerived = ((Derived*)this);

        m_dwTimerInterval = dwTimerInterval;
        if (m_bTimerOn) // already on, just change interval
            return S_OK;

        m_bTimerOn = TRUE;
        m_dwTimerInterval = dwTimerInterval;
        m_pStream = NULL; 

        HRESULT hRes;

        hRes = CoMarshalInterThreadInterfaceInStream(*piid, (T*)pDerived, &m_pStream);

        // Create thread and pass the thread proc the this ptr
        m_hThread = CreateThread(NULL, 0, &_Apartment, (void*)this, 0, &m_dwThreadID);

        return S_OK;
    }

    void TimerOff()
    {
        if (m_bTimerOn)
        {
            m_bTimerOn = FALSE;
            AtlWaitWithMessageLoop(m_hThread);
        }
    }


// Implementation
private:
    static DWORD WINAPI _Apartment(void* pv)
    {
        CTimer<Derived, T, piid>* pThis = (CTimer<Derived, T, piid>*) pv;
        pThis->Apartment();
        return 0;
    }

    DWORD Apartment()
    {
        CoInitialize(NULL);
        HRESULT hRes;

        m_spT.Release();

        if (m_pStream)
        {
            hRes = CoGetInterfaceAndReleaseStream(m_pStream, *piid, (void**)&m_spT);
        }

        while(m_bTimerOn)
        {
            Sleep(m_dwTimerInterval);
            if (!m_bTimerOn)
                break;

            m_spT->_OnTimer();
        }
        m_spT.Release();

        CoUninitialize();
        return 0;
    }

// Attributes
public:
    DWORD m_dwTimerInterval;

// Implementation
private:
    HANDLE m_hThread;
    DWORD m_dwThreadID;
    LPSTREAM m_pStream;
    CComPtr<T> m_spT;
    BOOL m_bTimerOn;
};

class CEventBroker;

//////////////////////////////////////////////////////////////////////////////
// CProxyITDCCtlEvents
template <class T>
class CProxyITDCCtlEvents : public IConnectionPointImpl<T, &IID_ITDCCtlEvents, CComDynamicUnkArray>
{
//ITDCCtlEvents : IDispatch
public:
    void FireOnReadyStateChanged()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS dispParams;
                dispParams.cArgs = 0;
                dispParams.cNamedArgs = 0;
                dispParams.rgvarg = NULL;
                dispParams.rgdispidNamedArgs = NULL;
                ITDCCtlEvents* pITDCCtlEvents = reinterpret_cast<ITDCCtlEvents*>(*pp);
                pITDCCtlEvents->Invoke(DISPID_READYSTATECHANGE, IID_NULL, CP_ACP, DISPATCH_METHOD, &dispParams,
                                       NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        return;
    }

};


//------------------------------------------------------------------------
//
//  Class:     CTDCCtl
//
//  Synopsis:  This is the TabularDataControl COM object.
//             It creates a CTDCArr object to manage the control's data.
//
//------------------------------------------------------------------------

class CTDCCtl :
    public CComObjectRoot,
    public CComCoClass<CTDCCtl, &CLSID_CTDCCtl>,
    public CComControl<CTDCCtl>,
    public CStockPropImpl<CTDCCtl, ITDCCtl, &IID_ITDCCtl, &LIBID_TDCLib>,
    public IProvideClassInfo2Impl<&CLSID_CTDCCtl, &IID_ITDCCtlEvents, &LIBID_TDCLib>,
    public IPersistStreamInitImpl<CTDCCtl>,
    public IOleControlImpl<CTDCCtl>,
    public IOleObjectImpl<CTDCCtl>,
    public IOleInPlaceActiveObjectImpl<CTDCCtl>,
    public IViewObjectExImpl<CTDCCtl>,
    public IOleInPlaceObjectWindowlessImpl<CTDCCtl>,
    public IPersistPropertyBagImpl<CTDCCtl>,
    public CTimer<CTDCCtl, ITDCCtl, &IID_ITDCCtl>,
    public IRunnableObjectImpl<CTDCCtl>,
    public IConnectionPointContainerImpl<CTDCCtl>,
    public IPropertyNotifySinkCP<CTDCCtl>,
    public CProxyITDCCtlEvents<CTDCCtl>
{
public:
    CTDCCtl();
    ~CTDCCtl();

DECLARE_REGISTRY_RESOURCEID(IDR_TDCCtl)

DECLARE_NOT_AGGREGATABLE(CTDCCtl)

BEGIN_COM_MAP(CTDCCtl) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITDCCtl)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    COM_INTERFACE_ENTRY_IMPL(IRunnableObject)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CTDCCtl)
    PROP_ENTRY("RowDelim",      DISPID_ROWDELIM,    CLSID_CTDCCtl)
    PROP_ENTRY("FieldDelim",    DISPID_FIELDDELIM,  CLSID_CTDCCtl)
    PROP_ENTRY("TextQualifier", DISPID_TEXTQUALIFIER,   CLSID_CTDCCtl)
    PROP_ENTRY("EscapeChar",    DISPID_ESCAPECHAR,  CLSID_CTDCCtl)
    PROP_ENTRY("UseHeader",     DISPID_USEHEADER,   CLSID_CTDCCtl)
    PROP_ENTRY("SortAscending", DISPID_SORTASCENDING,   CLSID_CTDCCtl)
    PROP_ENTRY("SortColumn",    DISPID_SORTCOLUMN,  CLSID_CTDCCtl)
    PROP_ENTRY("FilterValue",   DISPID_FILTERVALUE, CLSID_CTDCCtl)
    PROP_ENTRY("FilterCriterion",   DISPID_FILTERCRITERION, CLSID_CTDCCtl)
    PROP_ENTRY("FilterColumn",  DISPID_FILTERCOLUMN,CLSID_CTDCCtl)
    PROP_ENTRY("CharSet",       DISPID_CHARSET,     CLSID_CTDCCtl)
    PROP_ENTRY("Language",      DISPID_LANGUAGE,    CLSID_CTDCCtl)
    PROP_ENTRY("CaseSensitive", DISPID_CASESENSITIVE, CLSID_CTDCCtl)
    PROP_ENTRY("Sort",          DISPID_SORT,        CLSID_CTDCCtl)
// ;begin_internal
//  Doesn't work right yet.
//    PROP_ENTRY("RefreshInterval",   DISPID_TIMER,      CLSID_CTDCCtl)
// ;end_internal
    PROP_ENTRY("Filter",        DISPID_FILTER,      CLSID_CTDCCtl)
    PROP_ENTRY("AppendData",    DISPID_APPENDDATA,  CLSID_CTDCCtl)
// ;begin_internal
//  Trying to save this property causes OLEAUT to GP Fault trying
//  to conver the IDispatch * to a BSTR!
//    PROP_ENTRY("OSP",           DISPID_OSP,         CLSID_CTDCCtl)
// ;end_internal
    //  This will be removed when we learn more about the HTML
    //  sub-tag "OBJECT"
    PROP_ENTRY("DataURL",       DISPID_DATAURL,     CLSID_CTDCCtl)
    PROP_ENTRY("ReadyState",    DISPID_READYSTATE,  CLSID_CTDCCtl)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CTDCCtl)
CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
CONNECTION_POINT_ENTRY(IID_ITDCCtlEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CTDCCtl)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()

private:
    CComBSTR     m_cbstrFieldDelim;
    CComBSTR     m_cbstrRowDelim;
    CComBSTR     m_cbstrQuoteChar;
    CComBSTR     m_cbstrEscapeChar;
    BOOL         m_fUseHeader;
    CComBSTR     m_cbstrSortColumn;
    BOOL         m_fSortAscending;
    CComBSTR     m_cbstrFilterValue;
    OSPCOMP      m_enumFilterCriterion;
    CComBSTR     m_cbstrFilterColumn;
    UINT         m_nCodePage;
    UINT         m_nAmbientCodePage;
    CComBSTR     m_cbstrLanguage;
    CComBSTR     m_cbstrDataURL;
    LCID         m_lcidRead;
    boolean      m_fDataURLChanged;
    HRESULT      m_hrDownloadStatus;
    LONG         m_lTimer;
    CComBSTR     m_cbstrFilterExpr;
    CComBSTR     m_cbstrSortExpr;
    BOOL         m_fAppendData;
    BOOL         m_fCaseSensitive;
    boolean      m_fInReset;

    OLEDBSimpleProvider *m_pSTD;
    CTDCArr      *m_pArr;
    IMultiLanguage  *m_pML;
    BOOL         m_fSecurityChecked;

// ;begin_internal
    DATASRCListener *m_pDATASRCListener;
// ;end_internal
    DataSourceListener *m_pDataSourceListener;
    CEventBroker *m_pEventBroker;


    //  These member objects are used while parsing the input stream
    //
    CTDCUnify       *m_pUnify;
    CComObject<CMyBindStatusCallback<CTDCCtl> > *m_pBSC;

// These members and methods expose the ITDCCtl interface
//
public:

    //  Control Properties
    //
    STDMETHOD(get_FieldDelim)(BSTR* pbstrFieldDelim);
    STDMETHOD(put_FieldDelim)(BSTR bstrFieldDelim);
    STDMETHOD(get_RowDelim)(BSTR* pbstrRowDelim);
    STDMETHOD(put_RowDelim)(BSTR bstrRowDelim);
    STDMETHOD(get_TextQualifier)(BSTR* pbstrTextQualifier);
    STDMETHOD(put_TextQualifier)(BSTR bstrTextQualifier);
    STDMETHOD(get_EscapeChar)(BSTR* pbstrEscapeChar);
    STDMETHOD(put_EscapeChar)(BSTR bstrEscapeChar);
    STDMETHOD(get_UseHeader)(VARIANT_BOOL* pfUseHeader);
    STDMETHOD(put_UseHeader)(VARIANT_BOOL fUseHeader);
    STDMETHOD(get_SortColumn)(BSTR* pbstrSortColumn);
    STDMETHOD(put_SortColumn)(BSTR bstrSortColumn);
    STDMETHOD(get_SortAscending)(VARIANT_BOOL* pfSortAscending);
    STDMETHOD(put_SortAscending)(VARIANT_BOOL fSortAscending);
    STDMETHOD(get_FilterValue)(BSTR* pbstrFilterValue);
    STDMETHOD(put_FilterValue)(BSTR bstrFilterValue);
    STDMETHOD(get_FilterCriterion)(BSTR* pbstrFilterCriterion);
    STDMETHOD(put_FilterCriterion)(BSTR bstrFilterCriterion);
    STDMETHOD(get_FilterColumn)(BSTR* pbstrFilterColumn);
    STDMETHOD(put_FilterColumn)(BSTR bstrFilterColumn);
    STDMETHOD(get_CharSet)(BSTR *pbstrCharSet);
    STDMETHOD(put_CharSet)(BSTR bstrCharSet);
    STDMETHOD(get_Language)(BSTR* pbstrLanguage);
    STDMETHOD(put_Language_)(LPWCH pwchLanguage);
    STDMETHOD(put_Language)(BSTR bstrLanguage);
    STDMETHOD(get_CaseSensitive)(VARIANT_BOOL *pfCaseSensitive);
    STDMETHOD(put_CaseSensitive)(VARIANT_BOOL fCaseSensitive);
    STDMETHOD(get_DataURL)(BSTR* pbstrDataURL); // 
    STDMETHOD(put_DataURL)(BSTR bstrDataURL);
// ;begin_internal
//    STDMETHOD(get_RefreshInterval)(LONG* plTimer);
//    STDMETHOD(put_RefreshInterval)(LONG lTimer);
// ;end_internal
    STDMETHOD(get_Filter)(BSTR* pbstrFilterExpr);
    STDMETHOD(put_Filter)(BSTR bstrFilterExpr);
    STDMETHOD(get_Sort)(BSTR* pbstrSortExpr);
    STDMETHOD(put_Sort)(BSTR bstrSortExpr);
    STDMETHOD(get_AppendData)(VARIANT_BOOL* pfAppendData);
    STDMETHOD(put_AppendData)(VARIANT_BOOL fAppendData);
    STDMETHOD(get_OSP)(OLEDBSimpleProviderX ** ppISTD);

    STDMETHOD(get_ReadyState)(LONG *lReadyState);
    STDMETHOD(put_ReadyState)(LONG lReadyState);

    // Override IPersistPropertyBagImpl::Load
    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);

    void UpdateReadyState(LONG lReadyState);
    //  Data source notification methods
    STDMETHOD(msDataSourceObject)(BSTR qualifier, IUnknown **ppUnk);
    STDMETHOD(addDataSourceListener)(IUnknown *pEvent);

    //  Control Methods
    //
    STDMETHOD(Reset)();
    STDMETHOD(_OnTimer)(void);

private:
    STDMETHOD(CreateTDCArr)(boolean fAppend);
    STDMETHOD(ReleaseTDCArr)(boolean fReplacing);
    void LockBSC();
    void UnlockBSC();
    STDMETHOD(InitiateDataLoad)(boolean fAppend);
    STDMETHOD(SecurityCheckDataURL)(LPOLESTR pszURL);
    STDMETHOD(SecurityMatchAllowDomainList)();
    STDMETHOD(SecurityMatchProtocols)(LPOLESTR pszURL);
    STDMETHOD(TerminateDataLoad)(CMyBindStatusCallback<CTDCCtl> *pBSC);
    BSTR bstrConstructSortExpr();
    BSTR bstrConstructFilterExpr();

protected:
    void OnData(CMyBindStatusCallback<CTDCCtl> *pbsc, BYTE *pBytes, DWORD dwSize);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\wch.h ===
//+-----------------------------------------------------------------------
//
//  Wide Character Routines
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       wch.h
//
//  Contents:   Declaration of wide characters routines.
//              These routines are being used to avoid dragging in
//              the initialisation chunk of the C run-time library
//              that would be required by library routines such as
//              wcsicmp() etc.
//
//------------------------------------------------------------------------

extern int wch_icmp(LPWCH pwch1, LPWCH pwch2);
extern int wch_incmp(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxCmp);
extern int wch_cmp(LPWCH pwch1, LPWCH pwch2);
extern int wch_ncmp(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxCmp);
extern int wch_len(LPWCH pwch);
extern void wch_cpy(LPWCH pwch1, LPWCH pwch2);
extern LPWCH wch_chr(LPWCH pwch, WCHAR wch);
extern boolean wch_wildcardMatch(LPWCH pwchText, LPWCH pwchPattern,
                                 boolean fCaseSensitive);

//------------------------------------------------------------------------
//
//  Function:  wch_ncpy()
//
//  Synopsis:  Perform an n-character wide-string copy.
//             Copies 'dwSize' characters from 'pwchSrc' to 'pwchDest'.
//
//  Arguments: pwchDesc  Destination buffer.
//             pwchSrc   Source string.
//             dwSize    Number of characters to copy.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

inline void wch_ncpy(LPWCH pwchDest, LPWCH pwchSrc, DWORD dwSize)
{
    memcpy(pwchDest, pwchSrc, dwSize * sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\tdc\wch.cpp ===
//+-----------------------------------------------------------------------
//
//  Wide Character Routines
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       wch.cpp
//
//  Contents:   Implementation of wide characters routines.
//              These routines are being used to avoid dragging in
//              the initialisation chunk of the C run-time library
//              that would be required by library routines such as
//              wcsicmp() etc.
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include "shlwapi.h"            // Wrapper routines for non-Win95 calls

#pragma comment(lib, "shlwapi.lib")

//------------------------------------------------------------------------
//
//  Function:  wch_icmp()
//
//  Synopsis:  Perform a case-insensitive comparison of two strings.
//
//  Arguments: pwch1     First string to compare
//             pwch2     Second string to compare
//             Treats NULLs as empty strings.
//
//  Returns:   0 if the strings are lexically equal (allowing for
//               case insensitivity)
//             -1 if pwch1 lexically less than pwch2
//             +1 if pwch1 lexically greater than pwch2
//
//------------------------------------------------------------------------

int wch_icmp(LPWCH pwch1, LPWCH pwch2)
{
    USES_CONVERSION;

    if (pwch1 == NULL)
        pwch1 = L"";
    if (pwch2 == NULL)
        pwch2 = L"";

    return StrCmpIW(pwch1, pwch2);
}

//------------------------------------------------------------------------
//
//  Function:  wch_incmp()
//
//  Synopsis:  Perform a case-insensitive comparison of two strings,
//             up to a specified maximum number of characters.
//
//  Arguments: pwch1     First string to compare
//             pwch2     Second string to compare
//             dwMaxLen  Maximum number of characters to compare.
//
//             Treats NULLs as empty strings.
//
//  Returns:   0 if the strings are lexically equal (allowing for
//               case insensitivity)
//             -1 if pwch1 lexically less than pwch2
//             +1 if pwch1 lexically greater than pwch2
//
//------------------------------------------------------------------------

int wch_incmp(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxLen)
{

    if (pwch1 == NULL)
        pwch1 = L"";
    if (pwch2 == NULL)
        pwch2 = L"";

    return StrCmpNIW(pwch1, pwch2, dwMaxLen);
}

//------------------------------------------------------------------------
//
//  Function:  wch_len()
//
//  Synopsis:  Calculate the length of a string.
//             Treats NULL as an empty string.
//
//  Arguments: pwch      String to measure
//
//  Returns:   Length of given string.
//
//------------------------------------------------------------------------

int wch_len(LPWCH pwch)
{
    LPWCH   pwchOrig = pwch;

    if (pwch == NULL)
        return 0;
    while (*pwch++ != 0)
        ;
    return pwch - pwchOrig - 1;
}

//------------------------------------------------------------------------
//
//  Function:  wch_cmp()
//
//  Synopsis:  Perform a case-sensitive comparison of two strings.
//             Treats NULLs as empty strings.
//
//  Arguments: pwch1     First string to compare
//             pwch2     Second string to compare
//
//  Returns:   0 if the strings are lexically equal
//             -1 if pwch1 lexically less than pwch2
//             +1 if pwch1 lexically greater than pwch2
//
//------------------------------------------------------------------------

int wch_cmp(LPWCH pwch1, LPWCH pwch2)
{
    if (pwch1 == NULL)
        pwch1 = L"";
    if (pwch2 == NULL)
        pwch2 = L"";
    for (; *pwch1 != 0 && *pwch1 == *pwch2; pwch1++, pwch2++)
        ;
    return *pwch1 - *pwch2;
}

//------------------------------------------------------------------------
//
//  Function:  wch_ncmp()
//
//  Synopsis:  Perform a case-sensitive comparison of two strings,
//             up to a specified maximum number of characters.
//
//  Arguments: pwch1     First string to compare
//             pwch2     Second string to compare
//             dwMaxLen  Maximum number of characters to compare.
//
//             Treats NULLs as empty strings.
//
//  Returns:   0 if the strings are lexically equal (allowing for
//               case insensitivity)
//             -1 if pwch1 lexically less than pwch2
//             +1 if pwch1 lexically greater than pwch2
//
//------------------------------------------------------------------------

int wch_ncmp(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxLen)
{
    int cmp;

    if (pwch1 == NULL)
        pwch1 = L"";
    if (pwch2 == NULL)
        pwch2 = L"";

    for (cmp = 0; cmp == 0 && dwMaxLen-- > 0; pwch1++, pwch2++)
        if (*pwch1 == 0)
        {
            cmp = (*pwch2 == 0) ? 0 : -1;
            break;
        }
        else
            cmp = (*pwch2 == 0) ? 1 : (*pwch2 - *pwch1);

    return cmp;
}

//------------------------------------------------------------------------
//
//  Function:  wch_cpy()
//
//  Synopsis:  Copy a wide-character null-terminated string.
//             Treats NULL source as an empty string.
//
//  Arguments: pwchDesc  Destination buffer.
//             pwchSrc   Source string.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

void wch_cpy(LPWCH pwchDest, LPWCH pwchSrc)
{
    if (pwchSrc == NULL)
        *pwchDest = 0;
    else
        while ((*pwchDest++ = *pwchSrc++) != 0)
            ;
}

//------------------------------------------------------------------------
//
//  Function:  wch_chr()
//
//  Synopsis:  Searches for a character in a null-terminated wide-character
//             string.
//             Treats NULL pwch as an empty string.
//
//  Arguments: pwch      Search string.
//             wch       Character to search for.copy.
//
//  Returns:   Pointer to first occurrence of 'wch' in 'pwch' if found.
//             NULL if 'wch' does not occur in 'pwch'.
//
//------------------------------------------------------------------------

LPWCH wch_chr(LPWCH pwch, WCHAR wch)
{
    if (pwch != NULL)
        for (; *pwch != 0; pwch++)
            if (*pwch == wch)
                return pwch;
    return NULL;
}

//------------------------------------------------------------------------
//
//  Function:  wch_wildcardMatch()
//
//  Synopsis:  Determines whether the given text matches the given
//             pattern, which interprets the character '*' as a match
//             for 0-or-more characters.
//             Treats NULL pwchText as an empty string.
//             Treats NULL pwchPattern as an empty string.
//
//  Arguments: pwchText         Text to match.
//             pwchPattern      Pattern to match against.
//             fCaseSensitive   Flag to indicate whether match should be
//                                case sensitive.
//
//  Returns:   TRUE if the text matches the given pattern.
//             FALSE otherwise.
//
//------------------------------------------------------------------------

// ;begin_internal
// compiler bug (VC5 with optimise?)
// ;end_internal
boolean wch_wildcardMatch(LPWCH pwchText, LPWCH pwchPattern,
                          boolean fCaseSensitive)
{
    boolean fMatched;
    LPWCH pwchStar;
    DWORD   dwPatternLen;

    if (pwchText == NULL || pwchText[0] == 0)
    {
        //  Empty/NULL text.  This matches:
        //     - Empty/NULL patterns
        //     - Patterns consisting of a string of '*'s
        //
        //  Equivalently, the text FAILS to match if there
        //  is at least one non-* character in the pattern.
        //
        fMatched = TRUE;
        if (pwchPattern != NULL)
            while (fMatched && *pwchPattern != 0)
                fMatched = *pwchPattern++ == L'*';
        goto Done;
    }
    if (pwchPattern == NULL || pwchPattern[0] == 0)
    {
        //  NULL pattern can only match empty text.
        //  Since we've already dealt with the case of empty text above,
        //  the match must fail
        //
        fMatched = FALSE;
        goto Done;
    }

    //  Find the occurrence of the first '*' in the pattern ...
    //
    pwchStar = wch_chr(pwchPattern, L'*');

    if (pwchStar == NULL)
    {
        //  No '*'s in the pattern - compute an exact match
        //
        fMatched = fCaseSensitive
            ? wch_cmp(pwchText, pwchPattern) == 0
            : wch_icmp(pwchText, pwchPattern) == 0;
        goto Done;
    }

    int (*pfnBufCmp)(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxCmp);

    pfnBufCmp = fCaseSensitive ? wch_ncmp : wch_incmp;

    //  Ensure an exact match for characters preceding the first '*', if any
    //
    dwPatternLen = pwchStar - pwchPattern;
    fMatched = (*pfnBufCmp)(pwchText, pwchPattern, dwPatternLen) == 0;
    if (!fMatched)
        goto Done;
    pwchText += dwPatternLen;

    for (;;)
    {
        DWORD dwTextLen = wch_len(pwchText);

        //  Skip over leading '*'s in the pattern
        //
        _ASSERT(*pwchStar == L'*');
        while (*pwchStar == L'*')
            pwchStar++;

        pwchPattern = pwchStar;

        //  Find the next occurrence of a '*' in the pattern
        //
        if (*pwchPattern == 0)
        {
            //  This must be have been a trailing '*' in the pattern.
            //  It automatically matches what remains of the text.
            //
            fMatched = TRUE;
            goto Done;
        }
        pwchStar = wch_chr(pwchPattern, L'*');
        if (pwchStar == NULL)
        {
            //  No more '*'s - require an exact match of remaining
            //  pattern text with the end of the text.
            //
            dwPatternLen = wch_len(pwchPattern);
            fMatched = (dwTextLen >= dwPatternLen) &&
                        (*pfnBufCmp)(pwchText + dwTextLen - dwPatternLen,
                                     pwchPattern, dwPatternLen) == 0;
            goto Done;
        }

        //  Locate an exact match for the pattern-up-to-next-*
        //  within the text buffer
        //
        dwPatternLen = pwchStar - pwchPattern;
        fMatched = FALSE;
        while (dwTextLen >= dwPatternLen)
        {
            fMatched = (*pfnBufCmp)(pwchText, pwchPattern, dwPatternLen) == 0;
            if (fMatched)
                break;
             dwTextLen--;
             pwchText++;
        }
        if (!fMatched)
            goto Done;
        pwchText += dwPatternLen;
    }

Done:
    return fMatched;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\array_p.inl ===
//---------------------------------------------------------------------------
// ARRAY_P.inl : CPtrArray inline functions
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CPTRARRAY_INL__
#define __CPTRARRAY_INL__


inline int CPtrArray::GetSize() const
	{ return m_nSize; }
inline int CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
inline void CPtrArray::RemoveAll()
	{ SetSize(0); }
inline void* CPtrArray::GetAt(int nIndex) const
	{ ASSERT_(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
inline void CPtrArray::SetAt(int nIndex, void* newElement)
	{ ASSERT_(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
inline void*& CPtrArray::ElementAt(int nIndex)
	{ ASSERT_(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
inline const void** CPtrArray::GetData() const
	{ return (const void**)m_pData; }
inline void** CPtrArray::GetData()
	{ return (void**)m_pData; }
inline int CPtrArray::Add(void* newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
inline void* CPtrArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
inline void*& CPtrArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }

#endif // __CPTRARRAY_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\bookmark.h ===
//---------------------------------------------------------------------------
// Bookmark.h : CVDBookmark header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDBOOKMARK__
#define __CVDBOOKMARK__

#define VDBOOKMARKSTATUS_INVALID	0	// same as CURSOR_DBBMK_INVALID  
#define VDBOOKMARKSTATUS_CURRENT	1	// same as CURSOR_DBBMK_CURRENT  
#define VDBOOKMARKSTATUS_BEGINNING	2	// same as CURSOR_DBBMK_BEGINNING
#define VDBOOKMARKSTATUS_END		3	// same as CURSOR_DBBMK_END      

class CVDCursorPosition;

class CVDBookmark
{
	friend class CVDCursorPosition;
public:
// Construction/Destruction
    CVDBookmark();
	~CVDBookmark();

public:

// Access functions
	CURSOR_DBVARIANT GetBookmarkVariant(){return m_varBookmark;}
	HROW GetHRow(){return m_hRow;}
	BYTE* GetBookmark(){return m_pBookmark;}
	ULONG GetBookmarkLen(){return m_cbBookmark;}
	WORD GetStatus(){return m_wStatus;}

// validation functions
	BOOL IsSameBookmark(CVDBookmark * pbm);
	BOOL IsSameHRow(HROW hRow){return VDBOOKMARKSTATUS_CURRENT == m_wStatus && hRow == m_hRow ? TRUE : FALSE;}

protected:
// Data members
    CURSOR_DBVARIANT m_varBookmark;  // variant that holds bookmark as a safearray 
    ULONG           m_cbBookmark;    // length of bookmark in bytes
    BYTE *          m_pBookmark;     // pointer to bookmark's data
    HROW            m_hRow;          // hRow associated with this bookmark
    WORD			m_wStatus;		 // beginning/end/row/unknown

// Initialization functions
	void Reset();
	HRESULT SetBookmark(WORD wStatus, HROW hRow = 0, BYTE* pBookmark = NULL, ULONG cbBookmark = 0);

};


#endif //__CVDBOOKMARK__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\bookmark.cpp ===
//---------------------------------------------------------------------------
// Bookmark.cpp : CVDBookmark implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "bookmark.h"         

SZTHISFILE

//=--------------------------------------------------------------------------=
// CVDBookmark - Constructor
//
CVDBookmark::CVDBookmark()
{

    VariantInit((VARIANT*)&m_varBookmark);
    m_pBookmark			= NULL;

	Reset();
}

//=--------------------------------------------------------------------------=
// ~CVDBookmark - Destructor
//
CVDBookmark::~CVDBookmark()
{

	SAFEARRAY * psa = NULL;

	if ((VT_ARRAY | VT_UI1) == V_VT(&m_varBookmark))
		psa = V_ARRAY(&m_varBookmark);

	if (psa && m_pBookmark)
		SafeArrayUnaccessData(psa);

    VariantClear((VARIANT*)&m_varBookmark);
}

//=--------------------------------------------------------------------------=
// Reset
//
void CVDBookmark::Reset()
{
    m_cbBookmark		= 0;   
    m_hRow				= 0;
	SetBookmark(VDBOOKMARKSTATUS_BEGINNING);
}

//=--------------------------------------------------------------------------=
// SetBookmark 
//
HRESULT CVDBookmark::SetBookmark(WORD wStatus, HROW hRow, BYTE* pBookmark, ULONG cbBookmark)
{

	SAFEARRAY * psa = NULL;

	switch (wStatus)
	{
		case VDBOOKMARKSTATUS_BEGINNING:
			cbBookmark	= CURSOR_DB_BMK_SIZE;
			pBookmark	= (BYTE*)&CURSOR_DBBMK_BEGINNING;
			break;
		case VDBOOKMARKSTATUS_END:
			cbBookmark	= CURSOR_DB_BMK_SIZE;
			pBookmark	= (BYTE*)&CURSOR_DBBMK_END;
			break;
		case VDBOOKMARKSTATUS_CURRENT:
			break;
		case VDBOOKMARKSTATUS_INVALID:
			return S_OK;
		default:
			ASSERT_(FALSE);
			return E_FAIL;
	}

	// initialize status flag
	m_wStatus	= VDBOOKMARKSTATUS_INVALID;

	// get pointer to existing safe array
	if ((VT_ARRAY | VT_UI1) == V_VT(&m_varBookmark))
		psa = V_ARRAY(&m_varBookmark);

	if (psa)
	{
		// if len changed and new len not = zero then redim array
		if (cbBookmark && cbBookmark != m_cbBookmark)
		{
			long lUbound;
			HRESULT hr = SafeArrayGetUBound(psa, 1, &lUbound);
			ASSERT_(!hr);
			if ((ULONG)lUbound + 1 != cbBookmark)	// confirm array needs rediming
			{
				if (psa && m_pBookmark)
					SafeArrayUnaccessData(psa);	// release old lock
				SAFEARRAYBOUND sab;
				sab.lLbound = 0; 
				sab.cElements = cbBookmark; 
				hr = SafeArrayRedim(psa, &sab);
				ASSERT_(!hr);
				if SUCCEEDED(hr)
					SafeArrayAccessData(psa, (void**)&m_pBookmark);
				else
					return hr;
			}
		}
	}
	else
	// if no existing array create one if passed in length not zero 
	if (cbBookmark && pBookmark)
	{
		SAFEARRAYBOUND sab;
		sab.lLbound = 0; 
		sab.cElements = cbBookmark; 
		psa = SafeArrayCreate(VT_UI1, 1, &sab);
		// if create was successful intital VARIANT structure
		if (psa)
		{
			V_VT(&m_varBookmark) = VT_ARRAY | VT_UI1;
            V_ARRAY(&m_varBookmark) = psa;
			SafeArrayAccessData(psa, (void**)&m_pBookmark);
		}
		else
			return E_OUTOFMEMORY;
	}

	// if everthing ok then copy bookmark data into safe array
	if (psa && m_pBookmark && pBookmark && cbBookmark)
		memcpy(m_pBookmark, pBookmark, cbBookmark);

	m_wStatus		= wStatus;
	m_cbBookmark	= cbBookmark;
	m_hRow			= hRow;

	return S_OK;
}

//=--------------------------------------------------------------------------=
// IsSameBookmark - compares bookmark data 
//
BOOL CVDBookmark::IsSameBookmark(CVDBookmark * pbm)
{
	ASSERT_(pbm);

	if (!pbm ||	
		VDBOOKMARKSTATUS_INVALID == pbm->GetStatus() ||
		VDBOOKMARKSTATUS_INVALID == m_wStatus)
		return FALSE;

	if (pbm->GetBookmarkLen() == m_cbBookmark	&&
		memcmp(pbm->GetBookmark(), m_pBookmark, m_cbBookmark) == 0)
		return TRUE;
	else
		return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\array_p.h ===
//---------------------------------------------------------------------------
// ARRAY_P.h : CPtrArray header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CPTRARRAY__
#define __CPTRARRAY__

////////////////////////////////////////////////////////////////////////////

class CPtrArray
{

public:

// Construction
	CPtrArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(int nIndex) const;
	void SetAt(int nIndex, void* newElement);
	void*& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const void** GetData() const;
	void** GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, void* newElement);
	int Add(void* newElement);
	int Append(const CPtrArray& src);
	void Copy(const CPtrArray& src);

	// overloaded operator helpers
	void* operator[](int nIndex) const;
	void*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, void* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CPtrArray();
//#ifdef _DEBUG
//	void Dump(CDumpContext&) const;
//	void AssertValid() const;
//#endif

protected:
	// local typedefs for class templates
//	typedef void* BASE_TYPE;
//	typedef void* BASE_ARG_TYPE;
};
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

#endif //__CPTRARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\array_p.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "stdafx.h"

SZTHISFILE

#include "ARRAY_P.INL"

/////////////////////////////////////////////////////////////////////////////

CPtrArray::CPtrArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CPtrArray::~CPtrArray()
{
//	ASSERT_VALID(this);

	delete[] (BYTE*)m_pData;
}

void CPtrArray::SetSize(int nNewSize, int nGrowBy)
{
//	ASSERT_VALID(this);
	ASSERT_(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT_(nNewSize <= SIZE_T_MAX/sizeof(void*));    // no overflow
#endif
		m_pData = (void**) new BYTE[nNewSize * sizeof(void*)];

		memset(m_pData, 0, nNewSize * sizeof(void*));  // zero fill

		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

		}

		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = min(1024, max(4, m_nSize / 8));
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT_(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
		ASSERT_(nNewMax <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
		void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(void*));

		// construct remaining elements
		ASSERT_(nNewSize > m_nSize);

		memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));


		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

int CPtrArray::Append(const CPtrArray& src)
{
//	ASSERT_VALID(this);
	ASSERT_(this != &src);   // cannot append to itself

	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(void*));

	return nOldSize;
}

void CPtrArray::Copy(const CPtrArray& src)
{
//	ASSERT_VALID(this);
	ASSERT_(this != &src);   // cannot append to itself

	SetSize(src.m_nSize);

	memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(void*));

}

void CPtrArray::FreeExtra()
{
//	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT_(m_nSize <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
		void** pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (void**) new BYTE[m_nSize * sizeof(void*)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(void*));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

void CPtrArray::SetAtGrow(int nIndex, void* newElement)
{
//	ASSERT_VALID(this);
	ASSERT_(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}

void CPtrArray::InsertAt(int nIndex, void* newElement, int nCount)
{
//	ASSERT_VALID(this);
	ASSERT_(nIndex >= 0);    // will expand to meet need
	ASSERT_(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(void*));

		// re-init slots we copied from

		memset(&m_pData[nIndex], 0, nCount * sizeof(void*));

	}

	// insert new value in the gap
	ASSERT_(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

void CPtrArray::RemoveAt(int nIndex, int nCount)
{
//	ASSERT_VALID(this);
	ASSERT_(nIndex >= 0);
	ASSERT_(nCount >= 0);
	ASSERT_(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);

	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(void*));
	m_nSize -= nCount;
}

void CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
//	ASSERT_VALID(this);
	ASSERT_(pNewArray != NULL);
//	ASSERT_KINDOF(CPtrArray, pNewArray);
//	ASSERT_VALID(pNewArray);
	ASSERT_(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}



/////////////////////////////////////////////////////////////////////////////
// Diagnostics
/*
#ifdef _DEBUG
void CPtrArray::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		for (int i = 0; i < m_nSize; i++)
			dc << "\n\t[" << i << "] = " << m_pData[i];
	}

	dc << "\n";
}

void CPtrArray::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT_(m_nSize == 0);
		ASSERT_(m_nMaxSize == 0);
	}
	else
	{
		ASSERT_(m_nSize >= 0);
		ASSERT_(m_nMaxSize >= 0);
		ASSERT_(m_nSize <= m_nMaxSize);
		ASSERT_(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(void*)));
	}
}
#endif //_DEBUG

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif


IMPLEMENT_DYNAMIC(CPtrArray, CObject)
*/
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\cmsr2c.h ===
//---------------------------------------------------------------------------
// CMSR2C.h : CVDCursorFromRowset header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef _CMSR2C_H_
#define _CMSR2C_H_

class CVDCursorFromRowset : public ICursorFromRowset,
						    public ICursorFromRowPosition
{
public:
	static HRESULT CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj);

protected:
	// construction/destruction
	CVDCursorFromRowset(LPUNKNOWN pUnkOuter);
	~CVDCursorFromRowset();

	// data members
	LPUNKNOWN m_pUnkOuter;	// pointer to controlling unknown

public:
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR *ppvObj);
	STDMETHOD_(ULONG,AddRef)(THIS);
	STDMETHOD_(ULONG,Release)(THIS);

	// ICursorFromRowset method
	STDMETHOD(GetCursor)(THIS_ IRowset *pRowset, ICursor **ppCursor, LCID lcid);

	// ICursorFromRowPosition method
	STDMETHOD(GetCursor)(THIS_ IRowPosition *pRowPosition, ICursor **ppCursor, LCID lcid);

  private:
    // the inner, private unknown implementation is for the aggregator
    // to control the lifetime of this object
    //
    class CPrivateUnknownObject : public IUnknown {
      public:
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // constructor is remarkably trivial
        //
        CPrivateUnknownObject() : m_cRef(0) {}

      private:
        CVDCursorFromRowset *m_pMainUnknown();
        ULONG m_cRef;
    } m_UnkPrivate;

    friend class CPrivateUnknownObject;
};

typedef CVDCursorFromRowset* PCVDCursorFromRowset;

#endif //_CMSR2C_H_

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\clssfcty.h ===
////////////////////////////////////////////////////////////////////
// File:	CSSCFcty.h
// Desc:	Definitions, classes, and prototypes for a DLL that
//			provides CSSFormat objects to any other object user.
////////////////////////////////////////////////////////////////////
#ifndef _CCLASSFACTORY_H_
#define _CCLASSFACTORY_H_

BOOL SetKeyAndValue(LPTSTR pszKey, LPTSTR pszSubkey, LPTSTR pszValue, LPTSTR pszThreadingModel);

class CClassFactory : public IClassFactory
{
	protected:
		// members
		ULONG m_cRef;

	public:
		// methods
		CClassFactory(void);
		~CClassFactory(void);
		STDMETHODIMP			QueryInterface(REFIID, LPVOID *);
		STDMETHODIMP_(ULONG)	AddRef(void);
		STDMETHODIMP_(ULONG)	Release(void);
		STDMETHODIMP			CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
		STDMETHODIMP			LockServer(BOOL);
};

typedef CClassFactory* PCClassFactory;

#endif _CCLASSFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\cmsr2c.cpp ===
//---------------------------------------------------------------------------
// CMSR2C.cpp : CVDCursorFromRowset implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "MSR2C.h"        
#include "CMSR2C.h"        
#include "Notifier.h"    
#include "RSColumn.h"     
#include "RSSource.h"         
#include "CursMain.h"

SZTHISFILE

//=--------------------------------------------------------------------------=
// CreateInstance - Same params as IClassFactory::CreateInstance
//
// Desc:	instantiates an CVDCursorFromRowset object, returning an interface
//			pointer.
// Parms:	riid -		ID identifying the interface the caller
//						desires	to have for the new object.
//			ppvObj -	pointer in which to store the desired
//						interface pointer for the new object.
// Return:	HRESULT -	NOERROR if successful, otherwise
//						E_NOINTERFACE if we cannot support the
//						requested interface.
//
HRESULT CVDCursorFromRowset::CreateInstance(LPUNKNOWN pUnkOuter, 
											REFIID riid, 
											LPVOID * ppvObj)
{
	if (!ppvObj)
		return E_INVALIDARG;

	*ppvObj=NULL;

    if (pUnkOuter) 
	{
		//If aggregating then they have to ask for IUnknown
        if (!DO_GUIDS_MATCH(riid, IID_IUnknown))
            return E_INVALIDARG;
    }
																	   
	//Create the object 
	CVDCursorFromRowset * pNewObj = new CVDCursorFromRowset(pUnkOuter);

	if (NULL==pNewObj)
		return E_OUTOFMEMORY;

	//Get interface from private unknown - needed for aggreagation support
	HRESULT hr=pNewObj->m_UnkPrivate.QueryInterface(riid, ppvObj);

	if FAILED(hr)
		delete pNewObj;

	return hr;
}

//=--------------------------------------------------------------------------=
// CVDCursorPosition - Constructor
//
CVDCursorFromRowset::CVDCursorFromRowset(LPUNKNOWN pUnkOuter)
{
	m_pUnkOuter	= pUnkOuter;

	VDUpdateObjectCount(1);  // update global object counter to prevent dll from being unloaded
}

//=--------------------------------------------------------------------------=
// CVDCursorPosition - Destructor
//
CVDCursorFromRowset::~CVDCursorFromRowset()
{
	VDUpdateObjectCount(-1);  // update global object counter to allow dll to be unloaded
}
///////////////////////////////////////////////////////////////////
// Name:	QueryInterface
// Desc:	allows a client to ask our object if we support a
//			particular method.
// Parms:	[in] riid - ID of method the client is querying for.
//			[out] ppv - pointer to the interface requested.
// Return:	HRESULT -	NOERROR if a pointer to the interface will
//						be returned, or E_NOINTERFACE if it cannot.
////////////////////////////////////////////////////////////////////
STDMETHODIMP CVDCursorFromRowset::QueryInterface(REFIID riid, void** ppv)
{
	if (m_pUnkOuter)
		return m_pUnkOuter->QueryInterface(riid, ppv);
	else
		return m_UnkPrivate.QueryInterface(riid, ppv);
}


////////////////////////////////////////////////////////////////////
// Name:	AddRef
// Desc:	increment the reference count on our object.
// Parms:	none
// Return:	current reference count.
////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CVDCursorFromRowset::AddRef(void)
{
	if (m_pUnkOuter)
		return m_pUnkOuter->AddRef();
	else
		return m_UnkPrivate.AddRef();
}

////////////////////////////////////////////////////////////////////
// Name:	Release
// Desc:	decrement the reference count on our object.  If the
//			count has gone to 0, destroy the object.
// Parms:	none
// Return:	current reference count.
////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CVDCursorFromRowset::Release(void)
{
	if (m_pUnkOuter)
		return m_pUnkOuter->Release();
	else
		return m_UnkPrivate.Release();
}

//=--------------------------------------------------------------------------=
// GetCursor - Get cursor from rowset
//=--------------------------------------------------------------------------=
STDMETHODIMP CVDCursorFromRowset::GetCursor(IRowset * pRowset,
										    ICursor ** ppCursor,
										    LCID lcid)
{
    return CVDCursorMain::Create(pRowset, ppCursor, lcid);
}

//=--------------------------------------------------------------------------=
// GetCursor - Get cursor from row position
//=--------------------------------------------------------------------------=
STDMETHODIMP CVDCursorFromRowset::GetCursor(IRowPosition * pRowPosition,
										    ICursor ** ppCursor,
										    LCID lcid)
{
    return CVDCursorMain::Create(pRowPosition, ppCursor, lcid);
}

//=--------------------------------------------------------------------------=
// CVDCursorFromRowset::CPrivateUnknownObject::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CVDCursorFromRowset *CVDCursorFromRowset::CPrivateUnknownObject::m_pMainUnknown
(
    void
)
{
    return (CVDCursorFromRowset *)((LPBYTE)this - offsetof(CVDCursorFromRowset, m_UnkPrivate));
}

//=--------------------------------------------------------------------------=
// CVDCursorFromRowset::CPrivateUnknownObject::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CVDCursorFromRowset::CPrivateUnknownObject::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
	if (!ppvObjOut)
		return E_INVALIDARG;

	*ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(riid, IID_IUnknown)) 
	{
		m_cRef++;
        *ppvObjOut = (IUnknown *)this;
	}
	else
    if (DO_GUIDS_MATCH(riid, IID_ICursorFromRowset)) 
	{
        m_pMainUnknown()->AddRef();
        *ppvObjOut = m_pMainUnknown();
	}
	else
    if (DO_GUIDS_MATCH(riid, IID_ICursorFromRowPosition)) 
	{
        m_pMainUnknown()->AddRef();
        *ppvObjOut = (ICursorFromRowPosition*)m_pMainUnknown();
	}

	return *ppvObjOut ? S_OK : E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// CVDCursorFromRowset::CPrivateUnknownObject::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CVDCursorFromRowset::CPrivateUnknownObject::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CVDCursorFromRowset::CPrivateUnknownObject::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CVDCursorFromRowset::CPrivateUnknownObject::Release
(
    void
)
{
    ULONG cRef = --m_cRef;

    if (!m_cRef)
        delete m_pMainUnknown();

    return cRef;
}

//=--------------------------------------------------------------------------=
// VDGetICursorFromIRowset
//=--------------------------------------------------------------------------=
// MSR2C entry point
//
HRESULT WINAPI VDGetICursorFromIRowset(IRowset * pRowset,
                                       ICursor ** ppCursor,
                                       LCID lcid)
{
	// call update object count to initialize g_pMalloc if not already initialized 
	VDUpdateObjectCount(1);

    HRESULT hr = CVDCursorMain::Create(pRowset, ppCursor, lcid);

	// maintain correct object count (object count is incremented in the constructor
	// of CVDCursorMain)
	VDUpdateObjectCount(-1);

	return hr;
}

// object construction/destruction counters (debug only)
//
#ifdef _DEBUG
int g_cVDNotifierCreated;                    // CVDNotifier
int g_cVDNotifierDestroyed;
int g_cVDNotifyDBEventsConnPtCreated;        // CVDNotifyDBEventsConnPt
int g_cVDNotifyDBEventsConnPtDestroyed;
int g_cVDNotifyDBEventsConnPtContCreated;    // CVDNotifyDBEventsConnPtCont
int g_cVDNotifyDBEventsConnPtContDestroyed;
int g_cVDEnumConnPointsCreated;              // CVDEnumConnPoints
int g_cVDEnumConnPointsDestroyed;
int g_cVDRowsetColumnCreated;                // CVDRowsetColumn
int g_cVDRowsetColumnDestroyed;
int g_cVDRowsetSourceCreated;                // CVDRowsetSource
int g_cVDRowsetSourceDestroyed;
int g_cVDCursorMainCreated;                  // CVDCursorMain
int g_cVDCursorMainDestroyed;
int g_cVDCursorPositionCreated;              // CVDCursorPosition
int g_cVDCursorPositionDestroyed;
int g_cVDCursorBaseCreated;                  // CVDCursorBase
int g_cVDCursorBaseDestroyed;
int g_cVDCursorCreated;                      // CVDCursor
int g_cVDCursorDestroyed;
int g_cVDMetadataCursorCreated;              // CVDMetadataCursor
int g_cVDMetadataCursorDestroyed;
int g_cVDEntryIDDataCreated;                 // CVDEntryIDData
int g_cVDEntryIDDataDestroyed;
int g_cVDStreamCreated;                      // CVDStream
int g_cVDStreamDestroyed;
int g_cVDColumnUpdateCreated;                // CVDColumnUpdate
int g_cVDColumnUpdateDestroyed;
#endif // _DEBUG

// dump oject counters
//
#ifdef _DEBUG
void DumpObjectCounters()
{
    CHAR str[256];
    OutputDebugString("MSR2C Objects-\n");
    wsprintf(str, "CVDNotifier:                 Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDNotifierCreated,   g_cVDNotifierDestroyed, 
        g_cVDNotifierCreated == g_cVDNotifierDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDNotifyDBEventsConnPt:     Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDNotifyDBEventsConnPtCreated,   g_cVDNotifyDBEventsConnPtDestroyed, 
        g_cVDNotifyDBEventsConnPtCreated == g_cVDNotifyDBEventsConnPtDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDNotifyDBEventsConnPtCont: Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDNotifyDBEventsConnPtContCreated,   g_cVDNotifyDBEventsConnPtContDestroyed, 
        g_cVDNotifyDBEventsConnPtContCreated == g_cVDNotifyDBEventsConnPtContDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDEnumConnPoints:           Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDEnumConnPointsCreated,   g_cVDEnumConnPointsDestroyed,
        g_cVDEnumConnPointsCreated == g_cVDEnumConnPointsDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDRowsetColumn:             Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDRowsetColumnCreated,   g_cVDRowsetColumnDestroyed, 
        g_cVDRowsetColumnCreated == g_cVDRowsetColumnDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDRowsetSource:             Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDRowsetSourceCreated,   g_cVDRowsetSourceDestroyed, 
        g_cVDRowsetSourceCreated == g_cVDRowsetSourceDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDCursorMain:               Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDCursorMainCreated,   g_cVDCursorMainDestroyed, 
        g_cVDCursorMainCreated == g_cVDCursorMainDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDCursorPosition:           Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDCursorPositionCreated,   g_cVDCursorPositionDestroyed, 
        g_cVDCursorPositionCreated == g_cVDCursorPositionDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDCursorBase:               Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDCursorBaseCreated,   g_cVDCursorBaseDestroyed, 
        g_cVDCursorBaseCreated == g_cVDCursorBaseDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDCursor:                   Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDCursorCreated,   g_cVDCursorDestroyed, 
        g_cVDCursorCreated == g_cVDCursorDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDMetadataCursor:           Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDMetadataCursorCreated,   g_cVDMetadataCursorDestroyed, 
        g_cVDMetadataCursorCreated == g_cVDMetadataCursorDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDEntryIDData:              Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDEntryIDDataCreated,   g_cVDEntryIDDataDestroyed, 
        g_cVDEntryIDDataCreated == g_cVDEntryIDDataDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDStream:                   Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDStreamCreated,   g_cVDStreamDestroyed, 
        g_cVDStreamCreated == g_cVDStreamDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDColumnUpdate:             Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDColumnUpdateCreated,   g_cVDColumnUpdateDestroyed, 
        g_cVDColumnUpdateCreated == g_cVDColumnUpdateDestroyed);
    OutputDebugString(str);
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\colupdat.cpp ===
//---------------------------------------------------------------------------
// ColumnUpdate.cpp : ColumnUpdate implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h" 
#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"         
#include "CursBase.h"
#include "ColUpdat.h"
#include "resource.h"         

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDColumnUpdate - Constructor
//
CVDColumnUpdate::CVDColumnUpdate()
{
    m_dwRefCount    = 1;
    m_pColumn       = NULL;
    m_cbVarDataLen  = 0;
    m_dwInfo        = 0;

    VariantInit((VARIANT*)&m_variant);

#ifdef _DEBUG
    g_cVDColumnUpdateCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDColumnUpdate - Destructor
//
CVDColumnUpdate::~CVDColumnUpdate()
{
    VariantClear((VARIANT*)&m_variant);

#ifdef _DEBUG
    g_cVDColumnUpdateDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// ExtractVariant - Extract variant
//=--------------------------------------------------------------------------=
// This function extracts a variant from update update data
//
// Parameters:
//    pBindParams       - [in]  a pointer to column update data
//    pVariant          - [out] a pointer a variant where to return data
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDColumnUpdate::ExtractVariant(CURSOR_DBBINDPARAMS * pBindParams, CURSOR_DBVARIANT * pVariant)
{
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)
    ASSERT_POINTER(pVariant, CURSOR_DBVARIANT)

    // make sure we have all necessary pointers
    if (!pBindParams || !pBindParams->pData || !pVariant)
        return E_INVALIDARG;

    CURSOR_DBVARIANT varTemp;

    // initialize all variants
    VariantInit((VARIANT*)&varTemp);
    VariantInit((VARIANT*)pVariant);

    // create temporary variant from supplied data
    if (pBindParams->dwBinding & CURSOR_DBBINDING_VARIANT)
    {
	    varTemp = *(CURSOR_DBVARIANT*)pBindParams->pData;
    }
    else // extract variant from default binding
    {
        BYTE * pData = (BYTE*)pBindParams->pData;
	    varTemp.vt = (VARTYPE)pBindParams->dwDataType;

        switch (pBindParams->dwDataType)
        {
            case CURSOR_DBTYPE_BYTES:
    	        varTemp.vt = CURSOR_DBTYPE_BLOB;
				varTemp.blob.cbSize = *(ULONG*)pData;
				varTemp.blob.pBlobData = (BYTE*)(pData + sizeof(ULONG));
                break;

            case CURSOR_DBTYPE_CHARS:
    	        varTemp.vt = CURSOR_DBTYPE_LPSTR;
        	    varTemp.pszVal = (CHAR*)pData;
                break;

            case CURSOR_DBTYPE_WCHARS:
    	        varTemp.vt = CURSOR_DBTYPE_LPWSTR;
        	    varTemp.pwszVal = (WCHAR*)pData;
                break;

            case CURSOR_DBTYPE_BLOB:
				varTemp.blob.cbSize = *(ULONG*)pData;
				varTemp.blob.pBlobData = *(LPBYTE*)(pData + sizeof(ULONG));
                break;

            case CURSOR_DBTYPE_LPSTR:
        	    varTemp.pszVal = *(LPSTR*)pData;
                break;

            case CURSOR_DBTYPE_LPWSTR:
        	    varTemp.pwszVal = *(LPWSTR*)pData;
                break;

            default:
                memcpy(&varTemp.cyVal, pBindParams->pData, CVDCursorBase::GetCursorTypeLength(varTemp.vt, 0));
                break;
        }
    }

    HRESULT hr = S_OK;

    // convert temporary variant to a desirable type and return
    switch (varTemp.vt)
    {
        case CURSOR_DBTYPE_LPSTR:
            pVariant->vt      = VT_BSTR;
            pVariant->bstrVal = BSTRFROMANSI(varTemp.pszVal);
            break;

        case CURSOR_DBTYPE_LPWSTR:
            pVariant->vt      = VT_BSTR;
            pVariant->bstrVal = SysAllocString(varTemp.pwszVal);
            break;

        default:
            hr = VariantCopy((VARIANT*)pVariant, (VARIANT*)&varTemp);
            break;
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// Create - Create column update object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new column update object
//
// Parameters:
//    pColumn           - [in]  rowset column pointer
//    pBindParams       - [in]  a pointer to column update data
//    ppColumnUpdate    - [out] a pointer in which to return pointer to 
//                              column update object
//    pResourceDLL      - [in]  a pointer which keeps track of resource DLL
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDColumnUpdate::Create(CVDRowsetColumn * pColumn, CURSOR_DBBINDPARAMS * pBindParams,
    CVDColumnUpdate ** ppColumnUpdate, CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pColumn, CVDRowsetColumn)
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)
    ASSERT_POINTER(ppColumnUpdate, CVDColumnUpdate)

    // make sure we have all necessary pointers
    if (!pColumn || !pBindParams || !pBindParams->pData || !ppColumnUpdate)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameter
    *ppColumnUpdate = NULL;

    // create new column update object
    CVDColumnUpdate * pColumnUpdate = new CVDColumnUpdate();

    if (!pColumnUpdate)
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursorUpdateARow, pResourceDLL);
        return E_OUTOFMEMORY;
    }

    CURSOR_DBVARIANT variant;

    // extract a variant from update data
    HRESULT hr = ExtractVariant(pBindParams, &variant);

    if (FAILED(hr))
    {
        // destroy object
        delete pColumnUpdate;

        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, pResourceDLL);
        return E_INVALIDARG;
    }

    // store update information
    pColumnUpdate->m_pColumn        = pColumn;
    pColumnUpdate->m_variant        = variant;
    pColumnUpdate->m_cbVarDataLen   = pBindParams->cbVarDataLen;
    pColumnUpdate->m_dwInfo         = pBindParams->dwInfo;
    pColumnUpdate->m_pResourceDLL   = pResourceDLL;

    // we're done
    *ppColumnUpdate = pColumnUpdate;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// AddRef
//
ULONG CVDColumnUpdate::AddRef(void)
{
    return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// Release
//
ULONG CVDColumnUpdate::Release(void)
{
    if (1 > --m_dwRefCount)
    {
        delete this;
        return 0;
    }

    return m_dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\cursbase.cpp ===
//---------------------------------------------------------------------------
// CursorBase.cpp : CursorBase implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"         
#include "CursBase.h"
#include "fastguid.h"
#include "resource.h"

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDCursorBase - Constructor
//
CVDCursorBase::CVDCursorBase()
{
    m_ulCursorBindings  = 0;
    m_pCursorBindings   = NULL;
    m_fNeedVarData      = FALSE;
    m_cbRowLength       = 0;
    m_cbVarRowLength    = 0;

#ifdef _DEBUG
    g_cVDCursorBaseCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDCursorBase - Destructor
//
CVDCursorBase::~CVDCursorBase()
{
    DestroyCursorBindings(&m_pCursorBindings, &m_ulCursorBindings);

#ifdef _DEBUG
    g_cVDCursorBaseDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// DestroyCursorBindings - Destroy cursor bindings and column identifer names
//
void CVDCursorBase::DestroyCursorBindings(CURSOR_DBCOLUMNBINDING** ppCursorBindings,
											ULONG* pcBindings)
{
    for (ULONG ulBind = 0; ulBind < *pcBindings; ulBind++)
    {
        CURSOR_DBCOLUMNID * pCursorColumnID = &(*ppCursorBindings)[ulBind].columnID;

        if (pCursorColumnID->dwKind == CURSOR_DBCOLKIND_GUID_NAME || pCursorColumnID->dwKind == CURSOR_DBCOLKIND_NAME)
            delete [] pCursorColumnID->lpdbsz;
    }

    delete [] *ppCursorBindings;

    *ppCursorBindings = NULL;
    *pcBindings = 0;
}

//=--------------------------------------------------------------------------=
// IsValidCursorType - Return TRUE if specified cursor data type is valid
//
BOOL CVDCursorBase::IsValidCursorType(DWORD dwCursorType)
{
    BOOL fValid = FALSE;

    switch (dwCursorType)
    {
        case CURSOR_DBTYPE_I2:
        case CURSOR_DBTYPE_I4:
        case CURSOR_DBTYPE_I8:
        case CURSOR_DBTYPE_R4:
        case CURSOR_DBTYPE_R8:
        case CURSOR_DBTYPE_CY:
        case CURSOR_DBTYPE_DATE:
        case CURSOR_DBTYPE_FILETIME:
        case CURSOR_DBTYPE_BOOL:
        case CURSOR_DBTYPE_LPSTR:
        case CURSOR_DBTYPE_LPWSTR:
        case CURSOR_DBTYPE_BLOB:
        case CURSOR_DBTYPE_UI2:
        case CURSOR_DBTYPE_UI4:
        case CURSOR_DBTYPE_UI8:
        case CURSOR_DBTYPE_COLUMNID:
        case CURSOR_DBTYPE_BYTES:
        case CURSOR_DBTYPE_CHARS:
        case CURSOR_DBTYPE_WCHARS:
        case CURSOR_DBTYPE_ANYVARIANT:
        case VT_VARIANT:
        case VT_BSTR:
        case VT_UI1:
        case VT_I1:
            fValid = TRUE;
            break;
    }

    return fValid;
}

//=--------------------------------------------------------------------------=
// DoesCursorTypeNeedVarData - Return TRUE if specified cursor type needs 
//                             variable length buffer
//
BOOL CVDCursorBase::DoesCursorTypeNeedVarData(DWORD dwCursorType)
{
    BOOL fNeedsVarData = FALSE;

    switch (dwCursorType)
    {
        case CURSOR_DBTYPE_BLOB:
        case CURSOR_DBTYPE_LPSTR:
        case CURSOR_DBTYPE_LPWSTR:
            fNeedsVarData = TRUE;
            break;
    }

    return fNeedsVarData;
}

//=--------------------------------------------------------------------------=
// GetCursorTypeLength - Get the size in bytes required by cursor data type
//
ULONG CVDCursorBase::GetCursorTypeLength(DWORD dwCursorType, ULONG cbMaxLen)
{
    ULONG cbRequired = 0;

    switch (dwCursorType)
    {
        case CURSOR_DBTYPE_I2:
        case CURSOR_DBTYPE_UI2:
            cbRequired = sizeof(short);
            break;

        case CURSOR_DBTYPE_I4:
        case CURSOR_DBTYPE_UI4:
            cbRequired = sizeof(long);
            break;

        case CURSOR_DBTYPE_I8:
        case CURSOR_DBTYPE_UI8:
            cbRequired = sizeof(LARGE_INTEGER);
            break;

        case CURSOR_DBTYPE_R4:
            cbRequired = sizeof(float);
            break;

        case CURSOR_DBTYPE_R8:
            cbRequired = sizeof(double);
            break;

        case CURSOR_DBTYPE_CY:
            cbRequired = sizeof(CY);
            break;

        case CURSOR_DBTYPE_DATE:
            cbRequired = sizeof(DATE);
            break;

        case CURSOR_DBTYPE_FILETIME:
            cbRequired = sizeof(FILETIME);
            break;

        case CURSOR_DBTYPE_BOOL:
            cbRequired = sizeof(VARIANT_BOOL);
            break;

        case CURSOR_DBTYPE_LPSTR:
            cbRequired = sizeof(LPSTR);
            break;

        case CURSOR_DBTYPE_LPWSTR:
            cbRequired = sizeof(LPWSTR);
            break;

        case CURSOR_DBTYPE_BLOB:
            cbRequired = sizeof(BLOB);
            break;

        case CURSOR_DBTYPE_COLUMNID:
            cbRequired = sizeof(CURSOR_DBCOLUMNID);
            break;

        case CURSOR_DBTYPE_BYTES:
            cbRequired = cbMaxLen;
            break;

        case CURSOR_DBTYPE_CHARS:
            cbRequired = cbMaxLen;
            break;

        case CURSOR_DBTYPE_WCHARS:
            cbRequired = cbMaxLen;
            break;

        case CURSOR_DBTYPE_ANYVARIANT:
            cbRequired = sizeof(CURSOR_DBVARIANT);
            break;

        case VT_VARIANT:
            cbRequired = sizeof(VARIANT);
            break;

        case VT_I1:
        case VT_UI1:
            cbRequired = sizeof(BYTE);
            break;
    }

    return cbRequired;
}

//=--------------------------------------------------------------------------=
// IsEqualCursorColumnID - Return TRUE if cursor column identifier are the same
//
BOOL CVDCursorBase::IsEqualCursorColumnID(const CURSOR_DBCOLUMNID& cursorColumnID1, const CURSOR_DBCOLUMNID& cursorColumnID2)
{
    // first check to see if column identifers are the same kind
    if (cursorColumnID1.dwKind != cursorColumnID1.dwKind)
        return FALSE;

    // then, check to see if they are equal
    BOOL bResult = TRUE;

    switch (cursorColumnID1.dwKind)
    {
	    case CURSOR_DBCOLKIND_GUID_NAME:
            if (!IsEqualGUID(cursorColumnID1.guid, cursorColumnID2.guid))
                bResult = FALSE;
            else if (lstrcmpW(cursorColumnID1.lpdbsz, cursorColumnID2.lpdbsz))
                bResult = FALSE;
            break;
            
	    case CURSOR_DBCOLKIND_GUID_NUMBER:
            if (!IsEqualGUID(cursorColumnID1.guid, cursorColumnID2.guid))
                bResult = FALSE;
            else if (cursorColumnID1.lNumber != cursorColumnID2.lNumber)
                bResult = FALSE;
            break;

        case CURSOR_DBCOLKIND_NAME:
            if (lstrcmpW(cursorColumnID1.lpdbsz, cursorColumnID2.lpdbsz))
                bResult = FALSE;
            break;
    }

    return bResult;
}

//=--------------------------------------------------------------------------=
// GetCursorColumnIDNameLength - Get the size in bytes of possible name attached
//                               to the specified cursor column identifier
//
ULONG CVDCursorBase::GetCursorColumnIDNameLength(const CURSOR_DBCOLUMNID& cursorColumnID)
{
    ULONG cbName = 0;

    if (cursorColumnID.dwKind == CURSOR_DBCOLKIND_GUID_NAME || cursorColumnID.dwKind == CURSOR_DBCOLKIND_NAME)
        cbName = (lstrlenW(cursorColumnID.lpdbsz) + 1) * sizeof(WCHAR);

    return cbName;
}

//=--------------------------------------------------------------------------=
// ValidateCursorBindings - Validate cursor column bindings
//=--------------------------------------------------------------------------=
// This function makes sure the specified column bindings are acceptable
//
// Parameters:
//    ulColumns             - [in]  the number available columns
//    pColumns              - [in]  an array of available columns
//    ulBindings            - [in]  the number of cursor column bindings
//    pCursorBindings       - [in]  an array of cursor column bindings
//    cbRequestedRowLength  - [in]  the requested number of bytes of inline 
//                                  memory in a single row of data
//    dwFlags               - [in]  a flag that specifies whether to replace the
//                                  existing column bindings or add to them
//    pcbNewRowLength       - [out] a pointer to memory in which to return
//                                  the new number of bytes of inline memory
//                                  in a single row of data for all bindings
//    pcbNewRowLength       - [out] a pointer to memory in which to return
//                                  the new number of bytes of out-of-line memory
//                                  in a single row of data for all bindings
//
// Output:
//    HRESULT - S_OK if successful
//              CURSOR_DB_E_BADBINDINFO bad binding information
//              CURSOR_DB_E_COLUMNUNAVAILABLE columnID is not available
//              CURSOR_DB_E_ROWTOOSHORT cbRequestedRowLength was less than the minumum (and not zero)
//
// Notes:
//    This function also computes and returns the new fixed and variable buffer row length required
//    by all the cursor bindings.
//
HRESULT CVDCursorBase::ValidateCursorBindings(ULONG ulColumns, 
											  CVDRowsetColumn * pColumns, 
											  ULONG ulBindings, 
											  CURSOR_DBCOLUMNBINDING * pCursorBindings, 
											  ULONG cbRequestedRowLength, 
											  DWORD dwFlags,
                                              ULONG * pcbNewRowLength,
                                              ULONG * pcbNewVarRowLength)
{
    DWORD cbMaxLength;
    DWORD dwCursorType;
    BOOL fColumnIDAvailable;

    CVDRowsetColumn * pColumn;

    ULONG cbRequiredRowLength = 0;
    ULONG cbRequiredVarRowLength = 0;

    CURSOR_DBCOLUMNBINDING * pBinding = pCursorBindings;

    // iterate through bindings
    for (ULONG ulBind = 0; ulBind < ulBindings; ulBind++)
    {
        // make sure column identifier is available
        fColumnIDAvailable = FALSE;

        pColumn = pColumns;

        for (ULONG ulCol = 0; ulCol < ulColumns && !fColumnIDAvailable; ulCol++)
        {
            if (IsEqualCursorColumnID(pBinding->columnID, pColumn->GetCursorColumnID()))
            {
                cbMaxLength = pColumn->GetMaxLength();
                dwCursorType = pColumn->GetCursorType();
                fColumnIDAvailable = TRUE;
            }

            pColumn++;
        }

        if (!fColumnIDAvailable)
        {
            VDSetErrorInfo(IDS_ERR_COLUMNUNAVAILABLE, IID_ICursor, m_pResourceDLL);
            return CURSOR_DB_E_COLUMNUNAVAILABLE;
        }

        // make sure caller supplied a maximum length if a default binding was specified 
        // for the cursor types CURSOR_DBTYPE_CHARS, CURSOR_DBTYPE_WCHARS or CURSOR_DBTYPE_BYTES
        if (pBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH && 
            pBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
        {
            if (pBinding->dwDataType == CURSOR_DBTYPE_CHARS || 
                pBinding->dwDataType == CURSOR_DBTYPE_WCHARS || 
                pBinding->dwDataType == CURSOR_DBTYPE_BYTES)
            {
                VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursor, m_pResourceDLL);
                return CURSOR_DB_E_BADBINDINFO;
            }
        }

        // check binding bit mask for possible values
        if (pBinding->dwBinding != CURSOR_DBBINDING_DEFAULT && 
            pBinding->dwBinding != CURSOR_DBBINDING_VARIANT &&
            pBinding->dwBinding != CURSOR_DBBINDING_ENTRYID && 
            pBinding->dwBinding != (CURSOR_DBBINDING_VARIANT | CURSOR_DBBINDING_ENTRYID))
        {
            VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursor, m_pResourceDLL);
            return CURSOR_DB_E_BADBINDINFO;
        }

        // check for valid cursor type
        if (!IsValidCursorType(pBinding->dwDataType))
        {
            VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursor, m_pResourceDLL);
            return CURSOR_DB_E_BADBINDINFO;
        }

        // if a variant binding was specified make sure the cursor type is not CURSOR_DBTYPE_CHARS, 
        // CURSOR_DBTYPE_WCHARS or CURSOR_DBTYPE_BYTES
        if (pBinding->dwBinding & CURSOR_DBBINDING_VARIANT)
        {
            if (pBinding->dwDataType == CURSOR_DBTYPE_CHARS || 
                pBinding->dwDataType == CURSOR_DBTYPE_WCHARS || 
                pBinding->dwDataType == CURSOR_DBTYPE_BYTES)
            {
                VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursor, m_pResourceDLL);
                return CURSOR_DB_E_BADBINDINFO;
            }
        }

        // if its not a variant binding make sure the cursor type is not CURSOR_DBTYPE_ANYVARIANT
        if (!(pBinding->dwBinding & CURSOR_DBBINDING_VARIANT) && pBinding->dwDataType == CURSOR_DBTYPE_ANYVARIANT)
        {
            VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursor, m_pResourceDLL);
            return CURSOR_DB_E_BADBINDINFO;
        }

        // calulate row length required by data field
        if (!(pBinding->dwBinding & CURSOR_DBBINDING_VARIANT))
            cbRequiredRowLength += GetCursorTypeLength(pBinding->dwDataType, pBinding->cbMaxLen);
        else
            cbRequiredRowLength += sizeof(CURSOR_DBVARIANT);

        // calulate row length required by variable data length field
        if (pBinding->obVarDataLen != CURSOR_DB_NOVALUE)
            cbRequiredRowLength += sizeof(ULONG);

        // calulate row length required by information field
        if (pBinding->obInfo != CURSOR_DB_NOVALUE)
            cbRequiredRowLength += sizeof(DWORD);

        // calulate variable row length required by data field
        if (!(pBinding->dwBinding & CURSOR_DBBINDING_VARIANT))
        {
            if (DoesCursorTypeNeedVarData(pBinding->dwDataType))
            {
                if (pBinding->cbMaxLen != CURSOR_DB_NOMAXLENGTH)
                    cbRequiredVarRowLength += pBinding->cbMaxLen;
                else
                    cbRequiredVarRowLength += cbMaxLength;
            }
        }
        else    // variant binding
        {
            if (DoesCursorTypeNeedVarData(pBinding->dwDataType))
            {
                if (pBinding->cbMaxLen != CURSOR_DB_NOMAXLENGTH)
                    cbRequiredVarRowLength += pBinding->cbMaxLen;
                else
                    cbRequiredVarRowLength += cbMaxLength;
            }

            if (pBinding->dwDataType == CURSOR_DBTYPE_COLUMNID)
                cbRequiredVarRowLength += sizeof(CURSOR_DBCOLUMNID);
        }

        pBinding++;
    }

    // if we're replacing bindings reset row lengths
    if (dwFlags == CURSOR_DBCOLUMNBINDOPTS_REPLACE)
    {
        *pcbNewRowLength    = 0;
        *pcbNewVarRowLength = 0;
    }
    else // if we're adding bindings set to current row lengths
    {
        *pcbNewRowLength    = m_cbRowLength;
        *pcbNewVarRowLength = m_cbVarRowLength;
    }

    // if no row length was requested, use required row length
    if (!cbRequestedRowLength)
    {
        *pcbNewRowLength += cbRequiredRowLength;
    }
    else    // make sure row length is large enough
    {
        if (cbRequestedRowLength < *pcbNewRowLength + cbRequiredRowLength)
        {
            VDSetErrorInfo(IDS_ERR_ROWTOOSHORT, IID_ICursor, m_pResourceDLL);
            return CURSOR_DB_E_ROWTOOSHORT;
        }

        // use requested row length
        *pcbNewRowLength += cbRequestedRowLength;
    }

    // calculate required variable row length
    *pcbNewVarRowLength += cbRequiredVarRowLength;

    return S_OK;
}


//=--------------------------------------------------------------------------=
// DoCursorBindingsNeedVarData - Return TRUE if current cursor column bindings
//                               need variable length buffer
//
BOOL CVDCursorBase::DoCursorBindingsNeedVarData()
{
    BOOL fNeedVarData = FALSE;

    CURSOR_DBCOLUMNBINDING * pCursorBinding = m_pCursorBindings;

    for (ULONG ulBind = 0; ulBind < m_ulCursorBindings && !fNeedVarData; ulBind++)
    {
        if (DoesCursorTypeNeedVarData(pCursorBinding->dwDataType))
            fNeedVarData = TRUE;

        pCursorBinding++;
    }

    return fNeedVarData;
}

//=--------------------------------------------------------------------------=
// Validate fetch params
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pFetchParams   - [in] ptr to the CURSOR_DBFETCHROWS structure
//    riid		     - [in] guid of calling interface (used for error generation)
//
// Output:
//    HRESULT - S_OK if pFetchParams valid
//              CURSOR_DB_E_BADFETCHINFO if pFetchParams invalid
//
//
HRESULT CVDCursorBase::ValidateFetchParams(CURSOR_DBFETCHROWS *pFetchParams, REFIID riid)
{

    if (!pFetchParams)
	{
        VDSetErrorInfo(IDS_ERR_INVALIDARG, riid, m_pResourceDLL);
        return E_INVALIDARG;
	}

    // init out parameter
    pFetchParams->cRowsReturned = 0;

    // return if caller didn't ask for any rows
    if (!pFetchParams->cRowsRequested)
        return S_OK;

	HRESULT hr = S_OK;

    // make sure fetch flags has only valid values
    if (pFetchParams->dwFlags != CURSOR_DBROWFETCH_DEFAULT &&
        pFetchParams->dwFlags != CURSOR_DBROWFETCH_CALLEEALLOCATES &&
        pFetchParams->dwFlags != CURSOR_DBROWFETCH_FORCEREFRESH &&
        pFetchParams->dwFlags != (CURSOR_DBROWFETCH_CALLEEALLOCATES | CURSOR_DBROWFETCH_FORCEREFRESH))
        hr =  CURSOR_DB_E_BADFETCHINFO;

    // if memory was caller allocated, make sure caller supplied data pointer 
    if (!(pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES) && !pFetchParams->pData)
        hr =  CURSOR_DB_E_BADFETCHINFO;

    // if memory was caller allocated, make sure caller supplied var-data pointer and size if needed
    if (!(pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES) && m_fNeedVarData &&
        (!pFetchParams->pVarData || !pFetchParams->cbVarData))
        hr =  CURSOR_DB_E_BADFETCHINFO;

	if (FAILED(hr))
        VDSetErrorInfo(IDS_ERR_BADFETCHINFO, riid, m_pResourceDLL);

	return hr;

}

//=--------------------------------------------------------------------------=
// IUnknown methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDCursorBase::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

    *ppvObjOut = NULL;

    switch (riid.Data1) 
    {
        QI_INTERFACE_SUPPORTED((ICursor*)this, IUnknown);
        QI_INTERFACE_SUPPORTED(this, ICursor);
        QI_INTERFACE_SUPPORTED(this, ICursorMove);
        QI_INTERFACE_SUPPORTED_IF(this, ICursorScroll, SupportsScroll());
		QI_INTERFACE_SUPPORTED(this, ISupportErrorInfo);
    }                   

    if (NULL == *ppvObjOut)
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef (Notifier and MetadataCursor maintain reference count)
//
ULONG CVDCursorBase::AddRef(void)
{
   return (ULONG)E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// IUnknown Release (Notifier and MetadataCursor maintain reference count)
//
ULONG CVDCursorBase::Release(void)
{
   return (ULONG)E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// ICursor methods implemented
//=--------------------------------------------------------------------------=
// ICursor SetBindings
//=--------------------------------------------------------------------------=
// Replaces the existing column bindings or adds new column bindings to the 
// existing ones
//
// Parameters:
//    cCol              - [in] the number of columns to bind
//    rgBoundColumns    - [in] an array of column bindings, one for each 
//                             column for which data is to be returned
//    cbRowLength       - [in] the number of bytes of inline memory in a 
//                             single row of data
//    dwFlags           - [in] a flag that specifies whether to replace the
//                             existing column bindings or add to them
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory
//
// Notes:
//    Parameter validation is performed by derived classes
//
HRESULT CVDCursorBase::SetBindings(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags)
{
    // reset flag
    m_fNeedVarData = FALSE;

    // if we should replace, then first destroy existing bindings
    if (dwFlags == CURSOR_DBCOLUMNBINDOPTS_REPLACE)
	    DestroyCursorBindings(&m_pCursorBindings, &m_ulCursorBindings);
    
    // if no new bindings are supplied, we're done
    if (!cCol)
        return S_OK;

    // create new storage
    CURSOR_DBCOLUMNBINDING * pCursorBindings = new CURSOR_DBCOLUMNBINDING[m_ulCursorBindings + cCol];

    if (!pCursorBindings)
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
        return E_OUTOFMEMORY;
    }

    // if we have exsiting bindings, then copy them over
    if (m_pCursorBindings)
        memcpy(pCursorBindings, m_pCursorBindings, m_ulCursorBindings * sizeof(CURSOR_DBCOLUMNBINDING));

    // then append new bindings directly,
    memcpy(pCursorBindings + m_ulCursorBindings, rgBoundColumns, cCol * sizeof(CURSOR_DBCOLUMNBINDING));

    // and adjust possible cursor column identifier names in new bindings
    for (ULONG ulBind = m_ulCursorBindings; ulBind < m_ulCursorBindings + cCol; ulBind++)
    {
        CURSOR_DBCOLUMNID * pCursorColumnID = &pCursorBindings[ulBind].columnID; 

        if (pCursorColumnID->dwKind == CURSOR_DBCOLKIND_GUID_NAME || pCursorColumnID->dwKind == CURSOR_DBCOLKIND_NAME)
        {
            const int nLength = lstrlenW(pCursorColumnID->lpdbsz);

            WCHAR * pwszName = new WCHAR[nLength + 1];
			if (!pwszName)
			{
				DestroyCursorBindings(&pCursorBindings, &ulBind);
				delete [] m_pCursorBindings;
				m_ulCursorBindings	= 0;
				VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
				return E_OUTOFMEMORY;
			}
			memcpy(pwszName, pCursorColumnID->lpdbsz, (nLength + 1) * sizeof(WCHAR));
			pCursorColumnID->lpdbsz = pwszName;
        }
    }

    m_ulCursorBindings += cCol;

    // delete previous storage
	// any existing bindings will have been copied over into 
	delete [] m_pCursorBindings;

    m_pCursorBindings = pCursorBindings;

    // determine if new bindings need variable length buffer
    m_fNeedVarData = DoCursorBindingsNeedVarData();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursor GetBindings
//=--------------------------------------------------------------------------=
// Returns the current column bindings
//
// Parameters:
//    pcCol             - [out] a pointer to memory in which to return the 
//                              number of bound columns
//    prgBoundColumns   - [out] a pointer to memory in which to return a 
//                              pointer to an array containing the current
//                              column bindings (callee allocated)
//    pcbRowLength      - [out] a pointer to memory in which to return the
//                              number of bytes of inline memory in a single 
//                              row
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory
//
// Notes: 
//
HRESULT CVDCursorBase::GetBindings(ULONG *pcCol, 
								   CURSOR_DBCOLUMNBINDING *prgBoundColumns[], 
								   ULONG *pcbRowLength)
{
    ASSERT_NULL_OR_POINTER(pcCol, ULONG)
    ASSERT_NULL_OR_POINTER(prgBoundColumns, CURSOR_DBCOLUMNBINDING)
    ASSERT_NULL_OR_POINTER(pcbRowLength, ULONG)

    // init out parameters
    if (pcCol)
        *pcCol = 0;

    if (prgBoundColumns)
        *prgBoundColumns = NULL;

    if (pcbRowLength)
        *pcbRowLength = 0;

    // return column bindings
    if (prgBoundColumns && m_ulCursorBindings)    
    {
        // calculate size of bindings
        ULONG cbBindings = m_ulCursorBindings * sizeof(CURSOR_DBCOLUMNBINDING);

        // calculate extra space needed for names in column identifers
        ULONG cbNames = 0;

        for (ULONG ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
            cbNames += GetCursorColumnIDNameLength(m_pCursorBindings[ulBind].columnID);

        // allocate memory for bindings and names
        CURSOR_DBCOLUMNBINDING * pCursorBindings = (CURSOR_DBCOLUMNBINDING*)g_pMalloc->Alloc(cbBindings + cbNames);

        if (!pCursorBindings)
        {
            VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
            return E_OUTOFMEMORY;
        }

        // copy bindings directly
        memcpy(pCursorBindings, m_pCursorBindings, cbBindings);

        // adjust column identifier names
        WCHAR * pwszName = (WCHAR*)(pCursorBindings + m_ulCursorBindings);

        for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            CURSOR_DBCOLUMNID * pCursorColumnID = &pCursorBindings[ulBind].columnID;

            if (pCursorColumnID->dwKind == CURSOR_DBCOLKIND_GUID_NAME || pCursorColumnID->dwKind == CURSOR_DBCOLKIND_NAME)
            {
                const int nLength = lstrlenW(pCursorColumnID->lpdbsz);

                memcpy(pwszName, pCursorColumnID->lpdbsz, (nLength + 1) * sizeof(WCHAR)); 
                pCursorColumnID->lpdbsz = pwszName;
                pwszName += nLength + 1;
            }
        }

        *prgBoundColumns = pCursorBindings;

		// sanity check
		ASSERT_((BYTE*)pwszName == ((BYTE*)pCursorBindings) + cbBindings + cbNames);
    
	}
    
    // return bound column count
    if (pcCol)  
        *pcCol = m_ulCursorBindings;

    // return row length
    if (pcbRowLength)
        *pcbRowLength = m_cbRowLength;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\cursbase.h ===
//---------------------------------------------------------------------------
// CursorBase.h : CVDCursorBase header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDCURSORBASE__
#define __CVDCURSORBASE__


class CVDCursorBase : public ICursorScroll,
       				  public ISupportErrorInfo
{
protected:
// Construction/Destruction
	CVDCursorBase();
	virtual ~CVDCursorBase();

    void DestroyCursorBindings(CURSOR_DBCOLUMNBINDING** ppCursorBindings,
											ULONG* pcBindings);


protected:
// Data members
    ULONG                       m_ulCursorBindings;     // number of cursor column bindings
    CURSOR_DBCOLUMNBINDING *    m_pCursorBindings;      // pointer to an array of cursor column bindings
    VARIANT_BOOL                m_fNeedVarData;         // do the cursor column bindings required variable length buffer?
    ULONG                       m_cbRowLength;          // fixed length buffer single row length
    ULONG                       m_cbVarRowLength;       // variable length buffer single row length

    CVDResourceDLL *            m_pResourceDLL;         // pointer which keeps track of resource DLL

public:
// Helper functions
    static BOOL IsValidCursorType(DWORD dwCursorType);
    static BOOL DoesCursorTypeNeedVarData(DWORD dwCursorType);
    static ULONG GetCursorTypeLength(DWORD dwCursorType, ULONG cbMaxLen);
    static BOOL IsEqualCursorColumnID(const CURSOR_DBCOLUMNID& cursorColumnID1, const CURSOR_DBCOLUMNID& cursorColumnID2);
    static ULONG GetCursorColumnIDNameLength(const CURSOR_DBCOLUMNID& cursorColumnID);

    HRESULT ValidateCursorBindings(ULONG ulColumns, CVDRowsetColumn * pColumns, 
        ULONG ulBindings, CURSOR_DBCOLUMNBINDING * pCursorBindings, ULONG cbRequestedRowLength, DWORD dwFlags,
        ULONG * pcbNewRowLength, ULONG * pcbNewVarRowLength);

	HRESULT ValidateFetchParams(CURSOR_DBFETCHROWS *pFetchParams, REFIID riid);

    BOOL DoCursorBindingsNeedVarData();

// Other
    virtual BOOL SupportsScroll() {return TRUE;}

	//=--------------------------------------------------------------------------=
    // IUnknown methods implemented
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
    // ICursor methods implemented
    //
    STDMETHOD(SetBindings)(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags);
    STDMETHOD(GetBindings)(ULONG *pcCol, CURSOR_DBCOLUMNBINDING *prgBoundColumns[], ULONG *pcbRowLength);

    //=--------------------------------------------------------------------------=
    // ISupportErrorInfo methods    
	//
	STDMETHOD(InterfaceSupportsErrorInfo)(THIS_ REFIID riid);
};


#endif //__CVDCURSORBASE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\crerror.cpp ===
//---------------------------------------------------------------------------
// CursorErrorInfo.cpp : CVDCursor ISupportErrorInfo implementation file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"         
#include "CursBase.h"         
#include "fastguid.h"         

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// ISupportErrorInfo Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ISupportErrorInfo InterfaceSupportsErrorInfo
//
HRESULT CVDCursorBase::InterfaceSupportsErrorInfo(REFIID riid)
{
	BOOL fSupportsErrorInfo	= FALSE;

	switch (riid.Data1) 
	{
		SUPPORTS_ERROR_INFO(ICursor);
		SUPPORTS_ERROR_INFO(ICursorMove);
		SUPPORTS_ERROR_INFO(ICursorScroll);
		SUPPORTS_ERROR_INFO(ICursorUpdateARow);
		SUPPORTS_ERROR_INFO(ICursorFind);
		SUPPORTS_ERROR_INFO(IEntryID);
	}						

    return fSupportsErrorInfo ? S_OK : S_FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\common.inc ===
SOURCES_USED=$(ROOT)\common.inc

!if $(ALPHA)
MSC_WARNING_LEVEL = /W3 /WX
!endif

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL = /W3 /WX
!endif

C_DEFINES = \
    /D_WCTYPE_INLINE_DEFINED \
!if $(FREEBUILD)
    /D_ATL_MIN_CRT \
!else
    /D_DEBUG \
!endif
    /DSTRICT

!if !$(FREEBUILD)
USE_RTTI=1
MSC_OPTIMIZATION=/Od
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /zm /zff /zgf
LINKER_NOICF=1      # ICF is s-l-o-w
!else
MSC_OPTIMIZATION=/Oxs
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /ox /oe /zm /zff /zgf
!endif

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob1 /Oi

NOT_LEAN_AND_MEAN=1

USE_NOLIBS=1
UMTYPE=windows

# Use NT 4.0/Win95 functionality only

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00

!ifdef WIN16

# Win 16 Specific Environment.
!ifndef __MSVC_ENV__
__WATCOM_ENV__=1
!endif
C_DEFINES = $(C_DEFINES) /DINC_WIN16X /DWRAP_RECTL /DFULL_DEBUG

FULL_DEBUG=1

!else

!if !$(FREEBUILD)
DEBUG_CRTS=1
!endif

# Win 32 Environment.
C_DEFINES = $(C_DEFINES) /D_MT

!endif

!if $(386)
NO_NTDLL=1
!else
# USE_NTDLL=1
!endif

CHECKED_ALT_DIR=1

#
# The IE build lab sets this flag for debug builds so we get full debug
#   on IE drops. The NT build lab wants debug lite builds and therefore
#   does not set it.
#
!ifdef MSHTML_FULL_DEBUG
!message MSHTML_FULL_DEBUG was defined. Building full debug.
FULL_DEBUG=1
!endif

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) /DPRODUCT_PROF
!endif

!ifdef USE_PERFTEST
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFTEST
!endif

!ifdef USE_PERFBUG
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFBUG
!endif

!ifdef USE_PERFTAGS
!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) /DPERFTAGS
!message PERFTAGS was defined
!endif
!endif

!ifdef USE_MSHTML_INCREMENTAL_LINKING
!if !$(FREEBUILD) && $(USE_MSHTML_INCREMENTAL_LINKING)
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
NTDBGFILES=1
!undef USE_MAPSYM
USE_INCREMENTAL_LINKING=1
LINKER_FLAGS=$(LINKER_FLAGS) -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
TARGETPDB=TDC
!message USE_MSHTML_INCREMENTAL_LINKING was defined
!message $(TARGETPDB) was defined
!endif
!else
# Compatibility with existing usage before use_mshtml_incremental_linking
!ifdef USE_INCREMENTAL_LINKING
!message DOING IT THE OLD WAY
LINKER_FLAGS = -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
!else
USE_MAPSYM=1
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\cursmain.cpp ===
//---------------------------------------------------------------------------
// CursorMain.cpp : CursorMain implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "MSR2C.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"
#include "ColUpdat.h"
#include "CursPos.h"
#include "CursBase.h"
#include "enumcnpt.h"
#include "Cursor.h"
#include "Bookmark.h"
#include "fastguid.h"

SZTHISFILE

#include "ARRAY_P.inl"

// static data
DWORD               CVDCursorMain::s_dwMetaRefCount   = 0;
ULONG               CVDCursorMain::s_ulMetaColumns    = 0;
CVDRowsetColumn *   CVDCursorMain::s_rgMetaColumns    = NULL;


//=--------------------------------------------------------------------------=
// CVDCursorMain - Constructor
//
CVDCursorMain::CVDCursorMain(LCID lcid) : m_resourceDLL(lcid)
{
    m_fWeAddedMetaRef		    = FALSE;
	m_fPassivated			    = FALSE;
	m_fColumnsRowsetSupported   = FALSE;
    m_fInternalInsertRow        = FALSE;
    m_fInternalDeleteRows       = FALSE;
    m_fInternalSetData          = FALSE;

	m_fLiteralBookmarks		    = FALSE;			
	m_fOrderedBookmarks		    = FALSE;
    m_fBookmarkSkipped          = FALSE;			

	m_fConnected			    = FALSE;
	m_dwAdviseCookie		    = 0;
    m_ulColumns				    = 0;
    m_rgColumns				    = NULL;

    m_cbMaxBookmark			    = 0;

	VDUpdateObjectCount(1);  // update object count to prevent dll from being unloaded

#ifdef _DEBUG
    g_cVDCursorMainCreated++;
#endif
}

//=--------------------------------------------------------------------------=
// ~CVDCursorMain - Destructor
//
CVDCursorMain::~CVDCursorMain()
{
	Passivate();

	VDUpdateObjectCount(-1);  // update object count to allow dll to be unloaded

#ifdef _DEBUG
    g_cVDCursorMainDestroyed++;
#endif
}

//=--------------------------------------------------------------------------=
// Pasivate when external ref count gets to zero
//
void CVDCursorMain::Passivate()
{

	if (m_fPassivated)
		return;

	m_fPassivated			= TRUE;

    if (IsRowsetValid())
	{
		if (m_hAccessorBM)
			GetAccessor()->ReleaseAccessor(m_hAccessorBM, NULL);

		if (m_fConnected)
			DisconnectIRowsetNotify();
	}

    DestroyColumns();
    DestroyMetaColumns();

}

//=--------------------------------------------------------------------------=
// Create - Create cursor provider from row position or rowset
//=--------------------------------------------------------------------------=
// This function creates and initializes a new cursor main object
//
// Parameters:
//    pRowPosition  - [in]  original IRowPosition provider (may be NULL)
//    pRowset       - [in]  original IRowset provider
//    ppCursor      - [out] resulting ICursor provider
//    lcid          - [in]  locale identifier
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              VD_E_CANNOTCONNECTIROWSETNOTIFY unable to connect IRowsetNotify
//
// Notes:
//
HRESULT CVDCursorMain::Create(IRowPosition* pRowPosition, IRowset * pRowset, ICursor ** ppCursor, LCID lcid)
{
    ASSERT_POINTER(pRowset, IRowset)
    ASSERT_POINTER(ppCursor, ICursor*)

    if (!pRowset || !ppCursor)
        return E_INVALIDARG;

    // create new cursor main object
    CVDCursorMain * pCursorMain = new CVDCursorMain(lcid);

    if (!pCursorMain)
        return E_OUTOFMEMORY;

    // initialize rowset source
    HRESULT hr = pCursorMain->Initialize(pRowset);

    if (FAILED(hr))
    {
        pCursorMain->Release();
        return hr;
    }

    // create array of column objects
    hr = pCursorMain->CreateColumns();

    if (FAILED(hr))
    {
        pCursorMain->Release();
        return hr;
    }

    // create array of meta-column objects
    hr = pCursorMain->CreateMetaColumns();

    if (FAILED(hr))
    {
        pCursorMain->Release();
        return hr;
    }

	// create bookmark accessor
    DBBINDING rgBindings[1];
	DBBINDSTATUS rgStatus[1];

	memset(rgBindings, 0, sizeof(DBBINDING));

	rgBindings[0].iOrdinal      = 0;
    rgBindings[0].obValue       = 4;
    rgBindings[0].obLength      = 0;
    rgBindings[0].dwPart        = DBPART_VALUE | DBPART_LENGTH;
    rgBindings[0].dwMemOwner    = DBMEMOWNER_CLIENTOWNED;
    rgBindings[0].cbMaxLen      = pCursorMain->GetMaxBookmarkLen();
    rgBindings[0].wType         = DBTYPE_BYTES;

	hr = pCursorMain->GetAccessor()->CreateAccessor(DBACCESSOR_ROWDATA,
													1,
													rgBindings,
													0,
													&pCursorMain->m_hAccessorBM,
													rgStatus);
    if (FAILED(hr))
    {
        pCursorMain->Release();
        return VD_E_CANNOTCREATEBOOKMARKACCESSOR;
    }

    // create new cursor position object
    CVDCursorPosition * pCursorPosition;

    hr = CVDCursorPosition::Create(pRowPosition, pCursorMain, &pCursorPosition, &pCursorMain->m_resourceDLL);

    if (FAILED(hr))
    {
        pCursorMain->Release();
        return hr;
    }

    // create new cursor object
    CVDCursor * pCursor;

    hr = CVDCursor::Create(pCursorPosition, &pCursor, &pCursorMain->m_resourceDLL);

    if (FAILED(hr))
    {
        ((CVDNotifier*)pCursorPosition)->Release();
        pCursorMain->Release();
        return hr;
    }

    // connect IRowsetNotify
	hr = pCursorMain->ConnectIRowsetNotify();

	if (SUCCEEDED(hr))
		pCursorMain->m_fConnected = TRUE;

    // check rowset properties
    BOOL fCanHoldRows = TRUE;

	IRowsetInfo * pRowsetInfo = pCursorMain->GetRowsetInfo();

	if (pRowsetInfo)
	{
		DBPROPID propids[] = { DBPROP_LITERALBOOKMARKS,
							   DBPROP_ORDEREDBOOKMARKS,
                               DBPROP_BOOKMARKSKIPPED,
                               DBPROP_CANHOLDROWS };

		const DBPROPIDSET propsetids[] = { propids, 4, {0,0,0,0} };
		memcpy((void*)&propsetids[0].guidPropertySet, &DBPROPSET_ROWSET, sizeof(DBPROPSET_ROWSET));

		ULONG cPropertySets = 0;
		DBPROPSET * propset = NULL;
		hr = pRowsetInfo->GetProperties(1, propsetids, &cPropertySets, &propset);

		if (SUCCEEDED(hr) && propset && propset->rgProperties)
		{
			if (DBPROPSTATUS_OK == propset->rgProperties[0].dwStatus)
				pCursorMain->m_fLiteralBookmarks = V_BOOL(&propset->rgProperties[0].vValue);

			if (DBPROPSTATUS_OK == propset->rgProperties[1].dwStatus)
				pCursorMain->m_fOrderedBookmarks = V_BOOL(&propset->rgProperties[1].vValue);

			if (DBPROPSTATUS_OK == propset->rgProperties[2].dwStatus)
				pCursorMain->m_fBookmarkSkipped = V_BOOL(&propset->rgProperties[2].vValue);

			if (DBPROPSTATUS_OK == propset->rgProperties[3].dwStatus)
				fCanHoldRows = V_BOOL(&propset->rgProperties[3].vValue);
		}

		if (propset)
		{
			if (propset->rgProperties)
				g_pMalloc->Free(propset->rgProperties);

			g_pMalloc->Free(propset);
		}
	}

    // release our references
    pCursorMain->Release();
    ((CVDNotifier*)pCursorPosition)->Release();

    // check for required property
    if (!fCanHoldRows)
    {
        pCursor->Release();
        return VD_E_REQUIREDPROPERTYNOTSUPPORTED;
    }

    // we're done
    *ppCursor = pCursor;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// Create - Create cursor provider from rowset
//=--------------------------------------------------------------------------=
// This function creates and initializes a new cursor main object
//
// Parameters:
//    pRowset       - [in]  original IRowset provider
//    ppCursor      - [out] resulting ICursor provider
//    lcid          - [in]  locale identifier
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              VD_E_CANNOTCONNECTIROWSETNOTIFY unable to connect IRowsetNotify
//
// Notes:
//
HRESULT CVDCursorMain::Create(IRowset * pRowset, ICursor ** ppCursor, LCID lcid)
{
    ASSERT_POINTER(pRowset, IRowset)
    ASSERT_POINTER(ppCursor, ICursor*)

    if (!pRowset || !ppCursor)
        return E_INVALIDARG;

	// create cursor as done before row position
	return Create(NULL, pRowset, ppCursor, lcid);
}

//=--------------------------------------------------------------------------=
// Create - Create cursor provider from row position
//=--------------------------------------------------------------------------=
// This function creates and initializes a new cursor main object
//
// Parameters:
//    pRowPosition  - [in]  original IRowPosition provider
//    ppCursor      - [out] resulting ICursor provider
//    lcid          - [in]  locale identifier
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              VD_E_CANNOTCONNECTIROWSETNOTIFY unable to connect IRowPositionNotify
//				VD_E_CANNOTGETROWSETINTERFACE unable to get IRowset
//
// Notes:
//
HRESULT CVDCursorMain::Create(IRowPosition * pRowPosition, ICursor ** ppCursor, LCID lcid)
{
    ASSERT_POINTER(pRowPosition, IRowPosition)
    ASSERT_POINTER(ppCursor, ICursor*)

    if (!pRowPosition || !ppCursor)
        return E_INVALIDARG;

	IRowset * pRowset;

	// get IRowset from IRowPosition
	HRESULT hr = pRowPosition->GetRowset(IID_IRowset, (IUnknown**)&pRowset);

	if (FAILED(hr))
		return VD_E_CANNOTGETROWSETINTERFACE;

	// create cursor with new row position parameter
	hr = Create(pRowPosition, pRowset, ppCursor, lcid);

	pRowset->Release();

    // we're done
	return hr;
}

typedef struct tagVDMETADATA_METADATA
	{
        const CURSOR_DBCOLUMNID * pCursorColumnID;
		ULONG	cbMaxLength;
		CHAR *	pszName;
		DWORD	dwCursorType;
	} VDMETADATA_METADATA;

#define MAX_METADATA_COLUMNS 21

static const VDMETADATA_METADATA g_MetaDataMetaData[MAX_METADATA_COLUMNS] =
{
    // Bookmark column
	{ &CURSOR_COLUMN_BMKTEMPORARY,		sizeof(ULONG),				NULL,					CURSOR_DBTYPE_BLOB },
    // data columns
	{ &CURSOR_COLUMN_COLUMNID,			sizeof(CURSOR_DBCOLUMNID),	"COLUMN_COLUMNID",		CURSOR_DBTYPE_COLUMNID },
	{ &CURSOR_COLUMN_DATACOLUMN,		sizeof(VARIANT_BOOL),		"COLUMN_DATACOLUMN",	CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_ENTRYIDMAXLENGTH,	sizeof(ULONG),				"COLUMN_ENTRYIDMAXLENGTH",CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_FIXED,				sizeof(VARIANT_BOOL),		"COLUMN_FIXED",			CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_MAXLENGTH,			sizeof(ULONG),				"COLUMN_MAXLENGTH",		CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_NAME,				256,						"COLUMN_NAME",			VT_LPWSTR },
	{ &CURSOR_COLUMN_NULLABLE,			sizeof(VARIANT_BOOL),		"COLUMN_NULLABLE",		CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_NUMBER,			sizeof(ULONG),				"COLUMN_NUMBER",		CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_SCALE,				sizeof(ULONG),				"COLUMN_SCALE",			CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_TYPE,				sizeof(ULONG),				"COLUMN_TYPE",			CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_UPDATABLE,			sizeof(ULONG),				"COLUMN_UPDATABLE",		CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_BINDTYPE,			sizeof(ULONG),				"COLUMN_BINDTYPE",		CURSOR_DBTYPE_I4 },
    // optional metadata columns - supported with IColumnsRowset only)
	{ &CURSOR_COLUMN_AUTOINCREMENT,		sizeof(VARIANT_BOOL),		"COLUMN_AUTOINCREMENT",	CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_BASECOLUMNNAME,	256,						"COLUMN_BASECOLUMNNAME",VT_LPWSTR },
	{ &CURSOR_COLUMN_BASENAME,			256,						"COLUMN_BASENAME",		VT_LPWSTR },
	{ &CURSOR_COLUMN_COLLATINGORDER,	sizeof(LCID),				"COLUMN_COLLATINGORDER",CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_DEFAULTVALUE,		256,						"COLUMN_DEFAULTVALUE",	VT_LPWSTR },
	{ &CURSOR_COLUMN_HASDEFAULT,		sizeof(VARIANT_BOOL),		"COLUMN_HASDEFAULT",	CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_CASESENSITIVE,		sizeof(VARIANT_BOOL),		"COLUMN_CASESENSITIVE",	CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_UNIQUE,			sizeof(VARIANT_BOOL),		"COLUMN_UNIQUE",		CURSOR_DBTYPE_BOOL },
};

//=--------------------------------------------------------------------------=
// CreateMetaColumns - Create array of meta-column objects
//
HRESULT CVDCursorMain::CreateMetaColumns()
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_CriticalSection);

    if (!s_dwMetaRefCount)
    {
		// allocate a static aray of metadata metadata columns
        s_rgMetaColumns = new CVDRowsetColumn[MAX_METADATA_COLUMNS];

        if (!s_rgMetaColumns)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        s_ulMetaColumns = MAX_METADATA_COLUMNS; // number of columns for IColumnsInfo

		// initialize the array elments from the static g_MetaDataMetaData table
		for (int i = 0; i < MAX_METADATA_COLUMNS; i++)
		{
	        s_rgMetaColumns[i].Initialize(g_MetaDataMetaData[i].pCursorColumnID,
										  (BOOL)i, // false for 1st column (bookmark) TRUE for all other columns
										  g_MetaDataMetaData[i].cbMaxLength,
										  g_MetaDataMetaData[i].pszName,
										  g_MetaDataMetaData[i].dwCursorType,
										  i );	// ordinal number
		}
    }

    s_dwMetaRefCount++;

    m_fWeAddedMetaRef = TRUE;

cleanup:
    LeaveCriticalSection(&g_CriticalSection);

    return hr;
}

//=--------------------------------------------------------------------------=
// DestroyMetaColumns - Destroy array of meta-columns objects
//
void CVDCursorMain::DestroyMetaColumns()
{
    EnterCriticalSection(&g_CriticalSection);

    if (m_fWeAddedMetaRef)
    {
        s_dwMetaRefCount--;

        if (!s_dwMetaRefCount)
        {
            delete [] s_rgMetaColumns;

            s_ulMetaColumns = 0;
            s_rgMetaColumns = NULL;
        }
    }

    LeaveCriticalSection(&g_CriticalSection);
}

//=--------------------------------------------------------------------------=
// CreateColumns - Create array of column objects
//
HRESULT CVDCursorMain::CreateColumns()
{
    IColumnsInfo * pColumnsInfo;

    // try to get IRowset's simple metadata interface
    HRESULT hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void**)&pColumnsInfo);

    if (FAILED(hr))
        return VD_E_CANNOTGETMANDATORYINTERFACE;

    ULONG cColumns          = 0;
    DBCOLUMNINFO * pInfo    = NULL;
    WCHAR * pStringsBuffer  = NULL;

    // now get column information
    hr = pColumnsInfo->GetColumnInfo(&cColumns, &pInfo, &pStringsBuffer);

    if (FAILED(hr))
    {
        pColumnsInfo->Release();
        return VD_E_CANNOTGETCOLUMNINFO;
    }

    // store column count
	// note cColumns includes the bookmark column (0)
    m_ulColumns = cColumns;

    // add one for CURSOR_COLUMN_BMK_CURSOR
    m_ulColumns++;

    // if rowset supports DBPROP_BOOKMARKSKIPPED add two for
    // CURSOR_COLUMN_BMK_TEMPORARYREL and CURSOR_COLUMN_BMK_CURSORREL
    if (m_fBookmarkSkipped)
        m_ulColumns += 2;

    // create array of rowset column objects
    m_rgColumns = new CVDRowsetColumn[m_ulColumns];

    if (!m_rgColumns)
    {
        if (pInfo)
            g_pMalloc->Free(pInfo);

        if (pStringsBuffer)
            g_pMalloc->Free(pStringsBuffer);

        pColumnsInfo->Release();

        return E_OUTOFMEMORY;
    }

    ULONG ulCursorOrdinal = 0;

    // get maximum length of bookmarks
    m_cbMaxBookmark = pInfo[0].ulColumnSize;

    // initialize data column(s)
    for (ULONG ulCol = 1; ulCol < cColumns; ulCol++)
    {
        m_rgColumns[ulCursorOrdinal].Initialize(ulCol, ulCursorOrdinal, &pInfo[ulCol], m_cbMaxBookmark);
        ulCursorOrdinal++;
    }

    // initialize bookmark columns
    pInfo[0].pwszName = NULL;   // ICursor requires bookmark columns have a NULL name

    m_rgColumns[ulCursorOrdinal].Initialize(0, ulCursorOrdinal, &pInfo[0], m_cbMaxBookmark,
        (CURSOR_DBCOLUMNID*)&CURSOR_COLUMN_BMKTEMPORARY);
    ulCursorOrdinal++;

    m_rgColumns[ulCursorOrdinal].Initialize(0, ulCursorOrdinal, &pInfo[0], m_cbMaxBookmark,
        (CURSOR_DBCOLUMNID*)&CURSOR_COLUMN_BMKCURSOR);
    ulCursorOrdinal++;

    if (m_fBookmarkSkipped)
    {
        m_rgColumns[ulCursorOrdinal].Initialize(0, ulCursorOrdinal, &pInfo[0], m_cbMaxBookmark,
            (CURSOR_DBCOLUMNID*)&CURSOR_COLUMN_BMKTEMPORARYREL);
        ulCursorOrdinal++;

        m_rgColumns[ulCursorOrdinal].Initialize(0, ulCursorOrdinal, &pInfo[0], m_cbMaxBookmark,
            (CURSOR_DBCOLUMNID*)&CURSOR_COLUMN_BMKCURSORREL);
        ulCursorOrdinal++;
    }

    // free resources
    if (pInfo)
        g_pMalloc->Free(pInfo);

    if (pStringsBuffer)
        g_pMalloc->Free(pStringsBuffer);

    pColumnsInfo->Release();

    InitOptionalMetadata(cColumns);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// InitOptionalMetadata - gets additional metadata from IColumnsRowset (if available)
//
void CVDCursorMain::InitOptionalMetadata(ULONG cColumns)
{
	// we should return if there is only a bookmark column
	if (cColumns < 2)
		return;

	IColumnsRowset * pColumnsRowset = NULL;

    // try to get IColumnsRowset interface
    HRESULT hr = m_pRowset->QueryInterface(IID_IColumnsRowset, (void**)&pColumnsRowset);

    if (FAILED(hr))
        return;

	IRowset * pRowset	= NULL;
	IColumnsInfo * pColumnsInfo = NULL;
	IAccessor * pAccessor = NULL;

	ULONG	cOptColumnsAvailable = 0;
	DBID *	rgOptColumnsAvailable = NULL;
	DBID *	pOptColumnsAvailable = NULL;  // work ptr

	ULONG	cOptColumns = 0;
	DBID *	rgOptColumns = NULL;
	DBID *	pOptColumns = NULL;	 //work ptr

	ULONG	ulBuffLen = 0;
	BYTE *	pBuff = NULL;
	HACCESSOR hAccessor;
	BOOL	fAccessorCreated = FALSE;

	HROW *	rgRows = NULL;
	ULONG	cRowsObtained = 0;

	// we are only interested in a few of the optional columns
	ULONG		rgColumnPropids[VD_COLUMNSROWSET_MAX_OPT_COLUMNS];
	ULONG		rgOrdinals[VD_COLUMNSROWSET_MAX_OPT_COLUMNS];
	DBBINDING	rgBindings[VD_COLUMNSROWSET_MAX_OPT_COLUMNS];
	DBBINDING * pBinding = NULL; // work ptr
	BOOL		fMatched;
	GUID		guidCID	= DBCIDGUID;

	ULONG	cColumnsMatched = 0;
	ULONG	i, j;

    // get array of available columns
	hr = pColumnsRowset->GetAvailableColumns(&cOptColumnsAvailable, &rgOptColumnsAvailable);

    if (FAILED(hr) || 0 == cOptColumnsAvailable)
		goto cleanup;

	ASSERT_(rgOptColumnsAvailable);

	// allocate enough DBIDs for the lesser of the total available columns or the total number of
	// columns we're interested in
	rgOptColumns = (DBID *)g_pMalloc->Alloc(min(cOptColumnsAvailable, VD_COLUMNSROWSET_MAX_OPT_COLUMNS)
											* sizeof(DBID));

	if (!rgOptColumns)
		goto cleanup;

	// initalize work pointers
	pOptColumnsAvailable	= rgOptColumnsAvailable;
	pOptColumns				= rgOptColumns;			
	pBinding				= rgBindings;

	memset(pBinding, 0, sizeof(DBBINDING) * VD_COLUMNSROWSET_MAX_OPT_COLUMNS);

	// search available columns for the ones we are interested in copying them into rgOptColumns
	for (i = 0; i < cOptColumnsAvailable && cColumnsMatched < VD_COLUMNSROWSET_MAX_OPT_COLUMNS; i++)
	{
		fMatched = FALSE; // initialize to false
		if (DBKIND_GUID_PROPID == pOptColumnsAvailable->eKind	&&
			DO_GUIDS_MATCH(pOptColumnsAvailable->uGuid.guid, guidCID))
		{
			switch (pOptColumnsAvailable->uName.ulPropid)
			{
				case 12: //DBCOLUMN_COLLATINGSEQUENCE     = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)12};
					pBinding->obValue     = ulBuffLen;
					ulBuffLen			 +=	sizeof(ULONG);
					pBinding->obStatus    = ulBuffLen;
					ulBuffLen			 +=	sizeof(DBSTATUS);
					pBinding->dwPart      = DBPART_VALUE | DBPART_STATUS;
					pBinding->dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
					pBinding->wType       = DBTYPE_I4;
					fMatched			  = TRUE;
					break;

				//string properties
				case 10: //DBCOLUMN_BASECOLUMNNAME        = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)10};
				case 11: //DBCOLUMN_BASETABLENAME         = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)11};
				case 14: //DBCOLUMN_DEFAULTVALUE          = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)14};
					pBinding->obValue     = ulBuffLen;
					ulBuffLen			 +=	512;
					pBinding->obLength    = ulBuffLen;
					ulBuffLen			 +=	sizeof(ULONG);
					pBinding->obStatus    = ulBuffLen;
					ulBuffLen			 +=	sizeof(DBSTATUS);
					pBinding->dwPart      = DBPART_VALUE | DBPART_LENGTH |DBPART_STATUS;
					pBinding->dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
					pBinding->cbMaxLen    = 512;
					pBinding->wType       = DBTYPE_WSTR;
					fMatched			  = TRUE;
					break;

					// bool properties
				case 16: //DBCOLUMN_HASDEFAULT            = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)16};
				case 17: //DBCOLUMN_ISAUTOINCREMENT       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)17};
				case 18: //DBCOLUMN_ISCASESENSITIVE       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)18};
				case 21: //DBCOLUMN_ISUNIQUE              = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)21};
					pBinding->obValue     = ulBuffLen;
					ulBuffLen			 +=	sizeof(VARIANT_BOOL);
					pBinding->obStatus    = ulBuffLen;
					ulBuffLen			 +=	sizeof(DBSTATUS);
					pBinding->dwPart      = DBPART_VALUE | DBPART_STATUS;
					pBinding->dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
					pBinding->wType       = DBTYPE_BOOL;
					fMatched			  = TRUE;
					break;
			}
		}

		if (fMatched)
		{
			rgColumnPropids[cColumnsMatched]	= pOptColumnsAvailable->uName.ulPropid;
			*pOptColumns						= *pOptColumnsAvailable;
			pBinding++;
			pOptColumns++;
			cColumnsMatched++;
		}
		pOptColumnsAvailable++;
	}

	if (!cColumnsMatched)
		goto cleanup;

    // get column's rowset
	hr = pColumnsRowset->GetColumnsRowset(NULL,
											cColumnsMatched,
											rgOptColumns,
											IID_IRowset,
											0,
											NULL,
											(IUnknown**)&pRowset);

    if FAILED(hr)
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

    // get IColumnsInfo interface on column's rowset
    hr = pRowset->QueryInterface(IID_IColumnsInfo, (void**)&pColumnsInfo);

    if (FAILED(hr))
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

	// get ordinals for our optional columns
	hr = pColumnsInfo->MapColumnIDs(cColumnsMatched, rgOptColumns, rgOrdinals);

    if (S_OK != hr)
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

	// update binding structures with ordinals
	for (i = 0; i < cColumnsMatched; i++)
		rgBindings[i].iOrdinal    = rgOrdinals[i];

    // get IAccessor interface on column's rowset
    hr = pRowset->QueryInterface(IID_IAccessor, (void**)&pAccessor);

    if (FAILED(hr))
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

    // create accessor based on rgBindings array
	hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA,
									cColumnsMatched,
									rgBindings,
									ulBuffLen,
									&hAccessor,
									NULL);

    if (S_OK != hr)
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

	// set flag that accessor was successfully created (used during cleanup)
	fAccessorCreated = TRUE;

	// allocate a buffer to hold the metadata
	pBuff = (BYTE *)g_pMalloc->Alloc(ulBuffLen);

	if (!pBuff)
	{
		ASSERT_(FALSE);
		goto cleanup;
	}
									
	// get all rows (each row represents a column in the original rowset)
	// except the first row which represents the bookmark column
	hr = pRowset->GetNextRows(0, // reserved
							  1, // skip the bookmark row
							  cColumns - 1,	// get 1 less than cColumns to account for bookmark row
							  &cRowsObtained, // return count of rows obtanied
							  &rgRows);

    if (FAILED(hr) || !cRowsObtained)
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

	BYTE *		pValue;

	// loop through all rows obtained
	for (i = 0; i < cRowsObtained; i++)
	{
		// call GetData to get the metadata for this row (which represents a column in the orig rowset)
		hr = pRowset->GetData(rgRows[i], hAccessor, pBuff);
		if SUCCEEDED(hr)
		{
			// now update the CVDRowsetColumn object (that this row represents)
			// with the values returned from GetData
			for (j = 0; j < cColumnsMatched; j++)
			{
				if (DBBINDSTATUS_OK != *(DBSTATUS*)(pBuff + rgBindings[j].obStatus))
					continue;

				// set pValue to point into buffer at correct offset
				pValue = pBuff + rgBindings[j].obValue;

				switch (rgColumnPropids[j])
				{
					case 12: //DBCOLUMN_COLLATINGSEQUENCE     = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)12};
						m_rgColumns[i].SetCollatingOrder(*(LCID*)pValue);
						break;

					//string properties
					case 10: //DBCOLUMN_BASECOLUMNNAME        = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)10};
						m_rgColumns[i].SetBaseColumnName((WCHAR*)pValue, *(ULONG*)(pBuff + rgBindings[j].obLength));
						break;
					case 11: //DBCOLUMN_BASETABLENAME         = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)11};
						m_rgColumns[i].SetBaseName((WCHAR*)pValue, *(ULONG*)(pBuff + rgBindings[j].obLength));
						break;
					case 14: //DBCOLUMN_DEFAULTVALUE          = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)14};
						m_rgColumns[i].SetDefaultValue((WCHAR*)pValue, *(ULONG*)(pBuff + rgBindings[j].obLength));
						break;

						// bool properties
					case 16: //DBCOLUMN_HASDEFAULT            = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)16};
						m_rgColumns[i].SetHasDefault(*(VARIANT_BOOL*)pValue);
						break;
					case 17: //DBCOLUMN_ISAUTOINCREMENT       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)17};
						m_rgColumns[i].SetAutoIncrement(*(VARIANT_BOOL*)pValue);
						break;
					case 18: //DBCOLUMN_ISCASESENSITIVE       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)18};
						m_rgColumns[i].SetCaseSensitive(*(VARIANT_BOOL*)pValue);
						break;
					case 21: //DBCOLUMN_ISUNIQUE              = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)21};
						m_rgColumns[i].SetUnique(*(VARIANT_BOOL*)pValue);
						break;
					default:
						ASSERT_(FALSE);
						break;
				}
			}
		}
		else
			ASSERT_(FALSE);
	}

	m_fColumnsRowsetSupported = TRUE;

cleanup:


	if (pBuff)
		g_pMalloc->Free(pBuff);

	if (pAccessor)
	{
		if (fAccessorCreated)
			pAccessor->ReleaseAccessor(hAccessor, NULL);
		pAccessor->Release();
	}

	if (pRowset)
	{
		if (cRowsObtained)
		{
			pRowset->ReleaseRows(cRowsObtained, rgRows, NULL, NULL, NULL);
			ASSERT_(rgRows);
			g_pMalloc->Free(rgRows);
		}
		pRowset->Release();
	}

	if (pColumnsInfo)
		pColumnsInfo->Release();

    if (rgOptColumnsAvailable)
		g_pMalloc->Free(rgOptColumnsAvailable);

    if (rgOptColumns)
		g_pMalloc->Free(rgOptColumns);
	
	if (pColumnsRowset)	
		pColumnsRowset->Release();

}

//=--------------------------------------------------------------------------=
// DestroyColumns - Destroy array of column objects
//
void CVDCursorMain::DestroyColumns()
{
    delete [] m_rgColumns;

    m_ulColumns = 0;
    m_rgColumns = NULL;
}

//=--------------------------------------------------------------------------=
// ConnectIRowsetNotify - Connect IRowsetNotify interface
//
HRESULT CVDCursorMain::ConnectIRowsetNotify()
{
    IConnectionPointContainer * pConnectionPointContainer;

    HRESULT hr = GetRowset()->QueryInterface(IID_IConnectionPointContainer, (void**)&pConnectionPointContainer);

    if (FAILED(hr))
        return VD_E_CANNOTCONNECTIROWSETNOTIFY;

    IConnectionPoint * pConnectionPoint;

    hr = pConnectionPointContainer->FindConnectionPoint(IID_IRowsetNotify, &pConnectionPoint);

    if (FAILED(hr))
    {
        pConnectionPointContainer->Release();
        return VD_E_CANNOTCONNECTIROWSETNOTIFY;
    }

    hr = pConnectionPoint->Advise(&m_RowsetNotify, &m_dwAdviseCookie);

    pConnectionPointContainer->Release();
    pConnectionPoint->Release();

    return hr;
}

//=--------------------------------------------------------------------------=
// DisconnectIRowsetNotify - Disconnect IRowsetNotify interface
//
void CVDCursorMain::DisconnectIRowsetNotify()
{
    IConnectionPointContainer * pConnectionPointContainer;

    HRESULT hr = GetRowset()->QueryInterface(IID_IConnectionPointContainer, (void**)&pConnectionPointContainer);

    if (FAILED(hr))
        return;

    IConnectionPoint * pConnectionPoint;

    hr = pConnectionPointContainer->FindConnectionPoint(IID_IRowsetNotify, &pConnectionPoint);

    if (FAILED(hr))
    {
        pConnectionPointContainer->Release();
        return;
    }

    hr = pConnectionPoint->Unadvise(m_dwAdviseCookie);

    if (SUCCEEDED(hr))
        m_dwAdviseCookie = 0;   // clear connection point identifier

    pConnectionPointContainer->Release();
    pConnectionPoint->Release();
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDCursorMain::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

	*ppvObjOut = NULL;

	if (DO_GUIDS_MATCH(riid, IID_IUnknown))
		{
		*ppvObjOut = this;
		AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef (needed to resolve ambiguity)
//
ULONG CVDCursorMain::AddRef(void)
{
    return CVDNotifier::AddRef();
}

//=--------------------------------------------------------------------------=
// IUnknown Release (needed to resolve ambiguity)
//
ULONG CVDCursorMain::Release(void)
{

	if (1 == m_dwRefCount)
		Passivate();  // unhook everything including notification sink

	if (1 > --m_dwRefCount)
	{
		if (0 == m_RowsetNotify.GetRefCount())
			delete this;
		return 0;
	}

	return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IsSameRowAsNew - Determine if specified hRow is an addrow
//
BOOL CVDCursorMain::IsSameRowAsNew(HROW hrow)
{
	for (int k = 0; k < m_Children.GetSize(); k++)
    {
		if (((CVDCursorPosition*)(CVDNotifier*)m_Children[k])->IsSameRowAsNew(hrow) == S_OK)
			return TRUE;
	}

	return FALSE;
}

//=--------------------------------------------------------------------------=
// AddedRows - Get the number of add-rows in cursor
//
ULONG CVDCursorMain::AddedRows()
{
	ULONG cAdded = 0;

	for (int k = 0; k < m_Children.GetSize(); k++)
    {
		if (((CVDCursorPosition*)(CVDNotifier*)m_Children[k])->GetEditMode() == CURSOR_DBEDITMODE_ADD)
			cAdded++;
	}

	return cAdded;
}

//=--------------------------------------------------------------------------=
// IRowsetNotify Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IRowsetNotify OnFieldChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::OnFieldChange(IRowset *pRowset,
									   HROW hRow,
									   ULONG cColumns,
									   ULONG rgColumns[],
									   DBREASON eReason,
									   DBEVENTPHASE ePhase,
									   BOOL fCantDeny)
{
	HRESULT hr = S_OK;

    // return if notification caused by internal rowset call
    if (m_fInternalSetData && eReason == DBREASON_COLUMN_SET)
        return hr;

	for (int k = 0; k < m_Children.GetSize(); k++)
    {
		hr = ((CVDCursorPosition*)(CVDNotifier*)m_Children[k])->OnFieldChange(pRowset,
															   hRow,
															   cColumns,
															   rgColumns,
															   eReason,
															   ePhase,
															   fCantDeny);
		if (hr)
			break;
	}

	return hr;

}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::OnRowChange(IRowset *pRowset,
									 ULONG cRows,
									 const HROW rghRows[],
									 DBREASON eReason,
									 DBEVENTPHASE ePhase,
									 BOOL fCantDeny)
{
	HRESULT hr = S_OK;

    // return if notification caused by internal rowset call (either insert or delete)
    if (m_fInternalInsertRow && eReason == DBREASON_ROW_INSERT || m_fInternalDeleteRows && eReason == DBREASON_ROW_DELETE)
        return hr;

	for (int k = 0; k < m_Children.GetSize(); k++)
    {
		hr = ((CVDCursorPosition*)(CVDNotifier*)m_Children[k])->OnRowChange(pRowset,
															   cRows,
															   rghRows,
															   eReason,
															   ePhase,
															   fCantDeny);
		if (hr)
			break;
    }

	return hr;
}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowsetChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::OnRowsetChange(IRowset *pRowset,
										DBREASON eReason,
										DBEVENTPHASE ePhase,
										BOOL fCantDeny)
{
	HRESULT hr = S_OK;

	for (int k = 0; k < m_Children.GetSize(); k++)
    {
		hr = ((CVDCursorPosition*)(CVDNotifier*)m_Children[k])->OnRowsetChange(pRowset,
															   eReason,
															   ePhase,
															   fCantDeny);
		if (hr)
			break;
	}

	return hr;
}

//=--------------------------------------------------------------------------=
// CVDCursorMain::CVDRowsetNotify::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CVDCursorMain *CVDCursorMain::CVDRowsetNotify::m_pMainUnknown
(
    void
)
{
    return (CVDCursorMain *)((LPBYTE)this - offsetof(CVDCursorMain, m_RowsetNotify));
}

//=--------------------------------------------------------------------------=
// CVDCursorMain::CVDRowsetNotify::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CVDCursorMain::CVDRowsetNotify::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
	if (!ppvObjOut)
		return E_INVALIDARG;

	*ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(riid, IID_IUnknown))
        *ppvObjOut = (IUnknown *)this;
	else
    if (DO_GUIDS_MATCH(riid, IID_IRowsetNotify))
        *ppvObjOut = (IUnknown *)this;

	if (*ppvObjOut)
	{
		m_cRef++;
        return S_OK;
	}

	return E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// CVDCursorMain::CVDRowsetNotify::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CVDCursorMain::CVDRowsetNotify::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CVDCursorMain::CVDRowsetNotify::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CVDCursorMain::CVDRowsetNotify::Release
(
    void
)
{
    ULONG cRef = --m_cRef;

    if (!m_cRef && !m_pMainUnknown()->m_dwRefCount)
        delete m_pMainUnknown();

    return cRef;
}

//=--------------------------------------------------------------------------=
// IRowsetNotify Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IRowsetNotify OnFieldChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::CVDRowsetNotify::OnFieldChange(IRowset *pRowset,
													   HROW hRow,
													   ULONG cColumns,
													   ULONG rgColumns[],
													   DBREASON eReason,
													   DBEVENTPHASE ePhase,
													   BOOL fCantDeny)
{
	
	return m_pMainUnknown()->OnFieldChange(pRowset,
											hRow,
											cColumns,
											rgColumns,
											eReason,
											ePhase,
											fCantDeny);
}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::CVDRowsetNotify::OnRowChange(IRowset *pRowset,
													 ULONG cRows,
													 const HROW rghRows[],
													 DBREASON eReason,
													 DBEVENTPHASE ePhase,
													 BOOL fCantDeny)
{
	return m_pMainUnknown()->OnRowChange(pRowset,
											cRows,
											rghRows,
											eReason,
											ePhase,
											fCantDeny);
}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowsetChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::CVDRowsetNotify::OnRowsetChange(IRowset *pRowset,
														DBREASON eReason,
														DBEVENTPHASE ePhase,
														BOOL fCantDeny)
{
	return m_pMainUnknown()->OnRowsetChange(pRowset,
											eReason,
											ePhase,
											fCantDeny);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\colupdat.h ===
//---------------------------------------------------------------------------
// ColumnUpdate.h : CVDColumnUpdate header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDCOLUMNUPDATE__
#define __CVDCOLUMNUPDATE__


class CVDColumnUpdate
{
protected:
// Construction/Destruction
	CVDColumnUpdate();
	virtual ~CVDColumnUpdate();

// Helper function
    static HRESULT ExtractVariant(CURSOR_DBBINDPARAMS * pBindParams, CURSOR_DBVARIANT * pVariant);

public:
    static HRESULT Create(CVDRowsetColumn * pColumn, CURSOR_DBBINDPARAMS * pBindParams,
        CVDColumnUpdate ** ppColumnUpdate, CVDResourceDLL * pResourceDLL);

// Reference count
    ULONG AddRef();
    ULONG Release();

// Access functions
    CVDRowsetColumn * GetColumn() const {return m_pColumn;}
    CURSOR_DBVARIANT GetVariant() const {return m_variant;}
    VARTYPE GetVariantType() const {return m_variant.vt;}
    ULONG GetVarDataLen() const {return m_cbVarDataLen;}
    DWORD GetInfo() const {return m_dwInfo;}

protected:
// Data members
    DWORD               m_dwRefCount;   // reference count
    CVDRowsetColumn *   m_pColumn;      // rowset column pointer
    CURSOR_DBVARIANT    m_variant;      // update variant
    ULONG               m_cbVarDataLen; // variable data length
    DWORD               m_dwInfo;       // information field
    CVDResourceDLL *    m_pResourceDLL; // pointer which keeps track of resource DLL
};


#endif //__CVDCOLUMNUPDATE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\cursmeta.cpp ===
//---------------------------------------------------------------------------
// MetadataCursor.cpp : MetadataCursor implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"
#include "CursBase.h"
#include "CursMeta.h"
#include "fastguid.h"
#include "resource.h"

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDMetadataCursor - Constructor
//
CVDMetadataCursor::CVDMetadataCursor()
{
    m_dwRefCount    = 1;
    m_lCurrentRow   = -1;   // before first

    m_ulColumns     = 0;
    m_pColumns      = NULL;

    m_ulMetaColumns = 0;
    m_pMetaColumns  = NULL;

#ifdef _DEBUG
    g_cVDMetadataCursorCreated++;
#endif
}

//=--------------------------------------------------------------------------=
// ~CVDMetadataCursor - Destructor
//
CVDMetadataCursor::~CVDMetadataCursor()
{
#ifdef _DEBUG
    g_cVDMetadataCursorDestroyed++;
#endif
}

//=--------------------------------------------------------------------------=
// RowToBookmark - Convert row to bookmark
//=--------------------------------------------------------------------------=
//
// Parameters:
//    lRow          - [in]  a row number
//    pcbBookmark   - [out] a pointer to memory in which to return the length
//                          in bytes of the corresponding bookmark
//    pBookmark     - [out] a pointer to memory in which to return the bookmark
//
// Notes:
//
void CVDMetadataCursor::RowToBookmark(LONG lRow, ULONG * pcbBookmark, void * pBookmark) const
{

    if (lRow < 0)
    {
        *pcbBookmark = CURSOR_DB_BMK_SIZE;
    	memcpy(pBookmark, &CURSOR_DBBMK_BEGINNING, CURSOR_DB_BMK_SIZE);
    }
    else if (lRow >= (LONG)m_ulColumns)
    {
        *pcbBookmark = CURSOR_DB_BMK_SIZE;
    	memcpy(pBookmark, &CURSOR_DBBMK_END, CURSOR_DB_BMK_SIZE);
    }
    else
    {
        *pcbBookmark = sizeof(LONG);
    	memcpy(pBookmark, &lRow, sizeof(LONG));
    }

}
//=--------------------------------------------------------------------------=
// BookmarkToRow - Convert bookmark to row
//=--------------------------------------------------------------------------=
//
// Parameters:
//    cbBookmark    - [in]  the length in bytes of the bookmark
//    pBookmark     - [in]  a pointer to the bookmark
//    pRow          - [out] a pointer to memory in which to return the
//                          corresponding row
//
// Output:
//    BOOL          - TRUE if successful
//
// Notes:
//
BOOL CVDMetadataCursor::BookmarkToRow(ULONG cbBookmark, void * pBookmark, LONG * plRow) const
{
    BOOL fResult = FALSE;

    if (cbBookmark == CURSOR_DB_BMK_SIZE)
    {
        if (memcmp(pBookmark, &CURSOR_DBBMK_BEGINNING, CURSOR_DB_BMK_SIZE) == 0)
        {
            *plRow = -1;
            fResult = TRUE;
        }
        else if (memcmp(pBookmark, &CURSOR_DBBMK_END, CURSOR_DB_BMK_SIZE) == 0)
        {
            *plRow = (LONG)m_ulColumns;
            fResult = TRUE;
        }
        else if (memcmp(pBookmark, &CURSOR_DBBMK_CURRENT, CURSOR_DB_BMK_SIZE) == 0)
        {
            *plRow = m_lCurrentRow;
            fResult = TRUE;
        }
    }
    else
    if (cbBookmark == sizeof(LONG))
    {
        memcpy(plRow, pBookmark, sizeof(LONG));
        if (*plRow >= 0 && *plRow < (LONG)m_ulColumns)
            fResult = TRUE;
    }

    return fResult;
}

//=--------------------------------------------------------------------------=
// ReturnData_I4 - Coerce I4 data into buffers
//=--------------------------------------------------------------------------=
// This function coerces the specified data into supplied buffers
//
// Parameters:
//    dwData            - [in] the 4-byte data
//    pCursorBinding    - [in] the cursor binding describing the format of the
//                             returned information
//    pData             - [in] a pointer to the fixed area buffer
//    pVarData          - [in] a pointer to the variable length buffer
//
// Output:
//    ULONG - the number of bytes used in variable length buffer
//
// Notes:
//
ULONG CVDMetadataCursor::ReturnData_I4(DWORD dwData, CURSOR_DBCOLUMNBINDING * pCursorBinding,
    BYTE * pData, BYTE * pVarData)
{
    ULONG cbVarData = 0;

    if (pCursorBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            *(DWORD*)(pData + pCursorBinding->obData) = dwData;
    }
    else if (pCursorBinding->dwBinding == CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
        {
            CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

            VariantInit((VARIANT*)pVariant);

            pVariant->vt    = CURSOR_DBTYPE_I4;
            pVariant->lVal  = dwData;
        }
    }

    if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
        *(ULONG*)(pData + pCursorBinding->obVarDataLen) = 0;

    if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obInfo) = CURSOR_DB_NOINFO;

    return cbVarData;
}

//=--------------------------------------------------------------------------=
// ReturnData_BOOL - Coerce BOOL data into buffers
//=--------------------------------------------------------------------------=
// This function coerces the specified data into supplied buffers
//
// Parameters:
//    fData             - [in] the boolean data
//    pCursorBinding    - [in] the cursor binding describing the format of the
//                             returned information
//    pData             - [in] a pointer to the fixed area buffer
//    pVarData          - [in] a pointer to the variable length buffer
//
// Output:
//    ULONG - the number of bytes used in variable length buffer
//
// Notes:
//
ULONG CVDMetadataCursor::ReturnData_BOOL(VARIANT_BOOL fData, CURSOR_DBCOLUMNBINDING * pCursorBinding,
    BYTE * pData, BYTE * pVarData)
{
    ULONG cbVarData = 0;

    if (pCursorBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            *(VARIANT_BOOL*)(pData + pCursorBinding->obData) = fData;
    }
    else if (pCursorBinding->dwBinding == CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
        {
            CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

            VariantInit((VARIANT*)pVariant);

            pVariant->vt        = CURSOR_DBTYPE_BOOL;
            pVariant->boolVal   = fData;
        }
    }

    if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
        *(ULONG*)(pData + pCursorBinding->obVarDataLen) = 0;

    if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obInfo) = CURSOR_DB_NOINFO;

    return cbVarData;
}

//=--------------------------------------------------------------------------=
// ReturnData_LPWSTR - Coerce LPWSTR data into buffers
//=--------------------------------------------------------------------------=
// This function coerces the specified data into supplied buffers
//
// Parameters:
//    pwszData          - [in] the string data
//    pCursorBinding    - [in] the cursor binding describing the format of the
//                             returned information
//    pData             - [in] a pointer to the fixed area buffer
//    pVarData          - [in] a pointer to the variable length buffer
//
// Output:
//    ULONG - the number of bytes used in variable length buffer
//
// Notes:
//
ULONG CVDMetadataCursor::ReturnData_LPWSTR(WCHAR * pwszData, CURSOR_DBCOLUMNBINDING * pCursorBinding,
    BYTE * pData, BYTE * pVarData)
{
    ULONG cbVarData = 0;

    ULONG cbLength = 0;
    DWORD dwInfo = CURSOR_DB_NOINFO;

    if (pCursorBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_CHARS)
        {
            if (pwszData)
                cbLength = GET_MBCSLEN_FROMWIDE(pwszData);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                if (pwszData)
                {
                    MAKE_MBCSPTR_FROMWIDE(pszData, pwszData);

                    memcpy(pData + pCursorBinding->obData, pszData, min(pCursorBinding->cbMaxLen, cbLength));

                    if (pCursorBinding->cbMaxLen < cbLength)
                        dwInfo = CURSOR_DB_TRUNCATED;
                }
                else
				{
                    *(CHAR*)(pData + pCursorBinding->obData) = 0;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
        else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_WCHARS)
        {
            if (pwszData)
                cbLength = (lstrlenW(pwszData) + 1) * sizeof(WCHAR);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                if (pwszData)
                {
                    memcpy(pData + pCursorBinding->obData, pwszData, min(pCursorBinding->cbMaxLen, cbLength));

                    if (pCursorBinding->cbMaxLen < cbLength)
                        dwInfo = CURSOR_DB_TRUNCATED;
                }
                else
				{
                    *(WCHAR*)(pData + pCursorBinding->obData) = 0;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
        else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPSTR)
        {
            if (pwszData)
                cbLength = GET_MBCSLEN_FROMWIDE(pwszData);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                if (pwszData)
                {
                    MAKE_MBCSPTR_FROMWIDE(pszData, pwszData);

                    *(LPSTR*)(pData + pCursorBinding->obData) = (LPSTR)pVarData;

                    if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                    {
                        memcpy(pVarData, pszData, cbLength);
	
	                    cbVarData = cbLength;
                    }
                    else
                    {
                        memcpy(pVarData, pszData, min(pCursorBinding->cbMaxLen, cbLength));

	                    cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                        if (pCursorBinding->cbMaxLen < cbLength)
                            dwInfo = CURSOR_DB_TRUNCATED;
                    }
                }
                else
				{
                    *(LPSTR*)(pData + pCursorBinding->obData) = NULL;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
        else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPWSTR)
        {
            if (pwszData)
                cbLength = (lstrlenW(pwszData) + 1) * sizeof(WCHAR);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                if (pwszData)
                {
                    *(LPWSTR*)(pData + pCursorBinding->obData) = (LPWSTR)pVarData;

                    if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                    {
                        memcpy(pVarData, pwszData, cbLength);

	                    cbVarData = cbLength;
                    }
                    else
                    {
                        memcpy(pVarData, pwszData, min(pCursorBinding->cbMaxLen, cbLength));

	                    cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                        if (pCursorBinding->cbMaxLen < cbLength)
                            dwInfo = CURSOR_DB_TRUNCATED;
                    }
                }
                else
				{
                    *(LPWSTR*)(pData + pCursorBinding->obData) = NULL;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
    }
    else if (pCursorBinding->dwBinding == CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPSTR)
        {
            if (pwszData)
                cbLength = GET_MBCSLEN_FROMWIDE(pwszData);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

                VariantInit((VARIANT*)pVariant);

                if (pwszData)
                {
                    MAKE_MBCSPTR_FROMWIDE(pszData, pwszData);

                    pVariant->vt        = CURSOR_DBTYPE_LPSTR;
                    pVariant->pszVal    = (LPSTR)pVarData;

                    if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                    {
                        memcpy(pVarData, pszData, cbLength);

	                    cbVarData = cbLength;
                    }
                    else
                    {
                        memcpy(pVarData, pszData, min(pCursorBinding->cbMaxLen, cbLength));

	                    cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                        if (pCursorBinding->cbMaxLen < cbLength)
                            dwInfo = CURSOR_DB_TRUNCATED;
                    }
                }
                else
				{
                    pVariant->vt = VT_NULL;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
        else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPWSTR)
        {
            if (pwszData)
                cbLength = (lstrlenW(pwszData) + 1) * sizeof(WCHAR);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

                VariantInit((VARIANT*)pVariant);

                if (pwszData)
                {
                    pVariant->vt        = CURSOR_DBTYPE_LPWSTR;
                    pVariant->pwszVal   = (LPWSTR)pVarData;

                    if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                    {
                        memcpy(pVarData, pwszData, cbLength);

	                    cbVarData = cbLength;
                    }
                    else
                    {
                        memcpy(pVarData, pwszData, min(pCursorBinding->cbMaxLen, cbLength));

	                    cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                        if (pCursorBinding->cbMaxLen < cbLength)
                            dwInfo = CURSOR_DB_TRUNCATED;
                    }
                }
                else
				{
                    pVariant->vt = VT_NULL;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
        else if (pCursorBinding->dwDataType == VT_BSTR)
        {
            if (pwszData)
                cbLength = (lstrlenW(pwszData) + 1) * sizeof(WCHAR);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
			{
                CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

                VariantInit((VARIANT*)pVariant);

                if (pwszData)
				{
                    pVariant->vt        = VT_BSTR;
                    pVariant->pwszVal   = SysAllocString(pwszData);
				}
                else
				{
                    pVariant->vt = VT_NULL;
					dwInfo = CURSOR_DB_NULL;
				}
			}
		}
	}

    if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
        *(ULONG*)(pData + pCursorBinding->obVarDataLen) = cbLength;

    if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obInfo) = dwInfo;

    return cbVarData;
}

//=--------------------------------------------------------------------------=
// ReturnData_DBCOLUMNID - Coerce DBCOLUMNID data into buffers
//=--------------------------------------------------------------------------=
// This function coerces the specified data into supplied buffers
//
// Parameters:
//    cursorColumnID    - [in] the cursor column identifier
//    pCursorBinding    - [in] the cursor binding describing the format of the
//                             returned information
//    pData             - [in] a pointer to the fixed area buffer
//    pVarData          - [in] a pointer to the variable length buffer
//
// Output:
//    ULONG - the number of bytes used in variable length buffer
//
// Notes:
//
ULONG CVDMetadataCursor::ReturnData_DBCOLUMNID(CURSOR_DBCOLUMNID cursorColumnID, CURSOR_DBCOLUMNBINDING * pCursorBinding,
    BYTE * pData, BYTE * pVarData)
{
    ULONG cbVarData = 0;

    if (pCursorBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            *(CURSOR_DBCOLUMNID*)(pData + pCursorBinding->obData) = cursorColumnID;
    }
    else if (pCursorBinding->dwBinding == CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
        {
            CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);
            CURSOR_DBCOLUMNID * pCursorColumnID = (CURSOR_DBCOLUMNID*)pVarData;

            VariantInit((VARIANT*)pVariant);

            pVariant->vt        = CURSOR_DBTYPE_COLUMNID;
            pVariant->pColumnid = pCursorColumnID;

            *pCursorColumnID = cursorColumnID;

            cbVarData = sizeof(CURSOR_DBCOLUMNID);
        }
    }

    if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obVarDataLen) = 0;

    if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obInfo) = CURSOR_DB_NOINFO;

    return cbVarData;
}

//=--------------------------------------------------------------------------=
// ReturnData_Bookmark - Coerce bookmark data into buffers
//=--------------------------------------------------------------------------=
// This function coerces the specified data into supplied buffers
//
// Parameters:
//    lRow              - [in] the current row
//    pCursorBinding    - [in] the cursor binding describing the format of the
//                             returned information
//    pData             - [in] a pointer to the fixed area buffer
//    pVarData          - [in] a pointer to the variable length buffer
//
// Output:
//    ULONG - the number of bytes used in variable length buffer
//
// Notes:
//
ULONG CVDMetadataCursor::ReturnData_Bookmark(LONG lRow, CURSOR_DBCOLUMNBINDING * pCursorBinding,
    BYTE * pData, BYTE * pVarData)
{
    ULONG cbVarData = 0;

    ULONG cbLength = sizeof(LONG);
    DWORD dwInfo = CURSOR_DB_NOINFO;

    if (pCursorBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BYTES)
        {
            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                memcpy(pData + pCursorBinding->obData, &lRow, min(pCursorBinding->cbMaxLen, cbLength));

                if (pCursorBinding->cbMaxLen < cbLength)
                    dwInfo = CURSOR_DB_TRUNCATED;
            }
        }
        else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB)
        {
            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                *(ULONG*)(pData + pCursorBinding->obData) = cbLength;
                *(LPBYTE*)(pData + pCursorBinding->obData + sizeof(ULONG)) = (LPBYTE)pVarData;

                if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                {
                    memcpy((LPBYTE)pVarData, &lRow, cbLength);

	                cbVarData = cbLength;
                }
                else
                {
                    memcpy(pVarData, &lRow, min(pCursorBinding->cbMaxLen, cbLength));

	                cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                    if (pCursorBinding->cbMaxLen < cbLength)
                        dwInfo = CURSOR_DB_TRUNCATED;
                }
            }
        }
    }
    else if (pCursorBinding->dwBinding == CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB)
        {
            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

                VariantInit((VARIANT*)pVariant);

                pVariant->vt                = CURSOR_DBTYPE_BLOB;
                pVariant->blob.cbSize       = cbLength;
                pVariant->blob.pBlobData    = (LPBYTE)pVarData;

                if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                {
                    memcpy((LPBYTE)pVarData, &lRow, cbLength);

	                cbVarData = cbLength;
                }
                else
                {
                    memcpy(pVarData, &lRow, min(pCursorBinding->cbMaxLen, cbLength));

	                cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                    if (pCursorBinding->cbMaxLen < cbLength)
                        dwInfo = CURSOR_DB_TRUNCATED;
                }
            }
        }
    }

    if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
        *(ULONG*)(pData + pCursorBinding->obVarDataLen) = cbLength;

    if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obInfo) = dwInfo;

    return cbVarData;
}

//=--------------------------------------------------------------------------=
// Create - Create metadata cursor object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new metadata cursor object
//
// Parameters:
//    ulColumns             - [in]  the number of rowset columns
//    pColumns              - [in]  a pointer to rowset columns where to
//                                  retrieve metadata
//    ulMetaColumns         - [in]  the number of rowset meta-columns (can be 0)
//    pMetaColumns          - [in]  a pointer to rowset meta-columns where to
//                                  retrieve metadata (can be NULL)
//    ppMetaDataCursor      - [out] a pointer in which to return pointer to
//                                  metadata cursor object
//    pResourceDLL          - [in]  a pointer which keeps track of resource DLL
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDMetadataCursor::Create(ULONG ulColumns, CVDRowsetColumn * pColumns, ULONG ulMetaColumns,
    CVDRowsetColumn * pMetaColumns, CVDMetadataCursor ** ppMetadataCursor, CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pColumns, CVDRowsetColumn)
    ASSERT_NULL_OR_POINTER(pMetaColumns, CVDRowsetColumn)
    ASSERT_POINTER(ppMetadataCursor, CVDMetadataCursor*)
    ASSERT_POINTER(pResourceDLL, CVDResourceDLL)

    if (!ppMetadataCursor || !pColumns)
        return E_INVALIDARG;

    *ppMetadataCursor = NULL;

    CVDMetadataCursor * pMetadataCursor = new CVDMetadataCursor();

    if (!pMetadataCursor)
        return E_OUTOFMEMORY;

    pMetadataCursor->m_ulColumns        = ulColumns;
    pMetadataCursor->m_pColumns         = pColumns;
    pMetadataCursor->m_ulMetaColumns    = ulMetaColumns;
    pMetadataCursor->m_pMetaColumns     = pMetaColumns;
    pMetadataCursor->m_pResourceDLL     = pResourceDLL;

    *ppMetadataCursor = pMetadataCursor;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDMetadataCursor::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

    *ppvObjOut = NULL;

    switch (riid.Data1)
    {
        QI_INTERFACE_SUPPORTED((ICursor*)this, IUnknown);
        QI_INTERFACE_SUPPORTED(this, ICursor);
        QI_INTERFACE_SUPPORTED(this, ICursorMove);
        QI_INTERFACE_SUPPORTED(this, ICursorScroll);
		QI_INTERFACE_SUPPORTED(this, ISupportErrorInfo);
    }

    if (NULL == *ppvObjOut)
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef
//
ULONG CVDMetadataCursor::AddRef(void)
{
   return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IUnknown Release
//
ULONG CVDMetadataCursor::Release(void)
{
    if (1 > --m_dwRefCount)
    {
        delete this;
        return 0;
    }

    return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// ICursor methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursor GetColumnsCursor
//=--------------------------------------------------------------------------=
// Creates a cursor containing information about the current cursor
//
// Parameters:
//    riid              - [in]  the interface ID to which to return a pointer
//    ppvColumnsCursor  - [out] a pointer to memory in which to return the
//                              interface pointer
//    pcRows            - [out] a pointer to memory in which to return the
//                              number of rows in the metadata cursor
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL can't create cursor
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_NOINTERFACE interface not available
//
// Notes:
//    This function only succeeds when creating a meta-metadata cursor.
//
HRESULT CVDMetadataCursor::GetColumnsCursor(REFIID riid, IUnknown **ppvColumnsCursor, ULONG *pcRows)
{
    ASSERT_POINTER(ppvColumnsCursor, IUnknown*)
    ASSERT_NULL_OR_POINTER(pcRows, ULONG)

    if (!ppvColumnsCursor)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameters
    *ppvColumnsCursor = NULL;

    if (pcRows)
        *pcRows = 0;

    if (!m_ulMetaColumns)   // can't create meta-meta-metadata cursor
    {
        VDSetErrorInfo(IDS_ERR_CANTCREATEMETACURSOR, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure caller asked for an available interface
    if (riid != IID_IUnknown && riid != IID_ICursor && riid != IID_ICursorMove && riid != IID_ICursorScroll)
    {
        VDSetErrorInfo(IDS_ERR_NOINTERFACE, IID_ICursor, m_pResourceDLL);
        return E_NOINTERFACE;
    }

    // create meta-metadata cursor
    CVDMetadataCursor * pMetadataCursor;

    HRESULT hr = CVDMetadataCursor::Create(m_ulMetaColumns, m_pMetaColumns, 0, 0, &pMetadataCursor, m_pResourceDLL);

    if (FAILED(hr)) // the only reason for failing here is an out of memory condition
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
        return hr;
    }

    *ppvColumnsCursor = (ICursor*)pMetadataCursor;

    if (pcRows)
        *pcRows = m_ulMetaColumns;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursor SetBindings
//=--------------------------------------------------------------------------=
// Replaces the existing column bindings or adds new column bindings to the
// existing ones
//
// Parameters:
//    cCol              - [in] the number of columns to bind
//    rgBoundColumns    - [in] an array of column bindings, one for each
//                             column for which data is to be returned
//    cbRowLength       - [in] the number of bytes of inline memory in a
//                             single row of data
//    dwFlags           - [in] a flag that specifies whether to replace the
//                             existing column bindings or add to them
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              CURSOR_DB_E_BADBINDINFO bad binding information
//              CURSOR_DB_E_COLUMNUNAVAILABLE columnID is not available
//              CURSOR_DB_E_ROWTOOSHORT cbRowLength was less than the minumum (and not zero)
//
// Notes:
//
HRESULT CVDMetadataCursor::SetBindings(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags)
{
    ASSERT_NULL_OR_POINTER(rgBoundColumns, CURSOR_DBCOLUMNBINDING)

    if (!cCol && dwFlags == CURSOR_DBCOLUMNBINDOPTS_ADD)
        return S_OK;

    if (cCol && !rgBoundColumns)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    if (dwFlags != CURSOR_DBCOLUMNBINDOPTS_REPLACE && dwFlags != CURSOR_DBCOLUMNBINDOPTS_ADD)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // make sure the bindings are okay
    ULONG ulColumns = m_ulMetaColumns;
    CVDRowsetColumn * pColumns = m_pMetaColumns;

    if (!pColumns)
    {
        ulColumns = m_ulColumns;
        pColumns = m_pColumns;
    }

    ULONG cbNewRowLength;
    ULONG cbNewVarRowLength;

    HRESULT hr = ValidateCursorBindings(ulColumns, pColumns, cCol, rgBoundColumns, cbRowLength, dwFlags,
        &cbNewRowLength, &cbNewVarRowLength);

    if (SUCCEEDED(hr))  // if so, then set them in cursor
    {
        hr = CVDCursorBase::SetBindings(cCol, rgBoundColumns, cbRowLength, dwFlags);

        if (SUCCEEDED(hr))  // store new row lengths computed during validation
        {
            m_cbRowLength = cbNewRowLength;
            m_cbVarRowLength = cbNewVarRowLength;
        }
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursor GetNextRows
//=--------------------------------------------------------------------------=
// Fetches the specified number of rows starting with the row after the
// current one
//
// Parameters:
//    udlRowsToSkip     - [in]      the number of rows to skip before fetching
//    pFetchParams      - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              CURSOR_DB_S_ENDOFCURSOR reached end of the cursor
//
// Notes:
//
HRESULT CVDMetadataCursor::GetNextRows(LARGE_INTEGER udlRowsToSkip, CURSOR_DBFETCHROWS *pFetchParams)
{
    ASSERT_NULL_OR_POINTER(pFetchParams, CURSOR_DBFETCHROWS)

    // return if caller doesn't supply fetch rows structure
    if (!pFetchParams)
        return S_OK;

    // init out parameter
    pFetchParams->cRowsReturned = 0;

    // return if caller didn't ask for any rows
    if (!pFetchParams->cRowsRequested)
        return S_OK;

    // make sure fetch flags has only valid values
    if (pFetchParams->dwFlags != CURSOR_DBROWFETCH_DEFAULT &&
        pFetchParams->dwFlags != CURSOR_DBROWFETCH_CALLEEALLOCATES &&
        pFetchParams->dwFlags != CURSOR_DBROWFETCH_FORCEREFRESH &&
        pFetchParams->dwFlags != (CURSOR_DBROWFETCH_CALLEEALLOCATES | CURSOR_DBROWFETCH_FORCEREFRESH))
        return CURSOR_DB_E_BADFETCHINFO;

    // if memory was caller allocated, make sure caller supplied data pointer
    if (!(pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES) && !pFetchParams->pData)
        return CURSOR_DB_E_BADFETCHINFO;

    // if memory was caller allocated, make sure caller supplied var-data pointer and size if needed
    if (!(pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES) && m_fNeedVarData &&
        (!pFetchParams->pVarData || !pFetchParams->cbVarData))
        return CURSOR_DB_E_BADFETCHINFO;

    // allocate necessary memory
    if (pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES)
    {
        // inline memory
        pFetchParams->pData = g_pMalloc->Alloc(pFetchParams->cRowsRequested * m_cbRowLength);

        if (!pFetchParams->pData)
        {
			VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
            return E_OUTOFMEMORY;
        }

        if (m_fNeedVarData)
        {
            // out-of-line memory
            pFetchParams->pVarData = g_pMalloc->Alloc(pFetchParams->cRowsRequested * m_cbVarRowLength);

            if (!pFetchParams->pData)
            {
                g_pMalloc->Free(pFetchParams->pData);
                pFetchParams->pData = NULL;
			    VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
                return E_OUTOFMEMORY;
            }
        }
        else
            pFetchParams->pVarData = NULL;
    }

    // fetch data
    HRESULT hrFetch = S_OK;
    CVDRowsetColumn * pColumn;
    CURSOR_DBCOLUMNID cursorColumnID;
    CURSOR_DBCOLUMNBINDING * pCursorBinding;
    BYTE * pData = (BYTE*)pFetchParams->pData;
    BYTE * pVarData = (BYTE*)pFetchParams->pVarData;

    // iterate through rows
    for (ULONG ulRow = 0; ulRow < pFetchParams->cRowsRequested; ulRow++)
    {
        // increment row
        m_lCurrentRow++;

        // make sure we didn't hit end of table
        if (m_lCurrentRow >= (LONG)m_ulColumns)
        {
            m_lCurrentRow = (LONG)m_ulColumns;
            hrFetch = CURSOR_DB_S_ENDOFCURSOR;
            goto DoneFetchingMetaData;
        }

        pCursorBinding = m_pCursorBindings;
        pColumn = &m_pColumns[m_lCurrentRow];

        // iterate through bindings
        for (ULONG ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            cursorColumnID = pCursorBinding->columnID;

            // return requested data
            if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_BINDTYPE))
            {
                pVarData += ReturnData_I4(pColumn->GetBindType(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_COLUMNID))
            {
                pVarData += ReturnData_DBCOLUMNID(pColumn->GetCursorColumnID(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_DATACOLUMN))
            {
                pVarData += ReturnData_BOOL(pColumn->GetDataColumn(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_ENTRYIDMAXLENGTH))
            {
                pVarData += ReturnData_I4(pColumn->GetEntryIDMaxLength(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_FIXED))
            {
                pVarData += ReturnData_BOOL(pColumn->GetFixed(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_MAXLENGTH))
            {
                pVarData += ReturnData_I4(pColumn->GetMaxLength(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_NAME))
            {
                pVarData += ReturnData_LPWSTR(pColumn->GetName(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_NUMBER))
            {
                pVarData += ReturnData_I4(pColumn->GetNumber(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_NULLABLE))
            {
                pVarData += ReturnData_BOOL(pColumn->GetNullable(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_SCALE))
            {
                pVarData += ReturnData_I4(pColumn->GetScale(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_TYPE))
            {
                pVarData += ReturnData_I4(pColumn->GetCursorType(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_UPDATABLE))
            {
                pVarData += ReturnData_I4(pColumn->GetUpdatable(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_UNIQUE))
            {
                pVarData += ReturnData_BOOL(pColumn->GetUnique(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_CASESENSITIVE))
            {
                pVarData += ReturnData_BOOL(pColumn->GetCaseSensitive(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_AUTOINCREMENT))
            {
                pVarData += ReturnData_BOOL(pColumn->GetAutoIncrement(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_HASDEFAULT))
            {
                pVarData += ReturnData_BOOL(pColumn->GetHasDefault(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_COLLATINGORDER))
            {
                pVarData += ReturnData_I4(pColumn->GetCollatingOrder(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_BASENAME))
            {
                pVarData += ReturnData_LPWSTR(pColumn->GetBaseName(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_BASECOLUMNNAME))
            {
                pVarData += ReturnData_LPWSTR(pColumn->GetBaseColumnName(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_DEFAULTVALUE))
            {
                pVarData += ReturnData_LPWSTR(pColumn->GetDefaultValue(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_BMKTEMPORARY))
            {
                pVarData += ReturnData_Bookmark(m_lCurrentRow, pCursorBinding, pData, pVarData);
            }

            pCursorBinding++;
        }

        // increment returned row count
        pFetchParams->cRowsReturned++;
        pData += m_cbRowLength;
    }

DoneFetchingMetaData:
    // cleanup memory allocations if we did not retrieve any rows
    if (pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES && !pFetchParams->cRowsReturned)
    {
        if (pFetchParams->pData)
        {
            g_pMalloc->Free(pFetchParams->pData);
            pFetchParams->pData = NULL;
        }

        if (pFetchParams->pVarData)
        {
            g_pMalloc->Free(pFetchParams->pVarData);
            pFetchParams->pVarData = NULL;
        }
    }

    return hrFetch;
}

//=--------------------------------------------------------------------------=
// ICursor Requery
//=--------------------------------------------------------------------------=
// Repopulates the cursor based on its original definition
//
// Parameters:
//              none
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDMetadataCursor::Requery(void)
{
    m_lCurrentRow = -1;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorMove methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursorMove Move
//=--------------------------------------------------------------------------=
// Moves the current row to a new row within the cursor and optionally fetches
// rows from that new position
//
// Parameters:
//    cbBookmark    - [in]      length in bytes of the bookmark
//    pBookmark     - [in]      a pointer to a bookmark which serves as the
//                              origin for the calculation that determines the
//                              target row
//    dlOffset      - [in]      a signed count of the rows from the origin
//                              bookmark to the target row
//    pFetchParams  - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDMetadataCursor::Move(ULONG cbBookmark, void *pBookmark, LARGE_INTEGER dlOffset, CURSOR_DBFETCHROWS *pFetchParams)
{
    ASSERT_POINTER(pBookmark, BYTE)
    ASSERT_NULL_OR_POINTER(pFetchParams, CURSOR_DBFETCHROWS)

    if (!cbBookmark || !pBookmark)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

	if (!BookmarkToRow(cbBookmark, pBookmark, &m_lCurrentRow))
    {
        VDSetErrorInfo(IDS_ERR_BADBOOKMARK, IID_ICursor, m_pResourceDLL);
        return CURSOR_DB_E_BADBOOKMARK;
    }

    m_lCurrentRow += (LONG)dlOffset.LowPart;

	if (m_lCurrentRow < -1)
	{
		m_lCurrentRow = -1;
		return CURSOR_DB_S_ENDOFCURSOR;
	}
	else
	if (m_lCurrentRow >= (LONG)m_ulColumns)
	{
		m_lCurrentRow = (LONG)m_ulColumns;
		return CURSOR_DB_S_ENDOFCURSOR;
	}

	if (!pFetchParams)
		return S_OK;

	// since get next rows starts from the row after the current row we must
	// back up one row
	m_lCurrentRow--;
	if (m_lCurrentRow < -1)
		m_lCurrentRow	= -1;

    return CVDMetadataCursor::GetNextRows(g_liZero, pFetchParams);
}

//=--------------------------------------------------------------------------=
// ICursorMove GetBookmark
//=--------------------------------------------------------------------------=
// Returns the bookmark of the current row
//
// Parameters:
//    pBookmarkType - [in]  a pointer to the type of bookmark desired
//    cbMaxSize     - [in]  length in bytes of the client buffer to put the
//                          returned bookmark into
//    pcbBookmark   - [out] a pointer to memory in which to return the actual
//                          length of the returned bookmark
//    pBookmark     - [out] a pointer to client buffer to put the returned
//                          bookmark into
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDMetadataCursor::GetBookmark(CURSOR_DBCOLUMNID *pBookmarkType,
									   ULONG cbMaxSize,
									   ULONG *pcbBookmark,
									   void *pBookmark)
{
    ASSERT_POINTER(pBookmarkType, CURSOR_DBCOLUMNID)
    ASSERT_POINTER(pcbBookmark, ULONG)
    ASSERT_POINTER(pBookmark, BYTE)

    if (!pBookmarkType || !pcbBookmark || !pBookmark)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    if (cbMaxSize < sizeof(LONG))
    {
        VDSetErrorInfo(IDS_ERR_BUFFERTOOSMALL, IID_ICursor, m_pResourceDLL);
        return CURSOR_DB_E_BUFFERTOOSMALL;
    }

	RowToBookmark(m_lCurrentRow, pcbBookmark, pBookmark);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorMove Clone
//=--------------------------------------------------------------------------=
// Returns a clone of the cursor
//
// Parameters:
//    dwFlags           - [in]  a flag that specifies the clone options
//    riid              - [in]  the interface desired for the returned clone
//    ppvClonedCursor   - [out] a pointer to memory in which to return newly
//                              created clone pointer
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDMetadataCursor::Clone(DWORD dwFlags, REFIID riid, IUnknown **ppvClonedCursor)
{

    CVDMetadataCursor * pMetaCursor = 0;

	HRESULT hr = CVDMetadataCursor::Create(m_ulColumns,
										m_pColumns,
										m_ulMetaColumns,
										m_pMetaColumns,
										&pMetaCursor,
										m_pResourceDLL);

    *ppvClonedCursor = (ICursor*)pMetaCursor;

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorScroll methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursorScroll Scroll
//=--------------------------------------------------------------------------=
// Moves the current row to a new row within the cursor, specified as a
// fraction, and optionally fetches rows from that new position
//
// Parameters:
//    ulNumerator   - [in]      the numerator of the fraction that states the
//                              position to scroll to in the cursor
//    ulDenominator - [in]      the denominator of that same fraction
//    pFetchParams  - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              CURSOR_DB_E_BADFRACTION - bad fraction
//
// Notes:
//
HRESULT CVDMetadataCursor::Scroll(ULONG ulNumerator, ULONG ulDenominator, CURSOR_DBFETCHROWS *pFetchParams)
{
    ASSERT_NULL_OR_POINTER(pFetchParams, CURSOR_DBFETCHROWS)

    if (!ulDenominator) // division by zero is a bad thing!
    {
        // this is a Viaduct1 error message, which doesn't really apply
        VDSetErrorInfo(IDS_ERR_BADFRACTION, IID_ICursor, m_pResourceDLL);
        return CURSOR_DB_E_BADFRACTION;
    }

    m_lCurrentRow = (LONG)((ulNumerator * m_ulColumns) / ulDenominator);

	if (m_lCurrentRow >= (LONG)m_ulColumns)
		m_lCurrentRow = (LONG)m_ulColumns - 1;

	if (!pFetchParams)
		return S_OK;

	// since get next rows starts from the row after the current row we must
	// back up one row
	m_lCurrentRow--;
	if (m_lCurrentRow < -1)
		m_lCurrentRow = -1;

    return CVDMetadataCursor::GetNextRows(g_liZero, pFetchParams);
}

//=--------------------------------------------------------------------------=
// ICursorScroll GetApproximatePosition
//=--------------------------------------------------------------------------=
// Returns the approximate location of a bookmark within the cursor, specified
// as a fraction
//
// Parameters:
//    cbBookmark        - [in]  length in bytes of the bookmark
//    pBookmark         - [in]  a pointer to the bookmark
//    pulNumerator      - [out] a pointer to memory in which to return the
//                              numerator of the faction that defines the
//                              approximate position of the bookmark
//    pulDenominator    - [out] a pointer to memory in which to return the
//                              denominator of that same faction
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDMetadataCursor::GetApproximatePosition(ULONG cbBookmark, void *pBookmark, ULONG *pulNumerator, ULONG *pulDenominator)
{
    ASSERT_POINTER(pBookmark, BYTE)
    ASSERT_POINTER(pulNumerator, ULONG)
    ASSERT_POINTER(pulDenominator, ULONG)

    if (!pBookmark || !pulNumerator || !pulDenominator)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

	LONG lRow;

	if (!BookmarkToRow(cbBookmark, pBookmark, &lRow))
    {
        VDSetErrorInfo(IDS_ERR_BADBOOKMARK, IID_ICursor, m_pResourceDLL);
        return CURSOR_DB_E_BADBOOKMARK;
    }

    *pulNumerator = lRow + 1;
    *pulDenominator = m_ulColumns ? m_ulColumns : 1;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorScroll GetApproximateCount
//=--------------------------------------------------------------------------=
// Returns the approximate number of rows in the cursor
//
// Parameters:
//    pudlApproxCount       - [out] a pointer to a buffer containing the
//                                  returned approximate count of the rows
//                                  in the cursor
//    pdwFullyPopuldated    - [out] a pointer to a buffer containing returned
//                                  flags indicating whether the cursor is fully
//                                  populated
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDMetadataCursor::GetApproximateCount(LARGE_INTEGER *pudlApproxCount, DWORD *pdwFullyPopulated)
{
    ASSERT_POINTER(pudlApproxCount, LARGE_INTEGER)
    ASSERT_NULL_OR_POINTER(pdwFullyPopulated, DWORD)

    if (!pudlApproxCount)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    pudlApproxCount->HighPart = 0;
    pudlApproxCount->LowPart  = m_ulColumns;

    if (pdwFullyPopulated)
        *pdwFullyPopulated = CURSOR_DBCURSORPOPULATED_FULLY;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\curspos.cpp ===
//---------------------------------------------------------------------------
// CursorPosition.cpp : CursorPosition implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"
#include "ColUpdat.h"
#include "CursPos.h"
#include "fastguid.h"
#include "MSR2C.h"
#include "resource.h"

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDCursorPosition - Constructor
//
CVDCursorPosition::CVDCursorPosition()
{
    m_pCursorMain       = NULL;
	m_pRowPosition		= NULL;
    m_pSameRowClone     = NULL;
    m_dwEditMode        = CURSOR_DBEDITMODE_NONE;
    m_ppColumnUpdates   = NULL;
	m_fTempEditMode		= FALSE;
	m_fConnected		= FALSE;
	m_dwAdviseCookie	= 0;
	m_fPassivated	    = FALSE;
	m_fInternalSetRow	= FALSE;

#ifdef _DEBUG
    g_cVDCursorPositionCreated++;
#endif
}

//=--------------------------------------------------------------------------=
// ~CVDCursorPosition - Destructor
//
CVDCursorPosition::~CVDCursorPosition()
{
	Passivate();

#ifdef _DEBUG
    g_cVDCursorPositionDestroyed++;
#endif
}

//=--------------------------------------------------------------------------=
// Pasivate when external ref count gets to zero
//
void CVDCursorPosition::Passivate()
{
	if (m_fPassivated)
		return;

	m_fPassivated = TRUE;

    DestroyColumnUpdates();
	ReleaseCurrentRow();
    ReleaseAddRow();

	LeaveFamily(); // remove myself from pCursorMain's notification family

	if (m_pCursorMain)
	    m_pCursorMain->Release();   // release associated cursor main object

	if (m_fConnected)
		DisconnectIRowPositionChange();	// disconnect IRowPosition change

	if (m_pRowPosition)
		m_pRowPosition->Release();	// release associated row position
}

//=--------------------------------------------------------------------------=
// Create - Create cursor position object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new cursor position object
//
// Parameters:
//    pRowPosition		- [in]  IRowPosition provider (may be NULL)
//    pCursorMain       - [in]  backwards pointer to CVDCursorMain object
//    ppCursorPosition  - [out] a pointer in which to return pointer to cursor position object
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDCursorPosition::Create(IRowPosition * pRowPosition,
								  CVDCursorMain * pCursorMain,
								  CVDCursorPosition ** ppCursorPosition,
								  CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pCursorMain, CVDCursorMain)
    ASSERT_POINTER(ppCursorPosition, CVDCursorPosition*)

    if (!pCursorMain || !ppCursorPosition)
	{
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorMove, pResourceDLL);
        return E_INVALIDARG;
	}

    *ppCursorPosition = NULL;

    CVDCursorPosition * pCursorPosition = new CVDCursorPosition();

    if (!pCursorPosition)
	{
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursorMove, pResourceDLL);
        return E_OUTOFMEMORY;
	}

    pCursorPosition->m_pResourceDLL	= pResourceDLL;
	pCursorPosition->m_pCursorMain	= pCursorMain;
	pCursorPosition->m_pRowPosition = pRowPosition;

    pCursorMain->AddRef();  // add reference to associated cursor main object

	if (pRowPosition)	// add reference to associated row position (if needed)
	{
		pRowPosition->AddRef();	

		// connect IRowPositionChange
		HRESULT hr = pCursorPosition->ConnectIRowPositionChange();

		if (SUCCEEDED(hr))
			pCursorPosition->m_fConnected = TRUE;
	}

	// add to pCursorMain's notification family
	pCursorPosition->JoinFamily(pCursorMain);

	pCursorPosition->PositionToFirstRow();
	
    *ppCursorPosition = pCursorPosition;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CreateColumnUpdates - Create array of column update pointers
//
HRESULT CVDCursorPosition::CreateColumnUpdates()
{
    const ULONG ulColumns = m_pCursorMain->GetColumnsCount();

    m_ppColumnUpdates = new CVDColumnUpdate*[ulColumns];

    if (!m_ppColumnUpdates)
    {
    	VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_OUTOFMEMORY;
    }

    // set all column update pointers to NULL
    memset(m_ppColumnUpdates, 0, ulColumns * sizeof(CVDColumnUpdate*));

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ResetColumnUpdates - Reset column updates array
//
HRESULT CVDCursorPosition::ResetColumnUpdates()
{
    HRESULT hr = S_OK;

    if (m_ppColumnUpdates)
    {
        const ULONG ulColumns = m_pCursorMain->GetColumnsCount();

        // set all column update pointers to NULL
        for (ULONG ulCol = 0; ulCol < ulColumns; ulCol++)
            SetColumnUpdate(ulCol, NULL);
    }
    else
    {
        // create array of column update pointers
        hr = CreateColumnUpdates();
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// DestroyColumnUpdates - Destroy column updates and array of update pointers
//
void CVDCursorPosition::DestroyColumnUpdates()
{
    if (m_ppColumnUpdates)
    {
        // set all column update pointers to NULL
        ResetColumnUpdates();

        // destroy array of column update pointers
        delete [] m_ppColumnUpdates;
        m_ppColumnUpdates = NULL;
    }
}

//=--------------------------------------------------------------------------=
// GetColumnUpdate - Get column update
//
CVDColumnUpdate * CVDCursorPosition::GetColumnUpdate(ULONG ulColumn) const
{
    CVDColumnUpdate * pColumnUpdate = NULL;

    const ULONG ulColumns = m_pCursorMain->GetColumnsCount();

    // make sure column index is in range
    if (ulColumn < ulColumns)
        pColumnUpdate = m_ppColumnUpdates[ulColumn];

    return pColumnUpdate;
}

//=--------------------------------------------------------------------------=
// SetColumnUpdate - Set column update
//
void CVDCursorPosition::SetColumnUpdate(ULONG ulColumn, CVDColumnUpdate * pColumnUpdate)
{
    const ULONG ulColumns = m_pCursorMain->GetColumnsCount();

    // make sure column index is in range
    if (ulColumn < ulColumns)
    {
        // release update if it already exists
        if (m_ppColumnUpdates[ulColumn])
            m_ppColumnUpdates[ulColumn]->Release();

        // store new column update
        m_ppColumnUpdates[ulColumn] = pColumnUpdate;
    }
}

//=--------------------------------------------------------------------------=
// PositionToFirstRow
//=--------------------------------------------------------------------------=
// Positions to the first row in the rowset
//
void CVDCursorPosition::PositionToFirstRow()
{
	m_bmCurrent.Reset();

	ULONG cRowsObtained = 0;
	HROW * rghRows = NULL;
	BYTE bSpecialBM;
	bSpecialBM			= DBBMK_FIRST;
	HRESULT hr = GetRowsetSource()->GetRowsetLocate()->GetRowsAt(0, 0, sizeof(BYTE), &bSpecialBM, 0,
															1, &cRowsObtained, &rghRows);

	if (cRowsObtained)
	{
		// set current row to first row
		SetCurrentHRow(rghRows[0]);
		// release hRows and associated memory
		GetRowsetSource()->GetRowset()->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);
		g_pMalloc->Free(rghRows);
	}

}

//=--------------------------------------------------------------------------=
// ReleaseCurrentRow
//=--------------------------------------------------------------------------=
// Releases old current row
//
void CVDCursorPosition::ReleaseCurrentRow()
{
    if (!GetRowsetSource()->IsRowsetValid()		||
		m_bmCurrent.GetStatus() != VDBOOKMARKSTATUS_CURRENT)
		return;

    if (m_bmCurrent.m_hRow)
    {
	    GetRowsetSource()->GetRowset()->ReleaseRows(1, &m_bmCurrent.m_hRow, NULL, NULL, NULL);
    	m_bmCurrent.m_hRow = NULL;
    }
}

//=--------------------------------------------------------------------------=
// ReleaseAddRow
//=--------------------------------------------------------------------------=
// Releases temporary add row
//
void CVDCursorPosition::ReleaseAddRow()
{
    if (!GetRowsetSource()->IsRowsetValid())
		return;

    if (m_bmAddRow.m_hRow)
    {
	    GetRowsetSource()->GetRowset()->ReleaseRows(1, &m_bmAddRow.m_hRow, NULL, NULL, NULL);
	    m_bmAddRow.m_hRow = NULL;
    }
}

//=--------------------------------------------------------------------------=
// SetCurrentRowStatus
//=--------------------------------------------------------------------------=
// Sets status to beginning or end (releasing current hrow)
//
void CVDCursorPosition::SetCurrentRowStatus(WORD wStatus)
{
	if (VDBOOKMARKSTATUS_BEGINNING  == wStatus  ||
		VDBOOKMARKSTATUS_END		== wStatus)
	{
		ReleaseCurrentRow();
		m_bmCurrent.SetBookmark(wStatus);
	}
}

//=--------------------------------------------------------------------------=
// SetCurrentHRow
//=--------------------------------------------------------------------------=
// Reads the bookmark from the hrow and sets the m_bmCurrent
//
// Parameters:
//    hRowNew       - [in]  hrow of new current row
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDCursorPosition::SetCurrentHRow(HROW hRowNew)
{
    if (!GetRowsetSource()->IsRowsetValid())
	{
		VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
		return E_FAIL;
	}

	IRowset * pRowset = GetRowsetSource()->GetRowset();

	// allocate buffer for bookmark plus length indicator
	BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];

	if (!pBuff)
    {
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
		return E_OUTOFMEMORY;
	}

	// get the bookmark data
	HRESULT hr = pRowset->GetData(hRowNew,
								  GetCursorMain()->GetBookmarkAccessor(),
								  pBuff);
	if (S_OK == hr)
	{
		ReleaseCurrentRow();
		pRowset->AddRefRows(1, &hRowNew, NULL, NULL);
		ULONG * pulLen = (ULONG*)pBuff;
		BYTE * pbmdata = pBuff + sizeof(ULONG);
		m_bmCurrent.SetBookmark(VDBOOKMARKSTATUS_CURRENT, hRowNew, pbmdata, *pulLen);
	}
	else
	{
		ASSERT_(FALSE);
		hr = VDMapRowsetHRtoCursorHR(hr,
									 IDS_ERR_GETDATAFAILED,
									 IID_ICursorMove,
									 pRowset,
									 IID_IRowset,
									 m_pResourceDLL);
	}

	delete [] pBuff;

	return hr;

}

//=--------------------------------------------------------------------------=
// IsSameRowAsCurrent - Compares current bookmark to supplied hrow
//=--------------------------------------------------------------------------=
//
// Parameters:
//    hRow				- [in]	hrow to check
//    fCacheIfNotSame	- [in]	If TRUE same hrow in cached CVDBookmark
//
// Output:
//    HRESULT   - S_OK if both hrows correspond to the same logical row
//				  S_FALSE if not same row
//				  E_INVALIDARG
//				  E_UNEXPECTED
//				  DB_E_BADROWHANDLE
//				  DB_E_DELETEDROW
//				  DB_E_NEWLYINSERTED
//
// Notes:
//

HRESULT CVDCursorPosition::IsSameRowAsCurrent(HROW hRow, BOOL fCacheIfNotSame)		
{

	if (!GetRowsetSource()->IsRowsetValid())
	{
		VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
		return E_FAIL;
	}

	if (m_bmCurrent.IsSameHRow(hRow))
		return S_OK;

	HRESULT hrSame = S_FALSE;

	IRowsetIdentity * pRowsetIdentity = GetRowsetSource()->GetRowsetIdentity();

	if (pRowsetIdentity)
	{
		hrSame = pRowsetIdentity->IsSameRow(hRow, m_bmCurrent.GetHRow());
		// return if hrow matches or not cache flag set
		if (S_OK == hrSame || !fCacheIfNotSame)
			return hrSame;
	}
	else
	if (fCacheIfNotSame)
	{
		// check if hRow matches cache
		if (m_bmCache.IsSameHRow(hRow))
		{
			// return TRUE if bookmark matches cache
			return m_bmCurrent.IsSameBookmark(&m_bmCache) ? S_OK : S_FALSE;
		}
	}

	// allocate buffer for bookmark plus length indicator
	BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];

	if (!pBuff)
    {
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
		return E_OUTOFMEMORY;
	}

	// get the bookmark data
	HRESULT hrWork = GetRowsetSource()->GetRowset()->GetData(hRow, GetCursorMain()->GetBookmarkAccessor(), pBuff);

	if (S_OK == hrWork)
	{
		ULONG * pulLen = (ULONG*)pBuff;
		BYTE * pbmdata = pBuff + sizeof(ULONG);
		// if IRowsetIdentity isn't supported, compare bookmarks
		if (!pRowsetIdentity)
		{
			DBCOMPARE dbcompare;
			hrWork = GetRowsetSource()->GetRowsetLocate()->Compare(0,
											m_bmCurrent.GetBookmarkLen(),
											m_bmCurrent.GetBookmark(),
											*pulLen,
											pbmdata,
											&dbcompare);
			if (SUCCEEDED(hrWork))
			{
				if (DBCOMPARE_EQ == dbcompare)
					hrSame = S_OK;
				else
					hrSame = S_FALSE;
			}
		}
		if (fCacheIfNotSame && S_OK != hrSame)
			m_bmCache.SetBookmark(VDBOOKMARKSTATUS_CURRENT, hRow, pbmdata, *pulLen);
	}
	else
		hrSame = hrWork;

	delete [] pBuff;

	return hrSame;

}

//=--------------------------------------------------------------------------=
// IsSameRowAsAddRow - Compares addrow bookmark to supplied hrow 
//=--------------------------------------------------------------------------=
//
// Parameters:
//    hRow				- [in]	hrow to check
//
// Output:
//    HRESULT   - S_OK if both hrows correspond to the same logical row
//				  S_FALSE if not same row
//				  E_INVALIDARG 
//				  E_UNEXPECTED
//				  DB_E_BADROWHANDLE
//				  DB_E_DELETEDROW
//				  DB_E_NEWLYINSERTED
//
// Notes:
//

HRESULT CVDCursorPosition::IsSameRowAsNew(HROW hRow)		
{

	if (!GetRowsetSource()->IsRowsetValid())
	{
		VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
		return E_FAIL;
	}

	if (m_bmAddRow.IsSameHRow(hRow))
		return S_OK;

    if (m_bmAddRow.m_hRow == NULL)
        return S_FALSE;

	HRESULT hrSame = S_FALSE;

	IRowsetIdentity * pRowsetIdentity = GetRowsetSource()->GetRowsetIdentity();

	if (pRowsetIdentity)
	{
		hrSame = pRowsetIdentity->IsSameRow(hRow, m_bmAddRow.GetHRow());
		// return result
		return hrSame;
	}

	// allocate buffer for bookmark plus length indicator
	BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];

	if (!pBuff)
    {
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
		return E_OUTOFMEMORY;
	}

	// get the bookmark data
	HRESULT hrWork = GetRowsetSource()->GetRowset()->GetData(hRow, GetCursorMain()->GetBookmarkAccessor(), pBuff);

	if (S_OK == hrWork)
	{
		ULONG * pulLen = (ULONG*)pBuff;
		BYTE * pbmdata = pBuff + sizeof(ULONG);

		// since IRowsetIdentity isn't supported, compare bookmarks
		DBCOMPARE dbcompare;
		hrWork = GetRowsetSource()->GetRowsetLocate()->Compare(0,
										m_bmAddRow.GetBookmarkLen(),
										m_bmAddRow.GetBookmark(),
										*pulLen,
										pbmdata,
										&dbcompare);
		if (SUCCEEDED(hrWork))
		{
			if (DBCOMPARE_EQ == dbcompare)
				hrSame = S_OK;
			else
				hrSame = S_FALSE;
		}
	}
	else
		hrSame = hrWork;

	delete [] pBuff;

	return hrSame;

}


//=--------------------------------------------------------------------------=
// SetAddHRow
//=--------------------------------------------------------------------------=
// Reads the bookmark from the hrow and sets the m_bmAddRow
//
// Parameters:
//    hRowNew       - [in]  hrow of new add row
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDCursorPosition::SetAddHRow(HROW hRowNew)
{
    if (!GetRowsetSource()->IsRowsetValid())
	{
		VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
		return E_FAIL;
	}

	IRowset * pRowset = GetRowsetSource()->GetRowset();

	// allocate buffer for bookmark plus length indicator
	BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];

	if (!pBuff)
    {
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
		return E_OUTOFMEMORY;
	}

	// get the bookmark data
	HRESULT hr = pRowset->GetData(hRowNew,
								  GetCursorMain()->GetBookmarkAccessor(),
								  pBuff);
	if (S_OK == hr)
	{
		ReleaseAddRow();
		pRowset->AddRefRows(1, &hRowNew, NULL, NULL);
		ULONG * pulLen = (ULONG*)pBuff;
		BYTE * pbmdata = pBuff + sizeof(ULONG);
		m_bmAddRow.SetBookmark(VDBOOKMARKSTATUS_CURRENT, hRowNew, pbmdata, *pulLen);
	}
	else
	{
		ASSERT_(FALSE);
		hr = VDMapRowsetHRtoCursorHR(hr,
									 IDS_ERR_GETDATAFAILED,
									 IID_ICursorMove,
									 pRowset,
									 IID_IRowset,
									 m_pResourceDLL);
	}

	delete [] pBuff;

	return hr;

}

//=--------------------------------------------------------------------------=
// GetEditRow - Get hRow of the row currently being edited
//
HROW CVDCursorPosition::GetEditRow() const
{
    HROW hRow = NULL;

    switch (m_dwEditMode)
    {
        case CURSOR_DBEDITMODE_UPDATE:
            hRow = m_bmCurrent.m_hRow;
            break;

        case CURSOR_DBEDITMODE_ADD:
            hRow = m_bmAddRow.m_hRow;
            break;
    }

    return hRow;
}

//=--------------------------------------------------------------------------=
// SetRowPosition - Set new current hRow
//
HRESULT CVDCursorPosition::SetRowPosition(HROW hRow)
{
	if (!m_pRowPosition)
		return S_OK;

    // set new current row (set/clear internal set row flag)
	m_fInternalSetRow = TRUE;

	HRESULT hr = m_pRowPosition->ClearRowPosition();

	if (SUCCEEDED(hr))
		hr = m_pRowPosition->SetRowPosition(NULL, hRow, DBPOSITION_OK);

	m_fInternalSetRow = FALSE;

	return hr;
}

#ifndef VD_DONT_IMPLEMENT_ISTREAM

//=--------------------------------------------------------------------------=
// UpdateEntryIDStream - Update entry identifier from stream
//=--------------------------------------------------------------------------=
// This function updates the entry identifier's data from stream
//
// Parameters:
//  pColumn     - [in] rowset column pointer
//  hRow        - [in] the row handle
//  pStream     - [in] stream pointer
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//
HRESULT CVDCursorPosition::UpdateEntryIDStream(CVDRowsetColumn * pColumn, HROW hRow, IStream * pStream)
{
    ASSERT_POINTER(pStream, IStream)

	IAccessor * pAccessor = GetCursorMain()->GetAccessor();
	IRowsetChange * pRowsetChange = GetCursorMain()->GetRowsetChange();

    // make sure we have valid accessor and change pointers
    if (!pAccessor || !pRowsetChange || !GetCursorMain()->IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pColumn || !pStream)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    STATSTG statstg;

    // retrieve status structure
    HRESULT hr = pStream->Stat(&statstg, STATFLAG_NONAME);

    if (FAILED(hr))
    {
        VDSetErrorInfo(IDS_ERR_STATFAILED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // determine length of data
    ULONG cbData = statstg.cbSize.LowPart;

    HGLOBAL hData;

    // get handle to data
    hr = GetHGlobalFromStream(pStream, &hData);

    if (FAILED(hr))
        return hr;

    // get pointer to data
    BYTE * pData = (BYTE*)GlobalLock(hData);

    DBBINDING binding;

    // clear out binding
    memset(&binding, 0, sizeof(DBBINDING));

    // create value binding
    binding.iOrdinal    = pColumn->GetOrdinal();
    binding.obValue     = sizeof(DBSTATUS) + sizeof(ULONG);
    binding.obLength    = sizeof(DBSTATUS);
    binding.obStatus    = 0;
    binding.dwPart      = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
    binding.dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
    binding.cbMaxLen    = cbData;
    binding.wType       = DBTYPE_BYREF | DBTYPE_BYTES;

    HACCESSOR hAccessor;

    // create update accessor
    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_IEntryID, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
    {
        // release pointer to data
        GlobalUnlock(hData);
        return hr;
    }

    // create update buffer
    BYTE * pBuffer = new BYTE[sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(LPBYTE)];

    if (!pBuffer)
    {
        // release pointer to data
        GlobalUnlock(hData);

        // release update accessor
        pAccessor->ReleaseAccessor(hAccessor, NULL);

        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_IEntryID, m_pResourceDLL);
        return E_OUTOFMEMORY;
    }

    // set status, length and value
    *(DBSTATUS*)pBuffer = DBSTATUS_S_OK;
    *(ULONG*)(pBuffer + sizeof(DBSTATUS)) = cbData;
    *(LPBYTE*)(pBuffer + sizeof(DBSTATUS) + sizeof(ULONG)) = pData;

    // modify column
    hr = pRowsetChange->SetData(hRow, hAccessor, pBuffer);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_SETDATAFAILED, IID_IEntryID, pRowsetChange, IID_IRowsetChange,
        m_pResourceDLL);

    // release pointer to data
    GlobalUnlock(hData);

    // release update accessor
    pAccessor->ReleaseAccessor(hAccessor, NULL);

    // destroy update buffer
    delete [] pBuffer;

    return hr;
}

#endif //VD_DONT_IMPLEMENT_ISTREAM

//=--------------------------------------------------------------------------=
// ReleaseSameRowClone - Release same-row clone, if we still have one
//
void CVDCursorPosition::ReleaseSameRowClone()
{
    if (m_pSameRowClone)
    {
        // must be set to NULL before release
        ICursor * pSameRowClone = m_pSameRowClone;
        m_pSameRowClone = NULL;

        pSameRowClone->Release();
    }
}

//=--------------------------------------------------------------------------=
// IRowsetNotify Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IRowsetNotify OnFieldChange
//=--------------------------------------------------------------------------=
// This function is called on any change to the value of a field
//
// Parameters:
//    pRowset       - [in]  the IRowset that is generating the notification
//							(we can ignore this since we are only ever dealing
//							with a single rowset).
//    hRow          - [in]  the HROW of the row in which the field value has
//							changed
//    cColumns      - [in]  the count of columns in rgColumns
//    rgColumns     - [in]  an array of column (ordinal positions) in the row
//							for which the value has changed
//    eReason       - [in]  the kind of action which caused this change
//    ePhase        - [in]  the phase of this notification
//    fCantDeny     - [in]  when this flag is set to TRUE, the consumer cannot
//							veto the event (by returning S_FALSE)
//
// Output:
//    HRESULT - S_OK if successful
//				S_FALSE the event/phase is vetoed
//              DB_S_UNWANTEDPHASE
//              DB_S_UNWANTEDREASON
//
// Notes:
//
HRESULT CVDCursorPosition::OnFieldChange(IUnknown *pRowset,
									   HROW hRow,
									   ULONG cColumns,
									   ULONG rgColumns[],
									   DBREASON eReason,
									   DBEVENTPHASE ePhase,
									   BOOL fCantDeny)
{
	// make sure rowset is valid
	if (!GetRowsetSource()->IsRowsetValid())
		return S_OK;

	// check for columns
	if (0 == cColumns)
		return S_OK;

	// check for known reasons
	if (eReason != DBREASON_COLUMN_SET && eReason != DBREASON_COLUMN_RECALCULATED)
		return S_OK;

	HRESULT hr = S_OK;

	// send edit mode notification if needed
	if (ePhase == DBEVENTPHASE_OKTODO && m_dwEditMode == CURSOR_DBEDITMODE_NONE)
	{
		// setup notification structures
   		DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
							CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;

		CURSOR_DBNOTIFYREASON rgReasons[1];
		VariantInit((VARIANT*)&rgReasons[0].arg1);
		VariantInit((VARIANT*)&rgReasons[0].arg2);

    	rgReasons[0].dwReason = CURSOR_DBREASON_EDIT;

		// notify other interested parties of action
		hr = NotifyBefore(dwEventWhat, 1, rgReasons);

		if (hr == S_OK)	
		{
			// notify other interested parties of success
			NotifyAfter(dwEventWhat, 1, rgReasons);

			// temporarily place cursor into edit mode
			m_fTempEditMode = TRUE;
		}
		else
		{
			// notify other interested parties of failure
			NotifyFail(dwEventWhat, 1, rgReasons);
		}
	}
	
	// sent set column notifications
	if (hr == S_OK && (ePhase == DBEVENTPHASE_OKTODO || 
					   ePhase == DBEVENTPHASE_DIDEVENT || 
					   ePhase == DBEVENTPHASE_FAILEDTODO))
	{
		// setup notification structures
		DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;

		CURSOR_DBNOTIFYREASON rgReasons[1];
		VariantInit((VARIANT*)&rgReasons[0].arg1);
		VariantInit((VARIANT*)&rgReasons[0].arg2);

		switch (eReason)
		{
			case DBREASON_COLUMN_SET:
				rgReasons[0].dwReason = CURSOR_DBREASON_SETCOLUMN;
				break;

			case DBREASON_COLUMN_RECALCULATED:
				rgReasons[0].dwReason = CURSOR_DBREASON_RECALC;
				break;
		}

		// get internal column pointers
		ULONG ulColumns = m_pCursorMain->GetColumnsCount();
		CVDRowsetColumn * pColumn = m_pCursorMain->InternalGetColumns();

		for (ULONG ulCol = 0; ulCol < cColumns; ulCol++)
		{
			// determine which column is changing
			for (ULONG ulRSCol = 0; ulRSCol < ulColumns; ulRSCol++)
			{
				if (pColumn[ulRSCol].GetOrdinal() == rgColumns[ulCol])
				{
					rgReasons[0].arg1.vt   = VT_I4;
					rgReasons[0].arg1.lVal = ulRSCol;
				}
			}

			HRESULT hrNotify = S_OK;

			// notify other interested parties
			switch (ePhase)
			{
				case DBEVENTPHASE_OKTODO:
					hrNotify = NotifyBefore(dwEventWhat, 1, rgReasons);
					break;

				case DBEVENTPHASE_DIDEVENT:
					NotifyAfter(dwEventWhat, 1, rgReasons);
					break;

				case DBEVENTPHASE_FAILEDTODO:
					NotifyFail(dwEventWhat, 1, rgReasons);
					break;
			}

			if (hrNotify != S_OK)
				hr = S_FALSE;
		}
	}

	// take cursor out of edit mode if we placed it into that mode (success)
	if (ePhase == DBEVENTPHASE_DIDEVENT && m_fTempEditMode)
	{
		// setup notification structures
   		DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
							CURSOR_DBEVENT_NONCURRENT_ROW_DATA_CHANGED |
							CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;

		CURSOR_DBNOTIFYREASON rgReasons[1];
		VariantInit((VARIANT*)&rgReasons[0].arg1);
		VariantInit((VARIANT*)&rgReasons[0].arg2);

		rgReasons[0].dwReason   = CURSOR_DBREASON_MODIFIED;
		
		// notify other interested parties of action
		NotifyBefore(dwEventWhat, 1, rgReasons);
		NotifyAfter(dwEventWhat, 1, rgReasons);

		// take out of edit mode
		m_fTempEditMode = FALSE;
	}

	// take cursor out of edit mode if we placed it into that mode (failure)
	if (ePhase == DBEVENTPHASE_FAILEDTODO && m_fTempEditMode)
	{
		// setup notification structures
		DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;

		CURSOR_DBNOTIFYREASON rgReasons[1];
		VariantInit((VARIANT*)&rgReasons[0].arg1);
		VariantInit((VARIANT*)&rgReasons[0].arg2);

		rgReasons[0].dwReason = CURSOR_DBREASON_CANCELUPDATE;

		// notify other interested parties of action
		NotifyBefore(dwEventWhat, 1, rgReasons);
		NotifyAfter(dwEventWhat, 1, rgReasons);

		// take out of edit mode
		m_fTempEditMode = FALSE;
	}

	// reset cache on ending phase
	if (DBEVENTPHASE_FAILEDTODO == ePhase ||
		DBEVENTPHASE_DIDEVENT	== ePhase)
		m_bmCache.Reset();

	return hr;
}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowChange
//=--------------------------------------------------------------------------=
// This function is called on the first change to a row, or any whole-row change
//
// Parameters:
//    pRowset       - [in]  the IRowset that is generating the notification
//							(we can ignore this since we are only ever dealing
//							with a single rowset).
//    cRows         - [in]  the count of HROWs in rghRows
//    rghRows       - [in]  an array of HROWs which are changing
//    eReason       - [in]  the kind of action which caused this change
//    ePhase        - [in]  the phase of this notification
//    fCantDeny     - [in]  when this flag is set to TRUE, the consumer cannot
//							veto the event (by returning S_FALSE)
//
// Output:
//    HRESULT - S_OK if successful
//				S_FALSE the event/phase is vetoed
//              DB_S_UNWANTEDPHASE
//              DB_S_UNWANTEDREASON
//
// Notes:
//
HRESULT CVDCursorPosition::OnRowChange(IUnknown *pRowset,
									 ULONG cRows,
									 const HROW rghRows[],
									 DBREASON eReason,
									 DBEVENTPHASE ePhase,
									 BOOL fCantDeny)
{
    // make sure we still have a valid rowset
	if (!(GetRowsetSource()->IsRowsetValid()))
		return S_OK;

	// check for rows
	if (0 == cRows)
		return S_OK;

	// filter notifications
	switch (eReason)
	{
		case DBREASON_ROW_DELETE:
		case DBREASON_ROW_INSERT:
		case DBREASON_ROW_RESYNCH:
		case DBREASON_ROW_UPDATE:
		case DBREASON_ROW_UNDOCHANGE:
		case DBREASON_ROW_UNDOINSERT:
			break;

// the following do not generate notifications
//
//		case DBREASON_ROW_ACTIVATE:
//		case DBREASON_ROW_RELEASE:
//		case DBREASON_ROW_FIRSTCHANGE:
//		case DBREASON_ROW_UNDODELETE:

		default:
			return S_OK;
	}

	// create variables
	DWORD dwEventWhat = 0;
	CURSOR_DBNOTIFYREASON * pReasons = (CURSOR_DBNOTIFYREASON *)g_pMalloc->Alloc(cRows * sizeof(CURSOR_DBNOTIFYREASON));

	if (!pReasons)
		return S_OK;

    memset(pReasons, 0, cRows * sizeof(CURSOR_DBNOTIFYREASON));

	HRESULT hr;
	BOOL fCurrentRow;

	// iterate through supplied rows
	for (ULONG ul = 0; ul < cRows; ul++)
	{
		if (eReason != DBREASON_ROW_UNDOINSERT)
		{
			// check to see if this row is current
			hr = IsSameRowAsCurrent(rghRows[ul], TRUE);

			switch (hr)
			{
				case S_OK:
					fCurrentRow = TRUE;
    				pReasons[ul].arg1 = m_bmCurrent.GetBookmarkVariant();
					break;
				case S_FALSE:
					fCurrentRow = FALSE;
    				pReasons[ul].arg1 = m_bmCache.GetBookmarkVariant();
					break;
				default:
					hr = S_OK;
					goto cleanup;
			}
		}
		else
		{
			// check to see of this row is current add-row
			if (m_dwEditMode == CURSOR_DBEDITMODE_ADD)
				hr = IsSameRowAsNew(rghRows[ul]);
			else
				hr = E_FAIL;

			switch (hr)
			{
				case S_OK:
					fCurrentRow = TRUE;
    				pReasons[ul].arg1 = m_bmAddRow.GetBookmarkVariant();
					break;
				default:
					hr = S_OK;
					goto cleanup;
			}
		}

		// setup variables
		switch (eReason)
		{
			case DBREASON_ROW_DELETE:
				if (fCurrentRow)
					dwEventWhat |=	CURSOR_DBEVENT_CURRENT_ROW_CHANGED |
									CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
									CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				else
					dwEventWhat |=	CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_DELETED;
				break;
			
			case DBREASON_ROW_INSERT:
				if (fCurrentRow)
					dwEventWhat |=	CURSOR_DBEVENT_CURRENT_ROW_CHANGED |
									CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				else
					dwEventWhat |=	CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_INSERTED;
				break;

			case DBREASON_ROW_RESYNCH:
				if (fCurrentRow)
					dwEventWhat |=	CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;
				else
					dwEventWhat |=	CURSOR_DBEVENT_NONCURRENT_ROW_DATA_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_REFRESH;
				break;

			case DBREASON_ROW_UPDATE:
				if (fCurrentRow)
					dwEventWhat |=	CURSOR_DBEVENT_CURRENT_ROW_CHANGED |
									CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
									CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				else
					dwEventWhat |=	CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_MODIFIED;
				break;

			case DBREASON_ROW_UNDOCHANGE:
				if (fCurrentRow)
   					dwEventWhat |=	CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
									CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				else
   					dwEventWhat |=	CURSOR_DBEVENT_NONCURRENT_ROW_DATA_CHANGED |
									CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_MODIFIED;
				break;

			case DBREASON_ROW_UNDOINSERT:
				if (fCurrentRow)
					dwEventWhat	|=	CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_CANCELUPDATE;
				break;
		}
	}

    // notify interested cursor listeners
	hr = SendNotification(ePhase, dwEventWhat, cRows, pReasons);

	// take cursor out of add-mode if we received UNDOINSERT on current add-row
	if (eReason == DBREASON_ROW_UNDOINSERT && ePhase == DBEVENTPHASE_DIDEVENT && hr == S_OK)
	{
		// if acquired, release same-row clone
		if (GetSameRowClone())
			ReleaseSameRowClone();

		// also, release add row if we have one
		if (m_bmAddRow.GetHRow())
			ReleaseAddRow();

		// reset edit mode
		SetEditMode(CURSOR_DBEDITMODE_NONE);

		// reset column updates
		ResetColumnUpdates();
	}

cleanup:
	g_pMalloc->Free(pReasons);

	// reset cache on ending phase
	if (DBEVENTPHASE_FAILEDTODO == ePhase ||
		DBEVENTPHASE_DIDEVENT	== ePhase)
		m_bmCache.Reset();

	return hr;
}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowsetChange
//=--------------------------------------------------------------------------=
// This function is called on any change affecting the entire rowset
//
// Parameters:
//    pRowset       - [in]  the IRowset that is generating the notification
//							(we can ignore this since we are only ever dealing
//							with a single rowset).
//    eReason       - [in]  the kind of action which caused this change
//    ePhase        - [in]  the phase of this notification
//    fCantDeny     - [in]  when this flag is set to TRUE, the consumer cannot
//							veto the event (by returning S_FALSE)
//
// Output:
//    HRESULT - S_OK if successful
//				S_FALSE the event/phase is vetoed
//              DB_S_UNWANTEDPHASE
//              DB_S_UNWANTEDREASON
//
// Notes:
//
HRESULT CVDCursorPosition::OnRowsetChange(IUnknown *pRowset,
										DBREASON eReason,
										DBEVENTPHASE ePhase,
										BOOL fCantDeny)
{
	if (!(GetRowsetSource()->IsRowsetValid()))
		return S_OK;

	switch (eReason)
	{
		case DBREASON_ROWSET_RELEASE:
			GetRowsetSource()->SetRowsetReleasedFlag();
			break;
		case DBREASON_ROWSET_FETCHPOSITIONCHANGE:
		{
/*


			What do we do here



			DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_CHANGED;
			CURSOR_DBNOTIFYREASON reason;
			memset(&reason, 0, sizeof(CURSOR_DBNOTIFYREASON));
			reason.dwReason		= CURSOR_DBREASON_MOVE;
			reason.arg1			= m_bmCurrent.GetBookmarkVariant();
			VariantInit((VARIANT*)&reason.arg2);
			reason.arg2.vt		= VT_I4;
			// the ICursor spec states that this is the value of dlOffset in
			// iCursorMove::Move. Since we can't get that from the Rowset spec
			// we are setting the value to an arbitrary 1
			reason.arg2.lVal	= 1;	
			return SendNotification(ePhase,	CURSOR_DBEVENT_CURRENT_ROW_CHANGED, 1, &reason);
*/
			break;
		}
	}

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ConnectIRowPositionChange - Connect IRowPositionChange interface
//
HRESULT CVDCursorPosition::ConnectIRowPositionChange()
{
    IConnectionPointContainer * pConnectionPointContainer;

    HRESULT hr = m_pRowPosition->QueryInterface(IID_IConnectionPointContainer, (void**)&pConnectionPointContainer);

    if (FAILED(hr))
        return VD_E_CANNOTCONNECTIROWPOSITIONCHANGE;

    IConnectionPoint * pConnectionPoint;

    hr = pConnectionPointContainer->FindConnectionPoint(IID_IRowPositionChange, &pConnectionPoint);

    if (FAILED(hr))
    {
        pConnectionPointContainer->Release();
        return VD_E_CANNOTCONNECTIROWPOSITIONCHANGE;
    }

    hr = pConnectionPoint->Advise(&m_RowPositionChange, &m_dwAdviseCookie);

    pConnectionPointContainer->Release();
    pConnectionPoint->Release();

    return hr;
}

//=--------------------------------------------------------------------------=
// DisconnectIRowPositionChange - Disconnect IRowPositionChange interface
//
void CVDCursorPosition::DisconnectIRowPositionChange()
{
    IConnectionPointContainer * pConnectionPointContainer;

    HRESULT hr = m_pRowPosition->QueryInterface(IID_IConnectionPointContainer, (void**)&pConnectionPointContainer);

    if (FAILED(hr))
        return;

    IConnectionPoint * pConnectionPoint;

    hr = pConnectionPointContainer->FindConnectionPoint(IID_IRowPositionChange, &pConnectionPoint);

    if (FAILED(hr))
    {
        pConnectionPointContainer->Release();
        return;
    }

    hr = pConnectionPoint->Unadvise(m_dwAdviseCookie);

    if (SUCCEEDED(hr))
        m_dwAdviseCookie = 0;   // clear connection point identifier

    pConnectionPointContainer->Release();
    pConnectionPoint->Release();
}

//=--------------------------------------------------------------------------=
// SendNotification maps the event phases to the corresponding INotifyDBEvents
//					methods
//
HRESULT	CVDCursorPosition::SendNotification(DBEVENTPHASE ePhase,
										  DWORD dwEventWhat,
										  ULONG cReasons,
										  CURSOR_DBNOTIFYREASON rgReasons[])
{
	HRESULT hr = S_OK;
	
	switch (ePhase)
	{
		case DBEVENTPHASE_OKTODO:
			hr = NotifyOKToDo(dwEventWhat, cReasons, rgReasons);
			break;
		case DBEVENTPHASE_ABOUTTODO:
			hr = NotifyAboutToDo(dwEventWhat, cReasons, rgReasons);
			if (S_OK == hr)
				hr = NotifySyncBefore(dwEventWhat, cReasons, rgReasons);
			break;
		case DBEVENTPHASE_SYNCHAFTER:
            // SyncAfter fired from DidEvent for reentrant safety
			break;
		case DBEVENTPHASE_FAILEDTODO:
			NotifyCancel(dwEventWhat, cReasons, rgReasons);
			NotifyFail(dwEventWhat, cReasons, rgReasons);
			break;
		case DBEVENTPHASE_DIDEVENT:
			hr = NotifySyncAfter(dwEventWhat, cReasons, rgReasons);
			if (S_OK == hr)
    		    hr = NotifyDidEvent(dwEventWhat, cReasons, rgReasons);
			break;
	}

	if (CURSOR_DB_S_CANCEL == hr)
		hr = S_FALSE;

	return hr;
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDCursorPosition::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

	*ppvObjOut = NULL;

	if (DO_GUIDS_MATCH(riid, IID_IUnknown))
		{
		*ppvObjOut = this;
		AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef (needed to resolve ambiguity)
//
ULONG CVDCursorPosition::AddRef(void)
{
    return CVDNotifier::AddRef();
}

//=--------------------------------------------------------------------------=
// IUnknown Release (needed to resolve ambiguity)
//
ULONG CVDCursorPosition::Release(void)
{
	if (1 == m_dwRefCount)
		Passivate();  // unhook everything including notification sink

	if (1 > --m_dwRefCount)
	{
		if (0 == m_RowPositionChange.GetRefCount())
			delete this;
		return 0;
	}

	return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IRowPositionChange methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IRowPositionChange OnRowPositionChange
//=--------------------------------------------------------------------------=
// This function is called on any change affecting the current row
//
// Parameters:
//    eReason       - [in]  the kind of action which caused this change
//    ePhase        - [in]  the phase of this notification
//    fCantDeny     - [in]  when this flag is set to TRUE, the consumer cannot
//							veto the event (by returning S_FALSE)
//
// Output:
//    HRESULT - S_OK if successful
//				S_FALSE the event/phase is vetoed
//              DB_S_UNWANTEDPHASE
//              DB_S_UNWANTEDREASON
//
// Notes:
//
HRESULT CVDCursorPosition::OnRowPositionChange(DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny)
{
    // return if notification caused by internal set row call
    if (m_fInternalSetRow)
        return S_OK;

	// return if reason has anything to do with chapter changes
	if (eReason == DBREASON_ROWPOSITION_CHAPTERCHANGED)
		return S_OK;

	IRowset * pRowset = GetRowsetSource()->GetRowset();

    // make sure we have valid row position and rowset pointers
    if (!m_pRowPosition || !pRowset || !GetRowsetSource()->IsRowsetValid())
        return S_OK;

	// synchronize hRow after event occurs
	if (ePhase == DBEVENTPHASE_SYNCHAFTER)
	{
		HROW hRow = NULL;
		HCHAPTER hChapterDummy = NULL;
		DBPOSITIONFLAGS dwPositionFlags = NULL;

		// get new current hRow and position flags from row position object
		HRESULT hr = m_pRowPosition->GetRowPosition(&hChapterDummy, &hRow, &dwPositionFlags);

		if (FAILED(hr))
			return hr;

		if (hRow)
		{
			// set new hRow
			SetCurrentHRow(hRow);
			pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);
		}
		else
		{
			// set row status to beginning or end
			if (dwPositionFlags == DBPOSITION_BOF)
				SetCurrentRowStatus(VDBOOKMARKSTATUS_BEGINNING);
			else if (dwPositionFlags == DBPOSITION_EOF)
				SetCurrentRowStatus(VDBOOKMARKSTATUS_END);
		}
	}

	CURSOR_DBNOTIFYREASON rgReasons[1];
	
	rgReasons[0].dwReason	= CURSOR_DBREASON_MOVE;
	rgReasons[0].arg1		= m_bmCurrent.GetBookmarkVariant();

	VariantInit((VARIANT*)&rgReasons[0].arg2);

    // notify other interested parties
	return SendNotification(ePhase, CURSOR_DBEVENT_CURRENT_ROW_CHANGED, 1, rgReasons);
}

//=--------------------------------------------------------------------------=
// CVDCursorPosition::CVDRowPositionChange::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CVDCursorPosition *CVDCursorPosition::CVDRowPositionChange::m_pMainUnknown
(
    void
)
{
    return (CVDCursorPosition *)((LPBYTE)this - offsetof(CVDCursorPosition, m_RowPositionChange));
}

//=--------------------------------------------------------------------------=
// CVDCursorPosition::CVDRowPositionChange::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CVDCursorPosition::CVDRowPositionChange::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
	if (!ppvObjOut)
		return E_INVALIDARG;

	*ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(riid, IID_IUnknown))
        *ppvObjOut = (IUnknown *)this;
	else
    if (DO_GUIDS_MATCH(riid, IID_IRowPositionChange))
        *ppvObjOut = (IUnknown *)this;

	if (*ppvObjOut)
	{
		m_cRef++;
        return S_OK;
	}

	return E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// CVDCursorPosition::CVDRowPositionChange::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CVDCursorPosition::CVDRowPositionChange::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CVDCursorPosition::CVDRowPositionChange::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CVDCursorPosition::CVDRowPositionChange::Release
(
    void
)
{
    ULONG cRef = --m_cRef;

    if (!m_cRef && !m_pMainUnknown()->m_dwRefCount)
        delete m_pMainUnknown();

    return cRef;
}

//=--------------------------------------------------------------------------=
// IRowPositionChange OnRowPositionChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursor objects in our family
//
HRESULT CVDCursorPosition::CVDRowPositionChange::OnRowPositionChange(DBREASON eReason, 
																	 DBEVENTPHASE ePhase, 
																	 BOOL fCantDeny)
{
	return m_pMainUnknown()->OnRowPositionChange(eReason, ePhase, fCantDeny);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\cursor.h ===
//---------------------------------------------------------------------------
// Cursor.h : CVDCursor header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDCURSOR__
#define __CVDCURSOR__

#define VD_ADJUST_VARIANT_TO_BYTE   1
#define VD_ADJUST_VARIANT_TO_WSTR   2
#define VD_ADJUST_VARIANT_TO_STR    3


class CVDCursor : public CVDNotifier,
                  public CVDCursorBase,
                  public ICursorUpdateARow,
                  public ICursorFind,
                  public IEntryID
{
protected:
// Construction/Destruction
	CVDCursor();
	virtual ~CVDCursor();

// Helper functions
    CVDRowsetColumn * GetRowsetColumn(ULONG ulOrdinal);
    CVDRowsetColumn * GetRowsetColumn(CURSOR_DBCOLUMNID& cursorColumnID);
    HRESULT GetOrdinal(CURSOR_DBCOLUMNID& cursorColumnID, ULONG * pulOrdinal);
    DWORD StatusToCursorInfo(DBSTATUS dwStatus);
    DBSTATUS CursorInfoToStatus(DWORD dwCursorInfo);

    HRESULT ValidateCursorBindParams(CURSOR_DBCOLUMNID * pCursorColumnID, CURSOR_DBBINDPARAMS * pCursorBindParams,
        CVDRowsetColumn ** ppRowsetColumn);

    HRESULT ValidateEntryID(ULONG cbEntryID, BYTE * pEntryID, CVDRowsetColumn ** ppColumn, HROW * phRow);
    HRESULT QueryEntryIDInterface(CVDRowsetColumn * pColumn, HROW hRow, DWORD dwFlags, REFIID riid, IUnknown ** ppUnknown);
#ifndef VD_DONT_IMPLEMENT_ISTREAM
    HRESULT CreateEntryIDStream(CVDRowsetColumn * pColumn, HROW hRow, IStream ** ppStream);
#endif //VD_DONT_IMPLEMENT_ISTREAM

    HRESULT MakeAdjustments(ULONG ulBindings, DBBINDING * pBindings, ULONG * pulIndex, ULONG ulTotalBindings,
        HACCESSOR ** prghAdjustAccessors, DWORD ** ppdwAdjustFlags, BOOL fBefore);
    HRESULT ReCreateAccessors(ULONG ulNewCursorBindings, CURSOR_DBCOLUMNBINDING * pNewCursorBindings, DWORD dwFlags);
    void ReleaseAccessorArray(HACCESSOR * rghAccessors);
    void DestroyAccessors();

    HRESULT ReCreateColumns();
    void DestroyColumns();
	HRESULT FilterNewRow(ULONG *pcRowsObtained, HROW *rghrow, HRESULT hr);

	HRESULT UseAdjustments(HROW hRow, BYTE * pData);
    HRESULT FillConsumersBuffer(HRESULT hrFetch,
								  CURSOR_DBFETCHROWS *pFetchParams,
								  ULONG cRowsObtained,
								  HROW * rghRows);
	
	HRESULT FetchAtBookmark(ULONG cbBookmark,
								void *pBookmark,
								LARGE_INTEGER dlOffset,
								CURSOR_DBFETCHROWS *pFetchParams);

    HRESULT InsertNewRow();

    HRESULT GetOriginalColumn(CVDRowsetColumn * pColumn, CURSOR_DBBINDPARAMS * pBindParams);
    HRESULT GetModifiedColumn(CVDColumnUpdate * pColumnUpdate, CURSOR_DBBINDPARAMS * pBindParams);

public:
    static HRESULT Create(CVDCursorPosition * pCursorPosition, CVDCursor ** ppCursor, CVDResourceDLL * pResourceDLL);

// Access functions
    CVDCursorMain * GetCursorMain() const       {return m_pCursorPosition->GetCursorMain();}

    BOOL IsRowsetValid() const                  {return m_pCursorPosition->GetRowsetSource()->IsRowsetValid();}

    IRowset * GetRowset() const                 {return m_pCursorPosition->GetRowsetSource()->GetRowset();}
    IAccessor * GetAccessor() const             {return m_pCursorPosition->GetRowsetSource()->GetAccessor();}
    IRowsetLocate * GetRowsetLocate() const     {return m_pCursorPosition->GetRowsetSource()->GetRowsetLocate();}
    IRowsetScroll * GetRowsetScroll() const     {return m_pCursorPosition->GetRowsetSource()->GetRowsetScroll();}
    IRowsetChange * GetRowsetChange() const     {return m_pCursorPosition->GetRowsetSource()->GetRowsetChange();}
    IRowsetUpdate * GetRowsetUpdate() const     {return m_pCursorPosition->GetRowsetSource()->GetRowsetUpdate();}
    IRowsetFind * GetRowsetFind() const         {return m_pCursorPosition->GetRowsetSource()->GetRowsetFind();}
    IRowsetInfo * GetRowsetInfo() const         {return m_pCursorPosition->GetRowsetSource()->GetRowsetInfo();}
    IRowsetIdentity * GetRowsetIdentity() const {return m_pCursorPosition->GetRowsetSource()->GetRowsetIdentity();}

// Other
    virtual BOOL SupportsScroll() {return (BOOL)m_pCursorPosition->GetRowsetSource()->GetRowsetScroll();}

protected:
// Retrieving data
    HACCESSOR                   m_hAccessor;            // fixed length buffer accessor
    HACCESSOR                   m_hVarHelper;           // variable length buffer accessors helper
    ULONG                       m_ulVarBindings;        // number of variable length buffer bindings
    HACCESSOR *                 m_rghVarAccessors;      // variable length buffer accessors
    HACCESSOR *                 m_rghAdjustAccessors;   // adjusted fixed length buffer accessors
    DWORD *                     m_pdwAdjustFlags;       // adjusted fixed length buffer accessors flags
    CVDRowsetColumn **          m_ppColumns;            // rowset columns associated with current bindings

// Other
    CVDCursorPosition * m_pCursorPosition;				// backwards pointer to CVDCursorPosition
	CVDNotifyDBEventsConnPtCont * m_pConnPtContainer;	// INotifyDBEvent connection points

// overridden virtual functions from CVDNotifier
	HRESULT NotifyFail  (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT	NotifyOKToDo    (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT NotifySyncBefore(DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT NotifyAboutToDo (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT NotifySyncAfter (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT NotifyDidEvent  (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT NotifyCancel    (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods implemented
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
    // ICursor methods implemented
    //
    STDMETHOD(GetColumnsCursor)(REFIID riid, IUnknown **ppvColumnsCursor, ULONG *pcRows);
    STDMETHOD(SetBindings)(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags);
    STDMETHOD(GetNextRows)(LARGE_INTEGER udlRowsToSkip, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(Requery)(void);

    //=--------------------------------------------------------------------------=
    // ICursorMove methods implemented
    //
    STDMETHOD(Move)(ULONG cbBookmark, void *pBookmark, LARGE_INTEGER dlOffset, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(GetBookmark)(CURSOR_DBCOLUMNID *pBookmarkType, ULONG cbMaxSize, ULONG *pcbBookmark, void *pBookmark);
    STDMETHOD(Clone)(DWORD dwFlags, REFIID riid, IUnknown **ppvClonedCursor);

    //=--------------------------------------------------------------------------=
    // ICursorScroll methods implemented
    //
    STDMETHOD(Scroll)(ULONG ulNumerator, ULONG ulDenominator, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(GetApproximatePosition)(ULONG cbBookmark, void *pBookmark, ULONG *pulNumerator, ULONG *pulDenominator);
    STDMETHOD(GetApproximateCount)(LARGE_INTEGER *pudlApproxCount, DWORD *pdwFullyPopulated);

    //=--------------------------------------------------------------------------=
    // ICursorUpdateARow methods
    //
    STDMETHOD(BeginUpdate)(DWORD dwFlags);
    STDMETHOD(SetColumn)(CURSOR_DBCOLUMNID *pcid, CURSOR_DBBINDPARAMS *pBindParams);
    STDMETHOD(GetColumn)(CURSOR_DBCOLUMNID *pcid, CURSOR_DBBINDPARAMS *pBindParams, DWORD *pdwFlags);
    STDMETHOD(GetEditMode)(DWORD *pdwState);
    STDMETHOD(Update)(CURSOR_DBCOLUMNID *pBookmarkType, ULONG *pcbBookmark, void **ppBookmark);
    STDMETHOD(Cancel)(void);
    STDMETHOD(Delete)(void);

    //=--------------------------------------------------------------------------=
    // ICursorFind methods
    //
    STDMETHOD(FindByValues)(ULONG cbBookmark, LPVOID pBookmark, DWORD dwFindFlags, ULONG cValues,
        CURSOR_DBCOLUMNID rgColumns[], CURSOR_DBVARIANT rgValues[], DWORD rgdwSeekFlags[],
        CURSOR_DBFETCHROWS FAR *pFetchParams);

    //=--------------------------------------------------------------------------=
    // IEnrtyID methods
    //
    STDMETHOD(GetInterface)(ULONG cbEntryID, void *pEntryID, DWORD dwFlags, REFIID riid, IUnknown **ppvObj);
};


#endif //__CVDCURSOR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\cursmain.h ===
//---------------------------------------------------------------------------
// CursorMain.h : CVDCursorMain header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDCURSORMAIN__
#define __CVDCURSORMAIN__

class CVDBookmark;
class CVDCursorPosition;

class CVDCursorMain : public CVDRowsetSource

{
protected:
// Construction/Destruction
    CVDCursorMain(LCID lcid);
	virtual ~CVDCursorMain();

protected:
    static HRESULT Create(IRowPosition * pRowPosition, IRowset * pRowset, ICursor ** ppCursor, LCID lcid);
public:
    static HRESULT Create(IRowset * pRowset, ICursor ** ppCursor, LCID lcid);
    static HRESULT Create(IRowPosition * pRowPosition, ICursor ** ppCursor, LCID lcid);

protected:
// Rowset columns
    HRESULT CreateMetaColumns();
	void InitOptionalMetadata(ULONG cColumns);
    void DestroyMetaColumns();

    HRESULT CreateColumns();
    void DestroyColumns();

public:
// Access functions
    ULONG GetMetaColumnsCount() const {return s_ulMetaColumns;}
    CVDRowsetColumn * InternalGetMetaColumns() const {return s_rgMetaColumns;}

    ULONG GetColumnsCount() const {return m_ulColumns;}
    CVDRowsetColumn * InternalGetColumns() const {return m_rgColumns;}

	HACCESSOR GetBookmarkAccessor() const {return m_hAccessorBM;}
	ULONG GetMaxBookmarkLen() const {return m_cbMaxBookmark;}

	BOOL IsColumnsRowsetSupported() const {return m_fColumnsRowsetSupported;}

    void SetInternalInsertRow(BOOL fInternalInsertRow) {m_fInternalInsertRow = fInternalInsertRow;}
    void SetInternalDeleteRows(BOOL fInternalDeleteRows) {m_fInternalDeleteRows = fInternalDeleteRows;}
    void SetInternalSetData(BOOL fInternalSetData) {m_fInternalSetData = fInternalSetData;}
	BOOL IsSameRowAsNew(HROW hrow);
	ULONG AddedRows(void);

protected:
// Rowset columns
    static DWORD                s_dwMetaRefCount;   // reference count for meta-columns
    static ULONG                s_ulMetaColumns;    // number of meta-columns for IColumnsInfo
    static CVDRowsetColumn *    s_rgMetaColumns;    // pointer to an array of meta-column objects

    ULONG                       m_ulColumns;        // number of rowset columns
    CVDRowsetColumn *           m_rgColumns;        // pointer to an array of column objects

// IRowsetNotify
	VARIANT_BOOL    m_fConnected;			// have we added ourselves to the Rowset's connection point
    DWORD           m_dwAdviseCookie;		// connection point identifier

	HRESULT ConnectIRowsetNotify();
	void DisconnectIRowsetNotify();

	void Passivate();

// Other
    ULONG                       m_cbMaxBookmark;    // sizeof maximum bookmark
    HACCESSOR					m_hAccessorBM;		// hAccessor for the bookmark column
	CVDResourceDLL		        m_resourceDLL;		// keeps track of resource DLL

// booleans
	WORD m_fWeAddedMetaRef	        : 1;			// we added a reference count to meta-columns
    WORD m_fPassivated			    : 1;			// external ref count went to zero
    WORD m_fColumnsRowsetSupported  : 1;			// does rowset expose IColumnsRowset
    WORD m_fInternalInsertRow       : 1;            // row insert caused by internal call
    WORD m_fInternalDeleteRows      : 1;            // row delete caused by internal call
    WORD m_fInternalSetData         : 1;            // set column caused by internal call

// rowset properties
	WORD m_fLiteralBookmarks	: 1;			
	WORD m_fOrderedBookmarks	: 1;
    WORD m_fBookmarkSkipped     : 1;			

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);
	//=--------------------------------------------------------------------------=
	// IRowsetNotify methods passed up from CVDRowsetNotify implementation
	//
	STDMETHOD(OnFieldChange)(IRowset *pRowset, HROW hRow, ULONG cColumns, ULONG rgColumns[], DBREASON eReason,
		DBEVENTPHASE ePhase, BOOL fCantDeny);
	STDMETHOD(OnRowChange)(IRowset *pRowset, ULONG cRows, const HROW rghRows[], DBREASON eReason, DBEVENTPHASE ePhase,
			BOOL fCantDeny);
	STDMETHOD(OnRowsetChange)(IRowset *pRowset, DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

  private:
    // the inner, private unknown implementation to give to connection point
    // container to avoid circular ref count
    //
    class CVDRowsetNotify : public IRowsetNotify {
      public:
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // constructor is remarkably trivial
        //
        CVDRowsetNotify() : m_cRef(0) {}

		ULONG GetRefCount() const {return m_cRef;}

      private:
        CVDCursorMain *m_pMainUnknown();
        ULONG m_cRef;
		//=--------------------------------------------------------------------------=
		// IRowsetNotify methods
		//
		STDMETHOD(OnFieldChange)(IRowset *pRowset, HROW hRow, ULONG cColumns, ULONG rgColumns[], DBREASON eReason,
			DBEVENTPHASE ePhase, BOOL fCantDeny);
		STDMETHOD(OnRowChange)(IRowset *pRowset, ULONG cRows, const HROW rghRows[], DBREASON eReason, DBEVENTPHASE ePhase,
				BOOL fCantDeny);
		STDMETHOD(OnRowsetChange)(IRowset *pRowset, DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

    } m_RowsetNotify;

    friend class CVDRowsetNotify;

};


#endif //__CVDCURSORMAIN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\curspos.h ===
//---------------------------------------------------------------------------
// CursorPosition.h : CVDCursorPosition header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDCURSORPOSITION__
#define __CVDCURSORPOSITION__

#include "bookmark.h"

class CVDRowsetSource;

class CVDCursorPosition : public CVDNotifier
{
protected:
// Construction/Destruction
    CVDCursorPosition();
	virtual ~CVDCursorPosition();

public:
    static HRESULT Create(IRowPosition * pRowPosition,
						  CVDCursorMain * pCursorMain,
						  CVDCursorPosition ** ppCursorPosition,
						  CVDResourceDLL * pResourceDLL);

public:
// Access functions
    CVDCursorMain * GetCursorMain() const {return m_pCursorMain;}
    CVDRowsetSource * GetRowsetSource() const {return m_pCursorMain;}

// Updating
    ICursor * GetSameRowClone() const {return m_pSameRowClone;}
    void SetSameRowClone(ICursor * pSameRowClone) {m_pSameRowClone = pSameRowClone;}
	DWORD GetEditMode() const {return m_dwEditMode;}
	void SetEditMode(DWORD dwEditMode) {m_dwEditMode = dwEditMode;}

// Column updates
    HRESULT CreateColumnUpdates();
    HRESULT ResetColumnUpdates();
    void DestroyColumnUpdates();
    CVDColumnUpdate * GetColumnUpdate(ULONG ulColumn) const;
    void SetColumnUpdate(ULONG ulColumn, CVDColumnUpdate * pColumnUpdate);

// Positioning/reset functions
	void PositionToFirstRow();
	HRESULT SetCurrentHRow(HROW hRowNew);
	void SetCurrentRowStatus(WORD wStatus);
	HRESULT SetAddHRow(HROW hRowNew);

	HRESULT IsSameRowAsCurrent(HROW hRow, BOOL fCacheIfNotSame);
	HRESULT IsSameRowAsNew(HROW hRow);

	HRESULT SetRowPosition(HROW hRow);

// adding/editing functions
#ifndef VD_DONT_IMPLEMENT_ISTREAM
    HRESULT UpdateEntryIDStream(CVDRowsetColumn * pColumn, HROW hRow, IStream * pStream);
#endif //VD_DONT_IMPLEMENT_ISTREAM
    void ReleaseSameRowClone();
    HROW GetEditRow() const;

// bookmarks
	CVDBookmark		    m_bmCurrent;			// current row's bookmark
	CVDBookmark		    m_bmCache;				// used to cache bookmark of last non-current
    CVDBookmark         m_bmAddRow;             // add row's bookmark

protected:
// Data members
	CVDResourceDLL *    m_pResourceDLL;
    CVDCursorMain *     m_pCursorMain;          // backwards pointer to CVDCursorMain
	IRowPosition *		m_pRowPosition;			// row position pointer, used to synchronize current position
    ICursor *           m_pSameRowClone;        // same-row clone used in ICursorUpdateARow::GetColumn() calls
    DWORD               m_dwEditMode;           // current edit mode
    CVDColumnUpdate **  m_ppColumnUpdates;      // column updates
	VARIANT_BOOL		m_fTempEditMode;		// temporary edit mode? (caused by external SetData call)

// IRowPositionChange
	VARIANT_BOOL    m_fConnected;		// have we added ourselves to the RowPosition's connection point
    DWORD           m_dwAdviseCookie;	// connection point identifier
    VARIANT_BOOL	m_fPassivated;		// external ref count went to zero
    VARIANT_BOOL	m_fInternalSetRow;  // OnRowPositionChange caused by internal call

	HRESULT ConnectIRowPositionChange();
	void DisconnectIRowPositionChange();

	void Passivate();

	HRESULT	SendNotification(DBEVENTPHASE ePhase,
							 DWORD dwEventWhat,
							 ULONG cReasons,
							 CURSOR_DBNOTIFYREASON rgReasons[]);
public:
	void ReleaseCurrentRow();
	void ReleaseAddRow();

    //=--------------------------------------------------------------------------=
    // IRowsetNotify methods  - IRowsetNotify is actually implemented off of CVDCursorMain
	//							which forwards each method to the CVDCursorPosition objects
	//							in its family
    //
    STDMETHOD(OnFieldChange)(IUnknown *pRowset, HROW hRow, ULONG cColumns, ULONG rgColumns[], DBREASON eReason,
        DBEVENTPHASE ePhase, BOOL fCantDeny);
    STDMETHOD(OnRowChange)(IUnknown *pRowset, ULONG cRows, const HROW rghRows[], DBREASON eReason, DBEVENTPHASE ePhase,
            BOOL fCantDeny);
    STDMETHOD(OnRowsetChange)(IUnknown *pRowset, DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

	//=--------------------------------------------------------------------------=
	// IRowPositionChange method passed up from CVDRowPositionChange implementation
	//
    STDMETHOD(OnRowPositionChange)(DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

private:
    // the inner, private unknown implementation to give to connection point
    // container to avoid circular ref count
    //
    class CVDRowPositionChange : public IRowPositionChange 
	{
	public:
		STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
		STDMETHOD_(ULONG, AddRef)(void);
		STDMETHOD_(ULONG, Release)(void);

		// constructor is remarkably trivial
		//
		CVDRowPositionChange() : m_cRef(0) {}

		ULONG GetRefCount() const {return m_cRef;}

	private:
		CVDCursorPosition *m_pMainUnknown();
		ULONG m_cRef;

		//=--------------------------------------------------------------------------=
		// IRowPositionChange method
		//
	    STDMETHOD(OnRowPositionChange)(DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

    } m_RowPositionChange;

    friend class CVDRowPositionChange;
};


#endif //__CVDCURSORPOSITION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\debug.cpp ===
//=--------------------------------------------------------------------------=
// Debug.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains various methods that will only really see any use in DEBUG builds
//

#include "stdafx.h"   // not really used here, but NT Build env. doesn't like
                      // some files in a dir to have pre-comp hdrs & some not
#ifdef _DEBUG


#include "IPServer.H"
#include <stdlib.h>


//=--------------------------------------------------------------------------=
// Private Constants
//---------------------------------------------------------------------------=
//
static char szFormat[]  = "%s\nFile %s, Line %d";
static char szFormat2[] = "%s\n%s\nFile %s, Line %d";
LPSTR Deb_lpszAssertInfo = NULL;

#define _SERVERNAME_ "Viaduct"

static char szTitle[]  = _SERVERNAME_ " Assertion  (Abort = UAE, Retry = INT 3, Ignore = Continue)";


//=--------------------------------------------------------------------------=
// Local functions
//=--------------------------------------------------------------------------=
int NEAR _IdMsgBox(LPSTR pszText, LPSTR pszTitle, UINT mbFlags);

//=--------------------------------------------------------------------------=
// DisplayAssert
//=--------------------------------------------------------------------------=
// Display an assert message box with the given pszMsg, pszAssert, source
// file name, and line number. The resulting message box has Abort, Retry,
// Ignore buttons with Abort as the default.  Abort does a FatalAppExit;
// Retry does an int 3 then returns; Ignore just returns.
//
VOID DisplayAssert
(
    LPSTR	 pszMsg,
    LPSTR	 pszAssert,
    LPSTR	 pszFile,
    UINT	 line
)
{
    char	szMsg[250 * 2];
    LPSTR	lpszText;

    lpszText = pszMsg;		// Assume no file & line # info

    // If C file assert, where you've got a file name and a line #
    //
    if (pszFile) {

        // Was additional information supplied?
        //
        if (Deb_lpszAssertInfo) {

            // Then format the assert nicely, using this additional information:
            //
            wsprintf(szMsg, szFormat2, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, Deb_lpszAssertInfo, pszFile, line);
            Deb_lpszAssertInfo = NULL;
	} else {

            // Then format the assert nicely without the extra information:
            //
            wsprintf(szMsg, szFormat, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, pszFile, line);
        }

        lpszText = szMsg;
    }

    // Put up a dialog box
    //
    switch (_IdMsgBox(lpszText, szTitle, MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SYSTEMMODAL)) {
        case IDABORT:
            FatalAppExit(0, lpszText);
            return;

        case IDRETRY:
            // call the win32 api to break us.
            //
            DebugBreak();
            return;
    }

    return;
}


//=---------------------------------------------------------------------------=
// Beefed-up version of WinMessageBox.
//=---------------------------------------------------------------------------=
//
int NEAR _IdMsgBox
(
    LPSTR	pszText,
    LPSTR	pszTitle,
    UINT	mbFlags
)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);

    return id;
}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\cursmeta.h ===
//---------------------------------------------------------------------------
// MetadataCursor.h : CVDMetadataCursor header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDMETADATACURSOR__
#define __CVDMETADATACURSOR__


class CVDMetadataCursor : public CVDCursorBase
{
protected:
// Construction/Destruction
	CVDMetadataCursor();
	virtual ~CVDMetadataCursor();

public:
    static HRESULT Create(ULONG ulColumns, CVDRowsetColumn * pColumns, ULONG ulMetaColumns, CVDRowsetColumn * pMetaColumns,
        CVDMetadataCursor ** ppMetadataCursor, CVDResourceDLL * pResourceDLL);

protected:
// Helper functions
    void RowToBookmark(LONG lRow, ULONG * pcbBookmark, void * pBookmark) const;
    BOOL BookmarkToRow(ULONG cbBookmark, void * pBookmark, LONG * plRow) const;

    ULONG ReturnData_I4(DWORD dwData, CURSOR_DBCOLUMNBINDING * pCursorBinding, BYTE * pData, BYTE * pVarData);
    ULONG ReturnData_BOOL(VARIANT_BOOL fData, CURSOR_DBCOLUMNBINDING * pCursorBinding, BYTE * pData, BYTE * pVarData);
    ULONG ReturnData_LPWSTR(WCHAR * pwszData, CURSOR_DBCOLUMNBINDING * pCursorBinding, BYTE * pData, BYTE * pVarData);
    ULONG ReturnData_DBCOLUMNID(CURSOR_DBCOLUMNID cursorColumnID, CURSOR_DBCOLUMNBINDING * pCursorBinding, 
        BYTE * pData, BYTE * pVarData);
    ULONG ReturnData_Bookmark(LONG lRow, CURSOR_DBCOLUMNBINDING * pCursorBinding, BYTE * pData, BYTE * pVarData);

protected:
// Data members
    DWORD               m_dwRefCount;       // reference count
    LONG                m_lCurrentRow;      // current row in metadata columns

    ULONG               m_ulColumns;        // number of rowset columns
    CVDRowsetColumn *   m_pColumns;         // pointer to array of column objects

    ULONG               m_ulMetaColumns;    // number of rowset meta-columns
    CVDRowsetColumn *   m_pMetaColumns;     // pointer to array of meta-column objects

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods implemented
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
    // ICursor methods implemented
    //
    STDMETHOD(GetColumnsCursor)(REFIID riid, IUnknown **ppvColumnsCursor, ULONG *pcRows);
    STDMETHOD(SetBindings)(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags);
    STDMETHOD(GetNextRows)(LARGE_INTEGER udlRowsToSkip, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(Requery)(void);

    //=--------------------------------------------------------------------------=
    // ICursorMove methods implemented
    //
    STDMETHOD(Move)(ULONG cbBookmark, void *pBookmark, LARGE_INTEGER dlOffset, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(GetBookmark)(CURSOR_DBCOLUMNID *pBookmarkType, ULONG cbMaxSize, ULONG *pcbBookmark, void *pBookmark);
    STDMETHOD(Clone)(DWORD dwFlags, REFIID riid, IUnknown **ppvClonedCursor);

    //=--------------------------------------------------------------------------=
    // ICursorScroll methods implemented
    //
    STDMETHOD(Scroll)(ULONG ulNumerator, ULONG ulDenominator, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(GetApproximatePosition)(ULONG cbBookmark, void *pBookmark, ULONG *pulNumerator, ULONG *pulDenominator);
    STDMETHOD(GetApproximateCount)(LARGE_INTEGER *pudlApproxCount, DWORD *pdwFullyPopulated);
};


#endif //__CVDMETADATACURSOR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\cursor.cpp ===
//---------------------------------------------------------------------------
// Cursor.cpp : Cursor implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"
#include "ColUpdat.h"
#include "CursPos.h"
#include "enumcnpt.h"
#include "CursBase.h"
#include "Cursor.h"
#include "CursMeta.h"
#include "EntryID.h"
#include "Stream.h"
#include "fastguid.h"
#include "resource.h"
#include "NConnPt.h"
#include "NConnPtC.h"
#include "FromVar.h"
#include "timeconv.h"

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDCursor - Constructor
//
CVDCursor::CVDCursor()
{
    m_hAccessor             = 0;
    m_hVarHelper            = 0;
    m_ulVarBindings         = 0;
    m_rghVarAccessors       = NULL;
    m_rghAdjustAccessors    = NULL;
    m_pdwAdjustFlags        = NULL;
    m_ppColumns             = NULL;

    m_pCursorPosition       = NULL;
    m_pConnPtContainer      = NULL;

#ifdef _DEBUG
    g_cVDCursorCreated++;
#endif
}

//=--------------------------------------------------------------------------=
// ~CVDCursor - Destructor
//
CVDCursor::~CVDCursor()
{
    DestroyAccessors();
    DestroyColumns();

    if (m_pCursorPosition->GetSameRowClone())
        m_pCursorPosition->ReleaseSameRowClone();

	LeaveFamily();  // leave m_pCursorPosition's notification family

	if (m_pConnPtContainer)
		m_pConnPtContainer->Destroy();

	if (m_pCursorPosition)
		((CVDNotifier*)m_pCursorPosition)->Release();   // release associated cursor position object

#ifdef _DEBUG
    g_cVDCursorDestroyed++;
#endif
}

//=--------------------------------------------------------------------------=
// GetRowsetColumn - Get rowset column from ordinal
//=--------------------------------------------------------------------------=
// This function retrieves the rowset column with the specified rowset ordinal
//
// Parameters:
//    ulOrdinal    - [in]  rowset ordinal
//
// Output:
//    CVDRowsetColumn pointer
//
// Notes:
//
CVDRowsetColumn * CVDCursor::GetRowsetColumn(ULONG ulOrdinal)
{
    CVDRowsetColumn * pRowsetColumn = NULL;

    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumn = GetCursorMain()->InternalGetColumns();

    for (ULONG ulCol = 0; ulCol < ulColumns && !pRowsetColumn; ulCol++)
    {
        if (pColumn->GetOrdinal() == ulOrdinal)
            pRowsetColumn = pColumn;

        pColumn++;
    }

    return pRowsetColumn;
}

//=--------------------------------------------------------------------------=
// GetRowsetColumn - Get rowset column from cursor column identifier
//=--------------------------------------------------------------------------=
// This function retrieves the rowset column associated with the specified
// cursor column identifier
//
// Parameters:
//    cursorColumnID    - [in]  a reference to cursor column identifier
//
// Output:
//    CVDRowsetColumn pointer
//
// Notes:
//
CVDRowsetColumn * CVDCursor::GetRowsetColumn(CURSOR_DBCOLUMNID& cursorColumnID)
{
    CVDRowsetColumn * pRowsetColumn = NULL;

    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumn = GetCursorMain()->InternalGetColumns();

    for (ULONG ulCol = 0; ulCol < ulColumns && !pRowsetColumn; ulCol++)
    {
        if (IsEqualCursorColumnID(cursorColumnID, pColumn->GetCursorColumnID()))
            pRowsetColumn = pColumn;

        pColumn++;
    }

    return pRowsetColumn;
}

//=--------------------------------------------------------------------------=
// GetOrdinal - Get ordinal from cursor column identifier
//=--------------------------------------------------------------------------=
// This function converts a cursor column identifier its ordinal eqivalent
//
// Parameters:
//    cursorColumnID    - [in]  a reference to cursor column identifier
//    pulOrdinal        - [out] a pointer to memory in which to return ordinal
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL bad cursor column identifier
//
// Notes:
//
HRESULT CVDCursor::GetOrdinal(CURSOR_DBCOLUMNID& cursorColumnID, ULONG * pulOrdinal)
{
    HRESULT hr = E_FAIL;

    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumn = GetCursorMain()->InternalGetColumns();

    for (ULONG ulCol = 0; ulCol < ulColumns && FAILED(hr); ulCol++)
    {
        if (IsEqualCursorColumnID(cursorColumnID, pColumn->GetCursorColumnID()))
        {
            *pulOrdinal = pColumn->GetOrdinal();
            hr = S_OK;
        }

        pColumn++;
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// StatusToCursorInfo - Get cursor info from rowset status field
//=--------------------------------------------------------------------------=
// This function converts a rowset status to its cursor information field
// eqivalent
//
// Parameters:
//    dwStatus  - [in] rowset status
//
// Output:
//    DWORD - cursor information
//
// Notes:
//    There are more rowset statuses than cursor information values
//
DWORD CVDCursor::StatusToCursorInfo(DBSTATUS dwStatus)
{
    DWORD dwCursorInfo = CURSOR_DB_UNKNOWN;

    switch (dwStatus)
    {
        case DBSTATUS_S_OK:
            dwCursorInfo = CURSOR_DB_NOINFO;
            break;

        case DBSTATUS_E_CANTCONVERTVALUE:
            dwCursorInfo = CURSOR_DB_CANTCOERCE;
            break;

        case DBSTATUS_S_ISNULL:
        	dwCursorInfo = CURSOR_DB_NULL;
            break;

        case DBSTATUS_S_TRUNCATED:
            dwCursorInfo = CURSOR_DB_TRUNCATED;
            break;
    }

    return dwCursorInfo;
}

//=--------------------------------------------------------------------------=
// CursorInfoToStatus - Get rowset status from cursor info field
//=--------------------------------------------------------------------------=
// This function converts a cursor information field to its rowset status
// eqivalent
//
// Parameters:
//    dwInfo  - [in] rowset status
//
// Output:
//    DWORD - cursor information
//
// Notes:
//    This function only converts successful cursor information fields for
//    the purpose of setting data
//
DBSTATUS CVDCursor::CursorInfoToStatus(DWORD dwCursorInfo)
{
    DBSTATUS dwStatus;

    switch (dwCursorInfo)
    {
        case CURSOR_DB_NULL:
            dwStatus = DBSTATUS_S_ISNULL;
            break;

        case CURSOR_DB_EMPTY:
            dwStatus = DBSTATUS_S_ISNULL;
            break;

        case CURSOR_DB_TRUNCATED:
            dwStatus = DBSTATUS_S_TRUNCATED;
            break;

        case CURSOR_DB_NOINFO:
            dwStatus = DBSTATUS_S_OK;
            break;
    }

    return dwStatus;
}

//=--------------------------------------------------------------------------=
// ValidateCursorBindParams - Validate cursor column binding parameters
//=--------------------------------------------------------------------------=
// This function makes sure the specified column binding parameters are
// acceptable and then returns a pointer to the corresponding rowset column
//
// Parameters:
//    pCursorColumnID       - [in]  a pointer to column identifier of the
//                                  column to bind
//    pCursorBindParams     - [in]  a pointer to binding structure
//    ppRowsetColumn        - [out] a pointer to memory in which to return
//                                  a pointer to the rowset column to bind
//
// Output:
//    HRESULT - S_OK if successful
//              CURSOR_DB_E_BADBINDINFO bad binding information
//              CURSOR_DB_E_BADCOLUMNID columnID is not available
//
// Notes:
//
HRESULT CVDCursor::ValidateCursorBindParams(CURSOR_DBCOLUMNID * pCursorColumnID, CURSOR_DBBINDPARAMS * pCursorBindParams,
    CVDRowsetColumn ** ppRowsetColumn)
{
    ASSERT_POINTER(pCursorColumnID, CURSOR_DBCOLUMNID)
    ASSERT_POINTER(pCursorBindParams, CURSOR_DBBINDPARAMS)
    ASSERT_POINTER(ppRowsetColumn, CVDRowsetColumn*)

    // make sure we have all necessary pointers
    if (!pCursorColumnID || !pCursorBindParams || !ppRowsetColumn)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameter
    *ppRowsetColumn = NULL;

    // make sure column identifier is available
    BOOL fColumnIDAvailable = FALSE;

    DWORD dwCursorType;
    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumns = GetCursorMain()->InternalGetColumns();
    CVDRowsetColumn * pColumn = pColumns;

    // iterate through rowset columns looking for match
    for (ULONG ulCol = 0; ulCol < ulColumns && !fColumnIDAvailable; ulCol++)
    {
        if (IsEqualCursorColumnID(*pCursorColumnID, pColumn->GetCursorColumnID()))
        {
            dwCursorType = pColumn->GetCursorType();
            *ppRowsetColumn = pColumn;
            fColumnIDAvailable = TRUE;
        }

        pColumn++;
    }

    // get out if not found
    if (!fColumnIDAvailable)
    {
        VDSetErrorInfo(IDS_ERR_BADCOLUMNID, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_BADCOLUMNID;
    }

    // make sure caller supplied a maximum length if a default binding was specified
    // for the cursor types CURSOR_DBTYPE_CHARS, CURSOR_DBTYPE_WCHARS or CURSOR_DBTYPE_BYTES
    if (pCursorBindParams->cbMaxLen == CURSOR_DB_NOMAXLENGTH &&
        pCursorBindParams->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBindParams->dwDataType == CURSOR_DBTYPE_CHARS ||
            pCursorBindParams->dwDataType == CURSOR_DBTYPE_WCHARS ||
            pCursorBindParams->dwDataType == CURSOR_DBTYPE_BYTES)
        {
            VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursorUpdateARow, m_pResourceDLL);
            return CURSOR_DB_E_BADBINDINFO;
        }
    }

    // check binding bit mask for possible values
    if (pCursorBindParams->dwBinding != CURSOR_DBBINDING_DEFAULT &&
        pCursorBindParams->dwBinding != CURSOR_DBBINDING_VARIANT &&
        pCursorBindParams->dwBinding != CURSOR_DBBINDING_ENTRYID &&
        pCursorBindParams->dwBinding != (CURSOR_DBBINDING_VARIANT | CURSOR_DBBINDING_ENTRYID))
    {
        VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_BADBINDINFO;
    }

    // check for valid cursor type
    if (!IsValidCursorType(pCursorBindParams->dwDataType))
    {
        VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_BADBINDINFO;
    }

    // if a variant binding was specified make sure the cursor type is not CURSOR_DBTYPE_CHARS,
    // CURSOR_DBTYPE_WCHARS or CURSOR_DBTYPE_BYTES
    if (pCursorBindParams->dwBinding & CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBindParams->dwDataType == CURSOR_DBTYPE_CHARS ||
            pCursorBindParams->dwDataType == CURSOR_DBTYPE_WCHARS ||
            pCursorBindParams->dwDataType == CURSOR_DBTYPE_BYTES)
        {
            VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursorUpdateARow, m_pResourceDLL);
            return CURSOR_DB_E_BADBINDINFO;
        }
    }

    // if its not a variant binding make sure the cursor type is not CURSOR_DBTYPE_ANYVARIANT
    if (!(pCursorBindParams->dwBinding & CURSOR_DBBINDING_VARIANT) &&
        pCursorBindParams->dwDataType == CURSOR_DBTYPE_ANYVARIANT)
    {
        VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_BADBINDINFO;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ValidateEntryID - Validate entry identifier
//=--------------------------------------------------------------------------=
// This function makes sure the specified enrty identifier is acceptable,
// if it is, then return rowset column and hRow associated with it
//
// Parameters:
//  cbEntryID   - [in]  the size of the entryID
//  pEntryID    - [in]  a pointer to the entryID
//  ppColumn    - [out] a pointer to memory in which to return rowset column pointer
//  phRow       - [out] a pointer to memory in which to return row handle
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              CURSOR_DB_E_BADENTRYID bad entry identifier
//
HRESULT CVDCursor::ValidateEntryID(ULONG cbEntryID, BYTE * pEntryID, CVDRowsetColumn ** ppColumn, HROW * phRow)
{
    ASSERT_POINTER(pEntryID, BYTE)
    ASSERT_POINTER(ppColumn, CVDRowsetColumn*)
    ASSERT_POINTER(phRow, HROW)

	IRowsetLocate * pRowsetLocate = GetRowsetLocate();

    // make sure we have a valid rowset locate pointer
    if (!pRowsetLocate || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pEntryID || !ppColumn || !phRow)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameters
    *ppColumn = NULL;
    *phRow = NULL;

    // check length of enrtyID
    if (cbEntryID != sizeof(ULONG) + sizeof(ULONG) + GetCursorMain()->GetMaxBookmarkLen())
    {
        VDSetErrorInfo(IDS_ERR_BADENTRYID, IID_IEntryID, m_pResourceDLL);
        return CURSOR_DB_E_BADENTRYID;
    }

    // extract column ordinal
    ULONG ulOrdinal = *(ULONG*)pEntryID;

    // make sure column ordinal is okay
    BOOL fColumnOrdinalOkay = FALSE;

    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumn = GetCursorMain()->InternalGetColumns();

    // iterate through rowset columns looking for match
    for (ULONG ulCol = 0; ulCol < ulColumns && !fColumnOrdinalOkay; ulCol++)
    {
        if (ulOrdinal == pColumn->GetOrdinal())
            fColumnOrdinalOkay = TRUE;
        else
            pColumn++;
    }

    // if not found, get out
    if (!fColumnOrdinalOkay)
    {
        VDSetErrorInfo(IDS_ERR_BADENTRYID, IID_IEntryID, m_pResourceDLL);
        return CURSOR_DB_E_BADENTRYID;
    }

    // set column pointer
    *ppColumn = pColumn;

    // extract row bookmark
    ULONG cbBookmark = *(ULONG*)(pEntryID + sizeof(ULONG));
    BYTE * pBookmark = (BYTE*)pEntryID + sizeof(ULONG) + sizeof(ULONG);

    // attempt to retrieve hRow from bookmark
    HRESULT hr = pRowsetLocate->GetRowsByBookmark(0, 1, &cbBookmark, (const BYTE**)&pBookmark, phRow, NULL);

    if (FAILED(hr))
        VDSetErrorInfo(IDS_ERR_BADENTRYID, IID_IEntryID, m_pResourceDLL);

    return hr;
}

//=--------------------------------------------------------------------------=
// QueryEntryIDInterface - Get specified interface for entry identifier
//=--------------------------------------------------------------------------=
// This function attempts to get the requested interface from the specified
// column row
//
// Parameters:
//  pColumn     - [in]  rowset column pointer
//  hRow        - [in]  the row handle
//  dwFlags     - [in]  interface specific flags
//  riid        - [in]  interface identifier requested
//  ppUnknown   - [out] a pointer to memory in which to return interface pointer
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL error occured
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_NOINTERFACE interface not available
//
HRESULT CVDCursor::QueryEntryIDInterface(CVDRowsetColumn * pColumn, HROW hRow, DWORD dwFlags, REFIID riid,
    IUnknown ** ppUnknown)
{
    ASSERT_POINTER(pColumn, CVDRowsetColumn)
    ASSERT_POINTER(ppUnknown, IUnknown*)

	IRowset * pRowset = GetRowset();
	IAccessor * pAccessor = GetAccessor();

    // make sure we have valid rowset and accessor pointers
    if (!pRowset || !pAccessor || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessay pointers
    if (!pColumn || !ppUnknown)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameters
    *ppUnknown = NULL;

    DBOBJECT object;
    DBBINDING binding;

    // clear out binding
    memset(&binding, 0, sizeof(DBBINDING));

    // create interface binding
    binding.iOrdinal            = pColumn->GetOrdinal();
    binding.pObject             = &object;
    binding.pObject->dwFlags    = dwFlags;
    binding.pObject->iid        = riid;
    binding.dwPart              = DBPART_VALUE;
    binding.dwMemOwner          = DBMEMOWNER_CLIENTOWNED;
    binding.cbMaxLen            = sizeof(IUnknown*);
    binding.wType               = DBTYPE_IUNKNOWN;

    HACCESSOR hAccessor;

    // create interface accessor
    HRESULT hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

    if (FAILED(hr))
        return E_NOINTERFACE;

    IUnknown * pUnknown = NULL;

    // try to get interface
    hr = pRowset->GetData(hRow, hAccessor, &pUnknown);

    // release interface accessor
    pAccessor->ReleaseAccessor(hAccessor, NULL);

    if (FAILED(hr))
        return E_NOINTERFACE;

    // return pointer
    *ppUnknown = pUnknown;

    return hr;
}

#ifndef VD_DONT_IMPLEMENT_ISTREAM

//=--------------------------------------------------------------------------=
// CreateEntryIDStream - Create stream for entry identifier
//=--------------------------------------------------------------------------=
// This function retrieves supplied column row's data and create a
// stream containing this data
//
// Parameters:
//  pColumn     - [in]  rowset column pointer
//  hRow        - [in]  the row handle
//  ppStream    - [out] a pointer to memory in which to return stream pointer
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL error occured
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//
HRESULT CVDCursor::CreateEntryIDStream(CVDRowsetColumn * pColumn, HROW hRow, IStream ** ppStream)
{
    ASSERT_POINTER(pColumn, CVDRowsetColumn)
    ASSERT_POINTER(ppStream, IStream*)

	IRowset * pRowset = GetRowset();
	IAccessor * pAccessor = GetAccessor();

    // make sure we have valid rowset and accessor pointers
    if (!pRowset || !pAccessor || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessay pointers
    if (!pColumn || !ppStream)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameters
    *ppStream = NULL;

    DBBINDING binding;

    // clear out binding
    memset(&binding, 0, sizeof(DBBINDING));

    // create length binding
    binding.iOrdinal    = pColumn->GetOrdinal();
    binding.obLength    = 0;
    binding.dwPart      = DBPART_LENGTH;
    binding.dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
    binding.wType       = DBTYPE_BYTES;

    HACCESSOR hAccessor;

    // create length accessor
    HRESULT hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_IEntryID, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
        return hr;

    ULONG cbData;

    // get size of data
    hr = pRowset->GetData(hRow, hAccessor, &cbData);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_IEntryID, pRowset, IID_IRowset, m_pResourceDLL);

    // release length accessor
    pAccessor->ReleaseAccessor(hAccessor, NULL);

    if (FAILED(hr))
        return hr;

    // create value binding
    binding.iOrdinal    = pColumn->GetOrdinal();
    binding.obValue     = 0;
    binding.dwPart      = DBPART_VALUE;
    binding.dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
    binding.cbMaxLen    = cbData;
    binding.wType       = DBTYPE_BYTES;

    // create value accessor
    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_IEntryID, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
        return hr;

    // create data buffer
    HGLOBAL hData = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD, cbData);

    if (!hData)
    {
        // release value accessor
        pAccessor->ReleaseAccessor(hAccessor, NULL);

        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_IEntryID, m_pResourceDLL);
        return E_OUTOFMEMORY;
    }

    // get pointer to data buffer
    BYTE * pData = (BYTE*)GlobalLock(hData);

    // get data value
    hr = pRowset->GetData(hRow, hAccessor, pData);

    // release pointer to data buffer
    GlobalUnlock(hData);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_IEntryID, pRowset, IID_IRowset, m_pResourceDLL);

    // release value accessor
    pAccessor->ReleaseAccessor(hAccessor, NULL);

    if (FAILED(hr))
    {
        GlobalFree(hData);
        return hr;
    }

    // create stream containing data
    hr = CreateStreamOnHGlobal(hData, TRUE, ppStream);

    if (FAILED(hr))
        GlobalFree(hData);

    return hr;
}

#endif //VD_DONT_IMPLEMENT_ISTREAM

//=--------------------------------------------------------------------------=
// MakeAdjustments - Make adjustments to fixed length buffer accessor bindings
//=--------------------------------------------------------------------------=
// This function makes adjustments to the fixed length buffer accessor
// bindings, after a call to CreateAccessor fails, to try and make the
// binding more suitable
//
// Parameters:
//    ulBindings            - [in]   number of fixed length buffer bindings
//    pBindings             - [in]   a pointer to fixed length buffer bindings
//    pulIndex              - [in]   a pointer to an array of indices, which
//                                   specify which cursor binding each fixed
//                                   length buffer binding applies
//    ulTotalBindings       - [in]   number of cursor bindings
//    prghAdjustAccessors   - [out]  a pointer to memory in which to return
//                                   a pointer to adjusted fixed length buffer
//                                   accessors
//    ppdwAdjustFlags       - [out]  a pointer to memory in which to return
//                                   a pointer to adjusted fixed length buffer
//                                   accessors flags
//    fBefore               - [in]   a flag which indicated whether this call
//                                   has been made before or after the call
//                                   to CreateAccessor
//
// Output:
//    S_OK - if adjustments were made
//    E_FAIL - failed to make any adjustments
//    E_OUTOFMEMORY - not enough memory
//    E_INVALIDARG - bad parameter
//
// Notes:
//    Specifically, this function can make the following adjustments...
//       (1) Change variant binding byte field -> byte binding          (fails in GetData)
//       (2) Change variant binding date field -> wide string binding   (fails in CreateAccessor)
//       (3) Change variant binding memo field -> string binding        (fails in CreateAccessor)
//
HRESULT CVDCursor::MakeAdjustments(ULONG ulBindings, DBBINDING * pBindings, ULONG * pulIndex, ULONG ulTotalBindings,
    HACCESSOR ** prghAdjustAccessors, DWORD ** ppdwAdjustFlags, BOOL fBefore)
{
    ASSERT_POINTER(pBindings, DBBINDING)
    ASSERT_POINTER(pulIndex, ULONG)
    ASSERT_POINTER(prghAdjustAccessors, HACCESSOR*)
    ASSERT_POINTER(ppdwAdjustFlags, DWORD*)

    IAccessor * pAccessor = GetAccessor();

    // make sure we have a valid accessor pointer
    if (!pAccessor || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pBindings || !pulIndex || !prghAdjustAccessors || !ppdwAdjustFlags)
        return E_INVALIDARG;

    BOOL fWeAllocatedMemory = FALSE;

    // try to get storage for adjusted accessors and flags
    HACCESSOR * rghAdjustAccessors = *prghAdjustAccessors;
    DWORD * pdwAdjustFlags = *ppdwAdjustFlags;

    // if not supplied, then create storage
    if (!rghAdjustAccessors || !pdwAdjustFlags)
    {
        rghAdjustAccessors = new HACCESSOR[ulTotalBindings];
        pdwAdjustFlags = new DWORD[ulTotalBindings];

        // make sure we got the requested memory
        if (!rghAdjustAccessors || !pdwAdjustFlags)
        {
            delete [] rghAdjustAccessors;
            delete [] pdwAdjustFlags;
		    VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
            return E_OUTOFMEMORY;
        }

        // clear adjusted accessors and flags
        memset(rghAdjustAccessors, 0, ulTotalBindings * sizeof(HACCESSOR));
        memset(pdwAdjustFlags, 0, ulTotalBindings * sizeof(DWORD));

        fWeAllocatedMemory = TRUE;
    }

    // initialize variables
    DBBINDING * pBinding = pBindings;
    CVDRowsetColumn * pColumn;
    DBTYPE wType;
    ULONG cbMaxLength;
    DBBINDING binding;
    HRESULT hr;
    HACCESSOR hAccessor;
    HRESULT hrAdjust = E_FAIL;

    // iterate through fixed length buffer bindings
    for (ULONG ulBind = 0; ulBind < ulBindings; ulBind++)
    {
        // first check for a variant binding, where value is to be returned
        if (pBinding->wType == DBTYPE_VARIANT && (pBinding->dwPart & DBPART_VALUE))
        {
            // get rowset column associated with this binding
            pColumn = GetRowsetColumn(pBinding->iOrdinal);

            if (pColumn)
            {
                // get attributes of this column
                wType = pColumn->GetType();
                cbMaxLength = pColumn->GetMaxLength();

                // check for a byte field
                if (fBefore && wType == DBTYPE_UI1)
                {
                    // make adjustments to fixed length buffer binding
                    pBinding->wType = DBTYPE_UI1;

                    // store associated flag
                    pdwAdjustFlags[pulIndex[ulBind]] = VD_ADJUST_VARIANT_TO_BYTE;

                    // we succeeded
                    hrAdjust = S_OK;
                }

                // check for a date field
                if (!fBefore && wType == DBTYPE_DBTIMESTAMP)
                {
                    // clear binding
                    memset(&binding, 0, sizeof(DBBINDING));

                    // create adjusted accessor binding
                    binding.iOrdinal    = pBinding->iOrdinal;
                    binding.dwPart      = DBPART_VALUE;
                    binding.dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
                    binding.cbMaxLen    = 0x7FFFFFFF;
                    binding.wType       = DBTYPE_WSTR;

                    // try to create adjusted accessor
                    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

                    if (SUCCEEDED(hr))
                    {
                        // make adjustments to fixed length buffer binding
                        pBinding->obLength  = pBinding->obValue;
                        pBinding->dwPart   &= ~DBPART_VALUE;
                        pBinding->dwPart   |= DBPART_LENGTH;
                        pBinding->wType     = DBTYPE_WSTR;

                        // store adjusted accessor and associated flag
                        rghAdjustAccessors[pulIndex[ulBind]] = hAccessor;
                        pdwAdjustFlags[pulIndex[ulBind]] = VD_ADJUST_VARIANT_TO_WSTR;

                        // we succeeded
                        hrAdjust = S_OK;
                    }
                }

                // check for a memo field
                if (!fBefore && wType == DBTYPE_STR && cbMaxLength >= 0x40000000)
                {
                    // clear binding
                    memset(&binding, 0, sizeof(DBBINDING));

                    // create adjusted accessor binding
                    binding.iOrdinal    = pBinding->iOrdinal;
                    binding.dwPart      = DBPART_VALUE;
                    binding.dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
                    binding.cbMaxLen    = 0x7FFFFFFF;
                    binding.wType       = DBTYPE_STR;

                    // try to create adjusted accessor
                    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

                    if (SUCCEEDED(hr))
                    {
                        // make adjustments to fixed length buffer binding
                        pBinding->obLength  = pBinding->obValue;
                        pBinding->dwPart   &= ~DBPART_VALUE;
                        pBinding->dwPart   |= DBPART_LENGTH;
                        pBinding->wType     = DBTYPE_STR;

                        // store adjusted accessor and associated flag
                        rghAdjustAccessors[pulIndex[ulBind]] = hAccessor;
                        pdwAdjustFlags[pulIndex[ulBind]] = VD_ADJUST_VARIANT_TO_STR;

                        // we succeeded
                        hrAdjust = S_OK;
                    }
                }
            }
        }

        pBinding++;
    }

    if (SUCCEEDED(hrAdjust))
    {
        // if we made any adjustments, return accessors and flags
        *prghAdjustAccessors = rghAdjustAccessors;
        *ppdwAdjustFlags = pdwAdjustFlags;
    }
    else if (fWeAllocatedMemory)
    {
        // destroy allocated memory
        delete [] rghAdjustAccessors;
        delete [] pdwAdjustFlags;
    }

    return hrAdjust;
}

//=--------------------------------------------------------------------------=
// ReCreateAccessors - Re-create accessors
//=--------------------------------------------------------------------------=
// This function attempts to recreate accessors based on old and new bindings
//
// Parameters:
//    ulNewCursorBindings   - [in] the number of new cursor column bindings
//    pNewCursorBindings    - [in] an array of new cursor column bindings
//    dwFlags               - [in] a flag that specifies whether to replace the
//                                 existing column bindings or add to them
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDCursor::ReCreateAccessors(ULONG ulNewCursorBindings, CURSOR_DBCOLUMNBINDING * pNewCursorBindings, DWORD dwFlags)
{
    IAccessor * pAccessor = GetAccessor();

    // make sure we have a valid accessor pointer
    if (!pAccessor || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    ULONG ulOldCursorBindings = 0;
    CURSOR_DBCOLUMNBINDING * pOldCursorBindings = NULL;

    // if we're adding bindings include old bindings
    if (dwFlags == CURSOR_DBCOLUMNBINDOPTS_ADD)
    {
        ulOldCursorBindings = m_ulCursorBindings;
        pOldCursorBindings = m_pCursorBindings;
    }

    // get total binding count (sum of old and new)
    ULONG ulTotalBindings = ulOldCursorBindings + ulNewCursorBindings;

    ULONG * pulIndex = NULL;
    DBBINDING * pBindings = NULL;
    DBBINDING * pHelperBindings = NULL;
    DBBINDING * pVarBindings = NULL;

	if (ulTotalBindings)
	{
		// create storage for new rowset bindings
		pulIndex = new ULONG[ulTotalBindings];
		pBindings = new DBBINDING[ulTotalBindings];
		pHelperBindings = new DBBINDING[ulTotalBindings];
		pVarBindings = new DBBINDING[ulTotalBindings];

		// make sure we got all requested memory
		if (!pulIndex || !pBindings || !pHelperBindings || !pVarBindings)
		{
			delete [] pulIndex;
			delete [] pBindings;
			delete [] pHelperBindings;
			delete [] pVarBindings;
			VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
			return E_OUTOFMEMORY;
		}

		// clear rowset bindings
		memset(pulIndex, 0, ulTotalBindings * sizeof(ULONG));
		memset(pBindings, 0, ulTotalBindings * sizeof(DBBINDING));
		memset(pHelperBindings, 0, ulTotalBindings * sizeof(DBBINDING));
		memset(pVarBindings, 0, ulTotalBindings * sizeof(DBBINDING));
	}

    // set adjustments to null
    HACCESSOR * rghAdjustAccessors = NULL;
    DWORD * pdwAdjustFlags = NULL;

    HRESULT hr;
    WORD wType;
    ULONG ulBindings = 0;
    ULONG ulHelperBindings = 0;
    ULONG ulVarBindings = 0;
    ULONG obVarDataInfo = 0;
    DBBINDING * pBinding = pBindings;
    DBBINDING * pHelperBinding = pHelperBindings;
    DBBINDING * pVarBinding = pVarBindings;
    CURSOR_DBCOLUMNBINDING * pCursorBinding = pOldCursorBindings;
    CVDRowsetColumn * pColumn;
    BOOL fEntryIDBinding;

    // iterate through cursor bindings and set rowset bindings
	for (ULONG ulCol = 0; ulCol < ulTotalBindings; ulCol++)
    {
        // if necessary, switch to new bindings
        if (ulCol == ulOldCursorBindings)
            pCursorBinding = pNewCursorBindings;

        // get rowset column for this binding
        pColumn = GetRowsetColumn(pCursorBinding->columnID);

        // get desired rowset datatype
        wType = CVDRowsetColumn::CursorTypeToType((CURSOR_DBVARENUM)pCursorBinding->dwDataType);

        // set entryID binding flag
        fEntryIDBinding = (pCursorBinding->dwBinding & CURSOR_DBBINDING_ENTRYID);

        // check for datatypes which require variable length buffer
        if (DoesCursorTypeNeedVarData(pCursorBinding->dwDataType))
        {
            // create fixed length buffer binding
            pBinding->iOrdinal      = pColumn->GetOrdinal();
            pBinding->dwMemOwner    = DBMEMOWNER_CLIENTOWNED;
            pBinding->wType         = wType;

            // determine offset to the length part
            if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
            {
                pBinding->obLength  = pCursorBinding->obVarDataLen;
                pBinding->dwPart   |= DBPART_LENGTH;
            }

            // determine offset to the status part
            if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
            {
                pBinding->obStatus  = pCursorBinding->obInfo;
                pBinding->dwPart   |= DBPART_STATUS;
            }

            // BLOBs always require the length part
            if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB &&
                pCursorBinding->obData != CURSOR_DB_NOVALUE && !fEntryIDBinding)
            {
                pBinding->obLength  = pCursorBinding->obData;
                pBinding->dwPart   |= DBPART_LENGTH;
            }

            // bookmark columns require native type
            if (!pColumn->GetDataColumn())
                pBinding->wType = pColumn->GetType();

            // create variable length helper buffer binding
            if (!pColumn->GetFixed() && !fEntryIDBinding)
            {
                // if column contains variable length data, then create binding
                pHelperBinding->iOrdinal    = pColumn->GetOrdinal();
                pHelperBinding->obLength    = obVarDataInfo;
                pHelperBinding->obStatus    = obVarDataInfo + sizeof(ULONG);
                pHelperBinding->dwPart      = DBPART_LENGTH | DBPART_STATUS;
                pHelperBinding->dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
                pHelperBinding->wType       = wType;
            }

            // always increase offset in helper buffer
            obVarDataInfo += sizeof(ULONG) + sizeof(DBSTATUS);

            // create variable length buffer binding
            pVarBinding->iOrdinal       = pColumn->GetOrdinal();
            pVarBinding->dwPart         = DBPART_VALUE;
            pVarBinding->dwMemOwner     = DBMEMOWNER_CLIENTOWNED;
            pVarBinding->cbMaxLen       = pCursorBinding->cbMaxLen;
            pVarBinding->wType          = wType;

            // adjust for no maximum length
            if (pVarBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                pVarBinding->cbMaxLen = 0x7FFFFFFF;
        }
        else    // datatype requires only fixed length buffer
        {
            // create fixed length buffer binding
            pBinding->iOrdinal      = pColumn->GetOrdinal();
            pBinding->dwMemOwner    = DBMEMOWNER_CLIENTOWNED;
            pBinding->cbMaxLen      = pCursorBinding->cbMaxLen;
            pBinding->wType         = wType;

            // determine offset to the value part
            if (pCursorBinding->obData != CURSOR_DB_NOVALUE && !fEntryIDBinding)
            {
                pBinding->obValue   = pCursorBinding->obData;
                pBinding->dwPart   |= DBPART_VALUE;
            }

            // determine offset to the length part
            if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
            {
                pBinding->obLength  = pCursorBinding->obVarDataLen;
                pBinding->dwPart   |= DBPART_LENGTH;
            }

            // determine offset to the status part
            if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
            {
                pBinding->obStatus  = pCursorBinding->obInfo;
                pBinding->dwPart   |= DBPART_STATUS;
            }

            // BYTES always require the length part
            if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BYTES &&
                pCursorBinding->obData != CURSOR_DB_NOVALUE && !fEntryIDBinding)
            {
                pBinding->obLength  = pCursorBinding->obData;
                pBinding->obValue  += sizeof(ULONG);
                pBinding->dwPart   |= DBPART_LENGTH;
            }

            // check for variant binding, in which case ask for variant
            if (pCursorBinding->dwBinding & CURSOR_DBBINDING_VARIANT)
                pBinding->wType = DBTYPE_VARIANT;
        }

        // if any parts needed, increment fixed buffer binding
        if (pBinding->dwPart)
        {
            pulIndex[ulBindings] = ulCol;
            ulBindings++;
            pBinding++;
        }

        // if any parts needed, increment variable buffer helper binding
        if (pHelperBinding->dwPart)
        {
            ulHelperBindings++;
            pHelperBinding++;
        }

        // if any parts needed, increment variable buffer binding count
        if (pVarBinding->dwPart)
        {
            // entryID bindings do not need value part
            if (fEntryIDBinding)
                pVarBinding->dwPart &= ~DBPART_VALUE;

            ulVarBindings++;
        }

        // however, always increment variable buffer binding
        pVarBinding++;

        // get next cursor binding
        pCursorBinding++;
    }

    hr = S_OK;

    // try to create fixed length buffer accessor
    HACCESSOR hAccessor = 0;

    if (ulBindings)
	{
		// make adjustments that can cause failure in GetData
		MakeAdjustments(ulBindings, pBindings, pulIndex, ulTotalBindings, &rghAdjustAccessors, &pdwAdjustFlags, TRUE);

    	hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, ulBindings, pBindings, 0, &hAccessor, NULL);
	}

    if (FAILED(hr))
    {
        // make other known adjustments that can cause CreateAccessor to fail
        hr = MakeAdjustments(ulBindings, pBindings, pulIndex, ulTotalBindings, &rghAdjustAccessors, &pdwAdjustFlags, FALSE);

        if (SUCCEEDED(hr))
            hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, ulBindings, pBindings, 0, &hAccessor, NULL);
    }

    delete [] pulIndex;
    delete [] pBindings;

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_ICursor, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
    {
        delete [] pHelperBindings;
        delete [] pVarBindings;
        ReleaseAccessorArray(rghAdjustAccessors);
        delete [] rghAdjustAccessors;
        delete [] pdwAdjustFlags;
        return hr;
    }

    // try to create variable length buffer accessors helper
    HACCESSOR hVarHelper = 0;

    if (ulHelperBindings)
    	hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, ulHelperBindings, pHelperBindings, 0, &hVarHelper, NULL);

    delete [] pHelperBindings;

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_ICursor, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
    {
        pAccessor->ReleaseAccessor(hAccessor, NULL);
        delete [] pVarBindings;
        ReleaseAccessorArray(rghAdjustAccessors);
        delete [] rghAdjustAccessors;
        delete [] pdwAdjustFlags;
        return hr;
    }

    // try to create variable length buffer accessors
    HACCESSOR * rghVarAccessors = NULL;

    if (ulTotalBindings)
    {
        rghVarAccessors = new HACCESSOR[ulTotalBindings];

        if (!rghVarAccessors)
            hr = E_OUTOFMEMORY;
        else
        {
            pVarBinding = pVarBindings;
            memset(rghVarAccessors, 0, ulTotalBindings * sizeof(HACCESSOR));

            // iterate through rowset bindings and create accessor for one which have a part
            for (ULONG ulBind = 0; ulBind < ulTotalBindings && SUCCEEDED(hr); ulBind++)
            {
                if (pVarBinding->dwPart)
	                hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, pVarBinding, 0, &rghVarAccessors[ulBind], NULL);

                pVarBinding++;
            }
        }
    }

    delete [] pVarBindings;

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_ICursor, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
    {
        if (rghVarAccessors)
        {
            // iterate through rowset bindings and destroy any created accessors
            for (ULONG ulBind = 0; ulBind < ulTotalBindings; ulBind++)
            {
                if (rghVarAccessors[ulBind])
                    pAccessor->ReleaseAccessor(rghVarAccessors[ulBind], NULL);
            }

            delete [] rghVarAccessors;
        }

        pAccessor->ReleaseAccessor(hAccessor, NULL);
        pAccessor->ReleaseAccessor(hVarHelper, NULL);
        ReleaseAccessorArray(rghAdjustAccessors);
        delete [] rghAdjustAccessors;
        delete [] pdwAdjustFlags;
        return hr;
    }

    // destroy old accessors
    DestroyAccessors();

    // store new accessors
    m_hAccessor = hAccessor;
    m_hVarHelper = hVarHelper;
    m_ulVarBindings = ulVarBindings;
    m_rghVarAccessors = rghVarAccessors;
    m_rghAdjustAccessors = rghAdjustAccessors;
    m_pdwAdjustFlags = pdwAdjustFlags;

    return hr;
}

//=--------------------------------------------------------------------------=
// ReleaseAccessorArray - Release all accessors in specified array
//
void CVDCursor::ReleaseAccessorArray(HACCESSOR * rghAccessors)
{
    IAccessor * pAccessor = GetAccessor();

    if (pAccessor && rghAccessors)
    {
        for (ULONG ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            if (rghAccessors[ulBind])
            {
                pAccessor->ReleaseAccessor(rghAccessors[ulBind], NULL);
                rghAccessors[ulBind] = NULL;
            }
        }
    }
}

//=--------------------------------------------------------------------------=
// DestroyAccessors - Destroy all rowset accessors
//
void CVDCursor::DestroyAccessors()
{
    IAccessor * pAccessor = GetAccessor();

    if (pAccessor && m_hAccessor)
    {
        pAccessor->ReleaseAccessor(m_hAccessor, NULL);
        m_hAccessor = 0;
    }

    if (pAccessor && m_hVarHelper)
    {
        pAccessor->ReleaseAccessor(m_hVarHelper, NULL);
        m_hVarHelper = 0;
    }

    m_ulVarBindings = 0;

    ReleaseAccessorArray(m_rghVarAccessors);
    delete [] m_rghVarAccessors;
    m_rghVarAccessors = NULL;

    ReleaseAccessorArray(m_rghAdjustAccessors);
    delete [] m_rghAdjustAccessors;
    m_rghAdjustAccessors = NULL;

    delete [] m_pdwAdjustFlags;
    m_pdwAdjustFlags = NULL;
}

//=--------------------------------------------------------------------------=
// ReCreateColumns - Re-create rowset columns associated with current bindings
//
HRESULT CVDCursor::ReCreateColumns()
{
    DestroyColumns();

    if (m_ulCursorBindings)
    {
        m_ppColumns = new CVDRowsetColumn*[m_ulCursorBindings];

        if (!m_ppColumns)
        {
            VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
            return E_OUTOFMEMORY;
        }

        CURSOR_DBCOLUMNBINDING * pCursorBinding = m_pCursorBindings;

        for (ULONG ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            m_ppColumns[ulBind] = GetRowsetColumn(pCursorBinding->columnID);
            pCursorBinding++;
        }
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// DestroyColumns - Destroy rowset column pointers
//
void CVDCursor::DestroyColumns()
{
    delete [] m_ppColumns;
    m_ppColumns = NULL;
}

//=--------------------------------------------------------------------------=
// InsertNewRow - Insert a new row and set in cursor position object
//
HRESULT CVDCursor::InsertNewRow()
{
	IRowset * pRowset = GetRowset();
    IAccessor * pAccessor = GetAccessor();
	IRowsetChange * pRowsetChange = GetRowsetChange();

    // make sure we have valid rowset, accessor and change pointers
    if (!pRowset || !pAccessor || !pRowsetChange || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    HACCESSOR hAccessor;

    // create null accessor
    HRESULT hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 0, NULL, 0, &hAccessor, NULL);

    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_ICursorUpdateARow, pAccessor, IID_IAccessor,
        m_pResourceDLL);

    if (FAILED(hr))
        return hr;

    HROW hRow;

    // insert an empty row using null accessor (set/clear internal insert row flag)
    GetCursorMain()->SetInternalInsertRow(TRUE);
    hr = pRowsetChange->InsertRow(0, hAccessor, NULL, &hRow);
    GetCursorMain()->SetInternalInsertRow(FALSE);

    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_INSERTROWFAILED, IID_ICursorUpdateARow, pRowsetChange, IID_IRowsetChange,
        m_pResourceDLL);

    // release null accessor
    pAccessor->ReleaseAccessor(hAccessor, NULL);

    if (FAILED(hr))
        return hr;

    // set hRow in cursor position object
    hr = m_pCursorPosition->SetAddHRow(hRow);

    // release our reference on hRow
	pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);

    return hr;
}

//=--------------------------------------------------------------------------=
// GetOriginalColumn - Get original column data using same-row clone
//
HRESULT CVDCursor::GetOriginalColumn(CVDRowsetColumn * pColumn, CURSOR_DBBINDPARAMS * pBindParams)
{
    ASSERT_POINTER(pColumn, CVDRowsetColumn)
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)

    // make sure we have all necessary pointers
    if (!pColumn || !pBindParams || !pBindParams->pData)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // get hRow of the row currently being edited
    HROW hRow = m_pCursorPosition->GetEditRow();

    // see if we already have a same-row clone
    ICursor * pSameRowClone = m_pCursorPosition->GetSameRowClone();

    if (!pSameRowClone)
    {
        // if not, create new same-row clone
        HRESULT hr = Clone(CURSOR_DBCLONEOPTS_SAMEROW, IID_ICursor, (IUnknown**)&pSameRowClone);

        if (FAILED(hr))
            return hr;

        // set same-row clone in cursor position object
        m_pCursorPosition->SetSameRowClone(pSameRowClone);
    }

    CURSOR_DBCOLUMNBINDING columnBinding;

    // set common column binding members
    columnBinding.columnID      = pColumn->GetCursorColumnID();
    columnBinding.obData        = CURSOR_DB_NOVALUE;
    columnBinding.cbMaxLen      = pBindParams->cbMaxLen;
    columnBinding.obVarDataLen  = CURSOR_DB_NOVALUE;
    columnBinding.obInfo        = CURSOR_DB_NOVALUE;
    columnBinding.dwBinding     = CURSOR_DBBINDING_DEFAULT;
    columnBinding.dwDataType    = pBindParams->dwDataType;

    // adjust column binding for variable length datatypes
    if (DoesCursorTypeNeedVarData(pBindParams->dwDataType))
    {
        switch (pBindParams->dwDataType)
        {
            case CURSOR_DBTYPE_BLOB:
                columnBinding.dwDataType = CURSOR_DBTYPE_BYTES;
                break;

            case CURSOR_DBTYPE_LPSTR:
                columnBinding.dwDataType = CURSOR_DBTYPE_CHARS;
                break;

            case CURSOR_DBTYPE_LPWSTR:
                columnBinding.dwDataType = CURSOR_DBTYPE_WCHARS;
                break;
        }
    }

    CURSOR_DBFETCHROWS fetchRows;

    // set common fetch rows members
    fetchRows.cRowsRequested    = 1;
    fetchRows.dwFlags           = CURSOR_DBROWFETCH_DEFAULT;
    fetchRows.pVarData          = NULL;
    fetchRows.cbVarData         = 0;

    // retrieve length and/or information field if requested
    if (pBindParams->cbVarDataLen != CURSOR_DB_NOVALUE || pBindParams->dwInfo != CURSOR_DB_NOVALUE)
    {
        // set column binding offsets
        if (pBindParams->cbVarDataLen != CURSOR_DB_NOVALUE)
            columnBinding.obVarDataLen = offsetof(CURSOR_DBBINDPARAMS, cbVarDataLen);

        if (pBindParams->dwInfo != CURSOR_DB_NOVALUE)
            columnBinding.obInfo = offsetof(CURSOR_DBBINDPARAMS, dwInfo);

        // set bindings on same-row clone
        HRESULT hr = pSameRowClone->SetBindings(1, &columnBinding, 0, CURSOR_DBCOLUMNBINDOPTS_REPLACE);

        if (FAILED(hr))
            return hr;

        // set fetch rows buffer
        fetchRows.pData = pBindParams;

        // retrieve length and/or information field from same-row clone
        hr = ((CVDCursor*)pSameRowClone)->FillConsumersBuffer(S_OK, &fetchRows, 1, &hRow);

        if (FAILED(hr))
            return hr;
    }

    // set column binding offsets and bind-type
    columnBinding.obData        = 0;
    columnBinding.obVarDataLen  = CURSOR_DB_NOVALUE;
    columnBinding.obInfo        = CURSOR_DB_NOVALUE;
    columnBinding.dwBinding     = pBindParams->dwBinding;

    // adjust offsets for variable length datatypes
    if (DoesCursorTypeNeedVarData(pBindParams->dwDataType))
    {
        columnBinding.dwBinding = CURSOR_DBBINDING_DEFAULT;

        if (pBindParams->dwBinding & CURSOR_DBBINDING_VARIANT)
        {
            if (pBindParams->dwDataType == CURSOR_DBTYPE_BLOB)
                columnBinding.obVarDataLen = columnBinding.obData;

            columnBinding.obData += sizeof(CURSOR_DBVARIANT);
        }
        else
        {
            switch (pBindParams->dwDataType)
            {
                case CURSOR_DBTYPE_BLOB:
                    columnBinding.obVarDataLen  = columnBinding.obData;
                    columnBinding.obData       += sizeof(ULONG) + sizeof(LPBYTE);
                    break;

                case CURSOR_DBTYPE_LPSTR:
                    columnBinding.obData       += sizeof(LPSTR);
                    break;

                case CURSOR_DBTYPE_LPWSTR:
                    columnBinding.obData       += sizeof(LPWSTR);
                    break;
            }
        }
    }

    // set bindings on same-row clone
    HRESULT hr = pSameRowClone->SetBindings(1, &columnBinding, pBindParams->cbMaxLen, CURSOR_DBCOLUMNBINDOPTS_REPLACE);

    if (FAILED(hr))
        return hr;

    // set fetch rows buffer
    fetchRows.pData = pBindParams->pData;

    // retrieve data value from same-row clone
    hr = ((CVDCursor*)pSameRowClone)->FillConsumersBuffer(S_OK, &fetchRows, 1, &hRow);

    if (FAILED(hr))
        return hr;

    // place data pointers in buffer for variable length datatypes
    if (DoesCursorTypeNeedVarData(pBindParams->dwDataType))
    {
        BYTE * pData = (BYTE*)pBindParams->pData;

        // first check for variant binding
        if (pBindParams->dwBinding & CURSOR_DBBINDING_VARIANT)
        {
            CURSOR_BLOB cursorBlob;
            CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)pBindParams->pData;

            switch (pBindParams->dwDataType)
			{
				case CURSOR_DBTYPE_BLOB:
					cursorBlob.cbSize       = *(ULONG*)pVariant;
					cursorBlob.pBlobData    = pData + sizeof(CURSOR_DBVARIANT);
					VariantInit((VARIANT*)pVariant);
					pVariant->vt            = CURSOR_DBTYPE_BLOB;
					pVariant->blob          = cursorBlob;
					break;

				case CURSOR_DBTYPE_LPSTR:
					VariantInit((VARIANT*)pVariant);
					pVariant->vt        = CURSOR_DBTYPE_LPSTR;
					pVariant->pszVal    = (LPSTR)(pData + sizeof(CURSOR_DBVARIANT));
					break;

				case CURSOR_DBTYPE_LPWSTR:
					VariantInit((VARIANT*)pVariant);
					pVariant->vt        = CURSOR_DBTYPE_LPSTR;
					pVariant->pwszVal   = (LPWSTR)(pData + sizeof(CURSOR_DBVARIANT));
					break;
			}
        }
        else // otherwise, default binding
        {
            switch (pBindParams->dwDataType)
            {
                case CURSOR_DBTYPE_BLOB:
                    *(LPBYTE*)(pData + sizeof(ULONG)) = pData + sizeof(ULONG) + sizeof(LPBYTE);
                    break;

                case CURSOR_DBTYPE_LPSTR:
                    *(LPSTR*)pData = (LPSTR)(pData + sizeof(LPSTR));
                    break;

                case CURSOR_DBTYPE_LPWSTR:
                    *(LPWSTR*)pData = (LPWSTR)(pData + sizeof(LPWSTR));
                    break;
            }
        }
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// GetModifiedColumn - Get modified column data from column update object
//
HRESULT CVDCursor::GetModifiedColumn(CVDColumnUpdate * pColumnUpdate, CURSOR_DBBINDPARAMS * pBindParams)
{
    ASSERT_POINTER(pColumnUpdate, CVDColumnUpdate)
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)

    // make sure we have all necessary pointers
    if (!pColumnUpdate || !pBindParams || !pBindParams->pData)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // get source variant
    CURSOR_DBVARIANT varSrc = pColumnUpdate->GetVariant();

    // check for any variant binding
    if (pBindParams->dwDataType == CURSOR_DBTYPE_ANYVARIANT)
        pBindParams->dwDataType = varSrc.vt;

    // determine which type the destination variant should be
    VARTYPE vtDest = (VARTYPE)pBindParams->dwDataType;

    switch (vtDest)
    {
        case CURSOR_DBTYPE_BYTES:
            vtDest = CURSOR_DBTYPE_BLOB;
            break;

        case CURSOR_DBTYPE_CHARS:
        case CURSOR_DBTYPE_WCHARS:
        case CURSOR_DBTYPE_LPSTR:
        case CURSOR_DBTYPE_LPWSTR:
            vtDest = VT_BSTR;
            break;
    }

    HRESULT hr = S_OK;
    CURSOR_DBVARIANT varDest;
    BOOL fVariantCreated = FALSE;

    // init destination variant
    VariantInit((VARIANT*)&varDest);

    // get destination variant
    if (varSrc.vt != vtDest)
    {
        // if the types do not match, then create a variant of the desired type
        hr = VariantChangeType((VARIANT*)&varDest, (VARIANT*)&varSrc, 0, vtDest);
        fVariantCreated = TRUE;
    }
    else
        varDest = varSrc;

    if (FAILED(hr))
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // get pointer to data
    BYTE * pData = (BYTE*)pBindParams->pData;

    // return coerced data
    if (pBindParams->dwBinding & CURSOR_DBBINDING_VARIANT)
    {
        // get pointer to variant data
        CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)pData;

        // return variant
        *pVariant = varDest;

        // adjust variant for variable length datatypes
        if (pBindParams->dwDataType == CURSOR_DBTYPE_BLOB)
        {
            pVariant->blob.pBlobData = pData + sizeof(CURSOR_DBVARIANT);
            memcpy(pData + sizeof(CURSOR_DBVARIANT), varDest.blob.pBlobData, varDest.blob.cbSize);
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_LPSTR)
        {
			ULONG cbLength = GET_MBCSLEN_FROMWIDE(varDest.bstrVal);
		    MAKE_MBCSPTR_FROMWIDE(psz, varDest.bstrVal);
            pVariant->pszVal = (LPSTR)(pData + sizeof(CURSOR_DBVARIANT));
		    memcpy(pData + sizeof(CURSOR_DBVARIANT), psz, min(pBindParams->cbMaxLen, cbLength));
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_LPWSTR)
        {
            ULONG cbLength = (lstrlenW(varDest.bstrVal) + 1) * sizeof(WCHAR);
            pVariant->pwszVal = (LPWSTR)(pData + sizeof(CURSOR_DBVARIANT));
            memcpy(pData + sizeof(CURSOR_DBVARIANT), varDest.bstrVal, min(pBindParams->cbMaxLen, cbLength));
        }
        else if (pBindParams->dwDataType == VT_BSTR)
        {
            pVariant->bstrVal = SysAllocString(pVariant->bstrVal);
        }
    }
    else // otherwise, default binding
    {
        // first check for variable length datatypes
        if (pBindParams->dwDataType == CURSOR_DBTYPE_BYTES)
        {
            *(ULONG*)pData = varDest.blob.cbSize;
            memcpy(pData + sizeof(ULONG), varDest.blob.pBlobData, varDest.blob.cbSize);
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_CHARS)
        {
			ULONG cbLength = GET_MBCSLEN_FROMWIDE(varDest.bstrVal);
		    MAKE_MBCSPTR_FROMWIDE(psz, varDest.bstrVal);
		    memcpy(pData, psz, min(pBindParams->cbMaxLen, cbLength));
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_WCHARS)
        {
            ULONG cbLength = (lstrlenW(varDest.bstrVal) + 1) * sizeof(WCHAR);
            memcpy(pData, varDest.bstrVal, min(pBindParams->cbMaxLen, cbLength));
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_BLOB)
        {
            *(ULONG*)pData = varDest.blob.cbSize;
            *(LPBYTE*)(pData + sizeof(ULONG)) = pData + sizeof(ULONG) + sizeof(LPBYTE);
            memcpy(pData + sizeof(ULONG) + sizeof(LPBYTE), varDest.blob.pBlobData, varDest.blob.cbSize);
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_LPSTR)
        {
			ULONG cbLength = GET_MBCSLEN_FROMWIDE(varDest.bstrVal);
		    MAKE_MBCSPTR_FROMWIDE(psz, varDest.bstrVal);
            *(LPSTR*)pData = (LPSTR)(pData + sizeof(LPSTR));
		    memcpy(pData + sizeof(LPSTR), psz, min(pBindParams->cbMaxLen, cbLength));
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_LPWSTR)
        {
            ULONG cbLength = (lstrlenW(varDest.bstrVal) + 1) * sizeof(WCHAR);
            *(LPWSTR*)pData = (LPWSTR)(pData + sizeof(LPWSTR));
            memcpy(pData + sizeof(LPWSTR), varDest.bstrVal, min(pBindParams->cbMaxLen, cbLength));
        }
        else // fixed length datatypes
        {
            ULONG cbLength = CVDCursorBase::GetCursorTypeLength(pBindParams->dwDataType, 0);
            memcpy(pData, &varDest.cyVal, cbLength);
        }
    }

    // if created, destroy variant
    if (fVariantCreated)
        VariantClear((VARIANT*)&varDest);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// Create - Create cursor object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new cursor object
//
// Parameters:
//    pCursorPosition   - [in]  backwards pointer to CVDCursorPosition object
//    ppCursor          - [out] a pointer in which to return pointer to cursor object
//    pResourceDLL      - [in]  a pointer which keeps track of resource DLL
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDCursor::Create(CVDCursorPosition * pCursorPosition, CVDCursor ** ppCursor, CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pCursorPosition, CVDCursorPosition)
    ASSERT_POINTER(ppCursor, CVDCursor*)
    ASSERT_POINTER(pResourceDLL, CVDResourceDLL)

    if (!pCursorPosition || !ppCursor)
        return E_INVALIDARG;

    *ppCursor = NULL;

    CVDCursor * pCursor = new CVDCursor();

    if (!pCursor)
        return E_OUTOFMEMORY;

	// create connection point container
    HRESULT hr = CVDNotifyDBEventsConnPtCont::Create(pCursor, &pCursor->m_pConnPtContainer);

	if (FAILED(hr))
	{
		delete pCursor;
		return hr;
	}

    ((CVDNotifier*)pCursorPosition)->AddRef();  // add reference to associated cursor position object

    pCursor->m_pCursorPosition = pCursorPosition;
    pCursor->m_pResourceDLL = pResourceDLL;

	// add to pCursorPosition's notification family
	pCursor->JoinFamily(pCursorPosition);

    *ppCursor = pCursor;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDCursor::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

    *ppvObjOut = NULL;

    switch (riid.Data1)
    {
        QI_INTERFACE_SUPPORTED_IF(this, ICursorUpdateARow, GetRowsetChange());
        QI_INTERFACE_SUPPORTED_IF(this, ICursorFind, GetRowsetFind());
        QI_INTERFACE_SUPPORTED(this, IEntryID);
        QI_INTERFACE_SUPPORTED(m_pConnPtContainer, IConnectionPointContainer);
    }

    if (NULL == *ppvObjOut)
        return CVDCursorBase::QueryInterface(riid, ppvObjOut);

    CVDNotifier::AddRef();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef (this override is needed to instantiate class)
//
ULONG CVDCursor::AddRef(void)
{
    return CVDNotifier::AddRef();
}

//=--------------------------------------------------------------------------=
// IUnknown Release (this override is needed to instantiate class)
//
ULONG CVDCursor::Release(void)
{
    return CVDNotifier::Release();
}

//=--------------------------------------------------------------------------=
// ICursor methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursor GetColumnsCursor
//=--------------------------------------------------------------------------=
// Creates a cursor containing information about the current cursor
//
// Parameters:
//    riid              - [in]  the interface ID to which to return a pointer
//    ppvColumnsCursor  - [out] a pointer to memory in which to return the
//                              interface pointer
//    pcRows            - [out] a pointer to memory in which to return the
//                              number of rows in the metadata cursor
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL can't create cursor
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_NOINTERFACE interface not available
//
// Notes:
//
HRESULT CVDCursor::GetColumnsCursor(REFIID riid, IUnknown **ppvColumnsCursor, ULONG *pcRows)
{
    ASSERT_POINTER(ppvColumnsCursor, IUnknown*)
    ASSERT_NULL_OR_POINTER(pcRows, ULONG)

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    if (!ppvColumnsCursor)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameters
    *ppvColumnsCursor = NULL;

    if (pcRows)
        *pcRows = 0;

    // make sure caller asked for an available interface
    if (riid != IID_IUnknown && riid != IID_ICursor && riid != IID_ICursorMove && riid != IID_ICursorScroll)
    {
        VDSetErrorInfo(IDS_ERR_NOINTERFACE, IID_ICursor, m_pResourceDLL);
        return E_NOINTERFACE;
    }

    // create metadata cursor
    CVDMetadataCursor * pMetadataCursor;

    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumns = GetCursorMain()->InternalGetColumns();

    ULONG ulMetaColumns = GetCursorMain()->GetMetaColumnsCount();
    CVDRowsetColumn * pMetaColumns = GetCursorMain()->InternalGetMetaColumns();
	
	if (!GetCursorMain()->IsColumnsRowsetSupported())
		ulMetaColumns -= VD_COLUMNSROWSET_MAX_OPT_COLUMNS;

    HRESULT hr = CVDMetadataCursor::Create(ulColumns,
											pColumns,
											ulMetaColumns,
											pMetaColumns,
											&pMetadataCursor,
											m_pResourceDLL);

    if (FAILED(hr)) // the only reason for failing here is an out of memory condition
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
        return hr;
    }

    *ppvColumnsCursor = (ICursor*)pMetadataCursor;

    if (pcRows)
        *pcRows = ulColumns;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursor SetBindings
//=--------------------------------------------------------------------------=
// Replaces the existing column bindings or adds new column bindings to the
// existing ones
//
// Parameters:
//    cCol              - [in] the number of columns to bind
//    rgBoundColumns    - [in] an array of column bindings, one for each
//                             column for which data is to be returned
//    cbRowLength       - [in] the number of bytes of inline memory in a
//                             single row of data
//    dwFlags           - [in] a flag that specifies whether to replace the
//                             existing column bindings or add to them
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              CURSOR_DB_E_BADBINDINFO bad binding information
//              CURSOR_DB_E_COLUMNUNAVAILABLE columnID is not available
//              CURSOR_DB_E_ROWTOOSHORT cbRowLength was less than the minumum (and not zero)
//
// Notes:
//
HRESULT CVDCursor::SetBindings(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags)
{
    ASSERT_NULL_OR_POINTER(rgBoundColumns, CURSOR_DBCOLUMNBINDING)

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    if (!cCol && dwFlags == CURSOR_DBCOLUMNBINDOPTS_ADD)
        return S_OK;

    if (cCol && !rgBoundColumns)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    if (dwFlags != CURSOR_DBCOLUMNBINDOPTS_REPLACE && dwFlags != CURSOR_DBCOLUMNBINDOPTS_ADD)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // make sure the bindings are okay
    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumns = GetCursorMain()->InternalGetColumns();

    ULONG cbNewRowLength;
    ULONG cbNewVarRowLength;

    HRESULT hr = ValidateCursorBindings(ulColumns, pColumns, cCol, rgBoundColumns, cbRowLength, dwFlags,
        &cbNewRowLength, &cbNewVarRowLength);

    if (SUCCEEDED(hr))
    {
        // if so, then try to create new accessors
        hr = ReCreateAccessors(cCol, rgBoundColumns, dwFlags);

        if (SUCCEEDED(hr))
        {
            // if all is okay, then set bindings in cursor
            hr = CVDCursorBase::SetBindings(cCol, rgBoundColumns, cbRowLength, dwFlags);

            if (SUCCEEDED(hr))
            {
                // store new row lengths computed during validation
                m_cbRowLength = cbNewRowLength;
                m_cbVarRowLength = cbNewVarRowLength;

                // recreate column pointers
                hr = ReCreateColumns();
            }
        }
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// FilterNewRow - Filter addrow from fetch
//=--------------------------------------------------------------------------=
// This function determines if the last row fetch was an addrow, in which case
// it releases and removes this row from the block of fetched hRows
//
// Parameters:
//    pcRowsObtained    - [in/out] a pointer to the number of hRows
//    rghRows           - [in/out] an array of nRows fetched
//    hr				- [in]     result of fetch
//
// Output:
//    HRESULT - E_FAIL rowset is invalid
//              E_INVALIDARG bad parameter
//              DB_E_BADSTARTPOSITION no rows fetched
//              DB_S_ENDOFROWSET reached end of rowset
//
// Notes:
//    This function was added to assist in filtering out of add-rows which 
//    appear as part of the underlying rowset, however should not appear as 
//    part of the implemeted cursor.
//
HRESULT CVDCursor::FilterNewRow(ULONG * pcRowsObtained, HROW * rghRows, HRESULT hr)
{
    ASSERT_POINTER(pcRowsObtained, ULONG)
    ASSERT_NULL_OR_POINTER(rghRows, HROW)

	IRowset * pRowset = GetRowset();

    // make sure we have a valid rowset pointer
    if (!pRowset || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have necessary pointers
    if (!pcRowsObtained || *pcRowsObtained && !rghRows)
        return E_INVALIDARG;

	if (*pcRowsObtained == 0)
		return hr;

    // detemine if last row fetched is an addrow
	if (GetCursorMain()->IsSameRowAsNew(rghRows[*pcRowsObtained - 1]))
	{
		// if so, release hRow
		pRowset->ReleaseRows(1, &rghRows[*pcRowsObtained - 1], NULL, NULL, NULL);

		// decrement fetch count
        *pcRowsObtained -= 1;

        // return appropriate result
		return *pcRowsObtained == 0 ? DB_E_BADSTARTPOSITION : DB_S_ENDOFROWSET;
	}

	return hr;
}

//=--------------------------------------------------------------------------=
// ICursor GetNextRows
//=--------------------------------------------------------------------------=
// Fetches the specified number of rows starting with the row after the
// current one
//
// Parameters:
//    udlRowsToSkip     - [in]      the number of rows to skip before fetching
//    pFetchParams      - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL rowset is invalid
//              CURSOR_DB_S_ENDOFCURSOR reached end of the cursor
//
// Notes:
//
HRESULT CVDCursor::GetNextRows(LARGE_INTEGER udlRowsToSkip, CURSOR_DBFETCHROWS *pFetchParams)
{
    ASSERT_NULL_OR_POINTER(pFetchParams, CURSOR_DBFETCHROWS)

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    // return if caller doesn't supply fetch rows structure
    if (!pFetchParams)
        return S_OK;

    // vaildate fetch params (implemented on CVDCursorBase
	HRESULT hr = ValidateFetchParams(pFetchParams, IID_ICursor);

    // return if fetch params are invalid
	if (FAILED(hr))
		return hr;

    // return if caller didn't ask for any rows
    if (!pFetchParams->cRowsRequested)
        return S_OK;

    HRESULT hrFetch;
    IRowset * pRowset = GetRowset();

    // notify other interested parties
   	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_CHANGED;
	CURSOR_DBNOTIFYREASON rgReasons[1];
	
	rgReasons[0].dwReason	= CURSOR_DBREASON_MOVE;
	rgReasons[0].arg1		= m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();

	VariantInit((VARIANT*)&rgReasons[0].arg2);
	rgReasons[0].arg2.vt		= VT_I8;
	rgReasons[0].arg2.cyVal.Lo	= udlRowsToSkip.LowPart;
	rgReasons[0].arg2.cyVal.Hi	= udlRowsToSkip.HighPart;

	hrFetch = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

    // make sure action was not cancelled
    if (hrFetch != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

	// make sure that an update is not already in progress
	if (m_pCursorPosition->GetEditMode() != CURSOR_DBEDITMODE_NONE)
	{
	    m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
        VDSetErrorInfo(IDS_ERR_UPDATEINPROGRESS, IID_ICursor, m_pResourceDLL);
		return CURSOR_DB_E_UPDATEINPROGRESS;
	}

    ULONG cRowsObtained = 0;
    HROW * rghRows = NULL;

	BYTE bSpecialBM;
	ULONG cbBookmark;
	BYTE * pBookmark;
	switch (m_pCursorPosition->m_bmCurrent.GetStatus())
	{
		case VDBOOKMARKSTATUS_BEGINNING:
			cbBookmark			= sizeof(BYTE);
			bSpecialBM			= DBBMK_FIRST;
			pBookmark			= &bSpecialBM;
			break;

		case VDBOOKMARKSTATUS_END:
			m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
			return CURSOR_DB_S_ENDOFCURSOR;

		case VDBOOKMARKSTATUS_CURRENT:
			cbBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
			pBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmark();
            udlRowsToSkip.LowPart++;
			break;

		default:
			m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
			ASSERT_(FALSE);
		    VDSetErrorInfo(IDS_ERR_INVALIDBMSTATUS, IID_ICursor, m_pResourceDLL);
			return E_FAIL;
	}

	hrFetch = GetRowsetLocate()->GetRowsAt(0, 0, cbBookmark, pBookmark,
										udlRowsToSkip.LowPart,
										pFetchParams->cRowsRequested,
										&cRowsObtained, &rghRows);

    hrFetch = FilterNewRow(&cRowsObtained, rghRows, hrFetch);

    if (S_OK != hrFetch)
		hrFetch = VDMapRowsetHRtoCursorHR(hrFetch, IDS_ERR_GETROWSATFAILED, IID_ICursor, GetRowsetLocate(), IID_IRowsetLocate, m_pResourceDLL);

    if FAILED(hrFetch)
	{
		if (cRowsObtained)
		{
			// release hRows and associated memory
			pRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);
			g_pMalloc->Free(rghRows);
		}
		m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
        return hrFetch;
	}

	if (cRowsObtained)
	{
		HRESULT hrMove = S_OK;

		// if got all rows requested then set current position to last row retrieved
		if (SUCCEEDED(hrFetch)	&&
			cRowsObtained == pFetchParams->cRowsRequested)
			hrMove = m_pCursorPosition->SetRowPosition(rghRows[cRowsObtained - 1]);

        // only do this if succeeded
		if (SUCCEEDED(hrMove))
		{
			// fill consumers buffer
			hrFetch = FillConsumersBuffer(hrFetch, pFetchParams, cRowsObtained, rghRows);

			// if got all rows requested then set current position to last row retrieved (internally)
			if (SUCCEEDED(hrFetch)	&&
				cRowsObtained == pFetchParams->cRowsRequested)
				m_pCursorPosition->SetCurrentHRow(rghRows[cRowsObtained - 1]);
		}

		// release hRows and associated memory
		pRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);
		g_pMalloc->Free(rghRows);

		// report failure
		if (FAILED(hrMove))
		{
			cRowsObtained = 0;
			hrFetch = E_FAIL;
		}
	}

	if (SUCCEEDED(hrFetch)	&&
		cRowsObtained < pFetchParams->cRowsRequested)
		m_pCursorPosition->SetCurrentRowStatus(VDBOOKMARKSTATUS_END);

	if SUCCEEDED(hrFetch)
	{
		rgReasons[0].arg1		= m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();
		m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
	}
	else
		m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);

    return hrFetch;
}

//=--------------------------------------------------------------------------=
// UseAdjustments - Use adjustments to fix-up returned data
//=--------------------------------------------------------------------------=
// This uses adjustments to fix-up returned data, see MakeAdjustments function
//
// Parameters:
//    hRow      - [in]   row handle
//    pData     - [in]   a pointer to data
//
// Output:
//    S_OK - if successful
//    E_INVALIDARG - bad parameter
//    E_OUTOFMEMORY - not enough memory
//
// Notes:
//
HRESULT CVDCursor::UseAdjustments(HROW hRow, BYTE * pData)
{
    ASSERT_POINTER(m_rghAdjustAccessors, HACCESSOR)
    ASSERT_POINTER(m_pdwAdjustFlags, DWORD)
    ASSERT_POINTER(pData, BYTE)

	IRowset * pRowset = GetRowset();

    // make sure we have a valid rowset pointer
    if (!pRowset || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all neccessary pointers
    if (!m_rghAdjustAccessors || !m_pdwAdjustFlags || !pData)
        return E_INVALIDARG;

    // iterate through cursor bindings, checking for adjustments
    for (ULONG ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
    {
        // check for variant binding byte field -> byte binding
        if (m_pdwAdjustFlags[ulBind] == VD_ADJUST_VARIANT_TO_BYTE)
        {
            // get variant pointer
            VARIANT * pVariant = (VARIANT*)(pData + m_pCursorBindings[ulBind].obData);

            // extract byte
            BYTE value = *(BYTE*)pVariant;

            // init byte variant
            VariantInit(pVariant);

            // fix-up returned data
            pVariant->vt = VT_UI1;
            pVariant->bVal = value;
        }

        // check for variant binding date field -> wide string binding
        if (m_pdwAdjustFlags[ulBind] == VD_ADJUST_VARIANT_TO_WSTR)
        {
            // get variant pointer
            VARIANT * pVariant = (VARIANT*)(pData + m_pCursorBindings[ulBind].obData);

            // extract length of string
            ULONG ulLength = *(ULONG*)pVariant;

            // place length field in proper place, if originally requested
            if (m_pCursorBindings[ulBind].obVarDataLen != CURSOR_DB_NOVALUE)
                *(ULONG*)(pData + m_pCursorBindings[ulBind].obVarDataLen) = ulLength;

            // init string variant
            VariantInit(pVariant);

            // create storage for string
            BSTR bstr = SysAllocStringByteLen(NULL, ulLength);

            if (!bstr)
            {
                VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
                return E_OUTOFMEMORY;
            }

            // clear wide string
            memset(bstr, 0, ulLength);

            HRESULT hr = S_OK;

            // get memo string value
            if (ulLength)
			{
                hr = pRowset->GetData(hRow, m_rghAdjustAccessors[ulBind], bstr);

				// ignore these return values
				if (hr == DB_S_ERRORSOCCURRED || hr == DB_E_ERRORSOCCURRED)
					hr = S_OK;
			}

            if (SUCCEEDED(hr))
            {
                // fix-up returned data
                pVariant->vt = VT_BSTR;
                pVariant->bstrVal = bstr;
            }
            else
                SysFreeString(bstr);
        }

        // check for variant binding memo field -> string binding
        if (m_pdwAdjustFlags[ulBind] == VD_ADJUST_VARIANT_TO_STR)
        {
            // get variant pointer
            VARIANT * pVariant = (VARIANT*)(pData + m_pCursorBindings[ulBind].obData);

            // extract length of string
            ULONG ulLength = *(ULONG*)pVariant;

            // place length field in proper place, if originally requested
            if (m_pCursorBindings[ulBind].obVarDataLen != CURSOR_DB_NOVALUE)
                *(ULONG*)(pData + m_pCursorBindings[ulBind].obVarDataLen) = ulLength;

            // init string variant
            VariantInit(pVariant);

            // create temporary string buffer
            CHAR * pszBuffer = new CHAR[ulLength + 1];

            if (!pszBuffer)
            {
                VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
                return E_OUTOFMEMORY;
            }

            // clear string buffer
            memset(pszBuffer, 0, ulLength + 1);

            HRESULT hr = S_OK;

            // get memo string value
            if (ulLength)
			{
                hr = pRowset->GetData(hRow, m_rghAdjustAccessors[ulBind], pszBuffer);

				// ignore these return values
				if (hr == DB_S_ERRORSOCCURRED || hr == DB_E_ERRORSOCCURRED)
					hr = S_OK;
			}

            if (SUCCEEDED(hr))
            {
                // fix-up returned data
                pVariant->vt = VT_BSTR;
                pVariant->bstrVal = BSTRFROMANSI(pszBuffer);
            }

            delete [] pszBuffer;
        }
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// FillConsumersBuffer
//=--------------------------------------------------------------------------=
// Fills the ICursor consumer's buffer with data from the obtained rows.
// Called from our implementations of GetNextRows, Move, Find, Scroll etc.
//
// Notes:
//    End of string characters are inserted into variable length buffer to resolve an
//    apparent difference between ICursor and IRowset.  ICursor places an empty string
//    in variable length buffer for NULL data, but this does not seem to be the behavior
//    with IRowset, because it does not touch the variable length buffer in this case.
//
//    Likewise, all variants are initialized before they are fetched to resolve another
//    apparent difference between ICursor and IRowset.  ICursor returns a NULL variant
//    in cases where the underlying data is NULL, however IRowset leaves the variant
//    untouched similar to the above.
//
HRESULT CVDCursor::FillConsumersBuffer(HRESULT hrFetch,
										 CURSOR_DBFETCHROWS *pFetchParams,
										 ULONG cRowsObtained,
										 HROW * rghRows)
{
    HRESULT hr;
    ULONG ulRow;
    ULONG ulBind;
    BYTE * pVarLength = NULL;
    BYTE * pVarHelperData = NULL;
    CURSOR_DBCOLUMNBINDING * pCursorBinding;
    BOOL fEntryIDBinding;

    IRowset * pRowset = GetRowset();

    // if caller requested callee allocated memory, then compute sizes and allocate memory
    if (pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES)
    {
        // allocate inline memory
        pFetchParams->pData = g_pMalloc->Alloc(cRowsObtained * m_cbRowLength);

        if (!pFetchParams->pData)
        {
			VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
            return E_OUTOFMEMORY;
        }

        // if needed, allocate out-of-line memory
        if (m_ulVarBindings)
        {
            // create variable length data table
            ULONG cbVarHelperData = cRowsObtained * m_ulVarBindings * (sizeof(ULONG) + sizeof(DBSTATUS));

            pVarHelperData = new BYTE[cbVarHelperData];

            if (!pVarHelperData)
            {
                g_pMalloc->Free(pFetchParams->pData);
                pFetchParams->pData = NULL;
			    VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
                return E_OUTOFMEMORY;
            }

            // clear table
            memset(pVarHelperData, 0, cbVarHelperData);

            ULONG cbVarData = 0;
            pVarLength = pVarHelperData;

            // determine necessary size of variable length buffer
            for (ulRow = 0; ulRow < cRowsObtained; ulRow++)
            {
                hr = S_OK;

                // if necessary, get variable length and status information
                if (m_hVarHelper)
                {
                    hr = pRowset->GetData(rghRows[ulRow], m_hVarHelper, pVarLength);

					// ignore these errors
					if (hr == DB_S_ERRORSOCCURRED || hr == DB_E_ERRORSOCCURRED)
						hr = S_OK;

        	        hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursor, pRowset, IID_IRowset,
                        m_pResourceDLL);
                }

                if (FAILED(hr))
                {
                    g_pMalloc->Free(pFetchParams->pData);
                    pFetchParams->pData = NULL;
                    delete [] pVarHelperData;
                    return hr;
                }

                pCursorBinding = m_pCursorBindings;

                // calculate sizes of data returned in out-of-line memory
                for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
                {
                    // set entryID binding flag
                    fEntryIDBinding = (pCursorBinding->dwBinding & CURSOR_DBBINDING_ENTRYID);

                    if (m_rghVarAccessors[ulBind] || fEntryIDBinding && pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB)
                    {
                        // insert length entries for fixed datatypes
                        if (m_ppColumns[ulBind]->GetFixed())
                        {
                            *(ULONG*)pVarLength = m_ppColumns[ulBind]->GetMaxStrLen();
                            *(DBSTATUS*)(pVarLength + sizeof(ULONG)) = DBSTATUS_S_OK;
                        }

                        // insert length entries for entryID bindings
                        if (fEntryIDBinding)
                        {
                            *(ULONG*)pVarLength =  sizeof(ULONG) + sizeof(ULONG) + GetCursorMain()->GetMaxBookmarkLen();
                            *(DBSTATUS*)(pVarLength + sizeof(ULONG)) = DBSTATUS_S_OK;
                        }

                        // allow for null-terminator
                        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPSTR ||
                            pCursorBinding->dwDataType == CURSOR_DBTYPE_LPWSTR)
                           *((ULONG*)pVarLength) += 1;

                        // allow for wide characters
                        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPWSTR)
                           *((ULONG*)pVarLength) *= sizeof(WCHAR);

                        cbVarData += *(ULONG*)pVarLength;
                        pVarLength += sizeof(ULONG) + sizeof(DBSTATUS);
                    }

                    pCursorBinding++;
                }
            }

            // now, allocate out-of-line memory
            pFetchParams->pVarData = g_pMalloc->Alloc(cbVarData);

            if (!pFetchParams->pData)
            {
                g_pMalloc->Free(pFetchParams->pData);
                pFetchParams->pData = NULL;
                delete [] pVarHelperData;
			    VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
                return E_OUTOFMEMORY;
            }
        }
        else
            pFetchParams->pVarData = NULL;
    }

    // fetch data
    CURSOR_BLOB cursorBlob;
    BYTE * pData = (BYTE*)pFetchParams->pData;
    BYTE * pVarData = (BYTE*)pFetchParams->pVarData;
    pVarLength = pVarHelperData;

    // iterate through the returned hRows
    for (ulRow = 0; ulRow < cRowsObtained; ulRow++)
    {
        hr = S_OK;

        pCursorBinding = m_pCursorBindings;

        // iterate through bindings and initialize variants
        for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            if (pCursorBinding->dwBinding & CURSOR_DBBINDING_VARIANT)
            {
                if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
				    VariantInit((VARIANT*)(pData + pCursorBinding->obData));
            }

            pCursorBinding++;
        }

        // if necessary get fixed length data
        if (m_hAccessor)
        {
            hr = pRowset->GetData(rghRows[ulRow], m_hAccessor, pData);

			// ignore these return values
			if (hr == DB_S_ERRORSOCCURRED || hr == DB_E_ERRORSOCCURRED)
				hr = S_OK;

            // check to see if need to use adjustments
            if (m_rghAdjustAccessors && SUCCEEDED(hr))
                hr = UseAdjustments(rghRows[ulRow], pData);

	        hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursor, pRowset, IID_IRowset, m_pResourceDLL);
        }

        if (FAILED(hr))
        {
            hrFetch = hr;
            pFetchParams->cRowsReturned = 0;
            goto DoneFetchingData;
        }

        pCursorBinding = m_pCursorBindings;

        // if necessary get fixed length entryIDs
        for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            // set entryID binding flag
            fEntryIDBinding = (pCursorBinding->dwBinding & CURSOR_DBBINDING_ENTRYID);

            if (fEntryIDBinding && pCursorBinding->dwDataType == CURSOR_DBTYPE_BYTES)
            {
                // return entryID length
				*(ULONG*)(pData + pCursorBinding->obData) =
                    sizeof(ULONG) + sizeof(ULONG) + GetCursorMain()->GetMaxBookmarkLen();

				// return column ordinal
                *(ULONG*)(pData + pCursorBinding->obData + sizeof(ULONG)) = m_ppColumns[ulBind]->GetOrdinal();

                // return row bookmark
                hr = pRowset->GetData(rghRows[ulRow], GetCursorMain()->GetBookmarkAccessor(),
                    pData + pCursorBinding->obData + sizeof(ULONG) + sizeof(ULONG));

	            hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursor, pRowset, IID_IRowset,
                    m_pResourceDLL);

                if (FAILED(hr))
                {
                    hrFetch = hr;
                    pFetchParams->cRowsReturned = 0;
                    goto DoneFetchingData;
                }
            }

            pCursorBinding++;
        }

        pCursorBinding = m_pCursorBindings;

        // if necessary get variable length data
        if (m_rghVarAccessors)
        {
            for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
            {
                // set entryID binding flag
                fEntryIDBinding = (pCursorBinding->dwBinding & CURSOR_DBBINDING_ENTRYID);

                if (m_rghVarAccessors[ulBind] || fEntryIDBinding && pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB)
                {
  		    // place end of string characters in variable length buffer
                    if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPSTR)
                    {
                        pVarData[0] = 0;
                    }
                    else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPWSTR)
                    {
                        pVarData[0] = 0;
                        pVarData[1] = 0;
                    }

                    // get data if we have accessor
                    if (m_rghVarAccessors[ulBind])
                    {
                        // get variable length data
                        hr = pRowset->GetData(rghRows[ulRow], m_rghVarAccessors[ulBind], pVarData);

						// ignore these return values
						if (hr == DB_S_ERRORSOCCURRED || hr == DB_E_ERRORSOCCURRED)
							hr = S_OK;

	                    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursor, pRowset, IID_IRowset,
                            m_pResourceDLL);
                    }
                    else // otherwise, get variable length entryIDs
                    {
                        // return entryID length
				        *(ULONG*)(pData + pCursorBinding->obData) =
                            sizeof(ULONG) + sizeof(ULONG) + GetCursorMain()->GetMaxBookmarkLen();

				        // return column ordinal
                        *(ULONG*)(pVarData) = m_ppColumns[ulBind]->GetOrdinal();

                        // return row bookmark
                        hr = pRowset->GetData(rghRows[ulRow], GetCursorMain()->GetBookmarkAccessor(),
                            pVarData + sizeof(ULONG));

	                    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursor, pRowset, IID_IRowset,
                            m_pResourceDLL);
                    }

                    if (FAILED(hr))
                    {
                        hrFetch = hr;
                        pFetchParams->cRowsReturned = 0;
                        goto DoneFetchingData;
                    }

                    // make adjustments in fixed length buffer for default bindings
                    if (!(pCursorBinding->dwBinding & CURSOR_DBBINDING_VARIANT))
                    {
                        switch (pCursorBinding->dwDataType)
					    {
						    case CURSOR_DBTYPE_BLOB:
							    *(LPBYTE*)(pData + pCursorBinding->obData + sizeof(ULONG)) = (LPBYTE)pVarData;
							    break;

						    case CURSOR_DBTYPE_LPSTR:
							    *(LPSTR*)(pData + pCursorBinding->obData) = (LPSTR)pVarData;
							    break;

						    case CURSOR_DBTYPE_LPWSTR:
							    *(LPWSTR*)(pData + pCursorBinding->obData) = (LPWSTR)pVarData;
							    break;
					    }
                    }
                    else    // make adjustments in fixed length buffer for variant bindings
                    {
                        CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

                        switch (pCursorBinding->dwDataType)
					    {
						    case CURSOR_DBTYPE_BLOB:
							    cursorBlob.cbSize       = *(ULONG*)pVariant;
							    cursorBlob.pBlobData    = (LPBYTE)pVarData;
							    VariantInit((VARIANT*)pVariant);
							    pVariant->vt            = CURSOR_DBTYPE_BLOB;
							    pVariant->blob          = cursorBlob;
							    break;

						    case CURSOR_DBTYPE_LPSTR:
							    VariantInit((VARIANT*)pVariant);
							    pVariant->vt        = CURSOR_DBTYPE_LPSTR;
							    pVariant->pszVal    = (LPSTR)pVarData;
							    break;

						    case CURSOR_DBTYPE_LPWSTR:
							    VariantInit((VARIANT*)pVariant);
							    pVariant->vt        = CURSOR_DBTYPE_LPSTR;
							    pVariant->pwszVal   = (LPWSTR)pVarData;
							    break;
					    }
                    }

                    if (pVarLength)
                    {
                        pVarData += *(ULONG*)pVarLength;
                        pVarLength += sizeof(ULONG) + sizeof(DBSTATUS);
                    }
                    else
						{
						if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB)
							pVarData += *(ULONG *) (pData + pCursorBinding->obData);
						else
							pVarData += pCursorBinding->cbMaxLen;
						}
                }
			    else
			    {
				    if (pCursorBinding->dwDataType == CURSOR_DBTYPE_FILETIME)
				    {
					    VDConvertToFileTime((DBTIMESTAMP*)(pData + pCursorBinding->obData),
										    (FILETIME*)(pData + pCursorBinding->obData));
				    }
			    }

                pCursorBinding++;
            }
        }

        pCursorBinding = m_pCursorBindings;

        // make adjustments for status fields
        for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
            {
                *(DWORD*)(pData + pCursorBinding->obInfo) =
                    StatusToCursorInfo(*(DBSTATUS*)(pData + pCursorBinding->obInfo));
            }

            pCursorBinding++;
        }

        // increment returned row count
        pFetchParams->cRowsReturned++;
        pData += m_cbRowLength;
    }

DoneFetchingData:
    delete [] pVarHelperData;

    // cleanup memory allocations if we did not retrieve any rows
    if (pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES && !pFetchParams->cRowsReturned)
    {
        if (pFetchParams->pData)
        {
            g_pMalloc->Free(pFetchParams->pData);
            pFetchParams->pData = NULL;
        }

        if (pFetchParams->pVarData)
        {
            g_pMalloc->Free(pFetchParams->pVarData);
            pFetchParams->pVarData = NULL;
        }
    }

    return hrFetch;
}

//=--------------------------------------------------------------------------=
// ICursor Requery
//=--------------------------------------------------------------------------=
// Repopulates the cursor based on its original definition
//
// Parameters:
//              none
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDCursor::Requery(void)
{

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    IRowset * pRowset = GetRowset();
	IRowsetResynch * pRowsetResynch = NULL;

	HRESULT hr = pRowset->QueryInterface(IID_IRowsetResynch, (void**)&pRowsetResynch);

	if (SUCCEEDED(hr))
	{
		hr = pRowsetResynch->ResynchRows(0, NULL, NULL, NULL, NULL);
		pRowsetResynch->Release();
		if (FAILED(hr))
			return VDMapRowsetHRtoCursorHR(hr, IDS_ERR_RESYNCHFAILED, IID_ICursor, pRowset, IID_IRowsetResynch, m_pResourceDLL);
	}

    hr = pRowset->RestartPosition(0);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_RESTARTPOSFAILED, IID_ICursor, pRowset, IID_IRowset, m_pResourceDLL);

	m_pCursorPosition->PositionToFirstRow();

    return hr;
}

//=--------------------------------------------------------------------------=
// FetchAtBookmark
//=--------------------------------------------------------------------------=
// Called from ICursorMove::Move, ICursorScroll::Scroll and	ICursorFind::Find
//
// Parameters:
//	cbBookmark		[in]	The length of the bookmark
//	pBookmark		[in]	A pointer to the bookmarks data
//	dlOffset		[in]	Offset from the bookmark position
//	pFetchParams	[in]	A pointer to the CURSOR_DBFETCHROWS structure (optional)
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
//
HRESULT CVDCursor::FetchAtBookmark(ULONG cbBookmark,
									  void *pBookmark,
									  LARGE_INTEGER dlOffset,
									  CURSOR_DBFETCHROWS *pFetchParams)
{

	HRESULT hr = S_OK;

    // vaildate fetch params (implemented on CVDCursorBase
    if (pFetchParams)
		hr = ValidateFetchParams(pFetchParams, IID_ICursorMove);

    // return if fetch params are invalid
	if (FAILED(hr))
		return hr;

    IRowset * pRowset = GetRowset();

	// make sure that an update is not already in progress
    if (m_pCursorPosition->GetEditMode() != CURSOR_DBEDITMODE_NONE)
	{
        VDSetErrorInfo(IDS_ERR_UPDATEINPROGRESS, IID_ICursor, m_pResourceDLL);
		return CURSOR_DB_E_UPDATEINPROGRESS;
	}

    ULONG cRowsObtained = 0;
    HROW * rghRows = NULL;

    HRESULT hrFetch = S_OK;
	BYTE bSpecialBM;
    BOOL fFetchData = TRUE;
    WORD wSpecialBMStatus = 0;

	if (CURSOR_DB_BMK_SIZE == cbBookmark)
	{
		if (memcmp(&CURSOR_DBBMK_BEGINNING, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
            if ((long)dlOffset.LowPart < 0)
            {
        		m_pCursorPosition->SetCurrentRowStatus(VDBOOKMARKSTATUS_BEGINNING);
                return CURSOR_DB_S_ENDOFCURSOR;
            }

			bSpecialBM	= DBBMK_FIRST;
			pBookmark	= &bSpecialBM;

            // make sure we properly handle situation when caller move before the first,
            // and does not fetch any rows
            if ((!pFetchParams || !pFetchParams->cRowsRequested) && (long)dlOffset.LowPart < 1)
            {
                fFetchData  = FALSE;
                wSpecialBMStatus = VDBOOKMARKSTATUS_BEGINNING;
            }
            else
                dlOffset.LowPart--;
		}
		else
		if (memcmp(&CURSOR_DBBMK_END, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
            if ((long)dlOffset.LowPart > 0)
            {
        		m_pCursorPosition->SetCurrentRowStatus(VDBOOKMARKSTATUS_END);
                return CURSOR_DB_S_ENDOFCURSOR;
            }

			bSpecialBM	= DBBMK_LAST;
			pBookmark	= &bSpecialBM;

            // make sure we properly handle situation when caller move after the last
            if ((!pFetchParams || !pFetchParams->cRowsRequested) && (long)dlOffset.LowPart > -1)
            {
                fFetchData  = FALSE;
                wSpecialBMStatus = VDBOOKMARKSTATUS_END;
            }
            else
                dlOffset.LowPart++;
		}
		else
		if (memcmp(&CURSOR_DBBMK_CURRENT, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			switch (m_pCursorPosition->m_bmCurrent.GetStatus())
			{
				case VDBOOKMARKSTATUS_BEGINNING:
					cbBookmark  = sizeof(BYTE);
        			bSpecialBM	= DBBMK_FIRST;
		        	pBookmark	= &bSpecialBM;
                    dlOffset.LowPart--;
                    break;

				case VDBOOKMARKSTATUS_END:
					cbBookmark  = sizeof(BYTE);
        			bSpecialBM	= DBBMK_LAST;
		        	pBookmark	= &bSpecialBM;
                    dlOffset.LowPart++;
                    break;

				case VDBOOKMARKSTATUS_CURRENT:
					cbBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
					pBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmark();
					break;

				default:
					ASSERT_(FALSE);
					VDSetErrorInfo(IDS_ERR_INVALIDBMSTATUS, IID_ICursor, m_pResourceDLL);
					return E_FAIL;
			}
		}
	}
	
	ULONG cRowsToFetch = 1;

    // if caller requested rows, fetch that count
    if (pFetchParams && pFetchParams->cRowsRequested > 0)
        cRowsToFetch = pFetchParams->cRowsRequested;

    if (fFetchData)
    {
        // fetch hRows
	    hrFetch = GetRowsetLocate()->GetRowsAt(0, 0, cbBookmark, (const BYTE *)pBookmark,
										    dlOffset.LowPart,
										    cRowsToFetch,
										    &cRowsObtained, &rghRows);

		if (hrFetch == E_UNEXPECTED)
		{
			// set rowset released flag, since original rowset is zombie'd
			m_pCursorPosition->GetRowsetSource()->SetRowsetReleasedFlag();
		}

        hrFetch = FilterNewRow(&cRowsObtained, rghRows, hrFetch);
        // check for before the first or after the last
        if (hrFetch == DB_E_BADSTARTPOSITION)
        {
            if ((long)dlOffset.LowPart < 0)
                wSpecialBMStatus = VDBOOKMARKSTATUS_BEGINNING;
            else
                wSpecialBMStatus = VDBOOKMARKSTATUS_END;

            hrFetch = DB_S_ENDOFROWSET;
            fFetchData  = FALSE;
        }
    }

	hrFetch = VDMapRowsetHRtoCursorHR(hrFetch, IDS_ERR_GETROWSATFAILED, IID_ICursorMove, GetRowsetLocate(),
        IID_IRowsetLocate, m_pResourceDLL);

    if (FAILED(hrFetch))
	{
		if (cRowsObtained)
		{
			// release hRows and associated memory
			pRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);
			g_pMalloc->Free(rghRows);
		}
        return hrFetch;
	}

	if (cRowsObtained)
	{
		HRESULT hrMove = S_OK;

		// if got all rows requested then set current position to last row retrieved
		if (SUCCEEDED(hrFetch)	&&
			cRowsObtained == cRowsToFetch)
			hrMove = m_pCursorPosition->SetRowPosition(rghRows[cRowsObtained - 1]);

        // only do this if succeeded
        if (SUCCEEDED(hrMove))
		{
			// fill consumers buffer
			if (pFetchParams && pFetchParams->cRowsRequested > 0)
				hrFetch = FillConsumersBuffer(hrFetch, pFetchParams, cRowsObtained, rghRows);

			// if got all rows requested then set current position to last row retrieved (internally)
			if (SUCCEEDED(hrFetch)	&&
				cRowsObtained == cRowsToFetch)
				m_pCursorPosition->SetCurrentHRow(rghRows[cRowsObtained - 1]);
		}

		// release hRows and associated memory
		pRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);
		g_pMalloc->Free(rghRows);

		// report failure
		if (FAILED(hrMove))
		{
			cRowsObtained = 0;
			hrFetch = E_FAIL;
		}
	}
    else if (wSpecialBMStatus)
    {
		m_pCursorPosition->SetCurrentRowStatus(wSpecialBMStatus);
        hrFetch = CURSOR_DB_S_ENDOFCURSOR;
    }

	if (SUCCEEDED(hrFetch)	&&
		cRowsObtained < cRowsToFetch &&
        !wSpecialBMStatus)
		m_pCursorPosition->SetCurrentRowStatus(VDBOOKMARKSTATUS_END);

    return hrFetch;
}

//=--------------------------------------------------------------------------=
// ICursorMove methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursorMove Move
//=--------------------------------------------------------------------------=
// Moves the current row to a new row within the cursor and optionally fetches
// rows from that new position
//
// Parameters:
//    cbBookmark    - [in]      length in bytes of the bookmark
//    pBookmark     - [in]      a pointer to a bookmark which serves as the
//                              origin for the calculation that determines the
//                              target row
//    dlOffset      - [in]      a signed count of the rows from the origin
//                              bookmark to the target row
//    pFetchParams  - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDCursor::Move(ULONG cbBookmark, void *pBookmark, LARGE_INTEGER dlOffset, CURSOR_DBFETCHROWS *pFetchParams)
{
    ASSERT_POINTER(pBookmark, BYTE)
    ASSERT_NULL_OR_POINTER(pFetchParams, CURSOR_DBFETCHROWS)

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorMove, m_pResourceDLL);
        return E_FAIL;
    }

	if (!cbBookmark || !pBookmark)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorMove, m_pResourceDLL);
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    BOOL fNotifyOthers = TRUE;

    // get current bookmark
    ULONG cbCurrent = m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
    BYTE * pCurrent = m_pCursorPosition->m_bmCurrent.GetBookmark();

    // check to see if caller is moving to the current row using the standard bookmark
    if (CURSOR_DB_BMK_SIZE == cbBookmark && memcmp(&CURSOR_DBBMK_CURRENT, pBookmark, CURSOR_DB_BMK_SIZE) == 0 &&
        dlOffset.HighPart == 0 && dlOffset.LowPart == 0)
    {
        // if caller is not fetching any rows, then get out
        if (!pFetchParams || pFetchParams->cRowsRequested == 0)
            return S_OK;

        // if caller is only fetching one row, then don't generate notifications
        if (pFetchParams && pFetchParams->cRowsRequested == 1)
            fNotifyOthers = FALSE;
    }

	CURSOR_DBNOTIFYREASON rgReasons[1];
	
	rgReasons[0].dwReason	= CURSOR_DBREASON_MOVE;
	rgReasons[0].arg1		= m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();

	VariantInit((VARIANT*)&rgReasons[0].arg2);

    // notify other interested parties
	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_CHANGED;

	if (fNotifyOthers)
        hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

    // make sure action was not cancelled
    if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorMove, m_pResourceDLL);
        return E_FAIL;
    }

	hr = FetchAtBookmark(cbBookmark, pBookmark, dlOffset, pFetchParams);

	if (SUCCEEDED(hr))
	{
		rgReasons[0].arg1	= m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();
		
    	if (fNotifyOthers)
            m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
	}
	else
    {
    	if (fNotifyOthers)
	    	m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
    }

	return hr;
}

//=--------------------------------------------------------------------------=
// ICursorMove GetBookmark
//=--------------------------------------------------------------------------=
// Returns the bookmark of the current row
//
// Parameters:
//    pBookmarkType - [in]  a pointer to the type of bookmark desired
//    cbMaxSize     - [in]  length in bytes of the client buffer to put the
//                          returned bookmark into
//    pcbBookmark   - [out] a pointer to memory in which to return the actual
//                          length of the returned bookmark
//    pBookmark     - [out] a pointer to client buffer to put the returned
//                          bookmark into
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDCursor::GetBookmark(CURSOR_DBCOLUMNID *pBookmarkType,
							   ULONG cbMaxSize,
							   ULONG *pcbBookmark,
							   void *pBookmark)
{

	ASSERT_POINTER(pBookmarkType, CURSOR_DBCOLUMNID);
	ASSERT_POINTER(pcbBookmark, ULONG);
	ASSERT_POINTER(pBookmark, BYTE);
	ASSERT_(cbMaxSize > 0)

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorMove, m_pResourceDLL);
        return E_FAIL;
    }

	if (!pcbBookmark || !pBookmark)
	{
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorMove, m_pResourceDLL);
		return E_INVALIDARG;
	}

	// verify bookmark type
	if (memcmp(&CURSOR_COLUMN_BMKTEMPORARY,	pBookmarkType, sizeof(CURSOR_DBCOLUMNID)) != 0 &&
		memcmp(&CURSOR_COLUMN_BMKTEMPORARYREL, pBookmarkType, sizeof(CURSOR_DBCOLUMNID)) != 0)
	{
        VDSetErrorInfo(IDS_ERR_BADCOLUMNID, IID_ICursorMove, m_pResourceDLL);
		return DB_E_BADCOLUMNID;
	}

	HRESULT hr = S_OK;

	if (0 == cbMaxSize)
	{
        VDSetErrorInfo(IDS_ERR_BUFFERTOOSMALL, IID_ICursorMove, m_pResourceDLL);
		hr = CURSOR_DB_E_BUFFERTOOSMALL;
	}
	else
	{
		switch (m_pCursorPosition->m_bmCurrent.GetStatus())
		{
			case VDBOOKMARKSTATUS_BEGINNING:
			case VDBOOKMARKSTATUS_END:
			case VDBOOKMARKSTATUS_CURRENT:
				if (m_pCursorPosition->m_bmCurrent.GetBookmarkLen() > cbMaxSize)
				{
			        VDSetErrorInfo(IDS_ERR_BUFFERTOOSMALL, IID_ICursorMove, m_pResourceDLL);
					hr = CURSOR_DB_E_BUFFERTOOSMALL;
					break;
				}
				*pcbBookmark		= m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
				memcpy(pBookmark, m_pCursorPosition->m_bmCurrent.GetBookmark(), *pcbBookmark);
				break;

			case VDBOOKMARKSTATUS_INVALID:
				*pcbBookmark		= CURSOR_DB_BMK_SIZE;
				*(BYTE*)pBookmark	= CURSOR_DBBMK_INVALID;
				break;

			default:
				ASSERT_(FALSE);
		        VDSetErrorInfo(IDS_ERR_INVALIDBMSTATUS, IID_ICursorMove, m_pResourceDLL);
				hr =  E_FAIL;
				break;
		}
	}

	return hr;
}

//=--------------------------------------------------------------------------=
// ICursorMove Clone
//=--------------------------------------------------------------------------=
// Returns a clone of the cursor
//
// Parameters:
//    dwFlags           - [in]  a flag that specifies the clone options
//    riid              - [in]  the interface desired for the returned clone
//    ppvClonedCursor   - [out] a pointer to memory in which to return newly
//                              created clone pointer
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDCursor::Clone(DWORD dwFlags, REFIID riid, IUnknown **ppvClonedCursor)
{

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorMove, m_pResourceDLL);
        return E_FAIL;
    }

	CVDCursorPosition * pCursorPosition;

	HRESULT hr;

	if (CURSOR_DBCLONEOPTS_SAMEROW == dwFlags)
	{
		pCursorPosition = m_pCursorPosition;
	}
	else
	{
		// create new cursor position object
		hr = CVDCursorPosition::Create(NULL,
									   m_pCursorPosition->GetCursorMain(),
									   &pCursorPosition,
									   m_pResourceDLL);
		if (FAILED(hr))
			return hr;
	}

    CVDCursor * pCursor = 0;

    hr = CVDCursor::Create(pCursorPosition, &pCursor, m_pResourceDLL);

	if (CURSOR_DBCLONEOPTS_SAMEROW != dwFlags)
    {
        // release our reference
        pCursorPosition->Release();
    }

    *ppvClonedCursor = (ICursorScroll*)pCursor;

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorScroll methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursorScroll Scroll
//=--------------------------------------------------------------------------=
// Moves the current row to a new row within the cursor, specified as a
// fraction, and optionally fetches rows from that new position
//
// Parameters:
//    ulNumerator   - [in]      the numerator of the fraction that states the
//                              position to scroll to in the cursor
//    ulDenominator - [in]      the denominator of that same fraction
//    pFetchParams  - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              CURSOR_DB_E_BADFRACTION - bad fraction
//
// Notes:
//
HRESULT CVDCursor::Scroll(ULONG ulNumerator, ULONG ulDenominator, CURSOR_DBFETCHROWS *pFetchParams)
{

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorScroll, m_pResourceDLL);
        return E_FAIL;
    }

	IRowsetScroll * pRowsetScroll = GetRowsetScroll();

	if (!pRowsetScroll)
		return E_NOTIMPL;

	CURSOR_DBNOTIFYREASON rgReasons[1];

	rgReasons[0].dwReason	= CURSOR_DBREASON_MOVEPERCENT;
	
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	rgReasons[0].arg1.vt		= VT_UI4;
	rgReasons[0].arg1.lVal		= ulNumerator;

	VariantInit((VARIANT*)&rgReasons[0].arg2);
	rgReasons[0].arg2.vt		= VT_UI4;
	rgReasons[0].arg2.lVal		= ulDenominator;

    // notify other interested parties
	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_CHANGED;

	HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

    // make sure action was not cancelled
    if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorScroll, m_pResourceDLL);
        return E_FAIL;
    }

	if (0 == ulNumerator) // go to first row
	{
		LARGE_INTEGER dlOffset;
		dlOffset.HighPart	= 0;
		dlOffset.LowPart	= 1;
		hr = FetchAtBookmark(CURSOR_DB_BMK_SIZE, (void*)&CURSOR_DBBMK_BEGINNING, dlOffset, pFetchParams);
	}
	else
	if (ulDenominator == ulNumerator) // go to last row
	{
		LARGE_INTEGER dlOffset;
		dlOffset.HighPart	= -1;
		dlOffset.LowPart	= 0xFFFFFFFF;
		hr = FetchAtBookmark(CURSOR_DB_BMK_SIZE, (void*)&CURSOR_DBBMK_END, dlOffset, pFetchParams);
	}
	else
	{
		HROW * pRow = NULL;
		ULONG cRowsObtained = 0;

		hr = pRowsetScroll->GetRowsAtRatio(0, 0,
											ulNumerator,
											ulDenominator,
											1,
											&cRowsObtained,
											&pRow);

		if FAILED(hr)
			hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_SCROLLFAILED, IID_ICursorScroll, pRowsetScroll, IID_IRowsetScroll, m_pResourceDLL);

		if (SUCCEEDED(hr) && cRowsObtained)
		{

			// allocate buffer for bookmark plus length indicator
			BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];
	
			if (!pBuff)
				hr = E_OUTOFMEMORY;
			else
			{
			// get the bookmark data
				hr = GetRowset()->GetData(*pRow, GetCursorMain()->GetBookmarkAccessor(), pBuff);
				if SUCCEEDED(hr)
				{
					ULONG * pulLen = (ULONG*)pBuff;
					BYTE * pbmdata = pBuff + sizeof(ULONG);
					LARGE_INTEGER dlOffset;
					dlOffset.HighPart	= 0;
					dlOffset.LowPart	= 0;
					hr = FetchAtBookmark(*pulLen, pbmdata, dlOffset, pFetchParams);
				}
				else
				{
					hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursorScroll, pRowsetScroll, IID_IRowset, m_pResourceDLL);
				}

				delete [] pBuff;
			}

		}
		
		if (pRow)
		{
			if (cRowsObtained)
				GetRowset()->ReleaseRows(1, pRow, NULL, NULL, NULL);
			g_pMalloc->Free(pRow);
		}
	}

	if SUCCEEDED(hr)
	{
		rgReasons[0].arg1	= m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();
		VariantClear((VARIANT*)&rgReasons[0].arg2);
		m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
	}
	else
		m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorScroll GetApproximatePosition
//=--------------------------------------------------------------------------=
// Returns the approximate location of a bookmark within the cursor, specified
// as a fraction
//
// Parameters:
//    cbBookmark        - [in]  length in bytes of the bookmark
//    pBookmark         - [in]  a pointer to the bookmark
//    pulNumerator      - [out] a pointer to memory in which to return the
//                              numerator of the faction that defines the
//                              approximate position of the bookmark
//    pulDenominator    - [out] a pointer to memory in which to return the
//                              denominator of that same faction
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDCursor::GetApproximatePosition(ULONG cbBookmark, void *pBookmark, ULONG *pulNumerator, ULONG *pulDenominator)
{

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorScroll, m_pResourceDLL);
        return E_FAIL;
    }

	ASSERT_(cbBookmark);
	ASSERT_POINTER(pBookmark, BYTE);
	ASSERT_POINTER(pulNumerator, ULONG);
	ASSERT_POINTER(pulDenominator, ULONG);

	if (!cbBookmark || !pBookmark || !pulNumerator || !pulDenominator)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorScroll, m_pResourceDLL);
        return E_INVALIDARG;
    }

	if (CURSOR_DB_BMK_SIZE == cbBookmark)
	{
		if (memcmp(&CURSOR_DBBMK_BEGINNING, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			*pulNumerator		= 0;
			*pulDenominator		= 1;
			return S_OK;
		}
		if (memcmp(&CURSOR_DBBMK_END, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			*pulNumerator		= 1;
			*pulDenominator		= 1;
			return S_OK;
		}
		if (memcmp(&CURSOR_DBBMK_CURRENT, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			cbBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
			pBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmark();
		}
	}

	IRowsetScroll * pRowsetScroll = GetRowsetScroll();

	if (!pRowsetScroll)
		return E_NOTIMPL;

	HRESULT hr = pRowsetScroll->GetApproximatePosition(0,
														cbBookmark,
														(const BYTE *)pBookmark,
														pulNumerator,
														pulDenominator);

	if SUCCEEDED(hr)
	{
		// since ICursor returns a zero based approximate position and IRowset is 1 based
		// we need to adjust the return value
		if (0 < *pulNumerator)
			(*pulNumerator)--;
	}
	else
		hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETAPPROXPOSFAILED, IID_ICursorScroll, pRowsetScroll, IID_IRowsetScroll, m_pResourceDLL);

    return hr;

}

//=--------------------------------------------------------------------------=
// ICursorScroll GetApproximateCount
//=--------------------------------------------------------------------------=
// Returns the approximate number of rows in the cursor
//
// Parameters:
//    pudlApproxCount       - [out] a pointer to a buffer containing the
//                                  returned approximate count of the rows
//                                  in the cursor
//    pdwFullyPopuldated    - [out] a pointer to a buffer containing returned
//                                  flags indicating whether the cursor is fully
//                                  populated
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDCursor::GetApproximateCount(LARGE_INTEGER *pudlApproxCount, DWORD *pdwFullyPopulated)
{

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorScroll, m_pResourceDLL);
        return E_FAIL;
    }

	ASSERT_POINTER(pudlApproxCount, LARGE_INTEGER);
	ASSERT_NULL_OR_POINTER(pdwFullyPopulated, DWORD);

	if (!pudlApproxCount)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorScroll, m_pResourceDLL);
        return E_INVALIDARG;
    }

	IRowsetScroll * pRowsetScroll = GetRowsetScroll();

	if (!pRowsetScroll)
		return E_NOTIMPL;

	HRESULT hr;

	if (pdwFullyPopulated)
	{
		*pdwFullyPopulated = CURSOR_DBCURSORPOPULATED_FULLY;

		IDBAsynchStatus * pDBAsynchStatus = NULL;
		hr = pRowsetScroll->QueryInterface(IID_IDBAsynchStatus, (void**)&pDBAsynchStatus);
		if (SUCCEEDED(hr) && pDBAsynchStatus)
		{
			ULONG ulProgress;
			ULONG ulProgressMax;
			ULONG ulStatusCode;
			hr = pDBAsynchStatus->GetStatus(DB_NULL_HCHAPTER, DBASYNCHOP_OPEN, &ulProgress, &ulProgressMax, &ulStatusCode, NULL);
			if (SUCCEEDED(hr))
			{
				if (ulProgress < ulProgressMax)
					*pdwFullyPopulated = CURSOR_DBCURSORPOPULATED_PARTIALLY;
			}
			pDBAsynchStatus->Release();
		}
	}

    pudlApproxCount->HighPart = 0;

	hr = pRowsetScroll->GetApproximatePosition(0, 0, NULL, NULL, &pudlApproxCount->LowPart);

	if FAILED(hr)
		hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETAPPROXPOSFAILED, IID_ICursorScroll, pRowsetScroll, IID_IRowsetScroll, m_pResourceDLL);
	else
		pudlApproxCount->LowPart -= m_pCursorPosition->GetCursorMain()->AddedRows();

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow methods
//=--------------------------------------------------------------------------=
// ICursorUpdateARow BeginUpdate
//=--------------------------------------------------------------------------=
// Begins an operation that updates the current or adds a new row
//
// Parameters:
//	dwFlags         - [in] specifies the operation to begin
//
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL a provider-specific error occured
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              CURSOR_DB_E_UPDATEINPROGRESS an update is already in progress
//
// Notes:
//
HRESULT CVDCursor::BeginUpdate(DWORD dwFlags)
{
	IRowset * pRowset = GetRowset();
    IAccessor * pAccessor = GetAccessor();
	IRowsetChange * pRowsetChange = GetRowsetChange();

    // make sure we have valid rowset, accessor and change pointers
    if (!pRowset || !pAccessor || !pRowsetChange || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // check dwFlags for acceptable values
    if (dwFlags != CURSOR_DBROWACTION_UPDATE && dwFlags != CURSOR_DBROWACTION_ADD)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // make sure that an update is not already in progress
    if (m_pCursorPosition->GetEditMode() != CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_UPDATEINPROGRESS, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_UPDATEINPROGRESS;
    }

    // setup notification structures
   	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
                        CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;

	CURSOR_DBNOTIFYREASON rgReasons[1];
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	VariantInit((VARIANT*)&rgReasons[0].arg2);

    switch (dwFlags)
    {
        case CURSOR_DBROWACTION_UPDATE:
    	    rgReasons[0].dwReason = CURSOR_DBREASON_EDIT;
            break;

        case CURSOR_DBROWACTION_ADD:
    	    rgReasons[0].dwReason = CURSOR_DBREASON_ADDNEW;
            break;
    }

    // notify other interested parties of action
    HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

	// make sure action was not cancelled
	if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorUpdateARow, m_pResourceDLL);
		return E_FAIL;
    }

    // insert new hRow if we're going into add mode
    if (dwFlags == CURSOR_DBROWACTION_ADD)
    {
        hr = InsertNewRow();

        if (FAILED(hr))
        {
            // notify other interested parties of failure
            m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
            return hr;
        }
    }

    // reset column updates
    hr = m_pCursorPosition->ResetColumnUpdates();

    if (FAILED(hr))
    {
        // notify other interested parties of failure
        m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
        return hr;
    }

    // place cursor in correct mode
    switch (dwFlags)
    {
        case CURSOR_DBROWACTION_UPDATE:
            m_pCursorPosition->SetEditMode(CURSOR_DBEDITMODE_UPDATE);
            break;

        case CURSOR_DBROWACTION_ADD:
            m_pCursorPosition->SetEditMode(CURSOR_DBEDITMODE_ADD);
            break;
    }

    // notify other interested parties of success
    m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow SetColumn
//=--------------------------------------------------------------------------=
// Sets the current value of the specified column
//
// Parameters:
//	pcid            - [in] a pointer to the columnID for which data is
//                         to be set
//  pBindParams     - [in] a pointer to a column binding structure containing
//                         information about the data and a pointer to the data
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_FAIL a provider-specific error occured
//              CURSOR_DB_E_STATEERROR not in update or add mode
//              CURSOR_DB_E_BADCOLUMNID pcid was not a valid column identifier
//              CURSOR_DB_E_BADBINDINFO bad binding information
//
// Notes:
//
HRESULT CVDCursor::SetColumn(CURSOR_DBCOLUMNID *pcid, CURSOR_DBBINDPARAMS *pBindParams)
{
    ASSERT_POINTER(pcid, CURSOR_DBCOLUMNID)
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)

    // make sure we have valid rowset
    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pcid || !pBindParams || !pBindParams->pData)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // make sure we are in update or add mode
    if (m_pCursorPosition->GetEditMode() == CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_STATEERROR, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_STATEERROR;
    }

    CVDRowsetColumn * pColumn;

    // validate cursor binding parameters and get rowset column
    HRESULT hr = ValidateCursorBindParams(pcid, pBindParams, &pColumn);

    if (FAILED(hr))
        return hr;

    CVDColumnUpdate * pColumnUpdate;

    // create new column update object
    hr = CVDColumnUpdate::Create(pColumn, pBindParams, &pColumnUpdate, m_pResourceDLL);

    if (FAILED(hr))
        return hr;

    // setup notification structures
   	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;

	CURSOR_DBNOTIFYREASON rgReasons[1];
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	VariantInit((VARIANT*)&rgReasons[0].arg2);

	rgReasons[0].dwReason   = CURSOR_DBREASON_SETCOLUMN;
	rgReasons[0].arg1.vt    = VT_I4;
	rgReasons[0].arg1.lVal  = pColumn->GetNumber();
    rgReasons[0].arg2       = pColumnUpdate->GetVariant();

    // notify other interested parties of action
	hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

	// make sure action was not cancelled
	if (hr != S_OK)
    {
        // release column update object
        pColumnUpdate->Release();

        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorUpdateARow, m_pResourceDLL);
		return E_FAIL;
    }

    // update column in cursor position
    m_pCursorPosition->SetColumnUpdate(pColumn->GetNumber(), pColumnUpdate);

    // notify other interested parties of success
    m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow GetColumn
//=--------------------------------------------------------------------------=
// Gets the current value of the specified column
//
// Parameters:
//	pcid            - [in]  a pointer to the columnID for which data is
//                          to be returned
//  pBindParams     - [out] a pointer to a column binding structure in which
//                          to return data
//  pdwFlags        - [out] a pointer to memory in which to return the
//                          changed state of the returned data
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_FAIL a provider-specific error occured
//              CURSOR_DB_E_STATEERROR not in update or add mode
//              CURSOR_DB_E_BADCOLUMNID pcid was not a valid column identifier
//              CURSOR_DB_E_BADBINDINFO bad binding information
//
// Notes:
//
HRESULT CVDCursor::GetColumn(CURSOR_DBCOLUMNID *pcid, CURSOR_DBBINDPARAMS *pBindParams, DWORD *pdwFlags)
{
    ASSERT_POINTER(pcid, CURSOR_DBCOLUMNID)
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)
    ASSERT_NULL_OR_POINTER(pdwFlags, DWORD)

    // make sure rowset is valid
    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pcid || !pBindParams || !pBindParams->pData)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // make sure we are in update or add mode
    if (m_pCursorPosition->GetEditMode() == CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_STATEERROR, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_STATEERROR;
    }

    CVDRowsetColumn * pColumn;

    // validate cursor binding parameters and get rowset column
    HRESULT hr = ValidateCursorBindParams(pcid, pBindParams, &pColumn);

    if (FAILED(hr))
        return hr;

    // get column update pointer for this column
    CVDColumnUpdate * pColumnUpdate = m_pCursorPosition->GetColumnUpdate(pColumn->GetNumber());

    // if not changed, get original value
    if (!pColumnUpdate)
    {
        hr = GetOriginalColumn(pColumn, pBindParams);

        if (pdwFlags)
            *pdwFlags = CURSOR_DBCOLUMNDATA_UNCHANGED;
    }
    else // otherwise, get modified value
    {
        hr = GetModifiedColumn(pColumnUpdate, pBindParams);

        if (pdwFlags)
            *pdwFlags = CURSOR_DBCOLUMNDATA_CHANGED;
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow GetEditMode
//=--------------------------------------------------------------------------=
// Gets the current edit mode: add, update or none
//
// Parameters:
//	pdwState        - [out] a pointer to memory in which to return the
//                          current edit mode
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL a provider-specific error occured
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDCursor::GetEditMode(DWORD *pdwState)
{
    ASSERT_POINTER(pdwState, DWORD)

    // make sure we have a valid rowset
    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have a pointer
    if (!pdwState)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // return edit mode
    *pdwState = m_pCursorPosition->GetEditMode();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow Update
//=--------------------------------------------------------------------------=
// Sends the contents of the edit buffer to the database and optionally
// returns the bookmark for the updated or added row
//
// Parameters:
//	pBookmarkType   - [in]  a pointer to a columnID that specifies the type
//                          of bookmark desired
//  pcbBookmark     - [out] a pointer to memory in which to return the actual
//                          length of the returned bookmark
//  ppBookmark      - [out] a pointer to memory in which to return a pointer
//                          to a bookmark
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL a provider-specific error occured
//              E_OUTOFMEMORY not enough memory
//              CURSOR_DB_E_STATEERROR not in update or add mode
//
// Notes:
//    Kagera does not allow variant bindings on dbtimestamp fields, so this code
//    updates dbtimestamp fields using string pointers if possible.
//
HRESULT CVDCursor::Update(CURSOR_DBCOLUMNID *pBookmarkType, ULONG *pcbBookmark, void **ppBookmark)
{
    ASSERT_NULL_OR_POINTER(pBookmarkType, CURSOR_DBCOLUMNID)
    ASSERT_NULL_OR_POINTER(pcbBookmark, ULONG)
    ASSERT_NULL_OR_POINTER(ppBookmark, void*)

    IAccessor * pAccessor = GetAccessor();
    IRowsetChange * pRowsetChange = GetRowsetChange();
	IRowsetUpdate * pRowsetUpdate = GetRowsetUpdate();
	BOOL fUndo = FALSE;
	BOOL fInsert = FALSE;

    // make sure we have valid accessor and change pointers
    if (!pAccessor || !pRowsetChange || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // get current edit mode
    const DWORD dwEditMode = m_pCursorPosition->GetEditMode();

    // make sure we are in update or add mode
    if (dwEditMode == CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_STATEERROR, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_STATEERROR;
    }


    // get hRow of the row currently being edited
    HROW hRow = m_pCursorPosition->GetEditRow();

    // get column count
    const ULONG ulColumns = GetCursorMain()->GetColumnsCount();

    // create update buffer accessor bindings
    DBBINDING * pBindings = new DBBINDING[ulColumns];

    if (!pBindings)
    {
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_OUTOFMEMORY;
    }

    // clear out bindings
    memset(pBindings, 0, ulColumns * sizeof(DBBINDING));

    // setup notification structures
   	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
                        CURSOR_DBEVENT_NONCURRENT_ROW_DATA_CHANGED |
                        CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;

	CURSOR_DBNOTIFYREASON rgReasons[1];
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	VariantInit((VARIANT*)&rgReasons[0].arg2);

    switch (dwEditMode)
    {
        case CURSOR_DBEDITMODE_UPDATE:
	        rgReasons[0].dwReason   = CURSOR_DBREASON_MODIFIED;
	        rgReasons[0].arg1       = m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();
            break;

        case CURSOR_DBEDITMODE_ADD:
	        rgReasons[0].dwReason   = CURSOR_DBREASON_INSERTED;
	        rgReasons[0].arg1       = m_pCursorPosition->m_bmAddRow.GetBookmarkVariant();
            break;
    }
	
    // notify other interested parties of action
	HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

	// make sure action was not cancelled
	if (hr != S_OK)
    {
        // destroy bindings
        delete [] pBindings;

        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorUpdateARow, m_pResourceDLL);
		return E_FAIL;
    }

    // variables
    ULONG cBindings = 0;
    DBBINDING * pBinding = pBindings;
    CVDColumnUpdate * pColumnUpdate;
    ULONG obUpdate = 0;

    // iterate through columns and setup binding structures
    for (ULONG ulCol = 0; ulCol < ulColumns; ulCol++)
    {
        // get column update pointer
        pColumnUpdate = m_pCursorPosition->GetColumnUpdate(ulCol);

        if (pColumnUpdate)
        {
            // create column update buffer binding
            pBinding->iOrdinal      = pColumnUpdate->GetColumn()->GetOrdinal();
            pBinding->obValue       = obUpdate + sizeof(DBSTATUS) + sizeof(ULONG);
            pBinding->obLength      = obUpdate + sizeof(DBSTATUS);
            pBinding->obStatus      = obUpdate;
            pBinding->dwPart        = DBPART_VALUE;
            pBinding->dwMemOwner    = DBMEMOWNER_CLIENTOWNED;
            pBinding->wType         = DBTYPE_VARIANT;

            // determine if length part is included
            if (pColumnUpdate->GetVarDataLen() != CURSOR_DB_NOVALUE)
                pBinding->dwPart |= DBPART_LENGTH;

			pBinding->dwPart |= DBPART_STATUS;

            // check for variant binding on dbtimestamp field, and supplied variant is a bstr
            if (pColumnUpdate->GetColumn()->GetType() == DBTYPE_DBTIMESTAMP && pColumnUpdate->GetVariantType() == VT_BSTR)
            {
                pBinding->dwPart &= ~DBPART_LENGTH;
                pBinding->wType   = DBTYPE_BYREF | DBTYPE_WSTR;
            }

            // increment update offset
            obUpdate += sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(VARIANT);

            // increment binding
            cBindings++;
            pBinding++;
        }
    }

    // if we have any bindings, then update
    if (cBindings)
    {
        HACCESSOR hAccessor;

        // create update accessor
  	    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, cBindings, pBindings, 0, &hAccessor, NULL);

	    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_ICursorUpdateARow, pAccessor, IID_IAccessor,
            m_pResourceDLL);

        if (FAILED(hr))
        {
            // destroy bindings
            delete [] pBindings;

            // notify other interested parties of failure
		    m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
            return hr;
        }

        // create update buffer
        BYTE * pBuffer = new BYTE[cBindings * (sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(VARIANT))];
		BYTE * pBufferOld = new BYTE[cBindings * (sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(VARIANT))];

        if (!pBuffer || !pBufferOld)
        {
            // destroy bindings
            delete [] pBindings;

			// destroy buffers
			delete [] pBuffer;
			delete [] pBufferOld;

            // release update accessor
      	    pAccessor->ReleaseAccessor(hAccessor, NULL);

            // notify other interested parties of failure
		    m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
            return E_OUTOFMEMORY;
        }


        // variables
        obUpdate = 0;
        pBinding = pBindings;
        CURSOR_DBVARIANT variant;

        // iterate through columns and setup buffer
        for (ULONG ulCol = 0; ulCol < ulColumns; ulCol++)
        {
            // get column update pointer
            pColumnUpdate = m_pCursorPosition->GetColumnUpdate(ulCol);

            if (pColumnUpdate)
            {
				// obtain current status
				DBSTATUS status = CursorInfoToStatus(pColumnUpdate->GetInfo());

				// get value
				variant = pColumnUpdate->GetVariant();

				// check for empty value since some controls treat this as NULL and make sure that we
				// treat the empty value as null
				if (status == DBSTATUS_S_OK &&
					variant.vt == VT_BSTR &&
					wcslen(variant.bstrVal) == 0)
					{
					*(DBSTATUS*)(pBuffer + obUpdate) = DBSTATUS_S_ISNULL;
					}
				else
					{
					*(DBSTATUS*)(pBuffer + obUpdate) = status;
					}

				*(DBSTATUS*)(pBufferOld + obUpdate) = DBSTATUS_S_ISNULL;

                // if necessary, set length part in buffer
                if (pBinding->dwPart & DBPART_LENGTH)
					{
                    *(ULONG*)(pBuffer + obUpdate + sizeof(DBSTATUS)) = pColumnUpdate->GetVarDataLen();
					*(ULONG*)(pBufferOld + obUpdate + sizeof(DBSTATUS)) = 0;
					}

                // always set value part in buffer
                if (pBinding->wType == (DBTYPE_BYREF | DBTYPE_WSTR))
					{
                    *(BSTR*)(pBuffer + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG)) = variant.bstrVal;
					*(BSTR*)(pBufferOld + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG)) = NULL;
					}
                else
					{
                    memcpy(pBuffer + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG), &variant, sizeof(VARIANT));
					VariantInit((VARIANT *) (pBufferOld + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG)));
					}

                // increment update offset
                obUpdate += sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(VARIANT);

                // increment binding
                pBinding++;
            }
        }

		DBPENDINGSTATUS status;

	    if (dwEditMode == CURSOR_DBEDITMODE_ADD)
			fInsert = TRUE;
		else if (pRowsetUpdate)
			{
			pRowsetUpdate->GetRowStatus(NULL, 1, &hRow, &status);
			if (status == DBPENDINGSTATUS_UNCHANGED)
				fUndo = TRUE;
			}


		if (!fUndo && !fInsert)
			{
            hr = GetRowset()->GetData(hRow, hAccessor, pBufferOld);
			if (status != DBPENDINGSTATUS_NEW)
				fUndo = TRUE;
			}

        // modify columns (set/clear internal set data flag)
        GetCursorMain()->SetInternalSetData(TRUE);
        hr = pRowsetChange->SetData(hRow, hAccessor, pBuffer);
		if (hr == DB_S_ERRORSOCCURRED)
			{
			// since partial changes occurred, restore data back
			// to original values.
			if (fUndo)
				pRowsetUpdate->Undo(NULL, 1, &hRow, NULL, NULL, NULL);
			else if (status != DBPENDINGSTATUS_NEW)
				pRowsetChange->SetData(hRow, hAccessor, pBufferOld);

			hr = DB_E_ERRORSOCCURRED;
			}

        GetCursorMain()->SetInternalSetData(FALSE);

	    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_SETDATAFAILED, IID_ICursorUpdateARow, pRowsetChange, IID_IRowsetChange,
            m_pResourceDLL);

        // release update accessor
  	    pAccessor->ReleaseAccessor(hAccessor, NULL);

		obUpdate = 0;
		pBinding = pBindings;
		// iterate through columns and reset buffer
        for (ulCol = 0; ulCol < ulColumns; ulCol++)
        {
            if (m_pCursorPosition->GetColumnUpdate(ulCol))
            {
				VARIANT var;

                if (pBinding->wType == (DBTYPE_BYREF | DBTYPE_WSTR))
					{
					var.vt = VT_BSTR;
					var.bstrVal = *(BSTR*)(pBufferOld + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG));
					}
                else
					{
                    memcpy(&var, pBufferOld + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG), sizeof(VARIANT));
					}

			    VariantClear(&var);

                // increment update offset
                obUpdate += sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(VARIANT);

                // increment binding
                pBinding++;
            }
        }


        // destroy update buffer
        delete [] pBuffer;
		delete [] pBufferOld;
    }

    // destroy bindings
    delete [] pBindings;

    if (FAILED(hr))
    {
        // notify other interested parties of failure
	    m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
    }
    else
    {
        // return bookmark if requested to do so
        if (pBookmarkType && pcbBookmark && ppBookmark)
        {
            switch (dwEditMode)
            {
                case CURSOR_DBEDITMODE_UPDATE:
        		    *pcbBookmark = m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
        		    memcpy(*ppBookmark, m_pCursorPosition->m_bmCurrent.GetBookmark(), *pcbBookmark);
                    break;

                case CURSOR_DBEDITMODE_ADD:
        		    *pcbBookmark = m_pCursorPosition->m_bmAddRow.GetBookmarkLen();
		            memcpy(*ppBookmark, m_pCursorPosition->m_bmAddRow.GetBookmark(), *pcbBookmark);
                    break;
            }
        }

        //  if acquired, release same-row clone
        if (m_pCursorPosition->GetSameRowClone())
            m_pCursorPosition->ReleaseSameRowClone();

        // also, release add row if we have one
        if (m_pCursorPosition->m_bmAddRow.GetHRow())
            m_pCursorPosition->ReleaseAddRow();

        // reset edit mode
        m_pCursorPosition->SetEditMode(CURSOR_DBEDITMODE_NONE);

		// reset column updates
		m_pCursorPosition->ResetColumnUpdates();

        // notify other interested parties of success
	    m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow Cancel
//=--------------------------------------------------------------------------=
// Cancels the update or add operation
//
// Parameters:
//              none
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL a provider-specific error occured
//              CURSOR_DB_E_STATEERROR not in update or add mode
//
// Notes:
//
HRESULT CVDCursor::Cancel(void)
{
    // make sure we have a valid rowset
    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // get current edit mode
    const DWORD dwEditMode = m_pCursorPosition->GetEditMode();

    // make sure we are in update or add mode
    if (dwEditMode == CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_STATEERROR, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_STATEERROR;
    }

    // try to get update pointer
    IRowsetUpdate * pRowsetUpdate = GetRowsetUpdate();

    // get hRow of the row currently being edited
    HROW hRow = m_pCursorPosition->GetEditRow();

    // setup notification structures
    DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;

    CURSOR_DBNOTIFYREASON rgReasons[1];
    VariantInit((VARIANT*)&rgReasons[0].arg1);
    VariantInit((VARIANT*)&rgReasons[0].arg2);

    rgReasons[0].dwReason = CURSOR_DBREASON_CANCELUPDATE;

    // notify other interested parties of action
    HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

    // make sure action was not cancelled
    if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // if we are comming out of add mode, undo inserted row
    if (pRowsetUpdate && dwEditMode == CURSOR_DBEDITMODE_ADD)
    {
        hr = pRowsetUpdate->Undo(0, 1, &hRow, NULL, NULL, NULL);

        hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_UNDOFAILED, IID_ICursorUpdateARow, pRowsetUpdate, IID_IRowsetUpdate,
            m_pResourceDLL);

        if (FAILED(hr))
        {
            // notify other interested parties of failure
            m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
            return hr;
        }
    }

    // if acquired, release same-row clone
    if (m_pCursorPosition->GetSameRowClone())
        m_pCursorPosition->ReleaseSameRowClone();

    // also, release add row if we have one
    if (m_pCursorPosition->m_bmAddRow.GetHRow())
        m_pCursorPosition->ReleaseAddRow();

    // reset edit mode
    m_pCursorPosition->SetEditMode(CURSOR_DBEDITMODE_NONE);

    // reset column updates
    m_pCursorPosition->ResetColumnUpdates();

    // notify other interested parties of success
    m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow Delete
//=--------------------------------------------------------------------------=
// Deletes the current row
//
// Parameters:
//              none
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL a provider-specific error occured
//              CURSOR_DB_E_UPDATEINPROGRESS an update is already in progress
//
// Notes:
//
HRESULT CVDCursor::Delete(void)
{
	IRowsetChange * pRowsetChange = GetRowsetChange();

    // make sure we have a valid change pointer
    if (!pRowsetChange || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure that an update is not already in progress
    if (m_pCursorPosition->GetEditMode() != CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_UPDATEINPROGRESS, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_UPDATEINPROGRESS;
    }

    // get current hRow
    HROW hRow = m_pCursorPosition->m_bmCurrent.GetHRow();

    // setup notification structures
   	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
                        CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;

	CURSOR_DBNOTIFYREASON rgReasons[1];
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	VariantInit((VARIANT*)&rgReasons[0].arg2);
	
	rgReasons[0].dwReason   = CURSOR_DBREASON_DELETED;
	rgReasons[0].arg1       = m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();

    // notify other interested parties of action
	HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

	// make sure action was not cancelled
	if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorUpdateARow, m_pResourceDLL);
		return E_FAIL;
    }

    // try to delete current row (set/clear internal delete rows flag)
    GetCursorMain()->SetInternalDeleteRows(TRUE);
    hr = pRowsetChange->DeleteRows(0, 1, &hRow, NULL);
    GetCursorMain()->SetInternalDeleteRows(FALSE);

    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_DELETEROWSFAILED, IID_ICursorUpdateARow, pRowsetChange, IID_IRowsetChange,
        m_pResourceDLL);

    if (FAILED(hr))
    {
        // notify other interested parties of failure
		m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
    }
    else
    {
        // notify other interested parties of success
	    m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorFind methods
//=--------------------------------------------------------------------------=
// ICursorFind FindByValues
//
HRESULT CVDCursor::FindByValues(ULONG cbBookmark,
								LPVOID pBookmark,
								DWORD dwFindFlags,
								ULONG cValues,
								CURSOR_DBCOLUMNID rgColumns[],
								CURSOR_DBVARIANT rgValues[],
								DWORD rgdwSeekFlags[],
								CURSOR_DBFETCHROWS FAR *pFetchParams)
{
	//////////////////////////////////////////////////////////////////////////
	// this implementation limits the number of columns that can be searched
	// to one, since current OLEDB spec only allows a single column accessor
	// to be passed to IRowsetFind::FindNextRow (06/11/97)
	//
	if (cValues > 1)
		return E_FAIL;
	//
	//////////////////////////////////////////////////////////////////////////

	IAccessor * pAccessor = GetAccessor();
	IRowsetFind * pRowsetFind = GetRowsetFind();

    // make sure we have valid accessor and find pointers
    if (!pAccessor || !pRowsetFind || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

	// check for values
	if (!cValues)
		return S_OK;

	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_CHANGED;

	CURSOR_DBNOTIFYREASON rgReasons[1];
	rgReasons[0].dwReason	= CURSOR_DBREASON_FIND;
	
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	rgReasons[0].arg1.vt	= VT_UI4;
	rgReasons[0].arg1.lVal	= dwFindFlags;

	VariantInit((VARIANT*)&rgReasons[0].arg2);

    // notify other interested parties
	HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

    // make sure action was not cancelled
    if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorFind, m_pResourceDLL);
        return E_FAIL;
    }

	ULONG ul;
	HROW * pRow = NULL;
	ULONG cRowsObtained = 0;
    HACCESSOR hAccessor = NULL;

	// allocate necessary memory
	ULONG * pColumns = new ULONG[cValues];
	DBTYPE * pDBTypes = new DBTYPE[cValues];
	DBCOMPAREOP * pDBCompareOp = new DBCOMPAREOP[cValues];
	BYTE ** ppValues = new BYTE*[cValues];
	BOOL * fMemAllocated = new BOOL[cValues];

	if (fMemAllocated)
	{
		// always init fMemAllocated flags to false
		memset(fMemAllocated, 0, sizeof(BOOL) * cValues);
	}

	// make sure we received all requested memory
	if (!pColumns || !pDBTypes || !ppValues || !pDBCompareOp || !fMemAllocated)
	{
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_IRowsetFind, m_pResourceDLL);
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	// iterate through columns
	for (ul = 0; ul < cValues; ul++)
	{
		// get column ordinal position
		hr = GetOrdinal(rgColumns[ul], &pColumns[ul]);
		
		if (FAILED(hr))
		{
			VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IRowsetFind, m_pResourceDLL);
			hr = E_INVALIDARG;
			goto cleanup;
		}

		// get find values from CURSOR_DBVARIANT
		hr = GetDataFromDBVariant(&rgValues[ul],
								  &pDBTypes[ul],
								  &(ppValues[ul]),
								  &fMemAllocated[ul]);

		if (FAILED(hr))
		{
			VDSetErrorInfo(IDS_ERR_CANTCOERCE, IID_IRowsetFind, m_pResourceDLL);
			goto cleanup;
		}

		// setup seek flags
		switch (rgdwSeekFlags[ul])
		{
			case CURSOR_DBSEEK_LT:
				pDBCompareOp[ul] = DBCOMPAREOPS_LT;
				break;

			case CURSOR_DBSEEK_LE:
				pDBCompareOp[ul] = DBCOMPAREOPS_LE;
				break;

			case CURSOR_DBSEEK_EQ:
				pDBCompareOp[ul] = DBCOMPAREOPS_EQ;
				break;

			case CURSOR_DBSEEK_GE:
				pDBCompareOp[ul] = DBCOMPAREOPS_GE;
				break;

			case CURSOR_DBSEEK_GT:
				pDBCompareOp[ul] = DBCOMPAREOPS_GT;
				break;

			case CURSOR_DBSEEK_PARTIALEQ:
				pDBCompareOp[ul] = DBCOMPAREOPS_BEGINSWITH;
				break;

			default:
				VDSetErrorInfo(IDS_ERR_INVALIDSEEKFLAGS, IID_IRowsetFind, m_pResourceDLL);
				hr = E_FAIL;
				goto cleanup;
		}
	}

	LONG cRows;
	BOOL fSkipCurrent;

	// determine direction of seek
	if (CURSOR_DBFINDFLAGS_FINDPRIOR == dwFindFlags)
	{
		cRows		 = -1;
		fSkipCurrent = TRUE;
	}
	else
	{
		cRows		 = 1;
		fSkipCurrent = TRUE;
	}

	BYTE bSpecialBM;

	// check for standard bookmarks
	if (CURSOR_DB_BMK_SIZE == cbBookmark)
	{
		if (memcmp(&CURSOR_DBBMK_BEGINNING, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			cbBookmark		= sizeof(BYTE);
			bSpecialBM		= DBBMK_FIRST;
			pBookmark		= &bSpecialBM;
			fSkipCurrent	= FALSE;
		}
		else
		if (memcmp(&CURSOR_DBBMK_END, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			cbBookmark		= sizeof(BYTE);
			bSpecialBM		= DBBMK_LAST;
			pBookmark		= &bSpecialBM;
			fSkipCurrent	= FALSE;
		}
		else
		if (memcmp(&CURSOR_DBBMK_CURRENT, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			cbBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
			pBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmark();
		}
	}

    DBBINDING binding;

    // clear out binding
    memset(&binding, 0, sizeof(DBBINDING));

    // create value binding
    binding.iOrdinal    = pColumns[0];
    binding.obValue     = 0;
    binding.dwPart      = DBPART_VALUE;
    binding.dwMemOwner	= DBMEMOWNER_CLIENTOWNED;
    binding.cbMaxLen    = 0x7FFFFFFF;
    binding.wType       = pDBTypes[0];

    // create accessor describing the value to be matched
	hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

	if (FAILED(hr))
		goto cleanup;

	// try to find hRow satisfying our condition
	hr = pRowsetFind->FindNextRow(DB_NULL_HCHAPTER, 
								  hAccessor,
								  ppValues[0],
								  pDBCompareOp[0],
								  cbBookmark,
								  (BYTE*)pBookmark,
								  fSkipCurrent,
								  cRows,
								  &cRowsObtained,
								  &pRow);

	// check to see if we rached end of rowset
	if (hr == DB_S_ENDOFROWSET && !cRowsObtained)
		hr = E_FAIL;

	if (FAILED(hr))
		hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_FINDFAILED, IID_ICursorFind, pRowsetFind, IID_IRowsetFind, m_pResourceDLL);

	// check to see if we got the hRow
	if (SUCCEEDED(hr) && cRowsObtained)
	{
		// allocate buffer for bookmark plus length indicator
		BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];

		if (!pBuff)
			hr = E_OUTOFMEMORY;
		else
		{
			// get the bookmark data
			hr = GetRowset()->GetData(*pRow, GetCursorMain()->GetBookmarkAccessor(), pBuff);
			if (SUCCEEDED(hr))
			{
				ULONG * pulLen = (ULONG*)pBuff;
				BYTE * pbmdata = pBuff + sizeof(ULONG);
				LARGE_INTEGER dlOffset;
				dlOffset.HighPart	= 0;
				dlOffset.LowPart	= 0;
				hr = FetchAtBookmark(*pulLen, pbmdata, dlOffset, pFetchParams);
			}
			else
				hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursorFind, pRowsetFind, IID_IRowset, m_pResourceDLL);

			delete [] pBuff;
		}

	}
	
	if (pRow)
	{
		// release hRow
		if (cRowsObtained)
			GetRowset()->ReleaseRows(1, pRow, NULL, NULL, NULL);
		g_pMalloc->Free(pRow);
	}

cleanup:

	rgReasons[0].arg2.vt		= VT_BOOL;
	V_BOOL(&rgReasons[0].arg2)	= SUCCEEDED(hr) ? TRUE : FALSE;

	if (SUCCEEDED(hr))
	{
        // notify other interested parties of success
		m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
	}
	else
	{
        // notify other interested parties of failure
		m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
	}

	// free values
	if (ppValues && fMemAllocated)
	{
		for (ul = 0; ul < cValues; ul++)
		{
			if (fMemAllocated[ul] && ppValues[ul])
				g_pMalloc->Free(ppValues[ul]);
		}
	}

	// free memory
	delete [] pColumns;
	delete [] pDBTypes;
	delete [] ppValues;
	delete [] pDBCompareOp;
	delete [] fMemAllocated;

	// release accessor
	if (hAccessor)
	    pAccessor->ReleaseAccessor(hAccessor, NULL);

    return hr;
}

//=--------------------------------------------------------------------------=
// IEnrtyID methods
//=--------------------------------------------------------------------------=
// IEntryID GetInterface
//=--------------------------------------------------------------------------=
// Gets the requested interface pointer to the given entryID
//
// Parameters:
//  cbEntryID   - [in]  the size of the entryID
//  pEntryID    - [in]  a pointer to the entryID
//  dwFlags     - [in]  interface specific flags
//  riid        - [in]  the interface id for the interface desired
//  ppvObj      - [out] a pointer to memory in which to return interface pointer
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_FAIL a provider-specific error occured
//              E_NOINTERFACE no such interface supported
//              CURSOR_DB_E_BADENTRYID bad entry identifier
//
// Notes:
//
HRESULT CVDCursor::GetInterface(ULONG cbEntryID, void *pEntryID, DWORD dwFlags, REFIID riid, IUnknown **ppvObj)
{
    ASSERT_POINTER(pEntryID, BYTE)
    ASSERT_POINTER(ppvObj, IUnknown*)

	IRowset * pRowset = GetRowset();

    // make sure we have a valid rowset pointer
    if (!pRowset || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pEntryID || !ppvObj)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameter
    *ppvObj = NULL;

    HROW hRow;
    CVDRowsetColumn * pColumn;

    // validate supplied entryID, and get rowset column and hRow
    HRESULT hr = ValidateEntryID(cbEntryID, (BYTE*)pEntryID, &pColumn, &hRow);

    if (FAILED(hr))
        return hr;

    IUnknown * pUnknown = NULL;

    // first, try to get requested interface from entry identifier
    hr = QueryEntryIDInterface(pColumn, hRow, dwFlags, riid, &pUnknown);

    // if we succeeded or caller is not asking for IStream then leave
    if (SUCCEEDED(hr) || riid != IID_IStream)
    {
        // release reference on hRow
        pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);
        *ppvObj = pUnknown;
        return hr;
    }

#ifndef VD_DONT_IMPLEMENT_ISTREAM

    IStream * pStream;

    // create stream from entry identifier
    hr = CreateEntryIDStream(pColumn, hRow, &pStream);

    if (FAILED(hr))
    {
        // release reference on hRow
        pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);
        return hr;
    }

    CVDEntryIDData * pEntryIDData;

    // create entryID data object
    hr = CVDEntryIDData::Create(m_pCursorPosition, pColumn, hRow, pStream, &pEntryIDData, m_pResourceDLL);

    // release reference on hRow
    pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);

    // release reference on stream
    pStream->Release();

    if (FAILED(hr))
        return hr;

    CVDStream * pVDStream;

    // create viaduct stream object
    hr = CVDStream::Create(pEntryIDData, pStream, &pVDStream, m_pResourceDLL);

    // release reference on entryID data object
    pEntryIDData->Release();

    if (FAILED(hr))
        return hr;

    // return stream
    *ppvObj = pVDStream;

    return S_OK;

#else //VD_DONT_IMPLEMENT_ISTREAM

    // release reference on hRow
    pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);

    VDSetErrorInfo(IDS_ERR_NOINTERFACE, IID_IEntryID, m_pResourceDLL);
    return E_NOINTERFACE;

#endif //VD_DONT_IMPLEMENT_ISTREAM
}

/////////////////////////////////////////////////////////////////////////
// CVDNotifier functions
/////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Member:		Notify Fail (public)
//
// Synopsis:	send NotifyFail notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		it worked

HRESULT
CVDCursor::NotifyFail(DWORD dwEventWhat, ULONG cReasons,
					   CURSOR_DBNOTIFYREASON rgReasons[])
{
    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
		ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->FailedToDo(dwEventWhat, cReasons, rgReasons);

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////
// CCursorNotifier helper functions
/////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Member:		Notify OK To Do (public)
//
// Synopsis:	Send OKToDo notification.  If a client objects (by
//				returning a non-zero HR, send FailedToDo to notified
//				clients to cancel the event.
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients agree it's OK to do the event
//				other		some client disagrees

HRESULT
CVDCursor::NotifyOKToDo(DWORD dwEventWhat, ULONG cReasons,
						 CURSOR_DBNOTIFYREASON rgReasons[])
{
    HRESULT hr = S_OK;

    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
	{
		hr = ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->OKToDo(dwEventWhat, cReasons, rgReasons);
		if (S_OK != hr)
		{
			for (UINT ui = 0; ui <= uiConn; ui++)	
				ppNotifyDBEvents[uiConnectionsActive - ui - 1]->Cancelled(dwEventWhat, cReasons, rgReasons);
			break;
		}
	}

    return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify Sync Before (public)
//
// Synopsis:	Send SyncBefore notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients received notification
//				other		some client returned an error

HRESULT
CVDCursor::NotifySyncBefore(DWORD dwEventWhat, ULONG cReasons,
							 CURSOR_DBNOTIFYREASON rgReasons[])
{
    HRESULT hr = S_OK;

    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
	{
		hr = ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->SyncBefore(dwEventWhat, cReasons, rgReasons);
		if (S_OK != hr)
			break;
	}

    return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify About To Do (public)
//
// Synopsis:	Send AboutToDo notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified
//				other		some client returned an error

HRESULT
CVDCursor::NotifyAboutToDo(DWORD dwEventWhat, ULONG cReasons,
							CURSOR_DBNOTIFYREASON rgReasons[])
{
    HRESULT hr = S_OK;

    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
	{
		hr = ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->AboutToDo(dwEventWhat, cReasons, rgReasons);
		if (S_OK != hr)
			break;
	}

    return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify Sync After (public)
//
// Synopsis:	Send SyncAfter notification.
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDCursor::NotifySyncAfter(DWORD dwEventWhat, ULONG cReasons,
								CURSOR_DBNOTIFYREASON rgReasons[])
{
    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
		ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->SyncAfter(dwEventWhat, cReasons, rgReasons);

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify Did Event (public)
//
// Synopsis:	Send DidEvent notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDCursor::NotifyDidEvent(DWORD dwEventWhat, ULONG cReasons,
							   CURSOR_DBNOTIFYREASON rgReasons[])
{
    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
		ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->DidEvent(dwEventWhat, cReasons, rgReasons);

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify Cancel (public)
//
// Synopsis:	Send Cancelled notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDCursor::NotifyCancel(DWORD dwEventWhat, ULONG cReasons,
						 	 CURSOR_DBNOTIFYREASON rgReasons[])
{
    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
		ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->Cancelled(dwEventWhat, cReasons, rgReasons);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\debug.h ===
//=--------------------------------------------------------------------------=
// Debug.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the various macros and the like which are only useful in DEBUG
// builds
//
#ifndef _DEBUG_H_

//=---------------------------------------------------------------------------=
// all the things required to handle our ASSERT mechanism
//=---------------------------------------------------------------------------=
//
#ifdef _DEBUG

// Function Prototypes
//
VOID DisplayAssert(LPSTR pszMsg, LPSTR pszAssert, LPSTR pszFile, UINT line);

// Macros
//
// *** Include this macro at the top of any source file using *ASSERT*() macros ***
//
#define SZTHISFILE	static char _szThisFile[] = __FILE__;


// our versions of the ASSERT and FAIL macros.
//
#define ASSERT(fTest, szMsg)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = szMsg;                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }

#define ASSERT_(fTest)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = "Assertion failure";                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }

#define FAIL(szMsg)                                         \
        { static char szMsgCode[] = szMsg;                    \
        DisplayAssert(szMsgCode, "FAIL", _szThisFile, __LINE__); }


#define ASSERT_POINTER(p, type) \
	ASSERT(((p) != NULL) && !IsBadReadPtr((p), sizeof(type)), "Null or bad Pointer")

#define ASSERT_NULL_OR_POINTER(p, type) \
	ASSERT(((p) == NULL) || !IsBadReadPtr((p), sizeof(type)), "Bad Pointer")

#define ASSERT_POINTER_LEN(p, len) \
	ASSERT(((p) != NULL) && !IsBadReadPtr((p), len), "Null or bad Pointer")

#define ASSERT_POINTER_OCCURS(p, type, occurs) \
	ASSERT(((p) != NULL) && !IsBadReadPtr((p), sizeof(type) * occurs), "Null or bad Pointer")

// macro that checks a pointer for validity on input
//
#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

// Viaduct 1
#define VD_ASSERTMSG_SEMAPHORECOUNTTOOLOW "Semaphore count too low"
#define VD_ASSERTMSG_SEMAPHOREWAITERROR "Semaphore wait failed"
#define VD_ASSERTMSG_OUTOFMEMORY "Out of memory"
#define VD_ASSERTMSG_BADSTATUS "Bad status"
#define VD_ASSERTMSG_UNKNOWNDBTYPE "Unknown DBTYPE"
#define VD_ASSERTMSG_BADCOLUMNINDEX "Bad column index"
#define VD_ASSERTMSG_INVALIDROWSTATUS "Invalid row status"
#define VD_ASSERTMSG_COLALREADYINITIALIZED "CVDColumn already initialized"
#define VD_ASSERTMSG_COLCOUNTDOESNTMATCH "Column counts don't match"
#define VD_ASSERTMSG_CANTDIVIDEBYZERO "Can't divide by zero"
#define VD_ASSERTMSG_CANTFINDRESOURCEDLL "Can't find error string resource dll."

// Viaduct 2
#define VD_ASSERTMSG_ROWSRCALREADYINITIALIZED "CVDRowsetSource already initialized"

#else  // DEBUG

#define SZTHISFILE
#define ASSERT_POINTER(p, type)
#define ASSERT_NULL_OR_POINTER(p, type)
#define ASSERT_POINTER_LEN(p, len)
#define ASSERT_POINTER_OCCURS(p, type, occurs) 
#define ASSERT(fTest, err)
#define ASSERT_(fTest)                               
#define FAIL(err)

#define CHECK_POINTER(val)

#define VD_ASSERTMSG_SEMAPHORECOUNTTOOLOW 0
#define VD_ASSERTMSG_SEMAPHOREWAITERROR 0
#define VD_ASSERTMSG_OUTOFMEMORY 0
#define VD_ASSERTMSG_BADSTATUS 0
#define VD_ASSERTMSG_UNKNOWNDBTYPE 0
#define VD_ASSERTMSG_BADCOLUMNINDEX 0
#define VD_ASSERTMSG_INVALIDROWSTATUS 0
#define VD_ASSERTMSG_COLALREADYINITIALIZED 0
#define VD_ASSERTMSG_COLCOUNTDOESNTMATCH 0
#define VD_ASSERTMSG_CANTDIVIDEBYZERO 0
#define VD_ASSERTMSG_CANTFINDRESOURCEDLL 0

#endif	// DEBUG




#define _DEBUG_H_
#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\enumcnpt.h ===
//---------------------------------------------------------------------------
// enumcnpt.h : CVDConnectionPointContainer header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __CVDENUMCONNECTIONPOINTS__
#define __CVDENUMCONNECTIONPOINTS__

class CVDEnumConnPoints : public IEnumConnectionPoints
{
public:
	CVDEnumConnPoints(IConnectionPoint* pConnPt);
	virtual ~CVDEnumConnPoints();

protected:
	DWORD				m_dwRefCount;
	DWORD				m_dwCurrentPosition;
	IConnectionPoint*	m_pConnPt; // there is only one connection point

public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.
    //
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
	// IEnumConnectionPoints methods
    //
	STDMETHOD(Next)(THIS_ ULONG cConnections, LPCONNECTIONPOINT FAR* rgpcn,
		ULONG FAR* lpcFetched);
	STDMETHOD(Skip)(THIS_ ULONG cConnections);
	STDMETHOD(Reset)(THIS);
	STDMETHOD(Clone)(THIS_ LPENUMCONNECTIONPOINTS FAR* ppEnum);

};
/////////////////////////////////////////////////////////////////////////////
#endif //__CVDENUMCONNECTIONPOINTS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\entryid.h ===
//---------------------------------------------------------------------------
// EntryIDData.h : CVDEntryIDData header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDENTRYIDDATA__
#define __CVDENTRYIDDATA__

#ifndef VD_DONT_IMPLEMENT_ISTREAM


class CVDEntryIDData
{
protected:
// Construction/Destruction
	CVDEntryIDData();
	virtual ~CVDEntryIDData();

public:
    static HRESULT Create(CVDCursorPosition * pCursorPosition, CVDRowsetColumn * pColumn, HROW hRow, IStream * pStream, 
        CVDEntryIDData ** ppEntryIDData, CVDResourceDLL * pResourceDLL);

// Reference count
    ULONG AddRef();
    ULONG Release();

// Updating data
    void SetDirty(BOOL fDirty) {m_fDirty = fDirty;}
    HRESULT Commit();

protected:
// Data members
    DWORD               m_dwRefCount;       // reference count
    CVDCursorPosition * m_pCursorPosition;	// backwards pointer to CVDCursorPosition
    CVDRowsetColumn *   m_pColumn;          // rowset column pointer
    HROW                m_hRow;             // row handle
    IStream *           m_pStream;          // data stream pointer
	CVDResourceDLL *	m_pResourceDLL;     // resource DLL
    BOOL                m_fDirty;           // dirty flag
};


#endif //VD_DONT_IMPLEMENT_ISTREAM

#endif //__CVDENTRYIDDATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\errorinf.cpp ===
//---------------------------------------------------------------------------
// SetErrorInfo.cpp 
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "globals.h"
#include "resource.h"
#include <mbstring.h>

// needed for ASSERTs and FAIL
//
SZTHISFILE

#define MAX_STRING_BUFFLEN	512

CVDResourceDLL::CVDResourceDLL(LCID lcid)
{
	m_lcid = lcid; 
	m_hinstance = 0;
}

CVDResourceDLL::~CVDResourceDLL()
{
	if (m_hinstance)
		FreeLibrary(m_hinstance);
}

int CVDResourceDLL::LoadString(UINT uID,			// resource identifier 
								LPTSTR lpBuffer,	// address of buffer for resource 
								int nBufferMax)		// size of buffer 
{
	lpBuffer[0] = 0;  //initialize buffer

	if (!m_hinstance)
	{
		// Get this dll's full path
		TCHAR szDllName[MAX_PATH];
		GetModuleFileName(g_hinstance, szDllName, MAX_PATH);

		// Strip off filename/ext leaving dir path
		TBYTE * szDirectory = _mbsrchr((TBYTE*)szDllName, '\\');

		if (!szDirectory)
			szDirectory = _mbsrchr((TBYTE*)szDllName, ':');

		if (szDirectory)
		{
			szDirectory = _mbsinc(szDirectory);
			*szDirectory = 0;
		}

		// construct dll name from supplied lcid
		TCHAR szLang[4 * 2];
		szLang[0] = 0;
		GetLocaleInfo (m_lcid, 
					   LOCALE_SABBREVLANGNAME,
					   szLang, 
					   4 * 2);
	   	_mbscat((TBYTE*)szDllName, (TBYTE*)VD_DLL_PREFIX);
	   	_mbscat((TBYTE*)szDllName, (TBYTE*)szLang);
	   	_mbscat((TBYTE*)szDllName, (TBYTE*)".DLL");
		m_hinstance = LoadLibrary(szDllName);

		// if dll not found try english us dll which should always be there
		if (!m_hinstance && szDirectory)	
		{
			*szDirectory = 0;
			_mbscat((TBYTE*)szDllName, (TBYTE*)VD_DLL_PREFIX);
	   		_mbscat((TBYTE*)szDllName, (TBYTE*)"ENU.DLL");
			m_hinstance = LoadLibrary(szDllName);
			ASSERT(m_hinstance, VD_ASSERTMSG_CANTFINDRESOURCEDLL);
		}
	}

	return m_hinstance ? ::LoadString(m_hinstance, uID, lpBuffer, nBufferMax) : 0;
}

//=--------------------------------------------------------------------------=
// VDSetErrorInfo
//=--------------------------------------------------------------------------=
// Sets rich error info
//
// Parameters:
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//

void VDSetErrorInfo(UINT nErrStringResID,
				    REFIID riid,
					CVDResourceDLL * pResDLL)
{

	ICreateErrorInfo *pCreateErrorInfo;  

	HRESULT hr = CreateErrorInfo(&pCreateErrorInfo); 
	if (SUCCEEDED(hr))
	{
		TCHAR buff[MAX_STRING_BUFFLEN];
		
		// set guid
		pCreateErrorInfo->SetGUID(riid);

		// load source string
		int nLen = pResDLL->LoadString(IDS_ERR_SOURCE,
									   buff,
									   MAX_STRING_BUFFLEN);
		
		if (nLen > 0)
		{
			BSTR bstr = BSTRFROMANSI(buff);

			if (bstr)
			{
				pCreateErrorInfo->SetSource(bstr);
				SysFreeString(bstr);
			}
			
			// load error description
			nLen = pResDLL->LoadString(nErrStringResID,
									   buff,
									   MAX_STRING_BUFFLEN);
			if (nLen > 0)
			{
				bstr = BSTRFROMANSI(buff);

				if (bstr)
				{
					pCreateErrorInfo->SetDescription(bstr);
					SysFreeString(bstr);
				}
			}
			
			IErrorInfo *pErrorInfo;
			hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (LPVOID FAR*) &pErrorInfo);

			if (SUCCEEDED(hr))
			{
				SetErrorInfo(0, pErrorInfo);
				pErrorInfo->Release();
			}
		}
		
		pCreateErrorInfo->Release();
	}  
 
}


//=--------------------------------------------------------------------------=
// VDCheckErrorInfo
//=--------------------------------------------------------------------------=
// Checks if rich error info is already available, otherwise it supplies it  
//
// Parameters:
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//

void VDCheckErrorInfo(UINT nErrStringResID,
						REFIID riid,
						LPUNKNOWN punkSource,
   						REFIID riidSource,
						CVDResourceDLL * pResDLL)
{

	if (punkSource)
	{
		// check if the ISupportErrorInfo interface is implemented
		ISupportErrorInfo * pSupportErrorInfo = NULL;
		HRESULT hr = punkSource->QueryInterface(IID_ISupportErrorInfo, 
											(void**)&pSupportErrorInfo); 
		if SUCCEEDED(hr)
		{
			// check if the interface that generated the error supports error info
			BOOL fInterfaceSupported = (S_OK == pSupportErrorInfo->InterfaceSupportsErrorInfo(riidSource));
			pSupportErrorInfo->Release();
			if (fInterfaceSupported)
				return;	// rich error info has already been supplied so just return
		}
	}

	// rich error info wasn't supplied so set it ourselves
	VDSetErrorInfo(nErrStringResID, riid, pResDLL);
}

//=--------------------------------------------------------------------------=
// VDGetErrorInfo
//=--------------------------------------------------------------------------=
// if available, gets rich error info from supplied interface
//
// Parameters:
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//    pbstrErrorDesc    - [out] a pointer to memory in which to return
//                              error description BSTR.
//
// Note - this function is no longer used, however it might be useful in
//        the future so it was not permanently removed.
//
/*
HRESULT VDGetErrorInfo(LPUNKNOWN punkSource,
   				            REFIID riidSource,
                            BSTR * pbstrErrorDesc)
{
    ASSERT_POINTER(pbstrErrorDesc, BSTR)

	if (punkSource && pbstrErrorDesc)
	{
        // init out parameter
        *pbstrErrorDesc = NULL;

		// check if the ISupportErrorInfo interface is implemented
		ISupportErrorInfo * pSupportErrorInfo = NULL;
		HRESULT hr = punkSource->QueryInterface(IID_ISupportErrorInfo, 
											(void**)&pSupportErrorInfo); 
		if (SUCCEEDED(hr))
		{
			// check if the interface that generated the error supports error info
			BOOL fInterfaceSupported = (S_OK == pSupportErrorInfo->InterfaceSupportsErrorInfo(riidSource));
			pSupportErrorInfo->Release();

			if (fInterfaceSupported)
            {
                // get error info interface
                IErrorInfo * pErrorInfo = NULL;
                hr = GetErrorInfo(0, &pErrorInfo);

                if (hr == S_OK)
                {
    			    // get rich error info
                    hr = pErrorInfo->GetDescription(pbstrErrorDesc);
                    pErrorInfo->Release();
                    return hr;
                }
            }
		}
	}

    return E_FAIL;
}
*/

//=--------------------------------------------------------------------------=
// VDMapCursorHRtoRowsetHR
//=--------------------------------------------------------------------------=
// Translates an ICursor HRESULT to an IRowset HRESULT
//
// Parameters:
//    nErrStringResID	- [in]  ICursor HRESULT
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
// Output:
//    HRESULT - Translated IRowset HRESULT
//

HRESULT VDMapCursorHRtoRowsetHR(HRESULT hr,
							 UINT nErrStringResIDFailed,
							 REFIID riid,
							 LPUNKNOWN punkSource,
   							 REFIID riidSource,
							 CVDResourceDLL * pResDLL)
{

    switch (hr)
    {
        case CURSOR_DB_S_ENDOFCURSOR:
            hr = DB_S_ENDOFROWSET;
            break;

        case CURSOR_DB_E_BADBOOKMARK:
			VDCheckErrorInfo(IDS_ERR_BADBOOKMARK, riid, punkSource, riidSource, pResDLL); 
            hr = DB_E_BADBOOKMARK;
            break;

        case CURSOR_DB_E_ROWDELETED:
			VDCheckErrorInfo(IDS_ERR_DELETEDROW, riid, punkSource, riidSource, pResDLL); 
            hr = DB_E_DELETEDROW;
            break;

        case CURSOR_DB_E_BADFRACTION:
			VDCheckErrorInfo(IDS_ERR_BADFRACTION, riid, punkSource, riidSource, pResDLL); 
            hr = DB_E_BADRATIO;
            break;

       case CURSOR_DB_E_UPDATEINPROGRESS:
			VDCheckErrorInfo(IDS_ERR_UPDATEINPROGRESS, riid, punkSource, riidSource, pResDLL); 
			hr = E_FAIL;
            break;

        case E_OUTOFMEMORY:
			VDCheckErrorInfo((UINT)E_OUTOFMEMORY, riid, punkSource, riidSource, pResDLL); 
            hr = E_OUTOFMEMORY;
            break;

        default:
			if FAILED(hr)
			{
				VDCheckErrorInfo(nErrStringResIDFailed, riid, punkSource, riidSource, pResDLL); 
				hr = E_FAIL;
			}
            break;
    }

	return hr;
}

//=--------------------------------------------------------------------------=
// VDMapRowsetHRtoCursorHR
//=--------------------------------------------------------------------------=
// Translates an IRowset HRESULT to an ICursor HRESULT
//
// Parameters:
//    hr	            - [in]  IRowset HRESULT
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to IRowsetFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
// Output:
//    HRESULT - Translated ICursor HRESULT
//

HRESULT VDMapRowsetHRtoCursorHR(HRESULT hr,
							 UINT nErrStringResIDFailed,
							 REFIID riid,
							 LPUNKNOWN punkSource,
   							 REFIID riidSource,
							 CVDResourceDLL * pResDLL)
{
    switch (hr)
    {
        case DB_S_ENDOFROWSET:
            hr = CURSOR_DB_S_ENDOFCURSOR;
            break;

        case DB_E_DELETEDROW:
			VDCheckErrorInfo(IDS_ERR_DELETEDROW, riid, punkSource, riidSource, pResDLL); 
            hr = CURSOR_DB_E_ROWDELETED;
            break;

		case DB_E_BADBOOKMARK:
			VDCheckErrorInfo(IDS_ERR_BADBOOKMARK, riid, punkSource, riidSource, pResDLL); 
            hr = CURSOR_DB_E_BADBOOKMARK;
			break;

        case DB_E_BADRATIO: 
			VDCheckErrorInfo(IDS_ERR_BADFRACTION, riid, punkSource, riidSource, pResDLL); 
            hr = CURSOR_DB_E_BADFRACTION;
            break;

        case E_OUTOFMEMORY:
			VDCheckErrorInfo((UINT)E_OUTOFMEMORY, riid, punkSource, riidSource, pResDLL); 
            hr = E_OUTOFMEMORY;
            break;

        default:
			if FAILED(hr)
			{
				VDCheckErrorInfo(nErrStringResIDFailed, riid, punkSource, riidSource, pResDLL); 
				hr = E_FAIL;
			}
            break;
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\entryid.cpp ===
//---------------------------------------------------------------------------
// EntryIDData.cpp : EntryIDData implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
 
#ifndef VD_DONT_IMPLEMENT_ISTREAM

#include "Notifier.h"        
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"        
#include "ColUpdat.h"
#include "CursPos.h"        
#include "EntryID.h"         
#include "resource.h"         

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDEntryIDData - Constructor
//
CVDEntryIDData::CVDEntryIDData()
{
    m_dwRefCount        = 1;
    m_pCursorPosition   = NULL;
    m_pColumn           = NULL;
    m_hRow              = 0;
    m_pStream           = NULL;
	m_pResourceDLL		= NULL;
    m_fDirty            = FALSE;

#ifdef _DEBUG
    g_cVDEntryIDDataCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDEntryIDData - Destructor
//
CVDEntryIDData::~CVDEntryIDData()
{
    if (m_fDirty)
        Commit();

	if (m_pCursorPosition)
    {
        if (m_hRow) 
        {
	        IRowset * pRowset = m_pCursorPosition->GetCursorMain()->GetRowset();

            if (pRowset && m_pCursorPosition->GetCursorMain()->IsRowsetValid())
                pRowset->ReleaseRows(1, &m_hRow, NULL, NULL, NULL);
        }

		((CVDNotifier*)m_pCursorPosition)->Release();
    }

    if (m_pStream)
        m_pStream->Release();

#ifdef _DEBUG
    g_cVDEntryIDDataDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// Create - Create entryID data object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new entryID data object
//
// Parameters:
//    pCursorPosition   - [in]  backwards pointer to CVDCursorPosition object
//    pColumn           - [in]  rowset column pointer
//    hRow              - [in]  row handle
//    pStream           - [in]  data stream pointer
//    ppEntryIDData     - [out] a pointer in which to return pointer to 
//                              entryID data object
//    pResourceDLL      - [in]  a pointer which keeps track of resource DLL
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDEntryIDData::Create(CVDCursorPosition * pCursorPosition, CVDRowsetColumn * pColumn, HROW hRow, 
    IStream * pStream, CVDEntryIDData ** ppEntryIDData, CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pCursorPosition, CVDCursorPosition)
    ASSERT_POINTER(pStream, IStream)
    ASSERT_POINTER(ppEntryIDData, CVDEntryIDData*)
    ASSERT_POINTER(pResourceDLL, CVDResourceDLL)

    // make sure we have all necessary pointers
    if (!pCursorPosition || !pStream || !ppEntryIDData)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, pResourceDLL);
        return E_INVALIDARG;
    }

	IRowset * pRowset = pCursorPosition->GetCursorMain()->GetRowset();

    // make sure we have a valid rowset pointer
    if (!pRowset || !pCursorPosition->GetCursorMain()->IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, pResourceDLL);
        return E_FAIL;
    }

    *ppEntryIDData = NULL;

    CVDEntryIDData * pEntryIDData = new CVDEntryIDData();

    if (!pEntryIDData)
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_IEntryID, pResourceDLL);
        return E_OUTOFMEMORY;
    }

    ((CVDNotifier*)pCursorPosition)->AddRef();
    pRowset->AddRefRows(1, &hRow, NULL, NULL); 
    pStream->AddRef();

    pEntryIDData->m_pCursorPosition = pCursorPosition;
    pEntryIDData->m_pColumn         = pColumn;
    pEntryIDData->m_hRow            = hRow;
    pEntryIDData->m_pStream         = pStream;
	pEntryIDData->m_pResourceDLL    = pResourceDLL;

    *ppEntryIDData = pEntryIDData;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// AddRef
//
ULONG CVDEntryIDData::AddRef(void)
{
    return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// Release
//
ULONG CVDEntryIDData::Release(void)
{
    if (1 > --m_dwRefCount)
    {
        delete this;
        return 0;
    }

    return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// Commit
//
HRESULT CVDEntryIDData::Commit()
{
    HRESULT hr = S_OK;

    if (m_fDirty)
    {
        hr = m_pCursorPosition->UpdateEntryIDStream(m_pColumn, m_hRow, m_pStream);

        if (SUCCEEDED(hr))
            m_fDirty = FALSE;
    }

    return hr;
}


#endif //VD_DONT_IMPLEMENT_ISTREAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\enumcnpt.cpp ===
//---------------------------------------------------------------------------
// enumcnpt.cpp : CVDEnumConnPoints implementation file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "enumcnpt.h"         

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// CVDEnumConnPoints constructor
//
CVDEnumConnPoints::CVDEnumConnPoints(IConnectionPoint* pConnPt)
{
	m_dwRefCount			= 1;
	m_dwCurrentPosition		= 0;
	m_pConnPt				= pConnPt;
	ADDREF_OBJECT(m_pConnPt);

#ifdef _DEBUG
    g_cVDEnumConnPointsCreated++;
#endif			
}

//=--------------------------------------------------------------------------=
// CVDEnumConnPoints destructor
//
CVDEnumConnPoints::~CVDEnumConnPoints()
{
	RELEASE_OBJECT(m_pConnPt);

#ifdef _DEBUG
    g_cVDEnumConnPointsDestroyed++;
#endif			
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface 
//
HRESULT CVDEnumConnPoints::QueryInterface(REFIID riid, void **ppvObjOut)
{
	ASSERT_POINTER(ppvObjOut, IUnknown*)

	*ppvObjOut = NULL;

	if (DO_GUIDS_MATCH(riid, IID_IUnknown) ||
		DO_GUIDS_MATCH(riid, IID_IEnumConnectionPoints) )
		{
		*ppvObjOut = this;
		AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// IUnknown AddRef
//
ULONG CVDEnumConnPoints::AddRef(void)
{
	return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IUnknown Release
//
ULONG CVDEnumConnPoints::Release(void)
{
	
	if (1 > --m_dwRefCount)
		{
		delete this;
		return 0;
		}

	return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IEnumConnectionPoints Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IEnumConnectionPoints Next
//
HRESULT CVDEnumConnPoints::Next(ULONG cConnections, LPCONNECTIONPOINT FAR* rgpcn,
		ULONG FAR* lpcFetched)
{
	ASSERT_POINTER(rgpcn, LPCONNECTIONPOINT)
	ASSERT_NULL_OR_POINTER(lpcFetched, ULONG)

	if (cConnections > 0 && m_dwCurrentPosition == 0 && m_pConnPt)
		{
		*rgpcn		= m_pConnPt;
		if (lpcFetched)
			*lpcFetched	= 1;
		m_dwCurrentPosition	= 1;
		return S_OK;
		}
	else
		return S_FALSE;
}

//=--------------------------------------------------------------------------=
// IEnumConnectionPoints Skip
//
HRESULT CVDEnumConnPoints::Skip(ULONG cConnections)
{
	m_dwCurrentPosition	= 1;
	return S_FALSE;
}

//=--------------------------------------------------------------------------=
// IEnumConnectionPoints Reset
//
HRESULT CVDEnumConnPoints::Reset()
{
	m_dwCurrentPosition = 0;

	return S_OK;
}

//=--------------------------------------------------------------------------=
// IEnumConnectionPoints Clone
//
HRESULT CVDEnumConnPoints::Clone(LPENUMCONNECTIONPOINTS FAR* ppEnum)
{
	ASSERT_POINTER(ppEnum, LPENUMCONNECTIONPOINTS)

	*ppEnum = new CVDEnumConnPoints(m_pConnPt);
	return (*ppEnum != NULL) ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\fastguid.h ===
//---------------------------------------------------------------------------
// Fastguid.h : Macros used to speed up guid comparisons
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __FASTGUID__
#define __FASTGUID__

#define SUPPORTS_ERROR_INFO(itf)              \
    case Data1_##itf:                       \
      if(DO_GUIDS_MATCH(riid, IID_##itf))    \
      {                                     \
		fSupportsErrorInfo	= TRUE;	\
      }                                     \
      break;

#define QI_INTERFACE_SUPPORTED(pObj, itf)              \
    case Data1_##itf:                       \
      if(DO_GUIDS_MATCH(riid, IID_##itf))    \
      {                                     \
        *ppvObjOut = (void *)(itf *)pObj;   \
      }                                     \
      break;

#define QI_INTERFACE_SUPPORTED_IF(pObj, itf, supportif) \
    case Data1_##itf:                       \
      if(supportif && DO_GUIDS_MATCH(riid, IID_##itf))    \
      {                                     \
        *ppvObjOut = (void *)(itf *)pObj;   \
      }                                     \
      break;

#define BOOL_PROP_SUPPORTED(itf, value) \
    case itf: \
		var.boolVal     = (VARIANT_BOOL)value; \
		fPropSupported	= TRUE; \
		break;

#define I4_PROP_SUPPORTED(itf, value)    \
    case itf:  \
		var.vt			= VT_I4; \
		var.lVal	    = value; \
		fPropSupported	= TRUE;	\
		break;

// Viaduct 1
#define Data1_IUnknown                     0x00000000
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_INotifyDBEvents              0xdb526cc0
#define Data1_IRowset					   0x0c733a7c
#define Data1_IRowsetLocate 	           0x0c733a7d
#define Data1_IRowsetScroll 	           0x0c733a7e
#define Data1_IAccessor	   				   0x0c733a8c
#define Data1_IColumnsInfo  	           0x0c733a11
#define Data1_IRowsetInfo   	           0x0c733a55
#define Data1_IRowsetChange 	           0x0c733a05
#define Data1_IRowsetUpdate 	           0x0c733a6d
//#define Data1_IRowsetNewRow 	           
#define Data1_IRowsetIdentity			   0x0c733a09
//#define Data1_IRowsetDelete
#define Data1_IRowsetFind   	           0x0c733a0d
#define Data1_IRowsetAsynch 	           0x0c733a0f
#define Data1_ISupportErrorInfo	           0xdf0b3d60
#define Data1_IRowPosition				   0x0c733a94

// Viaduct 2
#define Data1_IStream	                   0x00000030
#define Data1_IStreamEx	                   0xf74e27fc
#define Data1_ICursor                      0x9f6aa700
#define Data1_ICursorMove                  0xacff0690
#define Data1_ICursorScroll                0xbb87e420
#define Data1_ICursorUpdateARow            0xd14216a0
#define Data1_ICursorFind                  0xe01d7850
#define Data1_IEntryID                     0xe4d19810
#define Data1_IRowPositionChange		   0x0997a571

#endif //__FASTGUID__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\errorinf.h ===
//---------------------------------------------------------------------------
// ErrorInf.h  
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __VDSETERRORINFO__
#define __VDSETERRORINFO__

//=--------------------------------------------------------------------------=
// CVDResourceDLL
//=--------------------------------------------------------------------------=
// Keeps track of the resource DLL for error strings
//
class CVDResourceDLL
{
public:
	CVDResourceDLL(LCID lcid);
	virtual ~CVDResourceDLL();

    int LoadString(UINT uID,			// resource identifier 
					LPTSTR lpBuffer,	// address of buffer for resource 
					int nBufferMax);	// size of buffer 

protected:
	LCID		m_lcid;					// passed in to the constructor
	HINSTANCE	m_hinstance;
};

//=--------------------------------------------------------------------------=
// VDSetErrorInfo
//=--------------------------------------------------------------------------=
// Sets rich error info.
//
// Parameters:
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
void VDSetErrorInfo(UINT nErrStringResID,
				    REFIID riid,
					CVDResourceDLL * pResDLL);

//=--------------------------------------------------------------------------=
// VDCheckErrorInfo
//=--------------------------------------------------------------------------=
// Checks if rich error info is already available, otherwise it supplies it  
//
// Parameters:
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
void VDCheckErrorInfo(UINT nErrStringResID,
						REFIID riid,
						LPUNKNOWN punkSource,
   						REFIID riidSource,
						CVDResourceDLL * pResDLL);

//=--------------------------------------------------------------------------=
// VDGetErrorInfo
//=--------------------------------------------------------------------------=
// if available, gets rich error info from supplied interface
//
// Parameters:
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//    pbstrErrorDesc    - [out] a pointer to memory in which to return
//                              error description BSTR.
//
// Note - this function is no longer used, however it might be useful in
//        the future so it was not permanently removed.
//
//* HRESULT VDGetErrorInfo(LPUNKNOWN punkSource,
//* 				           REFIID riidSource,
//*                            BSTR * pbstrErrorDesc);

//=--------------------------------------------------------------------------=
// VDMapCursorHRtoRowsetHR
//=--------------------------------------------------------------------------=
// Translates an ICursor HRESULT to an IRowset HRESULT
//
// Parameters:
//    nErrStringResID	- [in]  ICursor HRESULT
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
// Output:
//    HRESULT - Translated IRowset HRESULT
//

HRESULT VDMapCursorHRtoRowsetHR(HRESULT hr,
							 UINT nErrStringResIDFailed,
							 REFIID riid,
							 LPUNKNOWN punkSource,
   							 REFIID riidSource,
							 CVDResourceDLL * pResDLL);

//=--------------------------------------------------------------------------=
// VDMapRowsetHRtoCursorHR
//=--------------------------------------------------------------------------=
// Translates an IRowset HRESULT to an ICursor HRESULT
//
// Parameters:
//    hr	            - [in]  IRowset HRESULT
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to IRowsetFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
// Output:
//    HRESULT - Translated ICursor HRESULT
//

HRESULT VDMapRowsetHRtoCursorHR(HRESULT hr,
							 UINT nErrStringResIDFailed,
							 REFIID riid,
							 LPUNKNOWN punkSource,
   							 REFIID riidSource,
							 CVDResourceDLL * pResDLL);

/////////////////////////////////////////////////////////////////////////////
#endif //__VDSETERRORINFO__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\guids.cpp ===
//---------------------------------------------------------------------------
// Guids.cpp : Contains guids we will define ourselves
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#define INITGUID                   // define all the guids.
#define DBINITCONSTANTS
#define CURSOR_DBINITCONSTANTS

#include "stdafx.h"

#include "olectl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\globals.h ===
//=--------------------------------------------------------------------------=
// Globals.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains externs and stuff for Global variables, etc ..
//
#ifndef _GLOBALS_H_

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
extern HANDLE    g_hHeap;
extern LPMALLOC  g_pMalloc;
extern HINSTANCE g_hinstance;
extern ULONG     g_cLockCount;
extern ULONG     g_cObjectCount;

extern CRITICAL_SECTION g_CriticalSection;

//=--------------------------------------------------------------------------=
// frequently used large integers
//
extern LARGE_INTEGER g_liMinus;     // minus one
extern LARGE_INTEGER g_liZero;      // - zero -
extern LARGE_INTEGER g_liPlus;      // plus one

#ifdef _DEBUG
void DumpObjectCounters();
#endif // _DEBUG

//=--------------------------------------------------------------------------=
// VDInitGlobals
//=--------------------------------------------------------------------------=
// Initialize global variables
//
// Parameters:
//    hinstResource	- [in]  The instance handle that contains resource strings
//
// Output:
//    TRUE if successful otherwise FALSE
//
BOOL VDInitGlobals(HINSTANCE hinstance);

//=--------------------------------------------------------------------------=
// VDReleaseGlobals
//=--------------------------------------------------------------------------=
void VDReleaseGlobals();

void VDUpdateObjectCount(int cChange);

#define _GLOBALS_H_
#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\fromvar.h ===
//---------------------------------------------------------------------------
// FromVar.h : GetDataFromDBVariant header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __VDFROMVAR__
#define __VDFROMVAR__

HRESULT GetDataFromDBVariant(CURSOR_DBVARIANT * pVar,
							 DBTYPE * pwType, 
							 BYTE ** ppData, 
							 BOOL * pfMemAllocated);


#endif //__VDFROMVAR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\ipserver.h ===
//=--------------------------------------------------------------------------=
// InProcServer.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global header file that contains all the windows stuff, etc ...  should
// be pre-compiled to speed things up a little bit.
//
#ifndef _INPROCSERVER_H_

#define INC_OLE2
#include <windows.h>
#include <stddef.h>                    // for offsetof()
#include <olectl.h>




// things that -everybody- wants [read: is going to get]
//
#include "Debug.H"

//=--------------------------------------------------------------------------=
// we don't want to use the CRTs, and would like some memory tracking in the
// debug case, so we'll override these guys
//=--------------------------------------------------------------------------=
//
void * _cdecl operator new(size_t size);
void  _cdecl operator delete(void *ptr);


//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp
#define CLEARERRORINFORET(hr) { SetErrorInfo(0, NULL); return hr; }
#define CLEARERRORINFORET_ON_FAILURE(hr) if (FAILED(hr)) { SetErrorInfo(0, NULL); return hr; }

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp

// conversions
//
#define BOOL_TO_VARIANTBOOL(f) (f) ? VARIANT_TRUE : VARIANT_FALSE

// for optimizing QI's
//
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

// Reference counting help.
//
#define RELEASE_OBJECT(ptr)    if (ptr) { IUnknown *pUnk = (ptr); (ptr) = NULL; pUnk->Release(); }
#define ADDREF_OBJECT(ptr)     if (ptr) (ptr)->AddRef()


#define _INPROCSERVER_H_
#endif // _INPROCSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\msdadc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 17:20:43 1997
 */
/* Compiler settings for msdadc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msdadc_h__
#define __msdadc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDataConvert_FWD_DEFINED__
#define __IDataConvert_FWD_DEFINED__
typedef interface IDataConvert IDataConvert;
#endif 	/* __IDataConvert_FWD_DEFINED__ */


#ifndef __IRowPosition_FWD_DEFINED__
#define __IRowPosition_FWD_DEFINED__
typedef interface IRowPosition IRowPosition;
#endif 	/* __IRowPosition_FWD_DEFINED__ */


#ifndef __IRowPositionChange_FWD_DEFINED__
#define __IRowPositionChange_FWD_DEFINED__
typedef interface IRowPositionChange IRowPositionChange;
#endif 	/* __IRowPositionChange_FWD_DEFINED__ */


#ifndef __DataConvert_FWD_DEFINED__
#define __DataConvert_FWD_DEFINED__

#ifdef __cplusplus
typedef class DataConvert DataConvert;
#else
typedef struct DataConvert DataConvert;
#endif /* __cplusplus */

#endif 	/* __DataConvert_FWD_DEFINED__ */


#ifndef __RowPosition_FWD_DEFINED__
#define __RowPosition_FWD_DEFINED__

#ifdef __cplusplus
typedef class RowPosition RowPosition;
#else
typedef struct RowPosition RowPosition;
#endif /* __cplusplus */

#endif 	/* __RowPosition_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IDataConvert_INTERFACE_DEFINED__
#define __IDataConvert_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataConvert
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 


typedef DWORD DBDATACONVERT;


enum DBDATACONVERTENUM
    {	DBDATACONVERT_DEFAULT	= 0,
	DBDATACONVERT_SETDATABEHAVIOR	= 0x1,
	DBDATACONVERT_LENGTHFROMNTS	= 0x2
    };

EXTERN_C const IID IID_IDataConvert;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a8d-2a1c-11ce-ade5-00aa0044773d")
    IDataConvert : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DataConvert( 
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType,
            /* [in] */ ULONG cbSrcLength,
            /* [out][in] */ ULONG __RPC_FAR *pcbDstLength,
            /* [in] */ void __RPC_FAR *pSrc,
            /* [out] */ void __RPC_FAR *pDst,
            /* [in] */ ULONG cbDstMaxLength,
            /* [in] */ DBSTATUS dbsSrcStatus,
            /* [out] */ DBSTATUS __RPC_FAR *pdbsStatus,
            /* [in] */ BYTE bPrecision,
            /* [in] */ BYTE bScale,
            /* [in] */ DBDATACONVERT dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanConvert( 
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetConversionSize( 
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType,
            /* [in] */ ULONG __RPC_FAR *pcbSrcLength,
            /* [out] */ ULONG __RPC_FAR *pcbDstLength,
            /* [size_is][in] */ void __RPC_FAR *pSrc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataConvertVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDataConvert __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDataConvert __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDataConvert __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DataConvert )( 
            IDataConvert __RPC_FAR * This,
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType,
            /* [in] */ ULONG cbSrcLength,
            /* [out][in] */ ULONG __RPC_FAR *pcbDstLength,
            /* [in] */ void __RPC_FAR *pSrc,
            /* [out] */ void __RPC_FAR *pDst,
            /* [in] */ ULONG cbDstMaxLength,
            /* [in] */ DBSTATUS dbsSrcStatus,
            /* [out] */ DBSTATUS __RPC_FAR *pdbsStatus,
            /* [in] */ BYTE bPrecision,
            /* [in] */ BYTE bScale,
            /* [in] */ DBDATACONVERT dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanConvert )( 
            IDataConvert __RPC_FAR * This,
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionSize )( 
            IDataConvert __RPC_FAR * This,
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType,
            /* [in] */ ULONG __RPC_FAR *pcbSrcLength,
            /* [out] */ ULONG __RPC_FAR *pcbDstLength,
            /* [size_is][in] */ void __RPC_FAR *pSrc);
        
        END_INTERFACE
    } IDataConvertVtbl;

    interface IDataConvert
    {
        CONST_VTBL struct IDataConvertVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataConvert_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataConvert_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataConvert_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataConvert_DataConvert(This,wSrcType,wDstType,cbSrcLength,pcbDstLength,pSrc,pDst,cbDstMaxLength,dbsSrcStatus,pdbsStatus,bPrecision,bScale,dwFlags)	\
    (This)->lpVtbl -> DataConvert(This,wSrcType,wDstType,cbSrcLength,pcbDstLength,pSrc,pDst,cbDstMaxLength,dbsSrcStatus,pdbsStatus,bPrecision,bScale,dwFlags)

#define IDataConvert_CanConvert(This,wSrcType,wDstType)	\
    (This)->lpVtbl -> CanConvert(This,wSrcType,wDstType)

#define IDataConvert_GetConversionSize(This,wSrcType,wDstType,pcbSrcLength,pcbDstLength,pSrc)	\
    (This)->lpVtbl -> GetConversionSize(This,wSrcType,wDstType,pcbSrcLength,pcbDstLength,pSrc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IDataConvert_DataConvert_Proxy( 
    IDataConvert __RPC_FAR * This,
    /* [in] */ DBTYPE wSrcType,
    /* [in] */ DBTYPE wDstType,
    /* [in] */ ULONG cbSrcLength,
    /* [out][in] */ ULONG __RPC_FAR *pcbDstLength,
    /* [in] */ void __RPC_FAR *pSrc,
    /* [out] */ void __RPC_FAR *pDst,
    /* [in] */ ULONG cbDstMaxLength,
    /* [in] */ DBSTATUS dbsSrcStatus,
    /* [out] */ DBSTATUS __RPC_FAR *pdbsStatus,
    /* [in] */ BYTE bPrecision,
    /* [in] */ BYTE bScale,
    /* [in] */ DBDATACONVERT dwFlags);


void __RPC_STUB IDataConvert_DataConvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDataConvert_CanConvert_Proxy( 
    IDataConvert __RPC_FAR * This,
    /* [in] */ DBTYPE wSrcType,
    /* [in] */ DBTYPE wDstType);


void __RPC_STUB IDataConvert_CanConvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDataConvert_GetConversionSize_Proxy( 
    IDataConvert __RPC_FAR * This,
    /* [in] */ DBTYPE wSrcType,
    /* [in] */ DBTYPE wDstType,
    /* [in] */ ULONG __RPC_FAR *pcbSrcLength,
    /* [out] */ ULONG __RPC_FAR *pcbDstLength,
    /* [size_is][in] */ void __RPC_FAR *pSrc);


void __RPC_STUB IDataConvert_GetConversionSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataConvert_INTERFACE_DEFINED__ */


#ifndef __IRowPosition_INTERFACE_DEFINED__
#define __IRowPosition_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPosition
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 


typedef DWORD DBPOSITIONFLAGS;


enum DBPOSITIONFLAGSENUM
    {	DBPOSITION_OK	= 0,
	DBPOSITION_NOROW	= DBPOSITION_OK + 1,
	DBPOSITION_BOF	= DBPOSITION_NOROW + 1,
	DBPOSITION_EOF	= DBPOSITION_BOF + 1
    };

EXTERN_C const IID IID_IRowPosition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a94-2a1c-11ce-ade5-00aa0044773d")
    IRowPosition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ClearRowPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowPosition( 
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowset( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown __RPC_FAR *pRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRowPosition( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPosition __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearRowPosition )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowset )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags);
        
        END_INTERFACE
    } IRowPositionVtbl;

    interface IRowPosition
    {
        CONST_VTBL struct IRowPositionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPosition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPosition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPosition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPosition_ClearRowPosition(This)	\
    (This)->lpVtbl -> ClearRowPosition(This)

#define IRowPosition_GetRowPosition(This,phChapter,phRow,pdwPositionFlags)	\
    (This)->lpVtbl -> GetRowPosition(This,phChapter,phRow,pdwPositionFlags)

#define IRowPosition_GetRowset(This,riid,ppRowset)	\
    (This)->lpVtbl -> GetRowset(This,riid,ppRowset)

#define IRowPosition_Initialize(This,pRowset)	\
    (This)->lpVtbl -> Initialize(This,pRowset)

#define IRowPosition_SetRowPosition(This,hChapter,hRow,dwPositionFlags)	\
    (This)->lpVtbl -> SetRowPosition(This,hChapter,hRow,dwPositionFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPosition_ClearRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This);


void __RPC_STUB IRowPosition_ClearRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [out] */ HCHAPTER __RPC_FAR *phChapter,
    /* [out] */ HROW __RPC_FAR *phRow,
    /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);


void __RPC_STUB IRowPosition_GetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowset_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);


void __RPC_STUB IRowPosition_GetRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_Initialize_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pRowset);


void __RPC_STUB IRowPosition_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_SetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow,
    /* [in] */ DBPOSITIONFLAGS dwPositionFlags);


void __RPC_STUB IRowPosition_SetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPosition_INTERFACE_DEFINED__ */


#ifndef __IRowPositionChange_INTERFACE_DEFINED__
#define __IRowPositionChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPositionChange
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



enum DBREASONPOSITIONENUM
    {	DBREASON_ROWPOSITION_CHANGED	= DBREASON_ROWSET_CHANGED + 1,
	DBREASON_ROWPOSITION_CHAPTERCHANGED	= DBREASON_ROWPOSITION_CHANGED + 1,
	DBREASON_ROWPOSITION_CLEARED	= DBREASON_ROWPOSITION_CHAPTERCHANGED + 1
    };

EXTERN_C const IID IID_IRowPositionChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0997a571-126e-11d0-9f8a-00a0c9a0631e")
    IRowPositionChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnRowPositionChange( 
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPositionChange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPositionChange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnRowPositionChange )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny);
        
        END_INTERFACE
    } IRowPositionChangeVtbl;

    interface IRowPositionChange
    {
        CONST_VTBL struct IRowPositionChangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPositionChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPositionChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPositionChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPositionChange_OnRowPositionChange(This,eReason,ePhase,fCantDeny)	\
    (This)->lpVtbl -> OnRowPositionChange(This,eReason,ePhase,fCantDeny)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPositionChange_OnRowPositionChange_Proxy( 
    IRowPositionChange __RPC_FAR * This,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny);


void __RPC_STUB IRowPositionChange_OnRowPositionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPositionChange_INTERFACE_DEFINED__ */



#ifndef __MSDAUTILLib_LIBRARY_DEFINED__
#define __MSDAUTILLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSDAUTILLib
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_MSDAUTILLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DataConvert;

class DECLSPEC_UUID("c8b522d1-5cf3-11ce-ade5-00aa0044773d")
DataConvert;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RowPosition;

class DECLSPEC_UUID("2048EEE6-7FA2-11D0-9E6A-00A0C9138C29")
RowPosition;

DEFINE_GUID(CLSID_RowPosition, 0x2048eee6, 0x7fa2, 0x11d0, 0x9e, 0x6a, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x29);
DEFINE_GUID(IID_IRowPosition,  0x0c733a94, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x0, 0xaa, 0x0, 0x44, 0x77, 0x3d);
DEFINE_GUID(IID_IRowPositionChange,  0x0997a571, 0x126e, 0x11d0, 0x9f, 0x8a, 0x0, 0xa0, 0xc9, 0xa0, 0x63, 0x1e);


#endif
#endif /* __MSDAUTILLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\msr2c.cpp ===
//---------------------------------------------------------------------------
// MSR2C.cpp : implements DllMain
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "MSR2C.h"
#include "CMSR2C.h"
#include "clssfcty.h"
#include <mbstring.h>

SZTHISFILE

// DllMain
//
BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvReserved)
{

	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			return VDInitGlobals(hinstDll);

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
			break;
		
		case DLL_PROCESS_DETACH:
			VDReleaseGlobals();
			break;
	}

	return TRUE;

}

////////////////////////////////////////////////////////////////////
// Name:	DllGetClassObject
// Desc:	provides an IClassFactory for a given CLSID that this DLL
//			is registered to support.  This DLL is placed under the
//			CLSID in the registration database as the InProcServer.
// Parms:	rclsid - identifies the class factory desired. since the
//			'this' parameter is passed, this DLL can handle any
//			number of objects simply by returning different class
//			factories here for different CLSIDs.
//			riid - ID specifying the interface the caller wants on
//			the class object, usually IID_ClassFactory.
//			ppv - pointer in which to return the interface pointer.
// Return:	HRESULT - NOERROR on success, otherwise an error code.
////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void ** ppv)
{
	HRESULT hr;
	CClassFactory *pObj;

	if (CLSID_CCursorFromRowset!=rclsid)
		return ResultFromScode(E_FAIL);

	pObj=new CClassFactory();

	if (NULL==pObj)
		return ResultFromScode(E_OUTOFMEMORY);

	hr=pObj->QueryInterface(riid, ppv);

	if (FAILED(hr))
		delete pObj;

	return hr;
}

////////////////////////////////////////////////////////////////////
// Name:	DllCanUnloadNow
// Desc:	lets the client know if this DLL can be freed, ie if
//			there are no references to anything this DLL provides.
// Parms:	none
// Return:	TRUE if nothing is using us, FALSE otherwise.
////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow(void)
{
	SCODE   sc;

	//Our answer is whether there are any object or locks
    EnterCriticalSection(&g_CriticalSection);

	sc=(0L==g_cObjectCount && 0L==g_cLockCount) ? S_OK : S_FALSE;

    LeaveCriticalSection(&g_CriticalSection);

	return ResultFromScode(sc);
}

////////////////////////////////////////////////////////////////////
// Name:	CSSCFcty
// Desc:	constructor
// Parms:	none
// Return:	none
////////////////////////////////////////////////////////////////////
CClassFactory::CClassFactory(void)
{
	m_cRef=0L;
	return;
}

////////////////////////////////////////////////////////////////////
// Name:	~CClassFactory
// Desc:	destructor
// Parms:	none
// Return:	none
////////////////////////////////////////////////////////////////////
CClassFactory::~CClassFactory(void)
{
	return;
}

////////////////////////////////////////////////////////////////////
// Name:	QueryInterface
// Desc:	queries the class factory for a method.
// Parms:	riid -
//			ppv -
// Return:	HRESULT - NOERROR if successful, otherwise an error code.
////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
	*ppv=NULL;

	if (IID_IUnknown==riid || IID_IClassFactory==riid)
		*ppv=this;

	if (NULL!=*ppv)
	{
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}

	return ResultFromScode(E_NOINTERFACE);
}

////////////////////////////////////////////////////////////////////
// Name:	AddRef
// Desc:	incrementes the class factory object reference count.
// Parms:	none
// Return:	current reference count.
////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
	return ++m_cRef;
}

////////////////////////////////////////////////////////////////////
// Name:	Release
// Desc:	decrement the reference count on the class factory.  If
//			the count has gone to 0, destroy the object.
// Parms:	none
// Return:	current reference count.
////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
	// if ref count can be decremented, return count
	if (0L!=--m_cRef)
		return m_cRef;

	// delete this object
	delete this;
	return 0L;
}

////////////////////////////////////////////////////////////////////
// Name:	CreateInstance
// Desc:	instantiates an CVDCursorFromRowset object, returning an interface
//			pointer.
// Parms:	riid -		ID identifying the interface the caller
//						desires	to have for the new object.
//			ppvObj -	pointer in which to store the desired
//						interface pointer for the new object.
// Return:	HRESULT -	NOERROR if successful, otherwise
//						E_NOINTERFACE if we cannot support the
//						requested interface.
////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
	return CVDCursorFromRowset::CreateInstance(pUnkOuter, riid, ppvObj);
}

////////////////////////////////////////////////////////////////////
// Name:	LockServer
// Desc:	increments or decrements the lock count of the DLL.  if
//			the lock count goes to zero, and there are no objects,
//			the DLL is allowed to unload.
// Parms:	fLock - boolean specifies whether to increment or
//					decrement the lock count.
// Return:	HRESULT: NOERROR always.
////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    EnterCriticalSection(&g_CriticalSection);

	if (fLock)
	{
		g_cLockCount++;
	}
	else
	{
		g_cLockCount--;
	}

    LeaveCriticalSection(&g_CriticalSection);

	return NOERROR;
}

////////////////////////////////////////////////////////////////////
// Name:	DllRegisterServer
// Desc:	instructs the server to create its own registry entries.
//			all entries are put in the HKEY_CLASSES_ROOT.
// Parms:	none
// Return:	HRESULT -	NOERROR if registration is successful, error
//						otherwise.
////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer(void)
{
	OLECHAR szID[128 * 2];
	TCHAR	szTID[128 * 2];
	TCHAR	szCLSID[128 * 2];
	TCHAR	szModule[512 * 2];

	// put the guid in the form of a string with class id prefix
	StringFromGUID2(CLSID_CCursorFromRowset, szID, 128 * 2);
	WideCharToMultiByte(CP_ACP, 0, szID, -1, szTID, 128 * 2, NULL, NULL);

	_mbscpy((TBYTE*)szCLSID, (TBYTE*)TEXT("CLSID\\"));
	_mbscat((TBYTE*)szCLSID, (TBYTE*)szTID);

	SetKeyAndValue(szCLSID, NULL, NULL, NULL);

	GetModuleFileName(g_hinstance, szModule, sizeof(szModule)/sizeof(TCHAR));

	SetKeyAndValue(szCLSID, TEXT("InprocServer32"), szModule, TEXT("Apartment"));

	return S_OK;
}

////////////////////////////////////////////////////////////////////
// Name:	DllUnregisterServer
// Desc:	instructs the server to remove its own registry entries.
// Parms:	none
// Return:	HRESULT: NOERROR if unregistration is successful, error
//			otherwise.
////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer(void)
{
	OLECHAR szID[128 * 2];
	TCHAR	szTID[128 * 2];
	TCHAR	szCLSID[128 * 2];
	TCHAR	szCLSIDInproc[128 * 2];

	// put the guid in the form of a string with class id prefix
	StringFromGUID2(CLSID_CCursorFromRowset, szID, 128 * 2);
	WideCharToMultiByte(CP_ACP, 0, szID, -1, szTID, 128 * 2, NULL, NULL);

	_mbscpy((TBYTE*)szCLSID, (TBYTE*)TEXT("CLSID\\"));
	_mbscat((TBYTE*)szCLSID, (TBYTE*)szTID);
    _mbscpy((TBYTE*)szCLSIDInproc, (TBYTE*)szCLSID);
	_mbscat((TBYTE*)szCLSIDInproc, (TBYTE*)TEXT("\\InprocServer32"));

	// delete the InprocServer32 key
	RegDeleteKey(HKEY_CLASSES_ROOT, szCLSIDInproc);

	// delete the class ID key
	RegDeleteKey(HKEY_CLASSES_ROOT, szCLSID);

	return S_OK;
}


////////////////////////////////////////////////////////////////////
// Name:	SetKeyAndValue
// Desc:	creates a registry key, sets a value, and closes the key.
// Parms:	pszKey -	pointer to a registry key.
//			pszSubkey -	pointer to a registry subkey.
//			pszValue -	pointer to value to enter for key-subkey
//			pszThreadingModel - pointer to threading model literal (optional) 		
// Return:	BOOL -		TRUE if successful, FALSE otherwise.
////////////////////////////////////////////////////////////////////
BOOL SetKeyAndValue(LPTSTR pszKey, LPTSTR pszSubkey, LPTSTR pszValue, LPTSTR pszThreadingModel)
{
	HKEY	hKey;
	TCHAR	szKey[256 * 2];

	_mbscpy((TBYTE*)szKey, (TBYTE*)pszKey);

	if (NULL!=pszSubkey)
	{
		_mbscat((TBYTE*)szKey, (TBYTE*)TEXT("\\"));
		_mbscat((TBYTE*)szKey, (TBYTE*)pszSubkey);
	}

	if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
											szKey,
											0,
											NULL,
											REG_OPTION_NON_VOLATILE,
											KEY_ALL_ACCESS,
											NULL,
											&hKey,
											NULL))
		return FALSE;

	if (NULL!=pszValue)
	{
		RegSetValueEx(	hKey,
						NULL,
						0,
						REG_SZ,
						(BYTE *)pszValue,
						_mbsnbcnt((TBYTE*)pszValue, (ULONG)-1) + 1);
	}

	if (NULL!=pszThreadingModel)
	{
		RegSetValueEx(	hKey,
						TEXT("ThreadingModel"),
						0,
						REG_SZ,
						(BYTE *)pszThreadingModel,
						_mbsnbcnt((TBYTE*)pszThreadingModel, (ULONG)-1) + 1);
	}

	RegCloseKey(hKey);

	return TRUE;
}

//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to take in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
//extern "C" int __cdecl _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
  FAIL("Pure virtual function called.");
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\fromvar.cpp ===
//---------------------------------------------------------------------------
// FromVar.cpp : GetDataFromDBVariant implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "timeconv.h"
#include "fromvar.h"
#include <math.h>
#include <limits.h>

SZTHISFILE


//=--------------------------------------------------------------------------=
// CoerceToDBVariant
//=--------------------------------------------------------------------------=
// Coerce a CURSOR_DBVARIANT to data suitable for IRowsetFind::GetRowsByValues
//
// Parameters:
//	  pVar 		        - [in]  a pointer to the variant containing the data
//	  pwType			- [out] a pointer to memory in which to return the DBTYPE
//								of the data
//    ppValue			- [out] a pointer to memory in which to return a pointer
//								to the date
//	  pfMemAllocated	- [out] a pointer to memory in which to return whether
//								new memory was allocated for the data. This is 
//								assumed to be initialzed to false by caller
//
// Output:
//    HRESULT - S_OK if successful
//
HRESULT GetDataFromDBVariant(CURSOR_DBVARIANT * pVar,
							 DBTYPE * pwType, 
							 BYTE ** ppData, 
							 BOOL * pfMemAllocated)
{
	ASSERT_POINTER(pVar, CURSOR_DBVARIANT)
	ASSERT_POINTER(pwType, DBTYPE)
	ASSERT_POINTER(ppData, BYTE*)
	ASSERT_POINTER(pfMemAllocated, BOOL)

    if (!pVar || !pwType || !ppData || !pfMemAllocated)
        return E_INVALIDARG;

	VARTYPE vt		= pVar->vt;
	BOOL fByRef		= FALSE;
	BOOL fArray		= FALSE;
	BOOL fVector	= FALSE;

	*pwType			= 0;

	if (vt & VT_VECTOR)
	{
		vt ^= VT_VECTOR;
		*pwType		= DBTYPE_VECTOR;
		if (vt & VT_BYREF)
		{
			*pwType	 |= DBTYPE_BYREF;
			vt ^= VT_BYREF;
		}
		fVector		= TRUE;
	}
	else
	if (vt & VT_ARRAY)
	{
		vt ^= VT_ARRAY;
		fArray		= TRUE;
		*pwType		= DBTYPE_ARRAY;
	}
	else
	if (vt & VT_BYREF)
	{
		vt ^= VT_BYREF;
		fByRef		= TRUE;
		*pwType		= DBTYPE_BYREF;
	}

	*ppData		= (BYTE*)&pVar->iVal;

	HRESULT hr = S_OK;

    switch (vt)
	{
		case CURSOR_DBTYPE_EMPTY:
			*pwType		= DBTYPE_EMPTY;
			break;

		case CURSOR_DBTYPE_NULL:
			*pwType		= DBTYPE_NULL;
			break;

		case CURSOR_DBTYPE_I2:
			*pwType		|= DBTYPE_I2;
			break;

		case CURSOR_DBTYPE_I4:
			*pwType		|= DBTYPE_I4;
			break;

		case CURSOR_DBTYPE_I8:
			*pwType		|= DBTYPE_I8;
			break;

		case CURSOR_DBTYPE_R4:
			*pwType		|= DBTYPE_R4;
			break;

		case CURSOR_DBTYPE_R8:
			*pwType		|= DBTYPE_R8;
			break;

		case CURSOR_DBTYPE_CY:
			*pwType		|= DBTYPE_CY;
			break;

		case CURSOR_DBTYPE_DATE:
			*pwType		|= DBTYPE_DATE;
			break;

		case CURSOR_DBTYPE_BOOL:
			*pwType		|= DBTYPE_BOOL;
			break;

		case CURSOR_DBTYPE_HRESULT:
			*pwType		|= DBTYPE_ERROR;
			break;

		case CURSOR_DBTYPE_LPSTR:
			*pwType		|= DBTYPE_STR;
			if (!fByRef && !fArray && !fVector)
				*ppData		= (BYTE*)pVar->pszVal;
			break;

		case CURSOR_DBTYPE_LPWSTR:
			*pwType		|= DBTYPE_WSTR;
			if (!fByRef && !fArray && !fVector)
				*ppData		= (BYTE*)pVar->pwszVal;
			break;

		case VT_BSTR:
			*pwType		|= DBTYPE_WSTR;
			if (!fByRef && !fArray && !fVector)
				*ppData		= (BYTE*)pVar->bstrVal;
			break;

		case CURSOR_DBTYPE_UUID:
			*pwType		|= DBTYPE_GUID;
			break;

		case CURSOR_DBTYPE_UI2:
			*pwType		|= DBTYPE_UI2;
			break;

		case CURSOR_DBTYPE_UI4:
			*pwType		|= DBTYPE_UI4;
			break;

		case CURSOR_DBTYPE_UI8:
			*pwType		|= DBTYPE_UI8;
			break;

		case CURSOR_DBTYPE_ANYVARIANT:
			*pwType		|= DBTYPE_VARIANT;
			break;

		case CURSOR_DBTYPE_BYTES:
		case CURSOR_DBTYPE_CHARS:
		case CURSOR_DBTYPE_BLOB:
			*pwType		|= DBTYPE_BYTES;
			break;

		case CURSOR_DBTYPE_WCHARS:
			*pwType		|= DBTYPE_UI2;
			break;

		case CURSOR_DBTYPE_FILETIME:

		{
			FILETIME *pFileTime = NULL;
			if (fVector)
			{
				DBVECTOR * pvector = (DBVECTOR*)pVar->byref;
				if (pvector)
					pFileTime = (FILETIME*)pvector->ptr;
			}
			else
			if (fByRef)
			{
				pFileTime = (FILETIME*)pVar->byref;
			}
			else
			if (!fArray)
			{
				pFileTime = (FILETIME*)&pVar->cyVal;
			}
			if (pFileTime)
			{
				DBTIMESTAMP * pstamp = (DBTIMESTAMP*)g_pMalloc->Alloc(sizeof(DBTIMESTAMP));
				if (pstamp)
				{
					if (VDConvertToDBTimeStamp(pFileTime, pstamp))
					{
						*ppData				= (BYTE*)pstamp;
						*pwType				|= DBTYPE_DBTIMESTAMP;
						*pfMemAllocated		= TRUE;
					}
					else
					{
						g_pMalloc->Free(pstamp);
						hr = CURSOR_DB_CANTCOERCE;
					}
				}
				else
					hr = E_OUTOFMEMORY;
			}
			else
				hr = CURSOR_DB_CANTCOERCE;
			break;
		}

		case CURSOR_DBTYPE_DBEXPR:
		case CURSOR_DBTYPE_COLUMNID:
		default:
			hr = CURSOR_DB_CANTCOERCE;
			break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\globals.cpp ===
//---------------------------------------------------------------------------
// Globals.cpp : Global information 
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"

SZTHISFILE

// our global memory allocator and global memory pool
//
HANDLE    g_hHeap;
LPMALLOC  g_pMalloc;
HINSTANCE g_hinstance;

//Count number of objects and number of locks.
ULONG     g_cLockCount=0;
ULONG     g_cObjectCount=0;

CRITICAL_SECTION    g_CriticalSection;

// frequently used large integers
//
LARGE_INTEGER g_liMinus = {(ULONG)-1, -1};  // minus one
LARGE_INTEGER g_liZero = {0, 0};            // - zero -
LARGE_INTEGER g_liPlus = {0, 1};            // plus one
//=--------------------------------------------------------------------------=
// VDInitGlobals
//=--------------------------------------------------------------------------=
// Initialize global variables
//
// Parameters:
//    hinstResource	- [in]  The instance handle that contains resource strings
//
// Output:
//    TRUE if successful otherwise FALSE
//
BOOL VDInitGlobals(HINSTANCE hinstance)
{
	g_pMalloc = NULL;
	g_hinstance = hinstance;
	g_hHeap = GetProcessHeap();
	if (!g_hHeap) 
	{
		FAIL("Couldn't get Process Heap.");
		return FALSE;
	}

	InitializeCriticalSection(&g_CriticalSection);

	return TRUE;
}

//=--------------------------------------------------------------------------=
// VDReleaseGlobals
//=--------------------------------------------------------------------------=
//
void VDReleaseGlobals()
{
	if (g_pMalloc)
	{
		g_pMalloc->Release();
		g_pMalloc = NULL;
	}
      
    #ifdef _DEBUG
	     DumpObjectCounters();    
    #endif // _DEBUG

	DeleteCriticalSection(&g_CriticalSection);

}

//=--------------------------------------------------------------------------=
// VDUpdateObjectCount increments/decrements global object count
//=--------------------------------------------------------------------------=
//
void VDUpdateObjectCount(int cChange)
{

    EnterCriticalSection(&g_CriticalSection);

	g_cObjectCount += cChange;

	// get global malloc pointer object count greater than zero
	if (!g_pMalloc && g_cObjectCount > 0)
	{
		CoGetMalloc(MEMCTX_TASK, &g_pMalloc);
	}
	else
	// release hold	on global malloc pointer when no more objects
	if (0 == g_cObjectCount && g_pMalloc)
	{
		g_pMalloc->Release();
		g_pMalloc = NULL;
	}

    LeaveCriticalSection(&g_CriticalSection);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\nconnpt.h ===
//---------------------------------------------------------------------------
// NotifyConnPt.h : CVDNotifyDBEventsConnPt header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __CVDNOTIFYDBEVENTSCONNPT__
#define __CVDNOTIFYDBEVENTSCONNPT__

class CVDNotifyDBEventsConnPt : public IConnectionPoint
{
protected:
// Construction/Destruction
	CVDNotifyDBEventsConnPt();
	~CVDNotifyDBEventsConnPt();

public:
    static HRESULT Create(IConnectionPointContainer * pConnPtContainer, CVDNotifyDBEventsConnPt ** ppNotifyDBEventsConnPt);

public:
// Access functions
    UINT GetConnectionsActive() const {return m_uiConnectionsActive;}
    INotifyDBEvents ** GetNotifyDBEventsTable() const {return m_ppNotifyDBEvents;}

protected:
// Data members
	DWORD			            m_dwRefCount;
	UINT			            m_uiConnectionsAllocated;
	UINT			            m_uiConnectionsActive;
	INotifyDBEvents **	        m_ppNotifyDBEvents; // pointer to an array of INotifyDBEvents ptrs
	IConnectionPointContainer * m_pConnPtContainer;

public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.
    //
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
	// IConnectionPoint methods
    //
	STDMETHOD(GetConnectionInterface)(THIS_ IID FAR* pIID);
	STDMETHOD(GetConnectionPointContainer)(THIS_
		IConnectionPointContainer FAR* FAR* ppCPC);
	STDMETHOD(Advise)(THIS_ LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie);
	STDMETHOD(Unadvise)(THIS_ DWORD dwCookie);
	STDMETHOD(EnumConnections)(THIS_ LPENUMCONNECTIONS FAR* ppEnum);

};
/////////////////////////////////////////////////////////////////////////////
#endif //__CVDNOTIFYDBEVENTSCONNPT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\nconnptc.h ===
//---------------------------------------------------------------------------
// NotifyConnPtCn.h : CVDNotifyDBEventsConnPtCont header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __CVDNOTIFYDBEVENTSCONNPTCONT__
#define __CVDNOTIFYDBEVENTSCONNPTCONT__

class CVDNotifier;            // forward references
class CVDNotifyDBEventsConnPt;

class CVDNotifyDBEventsConnPtCont : public IConnectionPointContainer
{
protected:
// Construction/Destruction
	CVDNotifyDBEventsConnPtCont();
	~CVDNotifyDBEventsConnPtCont();

public:    
    static HRESULT Create(CVDNotifier * pNotifier, CVDNotifyDBEventsConnPtCont ** ppConnPtContainer);
    void Destroy();

public:
// Access functions
    CVDNotifyDBEventsConnPt * GetNotifyDBEventsConnPt() const {return m_pNotifyDBEventsConnPt;}

protected:
// Data members
	CVDNotifier *				m_pNotifier;
	CVDNotifyDBEventsConnPt *	m_pNotifyDBEventsConnPt;  // there is only one connection point
														  // namely INotifyDBEvents
public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.
    //
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
	// IConnectionPointContainer methods
    //
	STDMETHOD(EnumConnectionPoints)(THIS_ LPENUMCONNECTIONPOINTS FAR* ppEnum);
	STDMETHOD(FindConnectionPoint)(THIS_ REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

};
/////////////////////////////////////////////////////////////////////////////
#endif //__CVDNOTIFYDBEVENTSCONNPTCONT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\nconnptc.cpp ===
//---------------------------------------------------------------------------
// NotifyConnPtCn.cpp : CVDNotifyDBEventsConnPtCont implementation file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "NConnPt.h"         
#include "NConnPtC.h"         
#include "enumcnpt.h"         
#include "Notifier.h"         
#include "RSSource.h"         

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// CVDNotifyDBEventsConnPtCont constructor
//
CVDNotifyDBEventsConnPtCont::CVDNotifyDBEventsConnPtCont()
{
	m_pNotifier = NULL;

#ifdef _DEBUG
    g_cVDNotifyDBEventsConnPtContCreated++;
#endif			
}

//=--------------------------------------------------------------------------=
// CVDNotifyDBEventsConnPtCont destructor
//
CVDNotifyDBEventsConnPtCont::~CVDNotifyDBEventsConnPtCont()
{
	RELEASE_OBJECT(m_pNotifyDBEventsConnPt)

#ifdef _DEBUG
    g_cVDNotifyDBEventsConnPtContDestroyed++;
#endif			
}

//=--------------------------------------------------------------------------=
// Create - Create connection point container object
//=--------------------------------------------------------------------------=
// This function creates a new connection point container object
//
// Parameters:
//    pConnPtContainer      - [in]  a pointer to rowset object
//    ppNotifyDBEventsConnPt  - [out] a pointer in which to return pointer to 
//                                  connection point container object
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDNotifyDBEventsConnPtCont::Create(CVDNotifier * pNotifier, CVDNotifyDBEventsConnPtCont ** ppConnPtContainer)
{
    *ppConnPtContainer = NULL;

    CVDNotifyDBEventsConnPtCont * pConnPtContainer = new CVDNotifyDBEventsConnPtCont();

    if (!pConnPtContainer)
        return E_OUTOFMEMORY;

    pConnPtContainer->m_pNotifier = pNotifier;

    CVDNotifyDBEventsConnPt::Create(pConnPtContainer, &pConnPtContainer->m_pNotifyDBEventsConnPt);

    if (!pConnPtContainer->m_pNotifyDBEventsConnPt)
    {
        delete pConnPtContainer;
        return E_OUTOFMEMORY;
    }

    *ppConnPtContainer = pConnPtContainer;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// Destroy - Destroy this connection point container object
//
void CVDNotifyDBEventsConnPtCont::Destroy()
{
    delete this;
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface 
//
HRESULT CVDNotifyDBEventsConnPtCont::QueryInterface(REFIID riid, void **ppvObjOut)
{

	return ((CVDNotifier*)m_pNotifier)->QueryInterface(riid, ppvObjOut); // logically part of CVDNotifier derived object;

}

//=--------------------------------------------------------------------------=
// IUnknown AddRef
//
ULONG CVDNotifyDBEventsConnPtCont::AddRef(void)
{
	return ((CVDNotifier*)m_pNotifier)->AddRef(); // logically part of CVDNotifier derived object
}

//=--------------------------------------------------------------------------=
// IUnknown Release
//
ULONG CVDNotifyDBEventsConnPtCont::Release(void)
{
	return ((CVDNotifier*)m_pNotifier)->Release(); // logically part of CVDNotifier derived object
}

//=--------------------------------------------------------------------------=
// IConnectionPointContainer Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IConnectionPointContainer EnumConnectionPoints
//
HRESULT CVDNotifyDBEventsConnPtCont::EnumConnectionPoints(LPENUMCONNECTIONPOINTS FAR* ppEnum)
{
	ASSERT_POINTER(ppEnum, LPENUMCONNECTIONPOINTS)

	CVDEnumConnPoints* pEnum = NULL;

	if (m_pNotifyDBEventsConnPt)
	{
		pEnum = new CVDEnumConnPoints(m_pNotifyDBEventsConnPt);
		if (!pEnum)
		{
			*ppEnum = NULL;
			return E_OUTOFMEMORY;
		}
	}

	*ppEnum = pEnum;

	return (pEnum != NULL) ? S_OK : CONNECT_E_NOCONNECTION;
}

//=--------------------------------------------------------------------------=
// IConnectionPointContainer FindConnectionPoint
//
HRESULT CVDNotifyDBEventsConnPtCont::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT FAR* ppCP)
{
	ASSERT_POINTER(ppCP, LPCONNECTIONPOINT)

	if (m_pNotifyDBEventsConnPt)
		{
		// there is only one connection point supported - IID_INotifyDBEvents
		if (DO_GUIDS_MATCH(iid, IID_INotifyDBEvents))
			{
			m_pNotifyDBEventsConnPt->AddRef();
			*ppCP = m_pNotifyDBEventsConnPt;
			return S_OK;
			}
		}

	return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\notifier.cpp ===
//---------------------------------------------------------------------------
// Notifier.cpp : Notifier implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"

SZTHISFILE

#include "array_p.inl"

//=--------------------------------------------------------------------------=
// CVDNotifier - Constructor
//
CVDNotifier::CVDNotifier()
{
    m_dwRefCount    = 1;
    m_pParent       = NULL;

#ifdef _DEBUG
    g_cVDNotifierCreated++;
#endif
}

//=--------------------------------------------------------------------------=
// ~CVDNotifier - Destructor
//
CVDNotifier::~CVDNotifier()
{
#ifdef _DEBUG
    g_cVDNotifierDestroyed++;
#endif
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface 	 - stub implemntation - does nothing
//
HRESULT CVDNotifier::QueryInterface(REFIID riid, void **ppvObjOut)
{
	return E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// AddRef
//
ULONG CVDNotifier::AddRef(void)
{
   return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// Release
//
ULONG CVDNotifier::Release(void)
{
    if (1 > --m_dwRefCount)
    {
        delete this;
        return 0;
    }

    return m_dwRefCount;
}

/////////////////////////////////////////////////////////////////////
// family maintenance
/////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Member:		Join Family (public)
//
// Synopsis:	add myself to the family of the given parent
//
// Arguments:	pParent		[in] parent of family I should join
//
// Returns:		S_OK		it worked
//				other		it didn't

HRESULT
CVDNotifier::JoinFamily(CVDNotifier* pParent)
{
	ASSERT_POINTER(pParent, CVDNotifier);
	m_pParent = pParent;
	return m_pParent->AddChild(this);
}


//+-------------------------------------------------------------------------
// Member:		Leave Family (public)
//
// Synopsis:	remove myself from my parent's family
//
// Arguments:	none
//
// Returns:		S_OK		it worked
//				other		it didn't

HRESULT
CVDNotifier::LeaveFamily()
{
	if (m_pParent)
		return m_pParent->DeleteChild(this);
	return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Add Child (public)
//
// Synopsis:	add a notifier to my child list
//
// Arguments:	pChild	[in] notifier to add as a child
//
// Returns:		S_OK		it worked
//				other		error while appending to dynamic array

HRESULT
CVDNotifier::AddChild(CVDNotifier *pChild)
{
	return m_Children.Add(pChild);
}


//+-------------------------------------------------------------------------
// Member:		Delete Child (public)
//
// Synopsis:	delete a notifier from my child list.  When the last
//				notifier is deleted, delete myself from my parent's
//				child list.
//
// Arguments:	pChild		[in] notifier to delete
//
// Returns:		S_OK		it worked
//				E_FAIL		error while deleting from dynamic array
//				other		error while deleting from parent's child list

HRESULT
CVDNotifier::DeleteChild(CVDNotifier *pChild)
{

	int k;

	for (k=0; k<m_Children.GetSize(); k++)
	{
		if (((CVDNotifier*)m_Children[k]) == pChild)
		{
			m_Children.RemoveAt(k);
			return S_OK;
		}
	}

	return E_FAIL;
}



/////////////////////////////////////////////////////////////////////
// notification
/////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Member:		Notify Before (public)
//
// Synopsis:	send OKToDo, SyncBefore, and AboutToDo notifications
//				before doing an event.  Send FailedToDo notification
//				if anything goes wrong during the process.
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK			everything is OK so far
//				other			some client indicated failure

HRESULT
CVDNotifier::NotifyBefore(DWORD dwEventWhat, ULONG cReasons,
						 	 CURSOR_DBNOTIFYREASON rgReasons[])
{
	HRESULT hr;

	// phase 1:  send OKToDo, and Cancelled if anyone objects
	hr = NotifyOKToDo(dwEventWhat, cReasons, rgReasons);
	if (hr)
		return hr;

	// phase 2:  send SyncBefore, and send FailedToDo if anything goes wrong
	hr = NotifySyncBefore(dwEventWhat, cReasons, rgReasons);
	if (hr) {
		NotifyFail(dwEventWhat, cReasons, rgReasons);
		return hr;
	}

	// phase 3:  send AboutToDo, and send FailedToDo if anything goes wrong
	hr = NotifyAboutToDo(dwEventWhat, cReasons, rgReasons);
	if (hr) {
		NotifyFail(dwEventWhat, cReasons, rgReasons);
		return hr;
	}
	
	return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify After (public)
//
// Synopsis:	send SyncAfter and DidEvent notifications after an event
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		it worked

HRESULT
CVDNotifier::NotifyAfter(DWORD dwEventWhat, ULONG cReasons,
						CURSOR_DBNOTIFYREASON rgReasons[])
{
	// phase 5: send SyncAfter.  Ignore errors - all clients need to hear this
	NotifySyncAfter(dwEventWhat, cReasons, rgReasons);

	// phase 6: send DidEvent.  Ignore errors - all clients need to hear this
	NotifyDidEvent(dwEventWhat, cReasons, rgReasons);

	return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify Fail (public)
//
// Synopsis:	send FailedToDo notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		it worked

HRESULT
CVDNotifier::NotifyFail(DWORD dwEventWhat, ULONG cReasons,
					   CURSOR_DBNOTIFYREASON rgReasons[])
{
	int k;

	// send FailedToDo to all clients, ignoring errors
	for (k=0; k<m_Children.GetSize(); k++) {
		((CVDNotifier*)m_Children[k])->NotifyFail(dwEventWhat, cReasons, rgReasons);
	}
	
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////
// helper functions
/////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Member:		Notify OK To Do (protected)
//
// Synopsis:	Send OKToDo notification.  If a client objects (by
//				returning a non-zero HR), send Cancelled to notified
//				clients to cancel the event.
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients agree it's OK to do the event
//				other		some client disagrees

HRESULT
CVDNotifier::NotifyOKToDo(DWORD dwEventWhat, ULONG cReasons,
						 CURSOR_DBNOTIFYREASON rgReasons[])
{
	HRESULT hr = S_OK;
	int j, k;

	// poll all clients, see if they think it's OKToDo the event
	for (k=0; k<m_Children.GetSize(); k++) {
		hr = ((CVDNotifier*)m_Children[k])->NotifyOKToDo(dwEventWhat, cReasons, rgReasons);
		if (hr) {			// somone objects, inform polled clients it's cancelled
			for (j=0; j<=k; j++) {
				((CVDNotifier*)m_Children[j])->NotifyCancel(dwEventWhat, cReasons, rgReasons);
			}
			break;
		}
	}

	return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify Sync Before (public)
//
// Synopsis:	Send SyncBefore notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients received notification
//				other		some client returned an error

HRESULT
CVDNotifier::NotifySyncBefore(DWORD dwEventWhat, ULONG cReasons,
							 CURSOR_DBNOTIFYREASON rgReasons[])
{
	HRESULT hr = S_OK;
	int k;

	for (k=0; k<m_Children.GetSize(); k++) {
		hr = ((CVDNotifier*)m_Children[k])->NotifySyncBefore(dwEventWhat, cReasons, rgReasons);
		if (hr)
			break;
	}
	return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify About To Do (protected)
//
// Synopsis:	Send AboutToDo notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified
//				other		some client returned an error

HRESULT
CVDNotifier::NotifyAboutToDo(DWORD dwEventWhat, ULONG cReasons,
							CURSOR_DBNOTIFYREASON rgReasons[])
{
	HRESULT hr = S_OK;
	int k;

	for (k=0; k<m_Children.GetSize(); k++) {
		hr = ((CVDNotifier*)m_Children[k])->NotifyAboutToDo(dwEventWhat, cReasons, rgReasons);
		if (hr)
			break;
	}
	return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify Sync After (protected)
//
// Synopsis:	Send SyncAfter notification.
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDNotifier::NotifySyncAfter(DWORD dwEventWhat, ULONG cReasons,
								CURSOR_DBNOTIFYREASON rgReasons[])
{
	int k;

	// send SyncAfter to all clients, ignoring errors
	for (k=0; k<m_Children.GetSize(); k++) {
		((CVDNotifier*)m_Children[k])->NotifySyncAfter(dwEventWhat, cReasons, rgReasons);
	}
	
	return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify Did Event (protected)
//
// Synopsis:	Send DidEvent notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDNotifier::NotifyDidEvent(DWORD dwEventWhat, ULONG cReasons,
							   CURSOR_DBNOTIFYREASON rgReasons[])
{
	int k;

	// send DidEvent to all clients, ignoring errors
	for (k=0; k<m_Children.GetSize(); k++) {
		((CVDNotifier*)m_Children[k])->NotifyDidEvent(dwEventWhat, cReasons, rgReasons);
	}
	
	return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify Cancel (protected)
//
// Synopsis:	Send Cancelled notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDNotifier::NotifyCancel(DWORD dwEventWhat, ULONG cReasons,
						 	 CURSOR_DBNOTIFYREASON rgReasons[])
{
	int k;

	// send Cancelled to all clients, ignoring errors
	for (k=0; k<m_Children.GetSize(); k++) {
		((CVDNotifier*)m_Children[k])->NotifyCancel(dwEventWhat, cReasons, rgReasons);
	}
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\notifier.h ===
//---------------------------------------------------------------------------
// Notifier.h : CVDNotifier header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDNOTIFIER__
#define __CVDNOTIFIER__


class CVDNotifier : public IUnknown
{
protected:
// Construction/Destruction
    CVDNotifier();
	virtual ~CVDNotifier();

protected:
// Data members
    DWORD           m_dwRefCount;   // reference count
    CVDNotifier *   m_pParent;      // pointer to CVDNotifier derived parent
    CPtrArray		m_Children;     // pointer array of CVDNotifier derived children

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods implemented
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);
	
	HRESULT			JoinFamily (CVDNotifier* pParent);
	HRESULT			LeaveFamily();

	CVDNotifier* GetParent () const { return m_pParent; }

	virtual HRESULT	NotifyBefore(DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifyAfter (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifyFail  (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);

protected:
	// helper functions
	HRESULT			AddChild   (CVDNotifier* pChild);
	HRESULT			DeleteChild(CVDNotifier* pChild);

	virtual HRESULT	NotifyOKToDo    (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifySyncBefore(DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifyAboutToDo (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifySyncAfter (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifyDidEvent  (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifyCancel    (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
};


#endif //__CVDNOTIFIER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\nconnpt.cpp ===
//---------------------------------------------------------------------------
// NotifyConnPt.cpp : CVDNotifyDBEventsConnPt implementation file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "NConnPt.h"         
#include <memory.h>

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// CVDNotifyDBEventsConnPt constructor
//
CVDNotifyDBEventsConnPt::CVDNotifyDBEventsConnPt()
{
	m_dwRefCount				= 1;
	m_uiConnectionsAllocated	= 0;
	m_uiConnectionsActive		= 0;
	m_pConnPtContainer			= NULL;
	m_ppNotifyDBEvents			= NULL;

#ifdef _DEBUG
    g_cVDNotifyDBEventsConnPtCreated++;
#endif			
}

//=--------------------------------------------------------------------------=
// CVDNotifyDBEventsConnPt destructor
//
CVDNotifyDBEventsConnPt::~CVDNotifyDBEventsConnPt()
{
	for (UINT i = 0; i < m_uiConnectionsActive; i++)
		RELEASE_OBJECT(m_ppNotifyDBEvents[i])

	delete [] m_ppNotifyDBEvents;   // free up table

#ifdef _DEBUG
    g_cVDNotifyDBEventsConnPtDestroyed++;
#endif			
}

//=--------------------------------------------------------------------------=
// Create - Create rowset notify connection point object
//=--------------------------------------------------------------------------=
// This function creates a new rowset notify connection point object
//
// Parameters:
//    pConnPtContainer      - [in]  a pointer to connection point container 
//                                  object
//    ppNotifyDBEventsConnPt  - [out] a pointer in which to return pointer to 
//                                  connection point object
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDNotifyDBEventsConnPt::Create(IConnectionPointContainer * pConnPtContainer, CVDNotifyDBEventsConnPt ** ppNotifyDBEventsConnPt)
{
    *ppNotifyDBEventsConnPt = NULL;

    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = new CVDNotifyDBEventsConnPt();

    if (!pNotifyDBEventsConnPt)
        return E_OUTOFMEMORY;

    pNotifyDBEventsConnPt->m_pConnPtContainer = pConnPtContainer;

    *ppNotifyDBEventsConnPt = pNotifyDBEventsConnPt;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface 
//
HRESULT CVDNotifyDBEventsConnPt::QueryInterface(REFIID riid, void **ppvObjOut)
{
	ASSERT_POINTER(ppvObjOut, IUnknown*)

	*ppvObjOut = NULL;

	if (DO_GUIDS_MATCH(riid, IID_IUnknown) ||
		DO_GUIDS_MATCH(riid, IID_IConnectionPoint) )
		{
		*ppvObjOut = this;
		AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// IUnknown AddRef
//
ULONG CVDNotifyDBEventsConnPt::AddRef(void)
{
	return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IUnknown Release
//
ULONG CVDNotifyDBEventsConnPt::Release(void)
{
	
	if (1 > --m_dwRefCount)
		{
		delete this;
		return 0;
		}

	return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IConnectionPoint Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IConnectionPoint GetConnectionInterface
//
HRESULT CVDNotifyDBEventsConnPt::GetConnectionInterface(IID FAR* pIID)
{
	ASSERT_POINTER(pIID, IID)
	*pIID = IID_INotifyDBEvents;
	return S_OK;
}

//=--------------------------------------------------------------------------=
// IConnectionPoint GetConnectionPointContainer
//
HRESULT CVDNotifyDBEventsConnPt::GetConnectionPointContainer(IConnectionPointContainer FAR* FAR* ppCPC)
{
	ASSERT_POINTER(ppCPC, IConnectionPointContainer*)

	if ((*ppCPC = m_pConnPtContainer) != NULL)
		return S_OK;

	return E_FAIL;
}

//=--------------------------------------------------------------------------=
// IConnectionPoint Advise
//
#define VD_ADVISE_TABLE_GROWBY  10

HRESULT CVDNotifyDBEventsConnPt::Advise(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie)
{
	ASSERT_NULL_OR_POINTER(pdwCookie, DWORD)
	ASSERT_POINTER(pUnkSink, IUnknown)

	if (pUnkSink == NULL)
		return E_POINTER;

	LPUNKNOWN lpInterface;

	if (SUCCEEDED(pUnkSink->QueryInterface(IID_INotifyDBEvents, (LPVOID*)&lpInterface)))
		{
		// 1st check to see if we need to allocate more entries
		if (m_uiConnectionsAllocated <= m_uiConnectionsActive) 
			{
			ULONG ulNewLen = (m_uiConnectionsAllocated + VD_ADVISE_TABLE_GROWBY) * sizeof(INotifyDBEvents**);
			INotifyDBEvents ** pNewMem = new INotifyDBEvents *[m_uiConnectionsAllocated + VD_ADVISE_TABLE_GROWBY];
			if (!pNewMem)
				return E_OUTOFMEMORY;
			memset(pNewMem, 0, (int)ulNewLen);
			// check to see if a table already exists
			if (m_ppNotifyDBEvents)
				{
				// if there are active connections copy them over to the new table
				if (m_uiConnectionsActive > 0)
					memcpy(pNewMem, m_ppNotifyDBEvents, m_uiConnectionsActive * sizeof(INotifyDBEvents**));
				 delete [] m_ppNotifyDBEvents;  // free up old table
				}
			m_ppNotifyDBEvents		= pNewMem;
			m_uiConnectionsAllocated += VD_ADVISE_TABLE_GROWBY;  // grow table by 10 entries each allocation
			}
		// append to end of table 
		m_ppNotifyDBEvents[m_uiConnectionsActive]	= (INotifyDBEvents*)lpInterface;
		m_uiConnectionsActive++;
		if (pdwCookie != NULL)
			*pdwCookie = (DWORD)lpInterface;
		return S_OK;
		}

	return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// IConnectionPoint Unadvise
//
HRESULT CVDNotifyDBEventsConnPt::Unadvise(DWORD dwCookie)
{
	ASSERT_POINTER((INotifyDBEvents*)dwCookie, INotifyDBEvents)

	for (UINT i = 0; i < m_uiConnectionsActive; i++)
		{
		if (m_ppNotifyDBEvents[i] == (INotifyDBEvents*)dwCookie)
			{
			RELEASE_OBJECT(m_ppNotifyDBEvents[i])
			// compress remaining entries in table
			for (UINT j = i; j < m_uiConnectionsActive - 1; j++)
				 m_ppNotifyDBEvents[j] = m_ppNotifyDBEvents[j + 1];
			m_uiConnectionsActive--;
			return S_OK;
			}
		}

	return CONNECT_E_NOCONNECTION;
}

//=--------------------------------------------------------------------------=
// IConnectionPoint EnumConnections
//
HRESULT CVDNotifyDBEventsConnPt::EnumConnections(LPENUMCONNECTIONS FAR* ppEnum)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\msr2c.h ===
//---------------------------------------------------------------------------
// MSR2C.h : Main header file for Viaduct phase II
//
// Copyright (c) 1996, 1997 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

  /////////////////////////////////////////////////////////////////////////
  // NOTE - you must define VD_INCLUDE_ROWPOSITION before including this //
  //        header for ICursorFromRowPosition to be defined in your code //
  /////////////////////////////////////////////////////////////////////////

#ifndef __MSR2C_H__
#define __MSR2C_H__

// {5B5E7E70-E653-11cf-84A5-0000C08C00C4}
const GUID CLSID_CCursorFromRowset =	
	{ 0x5b5e7e70, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

// {5B5E7E72-E653-11cf-84A5-0000C08C00C4}
const IID IID_ICursorFromRowset = 
	{ 0x5b5e7e72, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

#ifdef VD_INCLUDE_ROWPOSITION

// {5B5E7E73-E653-11cf-84A5-0000C08C00C4}
const IID IID_ICursorFromRowPosition = 
	{ 0x5b5e7e73, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

#endif //VD_INCLUDE_ROWPOSITION

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICursorFromRowset : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCursor( 
            /* [in]  */ IRowset __RPC_FAR *pRowset,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid) = 0;
    };
    
#ifdef VD_INCLUDE_ROWPOSITION

    interface ICursorFromRowPosition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCursor( 
            /* [in]  */ IRowPosition __RPC_FAR *pRowPosition,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid) = 0;
    };

#endif //VD_INCLUDE_ROWPOSITION

#else 	/* C style interface */

    typedef struct ICursorFromRowset
    {
        BEGIN_INTERFACE
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *QueryInterface)( 
            ICursorFromRowset __RPC_FAR *This,
            /* [in]  */ REFIID riid,
            /* [out] */ void __RPC_FAR **ppvObject);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *AddRef)( 
            ICursorFromRowset __RPC_FAR *This);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *Release)( 
            ICursorFromRowset __RPC_FAR *This);
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *GetCursor)( 
            ICursorFromRowset __RPC_FAR *This,
            /* [in]  */ IRowset __RPC_FAR *pRowset,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid);
        
        END_INTERFACE
    } ICursorFromRowsetVtbl;

    interface ICursorFromRowset
    {
        CONST_VTBL struct ICursorFromRowsetVtbl __RPC_FAR *lpVtbl;
    };

#ifdef VD_INCLUDE_ROWPOSITION

    typedef struct ICursorFromRowPosition
    {
        BEGIN_INTERFACE
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *QueryInterface)( 
            ICursorFromRowPosition __RPC_FAR *This,
            /* [in]  */ REFIID riid,
            /* [out] */ void __RPC_FAR **ppvObject);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *AddRef)( 
            ICursorFromRowPosition __RPC_FAR *This);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *Release)( 
            ICursorFromRowPosition __RPC_FAR *This);
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *GetCursor)( 
            ICursorFromRowPosition __RPC_FAR *This,
            /* [in]  */ IRowPosition __RPC_FAR *pRowPosition,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid);
        
        END_INTERFACE
    } ICursorFromRowPositionVtbl;

    interface ICursorFromRowPosition
    {
        CONST_VTBL struct ICursorFromRowPositionVtbl __RPC_FAR *lpVtbl;
    };

#endif //VD_INCLUDE_ROWPOSITION

#endif 	/* C style interface */

#ifdef __cplusplus
extern "C" {
#endif
// old entry point
HRESULT WINAPI VDGetICursorFromIRowset(IRowset * pRowset, 
                                       ICursor ** ppCursor,
                                       LCID lcid);
#ifdef __cplusplus
}
#endif

//
// MessageId: VD_E_CANNOTGETMANDATORYINTERFACE
//
// MessageText:
//
//  Unable to get required interface
//
#define VD_E_CANNOTGETMANDATORYINTERFACE        ((HRESULT)0x80050E00L)

//
// MessageId: VD_E_CANNOTCONNECTIROWSETNOTIFY
//
// MessageText:
//
//  Unable to connect IRowsetNotify
//
#define VD_E_CANNOTCONNECTIROWSETNOTIFY         ((HRESULT)0x80050E31L)

//
// MessageId: VD_E_CANNOTGETCOLUMNINFO
//
// MessageText:
//
//  Unable to get column information
//
#define VD_E_CANNOTGETCOLUMNINFO                ((HRESULT)0x80050E32L)

//
// MessageId: VD_E_CANNOTCREATEBOOKMARKACCESSOR
//
// MessageText:
//
//  Unable to create bookmark accessor
//
#define VD_E_CANNOTCREATEBOOKMARKACCESSOR       ((HRESULT)0x80050E33L)

//
// MessageId: VD_E_REQUIREDPROPERTYNOTSUPPORTED
//
// MessageText:
//
//  Require rowset property is not supported
//
#define VD_E_REQUIREDPROPERTYNOTSUPPORTED       ((HRESULT)0x80050E34L)

//
// MessageId: VD_E_CANNOTGETROWSETINTERFACE
//
// MessageText:
//
//  Unable to get rowset interface
//
#define VD_E_CANNOTGETROWSETINTERFACE			((HRESULT)0x80050E35L)

//
// MessageId: VD_E_CANNOTCONNECTIROWPOSITIONCHANGE
//
// MessageText:
//
//  Unable to connect IRowPositionChange
//
#define VD_E_CANNOTCONNECTIROWPOSITIONCHANGE	((HRESULT)0x80050E36L)

#endif //__MSR2C_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\ocdbid.h ===
/*=--------------------------------------------------------------------------=
 * ocdbid.h
 *=--------------------------------------------------------------------------=
 * defines all the guids for OLE Controls Data Binding Interfaces interfaces.
 *
 * Copyright (c) 1994-1995 Microsoft Corporation, All Rights Reserved.
 *
 *
 * Note: This header file has been modified by Sheridan Software to resolve
 *       name conflicts with other Microsoft header files.  Some GUIDs have
 *       prefixed with "_CURSOR".
 *
 */

/* {9F6AA700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursor,
0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {ACFF0690-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorMove,
0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {BB87E420-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorScroll,
0xbb87e420, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {D14216A0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorUpdateARow,
0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {DB526CC0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_INotifyDBEvents,
0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E01D7850-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorFind,
0xe01d7850, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E4D19810-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_IEntryID,
0xe4d19810, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E8BF1170-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_CURSOR_GUID_NAMEONLY,
0xe8bf1170, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {F6304BB0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_CURSOR_DBBMKGUID,
0xf6304bb0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {FE284700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_CURSOR_DBCIDGUID,
0xfe284700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\ocdb.h ===
/*=--------------------------------------------------------------------------=
 * ocdb.h
 *=--------------------------------------------------------------------------=
 * defines the interfaces and constants for use with the OLE Controls Data
 * binding interfaces.
 *
 * Copyright (c) 1994-1995 Microsoft Corporation, All Rights Reserved.
 *
 *
 * Note: This header file has been modified by Sheridan Software to resolve
 *       name conflicts with other Microsoft header files.  All defines,
 *       enumerations and structures have been prefixed with "CURSOR_".
 *
 */
#ifndef __OCDB_H_

#undef Delete
#ifdef __cplusplus
extern "C" {
#endif

/* CURSOR_LPDBSTRs are MultiByte in 16bits, and Unicode in 32bits.
 */
#if WIN16

#define CURSOR_LPDBSTR              LPSTR
#define CURSOR_DBCHAR               char
#define CURSOR_ldbstrlen(str)       lstrlen(str)
#define CURSOR_ldbstrcpy(a, b)      lstrcpy((a), (b))
#define CURSOR_ldbstrcpyn(a,b,n)    lstrcpyn((a), (b), (n))
#define CURSOR_ldbstrcmp(a, b)      lstrcmp((a), (b))
#define CURSOR_ldbstrcat(a, b)      lstrcat((a), (b))
#define CURSOR_ldbstrcmpi(a,b)      lstrcmpi((a),(b))
#define CURSOR_DBTEXT(quote)        quote

#else

#define CURSOR_LPDBSTR              LPWSTR
#define CURSOR_DBCHAR               WCHAR
#define CURSOR_ldbstrlen(str)       wcslen(str)
#define CURSOR_ldbstrcpy(a, b)      wcscpy((a), (b))
#define CURSOR_ldbstrcpyn(a,b,n)    wcsncpy((a), (b), (n))
#define CURSOR_ldbstrcmp(a, b)      wcscmp((a), (b))
#define CURSOR_ldbstrcat(a, b)      wcscat((a), (b))
#define CURSOR_ldbstrcmpi(a,b)      wcsicmp((a),(b))
#define CURSOR_DBTEXT(quote)        L##quote

#endif /* WIN16 */

typedef CURSOR_LPDBSTR FAR *  CURSOR_LPLPDBSTR;


/* Many systems don't have BLOBs defined.
 */
#ifndef _tagCURSOR_BLOB_DEFINED
#define _tagCURSOR_BLOB_DEFINED
#define _CURSOR_BLOB_DEFINED
#define _CURSOR_LPBLOB_DEFINED

typedef struct tagCURSOR_BLOB {

    ULONG cbSize;
    BYTE *pBlobData;

} CURSOR_BLOB, *CURSOR_LPBLOB;

#endif

/*----------------------------------------------------------------------------
 *
 *	dbvar.h
 *
 *----------------------------------------------------------------------------
 */
#ifndef _CURSOR_DBCOLUMNID_DEFINED
#define _CURSOR_DBCOLUMNID_DEFINED
typedef enum tagCURSOR_DBCOLKIND
    {
	    CURSOR_DBCOLKIND_GUID_NAME = 0,
	    CURSOR_DBCOLKIND_GUID_NUMBER = 1,
        CURSOR_DBCOLKIND_NAME = 2
    }
CURSOR_DBCOLKIND;

#define CURSOR_GUID_NAMEONLY	{0x88c8d398,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define CURSOR_GUID_NUMBERONLY  {0x88c8d399,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}

typedef struct tagCURSOR_DBCOLUMNID
    {
        GUID guid;
        CURSOR_DBCOLKIND dwKind;
union
    {
        LONG lNumber;
        CURSOR_LPDBSTR lpdbsz;
    }
  ;
  }
CURSOR_DBCOLUMNID;
#endif   /* ndef _CURSOR_COLUMNID_DEFINED */

#ifndef _CURSOR_DBVARENUM_DEFINED
#define _CURSOR_DBVARENUM_DEFINED
enum CURSOR_DBVARENUM
    {
        CURSOR_DBTYPE_EMPTY = 0,
        CURSOR_DBTYPE_NULL = 1,
        CURSOR_DBTYPE_I2 = 2,
        CURSOR_DBTYPE_I4 = 3,
        CURSOR_DBTYPE_I8 = 20,
        CURSOR_DBTYPE_R4 = 4,
        CURSOR_DBTYPE_R8 = 5,
        CURSOR_DBTYPE_CY = 6,
        CURSOR_DBTYPE_DATE = 7,
        CURSOR_DBTYPE_BOOL = 11,
        CURSOR_DBTYPE_HRESULT = 25,
        CURSOR_DBTYPE_LPSTR = 30,
        CURSOR_DBTYPE_LPWSTR = 31,
        CURSOR_DBTYPE_FILETIME = 64,
        CURSOR_DBTYPE_BLOB = 65,
        CURSOR_DBTYPE_UUID = 72,
        CURSOR_DBTYPE_DBEXPR = 503,
        CURSOR_DBTYPE_UI2 = 504,
        CURSOR_DBTYPE_UI4 = 505,
        CURSOR_DBTYPE_UI8 = 506,
        CURSOR_DBTYPE_COLUMNID = 507,
        CURSOR_DBTYPE_BYTES = 508,
        CURSOR_DBTYPE_CHARS = 509,
        CURSOR_DBTYPE_WCHARS = 510,
        CURSOR_DBTYPE_ANYVARIANT = 511
    }
;
#endif   /* ndef _CURSOR_DBVARENUM_DEFINED */

#define CURSOR_DBTYPE_EXT       0x100
#define CURSOR_DBTYPE_VECTOR	0x1000

typedef struct tagCURSOR_DBVARIANT CURSOR_DBVARIANT;

struct FARSTRUCT tagCURSOR_DBVARIANT {
    VARTYPE vt;
    unsigned short wReserved1;
    unsigned short wReserved2;
    unsigned short wReserved3;
    union {
        unsigned char       bVal;	                /* VT_UI1                   */
        short	            iVal;                   /* VT_I2                    */
        long	            lVal;                   /* VT_I4                    */
        float	            fltVal;                 /* VT_R4                    */
        double	            dblVal;                 /* VT_R8                    */
#pragma warning(disable: 4237)
		VARIANT_BOOL        bool;                   /* (obsolete)               */
#pragma warning(default: 4237)
        VARIANT_BOOL        boolVal;                /* VT_BOOL                  */
        SCODE	            scode;                  /* VT_ERROR                 */
        CY	                cyVal;                  /* VT_CY                    */
        DATE	            date;                   /* VT_DATE                  */
        BSTR	            bstrVal;                /* VT_BSTR                  */
        IUnknown	        FAR* punkVal;           /* VT_UNKNOWN               */
        IDispatch	        FAR* pdispVal;          /* VT_DISPATCH              */
        SAFEARRAY	        FAR* parray;	        /* VT_ARRAY|*               */
                                                                                
        unsigned char       FAR* pbVal;             /* VT_BYREF|VT_UI1          */
        short	            FAR* piVal;             /* VT_BYREF|VT_I2	        */
        long	            FAR* plVal;             /* VT_BYREF|VT_I4	        */
        float	            FAR* pfltVal;           /* VT_BYREF|VT_R4           */
        double	            FAR* pdblVal;           /* VT_BYREF|VT_R8           */
        VARIANT_BOOL        FAR* pbool;             /* VT_BYREF|VT_BOOL         */
        SCODE	            FAR* pscode;            /* VT_BYREF|VT_ERROR        */
        CY	                FAR* pcyVal;            /* VT_BYREF|VT_CY           */
        DATE	            FAR* pdate;             /* VT_BYREF|VT_DATE         */
        BSTR	            FAR* pbstrVal;          /* VT_BYREF|VT_BSTR         */
        IUnknown            FAR* FAR* ppunkVal;     /* VT_BYREF|VT_UNKNOWN      */
        IDispatch           FAR* FAR* ppdispVal;    /* VT_BYREF|VT_DISPATCH     */
        SAFEARRAY           FAR* FAR* pparray;      /* VT_BYREF|VT_ARRAY|*      */
        VARIANT	            FAR* pvarVal;           /* VT_BYREF|VT_VARIANT      */
                                                                                
        void	            FAR* byref;	            /* Generic ByRef            */
                                                                                
        // types new to CURSOR_DBVARIANTs                                              
        //                                                                      
        CURSOR_BLOB         blob;                   /* VT_BLOB                  */
        CURSOR_DBCOLUMNID   *pColumnid;             /* CURSOR_DBTYPE_COLUMNID   */
        LPSTR               pszVal;                 /* VT_LPSTR                 */
#if WIN32                                                                       
        LPWSTR              pwszVal;                /* VT_LPWSTR                */
        LPWSTR FAR          *ppwszVal;              /* VT_LPWSTR|VT_BYREF       */
#endif /* WIN32 */                                                              
        CURSOR_BLOB FAR     *pblob;                 /* VT_BYREF|VT_BLOB                 */
        CURSOR_DBCOLUMNID   **ppColumnid;           /* VT_BYREF|CURSOR_DBTYPE_COLUMNID  */
        CURSOR_DBVARIANT    *pdbvarVal;             /* VT_BYREF|CURSOR_DBTYPE_VARIANT   */
    }
#if defined(NONAMELESSUNION) || (defined(_MAC) && !defined(__cplusplus) && !defined(_MSC_VER))
    u
#endif
    ;
};

/*----------------------------------------------------------------------------
 *
 *	dbs.h
 *
 *----------------------------------------------------------------------------
 */
typedef enum tagCURSOR_DBROWFETCH
    {
	    CURSOR_DBROWFETCH_DEFAULT = 0,
	    CURSOR_DBROWFETCH_CALLEEALLOCATES = 1,
	    CURSOR_DBROWFETCH_FORCEREFRESH = 2
    }
CURSOR_DBROWFETCH;

typedef struct tagCURSOR_DBFETCHROWS
    {
        ULONG      cRowsRequested;
        DWORD      dwFlags;
        VOID HUGEP *pData;
        VOID HUGEP *pVarData;
        ULONG      cbVarData;
        ULONG      cRowsReturned;
    }
CURSOR_DBFETCHROWS;

#define CURSOR_DB_NOMAXLENGTH   (DWORD)0
#define CURSOR_DB_NOVALUE       (DWORD)0xFFFFFFFF
#define CURSOR_DB_NULL          (DWORD)0xFFFFFFFF
#define CURSOR_DB_EMPTY         (DWORD)0xFFFFFFFE
#define CURSOR_DB_USEENTRYID    (DWORD)0xFFFFFFFD
#define CURSOR_DB_CANTCOERCE    (DWORD)0xFFFFFFFC
#define CURSOR_DB_TRUNCATED     (DWORD)0xFFFFFFFB
#define CURSOR_DB_UNKNOWN       (DWORD)0xFFFFFFFA
#define CURSOR_DB_NOINFO        (DWORD)0xFFFFFFF9

typedef enum tagCURSOR_DBBINDING
    {
	    CURSOR_DBBINDING_DEFAULT = 0,
	    CURSOR_DBBINDING_VARIANT = 1,
	    CURSOR_DBBINDING_ENTRYID = 2
    }
CURSOR_DBBINDING;

typedef enum tagCURSOR_DBBINDTYPE
    {
        CURSOR_DBBINDTYPE_DATA    = 0,
	    CURSOR_DBBINDTYPE_ENTRYID = 1,
	    CURSOR_DBBDINTYPE_EITHER  = 2,
	    CURSOR_DBBINDTYPE_BOTH    = 3
    }
CURSOR_DBBINDTYPE;

typedef struct tagCURSOR_DBCOLUMNBINDING
    {
        CURSOR_DBCOLUMNID columnID;
        ULONG obData;
        ULONG cbMaxLen;
        ULONG obVarDataLen;
        ULONG obInfo;
        DWORD dwBinding;
        DWORD dwDataType;
    }
CURSOR_DBCOLUMNBINDING;

typedef struct tagCURSOR_DBBINDPARAMS
    {
        ULONG cbMaxLen;
        DWORD dwBinding;
        DWORD dwDataType;
        ULONG cbVarDataLen;
        DWORD dwInfo;
        void *pData;
    }
CURSOR_DBBINDPARAMS;

#define CURSOR_CID_NUMBER_INVALID              -1
#define CURSOR_CID_NUMBER_AUTOINCREMENT         0
#define CURSOR_CID_NUMBER_BASECOLUMNNAME        1
#define CURSOR_CID_NUMBER_BASENAME              2
#define CURSOR_CID_NUMBER_BINARYCOMPARABLE      3
#define CURSOR_CID_NUMBER_BINDTYPE              4
#define CURSOR_CID_NUMBER_CASESENSITIVE         5
#define CURSOR_CID_NUMBER_COLLATINGORDER        6
#define CURSOR_CID_NUMBER_COLUMNID              7
#define CURSOR_CID_NUMBER_CURSORCOLUMN          8
#define CURSOR_CID_NUMBER_DATACOLUMN            9
#define CURSOR_CID_NUMBER_DEFAULTVALUE          10
#define CURSOR_CID_NUMBER_ENTRYIDMAXLENGTH      11
#define CURSOR_CID_NUMBER_FIXED                 12
#define CURSOR_CID_NUMBER_HASDEFAULT            13
#define CURSOR_CID_NUMBER_MAXLENGTH             14
#define CURSOR_CID_NUMBER_MULTIVALUED           15
#define CURSOR_CID_NUMBER_NAME                  16
#define CURSOR_CID_NUMBER_NULLABLE              17
#define CURSOR_CID_NUMBER_PHYSICALSORT          18
#define CURSOR_CID_NUMBER_NUMBER                19
#define CURSOR_CID_NUMBER_ROWENTRYID            20
#define CURSOR_CID_NUMBER_SCALE                 21
#define CURSOR_CID_NUMBER_SEARCHABLE            22
#define CURSOR_CID_NUMBER_TYPE                  23
#define CURSOR_CID_NUMBER_UNIQUE                24
#define CURSOR_CID_NUMBER_UPDATABLE             25
#define CURSOR_CID_NUMBER_VERSION               26
#define CURSOR_CID_NUMBER_STATUS                27

/* c and C++ have different meanings for const.
 */
#ifdef __cplusplus
#define EXTERNAL_DEFN    extern const
#else
#define EXTERNAL_DEFN    const
#endif /* __cplusplus */



#define CURSOR_DBCIDGUID {0xfe284700L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef CURSOR_DBINITCONSTANTS

EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMNID_INVALID        = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, -1};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_AUTOINCREMENT    = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BASECOLUMNNAME   = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BASENAME         = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BINARYCOMPARABLE = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BINDTYPE         = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_CASESENSITIVE    = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_COLLATINGORDER   = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_COLUMNID         = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 7};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_CURSORCOLUMN     = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 8};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_DATACOLUMN       = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 9};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_DEFAULTVALUE     = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 10};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_ENTRYIDMAXLENGTH = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 11};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_FIXED            = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 12};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_HASDEFAULT       = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 13};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_MAXLENGTH        = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 14};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_MULTIVALUED      = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 15};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NAME             = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 16};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NULLABLE         = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 17};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_PHYSICALSORT     = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 18};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NUMBER           = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 19};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_ROWENTRYID       = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 20};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_SCALE            = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 21};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_SEARCHABLE       = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 22};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_TYPE             = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 23};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_UNIQUE           = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 24};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_UPDATABLE        = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 25};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_VERSION          = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 26};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_STATUS           = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 27};
#else
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMNID_INVALID;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_AUTOINCREMENT;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BASECOLUMNNAME;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BASENAME;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BINARYCOMPARABLE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BINDTYPE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_CASESENSITIVE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_COLLATINGORDER;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_COLUMNID;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_CURSORCOLUMN;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_DATACOLUMN;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_DEFAULTVALUE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_ENTRYIDMAXLENGTH;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_FIXED;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_HASDEFAULT;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_MAXLENGTH;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_MULTIVALUED;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NAME;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NULLABLE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_PHYSICALSORT;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NUMBER;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_ROWENTRYID;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_SCALE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_SEARCHABLE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_TYPE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_UNIQUE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_UPDATABLE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_VERSION;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_STATUS;
#endif

#define CURSOR_BMK_NUMBER_BMKTEMPORARY      0
#define CURSOR_BMK_NUMBER_BMKTEMPORARYREL   1
#define CURSOR_BMK_NUMBER_BMKCURSOR         2
#define CURSOR_BMK_NUMBER_BMKCURSORREL      3
#define CURSOR_BMK_NUMBER_BMKSESSION        4
#define CURSOR_BMK_NUMBER_BMKSESSIONREL     5
#define CURSOR_BMK_NUMBER_BMKPERSIST        6
#define CURSOR_BMK_NUMBER_BMKPERSISTREL     7


#define CURSOR_DBBMKGUID {0xf6304bb0L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef CURSOR_DBINITCONSTANTS
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKTEMPORARY     = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKTEMPORARYREL  = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKCURSOR        = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKCURSORREL     = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKSESSION       = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKSESSIONREL    = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKPERSIST       = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKPERSISTREL    = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 7};
#else
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKINVALID;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKTEMPORARY;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKTEMPORARYREL;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKCURSOR;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKCURSORREL;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKSESSION;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKSESSIONREL;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKPERSIST;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKPERSISTREL;
#endif

#define CURSOR_DB_BMK_SIZE  sizeof(BYTE)
#ifdef CURSOR_DBINITCONSTANTS
EXTERNAL_DEFN BYTE NEAR CURSOR_DBBMK_INVALID    = 0x0;
EXTERNAL_DEFN BYTE NEAR CURSOR_DBBMK_CURRENT    = 0x1;
EXTERNAL_DEFN BYTE NEAR CURSOR_DBBMK_BEGINNING  = 0x2;
EXTERNAL_DEFN BYTE NEAR CURSOR_DBBMK_END        = 0x3;
#else
extern const BYTE NEAR CURSOR_DBBMK_INVALID;
extern const BYTE NEAR CURSOR_DBBMK_CURRENT;
extern const BYTE NEAR CURSOR_DBBMK_BEGINNING;
extern const BYTE NEAR CURSOR_DBBMK_END;
#endif

typedef enum tagCURSOR_DBCOLUMNBINDOPTS
    {
	    CURSOR_DBCOLUMNBINDOPTS_REPLACE = 0,
	    CURSOR_DBCOLUMNBINDOPTS_ADD = 1
    }
CURSOR_DBCOLUMNBINDOPTS;

typedef enum tagCURSOR_DBUPDATELOCK
    {
	    CURSOR_DBUPDATELOCK_PESSIMISTIC = 0,
	    CURSOR_DBUPDATELOCK_OPTIMISTIC = 1
    }
CURSOR_DBUPDATELOCK;

typedef enum tagCURSOR_DBCOLUMNDATA
    {
	    CURSOR_DBCOLUMNDATA_UNCHANGED = 0,
	    CURSOR_DBCOLUMNDATA_CHANGED = 1,
        CURSOR_DBCOLUMNDATA_UNKNOWN = 2
    }
CURSOR_DBCOLUMNDATA;

typedef enum tagCURSOR_DBROWACTION
    {
	    CURSOR_DBROWACTION_IGNORE = 0,
	    CURSOR_DBROWACTION_UPDATE = 1,
	    CURSOR_DBROWACTION_DELETE = 2,
	    CURSOR_DBROWACTION_ADD = 3,
	    CURSOR_DBROWACTION_LOCK = 4,
	    CURSOR_DBROWACTION_UNLOCK = 5
    }
CURSOR_DBROWACTION;

typedef enum tagCURSOR_DBUPDATEABLE
    {
	    CURSOR_DBUPDATEABLE_UPDATEABLE = 0,
	    CURSOR_DBUPDATEABLE_NOTUPDATEABLE = 1,
	    CURSOR_DBUPDATEABLE_UNKNOWN = 2
    }
CURSOR_DBUPDATEABLE;

typedef struct tagCURSOR_DBROWSTATUS
    {
        HRESULT hrStatus;
        CURSOR_BLOB Bookmark;
    }
CURSOR_DBROWSTATUS;

typedef enum tagCURSOR_DBEVENTWHATS
    {
        CURSOR_DBEVENT_CURRENT_ROW_CHANGED = 1,
        CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED = 2,
        CURSOR_DBEVENT_NONCURRENT_ROW_DATA_CHANGED = 4,
        CURSOR_DBEVENT_SET_OF_COLUMNS_CHANGED = 8,
        CURSOR_DBEVENT_ORDER_OF_COLUMNS_CHANGED = 16,
        CURSOR_DBEVENT_SET_OF_ROWS_CHANGED = 32,
        CURSOR_DBEVENT_ORDER_OF_ROWS_CHANGED = 64,
        CURSOR_DBEVENT_METADATA_CHANGED = 128,
        CURSOR_DBEVENT_ASYNCH_OP_FINISHED = 256,
        CURSOR_DBEVENT_FIND_CRITERIA_CHANGED = 512,
    }
CURSOR_DBEVENTWHATS;

typedef enum tagCURSOR_DBREASON
    {
        CURSOR_DBREASON_DELETED = 1,
        CURSOR_DBREASON_INSERTED = 2,
        CURSOR_DBREASON_MODIFIED = 3,
        CURSOR_DBREASON_REMOVEDFROMCURSOR = 4,
        CURSOR_DBREASON_MOVEDINCURSOR = 5,
        CURSOR_DBREASON_MOVE = 6,
        CURSOR_DBREASON_FIND = 7,
        CURSOR_DBREASON_NEWINDEX = 8,
        CURSOR_DBREASON_ROWFIXUP = 9,
        CURSOR_DBREASON_RECALC = 10,
        CURSOR_DBREASON_REFRESH = 11,
        CURSOR_DBREASON_NEWPARAMETERS = 12,
        CURSOR_DBREASON_SORTCHANGED = 13,
        CURSOR_DBREASON_FILTERCHANGED = 14,
        CURSOR_DBREASON_QUERYSPECCHANGED = 15,
        CURSOR_DBREASON_SEEK = 16,
        CURSOR_DBREASON_PERCENT = 17,
        CURSOR_DBREASON_FINDCRITERIACHANGED = 18,
        CURSOR_DBREASON_SETRANGECHANGED = 19,
        CURSOR_DBREASON_ADDNEW = 20,
        CURSOR_DBREASON_MOVEPERCENT = 21,
        CURSOR_DBREASON_BEGINTRANSACT = 22,
        CURSOR_DBREASON_ROLLBACK = 23,
        CURSOR_DBREASON_COMMIT = 24,
        CURSOR_DBREASON_CLOSE = 25,
        CURSOR_DBREASON_BULK_ERROR = 26,
        CURSOR_DBREASON_BULK_NOTTRANSACTABLE = 27,
        CURSOR_DBREASON_BULK_ABOUTTOEXECUTE = 28,
        CURSOR_DBREASON_CANCELUPDATE = 29,
        CURSOR_DBREASON_SETCOLUMN = 30,
        CURSOR_DBREASON_EDIT = 31
    }
CURSOR_DBREASON;

// Arg1 values for CURSOR_DBREASON_FIND
typedef enum tagCURSOR_DBFINDTYPES
    {
        CURSOR_DB_FINDFIRST = 1,
        CURSOR_DB_FINDLAST = 2,
        CURSOR_DB_FINDNEXT = 3,
        CURSOR_DB_FINDPRIOR = 4,
        CURSOR_DB_FIND = 5
    }
CURSOR_DBFINDTYPES;

typedef struct tagCURSOR_DBNOTIFYREASON
    {
        DWORD dwReason;
        CURSOR_DBVARIANT arg1;
        CURSOR_DBVARIANT arg2;
    }
CURSOR_DBNOTIFYREASON;

#define CURSOR_DB_E_BADBINDINFO           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e00)
#define CURSOR_DB_E_BADBOOKMARK           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e01)
#define CURSOR_DB_E_BADCOLUMNID           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e02)
#define CURSOR_DB_E_BADCRITERIA           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e03)
#define CURSOR_DB_E_BADENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e04)
#define CURSOR_DB_E_BADFRACTION           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e05)
#define CURSOR_DB_E_BADINDEXID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e06)
#define CURSOR_DB_E_BADQUERYSPEC          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e07)
#define CURSOR_DB_E_BADSORTORDER          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e08)
#define CURSOR_DB_E_BADVALUES             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e09)
#define CURSOR_DB_E_CANTCOERCE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0a)
#define CURSOR_DB_E_CANTLOCK              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0b)
#define CURSOR_DB_E_COLUMNUNAVAILABLE     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0c)
#define CURSOR_DB_E_DATACHANGED           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0d)
#define CURSOR_DB_E_INVALIDCOLUMNORDINAL  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0e)
#define CURSOR_DB_E_INVALIDINTERFACE      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0f)
#define CURSOR_DB_E_LOCKFAILED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e10)
#define CURSOR_DB_E_ROWDELETED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e11)
#define CURSOR_DB_E_ROWTOOSHORT           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e12)
#define CURSOR_DB_E_SCHEMAVIOLATION       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e13)
#define CURSOR_DB_E_SEEKKINDNOTSUPPORTED  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e14)
#define CURSOR_DB_E_UPDATEINPROGRESS      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e15)
#define CURSOR_DB_E_USEENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e16)
#define CURSOR_DB_E_STATEERROR            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e17)
#define CURSOR_DB_E_BADFETCHINFO          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e18)
#define CURSOR_DB_E_NOASYNC               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e19)
#define CURSOR_DB_E_ENTRYIDOPEN           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1a)
#define CURSOR_DB_E_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1b)
#define CURSOR_DB_S_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec0)
#define CURSOR_DB_S_CANCEL                MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec1)
#define CURSOR_DB_S_DATACHANGED           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec2)
#define CURSOR_DB_S_ENDOFCURSOR           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec3)
#define CURSOR_DB_S_ENDOFRESULTSET        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec4)
#define CURSOR_DB_S_OPERATIONCANCELLED    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec5)
#define CURSOR_DB_S_QUERYINTERFACE        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec6)
#define CURSOR_DB_S_WORKINGASYNC          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec7)
//#define CURSOR_DB_S_COULDNTCOERCE         MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec8)
#define CURSOR_DB_S_MOVEDTOFIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec9)
#define CURSOR_DB_S_CURRENTROWUNCHANGED   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0eca)
#define CURSOR_DB_S_ROWADDED              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecb)
#define CURSOR_DB_S_ROWUPDATED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecc)
#define CURSOR_DB_S_ROWDELETED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecd)

/*----------------------------------------------------------------------------
 *
 *	ICursor
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursor ICursor;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursor;

interface ICursor : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetColumnsCursor
    (
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetBindings
    (
	ULONG cCol,
	CURSOR_DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBindings
    (
	ULONG *pcCol,
	CURSOR_DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNextRows
    (
	LARGE_INTEGER udlRowsToSkip,
	CURSOR_DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Requery
    (
        void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursor;

typedef struct ICursorVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursor FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursor FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursor FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursor FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursor FAR *this,
	ULONG cCol,
	CURSOR_DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursor FAR *this,
	ULONG *pcCol,
	CURSOR_DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursor FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursor FAR *this
    );

} ICursorVtbl;

interface ICursor
{
    ICursorVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursor_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursor_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursor_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursor_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursor_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursor_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursor_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursor_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorMove
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorMove ICursorMove;

typedef enum tagCURSOR_DBCLONEOPTS
    {  
        CURSOR_DBCLONEOPTS_DEFAULT = 0,
        CURSOR_DBCLONEOPTS_SAMEROW = 1
    }
CURSOR_DBCLONEOPTS;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorMove;

interface ICursorMove : public ICursor
{
public:
    virtual HRESULT STDMETHODCALLTYPE Move
    (
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	CURSOR_DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBookmark
    (
	CURSOR_DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Clone
    (
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorMove;

typedef struct ICursorMoveVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorMove FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorMove FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorMove FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorMove FAR *this,
	ULONG cCol,
	CURSOR_DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorMove FAR *this,
	ULONG *pcCol,
	CURSOR_DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorMove FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorMove FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorMove FAR *this,
	CURSOR_DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorMove FAR *this,
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    );

} ICursorMoveVtbl;

interface ICursorMove
{
    ICursorMoveVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorMove_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorMove_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorMove_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorMove_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorMove_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorMove_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorMove_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorMove_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorMove_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorMove_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorMove_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorScroll
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorScroll ICursorScroll;

typedef enum tagCURSOR_DBCURSORPOPULATED
    {
        CURSOR_DBCURSORPOPULATED_FULLY = 0,
        CURSOR_DBCURSORPOPULATED_PARTIALLY = 1
    }
CURSOR_DBCURSORPOPULATED;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorScroll;

interface ICursorScroll : public ICursorMove
{
public:
    virtual HRESULT STDMETHODCALLTYPE Scroll
    (
	ULONG ulNumerator,
	ULONG ulDenominator,
	CURSOR_DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximatePosition
    (
	ULONG cbBookmark,
	void *pBookmark,
	ULONG *pulNumerator,
	ULONG *pulDenominator
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximateCount
    (
	LARGE_INTEGER *pudlApproxCount,
	DWORD *pdwFullyPopulated
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorScroll;

typedef struct ICursorScrollVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorScroll FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorScroll FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorScroll FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorScroll FAR *this,
	ULONG cCol,
	CURSOR_DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorScroll FAR *this,
	ULONG *pcCol,
	CURSOR_DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorScroll FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorScroll FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorScroll FAR *this,
	CURSOR_DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorScroll FAR *this,
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    );

    HRESULT (STDMETHODCALLTYPE FAR *Scroll)
    (
        ICursorScroll FAR *this,
	ULONG ulNumerator,
	ULONG ulDenominator,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximatePosition)
    (
        ICursorScroll FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	ULONG *pulNumerator,
	ULONG *pulDenominator
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximateCount)
    (
        ICursorScroll FAR *this,
	LARGE_INTEGER *pudlApproxCount,
	DWORD *pdwFullyPopulated
    );

} ICursorScrollVtbl;

interface ICursorScroll
{
    ICursorScrollVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorScroll_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorScroll_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorScroll_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorScroll_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorScroll_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorScroll_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorScroll_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorScroll_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorScroll_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorScroll_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorScroll_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)

#define ICursorScroll_Scroll(pI, ulNumerator, ulDenominator, pFetchParams) \
    (*(pI)->lpVtbl->Scroll)((pI), ulNumerator, ulDenominator, pFetchParams)

#define ICursorScroll_GetApproximatePosition(pI, cbBookmark, pBookmark, pulNumerator, pulDenominator) \
    (*(pI)->lpVtbl->GetApproximatePosition)((pI), cbBookmark, pBookmark, pulNumerator, pulDenominator)

#define ICursorScroll_GetApproximateCount(pI, pudlApproxCount, pdwFullyPopulated) \
    (*(pI)->lpVtbl->GetApproximateCount)((pI), pudlApproxCount, pdwFullyPopulated)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorUpdateARow
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorUpdateARow ICursorUpdateARow;

typedef enum tagCURSOR_DBEDITMODE
    {
        CURSOR_DBEDITMODE_NONE = 1,
        CURSOR_DBEDITMODE_UPDATE = 2,
        CURSOR_DBEDITMODE_ADD = 3
    }
CURSOR_DBEDITMODE;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorUpdateARow;

interface ICursorUpdateARow : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE BeginUpdate
    (
	DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetColumn
    (
	CURSOR_DBCOLUMNID *pcid,
	CURSOR_DBBINDPARAMS *pBindParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetColumn
    (
	CURSOR_DBCOLUMNID *pcid,
	CURSOR_DBBINDPARAMS *pBindParams,
	DWORD *pdwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetEditMode
    (
	DWORD *pdwState
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Update
    (
	CURSOR_DBCOLUMNID *pBookmarkType,
	ULONG *pcbBookmark,
	void **ppBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancel
    (
        void
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Delete
    (
	void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorUpdateARow;

typedef struct ICursorUpdateARowVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorUpdateARow FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorUpdateARow FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *BeginUpdate)
    (
        ICursorUpdateARow FAR *this,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetColumn)
    (
        ICursorUpdateARow FAR *this,
	CURSOR_DBCOLUMNID *pcid,
	CURSOR_DBBINDPARAMS *pBindParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumn)
    (
        ICursorUpdateARow FAR *this,
	CURSOR_DBCOLUMNID *pcid,
	CURSOR_DBBINDPARAMS *pBindParams,
	DWORD *pdwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetEditMode)
    (
        ICursorUpdateARow FAR *this,
	DWORD *pdwState
    );

    HRESULT (STDMETHODCALLTYPE FAR *Update)
    (
        ICursorUpdateARow FAR *this,
	CURSOR_DBCOLUMNID *pBookmarkType,
	ULONG *pcbBookmark,
	void **ppBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancel)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Delete)
    (
        ICursorUpdateARow FAR *this
    );

} ICursorUpdateARowVtbl;

interface ICursorUpdateARow
{
    ICursorUpdateARowVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorUpdateARow_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorUpdateARow_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorUpdateARow_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorUpdateARow_BeginUpdate(pI, dwFlags) \
    (*(pI)->lpVtbl->BeginUpdate)((pI), dwFlags)

#define ICursorUpdateARow_SetColumn(pI, pcid, pBindParams) \
    (*(pI)->lpVtbl->SetColumn)((pI), pcid, pBindParams)

#define ICursorUpdateARow_GetColumn(pI, pcid, pBindParams, pdwFlags) \
    (*(pI)->lpVtbl->GetColumn)((pI), pcid, pBindParams, pdwFlags)

#define ICursorUpdateARow_GetEditMode(pI, pdwState) \
    (*(pI)->lpVtbl->GetEditMode)((pI), pdwState)

#define ICursorUpdateARow_Update(pI, pBookmarkType, pcbBookmark, ppBookmark) \
    (*(pI)->lpVtbl->Update)((pI), pBookmarkType, pcbBookmark, ppBookmark)

#define ICursorUpdateARow_Cancel(pI) \
    (*(pI)->lpVtbl->Cancel)((pI))

#define ICursorUpdateARow_Delete(pI) \
    (*(pI)->lpVtbl->Delete)((pI))


#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorFind
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorFind ICursorFind;

typedef enum tagCURSOR_DBFINDFLAGS
    {
        CURSOR_DBFINDFLAGS_FINDNEXT = 1,
        CURSOR_DBFINDFLAGS_FINDPRIOR = 2,
        CURSOR_DBFINDFLAGS_INCLUDECURRENT = 4
    }
CURSOR_DBFINDFLAGS;


typedef enum tagCURSOR_DBSEEKFLAGS
    {
        CURSOR_DBSEEK_LT	 = 1,
        CURSOR_DBSEEK_LE	 = 2,
        CURSOR_DBSEEK_EQ	 = 3,		// EXACT EQUALITY
        CURSOR_DBSEEK_GT	 = 4,
        CURSOR_DBSEEK_GE	 = 5,
        CURSOR_DBSEEK_PARTIALEQ = 6             // only for strings
    }
CURSOR_DBSEEKFLAGS;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorFind;

interface ICursorFind : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE FindByValues
    (
	ULONG                       cbBookmark,
	LPVOID                      pBookmark,
	DWORD                       dwFindFlags,
	ULONG                       cValues,
    CURSOR_DBCOLUMNID           rgColumns[],
	CURSOR_DBVARIANT            rgValues[],
	DWORD                       rgdwSeekFlags[],
    CURSOR_DBFETCHROWS FAR *    pFetchParams
    ) = 0;
};

#else

/* C Language Binding */
//extern const IID IID_ICursorFind;

typedef struct ICursorFindVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorFind FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorFind FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorFind FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *FindByValues)
    (
        ICursorFind FAR *this,
	ULONG                       cbBookmark,
	LPVOID                      pBookmark,
	DWORD                       dwFindFlags,
	ULONG                       cValues,
    CURSOR_DBCOLUMNID           rgColumns[],
	CURSOR_DBVARIANT            rgValues[],
	DWORD                       rgdwSeekFlags[],
    CURSOR_DBFETCHROWS FAR *    pFetchParams
    );


} ICursorFindVtbl;

interface ICursorFind
{
    ICursorFindVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorFind_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorFind_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorFind_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorFind_FindByValues(pI, cbB, pB, dwFF, cV, rgC, rgV, rgSF, pF) \
    (*(pI)->lpVtbl->FindByValues)((pI), cbB, pB, dwFF, cB, rgC, rgV, rgSF, pF)

#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *	IEntryID
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface IEntryID IEntryID;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_IEntryID;

interface IEntryID : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetInterface
    (
	ULONG cbEntryID,
	void *pEntryID,
        DWORD dwFlags,
        REFIID riid,
	IUnknown **ppvObj
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_IEntryID;

typedef struct IEntryIDVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IEntryID FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IEntryID FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IEntryID FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetInterface)
    (
        IEntryID FAR *this,
	ULONG cbEntryID,
	void *pEntryID,
        REFIID riid,
	IUnknown **ppvObj
    );

} IEntryIDVtbl;

interface IEntryID
{
    IEntryIDVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define IEntryID_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define IEntryID_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define IEntryID_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define IEntryID_GetInterface(pI, cbEntryID, pEntryID, riid, ppvObj) \
    (*(pI)->lpVtbl->GetInterface)((pI), cbEntryID, pEntryID, riid, ppvObj)
#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *	INotifyDBEvents
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface INotifyDBEvents INotifyDBEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_INotifyDBEvents;

interface INotifyDBEvents : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE OKToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancelled
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncBefore
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE AboutToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE FailedToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncAfter
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DidEvent
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

};

#else

/* C Language Binding */
extern const IID IID_INotifyDBEvents;

typedef struct INotifyDBEventsVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        INotifyDBEvents FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        INotifyDBEvents FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        INotifyDBEvents FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *OKToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancelled)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncBefore)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *AboutToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *FailedToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncAfter)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *DidEvent)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

} INotifyDBEventsVtbl;

interface INotifyDBEvents
{
    INotifyDBEventsVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define INotifyDBEvents_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define INotifyDBEvents_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define INotifyDBEvents_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define INotifyDBEvents_OKToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->OKToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_Cancelled(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->Cancelled)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncBefore(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncBefore)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_AboutToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->AboutToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_FailedToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->FailedToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncAfter(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncAfter)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_DidEvent(pI, dwEventWhat, cReas