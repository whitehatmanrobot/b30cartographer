 oldCS and oldIP, reset flags (ifl) and
; set CS:IP to point to interrupt instruction.
	MOV	ES,SSSAVE		; point to user stack
	MOV	DI,SPSAVE
; Take old flags and PUSH the flags.
	MOV	CX,FLSAVE		 ; get flags
	SUB	DI,2			; PUSHF
	MOV	ES:[DI],CX		; rest of push
; Push the old CS
	SUB	DI,2			; PUSH CS
	MOV	ES:[DI],BX		; rest of push
; Push the old IP
	SUB	DI,2			; PUSH IP
	ADD	AX,2			; increment IP
	MOV	ES:[DI],AX		; rest of push
; Update stack
	MOV	SPSAVE,DI		; store
; Take flags and turn interrupts off and trace mode off
	AND	CX,NOT F_INTERRUPT	; CLI
	AND	CX,NOT F_TRACE		; no trace
	MOV	FLSAVE,CX		 ; rest of CLI
; Set up correct process and go to normal reentry code.
	IF	NOT SYSVER
	    MOV     BX,[USER_PROC_PDB]
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
	JMP	SETENVIRON
; We need to special case the following instructions that may push a TRACE bit
; on the stack:  PUSHF (9C)

; Save the opcode in A Special place
CHECKOP:
	MOV	RSETFLAG,AL		; no bits to turn off
SETTRACE:
	OR	FLSAVE,F_TRACE		 ; Turn on trace bit
	IF	IBMVER
;
;	the following stuff can be inhibited on 286/386/etc CPUs.  The
;	  designers of the later chips added logic to enhance trace
;	  mode operation.  The reason why we just don't run it all of
;	  the time is that it can cause a system crash if the instruction
;	  being traced causes an overflow condition because nobody will
;	  turn interrupts back on.

	test	cpu_not_8088,1		; see if 8088/8086
	jnz	no_fix_8088

	    CLI
	    IN	    AL,MASK_PORT	; Get current mask
	    JMP     SHORT FOO
FOO:
	    MOV     [OLD_MASK],AL	; Save it
	    MOV     AL,INT_MASK 	; New mask
	    OUT     MASK_PORT,AL	; Set it
	    STI

no_fix_8088:

	ENDIF
DEXIT:
	IF	NOT SYSVER
	    MOV     BX,[USER_PROC_PDB]
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
; Unfortunately, any system call we issue will muck with the current extended
; errors.  Here we must restore the extended error state so that if the user
; program gets it, we do not interfere.
	MOV	AX,(SERVERCALL SHL 8) + 10
	MOV	DX,OFFSET DG:SAVESTATE
	INT	21H
	PUSH	DS
	XOR	AX,AX
	MOV	DS,AX
	MOV	WORD PTR DS:[12],OFFSET DG:BREAKFIX ; Set vector 3--breakpoint instruction
	MOV	WORD PTR DS:[14],CS
	MOV	WORD PTR DS:[4],OFFSET DG:REENTER ; Set vector 1--Single step
	MOV	WORD PTR DS:[6],CS
	CLI
	IF	SETCNTC
	    MOV     WORD PTR DS:[8CH],OFFSET DG:CONTC ; Set vector 23H (CTRL-C)
	    MOV     WORD PTR DS:[8EH],CS
	ENDIF
	POP	DS
	MOV	SP,OFFSET DG:STACK
	POP	AX
	POP	BX
	POP	CX
	POP	DX
	POP	BP
	POP	BP
	POP	SI
	POP	DI
	POP	ES
	POP	ES
	POP	SS
	MOV	SP,[SPSAVE]
	PUSH	[FLSAVE]
	PUSH	[CSSAVE]
	PUSH	[IPSAVE]
	MOV	DS,[DSSAVE]
	IRET
STEP1:
	CALL	CRLF
	CALL	DISPREG
	TEST	FZTRACE,-1
	JNZ	STEPZ
	JMP	STEP
STEPZ:	JMP	ZSTEP

; Re-entry point from CTRL-C. Top of stack has address in 86-DOS for
; continuing, so we must pop that off.
CONTC:
	ADD	SP,6
	JMP	SHORT REENTERREAL

; Re-entry point from breakpoint. Need to decrement instruction
; pointer so it points to location where breakpoint actually
; occured.
BREAKFIX:
	PUSH	BP
	MOV	BP,SP
	DEC	WORD PTR [BP].OLDIP
	POP	BP
	JMP	short REENTERREAL

; Re-entry point from trace mode or interrupt during execution.  All registers
; are saved so they can be displayed or modified.
INTERRUPT_FRAME STRUC
OLDBP	DW	?
OLDIP	DW	?
OLDCS	DW	?
OLDF	DW	?
OLDERIP DW	?
OLDERCS DW	?
OLDERF	DW	?
INTERRUPT_FRAME ENDS

ASSUME	CS:DG,DS:NOTHING,ES:NOTHING,SS:NOTHING
; ReEnter is the main entry point for breakpoint interrupts and for trace mode
; interrupts.  We treat both of these cases identically:  save state, display
; registers and go for another command.  If we get NMI's, we skip them or if
; it turns out that we are debugging ourselves, we skip them.

; Due to bogosities in the 808x chip, Consider tracing over an interrupt and
; then setting a breakpoint to where the interrupt returns.  You get the INT 3
; and then trace mode gets invoked!  This is why we ignore interrupts within
; ourselves.
REENTER:
	PUSH	BP
	MOV	BP,SP			; get a frame to address from
	PUSH	AX
;	MOV	AX,CS
;	CMP	AX,[BP].OLDCS		; Did we interrupt ourselves?
;	JNZ	GOREENTER		; no, go reenter
	IF	IBMJAPAN
	    MOV     AX,[BP].OLDIP
	    CMP     AX,OFFSET DG:NMIINT ; interrupt below NMI interrupt?
	    JB	    GOREENTER		; yes, go reenter
	    CMP     [BP].OLDIP,OFFSET DG:NMIINTEND
	    JAE     GOREENTER		; interrupt above NMI interrupt?
	    POP     AX			; restore state
	    POP     BP
	    SUB     SP,6		; switch TRACE and NMI stack frames
	    PUSH    BP
	    MOV     BP,SP		; set up frame
	    PUSH    AX			; get temp variable
	    MOV     AX,[BP].OLDERIP	; get NMI Vector
	    MOV     [BP].OLDIP,AX	; stuff in new NMI vector
	    MOV     AX,[BP].OLDERCS	; get NMI Vector
	    MOV     [BP].OLDCS,AX	; stuff in new NMI vector
	    MOV     AX,[BP].OLDERF	; get NMI Vector
	    AND     AH,0FEH		; turn off Trace if present
	    MOV     [BP].OLDF,AX	; stuff in new NMI vector
	    MOV     [BP].OLDERF,AX
	    MOV     [BP].OLDERIP,OFFSET DG:REENTER ; offset of routine
	    MOV     [BP].OLDERCS,CS	; and CS
	    POP     AX
	    POP     BP
	    IRET			; go try again
	ENDIF
GOREENTER:
	IF	IBMVER
	test	cpu_not_8088,1
	jnz	no_restore_pic_mask
	    MOV     AL,CS:[OLD_MASK]	; Recover Old mask
	    OUT     MASK_PORT,AL	; Restore it
no_restore_pic_mask:
	ENDIF

	MOV	AL,CS:[RSETFLAG]
; Determine, based on the previous instruction, what we are supposed to do
; to flags on the users stack.
	CMP	AL,09CH 		; PUSHF
	JNZ	NOFIX
; OlderIP = flags.  Turn off trace bit
	AND	[BP].OLDERIP,NOT F_TRACE
NOFIX:
	POP	AX
	POP	BP
REENTERREAL:
	MOV	CS:[SPSAVE+SEGDIF],SP
	MOV	CS:[SSSAVE+SEGDIF],SS
	MOV	CS:[FLSAVE],CS
	MOV	SS,CS:[FLSAVE]
	MOV	SP,OFFSET DG:RSTACK
	ASSUME	SS:DG

	PUSH	ES
	PUSH	DS
	PUSH	DI
	PUSH	SI
	PUSH	BP
	DEC	SP
	DEC	SP
	PUSH	DX
	PUSH	CX
	PUSH	BX
	PUSH	AX
	PUSH	SS
	POP	DS
	ASSUME	DS:DG

	MOV	SS,[SSSAVE]
	MOV	SP,[SPSAVE]
	ASSUME	SS:NOTHING

	POP	[IPSAVE]
	POP	[CSSAVE]
	POP	AX
	AND	AX,NOT F_TRACE		; TURN OFf trace mode bit
	MOV	[FLSAVE],AX
	MOV	[SPSAVE],SP
SETENVIRON:
	PUSH	DS
	POP	ES
	ASSUME	ES:DG

	PUSH	DS
	POP	SS
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	PUSH	DS
	XOR	AX,AX
	MOV	DS,AX
	ASSUME	DS:NOTHING

	IF	SETCNTC
	    MOV     WORD PTR DS:[8CH],OFFSET DG:DABORT ; Set Ctrl-C vector
	    MOV     WORD PTR DS:[8EH],CS
	ENDIF
	POP	DS
	ASSUME	DS:DG

	STI
	CLD
; Since we are about to issue system calls, let's grab the current user's
; extended error info.
	MOV	AH,GETEXTENDEDERROR
	INT	21H
	ASSUME	DS:NOTHING,ES:NOTHING

	MOV	SAVESTATE.DPL_AX,AX
	MOV	SAVESTATE.DPL_BX,BX
	MOV	SAVESTATE.DPL_CX,CX
	MOV	SAVESTATE.DPL_DX,DX
	MOV	SAVESTATE.DPL_SI,SI
	MOV	SAVESTATE.DPL_DI,DI
	MOV	SAVESTATE.DPL_DS,DS
	MOV	SAVESTATE.DPL_ES,ES
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	ASSUME	DS:DG,ES:DG

	IF	NOT SYSVER
	    MOV     AH,GET_CURRENT_PDB
	    INT     21H
	    MOV     [USER_PROC_PDB],BX
	    MOV     BX,BEGSEG
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
	MOV	SI,OFFSET DG:BPTAB
	MOV	CX,[BRKCNT]
	JCXZ	SHOREG
	PUSH	ES
CLEARBP:
	LES	DI,DWORD PTR [SI]
	ADD	SI,4
	MOVSB
	LOOP	CLEARBP
	POP	ES
SHOREG:
	DEC	[TCOUNT]
	JZ	CHECKDISP
	JMP	STEP1
CHECKDISP:
	CALL	CRLF
	CALL	DISPREG
	JMP	COMMAND

; Input from the specified port and display result
INPUT:
	MOV	CX,4			; Port may have 4 digits
	CALL	GETHEX			; Get port number in DX
	CALL	GETEOL

	IN	AL,DX			; Variable port input

	PUSH	CS
	POP	ES
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	HEX			; And display

	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:ARG_BUF_PTR
	JMP	PRINTF_CRLF

; Output a value to specified port.
OUTPUT:
	MOV	CX,4			; Port may have 4 digits
	CALL	GETHEX			; Get port number
	PUSH	DX			; Save while we get data
	MOV	CX,2			; Byte output only
	CALL	GETHEX			; Get data to output
	CALL	GETEOL
	XCHG	AX,DX			; Output data in AL
	POP	DX			; Port in DX

	OUT	DX,AL			; Variable port output

	RETURN

SETADD:
	MOV	DX,CSSAVE		; set up start addresses
	MOV	NEXTCS,DX
	MOV	DX,IPSAVE
	MOV	NEXTIP,DX
	MOV	BP,[CSSAVE]
	CALL	SCANP
	CMP	BYTE PTR [SI],"="
	RETNZ
	INC	SI
	CALL	ADDRESS
	MOV	NEXTCS,AX
	MOV	NEXTIP,DX
	RETURN

; Jump to program, setting up registers according to the
; save area. up to 10 breakpoint addresses may be specified.
GO:
	MOV	RSETFLAG,0
	CALL	SETADD
	XOR	BX,BX
	MOV	DI,OFFSET DG:BPTAB
GO1:
	CALL	SCANP
	JZ	DEXEC
	MOV	BP,[CSSAVE]
	PUSH	DI
	PUSH	BX			;AN000; DMS;SAVE BX - ADDRESS KILLS IT
	CALL	ADDRESS
	POP	BX			;AN000; DMS;RESTORE BX
	POP	DI
	MOV	[DI],DX 		; Save offset
	MOV	[DI+2],AX		; Save segment
	ADD	DI,5			; Leave a little room
	INC	BX
	CMP	BX,1+BPMAX
	JNZ	GO1
	MOV	DX,OFFSET DG:BP_ERROR	; BP ERROR
	JMP	ERR
DEXEC:
	MOV	[BRKCNT],BX
	MOV	CX,BX
	JCXZ	NOBP
	MOV	DI,OFFSET DG:BPTAB
	PUSH	DS
SETBP:
	LDS	SI,ES:DWORD PTR [DI]
	ADD	DI,4
	MOVSB
	MOV	BYTE PTR [SI-1],0CCH
	LOOP	SETBP
	POP	DS
NOBP:
	MOV	DX,NEXTCS
	MOV	CSSAVE,DX
	MOV	DX,NEXTIP
	MOV	IPSAVE,DX
	MOV	[TCOUNT],1
	JMP	DEXIT

SKIP_FILE:
	MOV	AH,CHAR_OPER
	XOR	AL,AL			; Get switch char subfunction
	INT	21H
	MOV	CS:[SWITCHAR],DL	; GET THE CURRENT SWITCH CHARACTER
FIND_DELIM:
	LODSB
	CALL	DELIM1
	JZ	GOTDELIM
	CALL	DELIM2
	JNZ	FIND_DELIM
GOTDELIM:
	DEC	SI
	RETURN

COMPARE:
	CALL	DSRANGE
	PUSH	CX
	PUSH	AX
	PUSH	DX
	CALL	ADDRESS 		; Same segment
	CALL	GETEOL
	POP	SI
	MOV	DI,DX
	MOV	ES,AX
	POP	DS
	POP	CX			; Length
	DEC	CX
	CALL	COMP			; Do one less than total
	INC	CX			; CX=1 (do last one)
COMP:
	REPE	CMPSB
	RETZ
; Compare error. Print address, value; value, address.
	DEC	SI
	MOV	CS:COMP_ARG1,DS
	MOV	CS:COMP_ARG2,SI
	XOR	AH,AH
	LODSB
	MOV	CS:COMP_ARG3,AX
	DEC	DI
	MOV	AL,ES:[DI]
	MOV	CS:COMP_ARG4,AX
	MOV	CS:COMP_ARG5,ES
	MOV	CS:COMP_ARG6,DI
	INC	DI
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	DX,OFFSET DG:COMP_PTR
	CALL	PRINTF_CRLF
	POP	DS
	XOR	AL,AL
	JMP	SHORT COMP

	PROCEDURE CHECKNONE,NEAR
	OR	DX,DX
	RETNZ
	MOV	DX,OFFSET DG:SYNERR_PTR ; ERROR MESSAGE
	JMP	PERR
	ENDPROC CHECKNONE

CODE	ENDS
	END	DEBCOM3

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debdata.asm ===
PAGE    60,132 ;
	   TITLE DEBDATA.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBDATA.ASM
;
; DESCRIPTIVE NAME: DATA SEGMENT VALUE DEFINITION
;
; FUNCTION: PROVIDES ALL DATA SEGMENT DEFINITIONS.
;
; ENTRY POINT: NA
;
; INPUT: ANY VALUE IN DATA SEGMENT
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES: NA
;
; EXTERNAL REFERENCES: NA
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- > 32 MB SUPPORT		DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================
;
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   03/21/90  DIC  C04	Fixed Microsoft Bug #744 - A problem involving a
;			limitation on the total number of requested EMS memory
;			pages to 255.  This limit is now a 4-digit hexadecimal
;			number.
;
;=============================================================================

.XLIST
.XCREF
	   include version.inc		; cas -- missing equates
	   INCLUDE DOSSYM.INC
           INCLUDE debug.inc
	   INCLUDE DPL.ASM
.LIST
.CREF
CODE	   SEGMENT PUBLIC BYTE
CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE
CONST	   ENDS

DATA	   SEGMENT PUBLIC BYTE
DATA	   ENDS

CSTACK	   SEGMENT STACK
CSTACK	   ENDS

DG	   GROUP CODE,CONST,CSTACK,DATA

DATA	   SEGMENT PUBLIC BYTE
	   PUBLIC PARITYFLAG,XNXOPT,XNXCMD,SWITCHAR,EXTPTR,HANDLE,TRANSADD
	   PUBLIC PARSERR,ASMADD,DISADD,DISCNT,ASMSP,INDEX,DEFDUMP,DEFLEN
	   PUBLIC REGSAVE,SEGSAVE,OFFSAVE,TEMP,BUFFER,BYTCNT,OPCODE,AWORD
	   PUBLIC REGMEM,MIDFLD,MODE,NSEG,BRKCNT,TCOUNT,ASSEM_CNT
	   PUBLIC ASSEM1,ASSEM2,ASSEM3,ASSEM4,ASSEM5,ASSEM6,BYTEBUF,BPTAB
	   PUBLIC DIFLG,SIFLG,BXFLG,BPFLG,NEGFLG,NUMFLG,MEMFLG,REGFLG
	   PUBLIC MOVFLG,TSTFLG,SEGFLG,LOWNUM,HINUM,F8087,DIRFLG,DATAEND
	   PUBLIC BEGSEG,CREATE_LONG,ARG_BUF_INDEX
	   PUBLIC FILEEND,FILESTRT,SSINTSAV,BPINTSAV
	   PUBLIC FZTRACE, PREV24, FIN24

	   public rel_read_write_tab		;an000;relative read/write
						;      table
	   public rel_low_sec			;an000;sector add. low word
	   public rel_high_sec			;an000;sector add. high word
	   public rel_sec_num			;an000;# of sectors to access
	   public rel_rw_add			;an000;transfer address

	   public lbtbl 			;an000;lead byte table pointer

	public xm_page				;an000;
	public xm_log				;an000;
	public xm_phy				;an000;
	public xm_handle			;an000;
	public xm_handle_ret			;an000;
	public xm_page_cnt			;an000;
	public xm_handle_pages_buf		;an000;
	public xm_frame 			;an000;
	public xm_deall_han			;an000;
	public xm_alloc_pg			;an000;
	public xm_total_pg			;an000;
	public xm_han_total			;an000;
	public xm_han_alloc			;an000;

;=========================================================================
; REL_READ_WRITE_TAB : This table provides the new generic IOCTL primitive
;		       read/write with its values.
;
;	Date	  : 6/17/87
;=========================================================================

REL_READ_WRITE_TAB	label	dword		;an000;relative read/write
						;      table
	rel_low_sec	dw	?		;an000;sector add. low word
	rel_high_sec	dw	?		;an000;sector add. high word
	rel_sec_num	dw	?		;an000;# of sectors to write
	rel_rw_add	dd	?		;an000;holds the segment
						;      & offset of the
						;      transfer address

;=========================================================================

lbtbl		dd	?			;an000;lead byte table pointer

;C04	xm_page        db   ?			;an000;page count to allocate
	xm_page        dw   ?	;page count to allocate - raised to 64K    ;C04
	xm_log	       db   ?			;an000;log. page to map
	xm_phy	       db   ?			;an000;phy. page to map
	xm_deall_han   dw   ?			;an000;handle to deallocate
	xm_handle      dw   ?			;an000;handle to map
	xm_handle_ret  dw   ?			;an000;handle created


	xm_page_cnt    dw   ?			;an000;current page count

	xm_handle_pages_buf db	 1024 dup(0)	;an000;hold handle pages

	xm_frame	dw  ?			;an000;holds frame segment

	xm_alloc_pg	dw  ?			;an000;active page count

	xm_total_pg	dw  ?			;an000;total possible page cnt.

	xm_han_total	dw  ?			;an000;total possible handles

	xm_han_alloc	dw  ?			;an000;handles allocated

	   IF	IBMVER
	       PUBLIC OLD_MASK
OLD_MASK       DB   ?
		public	cpu_not_8088
cpu_not_8088	db	?			; true if not 8088/8086
	   ENDIF

PREV24	   DD	?			; prevvious INT 24 handler
FIN24	   DB	0			; TRUE => in the process of cleaning up
FZTRACE    DB	0			; TRUE => in a Ztrace
FILEEND    DW	?			; ARR 2.4
FILESTRT   DW	?			; ARR 2.4
SSINTSAV   DD	?			; ARR 2.4
BPINTSAV   DD	?			; ARR 2.4

PARITYFLAG DB	0

PUBLIC	   SAVESTATE
SAVESTATE  DPL	<>			; storage for extended error info

XNXOPT	   DB	?			; AL OPTION FOR DOS COMMAND
XNXCMD	   DB	?			; DOS COMMAND FOR OPEN_A_FILE TO PERFORM
SWITCHAR   DB	?			; CURRENT SWITCH CHARACTER
EXTPTR	   DW	?			; POINTER TO FILE EXTENSION
HANDLE	   DW	?			; CURRENT HANDLE
TRANSADD   DD	?			; TRANSFER ADDRESS

PARSERR    DB	?
ASMADD	   DB	4 DUP (?)
DISADD	   DB	4 DUP (?)
DISCNT	   DW	?
ASMSP	   DW	?			; SP AT ENTRY TO ASM
INDEX	   DW	?
DEFDUMP    DB	4 DUP (?)
DEFLEN	   DW	?
REGSAVE    DW	?
SEGSAVE    DW	?
OFFSAVE    DW	?

;Do NOT move this dword variable - it sets up a long call for
;a Create_process_data_block call issued in DEBUG
CREATE_LONG LABEL DWORD
	   DW	100H
BEGSEG	   DW	?

; The following data areas are destroyed during hex file read
TEMP	   DB	4 DUP(?)
BUFFER	   LABEL BYTE
BYTCNT	   DB	?
ARG_BUF_INDEX DW ?
OPCODE	   DW	?
AWORD	   DB	?
REGMEM	   DB	?
MIDFLD	   DB	?
MODE	   DB	?
NSEG	   DW	?
BRKCNT	   DW	?			; Number of breakpoints
TCOUNT	   DW	?			; Number of steps to trace
ASSEM_CNT  DB	?			; preserve order of assem_cnt and assem1
ASSEM1	   DB	?
ASSEM2	   DB	?
ASSEM3	   DB	?
ASSEM4	   DB	?
ASSEM5	   DB	?
ASSEM6	   DB	?			; preserve order of assemx and bytebuf
BYTEBUF    DB	BUFLEN	DUP (?) 	; Table used by LIST
BPTAB	   DB	BPLEN	DUP (?) 	; Breakpoint table
DIFLG	   DB	?
SIFLG	   DB	?
BXFLG	   DB	?
BPFLG	   DB	?
NEGFLG	   DB	?
NUMFLG	   DB	?			; ZERO MEANS NO NUMBER SEEN
MEMFLG	   DB	?
REGFLG	   DB	?
MOVFLG	   DB	?
TSTFLG	   DB	?
SEGFLG	   DB	?
LOWNUM	   DW	?
HINUM	   DW	?
F8087	   DB	?
DIRFLG	   DB	?
	   DB	BUFFER+BUFSIZ-$ DUP (?)

DATAEND    LABEL WORD

DATA	   ENDS
	   END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debcom1.asm ===
PAGE    60,132
	TITLE	DEBCOM1.ASM - PART1 DEBUGGER COMMANDS	PC DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DECOM1.asm
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH A TOOL FOR DEBUGGING PROGRAMS.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM2 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS ROUTINES CALLED BY DEBUG
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- IMPLEMENT > 32MB SUPPORT	DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================

; Routines to perform debugger commands except ASSEMble and UASSEMble

	IF1
           ;%out COMPONENT=DEBUG, MODULE=DEBCOM1
	ENDIF
.XLIST
.XCREF
	include syscall.inc		; cas -- missing equates
	include version.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
        INCLUDE debug.inc
.CREF
.LIST

CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	SYNERR_PTR:BYTE
	EXTRN	DISPB:WORD,DSIZ:BYTE,DSSAVE:WORD
	IF	SYSVER
	    EXTRN   CIN:DWORD,PFLAG:BYTE
	ENDIF
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	DEFLEN:WORD,BYTEBUF:BYTE,DEFDUMP:BYTE
	EXTRN	ARG_BUF:BYTE,ARG_BUF_PTR:BYTE
	EXTRN	ONE_CHAR_BUF:BYTE,ONE_CHAR_BUF_PTR:WORD
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	PUBLIC	HEXCHK,GETHEX1,PRINT,DSRANGE,ADDRESS,HEXIN,PERROR
	PUBLIC	GETHEX,GET_ADDRESS,GETEOL,GETHX,PERR
	PUBLIC	PERR,MOVE,DUMP,ENTERDATA,FILL,SEARCH,DEFAULT
ifdef JAPAN
	public	SETDUMPMODE
	extrn	test_lead:near
endif
	IF	SYSVER
	    PUBLIC  IN
	    EXTRN   DISPREG:NEAR,DEVIOCALL:NEAR
	ENDIF
	EXTRN	CRLF:NEAR,OUTDI:NEAR,OUTSI:NEAR,SCANP:NEAR
	EXTRN	SCANB:NEAR,BLANK:NEAR,TAB:NEAR,COMMAND:NEAR
	EXTRN	HEX:NEAR,BACKUP:NEAR
	EXTRN	PRINTF_CRLF:NEAR,HEX_ADDRESS_ONLY:NEAR,HEX_ADDRESS_STR:NEAR
	EXTRN	STD_PRINTF:NEAR
DEBCOM1:
; RANGE - Looks for parameters defining an address range.
; The first parameter is the starting address. The second parameter
; may specify the ending address, or it may be preceded by
; "L" and specify a length (4 digits max), or it may be
; omitted and a length of 128 bytes is assumed. Returns with
; segment in AX, displacement in DX, and length in CX.
DSRANGE:
	MOV	BP,[DSSAVE]		; Set default segment to DS
	MOV	[DEFLEN],128		; And default length to 128 bytes
RANGE:
	CALL	ADDRESS

	PUSH	AX			; Save segment
	PUSH	DX			; Save offset
	CALL	SCANP			; Get to next parameter

	MOV	AL,[SI]
	CMP	AL,UPPER_L		; Length indicator?
	JE	GETLEN

	MOV	DX,[DEFLEN]		; Default length
	CALL	HEXIN			; Second parameter present?

	JC	GETDEF			; If not, use default

	MOV	CX,4
	CALL	GETHEX			; Get ending address (same segment)

	MOV	CX,DX			; Low 16 bits of ending addr.
	POP	DX			; Low 16 bits of starting addr.
	SUB	CX,DX			; Compute range
	JAE	DSRNG2

DSRNG1:
	JMP	PERROR			; Negative range
DSRNG2:
	INC	CX			; Include last location
;	JCXZ	DSRNG1			; Wrap around error
;	Removing this instruction allows 0 FFFF to valid range
	POP	AX			; Restore segment
	RET
GETDEF:
	POP	CX			; get original offset
	PUSH	CX			; save it
	NEG	CX			; rest of segment
	JZ	RNGRET			; use default

	CMP	CX,DX			; more room in segment?
	JAE	RNGRET			; yes, use default

	JMP	short RNGRET1 		; no, length is in CX

GETLEN:
	INC	SI			; Skip over "L" to length
	MOV	CX,4			; Length may have 4 digits
	CALL	GETHEX			; Get the range

RNGRET:
	MOV	CX,DX			; Length
RNGRET1:
	POP	DX			; Offset
	MOV	AX,CX
	ADD	AX,DX
	JNC	OKRET

	CMP	AX,1
	JAE	DSRNG1			; Look for wrap error

OKRET:
	POP	AX			; Segment
	RET
DEFAULT:
; DI points to default address and CX has default length
	CALL	SCANP

	JZ	USEDEF			; Use default if no parameters

	MOV	[DEFLEN],CX
	CALL	RANGE

	JMP	GETEOL

USEDEF:
	MOV	SI,DI
	LODSW				; Get default displacement
	MOV	DX,AX
	LODSW				; Get default segment
	RET

ifdef JAPAN
;
;	Set Dump mode to Kanji or Ascii
;
dump_mode	db	0
dbcs_flag	db	0
dbcs_adj	db	0

SETDUMPMODE:
	call	scanp			; get parameter
	jz	dm_err			; if none
	lodsb
	cmp	al,'K'			; is it for Kanji mode
	jnz	@f			; no
	call	geteol
	mov	cs:dump_mode,1		; set Kanji mode
	jmp	short dm_ret
@@:
	cmp	al,'A'			; is it for Ascii mode
	jnz	@f			; no
	call	geteol
	mov	cs:dump_mode,0		; set Ascii mode
	jmp	short dm_ret
@@:
dm_err:
	jmp	PERR
dm_ret:
	ret
endif

; Dump an area of memory in both hex and ASCII
DUMP:
ifdef JAPAN
	mov	cs:dbcs_flag,0
	mov	cs:dbcs_adj,0
endif

	MOV	BP,[DSSAVE]
	MOV	CX,DISPB
	MOV	DI,OFFSET DG:DEFDUMP
	CALL	DEFAULT 		; Get range if specified

	MOV	DS,AX			; Set segment
	ASSUME	DS:NOTHING

	MOV	SI,DX			; SI has displacement in segment
	PUSH	SI			; save SI away
	MOV	AL,DSIZ
	XOR	AH,AH
	XOR	AX,-1
	AND	SI,AX			; convert to para number
	MOV	DI,OFFSET DG:ARG_BUF	; Build the output str in arg_buf
	CALL	OUTSI			; display location

	POP	SI			; get SI back
; Determine where the registers display should begin.
	MOV	AX,SI			; move offset
	MOV	AH,3			; spaces per byte
	AND	AL,DSIZ 		; convert to real offset
	MUL	AH			; 3 char positions per byte of output
	OR	AL,AL			; at beginning?
	JZ	INROW			; if so, then no movement.

	PUSH	CX
	MOV	CX,AX
	CALL	TAB

	POP	CX
INROW:
	PUSH	SI			; Save address for ASCII dump
BYTE0:
	CALL	BLANK			; Space between bytes
BYTE1:
	LODSB				; Get byte to dump
	CALL	HEX			; and display it

	POP	DX			; DX has start addr. for ASCII dump
	DEC	CX			; Drop loop count
	JZ	ASCII			; If through do ASCII dump

	MOV	AX,SI
	TEST	AL,DSIZ 		; On row boundary?
	JZ	ENDROW

	PUSH	DX			; Didn't need ASCII addr. yet
	TEST	AL,7			; On 8-byte boundary?
	JNZ	BYTE0

	MOV	AL,CHAR_MINUS		; Mark every 8 bytes with "-"
	STOSB
	JMP	SHORT BYTE1

ENDROW:
	CALL	ASCII			; Show it in ASCII

	MOV	DI,OFFSET DG:ARG_BUF	; Build the output str in arg_buf
	CALL	OUTSI			; Get the address at start of line

	JMP	INROW			; Loop until count is zero

; Produce a dump of the ascii text characters.	We take the current SI which
; contains the byte after the last one dumped.	From this we determine how
; many spaces we need to output to get to the ascii column.  Then we look at
; the beginning address of the dump to tsee how many spaces we need to indent.
ASCII:
	PUSH	CX			; Save count of remaining bytes
; Determine how many spaces to go until the ASCII column.
	MOV	AX,SI			; get offset of next byte
	DEC	AL
	AND	AL,DSIZ
	INC	AL
; AX now has the number of bytes that we have displayed:  1 to Dsiz+1.
; Compute characters remaining to be displayed.  We *always* put the ASCII
; dump in column 51 (or whereever)
	SUB	AL,10H			; get negative of number
	DEC	AL			;
	NEG	AL			; convert to positive
	CBW				; convert to word
; 3 character positions for each byte displayed.
	MOV	CX,AX
	SHL	AX,1
	ADD	CX,AX
; Compute indent for ascii dump
	MOV	AX,DX
	AND	AL,DSIZ
	XOR	AH,AH
	ADD	CX,AX
; Tab over
	CALL	TAB

; Set up for true dump
	MOV	CX,SI
	MOV	SI,DX
	SUB	CX,SI
ASCDMP:
	LODSB				; Get ASCII byte to dump

ifdef JAPAN
	cmp	cs:dbcs_flag,1
	jz	set_dbcs		; if it was lead byte
	cmp	cs:dbcs_flag,2
	jnz	@f			; if it was not tail byte
	mov	cs:dbcs_flag,0		; reset
@@:
	call	test_lead
	jnc	@f			; if this is not lead byte
	cmp	byte ptr [si],CHAR_BLANK
	jae	set_dbcs		; if tail byte is not control corde
	mov	al,CHAR_PERIOD
	jmp	short @f
set_dbcs:
	inc	cs:dbcs_flag
@@:
	cmp	cs:dump_mode,1
	jnz	@f			; if not Kanji mode
	cmp	cs:dbcs_adj,1
	jnz	kanjiprt		; if no need to adjust
	mov	al,' '			; tail byte is displayed already
	mov	cs:dbcs_adj,0
	jmp	short kanjiprt
@@:
endif

	CMP	AL,CHAR_RUBOUT
	JAE	NOPRT			; Don't print RUBOUT or above

ifdef JAPAN
kanjiprt:
endif

	CMP	AL,CHAR_BLANK
	JAE	PRIN			; print space through RUBOUT-1

NOPRT:
	MOV	AL,CHAR_PERIOD		; If unprintable character
PRIN:
	STOSB
	LOOP	ASCDMP			; CX times

ifdef JAPAN
	cmp	cs:dump_mode,1
	jnz	@f			; if not Kanji mode
	cmp	cs:dbcs_flag,1
	jnz	@f			; if not ended with lead byte
	mov	al,[si]			; get tail byte
	stosb
	mov	cs:dbcs_adj,1
@@:
endif

	MOV	AL,0
	STOSB
	PUSH	DS
	PUSH	CS
	POP	DS
	ASSUME	DS:DG

	CALL	HEX_ADDRESS_STR

	CALL	CRLF

	POP	DS
	ASSUME	DS:NOTHING

	POP	CX			; Restore overall dump len
	MOV	WORD PTR [DEFDUMP],SI
	MOV	WORD PTR [DEFDUMP+WORD],DS ; Save last address as def
	RET

	ASSUME	DS:DG
; Block move one area of memory to another Overlapping moves are performed
; correctly, i.e., so that a source byte is not overwritten until after it has
; been moved.
MOVE:
	CALL	DSRANGE 		; Get range of source area

	PUSH	CX			; Save length
	PUSH	AX			; Save segment
	PUSH	DX			; Save source displacement
	CALL	ADDRESS 		; Get destination address (sam

	CALL	GETEOL			; Check for errors

	POP	SI
	MOV	DI,DX			; Set dest. displacement
	POP	BX			; Source segment
	MOV	DS,BX
	MOV	ES,AX			; Destination segment
	POP	CX			; Length
	CMP	DI,SI			; Check direction of move
	SBB	AX,BX			; Extend the CMP to 32 bits
	JB	COPYLIST		; Move forward into lower mem.

; Otherwise, move backward. Figure end of source and destination
; areas and flip direction flag.
	DEC	CX
	ADD	SI,CX			; End of source area
	ADD	DI,CX			; End of destination area
	STD				; Reverse direction
	INC	CX
COPYLIST:
	MOVSB				; Do at least 1 - Range is 1-1
	DEC	CX
	REP	MOVSB			; Block move
RET1:
	RET

; Fill an area of memory with a list values. If the list
; is bigger than the area, don't use the whole list. If the
; list is smaller, repeat it as many times as necessary.
FILL:
	CALL	DSRANGE 		; Get range to fill

	PUSH	CX			; Save length
	PUSH	AX			; Save segment number
	PUSH	DX			; Save displacement
	CALL	LIST			; Get list of values to fill w

	POP	DI			; Displacement in segment
	POP	ES			; Segment
	POP	CX			; Length
	CMP	BX,CX			; BX is length of fill list
	MOV	SI,OFFSET DG:BYTEBUF	; List is in byte buffer
	JCXZ	BIGRNG

	JAE	COPYLIST		; If list is big, copy part of

BIGRNG:
	SUB	CX,BX			; How much bigger is area than
	XCHG	CX,BX			; CX=length of list
	PUSH	DI			; Save starting addr. of area
	REP	MOVSB			; Move list into area
	POP	SI
; The list has been copied into the beginning of the
; specified area of memory. SI is the first address
; of that area, DI is the end of the copy of the list
; plus one, which is where the list will begin to repeat.
; All we need to do now is copy [SI] to [DI] until the
; end of the memory area is reached. This will cause the
; list to repeat as many times as necessary.
	MOV	CX,BX			; Length of area minus list
	PUSH	ES			; Different index register
	POP	DS			; requires different segment r
	JMP	SHORT COPYLIST		; Do the block move

; Search a specified area of memory for given list of bytes.
; Print address of first byte of each match.
SEARCH:
	CALL	DSRANGE 		; Get area to be searched

	PUSH	CX			; Save count
	PUSH	AX			; Save segment number
	PUSH	DX			; Save displacement
	CALL	LIST			; Get search list

	DEC	BX			; No. of bytes in list-1
	POP	DI			; Displacement within segment
	POP	ES			; Segment
	POP	CX			; Length to be searched
	SUB	CX,BX			;  minus length of list
SCAN:
	MOV	SI,OFFSET DG:BYTEBUF	; List kept in byte buffer
	LODSB				; Bring first byte into AL
DOSCAN:
	SCASB				; Search for first byte
	LOOPNE	DOSCAN			; Do at least once by using LO

	JNZ	RET1			; Exit if not found

	PUSH	BX			; Length of list minus 1
	XCHG	BX,CX
	PUSH	DI			; Will resume search here
	REPE	CMPSB			; Compare rest of string
	MOV	CX,BX			; Area length back in CX
	POP	DI			; Next search location
	POP	BX			; Restore list length
	JNZ	TTEST			 ; Continue search if no match

	DEC	DI			; Match address
	CALL	OUTDI			; Print it

	INC	DI			; Restore search address
	CALL	HEX_ADDRESS_ONLY	; Print the addresss

	CALL	CRLF

TTEST:
	JCXZ	RET1

	JMP	SHORT SCAN		; Look for next occurrence

; Get the next parameter, which must be a hex number.
; CX is maximum number of digits the number may have.

;=========================================================================
; GETHX: This routine calculates the binary representation of an address
;	 entered in ASCII by a user.  GETHX has been modified to provide
;	 support for sector addresses > 32mb.  To do this the bx register
;	 has been added to provide a 32 bit address.  BX is the high word
;	 and DX is the low word.  For routines that rely on DX for a 16
;	 bit address, the use of BX will have no effect.
;
;	Date	   : 6/16/87
;=========================================================================

GETHX:
	CALL	SCANP
GETHX1:
	XOR	DX,DX			; Initialize the number
	xor	bx,bx			;an000;initialize high word for
					;      sector address
	CALL	HEXIN			; Get a hex digit

	JC	HXERR			; Must be one valid digit

	MOV	DL,AL			; First 4 bits in position
GETLP:
	INC	SI			; Next char in buffer
	DEC	CX			; Digit count
	CALL	HEXIN			; Get another hex digit?

	JC	RETHX			; All done if no more digits

	STC
	JCXZ	HXERR			; Too many digits?


	call	ADDRESS_32_BIT		;an000;multiply by 32
	JMP	SHORT GETLP		; Get more digits

GETHEX:
	CALL	GETHX			; Scan to next parameter

	JMP	SHORT GETHX2

GETHEX1:
	CALL	GETHX1
GETHX2:
	JC	PERROR
RETHX:
	CLC
HXERR:
	RET

; Check if next character in the input buffer is a hex digit
; and convert it to binary if it is. Carry set if not.
HEXIN:
	MOV	AL,[SI]
; Check if AL  is a hex digit and convert it to binary if it
; is. Carry set if not.
HEXCHK:
	SUB	AL,CHAR_ZERO		; Kill ASCII numeric bias
	JC	RET2

	CMP	AL,10
	CMC
	JNC	RET2			; OK if 0-9

	AND	AL,5FH
	SUB	AL,7			; Kill A-F bias
	CMP	AL,10
	JC	RET2

	CMP	AL,16
	CMC
RET2:
	RET

; Process one parameter when a list of bytes is
; required. Carry set if parameter bad. Called by LIST.
LISTITEM:
	CALL	SCANP			; Scan to parameter

	CALL	HEXIN			; Is it in hex?

	JC	STRINGCHK		; If not, could be a string

	MOV	CX,2			; Only 2 hex digits for bytes
	push	bx			;an000;save it - we stomp it
	CALL	GETHEX			; Get the byte value
	pop	bx			;an000;restore it

	MOV	[BX],DL 		; Add to list
	INC	BX
GRET:
	CLC				; Parameter was OK
	RET

STRINGCHK:
	MOV	AL,[SI] 		; Get first character of param
	CMP	AL,SINGLE_QUOTE 	; String?
	JZ	STRING

	CMP	AL,DOUBLE_QUOTE 	; Either quote is all right
	JZ	STRING

	STC				; Not string, not hex - bad
	RET
STRING:
	MOV	AH,AL			; Save for closing quote
	INC	SI
STRNGLP:
	LODSB				; Next char of string
	CMP	AL,CR			; Check for end of line
	JZ	PERR			; Must find a close quote

	CMP	AL,AH			; Check for close quote
	JNZ	STOSTRG 		; Add new character to list

	CMP	AH,[SI] 		; Two quotes in a row?
	JNZ	GRET			; If not, we're done

	INC	SI			; Yes - skip second one
STOSTRG:
	MOV	[BX],AL 		; Put new char in list
	INC	BX
	JMP	SHORT STRNGLP		; Get more characters

; Get a byte list for ENTER, FILL or SEARCH. Accepts any number
; of 2-digit hex values or character strings in either single
; (') or double (") quotes.
LIST:
	MOV	BX,OFFSET DG:BYTEBUF	; Put byte list in the byte buffer
LISTLP:
	CALL	LISTITEM		; Process a parameter

	JNC	LISTLP			; If OK, try for more

	SUB	BX,OFFSET DG:BYTEBUF	; BX now has no. of bytes in list
	JZ	PERROR			; List must not be empty

; Make sure there is nothing more on the line except for
; blanks and carriage return. If there is, it is an
; unrecognized parameter and an error.
GETEOL:
	CALL	SCANB			; Skip blanks

	JNZ	PERROR			; Better be a RETURN
RET3:
	RET

; Command error.  SI has been incremented beyond the command letter so it must
; decremented for the error pointer to work.
PERR:
	DEC	SI
; Syntax error.  SI points to character in the input buffer which caused
; error.  By subtracting from start of buffer, we will know how far to tab
; over to appear directly below it on the terminal.  Then print "^ Error".
PERROR:
	SUB	SI,OFFSET DG:(BYTEBUF-1) ; How many char processed so far?
	MOV	CX,SI			; Parameter for TAB in CX
	MOV	DI,OFFSET DG:ARG_BUF	;
	CALL	TAB			; Directly below bad char

	MOV	BYTE PTR [DI],0 	; nul terminate the tab
	MOV	DX,OFFSET DG:SYNERR_PTR ; Error message
; Print error message and abort to command level
PRINT:
	CALL	PRINTF_CRLF

	JMP	COMMAND

; Gets an address in Segment:Displacement format. Segment may be omitted
; and a default (kept in BP) will be used, or it may be a segment
; register (DS, ES, SS, CS). Returns with segment in AX, OFFSET in DX.
ADDRESS:
	CALL	GET_ADDRESS

	JC	PERROR

ADRERR:
	STC
	RET

GET_ADDRESS:
	CALL	SCANP

	MOV	AL,[SI+1]
	CMP	AL,UPPER_S
	JZ	SEGREG

	MOV	CX,4
	CALL	GETHX

	JC	ADRERR

	MOV	AX,BP			; Get default segment
	CMP	BYTE PTR [SI],CHAR_COLON
	JNZ	GETRET

	PUSH	DX
GETDISP:
	INC	SI			; Skip over ":"
	MOV	CX,4
	CALL	GETHX

	POP	AX
	JC	ADRERR

GETRET:
	CLC
	RET

SEGREG:
	MOV	AL,[SI]
	MOV	DI,OFFSET DG:SEGLET	; SEGLET  DB  "CSED"
	MOV	CX,4
	REPNE	SCASB
	JNZ	ADRERR

	INC	SI
	INC	SI
	SHL	CX,1
	MOV	BX,CX
	CMP	BYTE PTR [SI],CHAR_COLON
	JNZ	ADRERR

	PUSH	[BX+DSSAVE]
	JMP	SHORT GETDISP

SEGLET	DB	"CSED"			; First letter of each of the segregs: CS,SS,ES,DS

; Short form of ENTER command. A list of values from the
; command line are put into memory without using normal
; ENTER mode.
GETLIST:
	CALL	LIST			; Get the bytes to enter

	POP	DI			; Displacement within segment
	POP	ES			; Segment to enter into
	MOV	SI,OFFSET DG:BYTEBUF	; List of bytes is in byte buffer
	MOV	CX,BX			; Count of bytes
	REP	MOVSB			; Enter that byte list
	RET

; Enter values into memory at a specified address.  If the line contains
; nothing but the address we go into "enter mode", where the address and its
; current value are printed and the user may change it if desired.  To change,
; type in new value in hex.  Backspace works to correct errors.  If an illegal
; hex digit or too many digits are typed, the bell is sounded but it is
; otherwise ignored.  To go to the next byte (with or without change), hit
; space bar.  To back CLDto a previous address, type "-".  On every 8-byte
; boundary a new line is started and the address is printed.  To terminate
; command, type carriage return.
;  Alternatively, the list of bytes to be entered may be included on the
; original command line immediately following the address.  This is in regular
; LIST format so any number of hex values or strings in quotes may be entered.
ENTERDATA:
	MOV	BP,[DSSAVE]		; Set default segment to DS
	CALL	ADDRESS

	PUSH	AX			; Save for later
	PUSH	DX
	CALL	SCANB			; Any more parameters?

	JNZ	GETLIST 		; If not end-of-line get list

	POP	DI			; Displacement of ENTER
	POP	ES			; Segment
GETROW:
	CALL	OUTDI			; Print address of entry

	PUSH	DI
	PUSH	ES
	PUSH	DS
	POP	ES
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	BLANK

	XOR	AL,AL
	STOSB
	CALL	HEX_ADDRESS_STR

	POP	ES
	POP	DI
GETBYTE:
	MOV	AL,ES:[DI]		; Get current value
	PUSH	DI
	PUSH	ES
	PUSH	DS
	POP	ES
	MOV	DI,OFFSET DG:ARG_BUF
	CALL	HEX			; And display it

	MOV	AL,CHAR_PERIOD
	STOSB
	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:ARG_BUF_PTR
	CALL	STD_PRINTF

	POP	ES
	POP	DI
LOOK_AGAIN:
	MOV	CX,2			; Max of 2 digits in new value
	MOV	DX,0			; Intial new value
GETDIG:
	CALL	INPT			; Get digit from user

	MOV	AH,AL			; Save
	CALL	HEXCHK			; Hex digit?

	XCHG	AH,AL			; Need original for echo
	JC	NOHEX			; If not, try special command

	MOV	DH,DL			; Rotate new value
	MOV	DL,AH			; And include new digit
	LOOP	GETDIG			; At most 2 digits

; We have two digits, so all we will accept now is a command.
DWAIT:
	CALL	INPT			; Get command character
NOHEX:
	CMP	AL,CHAR_BACKSPACE	; Backspace
	JZ	BS

	CMP	AL,CHAR_RUBOUT		; RUBOUT
	JZ	RUB

	CMP	AL,CHAR_MINUS		; Back up to previous address
	JZ	PREV

	CMP	AL,CR			; All done with command?
	JZ	EOL

	CMP	AL,CHAR_BLANK		; Go to next address
	JZ	NEXT

	MOV	AL,CHAR_BACKSPACE
	CALL	OUT_CHAR		; Back up over illegal character

	CALL	BACKUP

	JCXZ	DWAIT

	JMP	SHORT GETDIG

RUB:
	MOV	AL,CHAR_BACKSPACE
	CALL	OUT_char
BS:
	CMP	CL,2			; CX=2 means nothing typed yet
	JZ	PUTDOT			; Put back the dot we backed up over

	INC	CL			; Accept one more character
	MOV	DL,DH			; Rotate out last digit
	MOV	DH,CH			; Zero this digit
	CALL	BACKUP			; Physical backspace

	JMP	SHORT GETDIG		; Get more digits

PUTDOT:
	MOV	AL,CHAR_PERIOD
	CALL	OUT_CHAR

	JMP	LOOK_AGAIN

; If new value has been entered, convert it to binary and
; put into memory. Always bump pointer to next location
STORE:
	CMP	CL,2			; CX=2 means nothing typed yet
	JZ	NOSTO			; So no new value to store

; Rotate DH left 4 bits to combine with DL and make a byte value
	PUSH	CX
	MOV	CL,4
	SHL	DH,CL
	POP	CX
	OR	DL,DH			; Hex is now converted to binary
	MOV	ES:[DI],DL		; Store new value
NOSTO:
	INC	DI			; Prepare for next location
	RET

NEXT:
	CALL	STORE			; Enter new value

	INC	CX			; Leave a space plus two for
	INC	CX			;  each digit not entered
	PUSH	DI
	MOV	DI,OFFSET DG:ARG_BUF
	PUSH	ES
	PUSH	DS
	POP	ES
	CALL	TAB

	XOR	AL,AL
	STOSB
	MOV	DX,OFFSET DG:ARG_BUF_PTR
	CALL	STD_PRINTF

	POP	ES
	POP	DI
	MOV	AX,DI			; Next memory address
	AND	AL,7			; Check for 8-byte boundary
	JZ	NEWROW			; Take 8 per line

	JMP	GETBYTE

NEWROW:
	CALL	CRLF			; Terminate line

	JMP	GETROW			; Print address on new line

PREV:
	CALL	STORE			; Enter the new value

; DI has been bumped to next byte. Drop it 2 to go to previous addr
	DEC	DI
	DEC	DI
	JMP	SHORT NEWROW		; Terminate line after backing	 CLD

EOL:
	CALL	STORE			; Enter the new value

	JMP	CRLF			; CR/LF and terminate

; Console input of single character
	IF	SYSVER
INPT:					  ;*** change for build - label to inpt
	    PUSH    DS
	    PUSH    SI
	    LDS     SI,CS:[CIN]
	    MOV     AH,4
	    CALL    DEVIOCALL

	    POP     SI
	    POP     DS
	    CMP     AL,3
	    JNZ     NOTCNTC

	    INT     VEC_CTRL_BREAK	;23H

NOTCNTC:
	    CMP     AL,UPPER_P - CHAR_AT_SIGN
	    JZ	    PRINTON

	    CMP     AL,UPPER_N - CHAR_AT_SIGN
	    JZ	    PRINTOFF

	    CALL    OUT_CHAR

	    RET

PRINTOFF:
PRINTON:
	    NOT     [PFLAG]
	    JMP     SHORT IN

	ELSE
INPT:				; Change label for build
	    MOV     AH,Std_Con_Input ;OPTION=1, STANDARD CONSOLE INPUT
	    INT     21H

	    RET

	ENDIF
OUT_CHAR:
	PUSH	DI
	PUSH	DX
	PUSH	ES
	PUSH	DS
	POP	ES
	MOV	DI,OFFSET DG:ONE_CHAR_BUF
	STOSB
	MOV	AL,0
	STOSB
	MOV	DX,OFFSET DG:ONE_CHAR_BUF_PTR
	CALL	STD_PRINTF

	POP	ES
	POP	DX
	POP	DI
	RET

;=========================================================================
; ADDRESS_32_BIT: This routine will build an address for 32bit sector
;		  addressibility.  BX will be the high word, with DX being
;		  the low word.
;
;	Inputs : DX/BX - registers to contain 32bit sector address
;		 DX & BX are both initialized to 0 on first call to routine.
;
;	Outputs: DX/BX - registers to contain 32bit sector address
;
;	Date	  : 6/16/87
;=========================================================================

ADDRESS_32_BIT	proc	near			;an000;perform 32 bit address
						;      creation
	push	cx				;an000;save affected regs.
	mov	cx,04h				;an000;initialize to
						;      nibble shift
;	$do					;an000;while cx not= 0
$$DO1:
		cmp	cx,00h			;an000;are we done?
;		$leave	e			;an000;yes, quit loop
		JE $$EN1
		shl	bx,1			;an000;shift bx 1 bit
		shl	dx,1			;an000;shift dx 1 bit
;		$if	c			;an000;did low word carry
		JNC $$IF3
			or	bx,01h		;an000;set bit 0 of high word
;		$endif				;an000;
$$IF3:
		dec	cx			;an000;decrease counter
;	$enddo					;an000;end while loop
	JMP SHORT $$DO1
$$EN1:
	or	dl,	al			;an000;overlay low word
						;      bits 0-3 with next
						;      portion of the address
	pop	cx				;an000;restore affected regs.

	ret					;an000;return to caller

ADDRESS_32_BIT	endp				;an000;end proc



CODE	ENDS
	END	DEBCOM1

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debconst.asm ===
;**************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;   Change Log:
;
;     Date    Who   #                   Description
;   --------  ---  ---  ------------------------------------------------------
;   04/01/90  DIC  C01  These variables are used to determine if enough memory
;                       is available to write a file out to disk. (Compaq STR
;                       #1889) (MS Bug #774)
;*****************************************************************************/
           PAGE    80,132 ;
	   TITLE DEBCONST.ASM
	   IF1
	       %OUT COMPONENT=DEBUG, MODULE=DEBCONST
	   ENDIF
.XLIST
.XCREF
include	version.inc		; cas -- missing equates
include	syscall.inc		; cas -- missing equates
INCLUDE    DOSSYM.INC
INCLUDE    debug.inc
.LIST
.CREF

CODE	   SEGMENT PUBLIC BYTE
CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE
CONST	   ENDS

CSTACK	   SEGMENT STACK
CSTACK	   ENDS

DATA	   SEGMENT PUBLIC BYTE
DATA	   ENDS

DG	   GROUP CODE,CONST,CSTACK,DATA

CODE	   SEGMENT PUBLIC  BYTE

	   EXTRN ALUFROMREG:NEAR, ALUTOREG:NEAR, ACCIMM:NEAR, SEGOP:NEAR
	   EXTRN ESPRE:NEAR, SSPRE:NEAR, CSPRE:NEAR, DSPRE:NEAR
	   EXTRN REGOP:NEAR, NOOPERANDS:NEAR, SAVHEX:NEAR, SHORTJMP:NEAR
	   EXTRN MOVSEGTO:NEAR, WORDTOALU:NEAR, MOVSEGFROM:NEAR
	   EXTRN GETADDR:NEAR, XCHGAX:NEAR, LONGJMP:NEAR, LOADACC:NEAR
	   EXTRN STOREACC:NEAR, REGIMMB:NEAR, SAV16:NEAR, MEMIMM:NEAR
	   EXTRN INT3:NEAR, SAV8:NEAR, CHK10:NEAR, M8087:NEAR
	   EXTRN M8087_D9:NEAR, M8087_DB:NEAR, M8087_DD:NEAR
	   EXTRN M8087_DF:NEAR, INFIXB:NEAR, INFIXW:NEAR, OUTFIXB:NEAR
	   EXTRN OUTFIXW:NEAR, JMPCALL:NEAR, INVARB:NEAR, INVARW:NEAR
	   EXTRN OUTVARB:NEAR, OUTVARW:NEAR, PREFIX:NEAR, IMMED:NEAR
	   EXTRN SIGNIMM:NEAR, SHIFT:NEAR, SHIFTV:NEAR, GRP1:NEAR
	   EXTRN GRP2:NEAR, REGIMMW:NEAR, DOORG:NEAR


	   EXTRN DB_OPER:NEAR, DW_OPER:NEAR, ASSEMLOOP:NEAR, GROUP2:NEAR
	   EXTRN NO_OPER:NEAR, GROUP1:NEAR, FGROUPP:NEAR, FGROUPX:NEAR
	   EXTRN FGROUPZ:NEAR, FD9_OPER:NEAR, FGROUPB:NEAR, FGROUP:NEAR
	   EXTRN FGROUPDS:NEAR, DCINC_OPER:NEAR, INT_OPER:NEAR
	   EXTRN IN_OPER:NEAR, DISP8_OPER:NEAR, JMP_OPER:NEAR, L_OPER:NEAR
	   EXTRN MOV_OPER:NEAR, OUT_OPER:NEAR, PUSH_OPER:NEAR
	   EXTRN GET_DATA16:NEAR, FGROUP3:NEAR, FGROUP3W:NEAR
	   EXTRN FDE_OPER:NEAR, ESC_OPER:NEAR, AA_OPER:NEAR
	   EXTRN CALL_OPER:NEAR, FDB_OPER:NEAR, POP_OPER:NEAR, ROTOP:NEAR
	   EXTRN TST_OPER:NEAR, EX_OPER:NEAR

CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE

	   PUBLIC REG8, REG16, SREG, SIZ8, DISTAB, DBMN, ADDMN, ADCMN, SUBMN
	   PUBLIC SBBMN, XORMN, ORMN, ANDMN, AAAMN, AADMN, AASMN, CALLMN, CBWMN
	   PUBLIC UPMN, DIMN, CMCMN, CMPMN, CWDMN, DAAMN, DASMN, DECMN, DIVMN
	   PUBLIC ESCMN, HLTMN, IDIVMN, IMULMN, INCMN, INTOMN, INTMN, INMN
	   PUBLIC IRETMN, JAMN, JCXZMN, JNCMN, JBEMN, JZMN, JGEMN, JGMN, JLEMN
	   PUBLIC JLMN, JMPMN, JNZMN, JPEMN, JNZMN, JPEMN, JPOMN, JNSMN, JNOMN
	   PUBLIC JOMN, JSMN, LAHFMN, LDSMN, LEAMN, LESMN, LOCKMN, LODBMN
	   PUBLIC LODWMN, LOOPNZMN, LOOPZMN, LOOPMN, MOVBMN, MOVWMN, MOVMN
	   PUBLIC MULMN, NEGMN, NOPMN, NOTMN, OUTMN, POPFMN, POPMN, PUSHFMN
	   PUBLIC PUSHMN, RCLMN, RCRMN, REPZMN, REPNZMN, RETFMN, RETMN, ROLMN
	   PUBLIC RORMN, SAHFMN, SARMN, SCABMN, SCAWMN, SHLMN, SHRMN, STCMN
	   PUBLIC DOWNMN, EIMN, STOBMN, STOWMN, TESTMN, WAITMN, XCHGMN, XLATMN
	   PUBLIC ESSEGMN, CSSEGMN, SSSEGMN, DSSEGMN, BADMN

	   PUBLIC M8087_TAB, FI_TAB, SIZE_TAB, MD9_TAB, MD9_TAB2, MDB_TAB
	   PUBLIC MDB_TAB2, MDD_TAB, MDD_TAB2, MDF_TAB, OPTAB, MAXOP, SHFTAB
	   PUBLIC IMMTAB, GRP1TAB, GRP2TAB, SEGTAB, REGTAB, REGTABEND, FLAGTAB
	   PUBLIC STACK

           PUBLIC DriveOfFile,FileSizeHB,FileSizeLB,TempLB,TempHB     ;C01

	   PUBLIC AXSAVE, BXSAVE, CXSAVE, DXSAVE, BPSAVE, SPSAVE, SISAVE
	   PUBLIC DISAVE, DSSAVE, ESSAVE, SSSAVE, CSSAVE, IPSAVE, FLSAVE, RSTACK
	   PUBLIC REGDIF, RDFLG, TOTREG, DSIZ, NOREGL, DISPB, LBUFSIZ, LBUFFCNT
	   PUBLIC LINEBUF, PFLAG, COLPOS, RSETFLAG

	   IF	SYSVER
	   PUBLIC CONFCB, POUT, COUT, CIN, IOBUFF, IOADDR, IOCALL, IOCOM
	   PUBLIC IOSTAT, IOCHRET, IOSEG, IOCNT
	   ENDIF

	   PUBLIC QFLAG, NEWEXEC, RETSAVE, USER_PROC_PDB, HEADSAVE, EXEC_BLOCK
	   PUBLIC COM_LINE, COM_FCB1, COM_FCB2, COM_SSSP, COM_CSIP, NEXTCS
	   PUBLIC NEXTIP, NAMESPEC

REG8	   DB	"ALCLDLBLAHCHDHBH"
REG16	   DB	"AXCXDXBXSPBPSIDI"
SREG	   DB	"ESCSSSDS",0,0
SIZ8	   DB	"BYWODWQWTB",0,0
; 0
DISTAB	   DW	OFFSET DG:ADDMN,ALUFROMREG
	   DW	OFFSET DG:ADDMN,ALUFROMREG
	   DW	OFFSET DG:ADDMN,ALUTOREG
	   DW	OFFSET DG:ADDMN,ALUTOREG
	   DW	OFFSET DG:ADDMN,ACCIMM
	   DW	OFFSET DG:ADDMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:POPMN,SEGOP
	   DW	OFFSET DG:ORMN,ALUFROMREG
	   DW	OFFSET DG:ORMN,ALUFROMREG
	   DW	OFFSET DG:ORMN,ALUTOREG
	   DW	OFFSET DG:ORMN,ALUTOREG
	   DW	OFFSET DG:ORMN,ACCIMM
	   DW	OFFSET DG:ORMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:DBMN,SAVHEX		; cas -- this has always been
;						; disassembled as a POP CS,
;						; which doesn't really exist.
;						; It is now a 386 prefix, but
;						; we don't know about 386
;						; instructions, so we'll put
;						; out a DB
; 10H
	   DW	OFFSET DG:ADCMN,ALUFROMREG
	   DW	OFFSET DG:ADCMN,ALUFROMREG
	   DW	OFFSET DG:ADCMN,ALUTOREG
	   DW	OFFSET DG:ADCMN,ALUTOREG
	   DW	OFFSET DG:ADCMN,ACCIMM
	   DW	OFFSET DG:ADCMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:POPMN,SEGOP
	   DW	OFFSET DG:SBBMN,ALUFROMREG
	   DW	OFFSET DG:SBBMN,ALUFROMREG
	   DW	OFFSET DG:SBBMN,ALUTOREG
	   DW	OFFSET DG:SBBMN,ALUTOREG
	   DW	OFFSET DG:SBBMN,ACCIMM
	   DW	OFFSET DG:SBBMN,ACCIMM
	   DW	OFFSET DG:PUSHMN,SEGOP
	   DW	OFFSET DG:POPMN,SEGOP
; 20H
	   DW	OFFSET DG:ANDMN,ALUFROMREG
	   DW	OFFSET DG:ANDMN,ALUFROMREG
	   DW	OFFSET DG:ANDMN,ALUTOREG
	   DW	OFFSET DG:ANDMN,ALUTOREG
	   DW	OFFSET DG:ANDMN,ACCIMM
	   DW	OFFSET DG:ANDMN,ACCIMM
	   DW	OFFSET DG:ESSEGMN,ESPRE
	   DW	OFFSET DG:DAAMN,NOOPERANDS
	   DW	OFFSET DG:SUBMN,ALUFROMREG
	   DW	OFFSET DG:SUBMN,ALUFROMREG
	   DW	OFFSET DG:SUBMN,ALUTOREG
	   DW	OFFSET DG:SUBMN,ALUTOREG
	   DW	OFFSET DG:SUBMN,ACCIMM
	   DW	OFFSET DG:SUBMN,ACCIMM
	   DW	OFFSET DG:CSSEGMN,CSPRE
	   DW	OFFSET DG:DASMN,NOOPERANDS
; 30H
	   DW	OFFSET DG:XORMN,ALUFROMREG
	   DW	OFFSET DG:XORMN,ALUFROMREG
	   DW	OFFSET DG:XORMN,ALUTOREG
	   DW	OFFSET DG:XORMN,ALUTOREG
	   DW	OFFSET DG:XORMN,ACCIMM
	   DW	OFFSET DG:XORMN,ACCIMM
	   DW	OFFSET DG:SSSEGMN,SSPRE
	   DW	OFFSET DG:AAAMN,NOOPERANDS
	   DW	OFFSET DG:CMPMN,ALUFROMREG
	   DW	OFFSET DG:CMPMN,ALUFROMREG
	   DW	OFFSET DG:CMPMN,ALUTOREG
	   DW	OFFSET DG:CMPMN,ALUTOREG
	   DW	OFFSET DG:CMPMN,ACCIMM
	   DW	OFFSET DG:CMPMN,ACCIMM
	   DW	OFFSET DG:DSSEGMN,DSPRE
	   DW	OFFSET DG:AASMN,NOOPERANDS
; 40H
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:INCMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
	   DW	OFFSET DG:DECMN,REGOP
; 50H
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:PUSHMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
	   DW	OFFSET DG:POPMN,REGOP
; 60H
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
; 70H
	   DW	OFFSET DG:JOMN,SHORTJMP
	   DW	OFFSET DG:JNOMN,SHORTJMP
	   DW	OFFSET DG:JCMN,SHORTJMP
	   DW	OFFSET DG:JNCMN,SHORTJMP
	   DW	OFFSET DG:JZMN,SHORTJMP
	   DW	OFFSET DG:JNZMN,SHORTJMP
	   DW	OFFSET DG:JBEMN,SHORTJMP
	   DW	OFFSET DG:JAMN,SHORTJMP
	   DW	OFFSET DG:JSMN,SHORTJMP
	   DW	OFFSET DG:JNSMN,SHORTJMP
	   DW	OFFSET DG:JPEMN,SHORTJMP
	   DW	OFFSET DG:JPOMN,SHORTJMP
	   DW	OFFSET DG:JLMN,SHORTJMP
	   DW	OFFSET DG:JGEMN,SHORTJMP
	   DW	OFFSET DG:JLEMN,SHORTJMP
	   DW	OFFSET DG:JGMN,SHORTJMP
; 80H
	   DW	0,IMMED
	   DW	0,IMMED
	   DW	0,IMMED
	   DW	0,SIGNIMM
	   DW	OFFSET DG:TESTMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:TESTMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:XCHGMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:XCHGMN,ALUTOREG ;ARR 2.4
	   DW	OFFSET DG:MOVMN,ALUFROMREG
	   DW	OFFSET DG:MOVMN,ALUFROMREG
	   DW	OFFSET DG:MOVMN,ALUTOREG
	   DW	OFFSET DG:MOVMN,ALUTOREG
	   DW	OFFSET DG:MOVMN,MOVSEGTO
	   DW	OFFSET DG:LEAMN,WORDTOALU
	   DW	OFFSET DG:MOVMN,MOVSEGFROM
	   DW	OFFSET DG:POPMN,GETADDR
; 90H
	   DW	OFFSET DG:NOPMN,NOOPERANDS
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:XCHGMN,XCHGAX
	   DW	OFFSET DG:CBWMN,NOOPERANDS
	   DW	OFFSET DG:CWDMN,NOOPERANDS
	   DW	OFFSET DG:CALLMN,LONGJMP
	   DW	OFFSET DG:WAITMN,NOOPERANDS
	   DW	OFFSET DG:PUSHFMN,NOOPERANDS
	   DW	OFFSET DG:POPFMN,NOOPERANDS
	   DW	OFFSET DG:SAHFMN,NOOPERANDS
	   DW	OFFSET DG:LAHFMN,NOOPERANDS
; A0H
	   DW	OFFSET DG:MOVMN,LOADACC
	   DW	OFFSET DG:MOVMN,LOADACC
	   DW	OFFSET DG:MOVMN,STOREACC
	   DW	OFFSET DG:MOVMN,STOREACC
	   DW	OFFSET DG:MOVBMN,NOOPERANDS
	   DW	OFFSET DG:MOVWMN,NOOPERANDS
	   DW	OFFSET DG:CMPBMN,NOOPERANDS
	   DW	OFFSET DG:CMPWMN,NOOPERANDS
	   DW	OFFSET DG:TESTMN,ACCIMM
	   DW	OFFSET DG:TESTMN,ACCIMM
	   DW	OFFSET DG:STOBMN,NOOPERANDS
	   DW	OFFSET DG:STOWMN,NOOPERANDS
	   DW	OFFSET DG:LODBMN,NOOPERANDS
	   DW	OFFSET DG:LODWMN,NOOPERANDS
	   DW	OFFSET DG:SCABMN,NOOPERANDS
	   DW	OFFSET DG:SCAWMN,NOOPERANDS
; B0H
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMB
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
	   DW	OFFSET DG:MOVMN,REGIMMW
; C0H
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:RETMN,SAV16
	   DW	OFFSET DG:RETMN,NOOPERANDS
	   DW	OFFSET DG:LESMN,WORDTOALU
	   DW	OFFSET DG:LDSMN,WORDTOALU
	   DW	OFFSET DG:MOVMN,MEMIMM
	   DW	OFFSET DG:MOVMN,MEMIMM
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:RETFMN,SAV16
	   DW	OFFSET DG:RETFMN,NOOPERANDS
	   DW	OFFSET DG:INTMN,INT3
	   DW	OFFSET DG:INTMN,SAV8
	   DW	OFFSET DG:INTOMN,NOOPERANDS
	   DW	OFFSET DG:IRETMN,NOOPERANDS
; D0H
	   DW	0,SHIFT
	   DW	0,SHIFT
	   DW	0,SHIFTV
	   DW	0,SHIFTV
	   DW	OFFSET DG:AAMMN,CHK10
	   DW	OFFSET DG:AADMN,CHK10
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:XLATMN,NOOPERANDS
	   DW	0,M8087 		; d8
	   DW	0,M8087_D9		; d9
	   DW	0,M8087 		; da
	   DW	0,M8087_DB		; db
	   DW	0,M8087 		; dc
	   DW	0,M8087_DD		; dd
	   DW	0,M8087 		; de
	   DW	0,M8087_DF		; df
; E0H
	   DW	OFFSET DG:LOOPNZMN,SHORTJMP
	   DW	OFFSET DG:LOOPZMN,SHORTJMP
	   DW	OFFSET DG:LOOPMN,SHORTJMP
	   DW	OFFSET DG:JCXZMN,SHORTJMP
	   DW	OFFSET DG:INMN,INFIXB
	   DW	OFFSET DG:INMN,INFIXW
	   DW	OFFSET DG:OUTMN,OUTFIXB
	   DW	OFFSET DG:OUTMN,OUTFIXW
	   DW	OFFSET DG:CALLMN,JMPCALL
	   DW	OFFSET DG:JMPMN,JMPCALL
	   DW	OFFSET DG:JMPMN,LONGJMP
	   DW	OFFSET DG:JMPMN,SHORTJMP
	   DW	OFFSET DG:INMN,INVARB
	   DW	OFFSET DG:INMN,INVARW
	   DW	OFFSET DG:OUTMN,OUTVARB
	   DW	OFFSET DG:OUTMN,OUTVARW
; F0H
	   DW	OFFSET DG:LOCKMN,PREFIX
	   DW	OFFSET DG:DBMN,SAVHEX
	   DW	OFFSET DG:REPNZMN,PREFIX
	   DW	OFFSET DG:REPZMN,PREFIX
	   DW	OFFSET DG:HLTMN,NOOPERANDS
	   DW	OFFSET DG:CMCMN,NOOPERANDS
	   DW	0,GRP1
	   DW	0,GRP1
	   DW	OFFSET DG:CLCMN,NOOPERANDS
	   DW	OFFSET DG:STCMN,NOOPERANDS
	   DW	OFFSET DG:DIMN,NOOPERANDS
	   DW	OFFSET DG:EIMN,NOOPERANDS
	   DW	OFFSET DG:UPMN,NOOPERANDS
	   DW	OFFSET DG:DOWNMN,NOOPERANDS
	   DW	0,GRP2
	   DW	0,GRP2

DBMN	   DB	"DB",0
	   DB	"DW",0
	   DB	";",0
ORGMN	   DB	"ORG",0
ADDMN	   DB	"ADD",0
ADCMN	   DB	"ADC",0
SUBMN	   DB	"SUB",0
SBBMN	   DB	"SBB",0
XORMN	   DB	"XOR",0
ORMN	   DB	"OR",0
ANDMN	   DB	"AND",0
AAAMN	   DB	"AAA",0
AADMN	   DB	"AAD",0
AAMMN	   DB	"AAM",0
AASMN	   DB	"AAS",0
CALLMN	   DB	"CALL",0
CBWMN	   DB	"CBW",0
CLCMN	   DB	"CLC",0
UPMN	   DB	"CLD",0                 ; CLD,0
DIMN	   DB	"CLI",0
CMCMN	   DB	"CMC",0
CMPBMN	   DB	"CMPSB",0               ; CMPSB
CMPWMN	   DB	"CMPSW",0               ; CMPSW,0
CMPMN	   DB	"CMP",0
CWDMN	   DB	"CWD",0
DAAMN	   DB	"DAA",0
DASMN	   DB	"DAS",0
DECMN	   DB	"DEC",0
DIVMN	   DB	"DIV",0
ESCMN	   DB	"ESC",0
	   DB	"FXCH",0
	   DB	"FFREE",0
	   DB	"FCOMPP",0
	   DB	"FCOMP",0
	   DB	"FCOM",0
	   DB	"FICOMP",0
	   DB	"FICOM",0
	   DB	"FNOP",0
	   DB	"FCHS",0
	   DB	"FABS",0
	   DB	"FTST",0
	   DB	"FXAM",0
	   DB	"FLDL2T",0
	   DB	"FLDL2E",0
	   DB	"FLDLG2",0
	   DB	"FLDLN2",0
	   DB	"FLDPI",0
	   DB	"FLD1",0
	   DB	"FLDZ",0
	   DB	"F2XM1",0
	   DB	"FYL2XP1",0
	   DB	"FYL2X",0
	   DB	"FPTAN",0
	   DB	"FPATAN",0
	   DB	"FXTRACT",0
	   DB	"FDECSTP",0
	   DB	"FINCSTP",0
	   DB	"FPREM",0
	   DB	"FSQRT",0
	   DB	"FRNDINT",0
	   DB	"FSCALE",0
	   DB	"FINIT",0
	   DB	"FDISI",0
	   DB	"FENI",0
	   DB	"FCLEX",0
	   DB	"FBLD",0
	   DB	"FBSTP",0
	   DB	"FLDCW",0
	   DB	"FSTCW",0
	   DB	"FSTSW",0
	   DB	"FSTENV",0
	   DB	"FLDENV",0
	   DB	"FSAVE",0
	   DB	"FRSTOR",0
	   DB	"FADDP",0
	   DB	"FADD",0
	   DB	"FIADD",0
	   DB	"FSUBRP",0
	   DB	"FSUBR",0
	   DB	"FSUBP",0
	   DB	"FSUB",0
	   DB	"FISUBR",0
	   DB	"FISUB",0
	   DB	"FMULP",0
	   DB	"FMUL",0
	   DB	"FIMUL",0
	   DB	"FDIVRP",0
	   DB	"FDIVR",0
	   DB	"FDIVP",0
	   DB	"FDIV",0
	   DB	"FIDIVR",0
	   DB	"FIDIV",0
	   DB	"FWAIT",0
	   DB	"FILD",0
	   DB	"FLD",0
	   DB	"FSTP",0
	   DB	"FST",0
	   DB	"FISTP",0
	   DB	"FIST",0
HLTMN	   DB	"HLT",0
IDIVMN	   DB	"IDIV",0
IMULMN	   DB	"IMUL",0
INCMN	   DB	"INC",0
INTOMN	   DB	"INTO",0
INTMN	   DB	"INT",0
INMN	   DB	"IN",0                  ; IN
IRETMN	   DB	"IRET",0
	   DB	"JNBE",0
	   DB	"JAE",0
JAMN	   DB	"JA",0
JCXZMN	   DB	"JCXZ",0
JNCMN	   DB	"JNB",0
JBEMN	   DB	"JBE",0
JCMN	   DB	"JB",0
	   DB	"JNC",0
	   DB	"JC",0
	   DB	"JNAE",0
	   DB	"JNA",0
JZMN	   DB	"JZ",0
	   DB	"JE",0
JGEMN	   DB	"JGE",0
JGMN	   DB	"JG",0
	   DB	"JNLE",0
	   DB	"JNL",0
JLEMN	   DB	"JLE",0
JLMN	   DB	"JL",0
	   DB	"JNGE",0
	   DB	"JNG",0
JMPMN	   DB	"JMP",0
JNZMN	   DB	"JNZ",0
	   DB	"JNE",0
JPEMN	   DB	"JPE",0
JPOMN	   DB	"JPO",0
	   DB	"JNP",0
JNSMN	   DB	"JNS",0
JNOMN	   DB	"JNO",0
JOMN	   DB	"JO",0
JSMN	   DB	"JS",0
	   DB	"JP",0
LAHFMN	   DB	"LAHF",0
LDSMN	   DB	"LDS",0
LEAMN	   DB	"LEA",0
LESMN	   DB	"LES",0
LOCKMN	   DB	"LOCK",0
LODBMN	   DB	"LODSB",0               ; LODSB
LODWMN	   DB	"LODSW",0               ; LODSW,0
LOOPNZMN   DB	"LOOPNZ",0
LOOPZMN    DB	"LOOPZ",0
	   DB	"LOOPNE",0
	   DB	"LOOPE",0
LOOPMN	   DB	"LOOP",0
MOVBMN	   DB	"MOVSB",0               ; MOVSB
MOVWMN	   DB	"MOVSW",0               ; MOVSW,0
MOVMN	   DB	"MOV",0
MULMN	   DB	"MUL",0
NEGMN	   DB	"NEG",0
NOPMN	   DB	"NOP",0
NOTMN	   DB	"NOT",0
OUTMN	   DB	"OUT",0                 ; OUT
POPFMN	   DB	"POPF",0
POPMN	   DB	"POP",0
PUSHFMN    DB	"PUSHF",0
PUSHMN	   DB	"PUSH",0
RCLMN	   DB	"RCL",0
RCRMN	   DB	"RCR",0
REPZMN	   DB	"REPZ",0
REPNZMN    DB	"REPNZ",0
	   DB	"REPE",0
	   DB	"REPNE",0
	   DB	"REP",0
RETFMN	   DB	"RETF",0
RETMN	   DB	"RET",0
ROLMN	   DB	"ROL",0
RORMN	   DB	"ROR",0
SAHFMN	   DB	"SAHF",0
SARMN	   DB	"SAR",0
SCABMN	   DB	"SCASB",0               ; SCASB
SCAWMN	   DB	"SCASW",0               ; SCASW,0
SHLMN	   DB	"SHL",0
SHRMN	   DB	"SHR",0
STCMN	   DB	"STC",0
DOWNMN	   DB	"STD",0                 ; STD
EIMN	   DB	"STI",0                 ; STI
STOBMN	   DB	"STOSB",0               ; STOSB
STOWMN	   DB	"STOSW",0               ; STOSW,0
TESTMN	   DB	"TEST",0
WAITMN	   DB	"WAIT",0
XCHGMN	   DB	"XCHG",0
XLATMN	   DB	"XLAT",0
ESSEGMN    DB	"ES:",0
CSSEGMN    DB	"CS:",0
SSSEGMN    DB	"SS:",0
DSSEGMN    DB	"DS:",0
BADMN	   DB	"???",0

M8087_TAB  DB	"ADD$MUL$COM$COMP$SUB$SUBR$DIV$DIVR$"
FI_TAB	   DB	"F$FI$F$FI$"
SIZE_TAB   DB	"DWORD PTR $DWORD PTR $QWORD PTR $WORD PTR $"
	   DB	"BYTE PTR $TBYTE PTR $"

MD9_TAB    DB	"LD$@$ST$STP$LDENV$LDCW$STENV$STCW$"
MD9_TAB2   DB	"CHS$ABS$@$@$TST$XAM$@$@$LD1$LDL2T$LDL2E$"
	   DB	"LDPI$LDLG2$LDLN2$LDZ$@$2XM1$YL2X$PTAN$PATAN$XTRACT$"
	   DB	"@$DECSTP$INCSTP$PREM$YL2XP1$SQRT$@$RNDINT$SCALE$@$@$"

MDB_TAB    DB	"ILD$@$IST$ISTP$@$LD$@$STP$"
MDB_TAB2   DB	"ENI$DISI$CLEX$INIT$"

MDD_TAB    DB	"LD$@$ST$STP$RSTOR$@$SAVE$STSW$"
MDD_TAB2   DB	"FREE$XCH$ST$STP$"

MDF_TAB    DB	"ILD$@$IST$ISTP$BLD$ILD$BSTP$ISTP$"


OPTAB	   DB	11111111B		; DB
	   DW	DB_OPER
	   DB	11111111B		; DW
	   DW	DW_OPER
	   DB	11111111B		; COMMENT
	   DW	ASSEMLOOP
	   DB	11111111B		; ORG
	   DW	DOORG
	   DB	0 * 8			; ADD
	   DW	GROUP2
	   DB	2 * 8			; ADC
	   DW	GROUP2
	   DB	5 * 8			; SUB
	   DW	GROUP2
	   DB	3 * 8			; SBB
	   DW	GROUP2
	   DB	6 * 8			; XOR
	   DW	GROUP2
	   DB	1 * 8			; OR
	   DW	GROUP2
	   DB	4 * 8			; AND
	   DW	GROUP2
	   DB	00110111B		; AAA
	   DW	NO_OPER
	   DB	11010101B		; AAD
	   DW	AA_OPER
	   DB	11010100B		; AAM
	   DW	AA_OPER
	   DB	00111111B		; AAS
	   DW	NO_OPER
	   DB	2 * 8			; CALL
	   DW	CALL_OPER
	   DB	10011000B		; CBW
	   DW	NO_OPER
	   DB	11111000B		; CLC
	   DW	NO_OPER
	   DB	11111100B		; CLD
	   DW	NO_OPER
	   DB	11111010B		; DIM
	   DW	NO_OPER
	   DB	11110101B		; CMC
	   DW	NO_OPER
	   DB	10100110B		; CMPB
	   DW	NO_OPER
	   DB	10100111B		; CMPW
	   DW	NO_OPER
	   DB	7 * 8			; CMP
	   DW	GROUP2
	   DB	10011001B		; CWD
	   DW	NO_OPER
	   DB	00100111B		; DAA
	   DW	NO_OPER
	   DB	00101111B		; DAS
	   DW	NO_OPER
	   DB	1 * 8			; DEC
	   DW	DCINC_OPER
	   DB	6 * 8			; DIV
	   DW	GROUP1
	   DB	11011000B		; ESC
	   DW	ESC_OPER
	   DB	00001001B		; FXCH
	   DW	FGROUPP
	   DB	00101000B		; FFREE
	   DW	FGROUPP
	   DB	11011001B		; FCOMPP
	   DW	FDE_OPER
	   DB	00000011B		; FCOMP
	   DW	FGROUPX 		; Exception to normal P instructions
	   DB	00000010B		; FCOM
	   DW	FGROUPX
	   DB	00010011B		; FICOMP
	   DW	FGROUPZ
	   DB	00010010B		; FICOM
	   DW	FGROUPZ
	   DB	11010000B		; FNOP
	   DW	FD9_OPER
	   DB	11100000B		; FCHS
	   DW	FD9_OPER
	   DB	11100001B		; FABS
	   DW	FD9_OPER
	   DB	11100100B		; FTST
	   DW	FD9_OPER
	   DB	11100101B		; FXAM
	   DW	FD9_OPER
	   DB	11101001B		; FLDL2T
	   DW	FD9_OPER
	   DB	11101010B		; FLDL2E
	   DW	FD9_OPER
	   DB	11101100B		; FLDLG2
	   DW	FD9_OPER
	   DB	11101101B		; FLDLN2
	   DW	FD9_OPER
	   DB	11101011B		; FLDPI
	   DW	FD9_OPER
	   DB	11101000B		; FLD1
	   DW	FD9_OPER
	   DB	11101110B		; FLDZ
	   DW	FD9_OPER
	   DB	11110000B		; F2XM1
	   DW	FD9_OPER
	   DB	11111001B		; FYL2XP1
	   DW	FD9_OPER
	   DB	11110001B		; FYL2X
	   DW	FD9_OPER
	   DB	11110010B		; FPTAN
	   DW	FD9_OPER
	   DB	11110011B		; FPATAN
	   DW	FD9_OPER
	   DB	11110100B		; FXTRACT
	   DW	FD9_OPER
	   DB	11110110B		; FDECSTP
	   DW	FD9_OPER
	   DB	11110111B		; FINCSTP
	   DW	FD9_OPER
	   DB	11111000B		; FPREM
	   DW	FD9_OPER
	   DB	11111010B		; FSQRT
	   DW	FD9_OPER
	   DB	11111100B		; FRNDINT
	   DW	FD9_OPER
	   DB	11111101B		; FSCALE
	   DW	FD9_OPER
	   DB	11100011B		; FINIT
	   DW	FDB_OPER
	   DB	11100001B		; FDISI
	   DW	FDB_OPER
	   DB	11100000B		; FENI
	   DW	FDB_OPER
	   DB	11100010B		; FCLEX
	   DW	FDB_OPER
	   DB	00111100B		; FBLD
	   DW	FGROUPB
	   DB	00111110B		; FBSTP
	   DW	FGROUPB
	   DB	00001101B		; FLDCW
	   DW	FGROUP3W
	   DB	00001111B		; FSTCW
	   DW	FGROUP3W
	   DB	00101111B		; FSTSW
	   DW	FGROUP3W
	   DB	00001110B		; FSTENV
	   DW	FGROUP3
	   DB	00001100B		; FLDENV
	   DW	FGROUP3
	   DB	00101110B		; FSAVE
	   DW	FGROUP3
	   DB	00101100B		; FRSTOR
	   DW	FGROUP3
	   DB	00110000B		; FADDP
	   DW	FGROUPP
	   DB	00000000B		; FADD
	   DW	FGROUP
	   DB	00010000B		; FIADD
	   DW	FGROUPZ
	   DB	00110100B		; FSUBRP
	   DW	FGROUPP
	   DB	00000101B		; FSUBR
	   DW	FGROUPDS
	   DB	00110101B		; FSUBP
	   DW	FGROUPP
	   DB	00000100B		; FSUB
	   DW	FGROUPDS
	   DB	00010101B		; FISUBR
	   DW	FGROUPZ
	   DB	00010100B		; FISUB
	   DW	FGROUPZ
	   DB	00110001B		; FMULP
	   DW	FGROUPP
	   DB	00000001B		; FMUL
	   DW	FGROUP
	   DB	00010001B		; FIMUL
	   DW	FGROUPZ
	   DB	00110110B		; FDIVRP
	   DW	FGROUPP
	   DB	00000111B		; FDIVR
	   DW	FGROUPDS
	   DB	00110111B		; FDIVP
	   DW	FGROUPP
	   DB	00000110B		; FDIV
	   DW	FGROUPDS
	   DB	00010111B		; FIDIVR
	   DW	FGROUPZ
	   DB	00010110B		; FIDIV
	   DW	FGROUPZ
	   DB	10011011B		; FWAIT
	   DW	NO_OPER
	   DB	00011000B		; FILD
	   DW	FGROUPZ
	   DB	00001000B		; FLD
	   DW	FGROUPX
	   DB	00001011B		; FSTP
	   DW	FGROUP			;an000; dms;
	   DB	00101010B		; FST
	   DW	FGROUPX
	   DB	00011011B		; FISTP
	   DW	FGROUPZ
	   DB	00011010B		; FIST
	   DW	FGROUPZ
	   DB	11110100B		; HLT
	   DW	NO_OPER
	   DB	7 * 8			; IDIV
	   DW	GROUP1
	   DB	5 * 8			; IMUL
	   DW	GROUP1
	   DB	0 * 8			; INC
	   DW	DCINC_OPER
	   DB	11001110B		; INTO
	   DW	NO_OPER
	   DB	11001100B		; INTM
	   DW	INT_OPER
	   DB	11101100B		; IN
	   DW	IN_OPER
	   DB	11001111B		; IRET
	   DW	NO_OPER
	   DB	01110111B		; JNBE
	   DW	DISP8_OPER
	   DB	01110011B		; JAE
	   DW	DISP8_OPER
	   DB	01110111B		; JA
	   DW	DISP8_OPER
	   DB	11100011B		; JCXZ
	   DW	DISP8_OPER
	   DB	01110011B		; JNB
	   DW	DISP8_OPER
	   DB	01110110B		; JBE
	   DW	DISP8_OPER
	   DB	01110010B		; JB
	   DW	DISP8_OPER
	   DB	01110011B		; JNC
	   DW	DISP8_OPER
	   DB	01110010B		; JC
	   DW	DISP8_OPER
	   DB	01110010B		; JNAE
	   DW	DISP8_OPER
	   DB	01110110B		; JNA
	   DW	DISP8_OPER
	   DB	01110100B		; JZ
	   DW	DISP8_OPER
	   DB	01110100B		; JE
	   DW	DISP8_OPER
	   DB	01111101B		; JGE
	   DW	DISP8_OPER
	   DB	01111111B		; JG
	   DW	DISP8_OPER
	   DB	01111111B		; JNLE
	   DW	DISP8_OPER
	   DB	01111101B		; JNL
	   DW	DISP8_OPER
	   DB	01111110B		; JLE
	   DW	DISP8_OPER
	   DB	01111100B		; JL
	   DW	DISP8_OPER
	   DB	01111100B		; JNGE
	   DW	DISP8_OPER
	   DB	01111110B		; JNG
	   DW	DISP8_OPER
	   DB	4 * 8			; JMP
	   DW	JMP_OPER
	   DB	01110101B		; JNZ
	   DW	DISP8_OPER
	   DB	01110101B		; JNE
	   DW	DISP8_OPER
	   DB	01111010B		; JPE
	   DW	DISP8_OPER
	   DB	01111011B		; JPO
	   DW	DISP8_OPER
	   DB	01111011B		; JNP
	   DW	DISP8_OPER
	   DB	01111001B		; JNS
	   DW	DISP8_OPER
	   DB	01110001B		; JNO
	   DW	DISP8_OPER
	   DB	01110000B		; JO
	   DW	DISP8_OPER
	   DB	01111000B		; JS
	   DW	DISP8_OPER
	   DB	01111010B		; JP
	   DW	DISP8_OPER
	   DB	10011111B		; LAHF
	   DW	NO_OPER
	   DB	11000101B		; LDS
	   DW	L_OPER
	   DB	10001101B		; LEA
	   DW	L_OPER
	   DB	11000100B		; LES
	   DW	L_OPER
	   DB	11110000B		; LOCK
	   DW	NO_OPER
	   DB	10101100B		; LODB
	   DW	NO_OPER
	   DB	10101101B		; LODW
	   DW	NO_OPER
	   DB	11100000B		; LOOPNZ
	   DW	DISP8_OPER
	   DB	11100001B		; LOOPZ
	   DW	DISP8_OPER
	   DB	11100000B		; LOOPNE
	   DW	DISP8_OPER
	   DB	11100001B		; LOOPE
	   DW	DISP8_OPER
	   DB	11100010B		; LOOP
	   DW	DISP8_OPER
	   DB	10100100B		; MOVB
	   DW	NO_OPER
	   DB	10100101B		; MOVW
	   DW	NO_OPER
	   DB	11000110B		; MOV
	   DW	MOV_OPER
	   DB	4 * 8			; MUL
	   DW	GROUP1
	   DB	3 * 8			; NEG
	   DW	GROUP1
	   DB	10010000B		; NOP
	   DW	NO_OPER
	   DB	2 * 8			; NOT
	   DW	GROUP1
	   DB	11101110B		; OUT
	   DW	OUT_OPER
	   DB	10011101B		; POPF
	   DW	NO_OPER
	   DB	0 * 8			; POP
	   DW	POP_OPER
	   DB	10011100B		; PUSHF
	   DW	NO_OPER
	   DB	6 * 8			; PUSH
	   DW	PUSH_OPER
	   DB	2 * 8			; RCL
	   DW	ROTOP
	   DB	3 * 8			; RCR
	   DW	ROTOP
	   DB	11110011B		; REPZ
	   DW	NO_OPER
	   DB	11110010B		; REPNZ
	   DW	NO_OPER
	   DB	11110011B		; REPE
	   DW	NO_OPER
	   DB	11110010B		; REPNE
	   DW	NO_OPER
	   DB	11110011B		; REP
	   DW	NO_OPER
	   DB	11001011B		; RETF
	   DW	GET_DATA16
	   DB	11000011B		; RET
	   DW	GET_DATA16
	   DB	0 * 8			; ROL
	   DW	ROTOP
	   DB	1 * 8			; ROR
	   DW	ROTOP
	   DB	10011110B		; SAHF
	   DW	NO_OPER
	   DB	7 * 8			; SAR
	   DW	ROTOP
	   DB	10101110B		; SCAB
	   DW	NO_OPER
	   DB	10101111B		; SCAW
	   DW	NO_OPER
	   DB	4 * 8			; SHL
	   DW	ROTOP
	   DB	5 * 8			; SHR
	   DW	ROTOP
	   DB	11111001B		; STC
	   DW	NO_OPER
	   DB	11111101B		; STD
	   DW	NO_OPER
	   DB	11111011B		; EI
	   DW	NO_OPER
	   DB	10101010B		; STOB
	   DW	NO_OPER
	   DB	10101011B		; STOW
	   DW	NO_OPER
	   DB	11110110B		; TEST
	   DW	TST_OPER
	   DB	10011011B		; WAIT
	   DW	NO_OPER
	   DB	10000110B		; XCHG
	   DW	EX_OPER
	   DB	11010111B		; XLAT
	   DW	NO_OPER
	   DB	00100110B		; ESSEG
	   DW	NO_OPER
	   DB	00101110B		; CSSEG
	   DW	NO_OPER
	   DB	00110110B		; SSSEG
	   DW	NO_OPER
	   DB	00111110B		; DSSEG
	   DW	NO_OPER

ZZOPCODE   LABEL BYTE
MAXOP	   =	(ZZOPCODE-OPTAB)/3

SHFTAB	   DW	OFFSET DG:ROLMN,OFFSET DG:RORMN,OFFSET DG:RCLMN
	   DW	OFFSET DG:RCRMN,OFFSET DG:SHLMN,OFFSET DG:SHRMN
	   DW	OFFSET DG:BADMN,OFFSET DG:SARMN

IMMTAB	   DW	OFFSET DG:ADDMN,OFFSET DG:ORMN,OFFSET DG:ADCMN
	   DW	OFFSET DG:SBBMN,OFFSET DG:ANDMN,OFFSET DG:SUBMN
	   DW	OFFSET DG:XORMN,OFFSET DG:CMPMN

GRP1TAB    DW	OFFSET DG:TESTMN,OFFSET DG:BADMN,OFFSET DG:NOTMN
	   DW	OFFSET DG:NEGMN,OFFSET DG:MULMN,OFFSET DG:IMULMN
	   DW	OFFSET DG:DIVMN,OFFSET DG:IDIVMN

GRP2TAB    DW	OFFSET DG:INCMN,OFFSET DG:DECMN,OFFSET DG:CALLMN
	   DW	OFFSET DG:CALLMN,OFFSET DG:JMPMN,OFFSET DG:JMPMN
	   DW	OFFSET DG:PUSHMN,OFFSET DG:BADMN

SEGTAB	   DW	OFFSET DG:ESSAVE,OFFSET DG:CSSAVE,OFFSET DG:SSSAVE
	   DW	OFFSET DG:DSSAVE

REGTAB	   DB	"AX",0,"BX",0,"CX",0,"DX",0,"SP",0,"BP",0
	   DB	"SI",0,"DI",0,"DS",0,"ES",0,"SS",0,"CS",0,"IP",0,"PC",0
REGTABEND  LABEL WORD

; Flags are ordered to correspond with the bits of the flag
; register, most significant bit first, zero if bit is not
; a flag. First 16 entries are for bit set, second 16 for
; bit reset.

FLAGTAB    DW	0
	   DW	0
	   DW	0
	   DW	0
	   DB	"OV"
	   DB	"DN"
	   DB	"EI"                    ; "STI"
	   DW	0
	   DB	"NG"
	   DB	"ZR"
	   DW	0
	   DB	"AC"
	   DW	0
	   DB	"PE"
	   DW	0
	   DB	"CY"
	   DW	0
	   DW	0
	   DW	0
	   DW	0
	   DB	"NV"
	   DB	"UP"                    ; "CLD"
	   DB	"DI"
	   DW	0
	   DB	"PL"
	   DB	"NZ"
	   DW	0
	   DB	"NA"
	   DW	0
	   DB	"PO"
	   DW	0
	   DB	"NC"

	   DW	80H DUP(?)
STACK	   LABEL BYTE


; Register save area

AXSAVE	   DW	0
BXSAVE	   DW	0
CXSAVE	   DW	0
DXSAVE	   DW	0
SPSAVE	   DW	5AH
BPSAVE	   DW	0
SISAVE	   DW	0
DISAVE	   DW	0
DSSAVE	   DW	0
ESSAVE	   DW	0
RSTACK	   LABEL WORD			; Stack set here so registers can be saved by pushing
SSSAVE	   DW	0
CSSAVE	   DW	0
IPSAVE	   DW	100H
FLSAVE	    DW	 0F202H

RSETFLAG   DB	0

;  These variables used to determine if the file is larget than the   ;C01
;  amount of disk space available whenever a write occurs.            ;C01
								      ;C01
FileSizeLB DW   0                                                     ;C01
FileSizeHB DW   0                                                     ;C01
TempHB     DW   0                                                     ;C01
TempLB     DW   0                                                     ;C01
DriveOfFile DB  ?                                                     ;C01

REGDIF	   EQU	AXSAVE-REGTAB

; This value is initially 0, it is set to non-zero if a file is specified
;  either at debug invokation, or via the (N)ame command. It is used to
;  control the printing of the NONAMESPEC message for the (W)rite command.
NAMESPEC   DB	0

; RAM area.

RDFLG	   DB	READ
TOTREG	   DB	13
DSIZ	   DB	0FH			;changed to 7 if screen 40 col mode
NOREGL	   DB	8			;changed to 4 if screen 40 col mode
DISPB	   DW	128			;changed to 64 if screen 40 col mode

LBUFSIZ    DB	BUFLEN
LBUFFCNT   DB	0
LINEBUF    DB	0DH
	   DB	BUFLEN DUP (?)
PFLAG	   DB	0
COLPOS	   DB	0

	   IF	SYSVER
CONFCB	   DB	0
	   DB	"PRN        "
	   DB	25 DUP(0)

POUT	   DD	?
COUT	   DD	?
CIN	   DD	?
IOBUFF	   DB	3 DUP (?)
IOADDR	   DD	?

IOCALL	   DB	22
	   DB	0
IOCOM	   DB	0
IOSTAT	   DW	0
	   DB	8 DUP (0)
IOCHRET    DB	0
	   DW	OFFSET DG:IOBUFF
IOSEG	   DW	?
IOCNT	   DW	1
	   DW	0
	   ENDIF

QFLAG	   DB	0
NEWEXEC    DB	0
RETSAVE    DW	?

USER_PROC_PDB DW ?
NextCS	   DW	?
NextIP	   DW	?

HEADSAVE   DW	?

EXEC_BLOCK LABEL BYTE
	   DW	0
COM_LINE   LABEL DWORD
	   DW	80H
	   DW	?
COM_FCB1   LABEL DWORD
	   DW	FCB
	   DW	?
COM_FCB2   LABEL DWORD
	   DW	FCB + 10H
	   DW	?
COM_SSSP   DD	?
COM_CSIP   DD	?

CONST	   ENDS
	   END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\deberr.asm ===
PAGE	80,132 ;
	TITLE	DEBERR.ASM - DEBUGGER DISK ERROR HANDLER
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************* START OF SPECIFICATIONS *****************************
;
; MODULE NAME:DEBERR.ASM
;
; DESCRIPTIVE NAME: DISK ERROR HANDLER
;
; FUNCTION: THIS ROUTINE IS A CATCHALL ERROR HANDLER.  IT PRIMARILY
;	    HANDLES DISK ERROR.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; INPUT: NA
;
; EXIT-NORMAL: NA
;
; EXIT-ERROR: NA
;
; INTERNAL REFERENCES:
;
;
; EXTERNAL REFERENCES:
;
; NOTES: THIS MODULE SHOULD BE PROCESSED WITH THE SALUT PRE-PROCESSOR
;	 WITH OPTIONS "PR".
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+DEBCONST+
;	      DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.0 - MESSAGE RETRIEVER IMPLEMENTED.  DMS:6/17/87
;
;
; COPYRIGHT: "MS DOS DEBUG Utility"
;	     "Version 4.00 (C) Copyright 1988 Microsoft"
;	     "Licensed Material - Property of Microsoft  "
;
;******************** END OF SPECIFICATIONS ******************************
;
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   03/27/90  DIC  C03	MSFT # 696 - DEBUG seemed to be reporting the wrong
;                      error after	attempting to reading logical sector zero
;                      on an SCO-XENIX boot diskette.  The message "Write
;                      Protect Error	Reading drive A." was displayed.
;*****************************************************************************

.XLIST
.XCREF
	include version.inc		; cas -- missing equates
	include syscall.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC
.CREF
.LIST

        INCLUDE debug.inc

FIRSTDRV EQU	"A"

CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
	EXTRN	RDFLG:BYTE
	EXTRN	DRVLET:BYTE
	EXTRN	dr1_ptr:word,dr2_ptr:word,dr3_ptr:word,dr4_ptr:word ;ac000
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	PARITYFLAG:BYTE
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CODE	SEGMENT PUBLIC BYTE
	ASSUME	CS:DG,DS:DG,ES:DG,SS:DG

	EXTRN	RESTART:NEAR
	PUBLIC	DRVERR, TRAPPARITY, RELEASEPARITY, NMIINT, NMIINTEND

TRAPPARITY:
	IF	IBMJAPAN
	    PUSH    BX
	    PUSH    ES
	    PUSH    DX			; save location of new offset
	    MOV     DX,OFFSET DG:NMIINT ; DS:DX has new interrupt vector
	    CALL    SWAPINT		; diddle interrupts
	    ASSUME  ES:NOTHING

	    MOV     WORD PTR [NMIPTR],BX ; save old offset
	    MOV     WORD PTR [NMIPTR+2],ES ; save old segment
	    POP     DX			; get old regs back
	    POP     ES			; restore old values
	    ASSUME  ES:DG

	    POP     BX
	    MOV     BYTE PTR [PARITYFLAG],0 ; no interrupts detected yet!
	    RET

SWAPINT:
	    PUSH    AX
	    MOV     AX,(GET_INTERRUPT_VECTOR SHL 8) + 2
	    INT     21H 		; Get old NMI Vector
	    MOV     AX,(SET_INTERRUPT_VECTOR SHL 8) + 2
	    INT     21h 		; let OS set new vector
	    POP     AX
	ENDIF
	RET

RELEASEPARITY:
	IF	IBMJAPAN
	    PUSH    DX
	    PUSH    DS
	    PUSH    BX
	    PUSH    ES
	    LDS     DX,DWORD PTR [NMIPtr] ; get old vector
	    CALL    SwapInt		; diddle back to original
	    POP     ES
	    POP     BX
	    POP     DS
	    POP     DX
	    MOV     [PARITYFLAG],0	; no interrupts possible!
	ENDIF
	RET

NMIInt:
	IF	IBMJAPAN
	    PUSH    AX			; save AX
	    IN	    AL,0A0H		; get status register
	    OR	    AL,1		; was there parity check?
	    POP     AX			; get old AX back
	    JZ	    NMICHAIN		; no, go chain interrupt
	    OUT     0A2H,AL		; reset NMI detector
	    MOV     CS:[PARITYFLAG],1	; signal detection
	    IRET
NMICHAIN:
	    JMP     DWORD PTR CS:[NMIPTR] ; chain the vectors
NMIPTR	    DD	    ?			; where old NMI gets stashed
	ENDIF
NMIINTEND:

DRVERR:

	or	al,al				;ac000;see if drive specified
;	$if	nz				;an000;drive specified
	JZ $$IF1
		add	byte ptr drvlet,firstdrv;ac000;determine drive letter
		cmp	byte ptr rdflg,write	;ac000;see if it is read/write
;		$if	z			;an000;it is write
		JNZ $$IF2
			mov	dx,offset dg:dr2_ptr	;an000;message
;		$else				;an000;it is read
		JMP SHORT $$EN2
$$IF2:
			mov	dx,offset dg:dr1_ptr	;an000;message
;		$endif				;an000;
$$EN2:
;	$else					;an000;write protect error
	JMP SHORT $$EN1
$$IF1:
		add	byte ptr drvlet,firstdrv;ac000;determine drive letter
		cmp	byte ptr rdflg,write	;ac000;see if it is read/write
;		$if	z			;an000;it is write
		JNZ $$IF6
			mov	dx,offset dg:dr4_ptr	;an000;message
;		$else				;an000;it is read
		JMP SHORT $$EN6
$$IF6:
			mov	dx,offset dg:dr1_ptr	;an000;message ;C03
;		$endif				;an000;
$$EN6:
;	$endif					;an000;
$$EN1:

; CLEAN OUT THE DISK...
	MOV	AH,DISK_RESET
	INT	21H

	JMP	RESTART
CODEEND:

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debmes.asm ===
PAGE	60,132				;
	TITLE	DEBMES.ASM - DEBUGGER MESSAGES PC DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	IF1
	    %OUT    COMPONENT=DEBUG, MODULE=DEBMES
	ENDIF

;******************* START OF SPECIFICATIONS *****************************
;
; MODULE NAME:DEBMES.ASM
;
; DESCRIPTIVE NAME: SUPPLIES APPLICABLE MESSAGES TO DEBUG.ASM
;
; FUNCTION: THIS ROUTINE PROVIDES A MEANS BY WHICH MESSAGES MAY BE
;	    OUTPUT FOR DEBUG.  THIS IS HANDLED THROUGH THE MESSAGE
;	    RETRIEVER FUNCTION SYSDISPMSG.  TO
;	    FACILITATE MIGRATION AWAY FROM THE PRINTF UTILITY
;	    THE INTERFACE FOR INVOKING MESSAGES HAS REMAINED THE SAME.
;	    THIS IS ACCOMPLISHED THROUGH THE USE OF MACROS AND TABLES.
;	    EACH MESSAGE HAS A TABLE OF VALUES REQUIRED BY THE MESSAGE
;	    RETRIEVER UTILITIES.  THE MACROS OPERATE ON THESE TABLES
;	    TO SUPPLY SYSDISPMSG WITH THE VALUES NECESSARY
;	    TO PRINT A MESSAGE.
;
; ENTRY POINT: PRINTF
;
; INPUT: PRINTF IS INVOKED AS IT HAS ALWAYS BEEN INVOKED.  DX MUST
;	 POINT TO THE OFFSET OF A MESSAGE TABLE.  THE TABLE POINTED TO
;	 BY DX CONTAINS ALL THE NECESSARY INFORMATION FOR THAT MESSAGE
;	 TO BE PRINTED.
;
; EXIT-NORMAL: NO CARRY
;
; EXIT-ERROR: CARRY SET - EITHER MESSAGE NOT FOUND OR UNABLE TO BE DISPLAYED
;
; INTERNAL REFERENCES:
;
;	ROUTINE:DISP_MESSAGE - THIS MACRO IS USED TO DIPLAY A MESSAGE
;			       VIA SYSDISPMSG.	IT TAKES AS INPUT A POINTER
;			       IN DX.  THIS POINTER POINTS TO A TABLE OF
;			       VALUES FOR THE REQUESTED MESSAGE.
;			       DISP_MESSAGE OBTAINS THE VALUES IT NEEDS TO
;			       TO INVOKE SYSDISPMSG FROM THIS TABLE.
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: SYSMSG.INC  - THIS ROUTINE IS SUPPLIED TO INTERFACE THE
;			       MESSAGE RETRIEVER SERVICES.
;
; NOTES: THIS MODULE SHOULD BE PROCESSED WITH THE SALUT PRE-PROCESSOR
;	 WITH OPTIONS "PR".
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+DEBCONST+
;	      DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.0 - MESSAGE RETRIEVER IMPLEMENTED.  DMS:6/17/87
;
;
; COPYRIGHT: "MS DOS DEBUG Utility"
;	     "Version 4.00 (C) Copyright 1988 Microsoft"
;	     "Licensed Material - Property of Microsoft  "
;
;******************** END OF SPECIFICATIONS ******************************
;
;  CHANGE LOG:
;
;     DATE    WHO   #		       DESCRIPTION
;   --------  ---  ---	---------------------------------------------------
;   04/01/90  DIC  C02	Message was only printing first parameter, not
;			first and second.  I made the BX:CX message print
;			1 byte for BX and left CX at 4 bytes. Corresponding
;			change in message file, DEBUG line 38. (Compaq STR
;			#1804) (MS Bug #338)
;
;   05/25/90  AKM  C07	Problem fixed - Number of bytes writtem message
;                       was being printed with the wrong alignment &
;                       precision.
;			(Microsoft Bug #1156)
;
;============================================================================
.xlist

	include sysmsg.inc		;an000;message retriever

.list

msg_utilname <DEBUG>			;an000;DEBUG messages

;=========================================================================
;revised debmes.asm
;=========================================================================

fatal_error	equ	45		;fatal message handler error
unlim_width	equ	00h		;unlimited output width
pad_blank	equ	20h		;blank pad
pre_load	equ	00h		;an000;normal pre-load
pad_zero	equ	30h		;an000;zero pad


FALSE	EQU	0
TRUE	EQU	NOT FALSE

;SYSVER 	 EQU FALSE		 ;if true, i/o direct to bios
	INCLUDE SYSVER.INC

;=========================================================================
; macro disp_message: the macro takes the message obtained in get_message
;		      and displays it to the applicable screen device.
;=========================================================================

disp_message macro tbl			;an000;display message macro

	push	si			;an000;save affected reg
	push	di			;an000;
	push	ax			;an000;
	push	bx			;an000;
	push	cx			;an000;
	push	dx			;an000;

	push	tbl			;an000;exchange tbl with si
	pop	si			;an000;

	mov	ax,[si] 		;an000;move message number to ax
	mov	bx,[si+3]		;an000;display handle
	mov	cx,[si+7]		;an000;number of subs
	mov	dl,[si+9]		;an000;function type
	mov	di,[si+10]		;an000;input buffer if appl.
	mov	dh,[si+2]		;an000;message type
	mov	si,[si+5]		;an000;sublist

	call	sysdispmsg		;an000;display the message

	pop	dx			;an000;restore affected reg
	pop	cx			;an000;
	pop	bx			;an000;
	pop	ax			;an000;
	pop	di			;an000;
	pop	si			;an000;


endm					;an000;end macro disp_message

;=========================================================================
; macro disp_message: end macro
;=========================================================================



CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE

DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA


code	segment public byte		;an000;code segment
	assume	cs:dg,ds:dg,ss:dg,es:dg ;an000;

	public	printf			;an000;share printf
;;	public	disp_fatal		;an000;fatal error display
	public	pre_load_message	;an000;message pre load

.xlist

msg_services <MSGDATA>

.list

;=========================================================================
;	  include sysmsg.inc - message retriever services
;options selected:
;		   NEARmsg
;		   DISPLAYmsg
;		   LOADmsg
;		   INPUTmsg
;		   CHARmsg
;		   NUMmsg
;		   CLSAmsg
;		   CLSBmsg
;		   CLSCmsg
;		   CLSDmsg
;=========================================================================

.xlist

msg_services <LOADmsg>			;an000;load the messages
msg_services <DISPLAYmsg,CHARmsg,NUMmsg>;an000;get and display messages
msg_services <INPUTmsg> 		;an000;input from keyboard
msg_services <DEBUG.CLA,DEBUG.CLB>	;an000;message types
msg_services <DEBUG.CLC,DEBUG.CLD>	;an000;
msg_services <DEBUG.CL1,DEBUG.CL2>	;an000;

.list

;=========================================================================
; printf: printf is a replacement of the printf procedure used in DOS
;	  releases prior 4.00.	printf invokes the macros get_message and
;	  disp_message to invoke the new message handler.  the interface
;	  into printf will continue to be a pointer to a message passed
;	  in DX.  the pointer is pointing to more than a message now.  it
;	  is pointing to a table for that message containing all relevant
;	  information for retieving and printing the message.  the macros
;	  get_message and disp_message operate on these tables.
;=========================================================================

printf	proc	near			;an000;printf procedure

	disp_message dx 		;an000;display a message
;;	$if	c			;an000;if an error occurred
;;		call disp_fatal 	;an000;display the fatal error
;;	$endif				;an000;

	ret				;an000;return to caller

printf	endp				;an000;end printf


;=========================================================================
; disp_fatal: this routine displays a fatal error message in the event
;	      an error occurred in disp_message.
;=========================================================================

;;disp_fatal	  proc	  near		  ;an000;fatal error message
;;
;;	  mov	  ax,fatal_error	  ;an000;fatal_error number
;;	  mov	  bx,stdout		  ;an000;print to console
;;	  mov	  cx,0			  ;an000;no parameters
;;	  mov	  dl,no_input		  ;an000;no input will be coming
;;	  mov	  dh,UTILITY_MSG_CLASS	     ;an000;utility messages
;;	  call	  sysdispmsg		  ;an000;dispaly fatal error
;;	  ret				  ;an000;return to caller
;;
;;disp_fatal	  endp			  ;an000;end disp_fatal


;=========================================================================
; PRE_LOAD_MESSAGE : This routine provides access to the messages required
;		     by DEBUG.	This routine will report if the load was
;		     successful.  An unsuccessful load will cause DEBUG
;		     to terminate with an appropriate error message.
;
;	Date	  : 6/15/87
;=========================================================================

PRE_LOAD_MESSAGE	proc	near		;an000;pre-load messages

	call	SYSLOADMSG			;an000;invoke loader

;	$if	c				;an000;if an error
	JNC $$IF1
		pushf				;an000;save flags
		call	SYSDISPMSG		;an000;let him say why
		popf				;an000;restore flags
;	$endif					;an000;
$$IF1:

	ret					;an000;return to caller

PRE_LOAD_MESSAGE	endp			;an000;end proc

include msgdcl.inc

code	ends				;an000;end code segment


CONST	SEGMENT PUBLIC BYTE

	PUBLIC	ENDMES_PTR,CRLF_PTR,NAMBAD_PTR
	PUBLIC	NOTFND_PTR,NOROOM_PTR,BADVER
	PUBLIC	NOSPACE_PTR,DRVLET
	PUBLIC	ACCMES_PTR,PROMPT_PTR
	PUBLIC	TOOBIG_PTR,SYNERR_PTR,BACMES_PTR
	PUBLIC	HEXERR_PTR,HEXWRT_PTR,WRTMES_PTR,EXEBAD_PTR,EXEWRT_PTR
	PUBLIC	EXECEMES_PTR, PARITYMES_PTR, NONAMESPEC_PTR
	PUBLIC	dr1_ptr,dr2_ptr,dr3_ptr,dr4_ptr 	;ac000;new messages
	PUBLIC	CHANGE_FLAG_PTR,DF_ERROR,BF_ERROR,BR_ERROR,BP_ERROR
	PUBLIC	CONSTEND

;======================= TABLE STRUCTURE =================================
;
;	byte 1	-	message number of message to be displayed
;	byte 2	-	message type to be used, i.e.;class 1, utility, etc.
;	byte 3	-	display handle, i.e.; console, printer, etc.
;	byte 4	-	pointer to substitution list, if any.
;	byte 6	-	number of replaceable parameters, if any.
;	byte 7	-	type of input from keyboard, if any.
;	byte 8	-	pointer to buffer for keyboard input, if any.
;
;=========================================================================

	IF	SYSVER

	    PUBLIC  BADDEV_PTR,BADLSTMES_PTR


baddev_ptr  label   word		;an000;"Bad device name",0
	    dw	    0006		;an000;message number 6
	    db	    UTILITY_MSG_CLASS	   ;an000;utility message
	    dw	    stdout		;an000;display handle
	    dw	    00			;an000;sublist
	    dw	    00			;an000;no subs
	    db	    no_input		;an000;no keyboard input
	    dw	    00			;an000;no keyboard buffer

badlstmes_ptr label word		;an000;"Couldn't open list device
					;      PRN","Enter name of list
					;      device?"
	    dw	    0007		;an000;message number 7
	    db	    UTILITY_MSG_CLASS	   ;an000;utility message
	    dw	    stdout		;an000;display handle
	    dw	    00			;an000;sublist
	    dw	    00			;an000;no subs
	    db	    DOS_KEYB_INP	;an000;keyboard input
	    dw	    00			;an000;no keyboard buffer


	ENDIF

;================= REPLACEABLE PARAMETER SUBLIST STRUCTURE ===============
;
;	byte 1	-	substitution list size, always 11
;	byte 2	-	reserved for use by message handler
;	byte 3	-	pointer to parameter to be used as a substitution
;	byte 7	-	which parameter is this to replace, %1, %2, etc.
;	byte 8	-	determines how the parameter is to be output
;	byte 9	-	determines the maximum width of the parameter string
;	byte 10 -	determines the minimum width of the parameter string
;	byte 11 -	define what is to be used as a pad character
;
;=========================================================================


;=========================================================================
;		replaceable parameter sublists
;=========================================================================

db_synerr_sub label dword		;an000;synerr parameters
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad

db_change_sub label dword		;an000;synerr parameters
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad

db_drive_error label dword		;an000;drive error parameters
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:drvlet		;an000;point to drive letter
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	01			;an000;1 byte
	db	01			;an000;1 byte
	db	pad_blank		;an000;blank pad



;=========================================================================
;		end replaceable parameter sublists
;=========================================================================


crlf_ptr label	word			;an000;13,10,0
	dw	0008			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


bacmes_ptr label word			;an000;32,8,0
	dw	0044			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


badver	label	word			;an000;"Incorrect DOS version"
	dw	0001			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

endmes_ptr label word			;an000;13,10,"Program terminated
					;	      normally",0
	dw	0009			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


nambad_ptr label word			;an000;"Invalid drive specification",0
	dw	0010			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


notfnd_ptr label word			;an000;"File not found",0
	dw	0002			;an000;message number
	db	Ext_Err_Class		;an000;extended error
	dw	stderr			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


noroom_ptr label word			;an000;"File creation error",0
	dw	0012			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


nospace_ptr label word			;an000;"Insufficient space on disk",0
	dw	0013			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr1_ptr label	word			;an000;"Disk error reading drive %1"
	dw	0014			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr2_ptr label	word			;an000;"Disk error writing drive %1"
	dw	0015			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr3_ptr label	word			;an000;"Write protect error reading
					;	drive %1"
	dw	0016			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


dr4_ptr label	word			;an000;"Write protect error writing
					;	drive %1"
	dw	0017			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_drive_error	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


toobig_ptr label word			;an000;"Insufficient memory",0
	dw	0008			;an000;message number
	db	Ext_Err_Class		;an000;utility message
	dw	stderr			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

synerr_ptr label word			;an000;"%1^Error",0
	dw	0019			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_synerr_sub	;an000;sublist
	dw	01			;an000;1 sub - leading spaces
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


hexerr_ptr label word			;an000;"Error in EXE or HEX file",0
	dw	0020			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

exebad_ptr label word			;an000;"Error in EXE or HEX file",0
	dw	0020			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


hexwrt_ptr label word			;an000;"EXE and HEX files cannot be
					;	written",0
	dw	0021			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

exewrt_ptr label word			;an000;"EXE and HEX files cannot be
					;	written",0
	dw	0021			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


execemes_ptr label word 		;an000;"EXEC failure",0
	dw	0022			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


nonamespec_ptr label word		;an000;"(W)rite error, no destination
					;	defined",0
	dw	0023			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

accmes_ptr label word			;an000;Access denied",0
	dw	0024			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


paritymes_ptr label word		;an000;"Parity error or nonexistant
					;	memory error detected",0
	dw	0025			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


prompt_ptr label word			;an000;"-",0
	dw	0026			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


change_flag_ptr label word		;an000;"%1 -",0
	dw	0027			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_change_sub	;an000;sublist
	dw	01			;an000;no subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

df_error	db	"df",0
bf_error	db	"bf",0
br_error	db	"br",0
bp_error	db	"bp",0
drvlet		db	"A",0

CONSTEND LABEL	BYTE

CONST	ENDS

DATA	SEGMENT PUBLIC BYTE

	PUBLIC	HEX_ARG1,HEX_ARG2,HEX_PTR,ARG_BUF
	PUBLIC	ARG_BUF_PTR,ADD_PTR,ERR_TYPE
	PUBLIC	CRLF_PTR,ADD_ARG,SUB_ARG,PROMPT_PTR
	PUBLIC	REGISTER_PTR,REG_NAME,REG_CONTENTS
	PUBLIC	SINGLE_REG_PTR,SINGLE_REG_ARG
	PUBLIC	ERRMES_PTR,LOC_PTR,LOC_ADD
	PUBLIC	LITTLE_PTR,BIG_PTR,LITTLE_CONTENTS
	PUBLIC	BIG_CONTENTS,COMP_PTR,COMP_ARG1,COMP_ARG2
	PUBLIC	COMP_ARG3,COMP_ARG4,COMP_ARG5,COMP_ARG6
	PUBLIC	WRTMES_PTR,WRT_ARG1,WRT_ARG2
	PUBLIC	IOTYP,MESTYP
	PUBLIC	ONE_CHAR_BUF,ONE_CHAR_BUF_PTR
	PUBLIC	OPBUF,UNASSEM_LN_PTR
	PUBLIC  QMES_1
	PUBLIC	QMES_2
	PUBLIC  QMES_3
	PUBLIC  QMES_4
	PUBLIC  QMES_5
	PUBLIC	HELP_TEXT1
	PUBLIC	HELP_TEXT2
	PUBLIC	HELP_TEXT3
	PUBLIC	HELP_TEXT4
	PUBLIC	HELP_TEXT5
	PUBLIC	HELP_TEXT6

	PUBLIC	xm_han_ret_ptr
	PUBLIC	xm_mapped_ptr
	PUBLIC	xm_err80_ptr
	PUBLIC	xm_err83_ptr
	PUBLIC	xm_err84_ptr
	PUBLIC	xm_err85_ptr
	PUBLIC	xm_err86_ptr
	PUBLIC	xm_err87_ptr
	PUBLIC	xm_err88_ptr
	PUBLIC	xm_err89_ptr
	PUBLIC	xm_err8a_ptr
	PUBLIC	xm_err8b_ptr
	PUBLIC	xm_err8d_ptr
	PUBLIC	xm_err8e_ptr
	PUBLIC	xm_err_gen_ptr
	PUBLIC	xm_parse_err_ptr
	PUBLIC	xm_status_ptr
	PUBLIC	xm_page_seg_ptr
	PUBLIC	xm_deall_ptr
	PUBLIC	xm_errff_ptr
	PUBLIC	xm_unall_ptr
	PUBLIC	xm_han_alloc_ptr

	EXTRN	XM_HANDLE_RET:word
	EXTRN	XM_LOG:byte
	EXTRN	XM_PHY:byte
	EXTRN	XM_PAGE_CNT:word
	EXTRN	XM_FRAME:word
	EXTRN	XM_DEALL_HAN:word
	EXTRN	XM_ALLOC_PG:word
	EXTRN	XM_TOTAL_PG:word
	EXTRN	XM_HAN_ALLOC:word
	EXTRN	XM_HAN_TOTAL:word

;=========================================================================
;		    begin parameter sublists
;=========================================================================

;======================= unassemble parameter sublists ===================

db_unassem_sb1 label dword		;an000;unassemble parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad

db_unassem_sb2 label dword		;an000;unassemble parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:opbuf		;an000;point to argument buffer
	db	02			;an000;parameter two
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad


;================== hex argument parameter sublists ======================

db_hexarg_sb1 label dword		;an000;hex argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:hex_arg1		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;right align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_hexarg_sb2 label dword		;an000;hex argument parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:hex_arg2		;an000;point to argument buffer
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_hexarg_sb3 label dword		;an000;hex argument parameter 3
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	03			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum width
	db	pad_blank		;an000;blank pad


;================== hex add parameter sublists ===========================

db_hexadd_sb1 label dword		;an000;hex add parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:add_arg		;an000;point to add_arg
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_hexadd_sb2 label dword		;an000;hex argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:sub_arg		;an000;point to sub_arg
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== end hex add parameter sublists =======================

;================== single register parameter sublists ===================
;string: "%1 %2",13,10,":",0

db_singrg_sb1 label dword		;an000;single register parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_singrg_sb2 label dword		;an000;single register parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:single_reg_arg	;an000;point single_reg_arg
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== register parameter sublists ==========================
;string: "%1=%2  ",0

db_regist_sb1 label dword		;an000;register parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:reg_name		;an000;point to reg_name
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	02			;an000;unlimited width
	db	02			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_regist_sb2 label dword		;an000;register parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:reg_contents 	;an000;point to reg_contents
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== error message parameter sublists =====================
;string: "%1 Error",0

db_error_sb1 label dword		;an000;error message parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:err_type		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

;================== writing message parameter sublists ===================
;string: "Writing %1%2 bytes",0

db_wrtmes_sb1 label dword		;an000;wrtmes parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:wrt_arg1		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;right align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_wrtmes_sb2 label dword		;an000;wrtmes parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:wrt_arg2		;an000;point to argument buffer
	db	02			;an000;parameter two
;C07	db	left_align+bin_hex_word
	db	right_align+bin_hex_word                                  ;C07
					;an000;left align/word/hexadecimal
;C02	db	04			;an000;maximum of 4 bytes
;C02	db	04			;an000;minimum of 4 bytes
;C07	db	01			;an000;maximum of 4 bytes	    ;C02
;C07	db	00			;an000;minimum of 4 bytes	    ;C02
	db	04			;an000;maximum of 4 bytes	  ;C07
	db	01			;an000;minimum of 4 bytes         ;C07
	db	pad_zero		;an000;blank pad

;================== loc address parameter sublists =======================
;string: "%1:%2=",0

db_locadd_sb1 label dword		;an000;loc address parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	right_align+Char_field_ASCIIZ
					;an000;left align/ASCIZZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_locadd_sb2 label dword		;an000;loc address parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:loc_add		;an000;point to loc_add
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;================== little contents parameter sublists ===================
;string "%1",0

db_little_sb1 label dword		;an000;one byte output parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:little_contents	;an000;point to little_contents
	db	01			;an000;parameter one
	db	right_align+bin_hex_byte
					;an000;left align/byte/hexadecimal
	db	02			;an000;maximum of 2 bytes
	db	02			;an000;minimum of 2 bytes
	db	pad_zero		;an000;blank pad

;================== big argument parameter sublists ======================
;string: "%1",0

db_big_sb1 label dword			;an000;word argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:big_contents 	;an000;point to big_contents
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;======================= comp argument parameter sublists ================
;string "%1:%2  %3  %4  %5:%6",0

db_comp_sb1 label dword 		;an000;comp argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg1		;an000;point to comp_arg1
	db	01			;an000;parameter one
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb2 label dword 		;an000;comp argument parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg2		;an000;point to comp_arg2
	db	02			;an000;parameter two
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb3 label dword 		;an000;comp argument parameter 3
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg3		;an000;point to comp_arg3
	db	03			;an000;parameter three
	db	right_align+bin_hex_byte
					;an000;left align/byte/hexadecimal
	db	02			;an000;maximum of 2 bytes
	db	02			;an000;minimum of 2 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb4 label dword 		;an000;comp argument parameter 4
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg4		;an000;point to comp_arg4
	db	04			;an000;parameter four
	db	right_align+bin_hex_byte
					;an000;left align/byte/hexadecimal
	db	02			;an000;maximum of 2 bytes
	db	02			;an000;minimum of 2 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb5 label dword 		;an000;comp argument parameter 5
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg5		;an000;point to comp_arg5
	db	05			;an000;parameter five
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

db_comp_sb6 label dword 		;an000;comp argument parameter 6
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:comp_arg6		;an000;
	db	06			;an000;parameter 6
	db	right_align+bin_hex_word
					;an000;left align/word/hexadecimal
	db	04			;an000;maximum of 4 bytes
	db	04			;an000;minimum of 4 bytes
	db	pad_zero		;an000;blank pad

;======================= disk error parameter sublists ===================
;string: "%1 error %2 drive %3",0

db_disk_sb1 label dword 		;an000;disk argument parameter 1
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:mestyp		;an000;point to mestyp
	db	01			;an000;parameter one
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_disk_sb2 label dword 		;an000;disk argument parameter 2
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:iotyp		;an000;point to iotyp
	db	02			;an000;parameter two
	db	left_align+Char_field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

db_disk_sb3 label dword 		;an000;disk argument parameter 3
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:drive		;an000;point to drive
	db	03			;an000;parameter three
	db	left_align+char_field_char
					;an000;left align/character/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

arg_buf_sb1 label dword 		;an000;argument sublist
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:arg_buf		;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_Field_ASCIIZ
					;an000;left align/ASCIIZ/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

one_char_sb1 label dword		;an000;character buffer sublist
	db	Sublist_Length		;an000;sublist size
	db	reserved		;an000;reserved
	dd	dg:one_char_buf 	;an000;point to argument buffer
	db	01			;an000;parameter one
	db	left_align+Char_Field_Char
					;an000;left align/character/character
	db	unlim_width		;an000;unlimited width
	db	00			;an000;minimum of 0 bytes
	db	pad_blank		;an000;blank pad

xm_han_sub	label	dword		;an000;sublist for handles
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HANDLE_RET	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_map_sub	label	dword		;an000;sublist for mappings
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_LOG		;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Byte;an000;
	db	02			;an000;maximum width
	db	02			;an000;minimum width
	db	30h			;an000;pad with zeros

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_PHY		;an000;parameter 2
	db	02			;an000;parameter 2
	db	right_align+Bin_Hex_Byte;an000;
	db	02			;an000;maximum width
	db	02			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_sta_sub	label	word		;an000;sublist for status
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HANDLE_RET	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_PAGE_CNT		;an000;parameter 2
	db	02			;an000;parameter 2
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_page_seg_sub label	word		;an000;sublist for frame seg status
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_PHY		;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Byte;an000;
	db	02			;an000;maximum width
	db	02			;an000;minimum width
	db	30h			;an000;pad with zeros

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_FRAME		;an000;parameter 2
	db	02			;an000;parameter 2
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_deall_sub	label	word		;an000;sublist for handle deallocation
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_DEALL_HAN 	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Byte;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	30h			;an000;pad with zeros

xm_unall_sub	label	word		;an000;sublist unallocated page report
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_ALLOC_PG		;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with blanks

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_TOTAL_PG		;an000;parameter 1
	db	02			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with zeros


xm_han_alloc_sub label	 word		 ;an000;sublist unallocated page report
	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HAN_ALLOC 	;an000;parameter 1
	db	01			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with blanks

	db	Sublist_Length		;an000;11 bytes
	db	Reserved		;an000;reserved field
	dd	dg:XM_HAN_TOTAL 	;an000;parameter 1
	db	02			;an000;parameter 1
	db	right_align+Bin_Hex_Word;an000;
	db	04			;an000;maximum width
	db	04			;an000;minimum width
	db	20h			;an000;pad with zeros
;=========================================================================
;		    end parameter sublists
;=========================================================================


unassem_ln_ptr label word		;an000;"%1%2",0
	dw	0032			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_unassem_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


hex_ptr label	word			;an000;"%1:%2 %3",0
	dw	0033			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_hexarg_sb1	;an000;sublist
	dw	03			;an000;3 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


add_ptr label	word			;an000;"%1  %2",0
	dw	0034			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_hexadd_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer



single_reg_ptr label word		;an000;"%1 %2",13,10,":",0
	dw	0035			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_singrg_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer



register_ptr label word 		;an000;"%1=%2  ",0 ex: AX=FFFF
	dw	0036			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_regist_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


errmes_ptr label word			;an000;"%1 Error",0
	dw	0037			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_error_sb1 	;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


wrtmes_ptr label word			;an000;"Writing %1 bytes",0
	dw	0038			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_wrtmes_sb1	;an000;sublist
;C02	dw	01			;an000;1 sub
	dw	02			;an000;1 sub			   ;C02
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


loc_ptr label	word			;an000:"%1;%2=",0 ex:CX:0000
	dw	0039			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_locadd_sb1	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


little_ptr label word			;an000;"%1",0 ex:FF
	dw	0040			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_little_sb1	;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


big_ptr label	word			;an000;"%1",0
	dw	0041			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_big_sb1		;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


comp_ptr label	word			;an000;"%1:%2  %3  %4  %5:%6",0
	dw	0042			;an000;message number
	db	UTILITY_MSG_CLASS	   ;an000;utility message
	dw	stdout			;an000;display handle
	dw	dg:db_comp_sb1		;an000;sublist
	dw	06			;an000;6 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


arg_buf_ptr label	word		;an000;"%1"
	dw	0046			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:arg_buf_sb1		;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer


one_char_buf_ptr label	word		;an000;"%1"
	dw	0047			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:one_char_sb1 	;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_unall_ptr	label	word		;an000;unallocated message report
	dw	0050			;an000;"%1 of a total %2 EMS pages
					;      have been allocated",cr,lf
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_UNALL_SUB 	;an000;sublist
	dw	02			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_han_alloc_ptr label	 word		;an000;unallocated message report
	dw	0051			;an000;"%1 of a total %2 EMS handles
					;      have been allocated",cr,lf
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_HAN_ALLOC_SUB	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_han_ret_ptr	label	word		;an000;prints handle created
	dw	0055			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_HAN_SUB		;an000;sublist
	dw	01			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_mapped_ptr	label	word		;an000;prints log/phy pages
	dw	0056			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_MAP_SUB		;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err80_ptr	label	word		;an000;ems error message
	dw	0057			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err83_ptr	label	word		;an000;ems error message
	dw	0058			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err84_ptr	label	word		;an000;ems error message
	dw	0059			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err85_ptr	label	word		;an000;ems error message
	dw	0060			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err86_ptr	label	word		;an000;ems error message
	dw	0061			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err87_ptr	label	word		;an000;ems error message
	dw	0062			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err88_ptr	label	word		;an000;ems error message
	dw	0063			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err89_ptr	label	word		;an000;ems error message
	dw	0064			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8a_ptr	label	word		;an000;ems error message
	dw	0065			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8b_ptr	label	word		;an000;ems error message
	dw	0066			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8d_ptr	label	word		;an000;ems error message
	dw	0067			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err8e_ptr	label	word		;an000;ems error message
	dw	0068			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_err_gen_ptr	label	word		;an000;ems error message
	dw	0070			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_parse_err_ptr label	word		;an000;input error message
	dw	0071			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;1 sub
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_status_ptr	label	word		;an000;prints status of EMS
	dw	0072			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_STA_SUB		;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_page_seg_ptr label	word		;an000;"Physical page %1 = Frame
					;	segment %2"
	dw	0075			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_PAGE_SEG_SUB	;an000;sublist
	dw	02			;an000;2 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_deall_ptr	label	word		;an000;"Handle %1 deallocated"

	dw	0076			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	dg:XM_DEALL_SUB 	;an000;sublist
	dw	01			;an000;1 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

xm_errff_ptr	    label word		;an000;"EMS not installed"

	dw	0078			;an000;message number
	db	UTILITY_MSG_CLASS	;an000;utility messages
	dw	stdout			;an000;display handle
	dw	00			;an000;sublist
	dw	00			;an000;0 subs
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_1 label	word			;
	dw	0090			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_2 label	word			;
	dw	0091			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_3 label	word			;
	dw	0092			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00
			;an000;no keyboard buffer
qmes_4 label	word			;
	dw	0093			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

qmes_5 label	word			;
	dw	0094			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text1	label	word
	dw	0100			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text2	label	word
	dw	0101			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text3	label	word
	dw	0102			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text4	label	word
	dw	0103			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text5	label	word
	dw	0104			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

help_text6	label	word
	dw	0105			;message number
	db	UTILITY_MSG_CLASS	;utility message
	dw	stdout			;an000;display handle
	dw	00
	dw	00
	db	no_input		;an000;no keyboard input
	dw	00			;an000;no keyboard buffer

arg_buf 	db   80 dup (?) 	;an000;argument buffer
one_char_buf	db   ?			;an000;character buffer

opbuf	db	51h dup (?)

hex_arg1 dw	?
hex_arg2 dw	?

add_arg dw	?
sub_arg dw	?

single_reg_arg dw ?

reg_name dw	?
reg_contents dw ?

err_type db	3	dup(0)		;ac000;changed to hold bf,bp,etc.

wrt_arg1 dw	?
wrt_arg2 dw	?

loc_add dw	?

little_contents dw ?
big_contents dw ?

comp_arg1 dw	?
comp_arg2 dw	?
comp_arg3 dw	?
comp_arg4 dw	?
comp_arg5 dw	?
comp_arg6 dw	?

mestyp	dw	?
iotyp	dw	?
drive	db	?


DATA	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debuasm.asm ===
PAGE    80,132 ;
	   TITLE DEBUASM.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; Code for the UASSEMble command in the debugger

	    IF1
		%OUT COMPONENT=DEBUG, MODULE=DEBUASM
	    ENDIF
.XLIST
.XCREF
	   include version.inc		; cas -- missing equates
	   INCLUDE DOSSYM.INC
           INCLUDE debug.inc
.CREF
.LIST
CODE	   SEGMENT PUBLIC BYTE
CODE	   ENDS

CONST	   SEGMENT PUBLIC BYTE
	   EXTRN SYNERR_PTR:BYTE,UNASSEM_LN_PTR:WORD
	   EXTRN NSEG:WORD,SISAVE:WORD,BPSAVE:WORD,DISAVE:WORD
	   EXTRN BXSAVE:WORD,DSSAVE:WORD,ESSAVE:WORD,CSSAVE:WORD,IPSAVE:WORD
	   EXTRN SSSAVE:WORD,CXSAVE:WORD,SPSAVE:WORD,FLSAVE:WORD
	   EXTRN DISTAB:WORD,SHFTAB:WORD,IMMTAB:WORD,GRP1TAB:WORD,GRP2TAB:WORD
	   EXTRN DBMN:BYTE,ESCMN:BYTE,DISPB:WORD,STACK:BYTE,REG8:BYTE
	   EXTRN REG16:BYTE,SREG:BYTE,SIZ8:BYTE,SEGTAB:WORD,M8087_TAB:BYTE
	   EXTRN FI_TAB:BYTE,SIZE_TAB:BYTE,MD9_TAB:BYTE,MD9_TAB2:BYTE
	   EXTRN MDB_TAB:BYTE,MDB_TAB2:BYTE,MDD_TAB:BYTE,MDD_TAB2:BYTE
	   EXTRN MDF_TAB:BYTE
CONST	   ENDS

CSTACK	   SEGMENT STACK
CSTACK	   ENDS

DATA	   SEGMENT PUBLIC BYTE
	   EXTRN DISADD:BYTE,DISCNT:WORD,BYTCNT:BYTE,TEMP:BYTE,AWORD:BYTE
	   EXTRN MIDFLD:BYTE,MODE:BYTE,REGMEM:BYTE,OPCODE:WORD,OPBUF:BYTE
	   EXTRN INDEX:WORD,ARG_BUF:BYTE,ARG_BUF_PTR:BYTE,ARG_BUF_INDEX:WORD
	   EXTRN OPBUF:BYTE,OPCODE:WORD
DATA	   ENDS

DG	   GROUP CODE,CONST,CSTACK,DATA

CODE	   SEGMENT PUBLIC BYTE
	   ASSUME CS:DG,DS:DG,ES:DG,SS:DG

	   PUBLIC UNASSEM
	   PUBLIC DISASLN,MEMIMM,JMPCALL,SIGNIMM,ALUFROMREG,WORDTOALU
	   PUBLIC GRP2,PREFIX,OUTVARW,GRP1,SSPRE,MOVSEGTO,DSPRE,SHIFT
	   PUBLIC ESPRE,IMMED,CSPRE,OUTVARB,CHK10,ACCIMM,INT3,INVARB
	   PUBLIC MOVSEGFROM,LOADACC,OUTFIXB,XCHGAX,REGIMMW,SHORTJMP
	   PUBLIC SAV8,M8087,M8087_DB,M8087_DF,M8087_D9,M8087_DD
	   PUBLIC SAV16,SAVHEX,INFIXW,REGIMMB,OUTFIXW,SHIFTV,LONGJMP
	   PUBLIC INVARW,STOREACC,INFIXB,NOOPERANDS,ALUTOREG
	   PUBLIC SEGOP,REGOP,GETADDR

	   EXTRN CRLF:NEAR,BLANK:NEAR,TAB:NEAR,STD_PRINTF:NEAR
	   EXTRN HEX:NEAR,DEFAULT:NEAR,OUTSI:NEAR,OUTDI:NEAR
	   EXTRN HEX_ADDRESS_ONLY:NEAR

UNASSEM:
	   MOV	BP,[CSSAVE]		; Default code segment
	   MOV	DI,OFFSET DG:DISADD	; Default address
	   MOV	CX,DISPB		; Default length
	   SHR	CX,1
	   SHR	CX,1
	   CALL DEFAULT
	   MOV	WORD PTR [DISADD],DX	; Displacement of disassembly
	   MOV	WORD PTR [DISADD+2],AX	; Segment
	   MOV	WORD PTR [DISCNT],CX	; No. of bytes (but whole instructions)
DISLP:
	   CALL DISASLN 		; Disassemble one line
	   CALL CRLF
	   TEST [DISCNT],-1		; See if we've used up the range
	   JNZ	DISLP
	   RET

GOTDIS:
	   PUSH DS			; RE-GET LAST BYTE
	   PUSH SI
	   LDS	SI,DWORD PTR [DISADD]
	   MOV	AL,[SI-1]
	   POP	SI
	   POP	DS
	   RET

GETDIS:
	   PUSH DS
	   LDS	SI,DWORD PTR [DISADD]
	   LODSB			; Get the next byte of code
	   POP	DS
	   MOV	WORD PTR [DISADD],SI	; Update pointer
	   PUSH AX
	   PUSH DI
	   MOV	DI,[ARG_BUF_INDEX]
	   CALL HEX			; Display each code byte
	   MOV	[ARG_BUF_INDEX],DI
	   POP	DI
	   MOV	SI,[DISCNT]
	   OR	SI,SI			; Check if range exhausted
	   JZ	ENDRNG			; If so, don't wrap around
	   DEC	SI			; Count off the bytes
	   MOV	[DISCNT],SI
ENDRNG:
	   INC	BYTE PTR[BYTCNT]	; Keep track of no. of bytes per line
	   POP	AX
	   RET

DSPRE:
	   INC	BYTE PTR [NSEG+1]
SSPRE:
	   INC	BYTE PTR [NSEG+1]
CSPRE:
	   INC	BYTE PTR [NSEG+1]
ESPRE:
	   INC	BYTE PTR [NSEG+1]

PREFIX:
	   POP	BX			; Dump off return address
	   CALL FINLN
	   CALL CRLF
DISASLN:
	   PUSH DS
	   LDS	SI,DWORD PTR [DISADD]
	   CALL OUTSI			; Show disassembly address
	   POP	DS
	   CALL HEX_ADDRESS_ONLY
DISASLN1:
	   MOV	BYTE PTR [BYTCNT],0	; Count of code bytes per line
; Fill overflow area with zeros
	   MOV	DI,OFFSET DG:OPBUF
	   MOV	CX,50
	   MOV	AL,0
	   REP	STOSB
; fill buffer with spaces
	   MOV	DI,OFFSET DG:OPBUF
	   MOV	CX,OPBUFLEN
	   MOV	AL," "
	   REP	STOSB
	   MOV	DI,OFFSET DG:ARG_BUF
	   MOV	[ARG_BUF_INDEX],DI
	   CALL GETDIS			; Get opcode
	   MOV	DI,[ARG_BUF_INDEX]
	   MOV	AH,0
	   MOV	BX,AX
	   AND	AL,1			; Mask to "W" bit
	   MOV	[AWORD],AL
	   MOV	AL,BL			; Restore opcode
	   SHL	BX,1
	   SHL	BX,1			; Multiply opcode by 4
	   ADD	BX,OFFSET DG:DISTAB
	   MOV	DX,[BX] 		; Get pointer to mnemonic from table
	   MOV	[OPCODE],DX
	   MOV	[ARG_BUF_INDEX],DI
	   MOV	DI,OFFSET DG:OPBUF
	   CALL WORD PTR [BX+2]
FINLN:
	   MOV	AH,[BYTCNT]		; See how many bytes in this instruction
	   ADD	AH,AH			; Each uses two characters
	   MOV	AL,14			; Amount of space we want to use
	   SUB	AL,AH			; See how many fill characters needed
	   CBW
	   XCHG CX,AX			; Parameter for TAB needed in CX
	   MOV	DI,[ARG_BUF_INDEX]
	   CALL TAB
	   MOV	SI,[OPCODE]
	   OR	SI,SI
	   JZ	GET_TAB
GET_OPCODE:
	   LODSB
	   OR	AL,AL
	   JZ	GET_TAB
	   STOSB
	   JMP	GET_OPCODE

GET_TAB:
	   MOV	AL,9
	   STOSB
	   MOV	BYTE PTR [DI],0 	; nul terminate address buffer
	   MOV	DX,OFFSET DG:UNASSEM_LN_PTR
	   CALL STD_PRINTF
	   RET

GETMODE:
	   CALL GETDIS			; Get the address mode byte
	   MOV	AH,AL
	   AND	AL,7			; Mask to "r/m" field
	   MOV	[REGMEM],AL
	   SHR	AH,1
	   SHR	AH,1
	   SHR	AH,1
	   MOV	AL,AH
	   AND	AL,7			; Mask to center 3-bit field
	   MOV	[MIDFLD],AL
	   SHR	AH,1
	   SHR	AH,1
	   SHR	AH,1
	   MOV	[MODE],AH		; Leaving 2-bit "MOD" field
	   RET

IMMED:
	   MOV	BX,OFFSET DG:IMMTAB
	   CALL GETMNE
FINIMM:
	   CALL TESTREG
	   JMP	SHORT IMM

MEMIMM:
	   CALL GETMODE
	   JMP	SHORT FINIMM

ACCIMM:
	   XOR	AL,AL
IMM1:
	   CALL SAVREG
IMM:
	   MOV	AL,","
	   STOSB
	   TEST BYTE PTR [AWORD],-1
	   JNZ	SAV16
SAV8:
	   CALL GETDIS
	   JMP	SHORT SAVHEX

LONGJMP:
	   PUSH DI
	   MOV	DI,OFFSET DG:TEMP
	   CALL SAV16
	   POP	DI
	   CALL SAV16
	   MOV	AL,":"
	   STOSB
	   MOV	SI,OFFSET DG:TEMP
	   MOV	CX,4
MOVDIG:
	   LODSB
	   STOSB
	   LOOP MOVDIG
	   RET

SAV16:
	   CALL GETDIS			; Get low byte
	   MOV	DL,AL
	   CALL GETDIS			; Get high byte
	   MOV	DH,AL
	   CALL SAVHEX			; Convert and store high byte
	   MOV	AL,DL
SAVHEX:
	   MOV	AH,AL
	   SHR	AL,1
	   SHR	AL,1
	   SHR	AL,1
	   SHR	AL,1
	   CALL SAVDIG
	   MOV	AL,AH
SAVDIG:
	   AND	AL,0FH
	   ADD	AL,90H
	   DAA
	   ADC	AL,40H
	   DAA
	   STOSB
	   RET

CHK10:
	   CALL GETDIS
	   CMP	AL,10
	   JNZ	SAVHEX
	   RET

SIGNIMM:
	   MOV	BX,OFFSET DG:IMMTAB
	   CALL GETMNE
	   CALL TESTREG
	   MOV	AL,","
	   STOSB
SAVD8:
	   CALL GETDIS			; Get signed 8-bit number
	   CBW
	   MOV	DX,AX			; Save true 16-bit value in DX
	   MOV	AH,AL
	   MOV	AL,"+"
	   OR	AH,AH
;	JZ	NOSIGN
	   JNS	POSITIV 		; OK if positive
	   MOV	AL,"-"
	   NEG	AH			; Get magnitude if negative
POSITIV:
	   STOSB
; NOSIGN:
	   MOV	AL,AH
	   JMP	SHORT SAVHEX

ALUFROMREG:
	   CALL GETADDR
	   MOV	AL,","
	   STOSB
REGFLD:
	   MOV	AL,[MIDFLD]
SAVREG:
	   MOV	SI,OFFSET DG:REG8
	   CMP	BYTE PTR [AWORD],1
	   JNE	FNDREG
SAVREG16:
	   MOV	SI,OFFSET DG:REG16
FNDREG:
	   CBW
	   ADD	SI,AX
	   ADD	SI,AX
	   MOVSW
	   RET

SEGOP:
	   SHR	AL,1
	   SHR	AL,1
	   SHR	AL,1
SAVSEG:
	   AND	AL,3
	   MOV	SI,OFFSET DG:SREG
	   JMP	SHORT FNDREG

REGOP:
	   AND	AL,7
	   JMP	SHORT SAVREG16

MOVSEGTO:
	   MOV	BYTE PTR [AWORD],1
	   CALL GETADDR
	   MOV	AL,","
	   STOSB
	   MOV	AL,[MIDFLD]
	   JMP	SHORT SAVSEG

MOVSEGFROM:
	   CALL GETMODE
	   CALL SAVSEG
	   MOV	BYTE PTR [AWORD],1
	   JMP	SHORT MEMOP2

GETADDR:
	   CALL GETMODE
	   JMP	SHORT ADDRMOD

WORDTOALU:
	   MOV	BYTE PTR [AWORD],1
ALUTOREG:
	   CALL GETMODE
	   CALL REGFLD
MEMOP2:
	   MOV	AL,","
	   STOSB
ADDRMOD:
	   CMP	BYTE PTR [MODE],3
	   MOV	AL,[REGMEM]
	   JE	SAVREG
	   XOR	BX,BX
	   MOV	BYTE PTR [NSEG],3
	   MOV	BYTE PTR [DI],"["
	   INC	DI
	   CMP	AL,6
	   JNE	NODRCT
	   CMP	BYTE PTR [MODE],0
	   JE	DIRECT			; Mode=0 and R/M=6 means direct addr.
NODRCT:
	   MOV	DL,AL
	   CMP	AL,1
	   JBE	USEBX
	   CMP	AL,7
	   JE	USEBX
	   CMP	AL,3
	   JBE	USEBP
	   CMP	AL,6
	   JNE	CHKPLS
USEBP:
	   MOV	BX,[BPSAVE]
	   MOV	BYTE PTR [NSEG],2	; Change default to Stack Segment
	   MOV	AX,BPREG
SAVBASE:
	   STOSW
CHKPLS:
	   CMP	DL,4
	   JAE	NOPLUS
	   MOV	AL,"+"
	   STOSB
NOPLUS:
	   CMP	DL,6
	   JAE	DOMODE			; No index register
	   AND	DL,1			; Even for SI, odd for DI
	   JZ	USESI
	   ADD	BX,[DISAVE]
	   MOV	AX,DIREG
SAVINDX:
	   STOSW
DOMODE:
	   MOV	AL,[MODE]
	   OR	AL,AL
	   JZ	CLOSADD 		; If no displacement, then done
	   CMP	AL,2
	   JZ	ADDDIR
	   CALL SAVD8			; Signed 8-bit displacement
ADDCLOS:
	   ADD	BX,DX
CLOSADD:
	   MOV	AL,"]"
	   STOSB
	   MOV	[INDEX],BX
NOOPERANDS:
	   RET

ADDDIR:
	   MOV	AL,"+"
	   STOSB
DIRECT:
	   CALL SAV16
	   JMP	SHORT ADDCLOS

USEBX:
	   MOV	BX,[BXSAVE]
	   MOV	AX,BXREG
	   JMP	SHORT SAVBASE

USESI:
	   ADD	BX,[SISAVE]
	   MOV	AX,SIREG
	   JMP	SHORT SAVINDX

SHORTJMP:
	   CALL GETDIS
	   CBW
	   ADD	AX,WORD PTR [DISADD]
	   XCHG DX,AX
SAVJMP:
	   MOV	AL,DH
	   CALL SAVHEX
	   MOV	AL,DL
	   JMP	SAVHEX

JMPCALL:
	   CALL GETDIS
	   MOV	DL,AL
	   CALL GETDIS
	   MOV	DH,AL
	   ADD	DX,WORD PTR [DISADD]
	   JMP	SHORT SAVJMP

XCHGAX:
	   AND	AL,7
	   CALL SAVREG16
	   MOV	AL,","
	   STOSB
	   XOR	AL,AL
	   JMP	SAVREG16

LOADACC:
	   XOR	AL,AL
	   CALL SAVREG
	   MOV	AL,","
	   STOSB
MEMDIR:
	   MOV	AL,"["
	   STOSB
	   XOR	BX,BX
	   MOV	BYTE PTR [NSEG],3
	   JMP	DIRECT

STOREACC:
	   CALL MEMDIR
	   MOV	AL,","
	   STOSB
	   XOR	AL,AL
	   JMP	SAVREG

REGIMMB:
	   MOV	BYTE PTR [AWORD],0
	   JMP	SHORT REGIMM

REGIMMW:
	   MOV	BYTE PTR [AWORD],1
REGIMM:
	   AND	AL,7
	   JMP	IMM1

INT3:
	   MOV	BYTE PTR [DI],"3"
	   INC	DI
	   RET

;  8087 instructions whose first byte is 0dfh
M8087_DF:
	   CALL GET64F
	   JZ	ISDD3
	   MOV	SI,OFFSET DG:MDF_TAB
	   JMP	short NODB3

;  8087 instructions whose first byte is 0ddh
M8087_DD:
	   CALL GET64F
	   JZ	ISDD3
	   MOV	SI,OFFSET DG:MDD_TAB
	   JMP	short NOD93

ISDD3:
	   MOV	AL,DL
	   TEST AL,100B
	   JZ	ISSTI
	   JMP	ESC0

ISSTI:
	   AND	AL,11B
	   MOV	SI,OFFSET DG:MDD_TAB2
	   MOV	CL,AL
	   CALL MOVBYT
	   JMP	short PUTRST

;  8087 instructions whose first byte is 0dbh
M8087_DB:
	   CALL GET64F
	   JZ	ISDB3
	   MOV	SI,OFFSET DG:MDB_TAB
NODB3:
	   CALL PUTOP
	   CALL PUTSIZE
	   JMP	ADDRMOD

ISDB3:
	   MOV	AL,DL
	   TEST AL,100B
	   JNZ	ISDBIG
ESC0V:
	   JMP	ESC0

ISDBIG:
	   CALL GOTDIS
	   AND	AL,11111B
	   CMP	AL,4
	   JAE	ESC0V
	   MOV	SI,OFFSET DG:MDB_TAB2
	   JMP	short DOBIG

;  8087 instructions whose first byte is 0d9h
M8087_D9:
	   CALL GET64F
	   JZ	ISD93

	   MOV	SI,OFFSET DG:MD9_TAB
NOD93:
	   CALL PUTOP
	   AND	AL,111B
	   CMP	AL,3
	   JA	NOSHO
	   MOV	AL,DL
	   CALL PUTSIZE
NOSHO:
	   JMP	ADDRMOD

ISD93:
	   MOV	AL,DL
	   TEST AL,100B
	   JNZ	ISD9BIG
	   AND	AL,111B
	   OR	AL,AL
	   JNZ	NOTFLD
	   MOV	AX,"DL"
	   STOSW
	   JMP	SHORT PUTRST

NOTFLD:
	   CMP	AL,1
	   JNZ	NOTFXCH
	   MOV	AX,"CX"
	   STOSW
	   MOV	AL,"H"
	   JMP	SHORT PUTRST1

NOTFXCH:
	   CMP	AL,3
	   JNZ	NOTFSTP
	   MOV	AX,"TS"
	   STOSW
	   MOV	AL,"P"
PUTRST1:
	   STOSB
PUTRST:
	   MOV	AL,9
	   STOSB
	   JMP	short PUTST0

NOTFSTP:
	   CALL GOTDIS
	   CMP	AL,11010000B		; CHECK FOR FNOP
	   JZ	GOTFNOP
	   JMP	ESC0

GOTFNOP:
	   MOV	AX,"ON"
	   STOSW
	   MOV	AL,"P"
	   STOSB
	   RET

ISD9BIG:
	   CALL GOTDIS			; GET THE MODE BYTE
	   MOV	SI,OFFSET DG:MD9_TAB2
DOBIG:
	   AND	AL,11111B
	   MOV	CL,AL
	   JMP	MOVBYT

; entry point for the remaining 8087 instructions
M8087:
	   CALL GET64
	   CALL PUTFI			; PUT FIRST PART OF OPCODE
	   MOV	AL,DL
	   CMP	BYTE PTR [MODE],11B	; CHECK FOR REGISTER MODE
	   JZ	MODEIS3
	   CALL PUTMN			; PUT MIDDLE PART OF OPCODE
NO3:
	   MOV	AL,9			; OUTPUT A TAB
	   STOSB
	   MOV	AL,DL
	   CALL PUTSIZE 		; OUTPUT THE OPERAND SIZE
	   JMP	ADDRMOD

MODEIS3:
	   TEST AL,100000B		; D BIT SET?
	   JZ	MPUT			; NOPE...
	   TEST AL,000100B		; FDIV OR FSUB?
	   JZ	MPUT			; NOPE...
	   XOR	AL,1			; REVERSE SENSE OF R
	   MOV	DL,AL			; SAVE CHANGE
MPUT:
	   CALL PUTMN			; PUT MIDDLE PART OF OPCODE
	   MOV	AL,DL
	   TEST AL,010000B
	   JZ	NOPSH
	   MOV	AL,"P"
	   STOSB
NOPSH:
	   MOV	AL,9
	   STOSB
	   MOV	AL,DL
	   AND	AL,00000111B
	   CMP	AL,2			; FCOM
	   JZ	PUTST0
	   CMP	AL,3			; FCOMP
	   JZ	PUTST0
	   MOV	AL,DL
	   TEST AL,100000B
	   JZ	PUTSTST0

; output 8087 registers in the form st(n),st
PUTST0ST:
	   CALL PUTST0
	   MOV	AL,','
ISCOMP:
	   STOSB

PUTST:
	   MOV	AX,"TS"
	   STOSW
	   RET

; output 8087 registers in the form st,st(n)
PUTSTST0:
	   CALL PUTST
	   MOV	AL,','
	   STOSB

PUTST0:
	   CALL PUTST
	   MOV	AL,"("
	   STOSB
	   MOV	AL,[REGMEM]
	   ADD	AL,"0"
	   STOSB
	   MOV	AL,")"
	   STOSB
	   RET

; output an 8087 mnemonic
PUTMN:
	   MOV	SI,OFFSET DG:M8087_TAB
	   MOV	CL,AL
	   AND	CL,00000111B
	   JMP	SHORT MOVBYT

; output either 'FI' or 'F' for first byte of opcode
PUTFI:
	   MOV	SI,OFFSET DG:FI_TAB
	   JMP	SHORT PUTFI2

; output size (dword, tbyte, etc.)
PUTSIZE:
	   MOV	SI,OFFSET DG:SIZE_TAB
PUTFI2:
	   CMP	BYTE PTR [MODE],11B	; check if 8087 register
	   JNZ	PUTFI3
	   AND	AL,111000B		; LOOK FOR INVALID FORM OF 0DAH OPERANDS
	   CMP	AL,010000B
	JZ	ESC0PJ
	   MOV	AL,DL
	   CMP	AL,110011B		; FCOMPP
	   JNZ	GOFI
	   CMP	BYTE PTR [REGMEM],1
	JZ	GOFI
ESC0PJ:
	jmp	short ESC0P		; we could've reached without a
;					; double branch here, but we needed
;					; a bridge for ESC0PJ
GOFI:
	   XOR	CL,CL
	   JMP	SHORT MOVBYT

;  Look for qword
PUTFI3:
	   CMP	AL,111101B
	   JZ	GOTQU
	   CMP	AL,111111B
	   JNZ	NOTQU
GOTQU:
	   MOV	CL,2
	   JMP	SHORT MOVBYT

;  look for tbyte
NOTQU:
	   CMP	AL,011101B
	   JZ	GOTTB
	   CMP	AL,111100B
	   JZ	GOTTB
	   CMP	AL,111110B
	   JZ	GOTTB
	   CMP	AL,011111B
	   JNZ	NOTTB
GOTTB:
	   MOV	CL,5
	   JMP	SHORT MOVBYT

NOTTB:
	   MOV	CL,4
	   SHR	AL,CL
	   MOV	CL,AL
; SI POINTS TO A TABLE OF TEXT SEPARATED BY "$"
; CL = WHICH ELEMENT IN THE TABLE YOU WISH TO COPY TO [DI]
MOVBYT:
	   PUSH AX
	   INC	CL
MOVBYT1:
	   DEC	CL
	   JZ	MOVBYT3
MOVBYT2:
	   LODSB
	   CMP	AL,"$"
	   JZ	MOVBYT1
	   JMP	MOVBYT2

MOVBYT3:
	   LODSB
	   CMP	AL,'$'
	   JZ	MOVBYT5
	   CMP	AL,'@'                  ; THIS MEANS RESVERED OP-CODE
	   JNZ	MOVBYT4
	   POP	AX
	   JMP	SHORT ESC0P		; GO DO AN ESCAPE COMMAND

MOVBYT4:
	   STOSB
	   JMP	MOVBYT3

MOVBYT5:
	   POP	AX
	   RET

PUTOP:
	   AND	AL,111B
	   MOV	CL,AL
	   CALL MOVBYT
	   MOV	AL,9
	   STOSB
	   MOV	AL,DL
	   RET

GET64F:
	   CALL GET64
	   MOV	AL,"F"
	   STOSB
	   CMP	BYTE PTR [MODE],3
	   MOV	AL,DL
	   RET

GET64:
	   AND	AL,7
	   MOV	DL,AL
	   CALL GETMODE
	   SHL	DL,1
	   SHL	DL,1
	   SHL	DL,1
	   OR	AL,DL
	   MOV	DL,AL			; SAVE RESULT
	   RET

ESC0P:
	   POP	DI			; CLEAN UP STACK
ESC0:
	   MOV	WORD PTR [OPCODE],OFFSET DG:ESCMN
	   MOV	AL,DL
	   MOV	DI,OFFSET DG:OPBUF
	   JMP	SHORT ESC1

ESCP:
	   CALL GET64
ESC1:
	   CALL SAVHEX
	   CMP	BYTE PTR [MODE],3
	   JZ	SHRTESC
	   MOV	BYTE PTR  [AWORD],1
	   JMP	MEMOP2

SHRTESC:
	   MOV	AL,","
	   STOSB
	   MOV	AL,[REGMEM]
	   AND	AL,7
	   JMP	SAVREG

INVARW:
	   CALL PUTAX
	   JMP	SHORT INVAR

INVARB:
	   CALL PUTAL
INVAR:
	   MOV	AL,','
	   STOSB
	   JMP	short PUTDX

INFIXW:
	   CALL PUTAX
	   JMP	SHORT INFIX

INFIXB:
	   CALL PUTAL
INFIX:
	   MOV	AL,','
	   STOSB
	   JMP	SAV8

	   STOSW			;IS THIS DEAD CODE? EMK
	   RET

OUTVARB:
	   MOV	BX,"LA"
	   JMP	SHORT OUTVAR

OUTVARW:
	   MOV	BX,"XA"
OUTVAR:
	   CALL PUTDX
OUTFV:
	   MOV	AL,','
	   STOSB
	   MOV	AX,BX
	   STOSW
	   RET

OUTFIXB:
	   MOV	BX,"LA"
	   JMP	SHORT OUTFIX

OUTFIXW:
	   MOV	BX,"XA"
OUTFIX:
	   CALL SAV8
	   JMP	OUTFV

PUTAL:
	   MOV	AX,"A"+4C00H            ; "AL"
	   JMP	SHORT PUTX

PUTAX:
	   MOV	AX,"A"+5800H            ; "AX"
	   JMP	SHORT PUTX

PUTDX:
	   MOV	AX,"D"+5800H            ; "DX"
PUTX:
	   STOSW
	   RET

SHFT:
	   MOV	BX,OFFSET DG:SHFTAB
	   CALL GETMNE
TESTREG:
	   CMP	BYTE PTR [MODE],3
	   JZ	NOFLG
	   MOV	SI,OFFSET DG:SIZE_TAB
	   MOV	CL,3
	   TEST BYTE PTR [AWORD],-1
	   JNZ	TEST_1
	   INC	CL
TEST_1:
	   CALL MOVBYT
NOFLG:
	   JMP	ADDRMOD

SHIFTV:
	   CALL SHFT
	   MOV	AL,","
	   STOSB
	   MOV	WORD PTR [DI],"C"+4C00H ; "CL"
	   ADD	DI,2
	   RET

SHIFT:
	   CALL SHFT
	   MOV	AX,"1,"
	   STOSW
	   RET

GETMNE:
	   CALL GETMODE
	   MOV	DL,AL
	   CBW
	   SHL	AX,1
	   ADD	BX,AX
	   MOV	AX,[BX]
	   MOV	[OPCODE],AX
	   MOV	AL,DL
	   RET

GRP1:
	   MOV	BX,OFFSET DG:GRP1TAB
	   CALL GETMNE
	   OR	AL,AL
	   JZ	FINIMMJ
	   JMP	TESTREG
FINIMMJ:
	   JMP	FINIMM

GRP2:
	   MOV	BX,OFFSET DG:GRP2TAB
	   CALL GETMNE
	   CMP	AL,2
	   JB	TESTREG
	   CMP	AL,6
	   JAE	INDIRECT
	   TEST AL,1
	   JZ	INDIRECT
	   MOV	AX,"AF"                 ; "FAR"
	   STOSW
	   MOV	AX," R"
	   STOSW
INDIRECT:
	   JMP	ADDRMOD

CODE	   ENDS
	   END	UNASSEM

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\sysver.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


		   IF1
                       %OUT Including ..SYSVER.FAL..
		   ENDIF

SYSVER		   EQU	FALSE		; if true, i/o direct to bios
					; so DOS can be debugged


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debug.inc ===
;**************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;*									                                                               * 
;*  Change History:							                                                *
;*									                                                               *
;*  DATE   ID	MSFT#  STR#	      Descripton			                             *
;* ------ ----	----- -----  --------------------------------------------  *
;* 05APR90 C05	 990  ????   The XS command always returned a value of	    *
;*	                  		     (FF) for the total number of handles that	    *
;*                  			     are supported.  Now, for EMS V4.0, the	       *
;*			                       actual # of total handles will be displayed.  *
;*                  			     See also: DEBEMS.SAL module.		                *
;**************************************************************************

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBEQU.SAL
;
; DESCRIPTIVE NAME: EQUATES NEEDED BY DEBUG
;
; FUNCTION: PROVIDES EQUATES NEEDED BY DEBUG
;
; ENTRY POINT: NA
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES: NA
;
; EXTERNAL REFERENCES: NA
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- > 32 MB SUPPORT		DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;======================= END OF SPECIFICATIONS ===========================


; Version control switches moved to VERSION.INC

	INCLUDE SYSVER.INC

SETCNTC EQU	TRUE			; If this is FALSE, DEBUG will not set
					; the Control C int vector

PROMPT	EQU	"-"
FCB	EQU	5CH
EXEFCB	EQU	FCB
BUFLEN	EQU	80			; Maximum length of line input buffer
BPMAX	EQU	10			; Maximum number of breakpoints
BPLEN	EQU	5*BPMAX 		; Length of breakpoint table
REGTABLEN EQU	14			; Number of registers
SEGDIF	EQU	0
BUFSIZ	EQU	512

BXREG	EQU	"B"+5800H		; "BX"
BPREG	EQU	"B"+5000H		; "BP"
SIREG	EQU	"S"+4900H		; "SI"
DIREG	EQU	"D"+4900H		; "DI"
COMMA	EQU	2C00H
OPBUFLEN EQU	35

	IF	IBMVER
MASK_PORT   EQU     21H 		; 8259 interrupt control register
INT_MASK    EQU     11111111B		; Disable ALL interrupts
	ENDIF

CR	EQU	13			;CARRIAGE RETURN
LF	EQU	10			;LINE FEED
CHAR_TAB EQU	9			;TAB
CHAR_BACKSPACE EQU 8			;BACKSPACE CHARACTER
CHAR_EOF EQU	1AH			;END OF FILE CHARACTER
CHAR_RUBOUT EQU 7FH			;RUBOUT CHARACTER

CHAR_EQUAL EQU	"="			;CHARACTER EQUAL
CHAR_MINUS EQU	"-"			;MINUS CHARACTER
CHAR_BLANK EQU	" "			;BLANK CHARACTER
DOUBLE_QUOTE EQU '"'			;DOUBLE QUOTE CHARACTER
SINGLE_QUOTE EQU "'"			;SINGLE QUOTE CHARACTER
CHAR_COMMA EQU	","			;CHARACTER COMMA
CHAR_PERIOD EQU "."			;CHARACTER PERIOD
CHAR_COLON EQU	":"			;CHARACTER COLON
CHAR_SEMICOLON EQU ";"			;CHARACTER SEMICOLON
CHAR_LEFT_BRACKET EQU "["		;CHARACTER LEFT BRACKET
CHAR_AT_SIGN EQU "@"			;CHARACTER "AT" SIGN
CHAR_ZERO EQU	"0"			;CHARACTER ZERO

LOWER_A EQU	"a"			;LOWER CASE CHARACTER "a"
LOWER_Z EQU	"z"			;LOWER CASE CHARACTER "z"

UPPER_A EQU	"A"			;UPPER CASE CHARACTER "A"
UPPER_C EQU	"C"			;UPPER CASE CHARACTER "C"
UPPER_E EQU	"E"			;UPPER CASE CHARACTER "E"
UPPER_F EQU	"F"			;UPPER CASE CHARACTER "F"
UPPER_L EQU	"L"			;UPPER CASE CHARACTER "L"
UPPER_M EQU	"M"			;UPPER CASE CHARACTER "M"
UPPER_N EQU	"N"			;UPPER CASE CHARACTER "N"
UPPER_P EQU	"P"			;UPPER CASE CHARACTER "P"
UPPER_S EQU	"S"			;UPPER CASE CHARACTER "S"
UPPER_X EQU	"X"			;UPPER CASE CHARACTER "X"
UPPER_Z EQU	"Z"			;UPPER CASE CHARACTER "Z"
FOR_SLASH  EQU	'/'
Q_MARK	EQU	'?'

VEC_SING_STEP EQU 1			;ID OF THE SINGLE STEP VECTOR
VEC_BREAKPOINT EQU 3			;ID OF THE BREAKPOINT VECTOR
VEC_TERM_ADDR EQU 22H			;ID OF THE TERMINATE ADDRESS VECTOR
VEC_CTRL_BREAK EQU 23H			;ID OF THE CTRL BREAK EXIT ADDRESS VECTOR
VEC_CRIT_ERR EQU 24H			;ID OF THE CRITICAL ERROR HANDLER VECTOR
VEC_PRIMITIVE_DISK_READ EQU 25H 	;ID OF THE PRIMITAVE DISK READ VECTOR
VEC_PRIMITIVE_DISK_WRITE EQU 26H	;ID OF THE PRIMITAVE DISK WRITE VECTOR
GENERIC_IOCTL EQU 440DH 		;an000;Generic IOCtl function
READ_WRITE EQU	08H			;an000;read/write relative sectors
READ_SECTOR EQU 00H			;an000;currently unknown value
WRITE_SECTOR EQU 00H			;an000;currently unknown value

SET_DRIVEID_OPTION EQU 1		;AL VALUE FOR "PARSE FILENAME" FUNCTION
LSEEK_FROM_START EQU 0			;AL VALUE FOR "LSEEK" FUNCTION
LSEEK_EOF_OPTION EQU 2			;AL VALUE FOR "LSEEK" FUNCTION

;======================= EMS Equates Begin ===============================

EMS_GET_MAN_STAT equ 40h		;an000;function 40h, int 67h
EMS_UNALL_PG_CNT equ 42h		;an000;funciton 42h, int 67h
EMS_HAN_ALLOC equ 43h			;an000;function 43h, int 67h
EMS_MAP_MEMORY equ 44h			;an000;function 44h, int 67h
EMS_PAGE_DEALL equ 45h			;an000;function 45h, int 67h
EMS_VERSION equ 46h			;an000;function 46h, int 67h
EMS_SAVE_PAGE_MAP equ 47h		;an000;function 47h, int 67h
EMS_REST_PAGE_MAP equ 48h		;an000;function 48h, int 67h
EMS_HANDLE_CNT equ 4bh			;an000;function 4bh, int 67h
EMS_HANDLE_PAGES equ 4dh		;an000;function 4dh, int 67h
EMS_GET_SET_PG_MP equ 4eh		;an000;function 4eh, int 67h
EMS_TOT_HANDLES   equ 5402h ;  Function 54h, sub-func:02 Get total handles  ; C05
EMS_GET_PAGE_MAP equ 00h		;an000;sub function 00h of
EMS_PG_FRAME equ 5800h			;an000;function 58h, int 67h
					;      function 4eh, int 67h
EMS_SET_PAGE_MAP equ 01h		;an000;sub function 01h of
					;      function 4eh, int 67h
EMS_HANDLE_TOTAL equ 0ffh		;an000;total possible handles

EMS_LIM_40 equ	040h			;an000;LIM 4.0 I.D.

XM_ERR80 equ	80h			;an000;error message type
XM_ERR83 equ	83h			;an000;error message type
XM_ERR84 equ	84h			;an000;error message type
XM_ERR85 equ	85h			;an000;error message type
XM_ERR86 equ	86h			;an000;error message type
XM_ERR87 equ	87h			;an000;error message type
XM_ERR88 equ	88h			;an000;error message type
XM_ERR89 equ	89h			;an000;error message type
XM_ERR8A equ	8Ah			;an000;error message type
XM_ERR8B equ	8Bh			;an000;error message type
XM_ERR8D equ	8Dh			;an000;error message type
XM_ERR8E equ	8Eh			;an000;error message type
XM_ERR8F equ	8Fh			;an000;error message type
XM_NOT_INST equ 0ffh			;an000;EMS not inst

;======================= EMS Equates End =================================

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\debug.asm ===
PAGE	60,132			;
	TITLE	DEBUG.ASM - DEBUGger for MS-DOS
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: DEBUG.ASM
;
; DESCRIPTIVE NAME: DEBUGGING TOOL
;
; FUNCTION: PROVIDES USERS WITH A TOOL FOR DEBUGGING PROGRAMS.
;
; ENTRY POINT: START
;
; INPUT: DOS COMMAND LINE
;	 DEBUG COMMANDS
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: DEBCOM1 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM2 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBCOM3 - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBASM  - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBUASM - CONTAINS ROUTINES CALLED BY DEBUG
;		 DEBMES  - CONTAINS MESSAGE RETRIEVER ROUTINES
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK DEBUG+DEBCOM1+DEBCOM2+DEBCOM3+DEBASM+DEBUASM+DEBERR+
;	      DEBCONST+DEBDATA+DEBMES
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT DBCS HANDLING	DMS:6/17/87
;				- IMPLEMENT DBCS HANDLING	bgb:5/03/88	;an001;bgb
;				- IMPLEMENT MESSAGE RETRIEVER	DMS:6/17/87
;				- > 32 MB SUPPORT		DMS:6/17/87
;
; COPYRIGHT: "MS DOS DEBUG UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
;	MICROSOFT REVISION HISTORY:
;
; Modified 5/4/82 by AaronR to do all I/O direct to devices
; Runs on MS-DOS 1.28 and above
;
; REV 1.20
;	Tab expansion
;	New device interface (1.29 and above)
; REV 2.0
;	line by line assembler added by C. P.
; REV 2.1
;	Uses EXEC system call
; REV 2.2
;	Ztrace mode by zibo.
;	Fix dump display to indent properly
;	Parity nonsense by zibo
;
; REV 2.3 NP
;	Use Printf for all standard output.
;	Change to EXE file
; REV 2.4 ARR
;	Bug fixes. TEST, XCHG instructions reg order reversed.
;	Single step, break point interrupts saved and restored.
;	Access denied given on W to read only file.
;======================= END OF SPECIFICATIONS ===========================
;   Change Log:
;
;     Date    Who   #			Description
;   --------  ---  ---	------------------------------------------------------
;   04/01/90  DIC  C01	This information on the drive containing the file is
;			used within DEBCOM2.ASM for determining if enough
;			memory is available to write a file out to disk.
;			(Compaq STR #1889) (MS Bug #774)
;
;   09/xx/90   CAS	Fixed divide overflow problem when trying to
;			write ridiculously large files
;
;   10/18/90   CAS      Changed "POP CS" to DB 0F
;			Added code to override 8086/8088 Trace PIC mask
;			stuff on later CPUs to avoid crashing after
;			tracing through divide overflows.
;			Eliminated most Long Branch warnings
;
;=============================================================================

.XLIST
.XCREF
	include version.inc		; cas -- missing equates
	include syscall.inc		; cas -- missing equates
	INCLUDE DOSSYM.INC		; ALSO VERSION NUMBER
.CREF
.LIST
        INCLUDE debug.inc
	IF	SYSVER
; Structure for system call 72
SYSINITVAR  STRUC
DPBHEAD     DD	    ?			; Pointer to head of DPB-FAT list
SFT_ADDR    DD	    ?			; Pointer to first FCB table
; The following address points to the CLOCK device
BCLOCK	    DD	    ?
; The following address is used by DISKSTATCHK it is always
; points to the console input device header
BCON	    DD	    ?			; Console device entry points
MAXSEC	    DW	    0			; Maximum allowed sector size
BUFFHEAD    DD	    ?
CDS	    DD	    ?
SFTFCB	    DD	    ?
KEEP	    DW	    ?
NUMIO	    DB	    0			; Number of disk tables
NCDS	    DB	    ?
DEVHEAD     DD	    ?
SYSINITVAR  ENDS

	ENDIF


;======================= macro equates ===================================

dbcs_delim equ	81h			;an000;delimits dbcs char
asian_blk equ	40h			;an000;asian blank
amer_blk equ	20h			;an000;american blank
quote_char equ	22h			;an000;quote delim "

;======================= end macro equates ===============================


;This segment must be the first loaded since we are using it to make
;a CREATE_PROCESS_DATA_BLOCK system call a la 1.0 and .COM files.
;For this system call CS must point to the Program Prefix Header, so
;by setting up a seperate segment just after the header we can issue
;an INT 21H via a long call.  So don't move this guy around!

A_CREATE_BLOCK SEGMENT

	PUBLIC	CREATE_CALL

;The other arguements to this system call have been set up
;by the caller.

CREATE_CALL PROC FAR
	MOV	AH,CREATE_PROCESS_DATA_BLOCK
	INT	21H
	RET

CREATE_CALL ENDP

A_CREATE_BLOCK ENDS


CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC
CONST	ENDS

CSTACK	SEGMENT STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC
DATA	ENDS

DG	GROUP	CODE,CONST,CSTACK,DATA

CONST	SEGMENT PUBLIC BYTE
	EXTRN	BADVER:BYTE,ENDMES_PTR:BYTE,CRLF_PTR:BYTE
	IF	IBMJAPAN
	    EXTRN   PARITYMES_PTR:BYTE
	ENDIF
	EXTRN	PROMPT_PTR:BYTE,ADD_PTR:BYTE,HEX_PTR:BYTE
	EXTRN	USER_PROC_PDB:WORD,CSSAVE:WORD,DSSAVE:WORD
	EXTRN	SPSAVE:WORD,IPSAVE:WORD,LINEBUF:BYTE,QFLAG:BYTE
	EXTRN	NEWEXEC:BYTE,HEADSAVE:WORD,LBUFSIZ:BYTE,BACMES_PTR:WORD
	EXTRN	QMES_1:BYTE
	EXTRN	QMES_2:BYTE
	EXTRN	QMES_3:BYTE
	EXTRN	QMES_4:BYTE
	EXTRN	QMES_5:BYTE
	EXTRN	HELP_TEXT1:BYTE
	EXTRN	HELP_TEXT2:BYTE
	EXTRN	HELP_TEXT3:BYTE
	EXTRN	HELP_TEXT4:BYTE
	EXTRN	HELP_TEXT5:BYTE
	EXTRN	HELP_TEXT6:BYTE

	IF	IBMVER
	    EXTRN   DSIZ:BYTE,NOREGL:BYTE,DISPB:WORD
	ENDIF

	IF	SYSVER
	    EXTRN   CONFCB:BYTE,POUT:DWORD,COUT:DWORD,CIN:DWORD,IOBUFF:BYTE
	    EXTRN   IOADDR:DWORD,IOCALL:BYTE,IOCOM:BYTE,IOSTAT:WORD,IOCNT:WORD
	    EXTRN   IOSEG:WORD,COLPOS:BYTE,BADDEV_PTR:BYTE,BADLSTMES_PTR:BYTE
	    EXTRN   LBUFFCNT:BYTE,PFLAG:BYTE
	ENDIF

	EXTRN	NAMESPEC:BYTE
	EXTRN	DriveOfFile:WORD       ; save default drive of file   ;C01

CONST	ENDS

CSTACK	SEGMENT STACK
	DB	(362 - 80H) + 80H DUP(?) ; (362 - 80H) == IBM'S ROM REQUIREMENTS
					; (NEW - OLD) == SIZE TO GROW STACK
CSTACK	ENDS

DATA	SEGMENT PUBLIC BYTE
	EXTRN	ARG_BUF:BYTE,ADD_ARG:WORD,SUB_ARG:WORD,HEX_ARG1:WORD
	EXTRN	HEX_ARG2:WORD,STACK:BYTE, PREV24:DWORD, FIN24:BYTE
	EXTRN	PARSERR:BYTE,DATAEND:WORD,PARITYFLAG:BYTE,DISADD:BYTE
	EXTRN	ASMADD:BYTE,DEFDUMP:BYTE,BYTEBUF:BYTE,BEGSEG:WORD
	EXTRN	BPINTSAV:DWORD,SSINTSAV:DWORD ;ARR 2.4
	EXTRN	CREATE_LONG:DWORD

	extrn	lbtbl:dword		;an000;lead byte table pointer

DATA	ENDS

	EXTRN	PRINTF:NEAR		;ac000;changed to NEAR call

CODE	SEGMENT PUBLIC
	ASSUME	CS:DG,DS:NOTHING,ES:NOTHING,SS:CSTACK

	PUBLIC	RESTART
	PUBLIC	STD_PRINTF,PRINTF_CRLF
	PUBLIC	HEX_ADDRESS_ONLY,HEX_ADDRESS_STR
	PUBLIC	RESTART,SET_TERMINATE_VECTOR,DABORT,TERMINATE,COMMAND
	PUBLIC	FIND_DEBUG,CRLF,BLANK,TAB,INBUF,SCANB,SCANP
	PUBLIC	HEX,OUTSI,OUTDI,DIGIT,BACKUP,RBUFIN
	public	test_lead							;an001;bgb
	public	test1								;an001;bgb

	IF	SYSVER
;	    PUBLIC  SETUDEV,DEVIOCALL				; kwc 12/10/86
	    PUBLIC  SETUDEV		; kwc 12/10/86
	    EXTRN   DISPREG:NEAR,INPT:NEAR
	ENDIF

	EXTRN	PERR:NEAR,COMPARE:NEAR,DUMP:NEAR,ENTERDATA:NEAR,FILL:NEAR
	EXTRN	GO:NEAR,INPUT:NEAR,LOAD:NEAR,MOVE:NEAR,NAMED:NEAR
	EXTRN	REG:NEAR,SEARCH:NEAR,DWRITE:NEAR,UNASSEM:NEAR,ASSEM:NEAR
	EXTRN	OUTPUT:NEAR,ZTRACE:NEAR,TRACE:NEAR,GETHEX:NEAR,GETEOL:NEAR
	EXTRN	PREPNAME:NEAR,DEFIO:NEAR,SKIP_FILE:NEAR,DEBUG_FOUND:NEAR
	EXTRN	TRAPPARITY:NEAR,RELEASEPARITY:NEAR
	extrn	pre_load_message:near	;an000;load messages
	extrn	debems:near		;an000;ems support
ifdef JAPAN
	extrn	SETDUMPMODE:near
endif


	DB	100H DUP (?)

START:
	JMP	SHORT DSTRT

HEADER	DB	"Vers 2.40"

DSTRT:
;=========================================================================
; invoke PRE_LOAD_MESSAGE here.  If the messages were not loaded we will
; exit with an appropriate error message.
;
;	Date	   : 6/14/87
;=========================================================================

	push	ds			;an000;save regs
	push	es			;an000;save resg

	push	cs			;an000;transfer cs
	pop	ds			;an000;    to ds

	push	cs			;an000;transfer cs
	pop	es			;an000;    to es
	assume	ds:dg,es:dg		;an000;assume them
	call	PRE_LOAD_MESSAGE	;an000;invoke SYSLOADMSG
;	$if	c			;an000;if the load was unsuccessful
	JNC $$IF1
	    mov     ax,(exit shl 8)	;an000;exit EDLIN.  PRE_LOAD_MESSAGE
					;      has already said why
	    int     21h 		;an000;exit
;	$endif				;an000;
$$IF1:

	pop	es			;an000;restore regs.
	pop	ds			;an000;
	assume	ds:nothing,es:nothing	;an000;back to original

	MOV	AX,(GET_INTERRUPT_VECTOR SHL 8) OR VEC_BREAKPOINT ;get original contents
	INT	21H			;  of the BREAKPOINT vector

	MOV	WORD PTR [BPINTSAV],BX	;  and save that vector for later
	MOV	WORD PTR [BPINTSAV+WORD],ES ; restoration

	MOV	AX,(GET_INTERRUPT_VECTOR SHL 8) OR VEC_SING_STEP ;get original contents
	INT	21H			;  of the SINGLE STEP vector

	MOV	WORD PTR [SSINTSAV],BX	;  and save that vector for later
	MOV	WORD PTR [SSINTSAV+WORD],ES ; restoration

	MOV	BEGSEG,DS		; save beginning DS
	PUSH	CS			; repair damaged ES to be
	POP	ES			;  back to just like CS
	XOR	SI,SI			; set source and destination
	XOR	DI,DI			;  indices both to zero
	MOV	CX,256			; set count to size of PSP
	REP	MOVSB			; move to es:[di] from ds:[si]
	PUSH	CS			; set up DS to be just like CS
	POP	DS			;  to match .COM rules of addressability
	ASSUME	DS:DG,ES:DG		; like CS, also have DS and DS as bases

	if	IBMVER

;	on IBM compatibles, we need to know whether we have a pre-286, so
;	  we can invoke special PIC mask code during tracing.

	extrn	cpu_not_8088:byte
	pushf				; save flags
	pushf				; copy to ax
	pop	ax
	and	ax,0fffh		; try to reset first 4 to zero
	push	ax
	popf
	pushf				; write it to flags and get it back
	pop	ax			; and back into ax
	cmp	ah,0f0h			; if all 4 are ones, then 8088/8086
;					;  otherwise, set carry (later cpu)
	sbb	al,al			; propagate carry across al
	mov	cpu_not_8088,al		; and save it for future reference
	popf				; restore flags
	endif

	CALL	TRAPPARITY		; scarf up those parity guys
	MOV	AH,GET_CURRENT_PDB	;(undocumented function call - 51h)
	INT	21H

	MOV	[USER_PROC_PDB],BX	; Initially set to DEBUG

	IF	SYSVER
	    MOV     [IOSEG],CS
	ENDIF

	MOV	[PARSERR],0


	IF	SYSVER
	    MOV     AH,GET_IN_VARS	;(undocumented function call - 52h)
	    INT     21H

	    LDS     SI,ES:[BX.BCON]	; get system console device
	    ASSUME  DS:NOTHING

	    MOV     WORD PTR CS:[CIN+WORD],DS ;save vector to console input device
	    MOV     WORD PTR CS:[CIN],SI
	    MOV     WORD PTR CS:[COUT+WORD],DS ;save vector to console output device
	    MOV     WORD PTR CS:[COUT],SI
	    PUSH    CS			; restore DS to be
	    POP     DS			;  just like CS, as before
	    ASSUME  DS:DG

	    MOV     DX,OFFSET DG:CONFCB ; get system printer device
	    MOV     AH,FCB_OPEN 	; open system printer "PRN"
	    INT     21H

	    OR	    AL,AL		; open ok?
	    JZ	    GOTLIST		; yes, it was there

	    MOV     DX,OFFSET DG:BADLSTMES_ptr ; no list file found...
	    CALL    STD_PRINTF		; tell user

	    CALL    RBUFIN		; ask for a new one

	    CALL    CRLF

	    MOV     CL,[LBUFFCNT]
	    OR	    CL,CL
	    JZ	    NOLIST1		; User didn't specify one

	    XOR     CH,CH
	    MOV     DI,OFFSET DG:(CONFCB + BYTE)
	    MOV     SI,OFFSET DG:LINEBUF ; get one from input line
	    REP     MOVSB
	    MOV     DX,OFFSET DG:CONFCB
	    MOV     AH,FCB_OPEN 	; try to open it
	    INT     21H

	    OR	    AL,AL
	    JZ	    GOTLIST		; yep, use it...

	    MOV     DX,OFFSET DG:BADDEV_Ptr ; complain again
	    CALL    STD_PRINTF
NOLIST1:				; kwc 12/10/86
	    MOV     WORD PTR [POUT+WORD],CS ; use null device for printer
	    MOV     WORD PTR [POUT],OFFSET DG:LONGRET
	    JMP     NOLIST

XXX	    PROC    FAR
LONGRET:
	    RET
XXX	    ENDP
	ENDIF

GOTLIST:
;DX = OFFSET OF 'CONFCB', WHICH HAS JUST BEEN OPENED OK
	IF	SYSVER
	    MOV     SI,DX
;	    LDS     SI,DWORD PTR DS:[SI.FCB_FIRCLUS]		; KWC 12/10/86
	    LDS     SI,DWORD PTR DS:[SI.FCB_NSLD_DRVPTR] ; KWC 12/10/86
	    ASSUME  DS:NOTHING

	    MOV     WORD PTR CS:[POUT+WORD],DS
	    MOV     WORD PTR CS:[POUT],SI
	ENDIF
NOLIST:
	MOV	AX,CS			;restore the DS and ES segregs
	MOV	DS,AX			; to become once again just like CS
	MOV	ES,AX
	ASSUME	DS:DG,ES:DG

; Code to print header
;	MOV	DX,OFFSET DG:HEADER_PTR
;	CALL	STD_PRINTF

	CALL	SET_TERMINATE_VECTOR

; Save the current INT 24 vector.  We will need this to link to the previous
; handler for handling of int 24 output.
	PUSH	ES			; save it, about to clobber it...
	MOV	AX,(GET_INTERRUPT_VECTOR SHL 8) + VEC_CRIT_ERR ; get original contents
	INT	21H			; of the int 24h vector

	MOV	WORD PTR PREV24,BX	; remember what int 24h used to
	MOV	WORD PTR PREV24+WORD,ES ;  point to
	POP	ES			; restore ES to be like CS and DS

	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) + VEC_CRIT_ERR ; change int 24h to
	MOV	DX,OFFSET DG:MY24	; point to my own int 24h handler
	INT	21H

	IF	SETCNTC
	    MOV     AL,VEC_CTRL_BREAK	; Set vector 23H
	    MOV     DX,OFFSET DG:DABORT
	    INT     21H
	ENDIF

	MOV	DX,CS			;get para of where this pgm starts
	MOV	AX,OFFSET DG:DATAEND+15 ;get offset of end of this program
	MOV	CL,4			; (plus 15 padding for rounding)
	SHR	AX,CL			; adjusted to number of paragraphs
	ADD	DX,AX			;get para of where this pgm ends
	MOV	AX,CS
	SUB	AX,BEGSEG		; add in size of printf
	ADD	DX,AX			; create program segment here
	CALL	[CREATE_LONG]		; and call special routine

	MOV	AX,DX
; Initialize the segments
	MOV	DI,OFFSET DG:DSSAVE
	CLD
	STOSW
	STOSW
	STOSW
	STOSW
	MOV	WORD PTR [DISADD+WORD],AX
	MOV	WORD PTR [ASMADD+WORD],AX
	MOV	WORD PTR [DEFDUMP+WORD],AX

	MOV	AX,100H
	MOV	WORD PTR[DISADD],AX
	MOV	WORD PTR[ASMADD],AX
	MOV	WORD PTR [DEFDUMP],AX

	MOV	DS,DX
	MOV	ES,DX
	ASSUME	DS:NOTHING,ES:NOTHING

	MOV	DX,80H
	MOV	AH,SET_DMA
	INT	21H			; Set default DMA address to 80H
; Set up initial stack.  We already have a 'good' stack set up already.  DS:6
; has the number of bytes remaining in the segment.  We should take this
; value, add 100h and use it as the Stack pointer.
	MOV	AX,WORD PTR DS:[6]	; get bytes remaining
	MOV	BX,AX
	ADD	AX,100h

;	MOV	BX,AX
;	CMP	AX,0FFF0H
;	PUSH	CS
;	POP	DS
;	JAE	SAVSTK
;	MOV	AX,WORD PTR DS:[6]
;	PUSH	BX
;	MOV	BX,OFFSET DG:DATAEND + 15
;	AND	BX,0FFF0H		; Size of DEBUG in bytes (rounded up to PARA)
;	SUB	AX,BX
;	POP	BX
;SAVSTK:
	PUSH	CS
	POP	DS
	ASSUME	DS:DG
	PUSH	BX			; bx is no. bytes remaining from PSP+6
	DEC	AX			; ax was no. bytes remaining +100h
	DEC	AX			; back up one word from end of new stack
	MOV	BX,AX			; set base to point to last word in new stack
	MOV	WORD PTR ES:[BX],0	; set final word in new stack to zero
	POP	BX			; back to beginning of new stack area
	MOV	SPSAVE,AX		; remember where new stack is
	DEC	AH
	MOV	ES:WORD PTR [6],AX	; change PSP to show usage of
	SUB	BX,AX			; new stack area
	MOV	CL,4
	SHR	BX,CL
	ADD	ES:WORD PTR [8],BX

	IF	IBMVER
; Get screen size and initialize display related variables
	    MOV     AH,15		;function = "request current video state"
	    INT     10H 		;set al=screen mode
					;    ah=no. char cols on screen
					;    bh=current active display page
	    CMP     AH,40		;is screen in 40 col mode?
	    JNZ     PARSCHK		; no, skip
					; yes, 40 col, continue
					;next fields defined in 'debconst.asm'
	    MOV     BYTE PTR DSIZ,7	; originally assembled as 0fh
	    MOV     BYTE PTR NOREGL,4	; originally assembled as 8
	    MOV     DISPB,64		; originally assembled as 128
	ENDIF

PARSCHK:


	call	DEBUG_LEAD_BYTE 	;an000;build the dbcs env. table
					;      of valid dbcs lead bytes

;=========================================================================
; prep_command_line requires the use of ds:si.	ds is left intact for
; the call.  si is initialized to point to the command line input buffer.
; ds and si are saved since we stomp all over them in prep_command_line.
;=========================================================================

	push	si			;an000;save si

	mov	si,81h			;an000;point to command line
	call	prep_command_line	;an000;invoke command line conversion

	pop	si			;an000;restore si

;=========================================================================
; we have prepped the command line for dbcs.  we can now enter the old
; routines.
;=========================================================================

; Copy rest of command line to test program's parameter area
	MOV	DI,FCB			;es[di]=to be filled with unopened FCB
	MOV	SI,80H			;ds[si]=command line to parse

; see if /? is the first argument in the command tail
NCHAR:	INC	SI
	CMP	BYTE PTR [SI], CHAR_BLANK
	JE	NCHAR
	CMP	BYTE PTR [SI], FOR_SLASH    ; are we looking at an '/' 
	JNE	NOQST                       ; if not, get out
	CMP	BYTE PTR [SI+1], Q_MARK     ;   else is the next char a '?' 
	JNE	NOQST                   

;print out /? help text
	MOV	DX, OFFSET DG:QMES_1
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_2
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_3
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_4
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:QMES_5
	CALL	STD_PRINTF
	JMP	QUITING

NOQST:  MOV	SI, 81H                 ; restore SI to what it should be
	MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION
					;func=29H, option al=1, which
					; says, drive id byte in fcb is set
					; only if drive specified in command
					; line being parsed.
	INT	21H			;parse filename from command to fcb
					; ds:si=points to first char AFTER parsed filename
					; es:di=points to first byte of formatted FCB

	mov	di,FCB			; get addr of FCB1	     ;C01
	mov	bx,[di] 		; get default drive of file  ;C01
	xor	bh,bh			; zero out high byte	     ;C01
	mov	DriveOfFile,bx		; save drive letter	     ;C01

	CALL	SKIP_FILE		; Make sure si points to delimiter
test1:					;for testing only - u can remove this
	CALL	PREPNAME

	PUSH	CS			;restore ES to point to the
	POP	ES			;  common group
FILECHK:
	MOV	DI,80H			;point to byte in PSP defining parm length
	CMP	BYTE PTR ES:[DI],0	; ANY STUFF FOUND?
	JZ	COMMAND 		; no parms, skip
					; yes parms, continue
FILOOP:
	INC	DI			;set index to first/next char in parm text
	CMP	BYTE PTR ES:[DI],CR	; carriage return? (at end of parms)
	JZ	COMMAND 		; yes, at end of parms
					; no, not at end of parms yet, continue
	CMP	BYTE PTR ES:[DI],CHAR_BLANK ; is this parm text char a blank?
	JZ	FILOOP			; yes, a blank, skip
					; no, not a blank, continue
	CMP	BYTE PTR ES:[DI],CHAR_TAB ; is this parm text char a tab?
	JZ	FILOOP			; yes, a tab, skip
					; no, not a tab, continue
	OR	[NAMESPEC],1		; set flag to indicate
					;  we have a specified file
					; (this could be set by "N" command also)
	CALL	DEFIO			; READ in the specified file

	PUSH	CS			;restore DS to point to the
	POP	DS			; common group

					;perform self-relocation on some internal vectors:
	MOV	AX,CSSAVE		; pick up the seg id to go to vectors
	MOV	WORD PTR DISADD+WORD,AX ;  shove it into the segid portion
	MOV	WORD PTR ASMADD+WORD,AX ;  of these two vectors
	MOV	AX,IPSAVE		; pick up the offset to go to vectors
	MOV	WORD PTR DISADD,AX	;  shove it into the offset portion
	MOV	WORD PTR ASMADD,AX	;  of these two vectors
COMMAND:
	CLD
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	cli				;disable before setting up the stack - EMK
	MOV	SS,AX			;now everything points to the same group
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	STI				;re-enable
	CMP	[PARITYFLAG],0		; did we detect a parity error?
	JZ	GOPROMPT		; no, go prompt
					; yes, parity error, continue
	MOV	[PARITYFLAG],0		; reset flag
	IF	IBMJAPAN
	    MOV     DX,OFFSET DG:PARITYMES_PTR
	    CALL    STD_PRINTF		;display msg about parity error
	ENDIF
GOPROMPT:
	MOV	DX,OFFSET DG:PROMPT_PTR ;display the user prompt request
	CALL	STD_PRINTF

	CALL	INBUF			; Get command line
; From now and throughout command line processing, DI points
; to next character in command line to be processed.
	CALL	SCANB			; Scan off leading blanks

	JZ	COMMAND 		; if zero, Null command, go get another
					; nonzero, got something in response
	LODSB				; AL=first non-blank character
; Prepare command letter for table lookup
; converts the first non-blank (assumed to be the command letter)
; to in index in the "comtab" array.
	SUB	AL,'?'			; Low end range check
	JB	ERR1

	CMP	AL,'Z'-'?'		; Upper end range check
	JA	ERR1

	SHL	AL,1			; Times two
	CBW				; Now a 16-bit quantity
	XCHG	BX,AX			; In BX we can address with it
	CALL	CS:[BX+COMTAB]		; Execute command

	JMP	SHORT COMMAND		; Get next command
ERR1:
	JMP	PERR

SET_TERMINATE_VECTOR:
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR VEC_TERM_ADDR ; Set vector 22H
	MOV	DX,OFFSET DG:TERMINATE
	INT	21H

	POP	DS
	RET

RESTORE_DEB_VECT:
	PUSH	DS
	PUSH	DX
	PUSH	AX
	LDS	DX,CS:[BPINTSAV]
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR VEC_BREAKPOINT ;Vector 3
	INT	21H

	LDS	DX,CS:[SSINTSAV]
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR VEC_SING_STEP ;Vector 1
	INT	21H

	POP	AX
	POP	DX
	POP	DS
	RET

; Internal INT 24 handler.  We allow our parent's handler to decide what to do
; and how to prompt.  When our parent returns, we note the return in AL.  If
; he said ABORT, we need to see if we are aborting ourselves.  If so, we
; cannot turn it into fail; we may get a cascade of errors due to the original
; cause.  Instead, we do the ol' disk-reset hack to clean up.  This involves
; issuing a disk-reset, ignoring all errors, and then returning to the caller.
MY24:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

; If we are already inside an INT 24, just ignore this error
	TEST	FIN24,-1
	JZ	DO24

	MOV	AL,0			; signal ignore
	IRET

; Let the user decide what to do
DO24:
	PUSHF
	CALL	PREV24			; simulate INT 24 to him

	CMP	AL,2			; was it ABORT?
	JNZ	DOIRET			; no, let it happen

	PUSH	AX
	PUSH	BX
	MOV	AH,GET_CURRENT_PDB	; find out who's terminating
	INT	21H

	CMP	BX,BEGSEG		; is it us?
	POP	BX
	POP	AX
	JZ	DORESET 		; no, let it happen

DOIRET:
	IRET

; We have been instructed to abort ourselves.  Since we can't do this, we will
; perform a disk reset to flush out all buffers and then ignore the errors we
; get.
DORESET:
	MOV	FIN24,-1		; signal that we ignore errors
	MOV	AH,DISK_RESET
	INT	21H			; clean out cache

	MOV	FIN24,0 		; reset flag
	JMP	COMMAND

TERMINATE:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	CMP	QFLAG,0
	JNZ	QUITING

	MOV	AX,BEGSEG
	MOV	USER_PROC_PDB,AX
	CMP	NEWEXEC,0
	JZ	NORMTERM

	MOV	AX,CS
	MOV	DS,AX
	ASSUME	DS:DG
					;is CLI/STI needed here ? - emk
	CLI
	MOV	SS,AX
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	STI
	MOV	AX,HEADSAVE
	JMP	DEBUG_FOUND

NORMTERM:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	PUSH	CS
	POP	DS
	ASSUME	DS:DG

	MOV	DX,OFFSET DG:ENDMES_PTR
	JMP	SHORT RESTART

QUITING:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	CALL	RESTORE_DEB_VECT

	MOV	AX,(EXIT SHL 8)
	INT	21H

RESTART:
	CALL	STD_PRINTF
DABORT:
	MOV	AX,CS
	MOV	DS,AX
	ASSUME	DS:DG

					;is CLI\STI needed here? - emk
	CLI
	MOV	SS,AX
	ASSUME	SS:DG

	MOV	SP,OFFSET DG:STACK
	STI
;;;;;;	CALL	CRLF

	JMP	COMMAND

	IF	SYSVER
SETUDEV:
	    MOV     DI,OFFSET DG:CONFCB
	    MOV     AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR SET_DRIVEID_OPTION
	    INT     21H

	    CALL    USERDEV

	    JMP     DISPREG

USERDEV:
	    MOV     DX,OFFSET DG:CONFCB
	    MOV     AH,FCB_OPEN
	    INT     21H

	    OR	    AL,AL
	    JNZ     OPENERR

	    MOV     SI,DX
;	    TEST    BYTE PTR [SI.FCB_DEVID],080H ; Device?	; KWC 12/10/86
;	    JZ	    OPENERR		; NO			; KWC 12/10/86
	    MOV     AL,BYTE PTR [SI.FCB_NSL_DRIVE] ; KWC 12/10/86
	    AND     AL,NOT FCBMASK	; KWC 12/10/86
	    CMP     AL,0C0H		; KWC 12/10/86
	    JNE     OPENERR		; KWC 12/10/86
	    XOR     AL,AL		; KWC 12/10/86

;	    LDS     SI,DWORD PTR [CONFCB.FCB_FIRCLUS]		; KWC 12/10/86
	    LDS     SI,DWORD PTR [CONFCB.FCB_NSLD_DRVPTR] ; KWC 12/10/86
	    MOV     WORD PTR CS:[CIN],SI
	    MOV     WORD PTR CS:[CIN+WORD],DS

	    MOV     WORD PTR CS:[COUT],SI
	    MOV     WORD PTR CS:[COUT+WORD],DS
	    PUSH    CS
	    POP     DS
	    RET

OPENERR:
	    MOV     DX,OFFSET DG:BADDEV_PTR
	    CALL    STD_PRINTF

	    RET
	ENDIF
; Get input line. Convert all characters NOT in quotes to upper case.
INBUF:
	CALL	RBUFIN

;=========================================================================
; prep_command_line requires the use of ds:si.	ds is left intact for
; the call.  si is initialized to point to the command line input buffer.
; ds and si are saved since we stomp all over them in prep_command_line.
;=========================================================================

	push	si			;an000;save si

	mov	si,offset dg:linebuf	;an000;point to command line
	call	prep_command_line	;an000;invoke command line conversion

	pop	si			;an000;restore si

;=========================================================================
; we have prepped the command line for dbcs.  we can now enter the old
; routines.
;=========================================================================

	MOV	SI,OFFSET DG:LINEBUF
	MOV	DI,OFFSET DG:BYTEBUF

CASECHK:

	LODSB

	call	Test_Lead			;DBCS lead byte 		;an000; dms;
;	$if	c				;yes - ignore 2nd. byte 	;an000; dms;
	JNC $$IF3
		stosb				;save the byte			;an000; dms;
		lodsb				;pick up the 2nd. character	;an000; dms;
		stosb				;save it also			;an000; dms;
		jmp	CaseChk 		;read next character		;an000; dms;
;	$endif					;				;an000; dms;
$$IF3:

	CMP	AL,LOWER_A
	JB	NOCONV

	CMP	AL,LOWER_Z
	JA	NOCONV

	ADD	AL,UPPER_A - LOWER_A	; Convert to upper case
NOCONV:
	STOSB
	CMP	AL,CR
	JZ	INDONE

	CMP	AL,DOUBLE_QUOTE
	JZ	QUOTSCAN

	CMP	AL,SINGLE_QUOTE
	JNZ	CASECHK

QUOTSCAN:
	MOV	AH,AL
KILLSTR:
	LODSB
	STOSB
	CMP	AL,CR			;CARRIAGE RETURN?
	JZ	INDONE

	CMP	AL,AH
	JNZ	KILLSTR

	JMP	SHORT CASECHK

INDONE:
	MOV	SI,OFFSET DG:BYTEBUF
	CALL	CRLF

	RET

; Physical backspace - blank, backspace, blank
BACKUP:
	PUSH	DX
	MOV	DX,OFFSET DG:BACMES_PTR
	CALL	STD_PRINTF

	POP	DX
	RET

; Scan for parameters of a command
SCANP:
	CALL	SCANB			; Get first non-blank

	CMP	BYTE PTR [SI],CHAR_COMMA ; One comma between params OK
	JNE	EOLCHK			; If not comma, we found param

	INC	SI			; Skip over comma
; Scan command line for next non-blank character
SCANB:
	PUSH	AX
SCANNEXT:
	LODSB
	CMP	AL,CHAR_BLANK		;is this char a "blank"?
	JZ	SCANNEXT

	CMP	AL,CHAR_TAB		;is this char a "tab"?
	JZ	SCANNEXT

	DEC	SI			; Back to first non-blank
	POP	AX
EOLCHK:
	CMP	BYTE PTR [SI],CR	;CARRIAGE RETURN
	RET

; Hex addition and subtraction
HEXADD:
	MOV	CX,4
	CALL	GETHEX

	MOV	DI,DX
	MOV	CX,4
	CALL	GETHEX

	CALL	GETEOL

	PUSH	DX
	ADD	DX,DI
	MOV	[ADD_ARG],DX
	POP	DX
	SUB	DI,DX
	MOV	[SUB_ARG],DI
	MOV	DX,OFFSET DG:ADD_PTR
	CALL	PRINTF_CRLF

	RET

; Put the hex address in DS:SI in the argument list for a call to printf
OUTSI:
	MOV	CS:[HEX_ARG1],DS
	MOV	CS:[HEX_ARG2],SI
	RET

;Put the hex address in ES:DI in the argument list for a call to printf
OUTDI:
	MOV	[HEX_ARG1],ES
	MOV	[HEX_ARG2],DI
	RET

HEX_ADDRESS_ONLY:
	MOV	BYTE PTR [ARG_BUF],0
HEX_ADDRESS_STR:
	MOV	DX,OFFSET DG:HEX_PTR
STD_PRINTF:
	PUSH	DX
	CALL	PRINTF
	POP	DX			;ac000;restore dx

	RET

PRINTF_CRLF:
	PUSH	DX
	CALL	PRINTF
	POP	DX			;ac000;restore dx
CRLF:
	MOV	DX,OFFSET DG:CRLF_PTR
	PUSH	DX
	CALL	PRINTF
	POP	DX			;ac000;restore dx

	RET

HEX:
	MOV	AH,AL			; Save for second digit
	PUSH	CX
	MOV	CL,4
	SHR	AL,CL
	POP	CX

	CALL	DIGIT			; First digit

	MOV	AL,AH			; Now do digit saved in AH
DIGIT:
	AND	AL,0FH			; Mask to 4 bits
	ADD	AL,90H
	DAA
	ADC	AL,40H
	DAA
	AND	AL,7FH
	STOSB
	RET

RBUFIN:
	PUSH	AX
	PUSH	DX
	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET DG:LBUFSIZ
	INT	21H

	POP	DX
	POP	AX
	RET

; Put one space in the printf output uffer
BLANK:
	MOV	AL,CHAR_BLANK
	STOSB
	RET

; Put CX spaces in the printf output buffer
TAB:
	JCXZ	TAB_RET

	CALL	BLANK

	LOOP	TAB
TAB_RET:
	RET

; Command Table. Command letter indexes into table to get
; address of command. PERR prints error for no such command.

COMTAB	DW	QUESTION_HELP		; ?
	DW	PERR			; @
	DW	ASSEM			; A
	DW	PERR			; B
	DW	COMPARE 		; C
	DW	DUMP			; D
	DW	ENTERDATA		; E
	DW	FILL			; F
	DW	GO			; G
	DW	HEXADD			; H
	DW	INPUT			; I
	DW	PERR			; J
ifdef JAPAN
	DW	SETDUMPMODE		; K
else
	DW	PERR			; K
endif
	DW	LOAD			; L
	DW	MOVE			; M
	DW	NAMED			; N
	DW	OUTPUT			; O
	DW	ZTRACE			; P
	DW	QUIT			; Q (QUIT)
	DW	REG			; R
	DW	SEARCH			; S
	DW	TRACE			; T
	DW	UNASSEM 		; U
	DW	PERR			; V
	DW	DWRITE			; W
	IF	SYSVER
	    DW	    SETUDEV		; X
	ELSE
	    DW	    DEBEMS
	ENDIF
	DW	PERR			; Y
	DW	PERR			; Z

QUESTION_HELP:
	MOV	DX, OFFSET DG:HELP_TEXT1
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT2
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT3
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT4
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT5
	CALL	STD_PRINTF
	MOV	DX, OFFSET DG:HELP_TEXT6
	JMP	STD_PRINTF


QUIT:
	INC	BYTE PTR [QFLAG]
	MOV	BX,[USER_PROC_PDB]
FIND_DEBUG:
	IF	NOT SYSVER
	    MOV     AH,SET_CURRENT_PDB
	    INT     21H
	ENDIF
	CALL	RELEASEPARITY		; let system do normal parity stuff

	CALL	RESTORE_DEB_VECT

	MOV	AX,(EXIT SHL 8)
	INT	21H

;======================= proc  prep_command_line =========================
; prep_command_line: This proc converts a Asian DBCS space delimiter (DB_SPACE)
;		     into 2 20h values.  In this way we can pass command
;		     lines throughout DEBUG without major modification
;		     to the source code.  This proc is invoked anywhere
;		     a command line is initially accessed.  In the case
;		     of DEBUG it is used in PARSCHK and INBUF.
;		     Any quoted string, a string delimited by ("), will
;		     be ignored.
;
;	input: ds - segment of command line
;	       si - offset of command line
;
;	output: command line with Asian blanks (DB_SPACE) converted to
;		2020h.
;
;=========================================================================

prep_command_line proc near		;command line conversion
    push    ax				;save affected regs.
    push    bx				;
    push    si				;

    mov     bl,00h			;initialize flag
					;bl is used to signal
					;  a quote delimiter
;   $DO 				;do while not CR
$$DO5:
	mov	al,[si] 		;move char from cmd line for compare
	cmp	al,CR			;is it a CR ?
;   $LEAVE  E				;if CR exit
    JE $$EN5

	cmp	al,quote_char		;is it a quote ?
;	$IF	Z			;if it is a quote
	JNZ $$IF7
	    xor     bl,01h		;set or reset the flag
;	$ENDIF
$$IF7:

	cmp	bl,01h			;is 1st quote set ?
;	$IF	NZ			;if not continue
	JZ $$IF9
	    call    TEST_LEAD		;test for dbcs lead byte
;	    $IF     C			;we have a lead byte
	    JNC $$IF10
		cmp	al,DB_SP_HI	;is it a dbcs char?
;		$IF	Z		;if a dbcs char
		JNZ $$IF11
		    mov     al,[si+1]	    ;move next char al
		    cmp     al,DB_SP_LO     ;is it an Asian blank?
;		    $IF     Z		    ;if an Asian blank
		    JNZ $$IF12
			mov	al,amer_blk ;set up moves
			mov	[si],al     ;  to replace
			mov	[si+1],al   ;  Asian blank w/20h
			inc	si	    ;point to si+1
;		    $ELSE		;if not an asian blank
		    JMP SHORT $$EN12
$$IF12:
			inc	si	;point to dbcs char
;		    $ENDIF		;
$$EN12:
;		$ENDIF			;
$$IF11:
;	    $ENDIF			;end lead byte test
$$IF10:
;	$ENDIF				;
$$IF9:
	inc	si			;point to si+1
;   $ENDDO				;end do while
    JMP SHORT $$DO5
$$EN5:
    pop     si				;restore affected regs.
    pop     bx				;
    pop     ax				;
    ret 				;return to caller
prep_command_line endp			;end proc


;=========================================================================
; DEBUG_LEAD_BYTE - This routine sets the lead-byte-pointers to point
;		    to the dbcs environmental vector table of lead bytes.
;		    This table will be used to determine if we have a
;		    dbcs lead byte.
;
;	Inputs - none
;
;	Outputs- pointer to dbcs environmental vector table of lead bytes
;		 LBTBL DD ?
;
;	Date	  : 6/16/87
;=========================================================================

DEBUG_LEAD_BYTE proc near		;an000;get lead byte vector

	push	ds			;an000;save affected regs
	push	es			;an000;
	push	si			;an000;

	mov	ax,(ECS_call shl 8) or 00h ;an000;get dbcs env. vector
	int	21h			;an000;invoke function

	assume	ds:nothing

	mov	word ptr cs:lbtbl[0],si ;an000;move offset of table
	mov	word ptr cs:lbtbl[2],ds ;an000;move segment of table

	pop	si			;an000;restore affected regs
	pop	es			;an000;
	pop	ds			;an000;

	ret				;an000;return to caller

DEBUG_LEAD_BYTE endp			;an000;end proc

;=========================================================================
; TEST_LEAD - This routine will determine whether or not we have a valid
;	      lead byte for a DBCS character.
;
;	Inputs : AL - Holds the byte to compare.  Passed by POP.		;an001;bgb
;
;	Outputs: Carry set if lead byte
;		 No carry if not lead byte
;
;	Date	  : 6/16/87
;=========================================================================

TEST_LEAD proc	near			;an000;check for dbcs lead byte

	push	ds			;an000;save affected regs
	push	si			;an000;
	push	ax			;an000;

	xchg	ah,al			;an000;ah used for compare
	mov	si,word ptr cs:lbtbl[2] ;an000;get segment of table
	mov	ds,si			;an000;
	mov	si,word ptr cs:lbtbl[0] ;an000;get offset of table

ck_next:

	lodsb				;an000;load al with byte table
	or	al,al			;an000;end of table?
;	$IF	z			;an000;yes, end of table
	jz	lead_exit		; exit with clear carry
	    cmp     al,ah		;an000;start > character?
;	    $IF     a			;an000;it is above
	    JNA $$IF21
		clc			;an000;clear carry flag
		jmp	short lead_exit	;an000;exit with clear carry
;	    $ELSE			;an000;
	    JMP SHORT $$EN21
$$IF21:
		lodsb			;an000;load al with byte table
		cmp	ah,al		;an000;character > end range
;		$IF	a		;an000;not a lead
		JNA $$IF23
		    jmp     ck_next	;an000;check next range
;		$ELSE			;an000;lead byte found
		JMP SHORT $$EN23
$$IF23:
		    stc 		;an000;set carry flag
;		$ENDIF			;an000;
$$EN23:
;	    $ENDIF			;an000;
$$EN21:
;	$ENDIF				;an000;

lead_exit:				;an000;exit from check

	pop	ax			;an000;
	pop	si			;an000;restore affected regs.
	pop	ds			;an000;

	ret				;an000;return to caller

TEST_LEAD endp				;an000;end proc



CODE	ENDS
	END	START

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edit\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edit\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\debug\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

debug.skl : ..\usa\debug.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\edlequ.asm ===
page	60,132			;
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	.xlist
	include version.inc
	include DOSSYM.INC
	include EDLSTDSW.INC
	.list

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLEQU.SAL
;
; DESCRIPTIVE NAME: EQUATES FOR EDLIN
;
; FUNCTION: PROVIDES EQUATES FOR EDLIN.  IT ALSO PROVIDES THE MACRO
;	    VAL_YN.
;
; ENTRY POINT: NA
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
;	ROUTINE: VAL_YN - VALIDATES Y/N RESPONSES FROM THE KEYBOARD
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: NA
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT SYSPARSE
;				- IMPLEMENT MESSAGE RETRIEVER
;				- IMPLEMENT DBCS ENABLING
;				- ENHANCED VIDEO SUPPORT
;				- EXTENDED OPENS
;				- SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;
;======================= END OF SPECIFICATIONS ===========================






COMAND_LINE_LENGTH EQU 128
QUOTE_CHAR EQU	16H			;Quote character = ^V
CR	EQU	13
STKSIZ	EQU	200h
STACK	equ	stksiz

asian_blk      equ DB_SP_LO		;an000;asian blank 2nd. byte
dbcs_lead_byte equ DB_SP_HI		;an000;asian blank lead byte
nul	equ	00h			;an000;nul character
Access_Denied equ 0005h 		;an000;extended error code for access denied

;======== Y/N validation equates =========================================

yn_chk	equ	23h			;an000;check for Y/N response
max_len equ	01h			;an000;max. len. for Y/N char.
yes	equ	01h			;an000;boolean yes value
no	equ	00h			;an000;boolean no value

;======== text display values for initialization =========================

video_get equ	0fh			;an000;int 10 get video attributes
video_set equ	00h			;an000;int 10 set video attributes
video_text equ	03h			;an000;80 X 25 color monitor

;======== code page values for functions =================================

get_set_cp equ	66h			;an000;get or set code page
get_cp	equ	01h			;an000;get active code page
set_cp	equ	02h			;an000;set active code page

;======== screen length & width defaults =================================

std_out equ	01h			;an000;console output
display_attr equ 03h			;an000;display for IOCTL
Get_Display equ 7fh			;an000;Get display for IOCTL
ifndef JAPAN
Def_Disp_Len equ 25			;an000;default display length
else					; if JAPAN
Def_Disp_Len equ 24
endif
Def_Disp_Width equ 80			;an000;default display width

;======== extended open equates ==========================================

rw	equ	0082h			;an000;read/write
					;      compatibility
					;      noinherit
					;      int 24h handler
					;      no commit

ext_read equ	0080h			;an000;read
					;      compatibility
					;      noinherit
					;      int 24h handler
					;      no commit

rw_flag equ	0101h			;an000;fail if file not exist
					;      open if file exists
					;      don't validate code page

creat_flag equ	0110h			;an000;create if file does not exist
					;      fail if file exists
					;      don't validate code page

open_flag equ	0101h			;an000;fail if file not exist
					;      open if file exists
					;      don't validate code page

creat_open_flag equ 0112h		;an000;create if file does not exist
					;      open/replace if file exists
					;      don't validate code page

attr	equ	00h			;an000;attributes set to 0

;======== parse value equates ============================================

nrm_parse_exit equ 0ffffh		;an000;normal exit from sysparse
too_many equ	01h			;an000;too many parms entered
op_missing equ	02h			;an000;required operand missing
sw_missing equ	03h			;an000;not a valid switch


;======== Strucs =========================================================

Display_Buffer_Struc Struc		;an000;dms;

	Display_Info_Level db	   ?	;an000;dms;
	Display_Reserved db	 ?	;an000;dms;
	Display_Buffer_Size dw	    ?	;an000;dms;
	Display_Flags dw      ? 	;an000;dms;
	Display_Mode db      ?		;an000;dms;
					;  TEXT=01
					;  APA =02
	Display_Mode_Reserved db      ? ;an000;dms;
	Display_Colors dw      ?	;an000;dms;# of colors
	Display_Width_Pixels dw      ?	;an000;dms;# of pixels in width
	Display_Length_Pixels dw      ? ;an000;dms;# of pixels in len.
	Display_Width_Char dw	   ?	;an000;dms;# of chars in width
	Display_Length_Char dw	    ?	;an000;dms;# of chars in length

Display_Buffer_Struc ends		;an000;dms;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\edlstdsw.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)stdsw.asm	1.1 85/04/10
; Use the switches below to produce the standard Microsoft version or the IBM
; version of the operating system


;include EDLVERS.INC			;IBM/MSVER/JAPVER switches


WANG	EQU	FALSE
Rainbow EQU	FALSE


; Set this switch to cause DOS to move itself to the end of memory
HIGHMEM EQU	FALSE

	IF	IBM
ESCCH	EQU	0			; character to begin escape seq.
CANCEL	EQU	27			;Cancel with ESCAPE
TOGLPRN EQU	TRUE			;One key toggles printer echo
ZEROEXT EQU	TRUE
	ELSE
	IF	WANG			;Are we assembling for WANG?
ESCCH	EQU	1FH			;Yes. Use 1FH for escape character
	ELSE
ESCCH	EQU	1BH
	ENDIF
CANCEL	EQU	"X"-"@"                 ;Cancel with Ctrl-X
TOGLPRN EQU	FALSE			;Separate keys for printer echo on
					;and off
ZEROEXT EQU	TRUE
	ENDIF


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\edlin.asm ===
PAGE	60,132;
	TITLE	EDLIN
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLIN.SAL
;
; DESCRIPTIVE NAME: LINE TEXT EDITOR
;
; FUNCTION: EDLIN IS A SIMPLE, LINE ORIENTED TEXT EDITOR.  IT PROVIDES
;	    USERS OF DOS THE ABILITY TO CREATE AND EDIT TEXT FILES.
;
; ENTRY POINT: EDLIN
;
; INPUT: DOS COMMAND LINE
;	 EDLIN COMMANDS
;	 TEXT
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: EDLCMD1 - CONTAINS ROUTINES CALLED BY EDLIN
;		 EDLCMD1 - CONTAINS ROUTINES CALLED BY EDLIN
;		 EDLMES  - CONTAINS ROUTINES CALLED BY EDLIN
;
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT SYSPARSE
;				- IMPLEMENT MESSAGE RETRIEVER
;				- IMPLEMENT DBCS ENABLING
;				- ENHANCED VIDEO SUPPORT
;				- EXTENDED OPENS
;				- SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft"
;
;
;	MICROSOFT REVISION HISTORY:
;									;
;	V1.02										;
;									;
;	V2.00	9/13/82  M.A.U						;
;									;
;		2/23/82  Rev. 13	N. P					;
;		    Changed to 2.0 system calls.				;
;		    Added an error message for READ-ONLY files		;
;									;
;		11/7/83  Rev. 14	N. P					;
;		    Changed to .EXE format and added Printf		;
;									;
;	V2.50	11/15/83 Rev. 1 	M.A. U					;
;		    Official dos 2.50 version. Some random bug		;
;		fixes and message changes.					;
;									;
;		11/30/83 Rev. 2 	MZ						;
;		    Close input file before rename.				;
;		    Jmp to replace after line edit				;
;									;
;		02/01/84 Rev. 3 	M.A. U			;
;		    Now it is called 3.00 dos. Repaired problem 	;
;		with using printf and having %'s as data.                       ;
;									;
;		02/15/84 MZ make out of space a fatal error with output;
;									;
;		03/28/84 MZ fixes bogus (totally) code in MOVE/COPY	;
;									;
;		04/02/84 MZ fixes DELETE and changes MOVE/COPY/EDIT	;
;									;
;	V3.20 08/29/86 Rev. 1 S.M. G					;
;									;
;		08/29/86 M001 MSKK TAR 593, TAB MOVEMENT		;
;									;
;		08/29/86 M002 MSKK TAR 157, BLKMOVE 1,1,1m, 1,3,1m	;
;									;
;		08/29/86 M003 MSKK TAR 476, EDLCMD2,MAKECAPS,kana char	;
;									;
;		08/29/86 M004 MSKK TAR 191, Append load size		;
;									;
;		08/29/86 M005 IBMJ TAR Transfer Load command		;
;									;
;	04/17/90 c-PaulB						;
;		Added /? switch to display options			;
;		Files changed: edlin.asm, edlparse.asm, edlmes.asm,	;
;		edlin.skl.						;
;									;
;======================= END OF SPECIFICATIONS ===========================									;

include version.inc
include intnat.inc
include syscall.inc
include edlequ.asm


SUBTTL	Contants and Data areas
PAGE
	extrn	parser_command:near		;an000;SYSPARSE

CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC WORD
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

CONST	SEGMENT PUBLIC WORD

	public	bak,$$$file,delflg,loadmod,txt1,txt2

	EXTRN	BADDRV:abs,NDNAME:abs
	EXTRN	opt_err_ptr:word,NOBAK:abs,BADCOM:abs
	EXTRN	NEWFIL:abs,DEST:abs,MRGERR:abs
	EXTRN	NODIR:abs,FILENM_ptr:word,ro_err:abs
	EXTRN	bcreat:abs,msg_too_many:abs,msg_lf:abs
	EXTRN	prompt:abs,MemFul_Ptr:word,simple_msg:word
	extrn	dsp_options:abs
	extrn	dsp_help:abs,num_help_msgs:abs

BAK	DB	".BAK",0

$$$FILE DB	".$$$",0

fourth	db	0			;fourth parameter flag

loadmod db	0			;Load mode flag, 0 = ^Z marks the
					; end of a file, 1 = viceversa.
optchar db	"-"

TXT1	DB	0,80H DUP (?)
TXT2	DB	0,80H DUP (?)
DELFLG	DB	0
fNew	DB	0			; old file
HAVEOF	DB	0

CONST	ENDS

cstack	segment stack
	db  stksiz dup (?)
cstack	ends

DATA	SEGMENT PUBLIC WORD

	extrn	arg_buf_ptr:word		;an000;
	extrn	line_num_buf_ptr:word		;an000;

	public	path_name,ext_ptr,start,line_num,line_flag
	public	arg_buf,wrt_handle,temp_path
	public	current,pointer,qflg,editbuf,amnt_req,fname_len,delflg,lastlin
	public	olddat,oldlen,newlen,srchflg,srchmod
	public	comline,lstfnd,numpos,lstnum,last_mem,srchcnt
	public	rd_handle,haveof,ending,three4th,one4th

	public	lc_adj				;an000;page length adj. factor
	public	lc_flag 			;an000;display cont. flag
	public	pg_count			;an000;lines left on screen
	public	Disp_Len			;an000;display length
	public	Disp_Width			;an000;display width
	public	continue			;an000;boolean T/F
	public	temp_path			;an000;pointer to filespec buf

Video_Buffer	label	word			;an000;buffer for video attr
	db	0				;an000;dms;
	db	0				;an000;dms;
	dw	14				;an000;dms;
	dw	0				;an000;dms;
	db	?				;an000;dms;
	db	0				;an000;dms;
	dw	?				;an000;dms;# of colors
	dw	?				;an000;dms;# of pixels in width
	dw	?				;an000;dms;# of pixels in len.
	dw	?				;an000;dms;# of chars in width
	dw	?				;an000;dms;# of chars in length


video_org	db	?			;an000;original video mode on
						;      entry to EDLIN.
lc_adj		db	?			;an000;page length adj. factor
lc_flag 	db	?			;an000;display cont. flag
pg_count	db	?			;an000;lines left on screen
Disp_Len	db	?			;an000;display length
Disp_Width	db	?			;an000;display width
continue	db	?			;an000;boolean T/F


;-----------------------------------------------------------------------;
; This is a table that is sequentially filled via GetNum.  Any additions to it
; must be placed in the correct position.  Currently Param4 is known to be a
; count and thus is treated specially.

	public	param1,param2,Param3,param4,ParamCt
PARAM1	DW	?
PARAM2	DW	?
PARAM3	DW	?
PARAM4	DW	?
ParamCt DW	?			; count of passed parameters
	ifdef	DBCS			; Used in TESTKANJ:
LBTbl	dd	?			;  long pointer to lead byte table
	endif				;  in the dos (from syscall 63H)

;-----------------------------------------------------------------------;

PUBLIC PTR_1, PTR_2, PTR_3, OLDLEN, NEWLEN, LSTFND, LSTNUM, NUMPOS, SRCHCNT
PUBLIC CURRENT, POINTER, ONE4TH, THREE4TH, LAST_MEM, ENDTXT, COPYSIZ
PUBLIC COMLINE, LASTLIN, COMBUF, EDITBUF, EOL, QFLG, ENDING, SRCHFLG
PUBLIC PATH_NAME, FNAME_LEN, RD_HANDLE, TEMP_PATH, WRT_HANDLE, EXT_PTR
PUBLIC MRG_PATH_NAME, MRG_HANDLE, amnt_req, olddat, srchmod, MOVFLG, org_ds
ifdef	DBCS
public	lbtbl
endif

;
; These comprise the known state of the internal buffer.  All editing
; functions must preserve these values.
;
CURRENT     DW	    ?			; the 1-based index of the current line
POINTER     DW	    ?			; pointer to the current line
ENDTXT	    DW	    ?			; pointer to end of buffer. (at ^Z)
LAST_MEM    DW	    ?			; offset of last byte of memory
;
; The label Start is the beginning of the in-core buffer.
;

;
; Internal temporary pointers
;
PTR_1		DW	    ?
PTR_2		DW	    ?
PTR_3		DW	    ?

QFLG		DB	    ?			; TRUE => query for replacement
OLDLEN	DW	    ?
NEWLEN	DW	    ?
LSTFND	DW	    ?
LSTNUM	DW	    ?
NUMPOS	DW	    ?
SRCHCNT     DW	    ?
ONE4TH	DW	    ?
THREE4TH    DW	    ?
COPYSIZ     DW	    ?			; total length to copy
COPYLEN     DW	    ?			; single copy length
COMLINE     DW	    ?
LASTLIN     DW	    ?
COMBUF	DB	    82H DUP (?)
EDITBUF     DB	    258 DUP (?)
EOL		DB	    ?
ENDING	DB	    ?
SRCHFLG     DB	    ?
PATH_NAME   DB	    128 DUP(0)
FNAME_LEN   DW	    ?
RD_HANDLE   DW	    ?
TEMP_PATH   DB	    128 DUP(?)
WRT_HANDLE  DW	    ?
EXT_PTR     DW	    ?
MRG_PATH_NAME DB    128 DUP(?)
MRG_HANDLE  DW	    ?
amnt_req    dw	    ?			; amount of bytes requested to read
olddat	db	    ?			; Used in replace and search, replace
					; by old data flag (1=yes)
srchmod     db	    ?			; Search mode:	1=from current+1 to
					; end of buffer, 0=from beg.  of
					; buffer to the end (old way).
MOVFLG	    DB	    ?
org_ds	    dw	    ?			;Orginal ds points to header block

arg_buf db	258 dup (?)

EA_Flag 	db	False		;an000; dms;set to false

EA_Buffer_Size	dw	?		;an000; dms;EA buffer's size

EA_Parm_List	label	word		;an000; dms;EA parms
		dd	dg:Start	;an000; dms;ptr to EA's
		dw	0001h		;an000; dms;additional parms
		db	06h		;an000; dms;
		dw	0002h		;an000; dms;iomode


line_num    dw	?

line_flag   db	?,0
	EVEN			;align on word boundaries
;
; Byte before start of data buffer must be < 40H  !!!!!!
;
	    dw	0		;we scan backwards looking for
				;a character which can't be part
				;of a two-byte seqence.  This
				;double byte sequence will cause the back
				;scan to stop here.
START	LABEL	WORD

DATA	ENDS


CODE SEGMENT PUBLIC

ASSUME	CS:DG,DS:NOTHING,ES:NOTHING,SS:CStack



	extrn	pre_load_message:near		;an000;message loader
	extrn	disp_fatal:near 		;an000;fatal message
	extrn	printf:near			;an000;new PRINTF routine

	extrn	findlin:near,shownum:near,loadbuf:near,crlf:near,lf:near
	extrn	abortcom:near,delbak:near,unquote:near,kill_bl:near
	extrn	make_caps:near,dispone:near,display:near,query:near
	extrn	quit:near,make_cntrl:near,scanln:near,scaneof:near
	extrn	fndfirst:near,fndnext:near,replace:near,memerr:near
	extrn	xerror:near
	extrn	zerror:near
	extrn	bad_read:near,append:near
	extrn	nocom:near,pager:near,list:near,search_from_curr:near
	extrn	replac_from_curr:near,ewrite:near,wrt:near,delete:near


	extrn	filespec:byte			;an000;parser's filespec
	extrn	parse_switch_b:byte		;an000;result of switch scan
	extrn	parse_switch_?:byte		;      result of switch scan

	public	std_printf,command,chkrange,comerr
	public	display_message
						;      exit from EDLIN

	IFDEF	DBCS
	extrn	testkanj:near
	ENDIF

EDLIN:
	JMP	SHORT SIMPED

std_printf	proc	near			;ac000;convert to proc

	push	dx
	call	printf
	pop	dx				;an000;balance the push
	ret

std_printf	endp				;ac000;end proc

Break	<Dispatch Table>

;-----------------------------------------------------------------------;
;   Careful changing the order of the next two tables.	They are linked and
;   changes should be be to both.

COMTAB	DB	13,";ACDEILMPQRSTW"
NUMCOM	EQU	$-COMTAB

TABLE	DW	BLANKLINE		; Blank line
	DW	NOCOM			; ;
	DW	APPEND			; A(ppend)
	DW	COPY			; C(opy)
	DW	DELETE			; D(elete)
	DW	ENDED			; E(xit)
	DW	INSERT			; I(nsert)
	DW	LIST			; L(ist)
	DW	MOVE			; M(ove)
	DW	PAGER			; P(age)
	DW	QUIT			; Q(uit)
	dw	replac_from_curr	; R(eplace)
	dw	search_from_curr	; S(earch)
	DW	MERGE			; T(merge)
	DW	EWRITE			; W(rite)

Break	<Initialization Code>

NONAME:
	mov	ax,NDNAME
	jmp	zerror

SIMPED:
	mov	org_ds,DS
	push	ax			;ac000;save for drive compare

	push	cs			;an000;exchange cs/es
	pop	es			;an000;

	push	cs			;an000;exchange cs/ds
	pop	ds			;an000;
	assume	ds:dg,es:dg		;an000;establish addressibility

	MOV	dg:ENDING,0
	mov	sp,stack
	call	EDLIN_DISP_GET			;an000;get current video
						;      mode & set it to
						;      text

;=========================================================================
; invoke PRE_LOAD_MESSAGE here.  If the messages were not loaded we will
; exit with an appropriate error message.
;
;	Date	   : 6/14/87
;=========================================================================

	call	PRE_LOAD_MESSAGE	;an000;invoke SYSLOADMSG
;	$if	c			;an000;if the load was unsuccessful
	JNC $$IF1
		mov ah,exit		;an000;exit EDLIN. PRE_LOAD_MESSAGE
					;      has said why we are exiting
		mov al,00h		;an000
		int 21h 		;an000;exit
;	$endif				;an000;
$$IF1:



VERS_OK:
;----- Check for valid drive specifier --------------------------------;

	pop	ax
	OR	AL,AL
	JZ	get_switch_char
	mov	ax,BADDRV
	jmp	zerror
get_switch_char:
	MOV	AX,(CHAR_OPER SHL 8)	;GET SWITCH CHARACTER
	INT	21H
	CMP	DL,"/"
	JNZ	CMD_LINE		;IF NOT / , THEN NOT PC
	MOV	OPTCHAR,"/"		;IN PC, OPTION CHAR = /

	IFDEF	DBCS
	push	ds			; SAVE! all regs destroyed on this
	push	es
	push	si			; call !!
	mov	ax,(ECS_call shl 8) or 00h  ; get kanji lead tbl
	int	21h
assume	ds:nothing
assume	es:nothing
	mov	word ptr [LBTbl],si
	mov	word ptr [LBTbl+2],ds
	pop	si
	pop	es
	pop	ds
assume	ds:dg
assume	es:dg
	ENDIF


CMD_LINE:
	push	cs
	pop	es
	ASSUME	ES:DG

;----- Process any options ------------------------------------------;

;=========================================================================
;  The system parser, called through PARSER_COMMAND, parses external
;  command lines.  In the case of EDLIN we are looking for two parameters
;  on the command line.
;
;  Parameter 1 - Filespec (REQUIRED)
;  Parameter 2 - \B switch (OPTIONAL)
;
;  PARSER_COMMAND  -  exit_normal : ffffh
;		      exit_error  : not = ffffh
;=========================================================================


	call	PARSER_COMMAND		;an000;invoke sysparse
					;      DMS:6/11/87

	; Check for /? switch.
	; If so, display the options
	; and exit.
	;
	; This is done first so that if the user typed
	; /? along with unknown commands, they can get
	; a coherent message without being over-errored.
	;
	; 4/17/90 c-PaulB

	cmp	[parse_switch_?], true	; is the /? switch on?
	jne	CheckOptionsDone	;  skip the rest of this if not

	mov	ax,dsp_options
	call	display_message

	mov	al, 0			; get an okay exit code
	mov	ah, exit		;  and
	int	21h			;   bail out.

CheckOptionsDone:

	cmp	ax,nrm_parse_exit	;an000;was it a good parse
;	$if	z			;an000;it was a good parse
	JNZ $$IF3
		call EDLIN_COMMAND	;an000;interface results
					;      into EDLIN
;	$else				;an000;
	JMP SHORT $$EN3
$$IF3:
		cmp ax,too_many 	;an000;too many operands
;		$if z			;an000;we have too many
		JNZ $$IF5
		    jmp short badopt	;an000;say why and exit
;		$endif
$$IF5:

		cmp ax,op_missing	;an000;required parm missing
;		$if z			;an000;missing parm
		JNZ $$IF7
ifdef DBCS
		    jmp noname		;an000;say why and exit
else
		    jmp short noname	;an000;say why and exit
endif
;		$endif			;an000;
$$IF7:

		cmp ax,sw_missing	;an000;is it an invalid switch
;		$if z			;an000;invalid switch
		JNZ $$IF9
		    jmp short badopt	;an000;say why and exit
;		$endif			;an000;
$$IF9:

;	$endif				;an000;
$$EN3:

;=========================================================================
;======================= begin .BAK check ================================
; Check for .BAK extension on the filename

	push	ds			;an000;save reg.
	push	cs			;an000;set up addressibility
	pop	ds			;an000;
	assume	ds:dg			;an000;

	push	ax			;an000;save reg.
	mov	ax,offset dg:path_name	;an000;point to path_name
	add	ax,[fname_len]		;an000;calculate end of path_name
	mov	si,ax			;an000;point to end of path_name
	pop	ax			;an000;restore reg.

	MOV	CX,4			;compare 4 bytes
	SUB	SI,4			;Point 4th to last char
	MOV	DI,OFFSET DG:BAK	;Point to string ".BAK"
	REPE	CMPSB			;Compare the two strings
	pop	ds
	ASSUME	DS:NOTHING
	JNZ	NOTBAK
	JMP	HAVBAK

;======================= end .BAK check ==================================

;======================= begin NOTBAK ====================================
; we have a file without a .BAK extension, try to open it

NOTBAK:
	push	ds
	push	cs
	pop	ds
	ASSUME	DS:DG

;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	push	es			;an000;save reg.
	mov	bx,RW			;an000;open for read/write
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,RW_FLAG		;an000;action to take on open
	mov	di,0ffffh		;an000;nul parm list

	call	EXT_OPEN1		;an000;open for R/W;DMS:6/10/87
	pop	es			;an000;restore reg.

;=========================================================================
	pop	ds
	ASSUME	DS:NOTHING
	JC	CHK_OPEN_ERR		;an open error occurred
	MOV	RD_HANDLE,AX		;Save the handle

	Jmp	HavFil			;work with the opened file

;======================= end NOTBAK ======================================

Badopt:
	MOV	DX,OFFSET DG:OPT_ERR_ptr;Bad option specified
	JMP	XERROR

;=========================================================================
;
; The open of the file failed.	We need to figure out why and report the
; correct message. The circumstances we can handle are:
;
;   open returns pathnotfound => bad drive or file name
;   open returns toomanyopenfiles => too many open files
;   open returns access denied =>
;	chmod indicates read-only => cannot edit read only file
;	else => file creation error
;   open returns filenotfound =>
;	creat ok => close, delete, new file
;	creat fails => file creation error
;   else => file cre
;

CHK_OPEN_ERR:
	cmp	ax,error_path_not_found
	jz	BadDriveError
	cmp	ax,error_too_many_open_files
	jz	TooManyError
	cmp	ax,error_access_denied
	jnz	CheckFNF
	push	ds
	push	cs
	pop	ds
	assume	ds:dg
	mov	ax,(chmod shl 8)
	MOV	DX,OFFSET DG:PATH_NAME
	int	21h
	jc	FileCreationError
	test	cx,attr_read_only
	jz	FileCreationError
	jmp	short ReadOnlyError

CheckFNF:
	cmp	ax,error_file_not_found
	jnz	FileCreationError
;
; Try to create the file to see if it is OK.
;
	push	ds
	push	cs
	pop	ds
	assume ds:dg
;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	mov	bx,RW			;an000;open for read/write
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,CREAT_FLAG		;an000;action to take on open
	mov	di,0ffffh		;an000;null parm list
	call	EXT_OPEN1		;an000;create file;DMS:6/10/87

;=========================================================================

	pop	ds
	assume	ds:nothing
	jc	CreateCheck
	mov	bx,ax
	mov	ah,close
	int	21h
	push	ds
	push	cs
	pop	ds
	assume	ds:dg
	mov	ah,unlink
	MOV	DX,OFFSET DG:PATH_NAME
	int	21h
	pop	ds
	assume	ds:nothing
	jc	FileCreationError	; This should NEVER be taken!!!
	MOV	HAVEOF,0FFH		; Flag from a system 1.xx call
	MOV	fNew,-1
	JMP	short HAVFIL

CreateCheck:
	cmp	ax,error_access_denied
	jnz	BadDriveError
DiskFull:
	mov	ax,NODIR
	jmp	zerror

FileCreationError:
	mov	ax,bcreat
	jmp	zerror

ReadOnlyError:
	mov	ax,RO_ERR
	jmp	zerror

BadDriveError:
	mov	ax,BADDRV
	jmp	zerror

TooManyError:
	mov	ax,msg_too_many
	jmp	zerror


CREAT_ERR:
	CMP	DELFLG,0
	JNZ	DiskFull
	push	cs
	pop	ds
	CALL	DELBAK
	JMP	short MAKFIL

HAVBAK:
	mov	ax,NOBAK
	jmp	zerror

HAVFIL:
	push	cs
	pop	ds
	ASSUME	DS:DG
	CMP	fNew,0
	JZ	MakeBak
	mov	ax,newfil
	call	display_message
MakeBak:
	MOV	SI,OFFSET DG:PATH_NAME
	MOV	CX,[FNAME_LEN]
	PUSH	CX
	MOV	DI,OFFSET DG:TEMP_PATH
	REP	MOVSB
	DEC	DI
	MOV	DX,DI
	POP	CX
	MOV	AL,"."
	STD
	REPNE	SCASB
	JZ	FOUND_EXT
	MOV	DI,DX			;Point to last char in filename
FOUND_EXT:
	CLD
	INC	DI
	MOV	[EXT_PTR],DI
	MOV	SI,OFFSET DG:$$$FILE
	MOV	CX,5
	REP	MOVSB

;Create .$$$ file to make sure directory has room
MAKFIL:

;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	mov	bx,RW			;an000;open for read/write
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,Creat_Open_Flag	;an000;action to take on open
	cmp	EA_Flag,True		;an000;EA_Buffer used?
;	$if	e			;an000;yes
	JNE $$IF12
		mov	di,offset dg:EA_Parm_List ;an000; point to buffer
;	$else				;an000;
	JMP SHORT $$EN12
$$IF12:
		mov	di,0ffffh	;an000;nul parm list
;	$endif				;an000;
$$EN12:
	call	EXT_OPEN2		;an000;create file;DMS:6/10/87

;=========================================================================

	JC	CREAT_ERR
	MOV	[WRT_HANDLE],AX
;
; We determine the size of the available memory.  Use the word in the PDB at
; [2] to determine the number of paragraphs.  Then truncate this to 64K at
; most.
;
	push	ds				;save ds for size calc
	mov	ds,[org_ds]
	MOV	CX,DS:[2]
	MOV	DI,CS
	SUB	CX,DI
	CMP	CX,1000h
	JBE	GotSize
	MOV	CX,0FFFh
GotSize:
	SHL	CX,1
	SHL	CX,1
	SHL	CX,1
	SHL	CX,1
	pop	ds				;restore ds after size calc
	DEC	CX
	MOV	[LAST_MEM],CX
	MOV	DI,OFFSET DG:START
	TEST	fNew,-1
	JNZ	SAVEND
	SUB	CX,OFFSET DG:START	;Available memory
	SHR	CX,1			;1/2 of available memory
	MOV	AX,CX
	SHR	CX,1			;1/4 of available memory
	MOV	[ONE4TH],CX		;Save amount of 1/4 full
	ADD	CX,AX			;3/4 of available memory
	MOV	DX,CX
	ADD	DX,OFFSET DG:START
	MOV	[THREE4TH],DX		;Save pointer to 3/4 full
	MOV	DX,OFFSET DG:START
SAVEND:
	CLD
	MOV	BYTE PTR [DI],1AH
	MOV	[ENDTXT],DI
	MOV	BYTE PTR [COMBUF],128
	MOV	BYTE PTR [EDITBUF],255
	MOV	BYTE PTR [EOL],10
	MOV	[POINTER],OFFSET DG:START
	MOV	[CURRENT],1
	MOV	ParamCt,1
	MOV	[PARAM1],0		;M004 Leave room in memory, was -1
	TEST	fNew,-1
	JNZ	COMMAND
;
; The above setting of PARAM1 to -1 causes this call to APPEND to try to read
;  in as many lines that will fit, BUT.... What we are doing is simulating
;  the user issuing an APPEND command, and if the user asks for more lines
;  than we get then an "Insufficient memory" error occurs. In this case we
;  DO NOT want this error, we just want as many lines as possible read in.
;  The twiddle of ENDING suppresses the memory error
;
	MOV	BYTE PTR [ENDING],1	;Suppress memory errors
	CALL	APPEND
	MOV	ENDING,0		; restore correct initial value

Break	<Main command loop>

;
; Main read/parse/execute loop.  We reset the stack all the time as there
; are routines that JMP back here.  Don't blame me; Tim Paterson write this.
;
COMMAND:
	push	cs				;an000;set up addressibility
	pop	ds				;an000;
	push	cs				;an000;
	pop	es				;an000;
	assume	ds:dg,es:dg			;an000;

	MOV	SP, STACK
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H
	MOV	DX,OFFSET DG:ABORTCOM
	INT	21H
	mov	ax,prompt
	call	display_message

	MOV	DX,OFFSET DG:COMBUF
	MOV	AH,STD_CON_STRING_INPUT
	INT	21H
	MOV	[COMLINE],OFFSET DG:COMBUF + 2

	mov	ax,msg_lf
	call	display_message

PARSE:
	MOV	[PARAM2],0
	MOV	[PARAM3],0
	MOV	[PARAM4],0
	mov	[fourth],0		;reset the fourth parameter flag
	MOV	QFLG,0
	MOV	SI,[COMLINE]
	MOV	BP,OFFSET DG:PARAM1
	XOR	DI,DI
CHKLP:
	CALL	GETNUM
;
; AL has first char after arg
;
	MOV	ds:[BP+DI],DX
	ADD	DI,2

	MOV	ParamCt,DI		; set up count of parameters
	SHR	ParamCt,1		; convert to index (1-based)

	CALL	SKIP1			; skip to next parameter
	CMP	AL,","			; is there a comma?
	jnz	NOT_COMMA		; if not, then done with arguments

	cmp	di,8			; **** maximum size of PARAM array!
	jb	CHKLP			;  continue scanning if <4 PARAMS
	jmp	short COMERR

NOT_COMMA:
	DEC	SI			; point at char next
	CALL	Kill_BL 		; skip all blanks
	CMP	AL,"?"			; is there a ?
	JNZ	DISPATCH		; no, got command letter
	MOV	QFLG,-1 		; signal query
	CALL	Kill_BL
DISPATCH:
	CMP	AL,5FH
	JBE	UPCASE
	cmp	al,"z"
	ja	upcase
	AND	AL,5FH
UPCASE:
	MOV	DI,OFFSET DG:COMTAB
	mov	cx,NUMCOM
	REPNE	SCASB
	JNZ	COMERR

	SUB	DI,1+OFFSET DG:COMTAB	; convert to index
	MOV	BX,DI
	MOV	AX,[PARAM2]
	OR	AX,AX
	JZ	PARMOK
	CMP	AX,[PARAM1]
	JB	COMERR			; Param. 2 must be >= param 1
PARMOK:
	MOV	[COMLINE],SI
	SHL	BX,1
	CALL	[BX+TABLE]
COMOVER:
	MOV	SI,[COMLINE]
	CALL	Kill_BL
	CMP	AL,0DH
	JZ	COMMANDJ
	CMP	AL,1AH
	JZ	DELIM
	CMP	AL,";"
	JNZ	NODELIM
DELIM:
	INC	SI
NODELIM:
	DEC	SI
	MOV	[COMLINE],SI
	JMP	PARSE

COMMANDJ:
	JMP	COMMAND

SKIP1:
	DEC	SI
	CALL	Kill_BL
ret1:	return

Break	<Range Checking and argument parsing>

;
; People call here.  we need to reset the stack.
;   Inputs: BX has param1
;   Outputs: Returns if BX <= Param2
;

CHKRANGE:
	CMP	[PARAM2],0
	retz
	CMP	BX,[PARAM2]
	JBE	RET1
	POP	DX			; clean up return address
COMERR:
	mov	ax,BADCOM
zcomerr1:
	call	display_message
	jmp	command

COMERR1:
	call	std_printf
	JMP	COMMAND

;
; GetNum parses off 1 argument from the command line.  Argument forms are:
;   nnn     a number < 65536
;   +nnn    current line + number
;   -nnn    current line - number
;   .	    current line
;   #	    lastline + 1
;
;

GETNUM:
	CALL	Kill_BL
	cmp	di,6			;Is this the fourth parameter?
	jne	sk1
	mov	[fourth],1		;yes, set the flag
sk1:
	CMP	AL,"."
	JZ	CURLIN
	CMP	AL,"#"
	JZ	MAXLIN
	CMP	AL,"+"
	JZ	FORLIN
	CMP	AL,"-"
	JZ	BACKLIN
	MOV	DX,0
	MOV	CL,0			;Flag no parameter seen yet
NUMLP:
	CMP	AL,"0"
	JB	NUMCHK
	CMP	AL,"9"
	JA	NUMCHK
	CMP	DX,6553 		;Max line/10
	JAE	COMERR			;Ten times this is too big
	MOV	CL,1			;Parameter digit has been found
	SUB	AL,"0"
	MOV	BX,DX
	SHL	DX,1
	SHL	DX,1
	ADD	DX,BX
	SHL	DX,1
	CBW
	ADD	DX,AX
	LODSB
	JMP	SHORT NUMLP
NUMCHK:
	CMP	CL,0
	retz
	OR	DX,DX
	JZ	COMERR			;Don't allow zero as a parameter
	return

CURLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	MOV	DX,[CURRENT]
	LODSB
	return
MAXLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	MOV	DX,1
	MOV	AL,0Ah
	PUSH	DI
	MOV	DI,OFFSET DG:START
	MOV	CX,EndTxt
	SUB	CX,DI
MLoop:
	JCXZ	MDone
	REPNZ	SCASB
	JNZ	MDone
	INC	DX
	JMP	MLoop
MDone:
	POP	DI
	LODSB
	return
FORLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	CALL	GETNUM
	ADD	DX,[CURRENT]
	return
BACKLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	CALL	GETNUM
	MOV	BX,[CURRENT]
	SUB	BX,DX
	JA	OkLin			; if negative or zero
	MOV	BX,1			; use first line
OkLin:
	MOV	DX,BX
	return

comerra:
	jmp	comerr


ERRORJ:
	JMP	COMERR
ERROR1J:
	JMP	zcomerr1

BLANKLINE:
	cmp	QFLG,0
	jnz	SHOWHELP		; if ? at front of blank line, do HELP
	jmp	NOCOM			; ignore blank line otherwise

SHOWHELP:
	dec	[COMLINE]		; point back to <cr>
	mov	cx,num_help_msgs-1
	mov	ax,dsp_help
SHOWHELP1:
	call	display_message
	inc	ax
	loop	SHOWHELP1

;	fall into display_message for last message and return

;=========================================================================
; display_message	: Displays a simple common message through the
;			;  message retriever, using a common parameter
;			;  block.

;	Inputs	: ax = message number to display
;
;=========================================================================

display_message	proc	near

	mov	dg:[simple_msg],ax
	mov	dx,offset dg:simple_msg
	jmp	printf			; display it

display_message	endp



Break	<Move and Copy commands>

PUBLIC MOVE
MOVE:
	CMP	ParamCt,3
	JNZ	ERRORJ
	MOV	BYTE PTR [MOVFLG],1
	JMP	SHORT BLKMOVE

PUBLIC COPY
COPY:
	CMP	ParamCt,3
	JB	ERRORJ
	MOV	BYTE PTR [MOVFLG],0
;
; We are to move/copy a number of lines from one range to another.
;
; Memory looks like this:
;
;   START:	line 1
;		...
;   pointer->	line n		Current has n in it
;		...
;		line m
;   endtxt->	^Z
;
; The algoritm is:
;
;   Bounds check on args.
;   set ptr1 and ptr2 to range before move
;   set copysiz to number to move
;   open up copysize * count for destination
;   if destination is before ptr1 then
;	add copysize * count to both ptrs
;   while count > 0 do
;	move from ptr1 to destination for copysize bytes
;	count --
;   if moving then
;	move from ptr2 through end to ptr1
;   set endtxt to last byte moved.
;   set current, pointer to original destination
;

BLKMOVE:
;
; Make sure that all correct arguments are specified.
;
	MOV	BX,[PARAM3]		; get destination of move/copy
	OR	BX,BX			; must be specified (non-0)
	mov	ax,DEST
	JZ	ERROR1J 		; is 0 => error
;
; get arg 1 (defaulting if necessary) and range check it.
;
	MOV	BX,[PARAM1]		; get first argument
	OR	BX,BX			; do we default it?
	JNZ	NXTARG			; no, assume it is OK.
	MOV	BX,[CURRENT]		; Defaults to the current line
	CALL	CHKRANGE		; Make sure it is good.
	MOV	[PARAM1],BX		; set it
NXTARG:
	CALL	FINDLIN 		; find first argument line
	JNZ	ErrorJ			; line not found
	MOV	[PTR_1],DI
;
; get arg 2 (defaulting if necessary) and range check it.
;
	MOV	BX,[PARAM2]		; Get the second parameter
	OR	BX,BX			; do we default it too?
	JNZ	HAVARGS 		; Nope.
	MOV	BX,[CURRENT]		; Defaults to the current line
	MOV	[PARAM2],BX		; Stash it away
HAVARGS:
	CALL	FindLin
	JNZ	ErrorJ			; line not found
	MOV	BX,Param2
	INC	BX			;Get pointer to line Param2+1
	CALL	FINDLIN
	MOV	[PTR_2],DI		;Save it
;
; We now have true line number arguments and pointers to the relevant places.
; ptr_1 points to beginning of region and ptr_2 points to first byte beyond
; that region.
;
; Check args for correct ordering of first two arguments
;
	mov	dx,[param1]
	cmp	dx,[param2]
	jbe	havargs1		; first must be <= second
	jmp	comerr
havargs1:
;
; make sure that the third argument is not contained in the first range
;
	MOV	DX,[PARAM3]
	CMP	DX,[PARAM1]		; third must be <= first or
	JBE	NOERROR
	CMP	DX,[PARAM2]
	JA	NoError 		; third must be > last
	JMP	ComErr
NOERROR:
;
; Determine number to move
;
	MOV	CX,Ptr_2
	SUB	CX,Ptr_1		; Calculate number of bytes to copy
	MOV	CopySiz,CX
	MOV	CopyLen,CX		; Save for individual move.
	MOV	AX,[PARAM4]		; Was count defaulted?
	OR	AX,AX
	JZ	SizeOk			; yes, CX has correct value
	MUL	[COPYSIZ]		; convert to true size
	MOV	CX,AX			; move to count register
	OR	DX,DX			; overflow?
	JZ	SizeOK			; no
	JMP	MEMERR			; yes, bomb.
SizeOK:
	MOV	[COPYSIZ],CX
;
; Check to see that we have room to grow by copysiz
;
	MOV	AX,[ENDTXT]		; get pointer to last byte
	MOV	DI,[LAST_MEM]		; get offset of last location in memory
	SUB	DI,AX			; remainder of space
	CMP	DI,CX			; is there at least copysiz room?
	JAE	HAV_ROOM		; yes
	JMP	MEMERR
HAV_ROOM:
;
; Find destination of move/copy
;
	MOV	BX,[PARAM3]
	CALL	FINDLIN
	MOV	[PTR_3],DI
;
; open up copysiz bytes of space at destination
;
;	move (p3, p3+copysiz, endtxt-p3);
;
	MOV	SI,EndTxt		; get source pointer to end
	MOV	CX,SI
	SUB	CX,DI			; number of bytes from here to end
	INC	CX			; remember ^Z at end
	MOV	DI,SI			; destination starts at end
	ADD	DI,[COPYSIZ]		; plus size we are opening
	MOV	[ENDTXT],DI		; new end point
	STD				; go backwards
	REP	MOVSB			; and store everything
	CLD				; go forward
;
; relocate ptr_1 and ptr_2 if we moved them
;
	MOV	BX,Ptr_3
	CMP	BX,Ptr_1		; was dest before source?
	JA	NoReloc 		; no, above. no relocation
	MOV	BX,CopySiz
	ADD	Ptr_1,BX
	ADD	Ptr_2,BX		; relocate pointers
NoReloc:
;
; Now we copy for count times copylen bytes from ptr_1 to ptr_3
;
;	move (ptr_1, ptr_3, copylen);
;
	MOV	BX,Param4		; count (0 and 1 are both 1)
	MOV	DI,Ptr_3		; destination
CopyText:
	MOV	CX,CopyLen		; number to move
	MOV	SI,Ptr_1		; start point
	REP	MOVSB			; move the bytes
	SUB	BX,1			; exhaust count?
	JG	CopyText		; no, go for more
;
; If we are moving
;
	CMP	BYTE PTR MovFlg,0
	JZ	CopyDone
;
; Delete the source text between ptr_1 and ptr_2
;
;	move (ptr_2, ptr_1, endtxt-ptr_2);
;
	MOV	DI,Ptr_1		; destination
	MOV	SI,Ptr_2		; source
	MOV	CX,EndTxt		; pointer to end
	SUB	CX,SI			; number of bytes to move
	CLD				; forwards
	REP	MOVSB
	MOV	BYTE PTR ES:[DI],1Ah	; remember ^Z terminate
	MOV	EndTxt,DI		; new end of file
;
; May need to relocate current line (parameter 3).
;
	MOV	BX,Param3		; get new current line
	CMP	BX,Param1		; do we need to relocate
	JBE	CopyDone		; no, current line is before removed M002
	ADD	BX,Param1		; add in first
	SUB	BX,Param2		; current += first-last - 1;
	DEC	BX
	MOV	Param3,BX
CopyDone:
;
; we are done.	Make current line the destination
;
	MOV	BX,Param3		; set parameter 3 to be current
	CALL	FINDLIN
	MOV	[POINTER],DI
	MOV	[CURRENT],BX
	return

Break	<MoveFile - open up a hole in the internal file>

;
;   MoveFile moves the text in the buffer to create a hole
;
;   Inputs:	DX is spot in buffer for destination
;		DI is spot in buffer for source
MOVEFILE:
	MOV	CX,[ENDTXT]		;Get End-of-text marker
	MOV	SI,CX
	SUB	CX,DI			;Calculate number of bytes to copy
	INC	CX			; remember ^Z
	MOV	DI,DX
	STD
	REP	MOVSB			;Copy CX bytes
	XCHG	SI,DI
	CLD
	INC	DI
	MOV	BP,SI
SETPTS:
	MOV	[POINTER],DI		;Current line is first free loc
	MOV	[CURRENT],BX		;   in the file
	MOV	[ENDTXT],BP		;End-of-text is last free loc before
	return

NAMERR:
	cmp	ax,error_file_not_found
	jne	otherMergeErr
	MOV	DX,OFFSET DG:FILENM_ptr
	JMP	COMERR1

otherMergeErr:
	mov	ax,BADDRV
	jmp	zcomerr1

PUBLIC MERGE
MERGE:
	CMP	ParamCt,1
	JZ	MergeOK
	JMP	Comerr
MergeOK:
	CALL	KILL_BL
	DEC	SI
	MOV	DI,OFFSET DG:MRG_PATH_NAME
	XOR	CX,CX
	CLD
MRG1:
	LODSB
	CMP	AL," "
	JE	MRG2
	CMP	AL,9
	JE	MRG2
	CMP	AL,CR
	JE	MRG2
	CMP	AL,";"
	JE	MRG2
	STOSB
	JMP	SHORT MRG1
MRG2:
	MOV	BYTE PTR[DI],0
	DEC	SI
	MOV	[COMLINE],SI

;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	push	es			;an000;save reg.
	mov	bx,ext_read		;an000;open for read
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,OPEN_FLAG		;an000;action to take on open
	mov	di,0ffffh		;an000;null parm list
	call	EXT_OPEN3		;an000;create file;DMS:6/10/87
	pop	es			;an000;restore reg.

;=========================================================================

	JC	NAMERR

	MOV	[MRG_HANDLE],AX
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H
	MOV	DX,OFFSET DG:ABORTMERGE
	INT	21H
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	MRG
	MOV	BX,[CURRENT]
	CALL	CHKRANGE
MRG:
	CALL	FINDLIN
	MOV	BX,DX
	MOV	DX,[LAST_MEM]
	CALL	MOVEFILE
	MOV	DX,[POINTER]
	MOV	CX,[ENDTXT]
	SUB	CX,[POINTER]
	PUSH	CX
	MOV	BX,[MRG_HANDLE]
	MOV	AH,READ
	INT	21H
	POP	DX
	MOV	CX,AX
	CMP	DX,CX
	JA	FILEMRG 			; M005
	mov	ax,mrgerr
	call	display_message
	MOV	CX,[POINTER]
	JMP	SHORT RESTORE_Z
FILEMRG:
	ADD	CX,[POINTER]
	MOV	SI,CX
	dec	si
	LODSB
	CMP	AL,1AH
	JNZ	RESTORE_Z
	dec	cx
RESTORE_Z:
	MOV	DI,CX
	MOV	SI,[ENDTXT]
	INC	SI
	MOV	CX,[LAST_MEM]
	SUB	CX,SI
	inc	cx			; remember ^Z
	REP	MOVSB
	dec	di			; unremember ^Z
	MOV	[ENDTXT],DI
	MOV	BX,[MRG_HANDLE]
	MOV	AH,CLOSE
	INT	21H
	return

PUBLIC INSERT
INSERT:
	CMP	ParamCt,1
	JBE	OKIns
	JMP	ComErr
OKIns:
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H	;Set vector 23H
	MOV	DX,OFFSET DG:ABORTINS
	INT	21H
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	INS
	MOV	BX,[CURRENT]
	CALL	CHKRANGE
INS:
	CALL	FINDLIN
	MOV	BX,DX
	MOV	DX,[LAST_MEM]
	CALL	MOVEFILE
INLP:
	CALL	SETPTS			;Update the pointers into file
	CALL	SHOWNUM
	MOV	DX,OFFSET DG:EDITBUF
	MOV	AH,STD_CON_STRING_INPUT
	INT	21H
	CALL	LF
	MOV	SI,2 + OFFSET DG:EDITBUF
	CMP	BYTE PTR [SI],1AH
	JZ	ENDINS
;-----------------------------------------------------------------------
	call	unquote 		;scan for quote chars if any
;-----------------------------------------------------------------------
	MOV	CL,[SI-1]
	MOV	CH,0
	MOV	DX,DI
	INC	CX
	ADD	DX,CX
	JC	MEMERRJ1
	JZ	MEMERRJ1
	CMP	DX,BP
	JB	MEMOK
MEMERRJ1:
	CALL	END_INS
	JMP	MEMERR
MEMOK:
	REP	MOVSB
	MOV	AL,10
	STOSB
	INC	BX
	JMP	SHORT INLP

ABORTMERGE:
	MOV	DX,OFFSET DG:START
	MOV	AH,SET_DMA
	INT	21H

ABORTINS:
	MOV	AX,CS			;Restore segment registers
	MOV	DS,AX
	MOV	ES,AX
	MOV	AX,CSTACK
	MOV	SS,AX
	MOV	SP,STACK
	STI
	CALL	CRLF
	CALL	ENDINS
	JMP	COMOVER

ENDINS:
	CALL	END_INS
	return

END_INS:
	MOV	BP,[ENDTXT]
	MOV	DI,[POINTER]
	MOV	SI,BP
	INC	SI
	MOV	CX,[LAST_MEM]
	SUB	CX,BP
	REP	MOVSB
	DEC	DI
	MOV	[ENDTXT],DI
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H
	MOV	DX,OFFSET DG:ABORTCOM
	INT	21H
	return


FILLBUF:
	MOV	[PARAM1],-1		;Read in max. no of lines
	MOV	ParamCt,1
	CALL	APPEND
	MOV	Param1,0
PUBLIC ENDED
ENDED:

;Write text out to .$$$ file

	CMP	ParamCt,1
	JZ	ENDED1
CERR:	JMP	ComErr
Ended1:
	CMP	Param1,0
	JNZ	Cerr
	MOV	BYTE PTR [ENDING],1	;Suppress memory errors
	MOV	BX,-1			;Write max. no of lines
	CALL	WRT
	TEST	BYTE PTR [HAVEOF],-1
	JZ	FILLBUF
	MOV	DX,[ENDTXT]
	MOV	CX,1
	MOV	BX,[WRT_HANDLE]
	MOV	AH,WRITE
	INT	21H			;Write end-of-file byte

;Close input file			; MZ 11/30
					; MZ 11/30
	MOV	BX,[RD_HANDLE]		; MZ 11/30
	MOV	AH,CLOSE		; MZ 11/30
	INT	21H			; MZ 11/30

;Close .$$$ file

	MOV	BX,[WRT_HANDLE]
	MOV	AH,CLOSE
	INT	21H

;Rename original file .BAK

	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:BAK
	MOVSW
	MOVSW
	MOVSB
	MOV	DX,OFFSET DG:PATH_NAME
	MOV	DI,OFFSET DG:TEMP_PATH
	MOV	AH,RENAME
	INT	21H
	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:$$$FILE
	MOVSW
	MOVSW
	MOVSB

;Rename .$$$ file to original name

	MOV	DX,OFFSET DG:TEMP_PATH
	MOV	DI,OFFSET DG:PATH_NAME
	MOV	AH,RENAME
	INT	21H
						;      mode
	mov	ah,exit
	xor	al,al
	int	21h

;=========================================================================
; EDLIN_DISP_GET: This routine will give us the attributes of the
;		  current display, which are to be used to restore the screen
;		  back to its original state on exit from EDLIN.  We also
;		  set the screen to a text mode here with an 80 X 25 color
;		  format.
;
;	Inputs	: VIDEO_GET - 0fH (get current video mode)
;		  VIDEO_SET - 00h (set video mode)
;		  VIDEO_TEXT- 03h (80 X 25 color mode)
;
;	Outputs : VIDEO_ORG - Original video attributes on entry to EDLIN
;
;=========================================================================

EDLIN_DISP_GET	proc	near			;an000;video attributes

	push	ax				;an000;save affected regs.
	push	bx				;an000;
	push	cx				;an000;
	push	dx				;an000;
	push	si				;an000;
	push	ds				;an000;

	push	cs				;an000;exchange cs/ds
	pop	ds				;an000;

	mov	ax,440Ch			;an000;generic ioctl
	mov	bx,Std_Out			;an000;Console
	mov	cx,(Display_Attr shl 8) or Get_Display ;an000;get display
	mov	dx,offset dg:Video_Buffer	;an000;buffer for video attr.
	int	21h				;an000;
;	$if	nc				;an000;function returned a
	JC $$IF15
						;      buffer
		mov	si,dx			;an000;get pointer
		mov	ax,word ptr dg:[si].Display_Length_Char  ;an000;get video len.
		dec	ax			;an000;allow room for message
		mov	dg:Disp_Len,al		;an000;put it into var.
		mov	ax,word ptr dg:[si].Display_Width_Char ;an000;get video width
		mov	dg:Disp_Width,al	;an000;put it into var.
;	$else					;an000;function failed use
	JMP SHORT $$EN15
$$IF15:
						;      default values
		mov	al,Def_Disp_Len 	;an000;get default length
		dec	al			;an000;leave room for messages
		mov	dg:Disp_Len,al		;an000;use default length
		mov	dg:Disp_Width,Def_Disp_Width;an000;use default width
;	$endif					;an000;
$$EN15:

	pop	ds				;an000;restore affected regs.
	pop	si				;an000;
	pop	dx				;an000;
	pop	cx				;an000;
	pop	bx				;an000;
	pop	ax				;an000;

	ret					;an000;return to caller

EDLIN_DISP_GET	endp				;an000;end proc.


;=========================================================================
; EXT_OPEN1 : This routine opens a file for read/write access.	If the file
;	      if not present for opening the open will fail and return with a
;	      carry set.
;
;	Inputs : BX - Open mode
;		 CX - File attributes
;		 DX - Open action
;
;	Outputs: CY - If error
;
;	Date	   : 6/10/87
;=========================================================================

EXT_OPEN1	proc	near			;an000;open for R/W

	assume	ds:dg
	push	ds				;an000;save regs
	push	si				;an000;

	mov	ah,ExtOpen			;an000;extended open
	mov	al,0				;an000;reserved by system
	mov	si,offset dg:path_name		;an000;point to PATH_NAME

	int	21h				;an000;invoke function
	pop	si				;an000;restore regs
	pop	ds				;an000;

	ret					;an000;return to caller

EXT_OPEN1	endp				;an000;end proc.

;=========================================================================
; EXT_OPEN2  : This routine will attempt to create a file for read/write
;	       access.	If the files exists the create will fail and return
;	       with the carry set.
;
;	Inputs : BX - Open mode
;		 CX - File attributes
;		 DX - Open action
;
;	Outputs: CY - If error
;
;	Date	   : 6/10/87
;=========================================================================

EXT_OPEN2	proc	near			;an000;create a file

	assume	ds:dg
	push	ds				;an000;save regs
	push	si				;an000;

	mov	ah,ExtOpen			;an000;extended open
	mov	al,0				;an000;reserved by system
	mov	si,offset dg:temp_path		;an000;point to TEMP_PATH

	int	21h				;an000;invoke function

	pop	si				;an000;restore regs
	pop	ds				;an000;

	ret					;an000;return to caller

EXT_OPEN2	endp				;an000;end proc.

;=========================================================================
; EXT_OPEN3  : This routine will attempt to create a file for read
;	       access.	If the files exists the create will fail and return
;	       with the carry set.
;
;	Inputs : BX - Open mode
;		 CX - File attributes
;		 DX - Open action
;
;	Outputs: CY - If error
;
;	Date	   : 6/10/87
;=========================================================================

EXT_OPEN3	proc	near			;an000;create a file

	assume	ds:dg
	push	ds				;an000;save regs
	push	si				;an000;

	mov	ah,ExtOpen			;an000;extended open
	mov	al,0				;an000;reserved by system
	mov	si,offset dg:mrg_path_name	;an000;point to mrg_path_name

	int	21h				;an000;invoke function

	pop	si				;an000;restore regs
	pop	ds				;an000;

	ret					;an000;return to caller

EXT_OPEN3	endp				;an000;end proc.


;=========================================================================
; EDLIN_COMMAND : This routine provides an interface between the new
;		  parser and the existing logic of EDLIN.  We will be
;		  interfacing the parser with three existing variables.
;
;	Inputs : FILESPEC - Filespec entered by the user and passed by
;			    the parser.
;
;		 PARSE_SWITCH_B - Contains the result of the parse for the
;				/B switch.  This is passed by the parser.
;
;	Outputs: PATH_NAME - Filespec
;		 LOADMOD   - Flag for /B switch
;		 FNAME_LEN - Length of filespec
;
;	Date	   : 6/11/87
;=========================================================================

EDLIN_COMMAND		proc	near		;an000;interface parser

	push	ax				;an000;save regs.
	push	cx				;an000;
	push	di				;an000
	push	si				;an000;

	mov	si,offset dg:filespec		;an000;get its offset
	mov	di,offset dg:path_name		;an000;get its offset

	mov	cx,00h				;an000;cx will count filespec
						;      length
	cmp	parse_switch_b,true		;an000;do we have /B switch
;	$if	z				;an000;we have the switch
	JNZ $$IF18
		mov	[LOADMOD],01h		;an000;signal switch found
;	$endif					;an000
$$IF18:

;	$do					;an000;while we have filespec
$$DO20:
		lodsb				;an000;move byte to al
		cmp	al,nul			;an000;see if we are at
						;      the end of the
						;      filespec
;		$leave	e			;an000;exit while loop
		JE $$EN20
		stosb				;an000;move byte to path_name
		inc	cx			;an000;increment the length
						;      of the filespec
;	$enddo					;an000;end do while
	JMP SHORT $$DO20
$$EN20:

	mov	[FNAME_LEN],cx			;an000;save filespec's length

	pop	si				;an000; restore regs
	pop	di				;an000;
	pop	cx				;an000;
	pop	ax				;an000;

	ret					;an000;return to caller

EDLIN_COMMAND		endp			;an000;end proc


;=========================================================================
; Calc_Memory_Avail	: This routine will calculate the memory
;			  available for use by EDLIN.
;
;	Inputs	: ORG_DS - DS of PSP
;
;	Outputs : DX	 - paras available
;=========================================================================

Calc_Memory_Avail	proc	near		;an000; dms;

	push	ds				;save ds for size calc
	push	cx				;an000; dms;
	push	di				;an000; dms;

	mov	ds,cs:[org_ds]
	MOV	CX,DS:[2]
	MOV	DI,CS
	SUB	CX,DI
	mov	dx,cx				;an000; dms;put paras in DX

	pop	di				;an000; dms;
	pop	cx				;an000; dms;
	pop	ds				;an000; dms;

	ret					;an000; dms;

Calc_Memory_Avail	endp			;an000; dms;

;=========================================================================
; EA_Fail_Exit		: This routine tells the user that there was
;			  Insufficient memory and exits EDLIN.
;
;	Inputs	: MemFul_Ptr - "Insufficient memory"
;
;	Outputs : message
;=========================================================================

EA_Fail_Exit		proc	near		;an000; dms;

	mov	dx,offset dg:MemFul_Ptr 	;an000; dms;"Insufficient

	push	cs				;an000; dms;xchange ds/cs
	pop	ds				;an000; dms;
						;	     memory"
	call	Std_Printf			;an000; dms;print message
	mov	ah,exit 			;an000; dms;exit
	xor	al,al				;an000; dms;clear al
	int	21h				;an000; dms;
	ret					;an000; dms;

EA_Fail_Exit		endp			;an000; dms;

CODE	ENDS
	END	EDLIN


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\edlcmd2.asm ===
PAGE 60,132
TITLE Edlcmd2 - PART2 procedures called from EDLIN
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLCMD2.SAL
;
; DESCRIPTIVE NAME: EDLIN ROUTINES
;
; FUNCTION: THIS MODULE PROVIDES ROUTINES NEEDED FOR EDLIN'S EXECUTION.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; EXIT NORMAL: NA
;
; EXIT ERROR : NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: EDLCMD1 - ROUTINES MAY BE CALLED FROM EDLCMD1
;		 EDLMES  - ROUTINES MAY BE CALLED FROM EDLMES
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				    - IMPLEMENT SYSPARSE
;				    - IMPLEMENT MESSAGE RETRIEVER
;				    - IMPLEMENT DBCS ENABLING
;				    - ENHANCED VIDEO SUPPORT
;				    - EXTENDED OPENS
;				    - SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;
;======================= END OF SPECIFICATIONS ===========================

include edlequ.asm
include syscall.inc

CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC WORD
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
DATA	ENDS


DG	GROUP	CODE,CONST,cstack,DATA

CONST	SEGMENT PUBLIC WORD
	extrn	msg_crlf:abs,msg_lf:abs,qmes_ptr:byte,ask_ptr:byte
	extrn	bak:byte,$$$file:byte,delflg:byte,loadmod:byte,txt1:byte
	extrn	txt2:byte,memful_ptr:word

	extrn	Del_Bak_Ptr:byte		;an000;dms;
	extrn	cont_ptr:byte			;an000;dms:6/10/87

CONST	ENDS

DATA	SEGMENT PUBLIC WORD
	extrn	ParamCt:WORD
	extrn	current:word,pointer:word,start:word,endtxt:word
	extrn	wrt_handle:word,editbuf:byte,ext_ptr:word,qflg:byte
	extrn	temp_path:byte,line_num:word,line_flag:byte
	extrn	line_num_buf_ptr:byte,arg_buf:byte,arg_buf_ptr:word
	extrn	olddat:byte,oldlen:word,newlen:word,param1:word,param2:word
	extrn	srchflg:byte,srchmod:byte,comline:word,lstfnd:word,numpos:word
	extrn	lstnum:word,last_mem:word,srchcnt:word,amnt_req:word

	extrn	lc_adj:byte			;an000;dms:6/10/87
	extrn	continue:byte			;an000;dms:6/10/87
	extrn	pg_count:byte			;an000;dms:6/10/87
	extrn	Disp_Len:byte			;an000;dms;
	extrn	Disp_Width:byte 		;an000;dms;
	extrn	lc_flag:byte			;an000;dms:6/10/87

	ifdef	DBCS
	extrn	lbtbl:dword
	endif

DATA	ENDS

CODE SEGMENT PUBLIC

ASSUME	CS:DG,DS:DG,SS:CStack,ES:DG

	public	findlin,shownum,loadbuf,crlf,lf,abortcom,unquote
	public	kill_bl,make_caps,display,dispone,make_cntrl
	public	query,quit,scanln,delbak,scaneof,memerr
	public	fndfirst,fndnext,replace
	ifdef	DBCS
	public	testkanj
	endif
	extrn	std_printf:near,command:near,chkrange:near,ComErr:NEAR
	extrn	Xerror:near
	extrn	display_message:near


FINDLIN:

; Inputs
;	BX = Line number to be located in buffer (0 means last line+1)
; Outputs:
;	DX = Actual line found
;	DI = Pointer to start of line DX
;	Zero set if BX = DX (if specified line found)
; AL,CX destroyed. No other registers affected.

	MOV	DX,[CURRENT]
	MOV	DI,[POINTER]
	CMP	BX,DX			; fast find.  Current = requested
	retz
	JA	FINDIT			; start scanning at current?
	OR	BX,BX			; special case of EOF?
	JZ	FINDIT			; yes
	MOV	DX,1			; set up for scan at beginning
	MOV	DI,OFFSET DG:START
	CMP	BX,DX			; at beginning?
	retz
FINDIT:
	MOV	CX,[ENDTXT]		; count of bytes in buffer
	SUB	CX,DI			; for scan
SCANLN:
	MOV	AL,10			; LF is what we look for.
	OR	AL,AL			; Clear zero flag for JCXZ
FINLIN:
	JCXZ	RET4			; at end? Yes, no skip.
	REPNE	SCASB			; find EOL
	INC	DX			; increment count
	CMP	BX,DX			; find correct line?
	JNZ	FINLIN			; no, try again.
RET4:	return

; Inputs:
;	BX = Line number to be displayed
; Function:
;	Displays line number on terminal in 8-character
;	format, suppressing leading zeros.
; AX, CX, DX destroyed. No other registers affected.

SHOWNUM:
	mov	dx,offset dg:line_num_buf_ptr
	mov	line_num,bx
	MOV	line_flag,"*"
	CMP	BX,[CURRENT]
	JZ	STARLIN
	MOV	line_flag," "
STARLIN:
	call	std_printf
ret5:	return


DISPONE:
	MOV	DI,1

DISPLAY:

; Inputs:
;	BX = Line number
;	SI = Pointer to text buffer
;	DI = No. of lines
; Function:
;	Ouputs specified no. of line to terminal, each
;	with leading line number.
; Outputs:
;	BX = Last line output.
; All registers destroyed.

	MOV	CX,[ENDTXT]
	SUB	CX,SI
	retz				; no lines to display
;=========================================================================
; Initialize screen size and line counts for use by display.
;
;	Date	   : 6/10/87
;=========================================================================

	push	ax				;an000;save affected regs

	mov	al,dg:disp_len			;an000;length of video display
	mov	pg_count,al			;an000;init. screen size ctr.

	pop	ax				;an000;restore affected regs

;=========================================================================

	mov	dx,di				;number of lines to print
;
; CX is the number of bytes in the buffer
; dx is the number of lines to be output
;
DISPLN:
	SaveReg <CX,DX>
	CALL	SHOWNUM
	RestoreReg  <DX,CX>
	mov	di,offset dg:arg_buf
;
; Copy chars until CR/LF or end of line hit
;
OUTLN:
	LODSB
	CMP	DI,254+offset dg:arg_buf ; are we at end of buffer?
	JAE	StoreDone		; Yes, do NOT store
	CMP	AL," "
	JAE	SEND
	CMP	AL,10
	JZ	SEND
	CMP	AL,13
	JZ	SEND
	CMP	AL,9
	JZ	SEND
	MOV	AH,"^"
	OR	AL,40h
	XCHG	AL,AH
	STOSW
	JMP	short StoreDone
SEND:
	stosb
StoreDone:
	CMP	AL,10			; perform copy until LF is seen
	LOOPNZ	OUTLN
;
; Make sure buffer ends with CRLF
;
	cmp	byte ptr [di-1],10
	jz	Terminate
;
; No LF seen.  See if CR
;
	cmp	byte ptr [di-1],CR
	jz	StoreLF
	mov	al,CR
	stosb
StoreLF:
	mov	al,10
	stosb
Terminate:
	mov	byte ptr [di],0

	call	EDLIN_DISP_COUNT		;an000;determine lines printed
						;      DMS:6/10/87
	push	dx
	mov	dx,offset dg:arg_buf_ptr
	call	std_printf
	pop	dx
	JCXZ	ret7
	INC	BX

	call	EDLIN_PG_COUNT			;an000;adjust screen line count
						;      DMS:6/10/87
	cmp	lc_flag,false			;an000;continue DISPLAY?
						;      DMS:6/10/87
	JNZ	DISPLN
	DEC	BX
ret7:	return

FNDFIRST:
	MOV	DI,1+OFFSET DG:TXT1
	mov	byte ptr[olddat],1     ;replace with old value if none new
	CALL	GETTEXT
	OR	AL,AL		;Reset zero flag in case CX is zero
	JCXZ	RET7
	cmp	al,1ah		;terminated with a ^Z ?
	jne	sj8
	mov	byte ptr[olddat],0     ;do not replace with old value
sj8:
	MOV	[OLDLEN],CX
	XOR	CX,CX
	CMP	AL,0DH
	JZ	SETBUF
	CMP	BYTE PTR [SRCHFLG],0
	JZ	NXTBUF
SETBUF:
	DEC	SI
NXTBUF:
	MOV	[COMLINE],SI
	MOV	DI,1+OFFSET DG:TXT2
	CALL	GETTEXT
	CMP	BYTE PTR [SRCHFLG],0
	JNZ	NOTREPL
	CMP	AL,0DH
	JNZ	HAVCHR
	DEC	SI
HAVCHR:
	MOV	[COMLINE],SI
NOTREPL:
	MOV	[NEWLEN],CX
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	CALLER
	cmp	byte ptr[srchmod],0
	jne	sj9
	mov	bx,1	 ;start from line number 1
	jmp	short sj9a
sj9:
	MOV	BX,[CURRENT]
	INC	BX	;Default search and replace to current+1
sj9a:
	CALL	CHKRANGE
CALLER:
	CALL	FINDLIN
	MOV	[LSTFND],DI
	MOV	[NUMPOS],DI
	MOV	[LSTNUM],DX
	MOV	BX,[PARAM2]
	CMP	BX,1
	SBB	BX,-1	;Decrement everything except zero
	CALL	FINDLIN
	MOV	CX,DI
	SUB	CX,[LSTFND]
	OR	AL,-1
	JCXZ	aret
	CMP	CX,[OLDLEN]
	jae	sj10
aret:	return
sj10:
	MOV	[SRCHCNT],CX

FNDNEXT:

; Inputs:
;	[TXT1+1] has string to search for
;	[OLDLEN] has length of the string
;	[LSTFND] has starting position of search in text buffer
;	[LSTNUM] has line number which has [LSTFND]
;	[SRCHCNT] has length to be searched
;	[NUMPOS] has beginning of line which has [LSTFND]
; Outputs:
;	Zero flag set if match found
;	[LSTFND],[LSTNUM],[SRCHCNT] updated for continuing the search
;	[NUMPOS] has beginning of line in which match was made

	MOV	AL,[TXT1+1]
	MOV	CX,[SRCHCNT]
	MOV	DI,[LSTFND]
SCAN:
	OR	DI,DI		;Clear zero flag in case CX=0
	REPNE	SCASB		;look for first byte of string

	retnz			;return if you don't find
ifdef	DBCS
	call	kanji_check	;see if the found byte is on a character boundary
	jnz	scan
endif
	MOV	DX,CX
	MOV	BX,DI		;Save search position
	MOV	CX,[OLDLEN]
	DEC	CX
	MOV	SI,2 + OFFSET DG:TXT1
	CMP	AL,AL		;Set zero flag in case CX=0
	REPE	CMPSB
	MOV	CX,DX
	MOV	DI,BX
	JNZ	SCAN
	MOV	[SRCHCNT],CX
	MOV	CX,DI
	MOV	[LSTFND],DI
	MOV	DI,[NUMPOS]
	SUB	CX,DI
	MOV	AL,10
	MOV	DX,[LSTNUM]
;Determine line number of match
GETLIN:
	INC	DX
	MOV	BX,DI
	REPNE	SCASB
	JZ	GETLIN
	DEC	DX
	MOV	[LSTNUM],DX
	MOV	[NUMPOS],BX
	XOR	AL,AL
	return

ifdef	DBCS

;Kanji_check		idea is to scan backwards to the first
;			character which can't be a kanji or part of one
;			(.lt. DB_SP_LO) then scan forward to see if the
;			current byte is on character boundary
;
;Output 	ZR <==> we're on a character boundary
;		NZ <==> we're not on character boundary i.e. No Match
kanji_check:
	push	ax			;save search character
	push	di
	dec	di			;point to the character we found
	mov	si,di			;start searching bakwards from there
	std
srch_loop:
	lodsb
	cmp	al,DB_SP_LO
	jae	srch_loop
	inc	si			;point to first non-kanji
	cld				;forward search
kan_loop:
	cmp	si,di			;are we at current byte?
	jae	passed_char		;if we are, or are passed it, exit
	call	next_char		;otherwise advance si to next char
	jmp	short kan_loop		;and loop
passed_char:
	pop	di
	pop	ax
	ret

;Next_char		si points to a character boundary
;			advance si to point to the beginning of the next char
;
;
next_char:
	push	ax
	lodsb
	call	testkanj
	jz	not_kanj
	inc	si
not_kanj:
	pop	ax
	ret

;--------------------------------------------------------------------;
; TESTKANJ ~ FIND OUT IS THE BYTE IS A KANJI PREFIX		     ;
;								     ;
; entry:  AL	byte to test					     ;
;								     ;
; exit:   NZ if lead byte ortherwise  ZR			     ;
;								     ;
; modifies:	AX						     ;
;								     ;
;--------------------------------------------------------------------;

testkanj:
	push	ax
	xchg	ah,al		    ;put byte in ah
	push	ds
	push	si
	lds	si,cs:[lbtbl]	       ;get pointer to lead byte table
ktlop:
	lodsb			    ;direction flag should be OK
	or	al,al		    ;are we at the end of table?
	jz	notlead 	    ;brif so
	cmp	al,ah		    ;is START RANGE > CHARACTER?
	ja	notlead 	    ;brif so, not a lead character (carry clear)
	lodsb			    ;get second range byte
	cmp	ah,al		    ;is CHARACTER > END RANGE
	ja	ktlop		    ;brif so, not a lead character (check next range)
	or	al,al		    ;make NZ
notl_exit:
	pop	si
	pop	ds
	pop	ax
	ret
notlead:
	cmp	al,al
	jmp	notl_exit

endif

GETTEXT:

; Inputs:
;	SI points into command line buffer
;	DI points to result buffer
; Function:
;	Moves [SI] to [DI] until ctrl-Z (1AH) or
;	RETURN (0DH) is found. Termination char not moved.
; Outputs:
;	AL = Termination character
;	CX = No of characters moved.
;	SI points one past termination character
;	DI points to next free location

	XOR	CX,CX

GETIT:
	LODSB
;-----------------------------------------------------------------------
	cmp	al,quote_char	;a quote character?
	jne	sj101		;no, skip....
	lodsb			;yes, get quoted character
	call	make_cntrl
	jmp	short sj102
;-----------------------------------------------------------------------
sj101:
	CMP	AL,1AH
	JZ	DEFCHK
sj102:
	CMP	AL,0DH
	JZ	DEFCHK
	STOSB
	INC	CX
	JMP	SHORT GETIT

DEFCHK:
	OR	CX,CX
	JZ	OLDTXT
	PUSH	DI
	SUB	DI,CX
	MOV	BYTE PTR [DI-1],cl
	POP	DI
	return

OLDTXT:
	cmp	byte ptr[olddat],1	;replace with old text?
	je	sj11			;yes...
	mov	byte ptr[di-1],cl	;zero text buffer char count
	return

sj11:
	MOV	CL,BYTE PTR [DI-1]
	ADD	DI,CX
	return

REPLACE:

; Inputs:
;	CX = Length of new text
;	DX = Length of original text
;	SI = Pointer to new text
;	DI = Pointer to old text in buffer
; Function:
;	New text replaces old text in buffer and buffer
;	size is adjusted. CX or DX may be zero.
; CX, SI, DI all destroyed. No other registers affected.

	CMP	CX,DX
	JZ	COPYIN
	PUSH	SI
	PUSH	DI
	PUSH	CX
	MOV	SI,DI
	ADD	SI,DX
	ADD	DI,CX
	MOV	AX,[ENDTXT]
	SUB	AX,DX
	ADD	AX,CX
	CMP	AX,[LAST_MEM]
	JAE	MEMERR
	XCHG	AX,[ENDTXT]
	MOV	CX,AX
	SUB	CX,SI
	CMP	SI,DI
	JA	DOMOV
	ADD	SI,CX
	ADD	DI,CX
	STD
DOMOV:
	INC	CX

	REP	MOVSB
	CLD
	POP	CX
	POP	DI
	POP	SI
COPYIN:
	REP	MOVSB
	return

MEMERR:
	MOV	DX,OFFSET DG:MEMFUL_ptr
	call	std_printf
	JMP	COMMAND


LOADBUF:
	MOV	DI,2 + OFFSET DG:EDITBUF
	MOV	CX,255
	MOV	DX,-1
LOADLP:
	LODSB
	STOSB
	INC	DX
	CMP	AL,13
	LOOPNZ	LOADLP
	MOV	[EDITBUF+1],DL
	retz
TRUNCLP:
	LODSB
	INC	DX
	CMP	AL,13
	JNZ	TRUNCLP
	DEC	DI
	STOSB
	return

SCANEOF:
	cmp	[loadmod],0
	je	sj52

;----- Load till physical end of file

	cmp	cx,word ptr[amnt_req]
	jb	sj51
	xor	al,al
	inc	al		;reset zero flag
	return
sj51:
	jcxz	sj51b
	push	di		;get rid of any ^Z at the end of the file
	add	di,cx
	dec	di		;points to last char
	cmp	byte ptr [di],1ah
	pop	di
	jne	sj51b
	dec	cx
sj51b:
	xor	al,al		;set zero flag
	call	check_end	;check that we have a CRLF pair at the end
	return

;----- Load till first ^Z is found

sj52:
	PUSH	DI
	PUSH	CX
	MOV	AL,1AH
	or	cx,cx
	jz	not_found	;skip with zero flag set
	REPNE	SCASB		;Scan for end of file mark
	jnz	not_found
	LAHF				;Save flags momentarily
	inc	cx			;include the ^Z
	SAHF				;Restore flags
not_found:
	mov	di,cx			;not found at the end
	POP	CX
	LAHF				;Save flags momentarily
	SUB	CX,DI			;Reduce byte count if EOF found
	SAHF				;Restore flags
	POP	DI
	call	check_end		;check that we have a CRLF pair at the end

	return


;-----------------------------------------------------------------------
;	If the end of file was found, then check that the last character
; in the file is a LF. If not put a CRLF pair in.

check_end:
	jnz	not_end 		;end was not reached
	pushf				;save return flag
	push	di			;save pointer to buffer
	add	di,cx			;points to one past end on text
	dec	di			;points to last character
	cmp	di,offset dg:start
	je	check_no
	cmp	byte ptr[di],0ah	;is a LF the last character?
	je	check_done		;yes, exit
check_no:
	mov	byte ptr[di+1],0dh	;no, put a CR
	inc	cx			;one more char in text
	mov	byte ptr[di+2],0ah	;put a LF
	inc	cx			;another character at the end
check_done:
	pop	di
	popf
not_end:
	return

CRLF:
	push	dx
	mov	ax,msg_crlf
	call	display_message
	pop	dx
	return
LF:
	mov	ax,msg_lf
	jmp	display_message

ABORTCOM:
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	MOV	AX,cstack
	MOV	SS,AX
	MOV	SP,STACK
	STI
	CALL	CRLF
	JMP	COMMAND

DELBAK:
	;Delete old backup file (.BAK)

	MOV	BYTE PTR [DELFLG],1
	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:BAK
	MOVSW
	MOVSW
	MOVSB
	MOV	AH,UNLINK
	MOV	DX,OFFSET DG:TEMP_PATH
	INT	21H
;	$if	c					;error ?		;an000; dms;
	JNC $$IF1
		cmp	ax,Access_Denied		;file read only?	;an000; dms;
;		$if	e				;yes			;an000; dms;
		JNE $$IF2
			mov	bx,[Wrt_Handle] 	;close .$$$ file	;an000; dms;
			mov	ah,Close		;close function 	;an000; dms;
			int	21h			;close it		;an000; dms;

			mov	di,[Ext_Ptr]		;point to extension	;an000; dms;
			mov	si,offset dg:$$$File	;point to .$$$ extension;an000; dms;
			movsw				;get .$$$ extension	;an000; dms;
			movsw				;			;an000; dms;
			movsb				;			;an000; dms;
			mov	dx,offset dg:Temp_Path	;point to .$$$ file	;an000; dms;
			mov	ah,Unlink		;delete it		;an000; dms;
			int	21h			;			;an000; dms;

			mov	di,[Ext_Ptr]		;point to extension	;an000; dms;
			mov	si,offset dg:BAK	;point to .BAK extension;an000; dms;
			movsw				;get .BAK extension	;an000; dms;
			movsw				;			;an000; dms;
			movsb				;			;an000; dms;
			mov	dx,offset dg:Del_Bak_Ptr;point to error message ;an000; dms;
			jmp	Xerror			;display message & exit ;an000; dms;
;		$endif
$$IF2:
;	$endif
$$IF1:

	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:$$$FILE
	MOVSW
	MOVSW
	MOVSB
	return


;-----------------------------------------------------------------------;
; Will scan buffer given pointed to by SI and get rid of quote
;characters, compressing the line and adjusting the length at the
;begining of the line.
; Preserves al registers except flags and AX .

unquote:
	push	cx
	push	di
	push	si
	mov	di,si
	mov	cl,[si-1]	;length of buffer
	xor	ch,ch
	mov	al,quote_char
	cld
unq_loop:
	jcxz	unq_done	;no more chars in the buffer, exit
	repnz	scasb		;search for quote character
	jnz	unq_done	;none found, exit
	push	cx		;save chars left in buffer
	push	di		;save pointer to quoted character
	push	ax		;save quote character
	mov	al,byte ptr[di] ;get quoted character
	call	make_cntrl
	mov	byte ptr[di],al
	pop	ax		;restore quote character
	mov	si,di
	dec	di		;points to the quote character
	inc	cx		;include the carriage return also
	rep	movsb		;compact line
	pop	di		;now points to after quoted character
	pop	cx
	jcxz	sj13		;if quote char was last of line do not adjust
	dec	cx		;one less char left in the buffer
sj13:	pop	si
	dec	byte ptr[si-1]	;one less character in total buffer count also
	push	si
	jmp	short unq_loop

unq_done:
	pop	si
	pop	di
	pop	cx
	return


;-----------------------------------------------------------------------;
;	Convert the character in AL to the corresponding control
; character. AL has to be between @ and _ to be converted. That is,
; it has to be a capital letter. All other letters are left unchanged.

make_cntrl:
	push	ax
	and	ax,11100000b
	cmp	ax,01000000b
	pop	ax
	jne	sj14
	and	ax,00011111b
sj14:
	return


;---- Kill spaces in buffer --------------------------------------------;
;=========================================================================
; kill_bl : Parses over spaces in a buffer.
;
;	Date	   : 6/10/86
;=========================================================================
kill_bl:

	push	bx			;an000;save affected reg.
kill_bl_cont:

	lodsb				;get rid of blanks
	    cmp al,9
	    je	kill_bl_cont		;an000;it is a tab

	    cmp al,10
	    je	kill_bl_cont		;an000;if LF

	    cmp al,' '
	    je	kill_bl_cont		;an000;we have a space

	ifdef DBCS			;an000;is this a kanji assembly
	     call testkanj		;an000;do we have a dbcs lead byte
;	     $if  nz			;an000;yes, we have a lead byte
	     JZ $$IF5
		  cmp  al,DB_SP_HI	;an000;is it DB_SP_HI
;		  $if  z		;an000;it is DB_SP_HI
		  JNZ $$IF6
		       mov  bl,ds:[si]	;an000;set up for compare
		       cmp  bl,DB_SP_LO ;an000;is it DB_SP_LO
;		       $if  z		;an000;we have an asian blank
		       JNZ $$IF7
			    lodsb	;an000;skip byte containing 81h
			    jmp kill_bl_cont
;		       $endif		;an000;
$$IF7:
;		  $endif		;an000;fall through no delim
$$IF6:
					;      found
;	     $endif			;an000;end test for dbcs lead byte
$$IF5:
	endif				;an000;end conditional assembly

	pop	bx			;an000;restore affected reg.
	return

;----- Capitalize the character in AL ----------------------------------;
;									;
;   Input:								;
;									;
;	    AL	    contains a character to capitalize			;
;									;
;   Output:								;
;									;
;	    AL	    contains a capitalized character			;
;									;
;-----------------------------------------------------------------------;

MAKE_CAPS:
	CMP	AL,"a"
	JB	CAPS1
	CMP	AL,"z"
ifdef DBCS
	JA	CAPS1		; M003 MSKK TAR 476, kana chars
else
	JG	CAPS1
endif
	AND	AL,0DFH
CAPS1:
	return

QUIT:
	CMP	ParamCt,1
	JZ	Quit1
CERR:	JMP	ComErr
Quit1:	CMP	Param1,0
	JNZ	CERR
	MOV	DX,OFFSET DG:QMES_ptr
	call	std_printf

IFDEF	DBCS
	CALL	TESTKANJ
	JZ	ASCII
	MOV	AX, (STD_CON_INPUT_FLUSH SHL 8) + 0
	INT	21H		; Eat the trailing byte.
	JMP	CRLF
ASCII:
ENDIF
;=========================================================================
; We are invoking the VAL_YN proc here.  This will replace the
; method of Y/N validation used prior to DOS 4.00.
;
;	Date	   : 6/10/87
;=========================================================================

	call	val_yn		;an000;pass Y/N byte in AL to macro
	cmp	ax,yes		;an000;did we return a Y
	jz	NoCRLF		;an000; dms; close the file
	cmp	ax,no		;an000; dms; return N?
;	$if	ne		;an000; dms; neither N or Y - reprompt
	JE $$IF11
		call	crlf			; spit out crlf
		jmp	Quit1			;an000; dms; reprompt
;	$endif			;an000; dms;
$$IF11:
	call	crlf			; spit out CRLF
	return				;an000; dms;

;=========================================================================
; End of Y/N validation check for qmes_ptr
;=========================================================================

NOCRLF:
	MOV	BX,[WRT_HANDLE]
	MOV	AH,CLOSE
	INT	21H
	MOV	DX,OFFSET DG:TEMP_PATH
	MOV	AH,UNLINK
	INT	21H
	mov	ah,exit
	xor	al,al
	INT	21H

QUERY:
	TEST	BYTE PTR [QFLG],-1
	retz
	MOV	DX,OFFSET DG:ASK_ptr
	call	std_printf
	PUSH	AX
	CALL	CRLF
	POP	AX
IFDEF	DBCS
	CALL	TESTKANJ
	JZ	ASCII1
	PUSH	AX
	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
	INT	21H		;Eat the trailing byte
	XOR	AX,AX
	INC	AX		; non zero flag
	POP	AX
	return
ASCII1:
ENDIF
	CMP	AL,13		;Carriage return means yes
	retz
;=========================================================================
; We are invoking the VAL_YN proc here.  This will replace the
; method of Y/N validation used prior to DOS 4.00.
; This invocation of val_yn will return ZR if Y is found, otherwise
; it will return NZ.
;
;	Date	   : 6/10/87
;=========================================================================

	call	val_yn		;an000;pass Y/N byte in AL to macro
	cmp	ax,yes		;an000;did we return a Y
	je	Query_Exit	;an000; dms; exit Y/N validation
	cmp	ax,no		;an000; dms; N response?
	jne	Query		;an000; dms; no - reprompt user
	cmp	ax,yes		;an000; dms; must have N response - force
				;	     NZ flag
Query_Exit:


;=========================================================================
; End of Y/N validation check for ask_ptr
;=========================================================================

	return

;=========================================================================
; EDLIN_DISP_COUNT: This routine will determine the number of lines
;		    actually displayed to the screen.  Lines displayed to
;		    the screen for one EDLIN line printed will be calculated
;		    by the following formula:
;
;		LINES_PRINTED = (LINE_LEN + 10) / SCREEN_WIDTH
;
;		LINES_PRINTED - Actual number of lines printed on screen
;				for one EDLIN line.  If LINES_PRINTED has
;				a remainder, it will be rounded up.
;
;		LINE_LEN      - The length, in bytes, of the EDLIN line
;				printed.
;
;		SCREEN_WIDTH  - The width in bytes of the current display.
;
;	Inputs : DI - offset into buffer containing line printed
;		 DISP_WIDTH  - width of current video output
;
;	Outputs: LC_ADJ - factor to adjust line counter by
;
;	Date	   : 6/10/87
;=========================================================================

EDLIN_DISP_COUNT	proc	near		;an000;lines printed

	push	dx				;an000;save affected regs
	push	di				;an000;
	push	ax				;an000;
	push	bx				;an000;
	push	cx				;an000;

	mov	bx,offset dg:arg_buf		;an000;arg_buf holds line
						;      printed
	mov	ax,di				;an000;where print line ends
	sub	ax,bx				;an000;diff = line's length
	add	ax,10				;an000;adjust for leading blks
	mov	cl,dg:disp_width		;an000;set up for division
	div	cl				;an000;divide AX by the
						;      width of the console
	cmp	ah,0				;an000;see if a remainder
;	$if	nz				;an000;if a remainder
	JZ $$IF13
		add al,1			;an000;increment AL 1
						;      to round upward
;	$endif					;an000;
$$IF13:

	mov	lc_adj,al			;an000;number of lines printed
						;      on console
	pop	cx				;an000;restore affected regs
	pop	bx				;an000;
	pop	ax				;an000;
	pop	di				;an000;
	pop	dx				;an000;

	ret					;an000;return to caller

EDLIN_DISP_COUNT	endp			;an000;end proc

;=========================================================================
; EDLIN_PG_COUNT : This routine determines whether or not we will continue
;		   displaying text lines based on the count of lines that
;		   can be output to the current video screen.
;
;	Inputs : LC_ADJ    - adjustment factor for number of lines printed
;		 PG_COUNT  - number of lines remaining on current video
;			     display
;		 DX	   - holds the total number of lines to print
;		 CONTINUE  - signals if the user wants to continue
;			     printing lines.
;
;	Outputs: LC_FLAG   - used to signal completion of print
;
;	Date	   : 6/10/87
;=========================================================================

EDLIN_PG_COUNT		proc	near		;an000;track remaining lines

	push	ax				;an000;save affected regs

	mov	lc_flag,true			;an000;init. flag to signal
						;      continue printing

	mov	al,pg_count			;an000;set up for page adj.
	cmp	al,lc_adj			;an000;see if we are at end
;	$if	be				;an000
	JNBE $$IF15
		mov	pg_count,0		;an000;set pg_count to 0
;	$else
	JMP SHORT $$EN15
$$IF15:
		sub	al,lc_adj		;an000;adjust number of lines
		mov	pg_count,al		;an000;save remaining line ct.
;	$endif					;an000;
$$EN15:

	dec	dx				;an000;decrease total number
						;      of lines to print by 1
;	$if	nz				;an000;more lines to print
	JZ $$IF18
	    cmp    pg_count,0			;an000;have we printed screen
;	    $if    be				;an000;we have printed screen
	    JNBE $$IF19
		   call    EDLIN_PG_PROMPT	;an000;prompt the user to
						;      "Continue(Y/N)?"
		   cmp	  continue,true 	;an000;did user say continue
;		   $if	  z			;an000;continue
		   JNZ $$IF20
			  mov	al,dg:disp_len	;an000;begin init of screen
;			  dec	al		;an000;    length
			  mov	pg_count,al	;an000;
;		   $else			;an000;do not continue
		   JMP SHORT $$EN20
$$IF20:
			  mov	lc_flag,false	;an000;signal no more to print
;		   $endif			;an000;
$$EN20:
;	    $endif				;an000;
$$IF19:
;	$else					;an000;total lines printed
	JMP SHORT $$EN18
$$IF18:
	    mov    lc_flag,false		;an000;signal no more to print
;	$endif					;an000;
$$EN18:

	pop	ax				;an000;restore affected regs

	ret					;an000;return to caller

EDLIN_PG_COUNT		endp			;an000;end procedure

;=========================================================================
; EDLIN_PG_PROMPT : This routine prompts the user as to whether or not to
;		    continue printing lines to the video display, if lines
;		    are still present for printing.
;
;	Inputs : none
;
;	Outputs: CONTINUE - flag that signals other routines whether or
;			    not to continue printing.
;
;	Date	   : 6/10/87
;=========================================================================

EDLIN_PG_PROMPT 	proc	near		;an000;ask user to continue?

	push	dx				;an000;save affected regs.
	push	ax				;an000;

EPP_Reprompt:

	mov	dx,offset dg:cont_ptr		;an000;point to Continue msg.
	call	std_printf			;an000;invoke message ret.

	push	ax				;an000;save affected regs.
	call	crlf				;an000;send crlf
	pop	ax				;an000;restore affected regs.

	call	val_yn				;an000;Y/N validation

	cmp	ax,yes				;an000;did we have a Y
	jz	EPP_True_Exit			;an000;we had a Y
	cmp	ax,no				;an000;did we have a N
	jz	EPP_False_Exit			;an000;yes
	jmp	EPP_Reprompt			;an000;neither Y or N - reprompt

EPP_True_Exit:

	mov	Continue,True			;an000;flag Y found
	jmp	short EPP_Exit			;an000;exit routine

EPP_False_Exit:

	mov	Continue,False			;an000;flag N found

EPP_Exit:

	pop	ax				;an000;restore affected regs.
	pop	dx				;an000;

	ret					;an000;return to caller

EDLIN_PG_PROMPT 	endp			;an000;end procedure

;=========================================================================
; val_yn: This proc validates a Y/N response entered by the user.  The
;	  routine uses the new functionality of "GET EXTENDED COUNTRY
;	  INFORMATION" being implemented in DOS 4.00.
;
; Inputs : AL - character to be validated for Y/N response
;
; Outputs: AX - 00h = "N"o
;	      - 01h = "Y"es
;=========================================================================

val_yn	proc	near		;an000;validate Y/N response

	push	dx		;an000;save affected registers
	push	cx		;an000;
	push	bx		;an000;

	mov	dl,al		;an000;character to be checked for Y/N
	mov	ah,GetExtCntry	;an000;get extended country information
	mov	al,yn_chk	;an000;perform Y/N checking
	mov	cx,max_len	;an000;max. len. of Y/N char.
	int	21h		;an000;invoke function

	pop	bx		;an000;restore affected registers
	pop	cx		;an000;
	pop	dx		;an000;

	ret			;an000;return to caller

val_yn	endp			;an000;end proc



code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\edlparse.asm ===
page	60,132;
	title	EDLPARSE for EDLIN
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;******************* START OF SPECIFICATIONS *****************************
;
; MODULE NAME: EDLPARSE.SAL
;
; DESCRIPTIVE NAME: PARSES THE EXTERNAL COMMAND LINE FOR EDLIN
;
; FUNCTION: THIS ROUTINE PROVIDES PARSING CAPABILITIES FOR THE
;	    EXTERNAL COMMAND LINE OF EDLIN.  IT PARSES FOR THE PRESENCE
;	    OF A REQUIRED FILESPEC AND AN OPTIONAL SWITCH (/B).
;
; ENTRY POINT: PARSER_COMMAND
;
; INPUT: DOS COMMAND LINE
;
; EXIT NORMAL: AX = 0FFH    - VALID SWITCH AND FILESPEC SPECIFIED
;
; EXIT ERROR:  AX NOT= 0FFH - INVALID SWITCH OR NO FILESPEC SPECIFIED
;
; INTERNAL REFERENCES
;
;	ROUTINE: PARSER_COMMAND - THIS ROUTINE PARSES FOR THE PRESENCE
;				  OF THE /B SWITCH AND A FILESPEC.  THE
;				  FILEPSEC IS REQUIRED, WHILE THE SWITCH
;				  IS OPTIONAL.
;
; EXTERNAL REFERENCES:
;
;     ROUTINE: PARSE.ASM - THIS IS THE PARSER CODE.
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - IMPLEMENTS THE SYSTEM PARSER (SYSPARSE)
;
; COPYRIGHT: "THE IBM PERSONAL COMPUTER EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft"
;
;
;******************** END OF SPECIFICATIONS ******************************


;======================= equates for edlparse ============================

parse_ok	equ	0			;an000;good parse return
parse_command	equ	081h			;an000;offset of command line
nul		equ	0			;an000;nul
fs_flag 	equ	05h			;an000;filespec found
sw_flag 	equ	03h			;an000;switch found
true		equ	0ffffh			;an000;true
false		equ	00h			;an000;false
too_many	equ	01h			;an000;too many parms

;======================= end equates =====================================


CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC BYTE

	extrn	path_name:byte
	extrn	org_ds:word			;an000; dms;

	public	parse_switch_b			;an000;parse switch result
	public	parse_switch_?			;      parse switch result
	public	filespec			;an000;actual filespec

;======================= input parameters control blocks =================
; these control blocks are used by sysparse and must be pointed to by
; es:di on invocation.

		public	parms			;an000;share parms
parms		label	byte			;an000;parms control block
		dw	dg:parmsx		;an000;point to parms structure
		db	00h			;an000;no additional delims.

parmsx		label	byte			;an000;parameter types
		db	1,1			;an000;must have filespec
		dw	dg:fs_pos		;an000;filespec control block
		db	2			;an000;max. number of switches
		dw	dg:sw_b 		;an000;/b switch control block
		dw	dg:sw_? 		;an000;/? switch control block
		db	00h			;an000;no keywords

;======================= filespec positional tables ======================

fs_pos		label	byte			;an000;filespec positional
		dw	0200h			;an000;filespec/not optional
		dw	0001h			;an000;cap
		dw	dg:filespec_res 	;an000;filespec result table
		dw	dg:noval		;an000;value list/none
		db	0			;an000;no keyword/switch syns.

filespec_res	label	byte			;an000;filespec result table
parse_fs_res	db	?			;an000;must be filespec (05)
parse_fs_tag	db	?			;an000;item tag
parse_fs_syn	dw	?			;an000;synonym pointer
parse_fs_off	dw	?			;an000;offset to filespec
parse_fs_seg	dw	?			;an000;segment of filespec

;======================= switch tables /b ================================

sw_b		label	byte			;an000;/b switch
		dw	0000h			;an000;no match flags
		dw	0000h			;an000;no cap
		dw	dg:switch_res		;an000;result buffer
		dw	dg:noval		;an000;value list/none
		db	1			;an000;1 switch
sw_b_switch	db	"/B",0			;an000;/B means ignore CTL-Z

sw_?		label	byte			;an000;/b switch
		dw	0000h			;an000;no match flags
		dw	0000h			;an000;no cap
		dw	dg:switch_res		;an000;result buffer
		dw	dg:noval		;an000;value list/none
		db	1			;an000;1 switch
sw_?_switch	db	"/?",0			;an000;/B means ignore CTL-Z
	PUBLIC sw_?_switch
switch_res	label	byte			;an000;switch result table
parse_sw_res	db	?			;an000;must be string (03)
parse_sw_tag	db	?			;an000;item tag
parse_sw_syn	dw	?			;an000;synonym pointer
parse_sw_ptr	dd	?			;an000;pointer to result

noval		label	byte			;an000;value table
		db	0			;an000;no values


;======================= end input parameter control blocks ==============

filespec	db	128 dup (0)		;an000;holds filespec
parse_switch_b	db	false			;an000;hold boolean result
						;      of /b parse
parse_switch_?	db	false			; true if /? found
parse_sw_b	db	"/B"			;an000;comparison switch

DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

code	segment public	byte			;an000;code segment
	assume cs:dg,ds:dg,es:dg,ss:CStack	;an000;

	public	parser_command			;an000;share this routine



;======================= begin main routine ==============================
.xlist

include version.inc  ; parse.asm include psdata.inc which needs defs from here
include parse.asm				;an000;parser

.list

parser_command	proc	near			;an000;parse routine

	push	es				;an000;save registers
	push	ds				;an000;
	push	di				;an000;
	push	si				;an000;

	mov	dg:parse_switch_b,false 	;an000;init. to false
	xor	cx,cx				;an000;set cx to 0
	xor	dx,dx				;an000;set dx to 0
	mov	di,offset dg:parms		;an000;point to parms
	mov	si,parse_command		;an000;point to ds:81h
	mov	ds,dg:org_ds			;an000;get ds at entry
	assume	ds:nothing			;an000;

parse_continue: 				;an000;loop return point

	call	sysparse			;an000;invoke parser
	cmp	ax,parse_ok			;an000;is it a good parse
	jne	parse_end			;an000;continue on good parse
	push	si
	mov	si,dx
	cmp	byte ptr es:[si],fs_flag	;an000;do we have a filespec
;	$if	e				;an000;yes we do
	JNE $$IF1
		call build_fs			;an000;save filespec
;	$else					;an000;
	JMP SHORT $$EN1
$$IF1:
	; A switch was found.
	; See which one it was.

	  call	val_sw				;an000;see which switch

;	$endif					;an000;
$$EN1:

	pop	si
	jmp	parse_continue			;an000;continue parsing

parse_end:					;an000;end parse routine

	pop	si				;an000;restore registers
	pop	di				;an000; for return to caller
	pop	ds				;an000;
	assume	ds:dg				;an000;
	pop	es				;an000;

	ret					;an000;return to caller

parser_command	endp				;an000;end parser_command


;======================= subroutine area =================================


;=========================================================================
; build_fs: This routine saves the filespec for use by the calling program.
;=========================================================================

build_fs	proc	near			;an000;save filespec

	push	ax				;an000;save affected regs.
	push	di				;an000;
	push	si				;an000;
	push	ds				;an000;
	push	es				;an000;

	mov	di,offset dg:filespec		;an000;point to filespec buffer
	lds	si,dword ptr es:parse_fs_off	;an000;get offset

build_cont:					;an000;continue routine

	lodsb					;an000;mov ds:si to al
	cmp	al,nul				;an000;is it end of filespec
;	$if	nz				;an000;if not
	JZ $$IF7
		stosb				;an000;move byte to filespec
		jmp build_cont			;an000;continue buffer fill
;	$endif					;an000;
$$IF7:
	stosb					;an000;save nul

	pop	es				;an000;restore regs
	pop	ds				;an000;
	pop	si				;an000;
	pop	di				;an000;
	pop	ax				;an000;

	ret					;an000;return to caller

build_fs	endp				;an000;end proc

;=========================================================================
; val_sw : determines which switch we have.
;=========================================================================

val_sw		proc	near			;an000;switch determination

	; Check for /B

	cmp	es:[parse_sw_syn], offset es:sw_b_switch
	jne	ValSwitchBDone
	cmp	es:[parse_switch_b], true	; see if already given
	jne	ValSwitchBOkay			; jump if not
	mov	ax, too_many			; set error level
	jmp	parse_end			;  and exit parser
ValSwitchBOkay:
	mov	es:[parse_switch_b], true	; set the flag on
	jmp	short ValSwitchExit		;  and done
ValSwitchBDone:

	; Check for /?

	cmp	es:[parse_sw_syn], offset es:sw_?_switch
	jne	ValSwitch?Done
	mov	es:[parse_switch_?], true	; set the flag on
	jmp	short ValSwitchExit		;  and done
ValSwitch?Done:

ValSwitchExit:

	ret					;an000;return to caller

val_sw		endp				;an000;end proc


code	ends					;an000;end segment
	end					;an000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\edlcmd1.asm ===
PAGE 60,132;
	TITLE EDLCMD1.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLCMD1.SAL
;
; DESCRIPTIVE NAME: EDLIN ROUTINES
;
; FUNCTION: THIS MODULE PROVIDES ROUTINES NEEDED FOR EDLIN'S EXECUTION.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; EXIT NORMAL: NA
;
; EXIT ERROR : NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: EDLCMD2 - ROUTINES MAY BE CALLED FROM EDLCMD2
;		 EDLMES  - ROUTINES MAY BE CALLED FROM EDLMES
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;					- IMPLEMENT SYSPARSE
;					- IMPLEMENT MESSAGE RETRIEVER
;					- IMPLEMENT DBCS ENABLING
;					- ENHANCED VIDEO SUPPORT
;					- EXTENDED OPENS
;					- SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;
;======================= END OF SPECIFICATIONS ===========================

include syscall.inc
include edlequ.asm

SUBTTL	Contants and Data areas
PAGE


CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC WORD
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

CONST	SEGMENT PUBLIC WORD
	EXTRN	DSKFUL:abs,READ_ERR_PTR:word
	EXTRN	NOSUCH:abs,TOOLNG:abs,EOF:abs
	extrn	txt1:byte,txt2:byte
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
	extrn	ParamCt:WORD
	extrn	current:word,pointer:word,start:word,endtxt:word
	extrn	wrt_handle:word,editbuf:byte,path_name:byte,fname_len:word
	extrn	arg_buf:byte,arg_buf_ptr:word
	extrn	olddat:byte,oldlen:word,newlen:word,param1:word,param2:word
	extrn	srchflg:byte,srchmod:byte,comline:word,lstfnd:word,numpos:word
	extrn	lstnum:word,srchcnt:word,amnt_req:word,delflg:byte,lastlin:word
	extrn	three4th:word,one4th:word,last_mem:word,rd_handle:word,ending:byte
	extrn	haveof:byte
	extrn	Disp_Len:Byte

DATA	ENDS

CODE SEGMENT PUBLIC
ASSUME	CS:DG,DS:DG,SS:CStack,ES:DG

	extrn	findlin:near,shownum:near,loadbuf:near
	extrn	delbak:near,unquote:near,lf:near
	extrn	dispone:near,display:near,query:near
	extrn	quit:near,scanln:near,scaneof:near
	extrn	fndfirst:near,fndnext:near,replace:near,memerr:near
	extrn	std_printf:near,chkrange:near,comerr:near
	extrn	display_message:near

	public	zerror
	public	xerror,bad_read,append,nocom,pager,list
	public	delete,replac_from_curr,search_from_curr,ewrite,wrt

NOMOREJ:JMP	NOMORE

APPEND:
	CMP	ParamCt,1
	JZ	AppendOK
	JMP	ComErr
AppendOK:
	TEST	BYTE PTR [HAVEOF],-1
	JNZ	NOMOREJ
	MOV	DX,[ENDTXT]
	CMP	[PARAM1],0	;See if parameter is missing
	JNZ	PARMAPP
	CMP	DX,[THREE4TH]	;See if already 3/4ths full
	jb	parmapp
	return			;If so, then done already
PARMAPP:
	MOV	DI,DX
	MOV	CX,[LAST_MEM]
	SUB	CX,DX		;Amount of memory available
	jnz	sj53
	jmp	memerr
sj53:
	MOV	DX,[ENDTXT]
	MOV	BX,[RD_HANDLE]
	mov	[amnt_req],cx	;Save number of chars requested
	MOV	AH,READ
	INT	21H		;Fill memory with file data
	CMP	CX,AX		;Did we read less than we asked for?
	JZ	SJ55
; Make sure this is an end-of-file by trying to read more
	PUSH	AX		;Save old byte count
	ADD	DX,AX		;Point to next open space in buffer
	MOV	CX,1		;Just one character past EOF
	MOV	AH,READ
	INT	21H
	CMP	AX,0		      ;Is it EOF?
	POP	AX
	JNZ	SJ54		      ;No -- we have one more character
	MOV	BYTE PTR [HAVEOF],1   ;Yes - set old style system call flag
	JMP	SHORT SJ55
SJ54:
	INC	AX		      ;Include one more char in byte count
sj55:
	MOV	CX,AX		      ;Want byte count in CX
	PUSH	CX		      ;Save actual byte count
	CALL	SCANEOF
	JNZ	NOTEND
	MOV	BYTE PTR [HAVEOF],1	;Set flag if 1AH found in file
NOTEND:
	XOR	DX,DX
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	COUNTLN
	MOV	AX,DI
	ADD	AX,CX		;First byte after loaded text
	CMP	AX,[THREE4TH]	;See if we made 3/4 full
	JBE	COUNTLN
	MOV	DI,[THREE4TH]
	MOV	CX,AX
	SUB	CX,DI		;Length remaining over 3/4
	MOV	BX,1		;Look for one more line
COUNTLN:
	CALL	SCANLN		;Look for BX lines
	CMP	[DI-1],AL	;Check for full line
	JZ	FULLN
	CMP	HavEof,1
	JNZ	DoBackScan
;
; We have an incomplete line in the buffer at end of file.  Fix it up to be
; pretty.
;
	MOV	BYTE PTR [DI],13	; CR
	MOV	BYTE PTR [DI+1],10	; LF
	ADD	DI,2			; length is 2 greater
	POP	CX
	ADD	CX,2
	PUSH	CX
	JMP	SHORT FULLN

DoBackScan:
	DEC	DI
	MOV	CX,[LAST_MEM]
	STD
	REPNE	SCASB			;Scan backwards for last line
	CLD
	INC	DI
	INC	DI
	DEC	DX
FULLN:
	POP	CX				    ;Actual amount read
	MOV	WORD PTR [DI],1AH		    ;Place EOF after last line
	SUB	CX,DI
	XCHG	DI,[ENDTXT]
	ADD	DI,CX				    ;Amount of file read but not used
; Must seek for old partial line
	OR	DI,DI
	JZ	FULLN1
	PUSH	DX
	PUSH	BX
	MOV	BX,[RD_HANDLE]
	MOV	DX,DI
	NEG	DX
	MOV	CX,-1
	MOV	AL,1
	MOV	AH,LSEEK
	INT	21H
	POP	BX
	POP	DX
	JC	BAD_READ
FULLN1:
	CMP	BX,DX
	JNZ	EOFCHK
	MOV	BYTE PTR [HAVEOF],0
	return
NOMORE:
	mov	ax,EOF
	call	display_message
ret3:	return

BAD_READ:
	MOV	DX,OFFSET DG:READ_ERR_ptr
	MOV	DI,offset dg:path_name
	ADD	DI,[FNAME_LEN]
	MOV	AL,0
	STOSB
	JMP	XERROR

EOFCHK:
	TEST	BYTE PTR [HAVEOF],-1
	JNZ	NOMORE
	TEST	BYTE PTR [ENDING],-1
	retnz			;Suppress memory error during End
	JMP	MEMERR

EWRITE:
	CMP	ParamCt,1
	JBE	EWriteOK
	JMP	ComErr
EWriteOK:
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	WRT
	MOV	CX,[ONE4TH]
	MOV	DI,[ENDTXT]
	SUB	DI,CX		;Write everything in front of here
	JBE	RET3
	CMP	DI,OFFSET DG:START	;See if there's anything to write
	JBE	RET3
	XOR	DX,DX
	MOV	BX,1		;Look for one more line
	CALL	SCANLN
	JMP	SHORT WRTADD
WRT:
	INC	BX
	CALL	FINDLIN
WRTADD:
	CMP	BYTE PTR [DELFLG],0
	JNZ	WRTADD1
	PUSH	DI
	CALL	DELBAK			;Want to delete the .BAK file
					;as soon as the first write occurs
	POP	DI
WRTADD1:
	MOV	CX,DI
	MOV	DX,OFFSET DG:START
	SUB	CX,DX			;Amount to write
	retz
	MOV	BX,[WRT_HANDLE]
	MOV	AH,WRITE
	INT	21H
	JC	WRTERR
	CMP	AX,CX			; MZ correct full disk detection
	JNZ	WRTERR			; MZ correct full disk detection
	MOV	SI,DI
	MOV	DI,OFFSET DG:START
	MOV	[POINTER],DI
	MOV	CX,[ENDTXT]
	SUB	CX,SI
	INC	CX			;Amount of text remaining
	CLD
	REP	MOVSB
	DEC	DI			;Point to EOF
	MOV	[ENDTXT],DI
	MOV	[CURRENT],1
	return

WRTERR:
	MOV	BX,[WRT_HANDLE]
	MOV	AH,CLOSE
	INT	21H
	mov	ax,DSKFUL
zerror:
	push	cs
	pop	ds
	call	display_message
xerror1111:
	mov	al,0ffh
	mov	ah,exit
	int	21h

xERROR:
	push	cs
	pop	ds
	call	std_printf
	jmp	xerror1111

NOTFNDJ:JMP	NOTFND

replac_from_curr:
	CMP	ParamCt,2
	JBE	Replace1
	JMP	ComErr
Replace1:
	mov	byte ptr [srchmod],1   ;search from curr+1 line
	jmp	short sj6

REPLAC:
	mov	byte ptr [srchmod],0   ;search from beg of buffer
sj6:
	MOV	BYTE PTR [SRCHFLG],0
	CALL	FNDFIRST
	JNZ	NOTFNDJ
REPLP:
	MOV	SI,[NUMPOS]
	CALL	LOADBUF 	;Count length of line
	SUB	DX,[OLDLEN]
	MOV	CX,[NEWLEN]
	ADD	DX,CX		;Length of new line
	CMP	DX,254
;	jbe	len_ok
;	Jmp	TOOLONG
	ja	toolong
len_ok:
	MOV	BX,[LSTNUM]
	PUSH	DX
	CALL	SHOWNUM
	POP	DX
	MOV	CX,[LSTFND]
	MOV	SI,[NUMPOS]
	SUB	CX,SI		;Get no. of char on line before change
	DEC	CX
	mov	di,offset dg:arg_buf	;Initialize the output string buffer
	CALL	OUTCNT		;Output first part of line
	PUSH	SI
	MOV	SI,1+ OFFSET DG:TXT2
	MOV	CX,[NEWLEN]
	CALL	OUTCNT		;Output change
	POP	SI
	ADD	SI,[OLDLEN]	;Skip over old stuff in line
	MOV	CX,DX		;DX=no. of char left in line
	ADD	CX,2		;Include CR/LF
	CALL	OUTCNT		;Output last part of line
	xor	al,al
	stosb
	mov	dx,offset dg:arg_buf_ptr
	call	std_printf
	CALL	QUERY		;Check if change OK
	JNZ	REPNXT
	CALL	PUTCURS
	MOV	DI,[LSTFND]
	DEC	DI
	MOV	SI,1+ OFFSET DG:TXT2
	MOV	DX,[OLDLEN]
	MOV	CX,[NEWLEN]
	DEC	CX
	ADD	[LSTFND],CX	;Bump pointer beyond new text
	INC	CX
	DEC	DX
	SUB	[SRCHCNT],DX	;Old text will not be searched
	JAE	SOMELEFT
	MOV	[SRCHCNT],0
SOMELEFT:
	INC	DX
	CALL	REPLACE
REPNXT:
	CALL	FNDNEXT
	retnz
	JMP	REPLP

OUTCNT:
	JCXZ	RET8
OUTLP:
	LODSB
	stosb
	DEC	DX
	LOOP	OUTLP
RET8:	return

TOOLONG:
	mov	ax,TOOLNG
	JMP	SHORT PERR

search_from_curr:
	CMP	ParamCt,2
	JBE	Search1
	JMP	ComErr
Search1:
	mov	byte ptr [srchmod],1   ;search from curr+1 line
	jmp	short sj7

SEARCH:
	mov	byte ptr [srchmod],0   ;search from beg of buffer
sj7:
	MOV	BYTE PTR [SRCHFLG],1
	CALL	FNDFIRST
	JNZ	NOTFND
SRCH:
	MOV	BX,[LSTNUM]
	MOV	SI,[NUMPOS]
	CALL	DISPONE
	MOV	DI,[LSTFND]
	MOV	CX,[SRCHCNT]
	MOV	AL,10
	CLD
	REPNE	SCASB
	JNZ	NOTFND
	MOV	[LSTFND],DI
	MOV	[NUMPOS],DI
	MOV	[SRCHCNT],CX
	INC	[LSTNUM]
	CALL	QUERY
	JZ	PUTCURS1
	CALL	FNDNEXT
	JZ	SRCH
NOTFND:
	mov	ax,NOSUCH
PERR:
	jmp	display_message

;
; Replace enters here with LSTNUM pointing to the correct line.
;
PUTCURS:
	MOV	BX,[LSTNUM]
	jmp	short putcursor
;
; Search enters here with LSTNUM pointing AFTER the correct line
;
putcurs1:
	MOV	BX,[LSTNUM]
	DEC	BX			;Current <= Last matched line

putcursor:
	CALL	FINDLIN
	MOV	[CURRENT],DX
	MOV	[POINTER],DI
	return

;
; n,mD	    deletes a range of lines.  Allowable values for n are:
;   1 ... LAST_MEM.  Allowable values for m are:
;   1 ... LAST_MEM.
; nD	    deletes a single line
; D	    deletes the current line
;
DELETE:
	CMP	ParamCt,2		; at most two parameters specified.
	JA	ComErrJ
	MOV	BX,Param1
	OR	BX,BX			; default first arg?
	JNZ	DelParm2
	MOV	BX,Current		; use current as default
	MOV	Param1,BX
DelParm2:
	MOV	BX,Param2		; did we default second arg?
	OR	BX,BX
	JNZ	DelCheck		; no, use it.
	MOV	BX,Param1		; use param1 as default
	MOV	Param2,BX
DelCheck:
	MOV	BX,Param1
	CALL	ChkRange		; returns by itself if bad range
;
; BX is first line of range to be deleted. Param2 is last line in range to
; be deleted.  Get pointer to beginning of block.  Save location
;
	CALL	FINDLIN 		; Grab line
	retnz				; If not found => return
	PUSH	BX
	PUSH	DI
;
; Get pointer past end of block (Param2+1).
;
	MOV	BX,Param2
	INC	BX
	CALL	FINDLIN
;
; Set up pointers.  Compute number of chars to move.
;
	MOV	SI,DI			; move from second line+1
	POP	DI			; restore destination (first line)
	POP	Current 		; Current line is first param
	MOV	Pointer,DI		; internal current line
	MOV	CX,EndTxt		; compute count
	SUB	CX,SI
	JB	ComErrJ 		; should never occur: ChkRange
	INC	CX			; remember ^Z at end
	CLD
	REP	MOVSB			; move data
	DEC	DI
	MOV	EndTxt,DI		; reset end pointer
	return

COMERRJ:
	JMP	COMERR

PAGER:
	CMP	ParamCt,2
	JA	ComErrJ
	xor	bx,bx		;get last line in the buffer
	call	findlin
	mov	[lastlin],dx

	mov	bx,[param1]
	or	bx,bx		;was it specified?
	jnz	frstok		;yes, use it
	mov	bx,[current]
	cmp	bx,1		;if current line =1 start from there
	je	frstok
	inc	bx		;start from current+1 line
frstok:
	cmp	bx,[lastlin]	;check that we are in the buffer
	jbe	frstok1
	return			;if not just quit
frstok1:
	mov	dx,[param2]
	or	dx,dx		;was param2 specified?
	jnz	scndok		;yes,....
	mov	dx,bx		;no, take the end line to be the
				;    start line + length of active display

;=========================================================================
; This modification is to provide support for screens larger than
; 24 lines.
;
;	Date	   : 6/10/87
;=========================================================================

	push	ax		;an000;save affected registers

	mov	ah,00h		;an000;zero out high byte
	mov	al,dg:disp_len	;an000;set ax to active display length
	sub	ax,2		;an000;adjust for length of screen & current
				;      line
	add	dx,ax		;an000;this gives us the last line to be
				;      printed
	pop	ax		;an000;restore affected registers

;=========================================================================

scndok:
	inc	dx
	cmp	dx,[lastlin]	;check that we are in the buffer
	jbe	infile
	mov	dx,[lastlin]	;we are not, take the last line as end
infile:
	cmp	dx,bx		;is param1 < param2 ?
	retz
	ja	sj33
	jmp	comerr		;yes, no backwards listing, print error
sj33:
	push	dx		;save the end line
	push	bx		;save start line
	mov	bx,dx		;set the current line
	dec	bx
	call	findlin
	mov	[pointer],di
	mov	[current],dx
	pop	bx		;restore start line
	call	findlin 	;get pointer to start line
	mov	si,di		;save pointer
	pop	di		;get end line
	sub	di,bx		;number of lines
	jmp	short display_lines


LIST:
	CMP	ParamCt,2
	JBE	ListOK
	JMP	ComERR
ListOK:
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	CHKP2
	MOV	BX,[CURRENT]
	SUB	BX,11
	JA	CHKP2
	MOV	BX,1
CHKP2:
	CALL	FINDLIN
	retnz
	MOV	SI,DI
	MOV	DI,[PARAM2]
	INC	DI
	SUB	DI,BX
	JA	DISPLAY_lines

;=========================================================================
; This modification is to provide support for screens larger than
; 24 lines.
;
;	Date	   : 6/10/87
;=========================================================================

	push	ax			;an000;save affected registers

	mov	ah,00h			;an000;zero out high byte
	mov	al,dg:disp_len		;an000;set ax to active display length	       dec     ax		       ;an000;allow room at bottom for
					;      messages
	mov	di,ax			;an000;number of lines to print an
					;      entire screen less 1.
	pop	ax			;an000;restore affected registers

;=========================================================================

display_lines:
	call	DISPLAY
	return

Break <NOCOM - edit a single line>

;
; NOCOM is called when there is a single line being edited.  This occurs when
; the command letter is CR or is ;.
;
NOCOM:
	CMP	ParamCt,2
	JB	NoComOK
	JMP	ComErr
NoComOK:
	DEC	[COMLINE]
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	HAVLIN
	MOV	BX,[CURRENT]
	INC	BX	;Default is current line plus one
	CALL	CHKRANGE
HAVLIN:
	CALL	FINDLIN
	MOV	SI,DI
	MOV	[CURRENT],DX
	MOV	[POINTER],SI
	jz	sj12
ret12:	return
sj12:
	CMP	SI,[ENDTXT]
	retz
	CALL	LOADBUF
	MOV	[OLDLEN],DX
	MOV	SI,[POINTER]
	CALL	DISPONE
	CALL	SHOWNUM
	MOV	AH,STD_CON_STRING_INPUT 	  ;Get input buffer
	MOV	DX,OFFSET DG:EDITBUF
	INT	21H
	CALL	lf
	MOV	CL,[EDITBUF+1]
	MOV	CH,0
	JCXZ	RET12
	MOV	DX,[OLDLEN]
	MOV	SI,2 + OFFSET DG:EDITBUF
;-----------------------------------------------------------------------
	call	unquote 		;scan for quote chars if any
;-----------------------------------------------------------------------
	mov	cl,[EditBuf+1]		;an000; dms;get new line length
	mov	ch,0			;an000; dms;clear high byte
	MOV	DI,[POINTER]
	JMP	Replace 		; MZ 11/30

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\edlmes.asm ===
PAGE	60,132;
	title	EDLIN Messages
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLMES.SAL
;
; DESCRIPTIVE NAME: MESSAGE RETRIEVER INTERFACE MODULE
;
; FUNCTION: THIS MODULE PROVIDES AN INTERFACE FOR THE MODULES THAT ARE
;	    NEEDED TO INVOKE THE MESSAGE RETRIEVER.
;
; ENTRY POINT: PRINTF
;
; INPUT: OFFSET CARRIED IN DX TO APPLICABLE MESSAGE TABLE
;
; EXIT NORMAL: NO CARRY
;
; EXIT ERROR : CARRY
;
; INTERNAL REFERENCES:
;
;	ROUTINE: PRINTF - PROVIDES THE ORIGINAL INTERFACE FOR THE ORIGINAL
;			  PRINTF USED PRIOR TO VERSION 4.00.  PRINTS MESSAGES.
;
;		 DISP_MESSAGE - BUILDS THE REGISTERS NECESSARY FOR INVOCATION
;			  OF THE MESSAGE RETRIEVER, BASED ON THE TABLE
;			  POINTED TO BY DX.
;
;		 DISP_FATAL - INVOKED IF AN ERROR OCCURS (CARRY) IN THE
;			  MESSAGE RETRIEVER.  IT DISPLAYS THE APPROPRIATE
;			  MESSAGE.
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: SYSLOADMSG - LOAD MESSAGES FOR THE MESSAGE RETRIEVER
;		 SYSDISPMSG - DISPLAYS THE REQUESTED MESSAGE
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.00 - IMPLEMENTATION OF MESSAGE RETRIEVER
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
; MICROSOFT REVISION HISTORY
;
;	 MODIFIED BY: AARON R
;		      M.A. U
;		      N. P
;======================= END OF SPECIFICATIONS ===========================

.xlist

include sysmsg.inc				;an000;message retriever

msg_utilname <EDLIN>				;an000;EDLIN messages
.list
;-----------------------------------------------------------------------;
;									;
;	Done for Vers 2.00 (rev 9) by Aaron R				;
;	Update for rev. 11 by M.A. U					;
;	Printf for 2.5 by Nancy P					;
;									;
;-----------------------------------------------------------------------;

;=========================================================================
; revised edlmes.asm
;=========================================================================

fatal_error	equ	30			;an000;fatal message handler
unlim_width	equ	00h			;an000;unlimited output width
pad_blank	equ	20h			;an000;blank pad
pre_load	equ	00h			;an000;normal pre-load




message_table	struc				;an000;struc for message table

	entry1	dw	0			;an000;message number
	entry2	db	0			;an000;message type
	entry3	dw	0			;an000;display handle
	entry4	dw	0			;an000;pointer to sublist
	entry5	dw	0			;an000;substitution count
	entry6	db	0			;an000;use keyb input?
	entry7	dw	0			;an000;keyb buffer to use

message_table	ends				;an000;end struc

;=========================================================================
; macro disp_message: this macro takes a pointer to a message table
;		      and displays the applicable message based on
;		      the table's contents.
;		      this is to provide an interface into the module
;		      of the message retriever, SYSDISPMSG.
;
;	Date	  : 6/11/87
;=========================================================================

disp_message	macro	tbl			;an000;display message macro

	push	bx				;an000;
	push	cx				;an000;
	push	dx				;an000;
	push	di				;an000;
	push	si				;an000;

	push	tbl				;an000;exchange tbl with si
	pop	si				;an000;exchanged

	mov	ax,[si].entry1			;an000;move message number
	mov	bx,[si].entry3			;an000;display handle
	mov	cx,[si].entry5			;an000;number of subs
	mov	dl,[si].entry6			;an000;function type
	mov	di,[si].entry7			;an000;input buffer if appl.
	mov	dh,[si].entry2			;an000;message type
	mov	si,[si].entry4			;an000;sublist

	call	sysdispmsg			;an000;display the message

	pop	si				;an000;restore affected regs
	pop	di				;an000;
	pop	dx				;an000;
	pop	cx				;an000;
	pop	bx				;an000;

endm						;an000;end macro disp_message

;=========================================================================
; macro disp_message: end macro
;=========================================================================

CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC BYTE

	extrn	path_name:byte

DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

code	segment public	byte			;an000;code segment
	assume cs:dg,ds:dg,es:dg,ss:CStack	;an000;

	public	printf				;an000;share printf
	public	disp_fatal			;an000;fatal error display
	public	pre_load_message		;an000;message loader

.xlist
msg_services <MSGDATA>				;an000;
.list

;======================= sysmsg.inc invocation ===========================
;
;	include sysmsg.inc - message retriever services
;
;
; options selected:
;		    NEARmsg
;		    DISPLAYmsg
;		    LOADmsg
;		    CHARmsg
;		    NUMmsg
;		    CLSAmsg
;		    CLSBmsg
;		    CLSCmsg
;
;=========================================================================

.xlist

 msg_services <LOADmsg> 			;an000;no version check
 msg_services <DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg>  ;an000;display messages
 msg_services <EDLIN.CLA,EDLIN.CLB,EDLIN.CLC>	;an000;message types
 msg_services <EDLIN.CL1,EDLIN.CL2>		;an000;message types
 msg_services <EDLIN.CTL>			;an000;

.list

;=========================================================================
; printf: printf is a replacement of the printf procedure used in DOS
;	  releases prior to 4.00.  printf invokes the macro disp_message
;	  to display a message through the new message handler.  the
;	  interface into printf will continue to be a pointer to a message
;	  passed in DX.  the pointer is pointing to more than a message
;	  now.	it is pointing to a table for that message containing
;	  all relevant information for printing the message.  the macro
;	  disp_message operates on these tables.
;
;	Date	  : 6/11/87
;=========================================================================

printf	proc	near				;an000;printf procedure

	disp_message	dx			;an000;display a message
;	$if	c				;an000;if an error occurred
	JNC $$IF1
		call	disp_fatal		;an000;display the fatal error
;	$endif					;an000;
$$IF1:

	ret					;an000;return to caller

printf	endp					;an000;end printf proc


;=========================================================================
; disp_fatal: this routine displays a fatal error message in the event
;	      an error occurred in disp_message.
;
;	Date	  : 6/11/87
;=========================================================================

disp_fatal proc near				;an000;fatal error message

	mov	ax,fatal_error			;an000;fatal_error number
	mov	bx,stdout			;an000;print to console
	mov	cx,0				;an000;no parameters
	mov	dl,no_input			;an000;no keyboard input
	mov	dh,UTILITY_MSG_CLASS		   ;an000;utility messages

	call	sysdispmsg			;an000;display fatal error

	ret					;an000;return to caller

disp_fatal endp 				;an000;end disp_fatal proc

;=========================================================================
; PRE_LOAD_MESSAGE : This routine provides access to the messages required
;		     by EDLIN.	This routine will report if the load was
;		     successful.  An unsuccessful load will cause EDLIN
;		     to terminate with an appropriate error message.
;
;	Date	  : 6/11/87
;=========================================================================

PRE_LOAD_MESSAGE	proc	near		;an000;pre-load messages


	call	SYSLOADMSG			;an000;invoke loader

;	$if	c				;an000;if an error
	JNC $$IF3
		pushf				;an000;save flags
		call	SYSDISPMSG		;an000;let him say why
		popf				;an000;restore flags
;	$endif					;an000;
$$IF3:

	ret					;an000;return to caller

PRE_LOAD_MESSAGE	endp			;an000;end proc

include msgdcl.inc

code	ends					;an000;end code segment




CONST	SEGMENT PUBLIC BYTE

	extrn	arg_buf:byte			;an000;
	extrn	line_num:byte			;an000;
	extrn	line_flag:byte			;an000;
	extrn	Temp_Path:byte			;an000;

	public	baddrv,opt_err_ptr,nobak
	public	simple_msg
	public	msg_too_many,dskful,memful_ptr,badcom
	public	nodir,filenm_ptr,newfil,read_err_ptr
	public	nosuch,toolng,eof,dest
	public	mrgerr,ro_err,bcreat,ndname
	public	dsp_options,dsp_help,num_help_msgs
	public	ask_ptr,qmes_ptr,msg_crlf,msg_lf
	public	prompt
	public	line_num_buf_ptr		;an000;DMS:6/15/87
	public	arg_buf_ptr			;an000;DMS:6/15/87
	public	cont_ptr			;an000;DMS:6/18/87
	public	cp_err				;an000;DMS:6/22/87
	public	Del_Bak_Ptr			;an000;dms;

;============== REPLACEABLE PARAMETER SUBLIST STRUCTURE ==================
;
;	byte 1	-	substitution list size, always 11
;	byte 2	-	reserved for use by message handler
;	byte 3	-	pointer to parameter to be used as a substitution
;	byte 7	-	which parameter is this to replace, %1, %2, etc.
;	byte 8	-	determines how the parameter is to be output
;	byte 9	-	determines the maximum width of the parameter string
;	byte 10 -	determines the minimum width of the parameter string
;	byte 11 -	define what is to be used as a pad character
;
;=========================================================================

;=========================================================================
;	     replaceable parameter sublists
;=========================================================================

ed_read_sub	label	dword			;an000;a read error occurred

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:path_name			   ;an000;pointer to parameter
	db	01				;an000;parm 1
	db	Char_Field_ASCIIZ		;an000;left align/asciiz/char.
	db	unlim_width			;an000;unlimited width
	db	00				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blanks

arg_sub 	label	dword			;an000;line output buffer

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:arg_buf			   ;an000;pointer to parameter
	db	01				;an000;parm 1
	db	Char_Field_ASCIIZ		;an000;left align/asciiz/char.
	db	unlim_width			;an000;unlimited width
	db	00				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blank

num_sub 	label	dword			;an000;line number

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:line_num			   ;an000;pointer to parameter
	db	01				;an000;parm 1
	db	Right_Align+Unsgn_Bin_Word	;an000;right align/decimal
	db	08				;an000;maximum width
	db	08				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blank

	db	11				;an000;optional flag
	db	00				;an000;reserved
	dd	dg:line_flag			   ;an000;pointer to parameter
	db	02				;an000;parm 2
	db	Char_Field_Char 		;an000;character
	db	01				;an000;minimum width of 1
	db	01				;an000;maximum width of 1
	db	pad_blank			;an000;pad with blank

BAK_Sub 	label	dword			;an000;line output buffer

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:Temp_Path			;an000;pointer to parameter
	db	00				;an000;parm 0
	db	Char_Field_ASCIIZ		;an000;left align/asciiz/char.
	db	unlim_width			;an000;unlimited width
	db	00				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blank


;=========================================================================
;	     end replaceable parameter sublists
;=========================================================================

;======================= TABLE STRUCTURE =================================
;
;	bute 1-2  :	message number of message to be displayed
;	byte 3	  :	message type to be used, i.e.;class 1, utility, etc.
;	byte 4-5  :	display handle, i.e.; console, printer, etc.
;	byte 6-7  :	pointer to substitution list, if any.
;	byte 8-9  :	number of replaceable parameters, if any.
;	byte 10   :	type of input from keyboard, if any.
;	byte 11-12:	pointer to buffer for keyboard input, if any.
;
;=========================================================================

;	a bunch of common messages (class=UTILITY_MSG_CLASS, dest=stdout,
;				    no inputs or sublists) are passed
;				    through absolute message numbers rather
;				    than duplicating the data structure for
;				    each one.

prompt		=	0006	; "*"
baddrv		=	0007	; "Invalid drive or file name"
ndname		=	0008	;"File name must be
				;specified",0d,0a,0
ro_err		=	0010	;"File is READ-ONLY",0d,0a,0
bcreat		=	0011	;"File Creation Error",0d,0a,0
msg_too_many	=	0012	;"Too many files open",0d,0a,0
nobak		=	0014	;"Cannot edit .BAK file
				;--rename file",0d,0a,0
nodir		=	0015	;"No room in directory
				;for file",0d,0d,0
dskful		=	0016	;"Disk full. Edits lost.",0d,0a,0
badcom		=	0018	;"Entry error",0d,0a,0
newfil		=	0019	;"New file",0d,0a,0
nosuch		=	0020	;"Not found",0d,0a,0
toolng		=	0022	;"Line too long",0d,0a,0
eof	 	=	0023	;"End of input file",0d,0a,0
dest		=	0025	;"Must specify destination
				;line number",0d,0a,0
mrgerr		=	0026	;"Not enough room to
				;merge the entire file",0d,0a,0
msg_crlf	=	0027	;0d,0a,0
msg_lf		=	0028	;0a,0
cp_err		=	0033	;"Cannot merge - Code page
				;	mismatch",0d,0a
dsp_options	=	0300	; display options
dsp_help	=	0301	; display help
num_help_msgs	=	7

simple_msg	label	word
		dw	0000  		; message number (supplied as used)
		db	UTILITY_MSG_CLASS  ; utility message
		dw	stdout		; display handle
		dw	00		; no sublist
		dw	00		; no sub
		db	no_input	; no keyboard input
		dw	00		; no keyboard buffer


opt_err_ptr	label	word		;an000;"Invalid parameter",0d,0a,0
		dw	0010		;an000;message number
		db	Parse_Err_Class ;an000;utility message
		dw	StdErr		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

read_err_ptr	label	word		;an000;"Read error in:",
					;an000;0d,0a,"%1",0d,0a,0
		dw	0013		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	dg:ed_read_sub	;an000;point to sublist
		dw	0001		;an000;1 sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

memful_ptr	label	word		;an000;"Insufficient memory",0d,0a,0
		dw	0008		;an000;message number
		db	Ext_Err_Class	;an000;extended error
		dw	stderr		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

filenm_ptr	label	word		;an000;"File not found",0d,0a
		dw	0002		;an000;message number
		db	Ext_Err_Class	;an000;utility message
		dw	stderr		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

ask_ptr 	label	word		;an000;"O.K.? ",0
		dw	0021		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	00		;an000;no sub
		dw	00		; no sublist
		db	DOS_KEYB_INP	;an000;keyboard input - AX
		dw	00		;an000;no keyboard buffer

qmes_ptr	label	word		;an000;"Abort edit (Y/N)? ",0
		dw	0024		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	DOS_KEYB_INP	;an000;keyboard input - AX
		dw	00		;an000;no keyboard buffer

cont_ptr	label	word		;an000;"Continue (Y/N)?"
		dw	0029		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	DOS_KEYB_INP	;an000;keyboard input
		dw	00		;an000;no keyboard buffer

arg_buf_ptr	label	word		;an000;argument buffer for
					;      line output
		dw	0031		;an000;message number
		db	UTILITY_MSG_CLASS     ;an000;utility message
		dw	stdout		;an000;display handle
		dw	dg:arg_sub	;an000;argument sublist
		dw	01		;an000;1 sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

line_num_buf_ptr label	word		;an000;holds line numbers
		dw	0032		;an000;message number
		db	UTILITY_MSG_CLASS     ;an000;utility message
		dw	stdout		;an000;display handle
		dw	dg:num_sub	;an000;argument sublist
		dw	02		;an000;2 subs
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

del_bak_ptr	label	word		;an000;"Access Denied - xxxxxxxx.BAK"
		dw	0005		;an000;message number
		db	Ext_Err_Class	;an000;utility message
		dw	stderr		;an000;display handle
		dw	dg:BAK_Sub	;an000;no sublist
		dw	01		;an000;no subs
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

CONST	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\edlin\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

edlin.skl : ..\usa\edlin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\e2bequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
                                                ;                               ;     ;

NO      equ     0
YES     equ     not NO


DOS_Found equ   0

INIT    equ     0


Net_Check equ   1200h
Assign_Check equ 8000h

Found_Yes equ   1
Found_No equ    0

Asciiz_End equ  0
;DBCS_Blank_hi    equ     81h
DBCS_Blank equ	DB_SP_LO
DBCS_Vector_Size equ 2
End_Of_Vector equ 0


Blank   equ     " "

Label_Length equ 11
CR      equ     13

DBCS_VECTOR equ NO

;-------------------------------------------------------------------------------





DRNUM   EQU     5CH



; Exit status defines
ExitOK  equ     0


;-------------------------------------------------------------------------------
; These are the data structures which we will need



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\e2bparse.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
data    segment public 'DATA'



;
;***************************************************************************
; Equates
;***************************************************************************
;

;Match Flags

Numeric_Value           equ     8000h           ;                               ;AN000;
Signed_Numeric_Value    equ     4000h           ;                               ;AN000;
Simple_String           equ     2000h           ;                               ;AN000;
Date_String             equ     1000h           ;                               ;AN000;
Time_String             equ     0800h           ;                               ;AN000;
Complex_List            equ     0400h           ;                               ;AN000;
Filespec                equ     0200h           ;                               ;AN000;
Drive_Only              equ     0100h           ;                               ;AN000;
Quoted_String           equ     0080h           ;                               ;AN000;
Ignore_Colon            equ     0010h           ;                               ;AN000;
Repeats_Allowed         equ     0002h           ;                               ;AN000;
Optional                equ     0001h           ;                               ;AN000;

;Function_Flags

File_Table_Capitalize   equ     1               ;                               ;AN000;

;Result buffer type returned
rb_Number               equ     1
rb_List_Index           equ     2
rb_String               equ     3
rb_Complex              equ     4
rb_Filespec             equ     5
rb_Drive                equ     6
rb_Date                 equ     7
rb_Time                 equ     8
rb_Quoted_String        equ     9


;Extra delimeters and EOL

Delimiters_Only         equ     1               ;                               ;AN000;
EOL_Or_Delimiters       equ     2               ;                               ;AN000;

Semi_Colon              equ     ";"             ;                               ;AN000;
Tab                     equ     09h             ;                               ;AN000;
Colon1                  equ     ":"             ;                               ;AN000;
NUL                     equ     "0"

;Parse Errors

No_Error                equ     0               ;                               ;AN000;
Too_Many_Operands       equ     1               ;                               ;AN000;
Operand_Missing         equ     2               ;                               ;AN000;
Not_In_Switch_List      equ     3               ;                               ;AN000;
Not_In_Keyword_List     equ     4               ;                               ;AN000;
Out_Of_Range            equ     6               ;                               ;AN000;
Not_In_Value_List       equ     7               ;                               ;AN000;
Not_In_String_List      equ     8               ;                               ;AN000;
Syntax_Error            equ     9               ;                               ;AN000;
End_Of_Parse            equ     -1              ;                               ;AN000;

;Other

None                    equ     0               ;                               ;AN000;
No_Error                equ     0               ;                               ;AN000;
Switch_Found            equ     0FFFFh          ;                               ;AN000;
Range_Ok                equ     1               ;                               ;AN000;
Command_Line_Parms      equ     81h             ;                               ;AN000;

;
;*****************************************************************************
; Parse Structures
;*****************************************************************************
;

Control          struc

Match_Flags     dw      ?
Function_Flags  dw      ?
Result          dw      ?
Values          dw      ?
Num_Keywords    db      ?
Keyword         db      ?

Control         ends

File_Name_Return        struc                   ;                               ;AN000;

Drive_Type      db      0                       ;                               ;AN000;
Drive_Item_Tag  db      0                       ;                               ;AN000;
Synonym         dw      0                       ;                               ;AN000;
String_Value_ptr db     0                       ;File Name                      ;AN000;

File_Name_Return     ends                       ;                               ;AN000;


;
;**************************************************************************
; Parse tables
;**************************************************************************
;

Command_Line_Table label byte                      ;                               ;AN000;

        dw      Command_Control                 ;Point to next level            ;AN000;
        db      Delimiters_Only                 ;                               ;AN000;
        db      1                               ;                               ;AN000;
        db      Semi_Colon                      ;                               ;AN000;


;
;**************************************************************************
; Define Positionals, Switches and Keywords
;**************************************************************************
;

Command_Control label byte                      ;                               ;AN000;

        db      1,2                             ;File names Positional (1 required) ;AN000;
        dw      Positional_Control1             ;Pointer to control table       ;AN000;
        dw      Positional_Control2             ;Pointer to control table       ;AN000;
        db      1                               ; 1 switch
	dw	Switch_Control1			; Pointer to control table
        db      None                            ;No Keywords (maxk)             ;AN000;

;
;**************************************************************************
;Control Tables
;**************************************************************************
;

Positional_Control1 label byte                  ;                               ;AN000;

        dw      Filespec                        ;Match_Flag                     ;AN000;
        dw      File_Table_Capitalize           ;No function flags              ;AN000;
        dw      File_Name_Buffer1               ;Where it will be returned      ;AN000;
        dw      No_Value                        ;No value ranges defined        ;AN000;
        db      None                            ;No defined switches/keywords   ;AN000;

Positional_Control2 label byte                  ;                               ;AN000;

        dw      Filespec+Optional               ;Match_Flag                     ;AN000;

        dw      File_Table_Capitalize           ;No function flags              ;AN000;
        dw      File_Name_Buffer2               ;Where it will be returned      ;AN000;
        dw      No_Value                        ;No value ranges defined        ;AN000;
        db      None                            ;No defined switches/keywords   ;AN000;

Switch_Control1	label byte			; used by /?

	dw	0				; Match Mask
	dw	0				; Func Mask
	dw	Switch_Buffer1			; ptr to Results
	dw	No_Value			; ptr to Value
	db	1				; # of synonyms
sw1_s1	db	"/?",0				; 1st synonym

No_Value        label   byte                    ;                               ;AN000;
        db      0                               ;                               ;AN000;

;
;************************************************************************
; PARSE Return Buffers
;************************************************************************
;
File_name_Buffer1   label  byte                 ;                               ;AN000;

rb_type1       db      0                        ;type returned                  ;AN000;
rb_item_tag1   db      0                        ;matched item tag               ;AN000;
rb_synonym1    dw      0                        ;found synonyms                 ;AN000;
rb_string1_off dw      0                        ;Offset of string               ;AN000;
rb_string1_seg dw      0                        ;Offset of string               ;AN000;

File_name_Buffer2   label  byte                 ;                               ;AN000;

rb_type2       db      0                        ;type returned                  ;AN000;
rb_item_tag2   db      0                        ;matched item tag               ;AN000;
rb_synonym2    dw      0                        ;found synonyms                 ;AN000;
rb_string2_off dw      0                        ;Offset of string               ;AN000;
rb_string2_seg dw      0                        ;Offset of string               ;AN000;

Switch_Buffer1	label byte			; used by /?

sw_type1	db	0			; type returned
sw_tag1		db	0			; matched item tag
sw_synonym1	dw	0			; found synonym
sw_padding1	dd	0			; pad it out

data    ends


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\e2bmacro.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */



;
;******************************************************************************
; Message Macro Definitions
;******************************************************************************
;

      EXTRN Display_Interface:near


;-----------------------------------------------------------------------------

MESSAGE macro   Message_Name                    ;                               ;AN000;
                                                ;
        mov     dx,offset Message_Name          ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
                                                ;
        endm                                    ;                               ;AN000;


;
;*****************************************************************************
; General Macro's
;*****************************************************************************
;

Procedure       macro   Proc_Name

Public  Proc_Name
Proc_Name    proc

        endm
;-----------------------------------------------------------------------------

DOS_Call        macro   Function

        mov     ah,Function
        int     21h

        endm
;-----------------------------------------------------------------------------

Parse_Message macro                                                             ;AN000;


        push    ds                                                              ;AN000;
        mov     dx,SEG parse_ptr                                                ;AN000;
        mov     ds,dx                                                           ;AN000;
        ASSUME  DS:DATA                                                         ;AN000;
        ASSUME  ES:DATA                                                         ;AN000;
        mov     word ptr Parse_Error_Msg,ax                                     ;AN000;
        mov     dx,offset Parse_Error_Msg       ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
        pop     ds
        endm                                    ;                               ;AN000;

;-----------------------------------------------------------------------------

Extend_Message macro                            ;                               ;AN001;

                                                ;
        push    ds                                                              ;AN001;
        mov     dx,SEG parse_ptr                                                ;AN001;
        mov     ds,dx                                                           ;AN001;
        ASSUME  DS:DATA                                                         ;AN001;
        ASSUME  ES:DATA                                                         ;AN001;
        mov     word ptr Extend_Error_Msg,ax     ;                              ;AN001;
        mov     dx,offset Extend_Error_Msg       ;                              ;AN001;
        call    Display_Interface               ;                               ;AN001;
        pop     ds                                                              ;AN001;
        endm                                    ;                               ;AN001;

;-----------------------------------------------------------------------------

; macros to declare messages

addr macro sym,name
    public name
    ifidn <name>,<>
	dw offset sym
    else
    public name
name    dw  offset sym
    endif
endm


defmsg	macro	sym, name, str1, str2, str3, str4, str5
	sym	db	str1
	ifnb	<str2>
		db	str2
	endif
	ifnb	<str3>
		db	str3
	endif
	ifnb	<str4>
		db	str4
	endif
	ifnb	<str5>
		db	str5
	endif
	ifnb	<name>
	addr	sym, name
	endif
endm

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\e2bchng.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
.xlist
;
;
;*****************************************************************************
;*                                                                           *
;* Change list to EXE2BIN modules                                            *
;*                                                                           *
;* Lines are tagged ANxxx for new, ACxxx for changed                         *
;* --------------------------------------------------------------------------*
;*  000 - DOS 4.00 Spec additions and DCR's thru unit/function test          *
;*         Date: 12/31/87  Developer: Dennis M	                             *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  001 - DOS 4.00 PTM P3964 Pass invalid parameter to message retriever for *
;*         replacement in error message.                                     *
;*         Date: 03/24/88  Developer: Dennis M	                             *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*****************************************************************************
;* Note: This is file E2BCHNG.INC for updating purposes                      *
;*****************************************************************************
.list


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\e2btable.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
data    segment

;
;*****************************************************************************
; Macro's
;*****************************************************************************
;


Define_Msg macro Message_Name                   ;                               ;AN000;
                                                ;
Create_Msg Message_Name,Message_Number,Handle,Sublist,Count,Class,Function,Input;AN000;
                                                ;
        endm                                    ;                               ;AN000;

;-----------------------------------------------------------------------------

Create_Msg macro Parm1,Parm2,Parm3,Parm4,Parm5,Parm6,Parm7,Parm8;               ;AN000;

Parm1   label   word                            ;                               ;AN000;
        dw      Parm2                           ;                               ;AN000;
        dw      Parm3                           ;                               ;AN000;
        dw      Parm4                           ;                               ;AN000;
        dw      Parm5                           ;                               ;AN000;
        db      Parm6                           ;                               ;AN000;
        db      Parm7                           ;                               ;AN000;
        dw      Parm8                           ;                               ;AN000;
        endm                                    ;                               ;AN000;


;---------------------------                    ;                               ;AN001;
Sublist_msg_parserr     label   dword           ;                               ;AN001;
                                                                                ;AN001;
        db              Sublist_Length          ;11                             ;AN001;
        db              Reserved                ;0                              ;AN001;
parsoff dw              ?                       ;off                            ;AN001;
parseg  dw              ?                       ;                               ;AN001;
        db              0                       ;USE PERCENT ZERO               ;AN001;
        db              Left_Align+Char_Field_ASCIIZ ;type of data              ;AN001;
        db              128                     ;max width                      ;AN001;
        db              1                       ;min width                      ;AN001;
        db              Blank                   ;pad char                       ;AN001;
;---------------------------                    ;                               ;AN001;

Sublist_msg_exterror label word                                                 ;AN001;

        db              Sublist_Length                                          ;AN001;
        db              Reserved                                                ;AN001;
FileNamePointer         label dword                                             ;AN001;
FileNameOffset  dw      ?                                                       ;AN001;
FileNameSegment dw      ?                                                       ;AN001;
        db              0                              ; SPECIAL %0 - Extended Errors only ;AN001;
        db              Left_Align+Char_Field_ASCIIZ                            ;AN001;
        db              132                                                     ;AN001;
        db              0                                                       ;AN001;
        db              Blank                                                   ;AN001;
;-----------------------------------------------------------------------------
;
;*****************************************************************************
; Message Retriever equates
;*****************************************************************************
;

Format_Msg              equ     'C'

N_A                     equ     0

Blank                   equ     " "
No_Function             equ     0

No_Input                equ     0


;
;*****************************************************************************
; Message Description Tables
;*****************************************************************************
;

MSG_OPTIONS_FIRST	equ	300
MSG_OPTIONS_LAST        equ     303

;----------------------                         ;
Message_Number  = 1                             ;                               ;AN000;
Handle          = No_Handle                     ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgBadDOSVersion        ;                               ;AN000;
;----------------------                         ;
Message_Number  = 2                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgOutOfMemory          ;                               ;AN000;
;----------------------                         ;
Message_Number  = 3                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgLoadFailure          ;                               ;AN000;
;----------------------                         ;
Message_Number  = 4                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoAccess             ;                               ;AN000;
;----------------------                         ;
Message_Number  = 5                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoConvert            ;                               ;AN000;
;----------------------                         ;
Message_Number  = 6                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoFile               ;                               ;AN000;
;----------------------                         ;
Message_Number  = 7                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgFileCreateError      ;                               ;AN000;
;----------------------                         ;
Message_Number  = 8                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = DOS_BUF_KEYB_INP              ;                               ;AN000;
Input           = INBUF                         ;                               ;AN000;
        Define_Msg      msgFixUp                ;                               ;AN000;
;----------------------                         ;
Message_Number  = 0                             ;                               ;AN001;
Handle          = STDERR                        ;                               ;AN001;
Sublist         = ds:sublist_msg_parserr        ;                               ;AN001;
Count           = 1                             ;                               ;AN001;
Class           = Parse_Err_Class               ;                               ;AN001;
Function        = No_Input                      ;                               ;AN001;
Input           = N_A                           ;                               ;AN001;
        Define_Msg      parse_error_msg         ;                               ;AN001;
;----------------------                         ;
Message_Number  = 0                             ;                               ;AN001;
Handle          = STDERR                        ;                               ;AN001;
Sublist         = ds:sublist_msg_exterror       ;                               ;AN001;
Count           = 1                             ;                               ;AN001;
Class           = ext_Err_Class                 ;                               ;AN001;
Function        = No_Input                      ;                               ;AN001;
Input           = N_A                           ;                               ;AN001;
        Define_Msg      extend_error_msg        ;                               ;AN001;
;----------------------                         ;
Message_Number  = 10                            ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoDiskSpace          ;                               ;AN000;
;----------------------                         ;
Message_Number  = 12                            ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoFileName           ;                               ;AN000;
;----------------------                         ;
Message_Number  = MSG_OPTIONS_FIRST             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgOptions              ;                               ;AN000;
;----------------------                         ;

data ends

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\display.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


CODE    SEGMENT PARA PUBLIC 'CODE'
CODE    ENDS
DATA    SEGMENT PARA PUBLIC 'DATA'
DATA    ENDS
STACK   SEGMENT PARA STACK  'STACK'
STACK   ENDS
ZLOAD   SEGMENT PARA PUBLIC 'ZLOAD'
ZLOAD   ENDS

CODE    SEGMENT PARA PUBLIC 'CODE'
        assume  cs:code,ds:data
;
;*****************************************************************************
; External Declarations
;*****************************************************************************
;

        extrn   SysDispMsg:near

;
;***************************************************************************
; Message Structures
;***************************************************************************
;


Message_Table struc                             ;                               ;AN000;
                                                ;
Entry1  dw      0                               ;                               ;AN000;
Entry2  dw      0                               ;                               ;AN000;
Entry3  dw      0                               ;                               ;AN000;
Entry4  dw      0                               ;                               ;AN000;
Entry5  db      0                               ;                               ;AN000;
Entry6  db      0                               ;                               ;AN000;
Entry7  dw      0                               ;                               ;AN000;
                                                ;
Message_Table ends                              ;                               ;AN000;



;*****************************************************************************
;Routine name&gml Display_Interface
;*****************************************************************************
;
;DescriptioN&gml Save all registers, set up registers required for SysDispMsg
;             routine. This information is contained in a message description
;             table pointed to by the DX register. Call SysDispMsg, then
;             restore registers. This routine assumes that the only time an
;             error will be returned is if an extended error message was
;             requested, so it will ignore error returns
;
;Called Procedures: Message (macro)
;
;Change History&gml Created        4/22/87         MT
;
;Input&gml ES&gmlDX = pointer to message description
;
;Output&gml None
;
;Psuedocode
;----------
;
;       Save all registers
;       Setup registers for SysDispMsg from Message Description Tables
;       CALL SysDispMsg
;       Restore registers
;       ret
;*****************************************************************************

Public  Display_Interface
Display_Interface   proc                        ;                               ;AN000;

        push    ds                              ;                               ;AN000;
        push    es                              ;                               ;AN000;
        push    ax                              ;Save registers                 ;AN000;
        push    bx                              ; "  "    "  "                  ;AN000;
        push    cx                              ; "  "    "  "                  ;AN000;
        push    dx                              ; "  "    "  "                  ;AN000;
        push    si                              ; "  "    "  "                  ;AN000;
        push    di                              ; "  "    "  "                  ;AN000;
        mov     di,dx                           ;Change pointer to table        ;AN000;
        mov     dx,SEG data                     ;Point to data segment
        mov     ds,dx                           ;
        mov     es,dx
        mov     ax,[di].Entry1                  ;Message number                 ;AN000;
        mov     bx,[di].Entry2                  ;Handle                         ;AN000;
        mov     si,[di].Entry3                  ;Sublist                        ;AN000;
        mov     cx,[di].Entry4                  ;Count                          ;AN000;
        mov     dh,[di].Entry5                  ;Class                          ;AN000;
        mov     dl,[di].Entry6                  ;Function                       ;AN000;
        mov     di,[di].Entry7                  ;Input                          ;AN000;
        call    SysDispMsg                      ;Display the message            ;AN000;
        pop     di                              ;Restore registers              ;AN000;
        pop     si                              ; "  "    "  "                  ;AN000;
        pop     dx                              ; "  "    "  "                  ;AN000;
        pop     cx                              ; "  "    "  "                  ;AN000;
        pop     bx                              ; "  "    "  "                  ;AN000;
        pop     ax                              ; "  "    "  "                  ;AN000;
        pop     es                              ;                               ;AN000;
        pop     ds                              ;                               ;AN000;
        ret                                     ;All done                       ;AN000;

Display_Interface      endp                     ;                               ;AN000;
code    ends


        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\e2binit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

Title	E2BINIT(EXE2BIN)

;*****************************************************************************
;   Loader for EXE files under 86-DOS
;   VER 1.5
;	05/21/82   Added rev number
;   VER 1.6
;	07/01/82   A little less choosy about size matches
;   VER 2.0  M.A.U
;	10/08/82   Modified to use new 2.0 system calls for file i/o
;   Ver 2.1  M.A.U
;	10/27/82   Added the DOS version check
;   Ver 2.2  MZ
;	8/30/83     Fixed command line parsing
;   Ver 2.3  EE
;	10-12-83    More fixes to command line parsing
;   Ver 2.4  NP
;	10/17/83    Use Printf for messages
;   Ver 2.5  MZ     Fix LOCATE sss D: problem
;	04/09/87    Add PARSER and MESSAGE RETRIEVER
;   Ver 4.00  DRM
;
;       M001    MD      12/27/90        Removed special checks for ambiguous
;                                       file names
;*****************************************************************************


INCLUDE SYSMSG.INC
MSG_UTILNAME <EXE2BIN>							;AN000;

	subttl	Main Code Area						;AN000;
	page


; The following switch allows use with the "old linker", which put a version
; number where the new linker puts the number of bytes used in the last page.
; If enabled, this will cause a test for 0004 at this location (the old linker
; version number), and if equal, change it to 200H so all of the last page
; will be used.

OLDLINK EQU	0			;1 to enable, 0 to disable

CODE	SEGMENT PARA PUBLIC 'CODE'					;AN000;
CODE	ENDS								;AN000;
DATA	SEGMENT PARA PUBLIC 'DATA'					;AN000;
DATA	ENDS								;AN000;
STACK	SEGMENT PARA PUBLIC 'STACK'					;AN000;
STACK	ENDS								;AN000;
ZLOAD	SEGMENT PARA PUBLIC 'ZLOAD'					;AN000;
ZLOAD	ENDS								;AN000;

DATA	SEGMENT PARA PUBLIC 'DATA'					;AN000;

MSG_SERVICES <MSGDATA>							;AN000;

Command_Line_Buffer db 128 dup(0)					;AN000;
Command_Line_Length equ $ - Command_Line_Buffer 			;AN000;

Fatal_Error db	0							;AN000;

Command_Line db NO



rev	db	"2.4"


file1_ext db	".EXE",00h
file2_ext db	".BIN",00h

per11	db	0							;AN000;
per2	db	0
per22	db	0							;AN000;

update	equ	0							;AN000;
noupdate equ	-1							;AN000;

file1	db	(64+13) dup(?)
fnptr	dw	offset file1		; Ptr to filename in file1
handle1 dw	1 dup(?)

file2	db	(64+13) dup(?)
f2cspot dw	offset file2		; Ptr to spot in file2, file1 maybe added

name2_given	db	1		;1-> atleast the file2 name is present
ext2_given	db	0		;1-> full file2 spec given
file2_given	db	0		; is TRUE if user specified atleast a 
					; drive, or path (or full name)
handle2 dw	1 dup(?)

dma_buf db	80h dup(0)		; DMA transfer buffer

INBUF	DB	5,0
	DB	5 DUP(?)

;The following locations must be defined for storing the header:

RUNVAR	LABEL	BYTE			;Start of RUN variables
RELPT	DW	?
LASTP	LABEL	WORD
RELSEG	DW	?
SIZ	LABEL	WORD			;Share these locations
PAGES	DW	?
RELCNT	DW	?
HEADSIZ DW	?
	DW	?
LOADLOW DW	?
INITSS	DW	?
INITSP	DW	?
	DW	?
INITIP	DW	?
INITCS	DW	?
RELTAB	DW	?
RUNVARSIZ EQU	$-RUNVAR

DBCS_Vector_Off dw 0							;AN000;
DBCS_Vector_Seg dw 0							;AN000;

parse_ptr DW	?

DATA	ENDS


STACK	SEGMENT PARA PUBLIC 'STACK'
	DB	(362 - 80h) + 80H DUP (?) ; (362 - 80h) is IBMs ROM requirement
					; (New - Old) == size of growth
STACK	ENDS
;



ZLOAD	SEGMENT PARA PUBLIC 'ZLOAD'
	db	?
ZLOAD	ENDS
LOAD	EQU	ZLOAD
;



;
;*****************************************************************************
; Include files
;*****************************************************************************
;

.xlist
INCLUDE DOSSYM.INC			; also versiona.inc		;AN000;
INCLUDE SYSCALL.INC							;AN000;
INCLUDE E2BMACRO.INC							;AN000;
INCLUDE E2BEQU.INC							;AN000;
INCLUDE E2BTABLE.INC							;AN000;
INCLUDE E2BPARSE.INC							;AN000;
include version.inc
.list



CODE	SEGMENT PARA PUBLIC 'CODE'
	assume	cs:CODE,ds:DATA,es:NOTHING,SS:STACK			;AN000;

psp_ptr dw	1 dup(?)						;AN000;
;
;*****************************************************************************
; SysDisplayMsg Declarations
;*****************************************************************************
;
.xlist
MSG_SERVICES <LOADmsg>							;AN000;
MSG_SERVICES <DISPLAYmsg,CHARmsg>					;AN000;
MSG_SERVICES <EXE2BIN.CLA,EXE2BIN.CLB>					;AN000;
MSG_SERVICES <EXE2BIN.CL1,EXE2BIN.CL2>					;AN000;
MSG_SERVICES <EXE2BIN.CTL>						;AN000;


.list

;
;*****************************************************************************
; External Routine Declarations
;*****************************************************************************
;

	public	SysDispMsg						;AN000;
	public	SysLoadMsg						;AN000;


;*****************************************************************************
;Routine name:	Main_Init
;*****************************************************************************
;
;Description: Main control routine for init section
;
;Called Procedures: Message (macro)
;		    Check_DOS_Version
;		    Init_Input_Output
;		    Validate_Target_Drive
;		    Hook_CNTRL_C
;
;Input: None
;
;Output: None
;
;Change History: Created	6/22/87 	DM
;
;*****************************************************************************

procedure Main_Init near		;				;AN000;

	ASSUME	DS:NOTHING		; THIS IS WHAT dos GIVES YOU	;AN000;
	ASSUME	ES:NOTHING						;AN000;

	PUSH	DS							;AN000;
	mov	psp_ptr,ds						;AN000;
	XOR	AX,AX							;AN000;
	PUSH	AX			;Push return address to DS:0	;AN000;

	MOV	AX,SEG DATA		;SET UP ADDRESSABILITY TO	;AN000;
	MOV	DS,AX			; THE DATA SEGMENT		;AN000;
	ASSUME	DS:DATA 		;TELL ASSEMBLER WHAT I JUST DID ;AN000;

	mov	Fatal_Error,No		;Init the error flag		;AN000;
	call	Init_Input_Output	;Setup messages and parse	;AN000;
	cmp	Fatal_Error,Yes 	;Error occur?			;AN000;
;	$IF	NE			;Nope, keep going		;AN000;
	JE $$IF1
	    call    LOCATE		;Go do the real program 	;AN000;
;	$ENDIF								;AN000;
$$IF1:
	xor	al,al							;AN000;
	Dos_call Exit							;AN000;
	int	20h			;If other exit fails		;AN000;

Main_Init endp								;AN000;

;*****************************************************************************
;Routine name: Init_Input_Output
;*****************************************************************************
;
;Description: Initialize messages, Parse command line, allocate memory as
;	      needed. If there is a /FS switch, go handle it first as
;	      syntax of IFS format may be different from FAT format.
;
;Called Procedures: Preload_Messages
;		    Parse_For_FS_Switch
;		    Parse_Command_Line
;		    Interpret_Parse
;
;Change History: Created	6/22/87 	DM
;
;Input: PSP command line at 81h and length at 80h
;	Fatal_Error  = No
;
;Output: Fatal_Error = YES/NO
;
;*****************************************************************************

procedure Init_Input_Output near					;AN000;

	call	Preload_Messages	;Load up message retriever	;AN000;
	cmp	Fatal_Error,YES 	;Quit?				;AN000;
;	$IF	NE			;Nope, keep going		;AN000;
	JE $$IF3
	    call    Parse_Command_Line	;Parse in command line input	;AN000;
;	$ENDIF								;AN000;
$$IF3:
	ret								;AN000;

Init_Input_Output endp							;AN000;

;*****************************************************************************
;Routine name: Preload_Messages
;*****************************************************************************
;
;Description: Preload messages using common message retriever routines.
;
;Called Procedures: SysLoadMsg
;
;
;Change History: Created	6/22/87 	DM
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;*****************************************************************************

procedure Preload_Messages near 					;AN000;

	call	SYSLOADMSG		;Preload the messages		;AN000;
;	$IF	C			;Error? 			;AN000;
	JNC $$IF5
	    call    SYSDISPMSG						;AN000;
	    mov     fatal_error, YES					;AN000;
;	$ENDIF								;AN000;
$$IF5:
	ret								;AN000;
Preload_Messages endp							;AN000;


;*****************************************************************************
;Routine name: Parse_Command_Line
;*****************************************************************************
;
;Description: Parses command line.
;
;Called Procedures: Message (macro)
;		    Sysparse
;
;Change History: Created	6/22/87 	DM
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;*****************************************************************************


Procedure Parse_Command_Line						;AN000;

	push	ds							;AN000;
	mov	ds,psp_ptr						;AN000;
	ASSUME	DS:NOTHING						;AN000;
	mov	si,Command_Line_Parms					;AN000;
	mov	ax,seg command_line_table				;AN000;
	push	es							;AN000;
	mov	es,ax							;AN000;
	ASSUME	ES:NOTHING						;AN000;
	mov	di,offset Command_Line_Table				;AN000;
	xor	cx,cx							;AN000;

	PUBLIC	MainParseLoop
MainParseLoop:

;	$DO								;AN000;
$$DO7:
	    xor     dx,dx						;AN000;
	    mov     es:parse_ptr,si
	    call    Sysparse						;AN000;
	    cmp     ax,No_Error 					;AN000;

;	    $IF     E							;AN000;
	    JNE $$IF8

	        ; Check if /? switch entered.
		; If so, display the options help message
		; and set for exit.
		;
		; This gives the user the info they want,
		; without all the other possible error messages.
		;
		; 4/18/90 c-PaulB

		cmp	es:[sw_synonym1], offset sw1_s1	; /?
		jne	CheckSW1Done			;  skip this if not
		call	DisplayOptions			; else display msg
		mov	es:[Fatal_Error], YES		; set flag to stop
		jmp	ParseCLExit			;  and bail out now
CheckSW1Done:

		push	ax						;AN000;
		push	bx						;AN000;
		push	ds						;AN000;
		push	es						;AN000;
		push	si						;AN000;
		push	di						;AN000;

		cmp	cx,1						;AN000;

;		$IF	E						;AN000;
		JNE $$IF9

		    mov     ax,seg rb_string1_off			;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,offset rb_string1_off			;AN000;
		    mov     ax,ds:[si]					;AN000;
		    mov     bx,ax					;AN000;


		    mov     ax,ds:[si+2]				;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,bx					;AN000;

		    mov     ax,seg file1				;AN000;
		    mov     es,ax					;AN000;
		    ASSUME  ES:NOTHING					;AN000;
		    mov     di,offset file1				;AN000;
		    call    copyfs					;AN000;

;		$ELSE							;AN000;
		JMP SHORT $$EN9
$$IF9:

		    mov     ax,seg rb_string2_off			;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,offset rb_string2_off			;AN000;
		    mov     ax,ds:[si]					;AN000;
		    mov     bx,ax					;AN000;


		    mov     ax,ds:[si+2]				;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,bx					;AN000;

		    mov     ax,seg file2				;AN000;
		    mov     es,ax					;AN000;
		    ASSUME  ES:NOTHING					;AN000;
		    mov     di,offset file2				;AN000;
		    call    copyfs					;AN000;

;		$ENDIF							;AN000;
$$EN9:

		pop	di						;AN000;
		pop	si						;AN000;
		pop	es						;AN000;
		ASSUME	ES:NOTHING					;AN000;
		pop	ds						;AN000;
		ASSUME	DS:NOTHING					;AN000;
		pop	bx						;AN000;
		pop	ax						;AN000;

;	    $ENDIF							;AN000;
$$IF8:

	    cmp     ax,No_Error 					;AN000;

;	$ENDDO	NE							;AN000;
	JE $$DO7

	cmp	ax,End_of_Parse 	;Check for parse error		;AN000;
;	$IF	NE							;AN000;
	JE $$IF14
		push	ax						;AN001;
		mov	ax,es:parse_ptr 				;AN001;
		mov	es:parsoff,ax					;AN001;
		mov	es:parseg,ds					;AN001;
		mov	byte ptr ds:[si],0				;AN001;
		pop	ax						;AN001;
		parse_message		       ;Must enter file name	;AN000;
		mov	es:Fatal_Error,YES     ;Indicate death! 	;AN000;
;	$ENDIF								;AN000;
$$IF14:
ParseCLExit:
	pop	es							;AN000;
	ASSUME	ES:NOTHING						;AN000;
	pop	ds							;AN000;
	ASSUME	DS:DATA 						;AN000;

	ret								;AN000;

Parse_Command_Line endp 						;AN000;

;*****************************************************************************
;Routine name: Parse_Command_Line
;*****************************************************************************
;
;Description:       Displays options help message lines.
;
;Called Procedures: Display_Interface
;
;Change History:    Created 5/2/90 c-PaulB
;
;Input:             No value passed.
;
;Output:            No value returned.
;
;*****************************************************************************


Procedure DisplayOptions

	mov     dx, offset msgOptions		; get options msg
DO_Loop:
	call    Display_Interface		;  and show it
	cmp	word ptr es:[msgOptions], MSG_OPTIONS_LAST	; last msg?
	je	DO_Done				; done if so
	inc	word ptr es:[msgOptions]		; else get next msg
	jmp	short DO_Loop			;  and go do it
DO_Done:
	ret

DisplayOptions	endp

;*****************************************************************************

INCLUDE PARSE.ASM

;*****************************************************************************


procedure LOCATE near

	push	ds							;AN000;
	ASSUME	ES:NOTHING		; THIS IS THE WAY IT GETS HERE! ;AN000;
	mov	ax,es			; ES -> PSP			;AN000;
	mov	ds,ax			; DS -> PSP			;AN000;
	ASSUME	DS:NOTHING						;AN000;

	MOV	SI,offset file1
	MOV	BX,SEG DATA
	MOV	ES,BX
	assume	es:data 						;AN000;

	MOV	BX,WORD PTR DS:[2]	;Get size of memory


;-----------------------------------------------------------------------;

;
; The rules for the arguments are:
;   File 1:
;	If no extention is present, .EXE is used.
;   File 2:
;	If no drive is present in file2, use the one from file1
;	If no path is specified, then use current dir
;	If no filename is specified, use the filename from file1
;	If no extention is present in file2, .BIN is used
;


;----- Get the first file name
	push	ds							;AN000;
	push	es							;AN000;
	ASSUME	ES:DATA 						;AN000;
	pop	ds							;AN000;
	ASSUME	DS:DATA 						;AN000;

sj01:
	mov	si,offset file1 	;   d = file1;
	mov	per11,0 		;   assume no extension on file1;AC000;

;******************************************************************************

sj0:
	lodsb				;   while (!IsBlank(c=*p++)) {
	cmp	al,0
	JE	SJ2
	call	dbcs_check		; see if a dbcs character	;AN000;
	jc	dbcs_1			; dbcs character, go load another char ;AN000;
	cmp	al,'\'			;	if (c == '\\' || c == ':') {
	jnz	sj05
	mov	per11,update						;AC000;
	mov	fnptr,si		;	    fnptr = ptr to slash
sj05:
	cmp	al,':'			;	if (c == '\\' || c == ':') {
	jnz	checkper1
	mov	per11,update						;AC000;
	mov	fnptr,si		;	    fnptr = ptr to slash
checkper1:
	cmp	al,'.'			;	if (c == '.')
	jne	sj0                     ;                               ;M001
	mov	per11,noupdate		;   set file1 to have extension ;AN000;
        jmp     short sj0               ;                               ;M001
                                        ;M001 - code removed
dbcs_1: 				;				;AN000;
	lodsb				; load another character and got to ;AN000;
	jmp	short sj0		; the start again.		;AN000;

;******************************************************************************

sj2:
get_second:
;----- Get the second file name
; Initially we assume that user has not given any file2 spec. Then if we find
; that user has entered something, then file2_given is made to TRUE;
; Once file2_given is TRUE, then we assume that user has given atleast a name
; i.e. name2_given = 1 but ext2_given = 0;
; if we find that user has given just a drive: then name2_given is made to FALSE
; The logic then simplifies to :
;	if (!file2_given) 
;		copy file1 and add .BIN ext and try to open
; 	else { /* file2 given */
;		if (!name2_given) 
;			copy name from file1 and .BIN as extn ; try to open
;		else { /* name2 also given */
;			do find_first		
;			if (file_not_found) 
;				add extn .BIN if needed and try to open
;			else if (it is subdir)  {
;				add '\' to it;
;				add the file1 name and .BIN 
;				go for file open
;			}	
;		} /* else name2 given*/
;	} /* else file2 given */

	MOV	SI,offset file1
	mov	di,offset file2 	;   d = file2

;******************************************************************************

sj3:
	cmp	word ptr [di],00	;   check to see if first character of
	je	sj32			;   file2 is a null.		;AN000;
	mov	file2_given,1		;   user has given atleast a partial
					;    spec for file2
	mov	si,offset file2 	;   set pointer to file2

;******************************************************************************

sj31:
	lodsb				;   If file2 first character is not a
	mov	f2cspot,si
	cmp	al,0			;   null, this loop will check to see
	JZ	maycopy 		;   the file has an extension assigned;AN000;
	call	dbcs_check		; to it.  If not it will set per2 to  ;AN000;
	jc	dbcs_2			; go load another byte		      ;AN000;
	cmp	al,'\'			
	jnz	checkper6	
	cmp	byte ptr [si],0		;   end of file2 spec ?
	jne	sj31			;  no, go get next char
	mov	name2_given,0		; copy from file1
checkper6:
	cmp	al,':'			;	if (c == '\\' || c == ':') {
	jnz	checkper4
	cmp	byte ptr [si],0		; end of file2 spec ?
	jne	sj31			; no, go get next char
	mov	name2_given,0		; no name; copy from file1
checkper4:				;   there is an extension already.
	cmp	al,'.'			;
	jne	sj31			;       M001
	mov	ext2_given,1		;       M001 - code removed
	jmp	short sj31		;       M001
                                        ;       M001 - code removed
dbcs_2:                                 ;
	lodsb				;load another character and got to    ;AN000;
	jmp	short sj31		;the start again.		      ;AN000;

;******************************************************************************

; we get here only if user specified something - a drive, just a name or
; even the full spec
; check if we have to copy the name 

maycopy:				
	cmp	name2_given,1		; did the user give a name
	je	sj5			; yes, go check for the existence 
	
	dec	f2cspot 						      
	mov	di,f2cspot						     

sj32:
					;   There is no second filename so
	mov	si,fnptr						      ;AN000;

;******************************************************************************

copy1to2:								      ;AN000;
	lodsb				; This loop is executed when there is ;AN000;
	cmp	al,0			; no file2 specified on the command   ;AN000;
	JZ	SJ5			; line.  It will copy the file1 name  ;AN000;
	call	dbcs_check		; check for dbcs character	      ;AN000;
	jc	dbcs_3			; got a dbcs character, go copy.      ;AN000;
	cmp	al,'.'			; extension.  The defult extension    ;AN000;
	je	sj5			; of .BIN will be added in check_ext. ;AN000;
	stosb								      ;AN000;
	jmp	short copy1to2						      ;AN000;
dbcs_3:
	stosb				; Got a dbcs character. Copy	      ;AN000;
	lodsb				; two characters and then go to       ;AN000;
	stosb				; next character in filename.	      ;AN000;
	jmp	short copy1to2						      ;AN000;	     ;AN000;

;******************************************************************************

sj5:
;	mov	byte ptr es:[di],00h	;   *d = 0;
	cmp	file2_given,1		; if the user specified some path
	jne	check_ext		; we need to check it; else 
	cmp	name2_given,1		; add .BIN and try to open file2
	jne	check_ext		; (at this point we have the name)
	mov	ah,Set_DMA		; Use find_first to see if file2 is
	mov	dx,offset dma_buf	; a directory.	If it isn't, go to
	int	21h			; set f2cspot to point to the spot
	mov	ah,Find_First		; right after the backslash, and
	mov	dx,offset file2 	; fall through to no_second so that
	mov	cx,-1			; file1's name will be added to file2.
	int	21h
	jc	check_ext
	test	dma_buf+21,00010000b
	jNZ	DoDirectory
	jmp	short Check_Ext
DoDirectory:
	mov	AL,'\'
	mov	di,f2cspot
	dec	di
	stosb
	inc	f2cspot
	mov	name2_given,0		; so that we will copy file1.ext to
	mov	ext2_given,0		; file2; we also have to copy ext
	jmp	maycopy			; 


;----- Check that files have an extension, otherwise set default
check_ext:
	cmp	per11,noupdate		;   if (ext2_given == NULL) { 	;AC000;
	jz	file1_ok
	mov	di,offset file1 	;	d = file1;
	mov	si,offset file1_ext	;	s = ".EXE";
	call	strcat			;	strcat (d, s);
file1_ok:				;	}
	cmp	ext2_given,1		;   if (ext2_given == NULL) { 	;AC000;
	je	file2_ok
	mov	di,offset file2 	;	d = file2;
	mov	si,offset file2_ext	;	s = ".BIN";
	call	strcat			;	strcat (d, s);
	jmp	short file2_ok		;	}

;-----------------------------------------------------------------------;
file2_ok:
	mov	dx,offset file1
	mov	ax,(open SHL 8) + 0	;for reading only
	INT	21H			;Open input file
	jc	bad_file
	mov	[handle1],ax
	jmp	short exeload

bad_file:
	jmp	DosError

BADEXE:
	pop	ds
	ASSUME	DS:nothing						;AN000;
	MESSAGE msgNoConvert						;AC000;
	jmp	getout							;AN000;

ReadError:
	jmp	DosError

EXELOAD:
	ASSUME	DS:DATA 						;AN000;
	MOV	DX,OFFSET RUNVAR	;Read header in here
	MOV	CX,RUNVARSIZ		;Amount of header info we need
	push	bx
	mov	bx,[handle1]
	MOV	AH,read
	INT	21H			;Read in header
	pop	bx
	jc	ReadError
	CMP	[RELPT],5A4DH		;Check signature word
	JNZ	BADEXE
	MOV	AX,[HEADSIZ]		;size of header in paragraphs
	ADD	AX,31			;Round up first
	CMP	AX,1000H		;Must not be >=64K
	JAE	TOOBIG
	AND	AX,NOT 31
	MOV	CL,4
	SHL	AX,CL			;Header size in bytes

	push	dx
	push	cx
	push	ax
	push	bx
	mov	dx,ax
	xor	cx,cx
	mov	al,0
	mov	bx,[handle1]
	mov	ah,lseek
	int	21h
	jc	LseekError
	pop	bx
	pop	ax
	pop	cx
	pop	dx

	XCHG	AL,AH
	SHR	AX,1			;Convert to pages
	MOV	DX,[PAGES]		;Total size of file in 512-byte pages
	SUB	DX,AX			;Size of program in pages
	CMP	DX,80H			;Fit in 64K? (128 * 512 = 64k)
	JAE	TOOBIG
	XCHG	DH,DL
	SHL	DX,1			;Convert pages to bytes
	MOV	AX,[LASTP]		;Get count of bytes in last page
	OR	AX,AX			;If zero, use all of last page
	JZ	WHOLEP

	IF	OLDLINK
	    CMP     AX,4		;Produced by old linker?
	    JZ	    WHOLEP		;If so, use all of last page too
	ENDIF

	SUB	DX,200H 		;Subtract last page
	ADD	DX,AX			;Add in byte count for last page
WHOLEP:
	MOV	[SIZ],DX
	ADD	DX,15
	SHR	DX,CL			;Convert bytes to paragraphs
	MOV	BP,SEG LOAD
	ADD	DX,BP			;Size + start = minimum memory (paragr.)
	CMP	DX,BX			;Enough memory?
	JA	TOOBIG
	MOV	AX,[INITSS]
	OR	AX,[INITSP]
	OR	AX,[INITCS]
	JMP	short ERRORNZ

TOOBIG:
	pop	ds
	ASSUME	DS:NOTHING						;AN000;
	MESSAGE msgOutOfMemory						;AN000;
	jmp	getout							;AN000;

LseekError:
	jmp	DosError


ERRORNZ:
	ASSUME	DS:DATA 						;AN000;
	jz	xj
	JMP	BADEXE			;AC000; For ptm P475;
xj:	MOV	AX,[INITIP]
	OR	AX,AX			;If IP=0, do binary fix
	JZ	BINFIX
	CMP	AX,100H 		;COM file must be set up for CS:100
	JNZ	ERRORNZ

	push	dx
	push	cx
	push	ax
	push	bx
	mov	dx,100h 		;chop off first 100h
	xor	cx,cx
	mov	al,1			;seek from current position
	mov	bx,[handle1]
	mov	ah,lseek
	int	21h
	jc	LseekError
	pop	bx
	pop	ax
	pop	cx
	pop	dx

	SUB	[SIZ],AX		;And count decreased size
	CMP	[RELCNT],0		;Must have no fixups
	JNZ	ERRORNZ
BINFIX:
	XOR	BX,BX			;Initialize fixup segment
;See if segment fixups needed
	CMP	[RELCNT],0
	JZ	LOADEXE
GETSEG:
	pop	ds
	ASSUME	DS:NOTHING						;AN000;
	MESSAGE msgFixUp						;AN000;
	PUSH	DS
	PUSH	ES
	POP	DS
	ASSUME	DS:DATA 						;AN000;
	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET INBUF
	INT	21H			;Get user response
	MOV	SI,OFFSET INBUF+2
;;dcl;; MOV	BYTE PTR [SI-1],0	;Any digits?
	cmp	BYTE PTR [SI-1],0	;Any digits?			;AC000;
	JZ	GETSEG
DIGLP:
	LODSB
	SUB	AL,"0"
	JC	DIGERR
	CMP	AL,10
	JB	HAVDIG
	AND	AL,5FH			;Convert to upper case
	SUB	AL,7
	CMP	AL,10
	JB	DIGERR
	CMP	AL,10H
	JAE	DIGERR
HAVDIG:
	SHL	BX,1
	SHL	BX,1
	SHL	BX,1
	SHL	BX,1
	OR	BL,AL
	JMP	DIGLP

DIGERR:
	CMP	BYTE PTR [SI-1],0DH	;Is last char. a CR?
	JNZ	GETSEG
LOADEXE:
	XCHG	BX,BP			;BX has LOAD, BP has fixup

	MOV	CX,[SIZ]
	MOV	AH,read
	push	di
	mov	di,[handle1]
	PUSH	DS
	MOV	DS,BX
	ASSUME	DS:NOTHING						;AN000;
	XOR	DX,DX
	push	bx
	mov	bx,di
	INT	21H			;Read in up to 64K
	pop	bx
	POP	DS
	ASSUME	DS:DATA 						;AN000;
	pop	di
	Jnc	HAVEXE			;Did we get it all?

	jmp	DosError

LseekError2:
	jmp	DosError

HAVEXE:
	ASSUME	DS:DATA 						;AN000;
	CMP	[RELCNT],0		;Any fixups to do?
	JZ	STORE
	MOV	AX,[RELTAB]		;Get position of table

	push	dx
	push	cx
	push	ax
	push	bx
	mov	dx,ax
	xor	cx,cx
	mov	al,0
	mov	bx,[handle1]
	mov	ah,lseek
	int	21h
	jc	LseekError2
	pop	bx
	pop	ax
	pop	cx
	pop	dx

	MOV	DX,OFFSET RELPT 	;4-byte buffer for relocation address
RELOC:
	MOV	DX,OFFSET RELPT 	;4-byte buffer for relocation address
	MOV	CX,4
	MOV	AH,read
	push	bx
	mov	bx,[handle1]
	INT	21H			;Read in one relocation pointer
	pop	bx
	Jnc	RDCMP
	jmp	short DosError
RDCMP:
	MOV	DI,[RELPT]		;Get offset of relocation pointer
	MOV	AX,[RELSEG]		;Get segment
	ADD	AX,BX			;Bias segment with actual load segment
	MOV	ES,AX
	ASSUME	ES:NOTHING						;AN000;
	ADD	ES:[DI],BP		;Relocate
	DEC	[RELCNT]		;Count off
	JNZ	RELOC
STORE:
	MOV	AH,CREAT
	MOV	DX,OFFSET file2
	xor	cx,cx
	INT	21H
	Jc	MKERR
	mov	[handle2],ax
	MOV	CX,[SIZ]
	MOV	AH,write
	push	di
	mov	di,[handle2]
	PUSH	DS
	MOV	DS,BX
	ASSUME	DS:NOTHING						;AN000;
	XOR	DX,DX			;Address 0 in segment
	push	bx
	mov	bx,di
	INT	21H
	pop	bx
	POP	DS
	ASSUME	DS:DATA 						;AN000;
	pop	di
	Jc	WRTERR			;Must be zero if more to come
	cmp	AX,CX
	jnz	NOROOM
	MOV	AH,CLOSE
	push	bx
	mov	bx,[handle2]
	INT	21H
	jc	CloseError
	pop	bx
	pop	ds
	pop	ds
	ASSUME	DS:NOTHING						;AN000;

	RET

;*******************************************************************************

NOROOM: 				;				     ;AN000;
	ASSUME	DS:DATA 						;AN000;
	MOV	AH,CLOSE		; Close the file here		     ;AN000;
	push	bx			;				     ;AN000;
	mov	bx,[handle2]		;				     ;AN000;
	INT	21H			;				     ;AN000;
	jc	CloseError		; If error let extend messages get it;AN000;
	pop	bx			;				     ;AN000;
	mov	ah,UNLINK		; Delete the file because it did     ;AN000;
	MOV	DX,OFFSET file2 	; not get written correctly.	     ;AN000;
	INT	21H			;				     ;AN000;
	jc	CloseError		; If error let extend messages get it;AN000;
	pop	ds			;				     ;AN000;
	ASSUME	DS:NOTHING		;				     ;AN000;
	message msgNoDiskSpace		; Put out insufficient disk space    ;AN000;
	jmp	short getout		; message			     ;AN000;
	RET				; return to main_init		     ;AN000;

;*******************************************************************************

WRTERR: 								;AN000;
MKERR:									;AN000;
CloseError:								;AN000;

	public	DosError						;AN000;
DosError:								;AN000;
	mov	es:FileNameSegment,ds	   ; save for opens, creates,	;AN000;
	mov	es:FileNameOffset,dx					;AN000;

	mov	bx,0			; get the extended error code	;AN000;
	mov	ah,059h 						;AN000;
	int	21h							;AN000;

	mov	si,offset ds:Sublist_msg_exterror			;AC001;
	extend_message							;AN001;
	pop	ds							;AN001;

getout: 								;AN000;
	pop	ds							;AN000;
	ASSUME	DS:NOTHING						;AN000;

	ret								;AN000;


LOCATE	ENDP

;----- concatenate two strings
strcat	proc	near			;   while (*d)
	cmp	byte ptr [di],0
	jz	atend
	inc	di			;	d++;
	jmp	strcat
atend:					;   while (*d++ = *s++)
	lodsb
	stosb
	or	al,al			;	;
	jnz	atend
	ret
strcat	endp

;----- Find the first non-ignorable char, return carry if CR found
kill_bl proc	near
	cld
sj10:					;   while ( *p != 13 &&
	lodsb
	CMP	AL,13			;	    IsBlank (*p++))
	JZ	BreakOut
	CALL	IsBlank
	JZ	SJ10			;	;
BreakOut:
	dec	si			;   p--;
	cmp	al,0dh			;   return *p == 13;
	clc
	jne	sj11
	stc
sj11:
	ret
kill_bl endp

IsBlank proc	near
	cmp	al,00							;AN000;
	retz								;AN000;
	cmp	al,13
	retz
	cmp	al,' '			; space
	retz
	cmp	al,9			; tab
	retz
	cmp	al,','			; comma
	retz
	cmp	al,';'			; semicolon
	retz
	cmp	al,'+'			; plus
	retz
	cmp	al,10			; line feed
	retz
	cmp	al,'='			; equal sign
	return
IsBlank Endp


procedure copyfs near

	push	ax							;AN000;

;	$do				; while we have filespec	;AN000;
$$DO16:
	    lodsb			; move byte to al		;AN000;
	    cmp     al,0		; see if we are at		;AN000;
					; the end of the
					; filespec
;	$leave	e			; exit while loop		;AN000;
	JE $$EN16
	    stosb			; move byte to path_name	;AN000;
;	$enddo				; end do while			;AN000;
	JMP SHORT $$DO16
$$EN16:
	stosb								;AN000;
	pop	ax							;AN000;

	ret								;AN000;
copyfs	endp								;AN000;


procedure dbcs_check near

	push	ds				;Save registers 	;AC000;
	push	si				; "  "	  "  "		;AC000;
	push	ax				; "  "	  "  "		;AC000;
	push	ds				; "  "	  "  "		;AC000;
	pop	es				;Establish addressability;AC000;
	cmp	byte ptr es:DBCS_VECTOR,Yes	;Have we set this yet?	;AC000;
	push	ax				;Save input character	;AC000;
;	$IF	NE				;Nope			;AN000;
	JE $$IF19
	   mov	   al,0 			;Get DBCS environment vectors;AC000;
	   DOS_Call Hongeul			;  "  "    "  " 	;AC000;
	   mov	   byte ptr es:DBCS_VECTOR,YES	;Indicate we've got vector;AC000;
	   mov	   es:DBCS_Vector_Off,si	;Save the vector	;AC000;
	   mov	   ax,ds			;			;AC000;
	   mov	   es:DBCS_Vector_Seg,ax	;			;AC000;
;	$ENDIF					; for next time in	;AC000;
$$IF19:
	pop	ax				;Restore input character;AC000;
	mov	si,es:DBCS_Vector_Seg		;Get saved vector pointer;AC000;
	mov	ds,si				;			;AC000;
	mov	si,es:DBCS_Vector_Off		;			;AC000;
;	$SEARCH 				;Check all the vectors	;AC000;
$$DO21:
	   cmp	   word ptr ds:[si],End_Of_Vector ;End of vector table? ;AC000;
;	$LEAVE	E				;Yes, done		;AC000;
	JE $$EN21
	   cmp	   al,ds:[si]			;See if char is in vector;AC000;
;	$EXITIF AE,AND				;If >= to lower, and	;AC000;
	JNAE $$IF21
	   cmp	   al,ds:[si+1] 		; =< than higher range	;AC000;
;	$EXITIF BE				; then DBCS character	;AC000;
	JNBE $$IF21
	   stc					;Set CY to indicate DBCS;AC000;
;	$ORELSE 				;Not in range, check next;AC000;
	JMP SHORT $$SR21
$$IF21:
	   add	   si,DBCS_Vector_Size		;Get next DBCS vector	;AC000;
;	$ENDLOOP				;We didn't find DBCS chaR;AC000;
	JMP SHORT $$DO21
$$EN21:
	   clc					;Clear CY for exit	;AC000;
;	$ENDSRCH				;			;AC000;
$$SR21:
	pop	ax				;Restore registers	;AC000;
	pop	si				; "  "	  "  "		;AC000;
	pop	ds				;Restore data segment	;AC000;
	ret					;			;AC000;

	ret								;AN000;
dbcs_check  endp							;AN000;



CODE	ends


	end	main_init						;AC000;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\fastopen\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\fastopen\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\exe2bin\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

exe2bin.skl : ..\usa\exe2bin.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\fastopen\fastopen.asm ===
; fastopen.asm
;
; Copyright (c) 1991, Microsoft Corporation
;
; History:
;   13-Apr-1992 Sudeep Bharati (sudeepb)
;   Created.
;
;   On NT this utility is just a stub which does nothing.
;

code	segment byte public 'CODE'
	assume	cs:code, ds:code, es:code

	org	100h
public	start
start:
	mov	ah,4ch
	xor	al,al
	int	21h
	ret

code	ends
	end	start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grctrl.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:   I  fixed  a  MS bug.  MS did  not  initialize  the  variable 
;**                 ROTATE_SW.  Consequently, if you do a non-rotate after doing 
;**                 a  rotate,  the picture would be printed  incorrectly  as  a 
;**                 rotated picture.  Note this bug was in Q.01.01 and fixed for 
;**                 Q.01.02.
;**  
;**  NOTES:    The   following  bug  was  fixed  for  the  pre-release   version 
;**            Q.01.02.
;**  
;**  BUG (mda004)
;**  ------------
;**  
;**  NAME:     After  GRAPHICS prints a rotated  picture  it will print pictures 
;**            which are not supposed to be rotated as rotated junk.
;**  
;**  FILES AFFECTED:     GRCTRL.ASM
;**  
;**  CAUSE:    MicroSoft  was  failing to initialize the variable  ROTATE_SW  to 
;**            OFF.  Consequently, if you printed a picture whose  corresponding 
;**            printbox did NOT specify a rotate after printing a picture  whose 
;**            corresponding  printbox did specify a rotate, the  picture  would 
;**            print as rotated junk.
;**  
;**  FIX:      Initialize the variable ROTATE_SW  to OFF right before going into 
;**            the print procedure Print_Color or Print_BW_APA.
;**  
;**  DOCUMENTATION NOTES:  This version of GRCTRL.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								
										
	TITLE	DOS GRAPHICS Command  -	Print screen Control module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;; DOS - GRAPHICS Command
;;                                 
;;										
;; File Name:  GRCTRL.ASM							
;; ----------									
;;										
;; Description: 								
;; ------------ 								
;;	 This file contains the code for the Print Screen control module.	
;;										
;; Documentation Reference:							
;; ------------------------							
;;	 OASIS High Level Design						
;;	 OASIS GRAPHICS I1 Overview						
;;										
;; Procedures Contained in This File:						
;; ----------------------------------						
;;	PRT_SCR 								
;;	  DET_HW_CONFIG 							
;;	  DET_MODE_STATE							
;;	  GET_MODE_ATTR 							
;;	  SET_UP_XLT_TAB							
;;	    SET_CGA_XLT_TAB							
;;	      CGA_COL2RGB							
;;	      RGB2XLT_TAB							
;;	    SET_EGA_XLT_TAB							
;;	      EGA_COL2RGB							
;;	    SET_MODE_F_XLT_TAB							
;;	    SET_MODE_13H_XLT_TAB						
;;	    SET_ROUNDUP_XLT_TAB 						
;;	 SET_BACKG_IN_XLT_TAB							
;;	 RGB2BAND								
;;	 RGB2INT								
;;										
;;										
;; Include Files Required:							
;; -----------------------							
;;	 GRINST.EXT - Externals for GRINST.ASM					
;;										
;;										
;; External Procedure References:						
;; ------------------------------						
;;	 FROM FILE  GRINST.ASM: 						
;;	      GRAPHICS_INSTALL - Main module for installation.			
;;										
;; Linkage Instructions:							
;; -------------------- 							
;;	 Refer to GRAPHICS.ASM							
;;										
;; Change History:								
;; ---------------								
;;  M001	NSM	1/30/91		New var to store the old int 10 handler
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
CODE	SEGMENT PUBLIC 'CODE'                                                   
	ASSUME		CS:CODE,DS:CODE 					
										
.XLIST										
INCLUDE GRINT2FH.EXT								
INCLUDE GRBWPRT.EXT								
INCLUDE GRCOLPRT.EXT								
INCLUDE GRSHAR.STR								
INCLUDE GRPATTRN.STR								
INCLUDE GRPATTRN.EXT								
INCLUDE STRUC.INC								
.LIST										
PRT_SCR PROC NEAR								
	JMP PRT_SCR_BEGIN							
PAGE										
;===============================================================================
;										
; GRAPHICS INTERRUPT DRIVER'S DATA:                                             
;										
;===============================================================================
.xlist										
PUBLIC PRT_SCR,ERROR_CODE,XLT_TAB,MODE_TYPE					
PUBLIC CUR_MODE_PTR,CUR_MODE,NB_COLORS,SCREEN_HEIGHT,SCREEN_WIDTH		
PUBLIC CUR_PAGE,CUR_COLUMN,CUR_ROW,NB_SCAN_LINES,SCAN_LINE_MAX_LENGTH		
PUBLIC CUR_SCAN_LNE_LENGTH							
PUBLIC PRT_BUF,NB_BOXES_PER_PRT_BUF,CUR_BOX,BOX_H,BOX_W 			
PUBLIC PRINT_SCREEN_ALLOWED,RGB 						
PUBLIC BIOS_INT_5H								
PUBLIC OLD_INT_10H			; /* M001 */
PUBLIC ROTATE_SW								
PUBLIC DET_HW_CONFIG								
PUBLIC NB_CHAR_COLUMNS								
PUBLIC RGB2INT									
PUBLIC RGB2BAND 								
.list										
INCLUDE GRCTRL.STR								
;-------------------------------------------------------------------------------
;										
; ENTRY POINT TO BIOS HARDWARE INTERRUPT 5 HANDLER				
;										
;-------------------------------------------------------------------------------
BIOS_INT_5H	DW	?		; Pointer to BIOS int 5h		
		DW	?							
										
;/* M001 BEGIN */ --------------------------------------------------------------
;										
; ENTRY POINT TO BIOS HARDWARE INTERRUPT 10 HANDLER				
;										
;-------------------------------------------------------------------------------
OLD_INT_10H	DW	?		; Pointer to BIOS int 10h		
		DW	?							
; /* M001 END */ 
;-------------------------------------------------------------------------------
;										
; PRINT SCREEN ERROR CODE (Used at print screen time, see GRCTRL.STR for	
;			   error codes allowed) 				
;										
;-------------------------------------------------------------------------------
ERROR_CODE	DB	0		; ERROR CODE 0 = NO ERROR		
										
;-------------------------------------------------------------------------------
;										
; SCREEN PIXEL: INTERNAL REPRESENTATION 					
;										
;-------------------------------------------------------------------------------
RGB	PIXEL_STR < , , >	  ; PIXEL := RED, GREEN, BLUE Values		
										
;-------------------------------------------------------------------------------
;										
; COLOR TRANSLATION TABLE:							
;										
; This table is used to translate the color numbers returned by 		
; Interrupt 10H Read Dot and Read Character calls into print			
; information.	The table consists of 256 entries, one byte each,		
; indexed by color number.							
; In the case of black and white printing, the table				
; entries are grey scale intensities from 0 to 63.  In the case 		
; of color printing each table entry contains a "band mask" indicating          
; which color print bands are required to generate the required color.		
; The band masks are simply bit masks where each bit corresponds to one 	
; of the printer bands. 							
;										
; The table is set up at the beginning of the print screen processing,		
; before any data is read from the screen.  From then on, translating		
; from screen information into print information is done quickly by		
; accessing this table.  Not all 256 entries are initialized for each		
; screen print.  The number of entries used is equal to the number		
; of colors available concurrently with the given display mode. 		
;-------------------------------------------------------------------------------
XLT_TAB DB	  256 DUP(32)  ; COLOR TRANSLATION TABLE			
			       ; This table is used to translate the Color Dot	
			       ; or Byte Attribute to a Band Mask for color	
			       ; printing or to a Grey Intensity for Mono-	
			       ; chrome printing.				
										
;-------------------------------------------------------------------------------
;										
; CURRENT VIDEO MODE ATTRIBUTES 						
;										
;-------------------------------------------------------------------------------
MODE_TYPE	DB	?	; Mode types (bit mask) APA or TXT		
										
CUR_MODE_PTR	DW	?	; DISPLAYMODE INFO RECORD for the current	
				;   mode (defined in the shared data area).	
CUR_MODE	DB	?	; Current video mode number			
NB_COLORS	DW	?	; Number of colors supported by this mode	
SCREEN_HEIGHT	DW	?	; Number of rows on the screen (chars or pixels)
SCREEN_WIDTH	DW	?	; Number of columns on the screen (chars/pixels)
				;  (for text modes is equal to NB_CHAR_COLUMNS) 
NB_CHAR_COLUMNS DB	?	; Number of columns on the screen if in txt mode
CUR_PAGE	DB	?	; Active page number				
ROTATE_SW	DB	?	; Switch: if "ON" then, must print sideways     
										
;-------------------------------------------------------------------------------
;										
; ACTIVE SCREEN ATTRIBUTES							
;										
;-------------------------------------------------------------------------------
CUR_COLUMN	DW	?	; Current pixel/char column number		
CUR_ROW 	DW	?	; Current pixel/char row number 		
NB_SCAN_LINES	DW	?	; Number of screen scan lines			
SCAN_LINE_MAX_LENGTH DW ?	; Maximum number of dots/chars per scan line	
CUR_SCAN_LNE_LENGTH DW	?	; Length in pels/chars of the current scan line 
										
;-------------------------------------------------------------------------------
;										
; PRINTER VARIABLES								
;										
;-------------------------------------------------------------------------------
PRT_BUF DB	?,?,?,? 	; PRINT BUFFER					
NB_BOXES_PER_PRT_BUF DB ?	; Number of boxes fitting in the print buffer	
CUR_BOX DB	?,?,?,? 	; BOX = PRINTER REPRESENTATION OF 1 PIXEL	
BOX_H	DB	?		; HEIGHT OF THE BOX				
BOX_W	DB	?		; WIDTH OF THE BOX				
										
;-------------------------------------------------------------------------------
;										
; CONTROL VARIABLES:								
;										
; This data is used to communicate between the Installation Modules		
; and the Resident Print Screen Modules.					
;-------------------------------------------------------------------------------
PRINT_SCREEN_ALLOWED	DB   YES; Used to avoid print screens			
				;  while the GRAPHICS installation		
				;   (or re-install) is in progress		
				; Set by GRAPHICS_INSTALL module.		
										
										
PAGE										
;===============================================================================
;										
; INTERRUPT 5 DRIVER'S CODE:                                                    
;										
;-------------------------------------------------------------------------------
;===============================================================================
;										
; PRT_SCR : PRINT THE ACTIVE SCREEN						
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: SHARED_DATA_AREA_PTR = Offset of the data area used for		
;				      passing data between the			
;				      Installation process and the Print	
;				      Screen process.				
;	      PRINT_SCREEN_ALLOWED  = Switch. Set to "No" if currently          
;				      installing GRAPHICS.COM			
;										
;				NOTE: These 2 variables are declared within	
;				      PRT_SCR but initialized by the		
;				      Installation process GRAPHICS_INIT	
;	OUTPUT: PRINTER 							
;										
;	CALLED BY: INTERRUPT 5							
;										
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION:									
;										
; PRINT THE ACTIVE SCREEN for all TEXT and  All Points Addressable (APA)	
; display modes  available  with  either  a MONO, CGA, EGA, or VGA video	
; adapter on a Black and White or Color printer.				
;										
; INITIALIZATION:								
;										
; Each pixel  or  character  on the screen has a color attribute.  These	
; colors must be translated into different internal representations:		
;										
;	For printing in colors, each color is translated to a BAND MASK.	
;	The Band Mask indicates how to obtain this color on the printer.	
;										
;	For printing  in  Black and White, each color is translated to a	
;	GREY INTENSITY number between 0 (black) and 63 (white). 		
;										
; The  BAND  MASK  or  the  GREY INTENSITIES  are  found  in  the  COLOR	
; TRANSLATION TABLE.  This  table is initialized  before  calling any of	
; the print screen modules.							
;										
; PRINT SCREEN TIME:								
;										
; When a pixel or character  is read  off the screen by one of the print	
; screen modules, its  color is  used as  an index  into the translation	
; table.									
;										
;										
; LOGIC:									
;										
; IF SCREEN_PRINTS_ALLOWED=NO	; Block print screens until Installation	
;   THEN IRET			;  Process (or re-install!) is finished.	
; ELSE										
;										
;   CALL DET_HW_CONFIG		  ; Determine hardware configuration		
;   CALL DET_MODE_STATE 	  ; Determine video mode and active page	
;   CALL GET_MODE_ATTR		  ; Get video attributes (TXT or APA, etc)	
;										
;  IF MODE_TYPE = TXT AND Number of colors = 0					
;    THEN Invoke BIOS INTERRUPT 5						
;  ELSE 									
;    IF PRINTER_TYPE = BLACK_WHITE						
;      THEN									
;      IF MODE_TYPE = TXT							
;	 THEN Invoke BIOS INTERRUPT 5						
;      ELSE ; Mode is APA							
;	 CALL SET_UP_XLT_TAB	 ; Set up the color translation table		
;	 CALL PRINT_BW_APA	 ; Print the active screen on a B&W printer	
;    ELSE ; Color printer attached						
;      CALL SET_UP_XLT_TAB	 ; Set up the color translation table		
;      CALL PRINT_COLOR 	 ; Print the active screen on a Color prt.	
;    IRET									
;										
PRT_SCR_BEGIN:									
  PUSH	  AX		  ; Save Registers					
  PUSH	  BX		  ;							
  PUSH	  CX		  ;							
  PUSH	  DX		  ;							
  PUSH	  SI		  ;							
  PUSH	  DI		  ;							
  PUSH	  BP		  ;							
  PUSH	  DS		  ;							
  PUSH	  ES		  ;							
			  ;							
  CLD			  ; Clear direction flag				
  PUSH	  CS		  ; DS := CS						
  POP	  DS									
										
;-------------------------------------------------------------------------------
; Verify if we are allowed to print (not allowed if currently installing	
; GRAPHICS or printing a screen):						
;-------------------------------------------------------------------------------
  CMP	  PRINT_SCREEN_ALLOWED,NO	  ; IF not allowed to print		
  JE	  PRT_SCR_RETURN		  ; THEN quit				
					  ; ELSE print the screen:		
;-------------------------------------------------------------------------------
; INITIALIZATION:								
;-------------------------------------------------------------------------------
PRT_SCR_INIT:				  ; Disable print screen while		
  MOV	  PRINT_SCREEN_ALLOWED,NO	  ;  we are printing the current	
					  ;   screen.				
  MOV	  BP,SHARED_DATA_AREA_PTR	  ; BP := Offset Shared Data Area	
  MOV	  ERROR_CODE,NO_ERROR		  ; No error so far.			
  CALL	  DET_HW_CONFIG   ; Determine the type of display adapter		
  CALL	  DET_MODE_STATE  ; Init CUR_PAGE, CUR_MODE				
  CALL	  GET_MODE_ATTR   ; Determine if APA or TXT, nb. of colors,		
			  ;  and screen dimensions in pels or characters.	
 ;										
 ; Test the error code returned by GET_MODE_ATTR:				
 ;										
  TEST	  ERROR_CODE,MODE_NOT_SUPPORTED    ;If mode not supported then, 	
  JNZ	  DO_BEEP			   ; let BIOS give it a try.		
										
 ;------------------------------------------------------------------------------
 ; Check the printer type:							
 ;------------------------------------------------------------------------------
 .IF <DS:[BP].PRINTER_TYPE EQ BLACK_WHITE> ; Is a black and white printer	
 .THEN					   ;  attached ?			
 ;------------------------------------------------------------------------------
 ; A Black and White printer is attached					
 ;------------------------------------------------------------------------------
   CMP	   MODE_TYPE,TXT	   ; Is the screen in text mode ?		
   JNE	   INVOKE_PRINT_ROUTINE    ; No, call GRAPHICS B&W routine		
   JMP	   SHORT EXIT_TO_BIOS	   ; Yes, give control to BIOS INTERRUPT 5	
 .ELSE										
 ;------------------------------------------------------------------------------
 ; A Color printer is attached							
 ;------------------------------------------------------------------------------
   CMP	   NB_COLORS,0		   ; Is the screen in a Monochrome		
   JNE	   INVOKE_PRINT_ROUTINE 						
   TEST    MODE_TYPE,TXT	   ;   text mode ?				
   JNZ	   INVOKE_PRINT_ROUTINE 						
   JMP	   SHORT EXIT_TO_BIOS	   ; Yes, let BIOS INTERRUPT 5 handle it	
				   ; No, we handle it.				
.ENDIF				   ; ENDIF black and white or color printer	
;-------------------------------------------------------------------------------
;										
; Call the print routine (which is either PRINT_COLOR or PRINT_BW_APA)		
;										
;-------------------------------------------------------------------------------
INVOKE_PRINT_ROUTINE:								
   CALL    SET_UP_XLT_TAB	   ; Set up the color translation table 	
; \/ ~~mda(004) ----------------------------------------------------------------
;               The following fixes a MS bug.  MS was failing to initialize
;               the variable ROTATE_SW to off.  Consequently, if you printed a
;               picture whose corresponding printbox did NOT specify a rotate
;               after printing a picture whose corresponding printbox did 
;               specify a rotate, the picture would print rotated.
   MOV     ROTATE_SW,OFF           ; Set printing to standard unless otherwise
                                   ; set to rotate via PRINT_OPTIONS.
; /\ ~~mda(004) ----------------------------------------------------------------
   CALL    PRINT_MODULE_START	   ; Call the print modules that were		
				   ;  made resident at Install time.		
   MOV	   PRINT_SCREEN_ALLOWED,YES; Enable PrtScr for next calls		
  ;-----------------------------------------------------------------------------
  ; Test the error code returned by either PRINT_COLOR or PRT_BW_APA		
  ;-----------------------------------------------------------------------------
   TEST    ERROR_CODE,UNABLE_TO_PRINT ; If unable to print the screen		
   JNZ	   SHORT EXIT_TO_BIOS	      ; then, let BIOS give it a try		
										
PRT_SCR_RETURN: 								
				   ; Restore registers				
  POP	  ES			   ;						
  POP	  DS			   ;						
  POP	  BP			   ;						
  POP	  DI			   ;						
  POP	  SI			   ;						
  POP	  DX			   ;						
  POP	  CX			   ;						
  POP	  BX			   ;						
  POP	  AX			   ;						
				   ;						
  IRET				   ; Return control to interrupted		
				   ;  process					

; give a beep for modes not supported by graphics

DO_BEEP:
  mov	ah,2			   ; console output
  mov	dx,7			   ; ^G - beep  for modes not supported
  int	21h			

EXIT_TO_BIOS:									
				   ; Restore registers				
  POP	  ES			   ;						
  POP	  DS			   ;						
  POP	  BP			   ;						
  POP	  DI			   ;						
  POP	  SI			   ;						
  POP	  DX			   ;						
  POP	  CX			   ;						
  POP	  BX			   ;						
  POP	  AX			   ;						
  CLI				   ; Disable interrupts 			
  MOV	  CS:PRINT_SCREEN_ALLOWED,YES ; Enable PrtScr for next calls		
  JMP	  DWORD PTR CS:BIOS_INT_5H ; Exit to BIOS INTERRUPT 5			
										
PRT_SCR ENDP									
										
										
;===============================================================================
;										
; PRT_SCR MODULES:								
;										
;-------------------------------------------------------------------------------
PAGE										
;===============================================================================
;										
; DET_HW_CONFIG : DETERMINE WHAT TYPE OF VIDEO HARDWARE IS PRESENT		
;										
;-------------------------------------------------------------------------------
;										
;	INPUT:	   BP		   = Offset of the shared data area		
;										
;	OUTPUT:    HARDWARE_CONFIG is updated in the shared data area		
;										
;	CALLED BY: PRT_SCR							
;										
;	EXTERNAL CALLS: BIOS INT 10H						
;										
;-------------------------------------------------------------------------------
;										
; LOGIC:									
;    Issue BIOS INT10H Get Display Configuration Code (AX=1A00H)		
;    IF AL = 1AH THEN	 /* VGA (PS/2 OR BRECON-B)	  */			
;	/* BL = active DCC				  */			
;	/* BH = alternate DCC				  */			
;	/* Display Code:				  */			
;	/*   1 - Mono Adapter				  */			
;	/*   2 - CGA					  */			
;	/*   4 - EGA with Mono Display			  */			
;	/*   5 - EGA with Color Display 		  */			
;	/*   7 - PS/2 Mod 50,60,80 OR BRECON-B with Mono Display */		
;	/*   8 - PS/2 Mod 50,60,80 OR BRECON-B with Color Display */		
;	/*   B - PS/2 Mod 30 with Mono Display		  */			
;	/*   C - PS/2 Mod 30 with Color Display 	  */			
;    IF AL = 1AH THEN	 /* Call is supported */				
;	Set HARDWARE_CONFIG byte based on DCC returned in DL			
;    ELSE									
;	Issue INT 10H EGA Info (AH=12H BL=10H)					
;	IF BL <> 10H  THEN     /* EGA  */					
;	   Set EGA bit in HARDWARE_CONFIG					
;	ELSE		  /* CGA or */						
;	  Issue INT 10H PC CONVERTIBLE Physical display description param.	
;	  request. (AH=15H)							
;	  IF ES:[DI] = 5140H							
;	  THEN									
;	   Set PC_CONVERTIBLE bit in HARDWARE_CONFIG				
;	  ELSE									
;	   Set OLD_ADAPTER bit in HARDWARE_CONFIG				
;	  ENDIF 								
;	ENDIF									
;    ENDIF									
;    RETURN									
;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
DET_HW_CONFIG PROC NEAR 							
										
;-------------------------------------------------------------------------------
;										
; Try to read display combination code (PS/2 call):				
;										
;-------------------------------------------------------------------------------
	MOV	AX,READ_CONFIG_CALL						
	INT	10H			; Call video BIOS			
										
       .IF <AL EQ 1AH>			; If call is supported			
       .THEN									
;-------------------------------------------------------------------------------
;										
; Call is supported, PS/2 BIOS is present (Model 39,50,60,80 or BRECON-B card), 
; Determine what is the primary video adapter:					
;										
;-------------------------------------------------------------------------------
	 .SELECT								
	   .WHEN    <BL EQ 1> OR	    ; MONO or				
	   .WHEN    <BL EQ 2>		    ; CGA				
	      MOV     DS:[BP].HARDWARE_CONFIG,OLD_ADAPTER			
	   .WHEN    <BL EQ 4> OR	    ; EGA with Mono or			
	   .WHEN    <BL EQ 5>		    ; EGA with Color			
	      MOV     DS:[BP].HARDWARE_CONFIG,EGA				
	   .WHEN    <BL EQ 7> OR	    ; BRECON-B with Mono or		
	   .WHEN    <BL EQ 8>		    ; BRECON-B with Color		
	      MOV     DS:[BP].HARDWARE_CONFIG,ROUNDUP				
	   .WHEN    <BL EQ 0Bh> OR	    ; PS/2 Model 30 with Mono or	
	   .WHEN    <BL EQ 0Ch> 	    ; PS/2 Model 30 with Color		
	      MOV     DS:[BP].HARDWARE_CONFIG,PALACE				
	 .ENDSELECT								
;-------------------------------------------------------------------------------
;										
; PS/2 call is not supported, try the EGA info call:				
;										
;-------------------------------------------------------------------------------
       .ELSE									
	  MOV	  AH,ALT_SELECT_CALL	  ; Request Alternate select's          
	  MOV	  BL,EGA_INFO_CALL	  ;  "return EGA information call"      
	  INT	  10H			  ; Call video BIOS			
	 .IF	  <BL NE EGA_INFO_CALL>   ; If a memory value is returned	
	 .THEN				  ; then, there is an EGA		
	    MOV     DS:[BP].HARDWARE_CONFIG,EGA 				
	 .ELSE				  ; else, call is not supported:	
;-------------------------------------------------------------------------------
;										
; EGA call is not supported, try the PC CONVERTIBLE display description call:	
;										
;-------------------------------------------------------------------------------
	    MOV     AH,DISP_DESC_CALL						
	    INT     10H 		    ; Call BIOS, ES:DI :=Offset of parms
	   .IF	    <ES:[DI] EQ 5140H>	    ; If LCD display type,		
	   .THEN			    ;	set LCD bit in Shared Data area 
	      MOV     DS:[BP].HARDWARE_CONFIG,PC_CONVERTIBLE			
	   .ELSE			    ; else, we have an old adapter.	
	      MOV     DS:[BP].HARDWARE_CONFIG,OLD_ADAPTER ; (either MONO or CGA)
	   .ENDIF   ; Display type is LCD					
	 .ENDIF ; EGA BIOS is present						
       .ENDIF ; PS/2 BIOS is present						
	RET									
DET_HW_CONFIG ENDP								
PAGE										
;=======================================================================	
;										
; DET_MODE_STATE : Determine the current video mode and the active page.	
;										
;-----------------------------------------------------------------------	
;										
;	INPUT:	HARDWARE_CONFIG = Type of video hardware attached		
;										
;	OUTPUT: CUR_MODE = Video mode number (0-13H)				
;		CUR_PAGE = Video page number (0-8)				
;		NB_CHAR_COLUMNS = Number of columns if in a text mode.		
;										
;										
;	CALLED BY: PRT_SCR							
;										
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION:	Use the BIOS interface to					
; obtain the current mode and active page.					
;										
; LOGIC:									
;										
;   Call BIOS INTERRUPT 10H: "Return current video state" (AH = 0fh)            
;										
DET_MODE_STATE PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	MOV	AH,GET_STATE_CALL						
	INT	10H			; CALL BIOS				
	MOV	CUR_MODE,AL							
	MOV	NB_CHAR_COLUMNS,AH						
	MOV	CUR_PAGE,BH							
										
	POP	BX								
	POP	AX								
	RET									
DET_MODE_STATE ENDP								
										
PAGE										
;=======================================================================	
;										
; GET_MODE_ATTR: Obtain attributes of current video mode.			
;										
;-----------------------------------------------------------------------	
;										
;	INPUT:	CUR_MODE   = Current video mode (1 BYTE)			
;										
;	OUTPUT: MODE_TYPE  = Video mode type (TXT or APA)			
;		NB_COLORS  = Maximum number of colors (0-256) (0=B&W)		
;		ERROR_CODE = Error code if error occurred.			
;		SCREEN_HEIGHT= Number of rows (in pixels if APA or char if TEXT)
;		SCREEN_WIDTH = Number of columns (in pixels/char)		
;										
;	CALLED BY: PRT_SCR							
;										
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: Scan the 2 local video mode attribute tables until the		
; current mode is located.  Return the attributes.				
; For APA modes SCREEN_HEIGHT and SCREEN_WIDTH are in pixels,			
; for TEXT modes they are in characters.					
;										
;										
; LOGIC:									
;										
; Scan the APA_ATTR_TABLE							
; IF FOUND									
;   MODE_TYPE  := APA								
;   NB_COLORS  := mode.MAX_COLORS						
;   SCREEN_HEIGHT := mode.NB_L							
;   SCREEN_WIDTH  := mode.NB_C							
; ELSE										
;   Scan the TXT_ATTR_TABLE							
;   When FOUND									
;     MODE_TYPE := TXT								
;     NB_COLORS := mode.NUM_COLORS						
;     SCREEN_WIDTH := NB_CHAR_COLUMNS						
;     SCREEN_HEIGHT := Byte in ROM BIOS at 40:84				
;										
;-----------------------------------------------------------------------	
GET_MODE_ATTR	PROC	NEAR							
	JMP	SHORT GET_MODE_ATTR_BEGIN					
;-----------------------------------------------------------------------	
;										
; LOCAL DATA									
;										
;-----------------------------------------------------------------------	
										
APA_ATTR   STRUC      ; ATTRIBUTES FOR APA MODES:				
  APA_MODE   DB ?     ;   Mode number						
  NB_C	     DW ?     ;   Number of columns					
  NB_L	     DW ?     ;   Number of lines					
  MAX_COLORS DW ?     ;   Maximum number of colors available (0=B&W)		
APA_ATTR   ENDS 								
										
TXT_ATTR   STRUC      ; ATTRIBUTES FOR TXT MODES:				
  TXT_MODE   DB ?     ;   Mode number						
  NUM_COLORS DB ?     ;   Number of colors					
TXT_ATTR   ENDS 								
										
;-----------------------------------------------------------------------	
;										
; APA MODE ATTRIBUTES:								
;										
;-----------------------------------------------------------------------	
NB_APA_MODES	DW  10								
APA_ATTR_TABLE LABEL WORD							
MODE04	APA_ATTR <  4,320,200,	4>						
MODE05	APA_ATTR <  5,320,200,	4>						
MODE06	APA_ATTR <  6,640,200,	2>						
MODE0D	APA_ATTR <0DH,320,200, 16>						
MODE0E	APA_ATTR <0EH,640,200, 16>						
MODE0F	APA_ATTR <0FH,640,350,	4>						
MODE10H APA_ATTR <10H,640,350, 16>						
MODE11H APA_ATTR <11H,640,480,	2>						
MODE12H APA_ATTR <12H,640,480, 16>						
MODE13H APA_ATTR <13H,320,200,256>						
										
;-----------------------------------------------------------------------	
;										
; TXT MODE ATTRIBUTES:								
;										
;-----------------------------------------------------------------------	
NB_TXT_MODES	DW  5								
TXT_ATTR_TABLE LABEL WORD							
MODE00 TXT_ATTR <  0, 16>							
MODE01 TXT_ATTR <  1, 16>							
MODE02 TXT_ATTR <  2, 16>							
MODE03 TXT_ATTR <  3, 16>							
MODE07 TXT_ATTR <  7,  0>							
										
;-----------------------------------------------------------------------	
;										
; BEGIN OF GET_MODE_ATTR							
;										
;-----------------------------------------------------------------------	
GET_MODE_ATTR_BEGIN:								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	MOV	DL,CUR_MODE		; DL = CURRENT MODE			
;										
; Scan the APA_ATTR_TABLE							
;										
	MOV	CX,NB_APA_MODES 	; CS <-- Number of APA modes		
	MOV	BX,OFFSET APA_ATTR_TABLE; BX <-- Offset of APA mode table	
      SCAN_APA: 								
	CMP	DL,[BX].APA_MODE	; IF mode found 			
	JE	SHORT ITS_APA		; THEN get its attributes		
	ADD	BX,SIZE APA_ATTR						
      LOOP    SCAN_APA			; ELSE keep scanning			
	JMP	SHORT SCAN_TXT_INIT	; NOT in this table: scan txt modes	
ITS_APA:									
	MOV	MODE_TYPE,APA		; MODE = APA				
	MOV	AX,[BX].MAX_COLORS						
	MOV	NB_COLORS,AX		; Get number of colors			
	MOV	AX,[BX].NB_L							
	MOV	SCREEN_HEIGHT,AX	; Get number of lines			
	MOV	AX,[BX].NB_C							
	MOV	SCREEN_WIDTH,AX 	; Get number of columns 		
	JMP	SHORT GET_MODE_ATTR_END 					
										
;										
; Scan the TXT_ATTR_TABLE							
;										
SCAN_TXT_INIT:									
	MOV	CX,NB_TXT_MODES 	; CX <-- Number of TXT modes		
	MOV	BX,OFFSET TXT_ATTR_TABLE; BX <-- Offset of TXT mode table	
      SCAN_TXT: 								
	CMP	DL,[BX].TXT_MODE	; IF mode found 			
	JE	SHORT ITS_TXT		; THEN get its attributes		
	ADD	BX,SIZE TXT_ATTR						
      LOOP    SCAN_TXT			; ELSE keep scanning			
ITS_TXT:									
	MOV	MODE_TYPE,TXT		; MODE = TXT				
	MOV	AL,[BX].NUM_COLORS						
	CBW									
	MOV	NB_COLORS,AX		; Get number of colors			
	MOV	AL,NB_CHAR_COLUMNS	; Get number of columns 		
	CBW									
	MOV	SCREEN_WIDTH,AX 						
       .IF  <DS:[BP].HARDWARE_CONFIG EQ OLD_ADAPTER>; If an old adapter is there
       .THEN ; The number of lines is 25					
	  MOV	  SCREEN_HEIGHT,25						
       .ELSE									
	  MOV	  AX,BIOS_SEG		; Get number of rows			
	  MOV	  ES,AX 		;  from BIOS Data Area			
	  MOV	  BX,NB_ROWS_OFFSET	;   at 0040:0084			
	  MOV	  AL,ES:[BX]							
	  CBW									
	  INC	  AX								
	  MOV	  SCREEN_HEIGHT,AX						
       .ENDIF									
	JMP	SHORT GET_MODE_ATTR_END 					
										
;										
; The current mode was not found in any of the tables				
;										
	MOV	ERROR_CODE,MODE_NOT_SUPPORTED					
										
GET_MODE_ATTR_END:								
	POP	AX								
	POP	BX								
	POP	CX								
	POP	DX								
	RET									
GET_MODE_ATTR ENDP								
PAGE										
;=======================================================================	
;										
; SET_UP_XLT_TABLE : SET UP A COLOR MAPPING FOR EACH COLOR AVAILABLE		
;		     WITH THE CURRENT MODE					
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: CUR_MODE        = Current video mode.				
;	       HARDWARE_CONFIG = Type of display adapter.			
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       XLT_TAB	       = Color translation table.			
;	       CUR_PAGE        = Active page number				
;	       BP	       = Offset of the shared data area 		
;										
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: PRT_SCR							
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: The table is updated to hold a mapping for each color		
; available in the current video mode either TEXT or APA.			
;										
; For example, if the current mode supports 16 colors then the first		
; sixteen bytes of the table will hold the corresponding Color printer		
; or Black and White printer mappings for these colors. 			
;										
;										
; LOGIC:									
;										
; IF HARDWARE_CONFIG = CGA OR HARDWARE_CONFIG = PC_CONVERTIBLE			
; THEN										
;   CALL SET_CGA_XLT_TAB							
;										
; ELSE IF HARDWARE_CONFIG = EGA 						
;   THEN									
;   CALL SET_EGA_XLT_TAB							
;										
; ELSE IF CUR_MODE = 0FH							
;   THEN									
;   CALL SET_MODE_F_XLT_TAB							
;										
; ELSE IF CUR_MODE = 19 							
;   THEN									
;   CALL SET_MODE_13H_XLT_TAB							
;										
; ELSE										
;   CALL SET_ROUNDUP_XLT_TAB							
;										
; CALL SET_BACKG_IN_XLT_TAB   ; Update the background in the translation table	
;										
SET_UP_XLT_TAB PROC NEAR							
;-------------------------------------------------------------------------------
; For old display modes: set up translation table as for a Color Graphics Adapt.
; Either 4 or 16 colors are set up depending if the mode is an APA or text mode.
;										
; NOTE: SET_UP_XLT_TAB cannot be invoked if the display adater is a Monochrome	
;	display adater. (When a Mono. adapter is attached, a jump is made to	
;	the ROM BIOS for printing the screen, and no translation table is set). 
;-------------------------------------------------------------------------------
.IF <BIT DS:[BP].HARDWARE_CONFIG  NZ OLD_ADAPTER> OR ; IF it is a CGA		
.IF <BIT DS:[BP].HARDWARE_CONFIG  NZ PC_CONVERTIBLE> ; or a PC convertible	
.THEN						     ; THEN set up CGA colors	
   CALL    SET_CGA_XLT_TAB			     ;				
.ELSEIF <BIT DS:[BP].HARDWARE_CONFIG NZ EGA>	     ; ELSEIF it is an EGA	
   CALL    SET_EGA_XLT_TAB			     ;	  set up EGA colors.	
.ELSEIF <CUR_MODE EQ 0FH>			     ; ELSEIF we are in mode 15 
   CALL    SET_MODE_F_XLT_TAB			     ;	  set up its 4 shades	
;-------------------------------------------------------------------------------
; A PS/2 system is attached: (we either have a PALACE [Model 30] or a ROUNDUP)	
;-------------------------------------------------------------------------------
.ELSEIF <CUR_MODE EQ 13H>			    ; ELSEIF current mode is 13h
   CALL    SET_MODE_13H_XLT_TAB 		    ;	  set up 256 colors	
.ELSEIF <BIT DS:[BP].HARDWARE_CONFIG NZ PALACE>     ; ELSEIF PS/2 Model 30(MCGA)
   CALL    SET_CGA_XLT_TAB			    ;	  handle it like a CGA	
.ELSE						    ; ELSE we have a ROUNDUP	
;-------------------------------------------------------------------------------
; A PS/2 model 50, 60 or 80 or an ADA 'B' card is attached (in 16 color mode):  
;-------------------------------------------------------------------------------
   CALL    SET_ROUNDUP_XLT_TAB			;   set up 16 colors		
.ENDIF										
;-------------------------------------------------------------------------------
; Finish setting up the translation table:					
;-------------------------------------------------------------------------------
										
CALL SET_BACKG_IN_XLT_TAB   ; Update the background in the translation table	
			    ;  according to the command line switch setting	
			    ;	(i.e.,/R /B)					
   RET										
SET_UP_XLT_TAB ENDP								
PAGE										
;===============================================================================
;										
; SET_BACKG_IN_XLT_TAB : ADJUST THE MAPPING FOR THE BACKGROUND COLOR IN THE	
;			 XLT_TAB ACCORDING TO PRINTER TYPE AND /R /B.		
;										
;										
;-------------------------------------------------------------------------------
;										
; INPUT:  BP = Offset of shared data area  (SWITCHES)				
;	  XLT_TAB = The color translation table.				
;										
; OUTPUT: XLT_TAB IS UPDATED							
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION: If there is a black and white printer and /R is NOT specified	
; then the background color should not be printed and it is replaced in the	
; translation table by the Intensity for white (will print nothing).		
;										
; If a color printer is attached and /B is not specified then the background	
; color is replaced by the Print Band mask for white.				
;										
; LOGIC:									
; IF  (a black and white printer is attached) AND (/R is OFF)			
; THEN										
;   MOV 	XLT_TAB, WHITE_INT	; Store white in translation table	
; ELSE (a color printer is attached)						
;   IF (/B is ON)								
;   THEN									
;      RGB.R := MAX_INT 							
;      RGB.G := MAX_INT 							
;      RGB.B := MAX_INT 							
;      CALL RGB2BAND			; Convert RGB for white to a Band Mask	
;      MOV	XLT_TAB,AL		; Store the band mask in the xlt table	
;										
;										
;-------------------------------------------------------------------------------
SET_BACKG_IN_XLT_TAB PROC NEAR							
;-------------------------------------------------------------------------------
;										
; Test if a black and white printer is attached.				
;										
;-------------------------------------------------------------------------------
.IF <BIT DS:[BP].PRINTER_TYPE NZ BLACK_WHITE> AND    ; IF black and white	
.IF <BIT DS:[BP].SWITCHES Z REVERSE_SW> 	     ;	   printer and not /R	
.THEN						     ; then, map background	
	MOV	XLT_TAB,WHITE_INT		     ;	   to white.		
;-------------------------------------------------------------------------------
;										
; A Color printer is attached:							
;										
;-------------------------------------------------------------------------------
.ELSEIF <BIT DS:[BP].PRINTER_TYPE NZ COLOR> AND      ; else, if color printer	
.IF <BIT DS:[BP].SWITCHES Z BACKGROUND_SW>	     ;	      and  /B if OFF	
.THEN						     ;				
						     ; Store a null band mask	
	MOV	XLT_TAB,0			     ;	the translation table.	
.ENDIF										
	RET									
SET_BACKG_IN_XLT_TAB  ENDP							
PAGE										
;=======================================================================	
;										
; SET_EGA_XLT_TAB : SET UP COLOR TRANSLATION TABLE FOR ENHANCED GRAPHIC 	
;		    ADAPTER							
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB = Color translation table.				
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       SWITCHES        = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-----------------------------------------------------------------------	
;										
; NOTES: With the EGA, "VIDEO BIOS READ DOT call" returns an index into         
; the 16 EGA palette registers. 						
;										
; These registers contain the actual colors stored as rgbRGB components 	
; (see EGA_COL2RGB for details) for mode hex 10.  Under mode hex E these	
; registers contain the actual colors as I0RGB components (see CGA_COL2RGB	
; for details). 								
;										
; These registers can be Revised by the user but, are 'WRITE ONLY'.            
; However, it is possible to define a SAVE AREA where BIOS will maintain	
; a copy of the palette registers.						
;										
; This area is called the "DYNAMIC SAVE AREA" and is defined via the            
; BIOS EGA SAVE_PTR AREA. Whenever the palette registers are changed by 	
; the user, BIOS updates the EGA_SAVE_AREA.					
;										
; The 16 palette registers are the first 16 bytes of the DYNAMIC SAVE AREA.	
;										
; This program takes advantage of this feature and consults the EGA DYNAMIC	
; SAVE AREA in order to obtain the colors used in the active screen.		
;										
;										
; DESCRIPTION: Obtain each color available with an EGA by reading its		
; palette register in the EGA_SAVE_AREA:					
;										
; Calculate the mapping for this color, either a BAND_MASK or a 		
; GREY INTENSITY and store it in the color translation table.			
;										
;										
; LOGIC:									
;										
; Obtain the DYNAMIC EGA SAVE AREA offset from the BIOS SAVE_PTR_AREA.		
;										
; If current mode is either 4,5 or 6						
; Then, 									
;   CALL SET_CGA_XLT_TAB							
;   Get the background color by reading palette register number 0		
; Else, 									
;   For each register number (0 to 15): 					
;     Get the register contents (rgbRGB values) from the EGA SAVE AREA		
;     CALL EGA_COL2RGB		  ; Obtain the Red, Green, Blue values		
;     CALL RGB2XLT_TAB		  ; Obtain a Band Mask or a Grey Intensity	
;				  ; and store the result in the XLT_TAB 	
;										
SET_EGA_XLT_TAB PROC NEAR							
	PUSH	AX			; Save the registers used		
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	DI								
										
;-------------------------------------------------------------------------------
;										
; Obtain the pointer to the DYNAMIC SAVE AREA from the SAVE AREA POINTER TABLE: 
;										
;-------------------------------------------------------------------------------
EGA_SAVE_PTR	EQU	4A8H		; EGA BIOS pointer to table of		
					; pointer to save areas.		
	XOR	AX,AX			; ES segment := paragraph 0		
	MOV	ES,AX								
										
	LES	BX,ES:DWORD PTR EGA_SAVE_PTR ; ES:BX := Pointer to ptr table	
	LES	BX,ES:[BX]+4		; ES:BX :=  Pointer to dynamic save area
					;  (NOTE: It is the second pointer in	
					;   the table)				
										
;-------------------------------------------------------------------------------
;										
; Set up one entry in the translation table for each color available.		
;										
;-------------------------------------------------------------------------------
.IF <CUR_MODE EQ 4> OR			; If the current mode is an old CGA	
.IF <CUR_MODE EQ 5> OR			;  GRAPHICS mode:			
.IF <CUR_MODE EQ 6>								
.THEN										
;-------------------------------------------------------------------------------
; Current mode is either mode 4, 5 or 6;					
; Store each color of the old CGA All Points Addressable mode:			
;-------------------------------------------------------------------------------
	CALL	SET_CGA_XLT_TAB 	; Set up  colors in the translation	
					;  table, NOTE: The background color	
					;   will not be set properly since the	
					;    EGA BIOS does not update memory	
					;     location 40:66 with the value	
					;      of the background color as CGA	
					;	does.				
;------Adjust the background color in the translation table:			
;------The background color is obtained from the EGA DYNAMIC SAVE AREA		
;------ES:BX = Address of the EGA DYNAMIC SAVE AREA				
;------NOTE : For CGA compatible modes EGA BIOS stores the color in the 	
;------DYNAMIC SAVE AREA as a I0RGB value.					
	XOR	DI,DI			; DI:=register number = index in XLT_TAB
	MOV	AL,ES:[BX][DI]		; AL:=Palette register 0 = Back. color	
	MOV	AH,AL			;  Convert I0RGB to IRGB (CGA color)	
	AND	AL,111B 		;    Isolate RGB bits			
	AND	AH,10000B		;    Isolate I bit			
	SHR	AH,1			;    Move I bit from position 5 to 4	
	OR	AL,AH			;    Get IRGB byte.			
	CALL	CGA_COL2RGB		; Convert IRGB to R,G,B values		
	CALL	RGB2XLT_TAB		; Convert RGB to an entry in XLT_TAB	
										
.ELSE					; ELSE, we have an EGA graphics mode:	
;-------------------------------------------------------------------------------
; The current mode is a either a text mode or one of the EGA enhanced mode;	
; Store in the translation table each color available (these modes have 16 col.)
;-------------------------------------------------------------------------------
	MOV	CX,16			; CX := Number of palette registers	
					;	to read 			
	XOR	DI,DI			; DI := Palette register number 	
					;  and index in the translation table	
STORE_1_EGA_COLOR:								
	MOV	AL,ES:[BX][DI]		; AL := Palette register		
       .IF   <CUR_MODE EQ 14> OR	; If mode E (hex) OR mode D (hex)	
       .IF   <CUR_MODE EQ 13>		; the colors are			
       .THEN				;  stored as I0CGA colors		
	  MOV	  AH,AL 		;  Convert I0RGB to IRGB (CGA color)	
	  AND	  AL,111B		;    Isolate RGB bits			
	  AND	  AH,10000B		;    Isolate I bit			
	  SHR	  AH,1			;    Move I bit from position 5 to 4	
	  OR	  AL,AH 		;    Get IRGB byte.			
	  CALL	  CGA_COL2RGB		;  Convert IRGB to R,G,B values 	
       .ELSE				; Else, they are stored as (rgbRGB);	
	  CALL	  EGA_COL2RGB		;   Convert register to R,G,B values	
       .ENDIF									
	CALL	RGB2XLT_TAB		; Convert RGB to an entry in XLT_TAB	
	INC	DI			; Get next palette register number	
	LOOP	STORE_1_EGA_COLOR						
.ENDIF					; ENDIF 4 colors or 16 colors		
										
	POP	DI			; Restore the registers 		
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
SET_EGA_XLT_TAB ENDP								
PAGE										
;=======================================================================	
;										
; SET_CGA_XLT_TAB : SET UP COLOR TRANSLATION TABLE FOR COLOR GRAPHIC		
;		    ADAPTER							
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB	       = Color translation table.			
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       SWITCHES        = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-----------------------------------------------------------------------	
;										
; NOTES: With the CGA, the "VIDEO BIOS READ DOT call" returns a number          
; from 0 to 3. A dot of value 0 is of the background color.			
;										
; The actual value of the background color is stored in BIOS VIDEO		
; DISPLAY DATA AREA as a PIIRGB value (see CGA_COL2RGB for details) and 	
; can be any of 16 colors.							
;										
; A dot of value 1,2, or 3 represents any of 2 specific colors depending	
; on the current color palette. 						
;										
; The palette number is obtained from the BIOS VIDEO DISPLAY DATA AREA		
; (It is the "P" bit or bit number 5)                                           
;										
; The dot values 1,2,3 expressed in binary actually represent the RG		
; (Red, Green) components of the color. 					
;										
; The palette number represents the B (Blue) component therefore, when		
; the palette number is appended to the color number we obtain the RGB		
; components for that color.							
;										
;  (E.G.,  COLOR  =  010	; COLOR # 2					
;	   PALETTE=    0	; PALETTE # 0					
;										
;	   IRGB   =  0100	; Intensity = 0  Ŀ				
;				; Red	    = 1   > color = Red		
;				; Green     = 0   				
;				; Blue	    = 0  				
;										
;										
; DESCRIPTION:									
;										
; For each color available with a CGA:						
;	 Calculate the color mapping, either a BAND_MASK or a GREY		
;	 INTENSITY and store it in the color translation table. 		
;										
; LOGIC:									
;										
; ; Obtain the background color from VIDEO BIOS DATA AREA			
; ;  and the paletter number							
;										
; ; Store the Background color: 						
; CALL CGA_COL2RGB		  ; Convert IRGB components to RGB values	
; CALL RGB2XLT_TAB		  ; Convert RGB to an entry in the translation	
;				  ; table					
; ; Store all other colors:							
; FOR IRG := 1 TO 3		  ; Obtain the color number			
;   Append palette number (B) to IRG						
;   CALL CGA_COL2RGB		  ; Convert color to RGB values 		
;   CALL RGB2XLT_TAB		  ; Convert RGB to an entry in the translation	
;				  ; table					
;										
SET_CGA_XLT_TAB  PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DI								
	PUSH	ES								
										
.IF <CUR_MODE EQ 4> OR								
.IF <CUR_MODE EQ 5>								
;===============================================================================
;										
; THE CURRENT MODE IS MODE 4 OR 5						
;										
;-------------------------------------------------------------------------------
.THEN										
;-------------------------------------------------------------------------------
; Read the CRT palette from the BIOS ROM to obtain the background color and	
; the current palette number; store the palette number in BL			
;-------------------------------------------------------------------------------
ROM_BIOS_SEG	EQU 40H    ; CGA BIOS SEGMENT					
CRT_PALETTE_OFF EQU 66H    ; BIOS Current palette setting			
P_BIT_MASK   EQU 100000B   ;   bit 5 = Current palette				
I_BIT_MASK   EQU   1000B   ;   bit 4 = Intensity bit				
R_BIT_MASK   EQU    100B   ;   bit 2 = Red bit					
G_BIT_MASK   EQU     10B   ;   bit 1 = Green bit				
B_BIT_MASK   EQU      1B   ;   bit 0 = Blue bit 				
										
	MOV	AX,ROM_BIOS_SEG      ; ES := ROM BIOS SEGMENT			
	PUSH	AX								
	POP	ES								
										
	MOV	AL,ES:CRT_PALETTE_OFF; AL := CRT Palette  (00PIIRGB)		
	MOV	BL,P_BIT_MASK	     ; LOW NIBBLE = BACKGROUND COLOR		
	AND	BL,AL		     ; BL := Palette number			
	MOV	CL,5								
	SHR	BL,CL								
										
	XOR	DI,DI		     ; DI := Index in the XLT_TAB		
;-------------------------------------------------------------------------------
; Store the background color, (obtained from low 4 bits of the byte at 40:66)	
;-------------------------------------------------------------------------------
	CALL	CGA_COL2RGB	     ; Convert color (in AL) to R, G, B values	
	CALL	RGB2XLT_TAB	     ; Convert RGB to an entry in XLT_TAB	
;-------------------------------------------------------------------------------
; Store the 3 foreground colors for mode 4 and 5				
;-------------------------------------------------------------------------------
	MOV	CX,3		     ; For each color, but the background:	
STORE_1_CGA_MODE4_COLOR:							
	INC	DI		     ; Increment index in the translation table 
	MOV	AX,DI		     ; AL := IRG				
	SHL	AL,1								
	OR	AL,BL		     ; AL := IRGB				
	CALL	CGA_COL2RGB	     ; Convert color (in AL) to R, G, B values	
	CALL	RGB2XLT_TAB	     ; Convert RGB to an entry in XLT_TAB	
	LOOP	STORE_1_CGA_MODE4_COLOR 					
.ELSEIF <CUR_MODE EQ 6> 							
;===============================================================================
;										
; THE CURRENT MODE IS MODE 6							
;										
;-------------------------------------------------------------------------------
.THEN										
;-------------------------------------------------------------------------------
; Store background color for mode 6 (mode 6 is a 2 colors, APA mode)		
; Background is stored as BLACK 						
;-------------------------------------------------------------------------------
	XOR	DI,DI		  ; DI := Index of color in translation table	
	MOV	RGB.R,BLACK_INT   ; Foreground color is white			
	MOV	RGB.G,BLACK_INT   ; RGB := RGB of white 			
	MOV	RGB.B,BLACK_INT   ;						
	CALL	RGB2XLT_TAB	  ; Convert RGB to an entry in XLT_TAB		
;-------------------------------------------------------------------------------
; Store foreground color for mode 6 (mode 6 is a 2 colors, APA mode)		
;-------------------------------------------------------------------------------
	INC	DI		  ; DI := Index of color in translation table	
	MOV	RGB.R,WHITE_INT   ; Background color is BLACK			
	MOV	RGB.G,WHITE_INT   ; RGB := RGB of BLACK 			
	MOV	RGB.B,WHITE_INT   ;						
	CALL	RGB2XLT_TAB	  ; Convert RGB to an entry in XLT_TAB		
.ELSE										
;===============================================================================
;										
; THE CURRENT MODE IS A TEXT MODE:						
;										
;-------------------------------------------------------------------------------
	XOR	DI,DI		  ; DI := Index in the translation table	
	MOV	CX,16		  ; For each of the 16 colors:			
STORE_1_CGA_TEXT_COLOR: 							
	MOV	AX,DI		  ; AL := IRGB					
	CALL	CGA_COL2RGB	  ; Convert color (in AL) to R, G, B values	
	CALL	RGB2XLT_TAB	  ; Convert RGB to an entry in XLT_TAB		
	INC	DI		  ; Increment index in the translation table	
	LOOP	STORE_1_CGA_TEXT_COLOR						
.ENDIF				  ;						
										
	POP	ES								
	POP	DI								
	POP	CX								
	POP	BX								
	POP	AX								
										
	RET									
SET_CGA_XLT_TAB  ENDP								
PAGE										
;===============================================================================
;										
; RGB2XLT_TAB: CONVERT R,G,B VALUES TO EITHER A BAND MASK OR AN INTENSITY	
;	   STORE THE RESULT IN THE TRANSLATION TABLE				
;										
;-------------------------------------------------------------------------------
;										
;	INPUT:	 DI  = Index in the translation table				
;		 RGB = Red Green Blue values of the color to be stored. 	
;										
;	OUTPUT:  XLT_TAB is updated						
;										
;-------------------------------------------------------------------------------
; DESCRIPTION: Convert the RGB values to either a Band mask or an intensity	
; depending on the printer type; store the result in the translation table.	
;										
; LOGIC:									
;   IF PRINTER_TYPE = COLOR							
;     THEN									
;     CALL RGB2BAND		  ; Obtain a Band Mask				
;   ELSE ; Printer is Monochrome						
;     CALL RGB2INT		  ; Obtain a Grey Intensity			
;   Store the result in the XLT_TAB						
;										
RGB2XLT_TAB PROC NEAR								
       .IF <DS:[BP].PRINTER_TYPE EQ COLOR>; Color printer ?			
       .THEN									
;-------A color printer is attached:						
	  CALL	  RGB2BAND		; Yes, convert RGB to color band (in AL)
       .ELSE									
;-------A black and white printer is attached:					
	  CALL	  RGB2INT		; No, RGB to an intensity in AL 	
       .ENDIF									
;-------Store the result							
	MOV	XLT_TAB[DI],AL							
       RET									
RGB2XLT_TAB ENDP								
PAGE										
;===============================================================================
;										
; CGA_COL2RGB : CONVERT A COLOR FROM THE CGA TO RED GREEN BLUE VALUES		
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: AL      = 0000IRGB    ONE BYTE WHERE BIT:			
;										
;					I = Intensity bit			
;					R = Red component			
;					G = Green component			
;					B = Blue component			
;										
;										
;	OUTPUT: RGB.R	    = RED   component (0-63)				
;		RGB.G	    = GREEN component (0-63)				
;		RGB.B	    = BLUE  component (0-63)				
;										
;	CALLED BY: SET_UP_CGA_XLT_TABLE 					
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: If either the RED, GREEN, or BLUE bit is on (in an IRGB		
; byte) then, the corresponding color gun on the display is firing 2/3		
; of its capacity, giving a color intensity of "2/3".                           
;										
; If the INTENSITY bit is on, then 1/3 is added to EACH color.			
;										
; (E.G.,		       IRGB		 R    G    B			
;	   BLACK	 = 00000000	      (  0,   0,   0)			
;	   WHITE	 = 00001111	      (3/3, 3/3, 3/3)			
;	   RED		 = 00000100	      (2/3,   0,   0)			
;	   HIGH INT. RED = 00001100	      (3/3, 1/3, 1/3)			
;										
; Since we want an intensity from 0 to 63,					
; "2/3" of RED means:                                                           
;		       2/3 * 63 = 42						
;										
;										
; LOGIC:									
; Get the intensity.								
; Get the red component 							
; Get the green component							
; Get the blue component							
;										
CGA_COL2RGB PROC NEAR								
;-----------------------------------------------------------------------	
;										
; Init the R,G,B values:							
;										
;-----------------------------------------------------------------------	
	MOV	RGB.R,0 							
	MOV	RGB.G,0 							
	MOV	RGB.B,0 							
;-----------------------------------------------------------------------	
;										
; Test the Intensity bit:							
;										
;-----------------------------------------------------------------------	
       .IF <BIT AL AND I_BIT_MASK>	; IF, I is on				
       .THEN									
	  ADD	  RGB.R,ONE_THIRD	; Then, add one third to each		
	  ADD	  RGB.G,ONE_THIRD	; color.				
	  ADD	  RGB.B,ONE_THIRD						
       .ENDIF									
;-----------------------------------------------------------------------	
;										
; Test the RGB bits:								
;										
;-----------------------------------------------------------------------	
       .IF <BIT AL AND R_BIT_MASK>	; If, Red is on 			
       .THEN									
	  ADD	  RGB.R,TWO_THIRD	; then, add two third RED		
       .ENDIF									
										
       .IF <BIT AL AND G_BIT_MASK>	; If, Green is on			
       .THEN									
	  ADD	  RGB.G,TWO_THIRD	; then, add two third GREEN		
       .ENDIF									
										
       .IF <BIT AL AND B_BIT_MASK>	; If, Blue is on			
       .THEN									
	  ADD	  RGB.B,TWO_THIRD	; then, add two third BLUE		
       .ENDIF									
										
	RET									
CGA_COL2RGB ENDP								
PAGE										
;=======================================================================	
;										
; SET_MODE_F_XLT_TAB: SET UP COLOR TRANSLATION TABLE FOR MONOCHROME		
;		      MODE "F"                                                  
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB	     = Color translation table. 			
;	       PRINTER_TYPE  = Type of printer attached (Color or B&W)		
;	       SWITCHES      = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-------------------------------------------------------------------------------
;										
; NOTES: In mode F the "VIDEO BIOS READ DOT call" returns a byte where          
; bit 1 and 3 represent the value of plane 1 and 3.				
; The following colors are available using this mode:				
;										
;		plane 2:   plane 0:	   color:				
;		   0	      0 	   black				
;		   0	      1 	   white				
;		   1	      0 	   blinking white			
;		   1	      1 	   high-intensity white 		
;										
;										
; DESCRIPTION: A local table holds the Red, Green, Blue values for each of	
; the 4 Mono colors available in Mode Fh.					
; Each color is stored as either a Grey intensity if printing in Monochrome	
; or as a Band Mask if printing in color.					
; Black is stored as black.							
; White is stored as a light gray						
; High-intensity white and blinking white are stored as white.			
;										
;										
; LOGIC:									
; FOR EACH "COLOR" AVAILABLE WITH MODE F                                        
; GET ITS R,G,B VALUES								
; CALL RGB2XLT_TAB		; Convert RGB to an entry in the translation	
;				; table 					
;										
SET_MODE_F_XLT_TAB PROC NEAR							
	PUSH	AX								
	PUSH	SI								
	PUSH	DI								
	JMP	SHORT SET_MODE_F_BEGIN						
;-------------------------------------------------------------------------------
;										
; TABLE OF R,G,B VALUES WE ASSIGN TO THE 4 COLORS AVAILABLE IN MODE F:		
;										
;-------------------------------------------------------------------------------
MODE_F_RGB	LABEL	BYTE							
	DB	BLACK_INT,BLACK_INT,BLACK_INT ; Black is mapped to black.	
	DB	TWO_THIRD,TWO_THIRD,TWO_THIRD ; White		--> light grey	
	DB	WHITE_INT,WHITE_INT,WHITE_INT ; Blinking	--> white	
	DB	WHITE_INT,WHITE_INT,WHITE_INT ; High-int. White --> white	
;-------------------------------------------------------------------------------
;										
; STORE THE COLORS AVAILABLE WITH MODE F					
;										
;-------------------------------------------------------------------------------
SET_MODE_F_BEGIN:								
	MOV	SI,OFFSET MODE_F_RGB	; SI <-- Offset of RGB table		
	XOR	DI,DI			; DI <-- Index into translation table	
										
;-------For each color available in mode F:					
STORE_1_MODE_F_COLOR:								
	MOV	AL,[SI] 		; Get the Red component 		
	MOV	RGB.R,AL							
	MOV	AL,[SI]+1		; Get the Green component		
	MOV	RGB.G,AL							
	MOV	AL,[SI]+2		; Get the Blue component		
	MOV	RGB.B,AL							
										
;-------Convert pixel to either a Color band or an Intensity:			
	CALL	RGB2XLT_TAB		; Convert and store in the xlt table	
										
	ADD	SI,3			; Get next R,G,B values 		
	INC	DI			; One more color has been stored	
	CMP	DI,NB_COLORS		; All stored ?				
	JL	STORE_1_MODE_F_COLOR						
										
	POP	DI								
	POP	SI								
	POP	AX								
	RET									
SET_MODE_F_XLT_TAB ENDP 							
PAGE										
;=======================================================================	
;										
; SET_MODE_13H_XLT_TAB: SET UP COLOR TRANSLATION TABLE FOR PALACE VIDEO 	
;		      ADAPTER IN MODE 13H					
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB	      = Color translation table.			
;	       PRINTER_TYPE   = Type of printer attached (Color or B&W) 	
;	       SWITCHES       = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-----------------------------------------------------------------------	
;										
; NOTES: With the PALACE the "VIDEO BIOS READ DOT call" returns a direct        
; index to the 256 COLOR REGISTERS.						
;										
; These COLORS REGISTERS hold the R,G,B (Red, Green, Blue) values for		
; each of the 256 colors available at the same time on the screen.		
; Color register number 0 holds the background color.				
;										
; DESCRIPTION: Store a color mapping for each color register.			
; If the REVERSE_SW is off,  exchange white and black.				
;										
; LOGIC:									
;										
; For each color (0 to 255)							
;   Read the color register	; get the RGB values for this color num.	
;   Store the result in the XLT_TAB						
;										
SET_MODE_13H_XLT_TAB PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	DI								
										
	MOV	NB_COLORS_TO_READ,256	; Read 256 color registers		
										
;-------------------------------------------------------------------------------
;										
; Store in the translation table each color available for mode 13h:		
;										
;-------------------------------------------------------------------------------
	XOR	DI,DI			; DI := Palette register number 	
					;  and index in the translation table	
STORE_1_M13H_COLOR:								
	MOV	BX,DI			; BX := Color register to be read	
	MOV	AX,GET_C_REG_CALL	; AX := BIOS Get color register call	
	INT	10H			; Call BIOS				
	MOV	RGB.R,DH		; Get Red value 			
	MOV	RGB.G,CH		; Get Green value			
	MOV	RGB.B,CL		; Get Blue value			
	CALL	RGB2XLT_TAB		; Convert RGB to an entry in XLT_TAB	
	INC	DI			; Get next palette register number	
	CMP	DI,NB_COLORS_TO_READ	; All colors stored ?			
	JL	STORE_1_M13H_COLOR	; No, get next one			
										
										
	POP	DI								
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
NB_COLORS_TO_READ DW ?		; Number of colors registers to read with a PS/2
SET_MODE_13H_XLT_TAB ENDP							
PAGE										
;===============================================================================
;										
; SET_ROUNDUP_XLT_TAB: SET UP COLOR TRANSLATION TABLE FOR ROUNDUP VIDEO 	
;		       ADAPTER							
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: XLT_TAB	       = Color translation table.			
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       SWITCHES        = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-------------------------------------------------------------------------------
;										
; NOTES: With the ROUNDUP the "VIDEO BIOS READ DOT call" returns an             
; index into the 16 PALETTE REGISTERS.						
;										
; Each palette register holds an index into the current "color page"            
; within the 256 COLOR REGISTERS.						
;										
; These "color pages" represent all the colors from WHICH TO CHOOSE the         
; screen colors for an active page; 16 colors can be displayed at the		
; same time on the screen.							
;										
; There are 2 paging modes: either 64 color pages or 16 color pages:		
;										
; In 64 color mode, there are 4 color pages available (the 256 palette		
; registers are partitioned in 4 blocks of 64 colors).				
;										
; The 16 screen colors for the active page are selected from these 64		
; color registers.								
;										
; This scheme allows for quickly changing the contents of the screen by 	
; changing the active page.							
;										
; The COLOR REGISTERS contains the color information stored as RGB (Red,	
; Green, Blue) components. There is one byte for each of these 3		
; components.  The value for each component ranges from 0 to 63 (where		
; 0 = color not present).							
;										
;										
; DESCRIPTION: Determine the paging mode and the active color page.		
; For each color available with the current mode, get the palette		
; register and then, read the corresponding color register in order to		
; obtain its RGB components.							
;										
; For mode 11h, 2 colors only are available. These colors are obtained from	
; palette register 0 (background) and 7 (foreground color). The contents	
; of these 2 palette registers is also used as an index within the color	
; registers.									
;										
; If printing is Monochrome, map the RGB to a Grey Intensity.			
; If printing is in colors, map the RGB to a Band Mask. 			
; Store the result in the translation table					
;										
; LOGIC:									
;										
; Read color page state (BIOS INT 10H - AL = 1AH)				
;										
; If mode 4,5 or 6								
; Then										
;   CALL SET_CGA_XLT_TAB							
;   Adjust the background color.						
; else										
; If mode 11h									
; then										
; For PALETTE_INDEX := 0 to 15							
; IF PAGE_MODE = PAGE_64_REGISTERS						
;   THEN									
;   Read the palette register number "PALETTE_INDEX"                            
;   COLOR_INDEX := Palette register contents					
;   COLOR_INDEX := (CUR_PAGE_NUM * 64) + COLOR_INDEX				
;   Read color register number "COLOR_INDEX"    ; Obtain R,G,B values.          
;   CALL    RGB2XLT_TAB       ; Convert RGB to an entry in XLT_TAB		
;										
; ELSE IF PAGE_MODE = PAGE_16_REGISTERS 					
;   COLOR_INDEX := (CUR_PAGE_NUM * 16) + PALETTE_INDEX				
;   Read color register number "COLOR_INDEX"                                    
;   CALL    RGB2XLT_TAB       ; Convert RGB to an entry in XLT_TAB		
;										
;										
SET_ROUNDUP_XLT_TAB PROC NEAR							
PAGING_MODE_64 EQU 0								
										
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DI								
										
;-------------------------------------------------------------------------------
; Obtain the color page state							
;-------------------------------------------------------------------------------
	MOV	AX,PAGE_STATE_CALL	  ; Call BIOS				
	INT	10H			  ;  BL := Paging mode			
					  ;  BH := Current page 		
										
;-------------------------------------------------------------------------------
; Check the video mode: 							
;-------------------------------------------------------------------------------
.SELECT 									
.WHEN <CUR_MODE EQ 4> OR		  ; If the current mode is an old CGA	
.WHEN <CUR_MODE EQ 5> OR		  ;  mode:				
.WHEN <CUR_MODE EQ 6>			  ;					
;-------------------------------------------------------------------------------
;										
; Old CGA graphics mode (mode 4, 5 or 6)					
;										
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; Store colors of the old CGA modes:						
;-------------------------------------------------------------------------------
	CALL	SET_CGA_XLT_TAB 	; Set up colors in the translation	
					;  table, NOTE: The background color	
					;   will not be set properly since the	
					;    PS/2 BIOS does not update memory	
					;     location 40:66 with the value	
					;      of the background color as CGA	
					;	does for modes 4 and 5. However 
					;	 40:66 holds the current palette
					;	  selected.			
;-------------------------------------------------------------------------------
; Adjust the background color for modes 4,5 or 6				
;-------------------------------------------------------------------------------
	MOV	PAL_REGISTER_NB,0	; Read the palette register number 0	
	CALL	GET_PALETTE_RGB 	;  this register points to the color	
					;   register that contains the RGB	
					;    values of the BACKGROUND color.	
	MOV	DI,0			; DI := Index in the translation table	
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
										
.WHEN  <CUR_MODE EQ 11H>							
;-------------------------------------------------------------------------------
;										
; Mode 11h (2 colors out of 256,000 colors)					
;										
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; Get the background color:							
;-------------------------------------------------------------------------------
	MOV	PAL_REGISTER_NB,0	; Read the palette register number 0	
	CALL	GET_PALETTE_RGB 	; Get the RGB values for this color	
	MOV	DI,0			; DI := Index in translation table	
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
;-------------------------------------------------------------------------------
; Get the foreground color:							
;-------------------------------------------------------------------------------
	MOV	PAL_REGISTER_NB,7	; Read the palette register for the	
					;  FOREGROUND color (palette register 7)
	CALL	GET_PALETTE_RGB 	; Get the RGB values for this color	
	MOV	DI,1			; DI := Index in translation table	
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
.OTHERWISE									
;-------------------------------------------------------------------------------
;										
; The current mode is a 16 color mode						
;										
;-------------------------------------------------------------------------------
	XOR	DI,DI			; DI := Index in translation table	
	MOV	CX,16			; 16 colors to read and store		
	MOV	PAL_REGISTER_NB,0	; Palette register to read		
STORE_1_PS2_COLOR:								
	CALL	GET_PALETTE_RGB 	; Get the RGB values for this color	
;										
;-------Convert the RGB values to band mask or intensity and store in XLT_TAB:	
										
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
	INC	DI			; Get next palette register number	
	INC	PAL_REGISTER_NB 	;					
	LOOP	STORE_1_PS2_COLOR	; Read it.				
.ENDSELECT									
										
	POP	DI								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
PAL_REGISTER_NB DB  ?			; Number of the palette register to read
SET_ROUNDUP_XLT_TAB ENDP							
										
PAGE										
;===============================================================================
;										
; GET_PALETTE_RGB:  ON THE PS/2 MODEL 50, 60 AND 80, GET THE RGB VALUES FOR A	
;		    PALETTE REGISTER BY READING THE CORRESPONDING COLOR REGISTER
;										
;-------------------------------------------------------------------------------
;										
;      INPUT:  PAL_REGISTER_NB = Palette register number			
;	       BH	       = Current page number				
;	       BL	       = Current paging mode				
;										
;      OUTPUT: RGB.R	       = The RGB values obtained from the color register
;	       RGB.G		 corresponding to the palette register specified
;	       RGB.B								
;										
;      CALLED BY: SET_ROUNDUP_XLT_TAB						
;										
;-------------------------------------------------------------------------------
GET_PALETTE_RGB PROC								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	SI								
										
	MOV	AL,BH			;  SI := Current page number		
	CBW				;					
	MOV	SI,AX			;					
;-------------------------------------------------------------------------------
;										
; Calculte the absolute number of the first Color Register for the current page:
; (calculated in SI)								
;										
;-------------------------------------------------------------------------------
.IF <BL EQ PAGING_MODE_64>		; If mode is 64 Color page		
.THEN					; then					
	MOV	CL,6			;    SI := Current page num * 64	
	SHL	SI,CL			;					
.ELSE					; else, Mode is 16 Color page		
	MOV	CL,4			;    SI := Current page num * 16	
	SHL	SI,CL			;					
.ENDIF										
										
;										
;-------Read the PALETTE REGISTER						
	MOV	BL,PAL_REGISTER_NB	; BL := Palette register to be read	
	MOV	AX,GET_P_REG_CALL	; Read palette register call		
	INT	10H			; Call BIOS,				
					;   BH := Color register index		
					;	  WITHIN the current page and is
					;	  either (0-15) or (0-63)	
					;  NOTE: SI = Absolute index (0-255) to 
					;  the first color register of the	
					;   current page and is a multiple of	
					;    either 16 or 64			
	MOV	BL,BH			; BX := Index within current color page 
	XOR	BH,BH			;					
										
;										
;-------Read the Color register:						
	OR	BX,SI			; BX := Index of Color register to read 
	MOV	AX,GET_C_REG_CALL	; Read the color register		
	INT	10H			; Call BIOS,				
	MOV	RGB.R,DH		; DH := Red value read			
	MOV	RGB.G,CH		; CH := Green value read		
	MOV	RGB.B,CL		; CL := Blue value read 		
										
	POP	SI								
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
GET_PALETTE_RGB ENDP								
PAGE										
;=======================================================================	
;										
; EGA_COL2RGB : CONVERT A COLOR FROM THE EGA TO RED GREEN BLUE VALUES		
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: AL      = 00rgbRGB    ONE BYTE WHERE BIT:			
;										
;					r = 1/3 of Red component		
;					g = 1/3 of Green component		
;					b = 1/3 of Blue component		
;					R = 2/3 of Red component		
;					G = 2/3 of Green component		
;					B = 3/3 of Blue component		
;										
;										
;	OUTPUT: RGB.R	    = RED   component (0-63)				
;		RGB.G	    = GREEN component (0-63)				
;		RGB.B	    = BLUE  component (0-63)				
;										
;	CALLED BY: SET_UP_EGA_XLT_TABLE 					
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: Sums up the values for each color component.			
; "2/3 of RED" means that the red gun in the display attached to the EGA        
; is firing at 2/3 of full intensity.						
;										
; Since the color intensities range from 0 to 63, "1/3" means an                
; intensity of: 								
;		 1/3 * 63 = 21							
;										
; LOGIC:									
;										
; Get the red component 							
; Get the green component							
; Get the blue component							
;										
EGA_COL2RGB PROC NEAR								
;										
;-------Get the RED component	(bit 5 and 2)					
;										
;-------Check bit 2								
	MOV	RGB.R,0 							
	TEST	AL,100B 		; "R" is on ?                           
	JZ	CHECK_BIT_5		; No, check "r"                         
	ADD	RGB.R,TWO_THIRD 	; Yes, add 2/3 RED			
CHECK_BIT_5:									
	TEST	AL,100000B		; "r" is on ?                           
	JZ	CHECK_BIT_1		; No, check Green			
	ADD	RGB.R,ONE_THIRD 	; Yes, add 1/3 RED			
;										
;-------Get the GREEN component (bit 4 and 1)					
;										
CHECK_BIT_1:									
	MOV	RGB.G,0 							
	TEST	AL,10B			; "G" is on ?                           
	JZ	CHECK_BIT_4		; No, check "g"                         
	ADD	RGB.G,TWO_THIRD 	; Yes, add 2/3 GREEN			
CHECK_BIT_4:									
	TEST	AL,10000B		; "g" is on ?                           
	JZ	CHECK_BIT_0		; No, check for Blue			
	ADD	RGB.G,ONE_THIRD 	; Yes, add 1/3 GREEN			
;										
;-------Get the BLUE component (bit 3 and 0)					
;										
CHECK_BIT_0:									
	MOV	RGB.B,0 							
	TEST	AL,1B			; "B" is on ?                           
	JZ	CHECK_BIT_3		; No, check "b"                         
	ADD	RGB.B,TWO_THIRD 	; Yes, add 2/3 BLUE			
CHECK_BIT_3:									
	TEST	AL,1000B		; "b" is on ?                           
	JZ	EGA_COL2RGB_RETURN	; No, return				
	ADD	RGB.B,ONE_THIRD 	; Yes, add 1/3 BLUE			
EGA_COL2RGB_RETURN:								
	RET									
EGA_COL2RGB ENDP								
										
PAGE										
;===============================================================================
;										
; RGB2INT : MAP RED GREEN BLUE VALUES TO AN INTENSITY.				
;										
;-------------------------------------------------------------------------------
;										
;	INPUT:	RGB.R		= A RED value (0-63)				
;		RGB.G		= A GREEN value (0-63)				
;		RGB.B		= A BLUE value (0-63)				
;		DARKADJUST_VALUE= THE DARKNESS VALUE (In shared data area).	
;		SWITCHES	= Command line switches 			
;										
;	OUTPUT: AL  = THE INTENSITY  (0-63)  NOTE: 0  = BLACK			
;						   63 = BRIGHT WHITE		
;										
;	WARNING: AH IS LOST							
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION: When the RGB values for a pixel are at their maximum		
; value, what we obtain is a bright white pixel on the screen; this is		
; the brightest color achievable and therefore, its intensity is 63.		
;										
; When no color gun is firing on the display: RGB values are 0,0,0 this 	
; is no color at all and therefore maps to intensity 0. 			
;										
; For intermediate colors, experimentation has shown that the eye will		
; see blue as darker than red and red as darker than green.			
;										
; On a grey rainbow from 0 - 10  where 0 is black and 10 is white:		
;										
;     Blue  corresponds to a grey of intensity 1				
;     Red   corresponds to a grey of intensity 3				
;     Green corresponds to a grey of intensity 6				
;										
; Therefore, if we mix all 3 colors we obtain a grey of 			
; intensity 1 + 3 + 6 = 10 (i.e.,white).					
;										
;										
; LOGIC:									
;										
; Calculate the intensity							
;										
;   AL = (.6 * G) + (.3 * R) + (.1 * B) 					
;										
; Adjust Darkness								
;										
;   AL = AL + DARKADJUST_VALUE							
;										
RGB2INT PROC NEAR								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
										
	XOR	AX,AX			; AL := Current component intensity	
	XOR	BX,BX			; BX is used for calculations		
	XOR	DX,DX			; DL := Running sum for grey intensity	
										
;-------Process /R   (Reverse black and white)					
.IF <BIT DS:[BP].SWITCHES Z REVERSE_SW>  ; IF reverse is OFF			
.THEN					 ; THEN REVERSE BLACK AND WHITE:	
;-------Test if the color is BLACK						
       .IF     <RGB.R EQ BLACK_INT> AND ; If black				
       .IF     <RGB.G EQ BLACK_INT> AND ;					
       .IF     <RGB.B EQ BLACK_INT>	;					
       .THEN				; then, replace it with white		
	  MOV	  AL,WHITE_INT							
	  JMP	  SHORT RGB2INT_END						
       .ELSEIF <RGB.R EQ WHITE_INT> AND ; else if, high-intensity white 	
       .IF     <RGB.G EQ WHITE_INT> AND ;					
       .IF     <RGB.B EQ WHITE_INT>	;					
       .THEN				; then, replace it with black		
	  MOV	  AL,BLACK_INT							
	  JMP	  SHORT RGB2INT_END						
       .ELSEIF <RGB.R EQ TWO_THIRD> AND ; else if, white			
       .IF     <RGB.G EQ TWO_THIRD> AND ;					
       .IF     <RGB.B EQ TWO_THIRD>	;					
       .THEN				; then, replace it with black		
	  MOV	  AL,BLACK_INT							
	  JMP	  SHORT RGB2INT_END						
       .ENDIF									
.ENDIF										
										
;-------Calculate Green component						
	MOV	AL,RGB.G		; AL := Green component 		
	MOV	BH,6			;					
	MUL	BH			; AX := Green * 6			
	MOV	BH,10			;					
	DIV	BH			; AL := (GREEN * 6) /  10		
	ADD	DL,AL			; DL := Cumulative intensity		
	MOV	CH,AH			; CH := Cumulative remainder		
										
;-------Calculate Red component 						
	MOV	AL,RGB.R		; AL := Red component			
	MOV	BH,3			;					
	MUL	BH			; AX := Red * 3 			
	MOV	BH,10			;					
	DIV	BH			; AL := (RED * 3) /  10 		
	ADD	DL,AL			; DL := Cumulative intensity		
	ADD	CH,AH			; CH := Cumulative remainder		
										
;-------Calculate Blue component						
	MOV	AL,RGB.B		; AX := Blue component			
	XOR	AH,AH			;					
	DIV	BH			; AL := BLUE / 10			
	ADD	DL,AL			; DL := Cumulative intensity		
	ADD	CH,AH			; CH := Cumulative remainder		
										
;-------Adjust intensity with cumulative remainder				
	XOR	AX,AX								
	MOV	AL,CH			; AX := Cumulative remainder		
	MOV	BH,10			; BH := 10				
	DIV	BH			; AL := Total remainder / 10		
	ADD	DL,AL			; DL := Cumulative intensity		
       .IF <AH GT 4>			; If remainder > 4			
       .THEN				; Then, add 1				
	INC	DL			;  to the intensity			
       .ENDIF									
										
;-------Adjust darkness 							
	ADD	DL,DS:[BP].DARKADJUST_VALUE					
										
;-------Return result								
	MOV	AL,DL			; AL := sum of R,G,B intensities	
										
RGB2INT_END:									
	POP	DX								
	POP	CX								
	POP	BX								
	RET									
RGB2INT ENDP									
										
PAGE										
;============================================================================== 
;										
; RGB2BAND: MAP RED GREEN BLUE VALUES TO A "SELECT COLOR BAND" MASK FOR         
;	    THE COLOR PRINTER.							
;										
;------------------------------------------------------------------------------ 
;										
;	INPUT:	RGB.R		= A RED value (0-63)				
;		RGB.G		= A GREEN value (0-63)				
;		RGB.B		= A BLUE value (0-63)				
;		BP		= Offset of the Shared Data Area.		
;										
;	OUTPUT: AL = The Band Mask, one byte where:				
;										
;				  bit 0 = Color Band 1 is needed		
;				  bit 1 = Color Band 2 is needed		
;				  bit 2 = Color Band 3 is needed		
;				  bit 3 = Color Band 4 is needed		
;										
;										
;	CALLED BY: SET_CGA_XLT_TAB						
;		   SET_EGA_XLT_TAB						
;		   SET_ROUNDUP_XLT_TAB						
;		   SET_MODE_13H_XLT_TAB 					
;		   SET_MODE_F_XLT_TAB						
;										
;------------------------------------------------------------------------------ 
;										
; NOTES: The RGB values in input describe a color from the screen.		
; Up to 256K different colors can be described with these RGB values.		
;										
; On the color printer, the print ribbon is composed of 4 color bands,		
; each of a different color.  By overlapping these 4 bands when 		
; printing, more colors can be obtained.  However, the number of colors 	
; that can be achieved by overlapping print bands is very limited (4 or 	
; 8 colors).									
;										
; THIS MODULE SELECT THE PRINTER COLOR THAT IS THE CLOSEST TO THE		
; DESIRED SCREEN COLOR. 							
;										
; The Band Mask specifies which color bands have to be overlapped to		
; obtain a color on the printer.						
;										
;										
; DESCRIPTION: Go through the list of printer colors in the SHARED DATA 	
; AREA, for each of these colors, compare its RGB values with those in		
; input.									
; Get the BAND_MASK of the closest printer color.				
;										
; LOGIC:									
;										
; Locate the printer colors info structure in the shared data area:		
; COLORPRINT_PTR := BP + COLORPRINT_PTR 					
;										
; Get the number of printer colors from the COLORPRINT info in the Shared	
; data area:									
; Number of colors  := COLORPRINT_PTR.NUM_PRT_COLOR				
;										
; CURRENT_COLOR_PTR : First record in the COLORPRINT info structure		
; BEST_CHOICE := CURRENT_RECORD_PTR.BAND_MASK					
; MIN_DIFF    := Maximum positive value 					
;										
; FOR each printer color:							
;   CUR_DIFF	:= 0								
; (* Calculate the geometric distance between the RGB values from the *)	
; (* input and those of the printer color.			      *)	
;   Red difference   := (R - CURRENT_COLOR_PTR.RED)				
;   Red difference   := Red difference * Red difference 			
;   CUR_DIFF	     := CUR_DIFF + Red difference				
;										
;   Green difference := (G - CURRENT_COLOR_PTR.GREEN)				
;   Green difference := Green difference * Green difference			
;   CUR_DIFF	     := CUR_DIFF + Green difference				
;										
;   Blue difference  := (B - CURRENT_COLOR_PTR.BLUE)				
;   Blue difference  := Blue difference  * Blue difference			
;   CUR_DIFF	     := CUR_DIFF + Blue difference				
;										
;   IF CUR_DIFF < MIN_DIFF							
;   THEN BEGIN									
;	 MIN_DIFF	:=  CUR_DIFF						
;	 BEST_CHOICE	:=  printer color.BAND_MASK				
;	 END									
;										
;   CURRENT_COLOR_PTR := Offset of next color					
; END (For each printer color)							
;										
; Return BEST_CHOICE								
;										
;										
RGB2BAND PROC NEAR								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
										
;-------Process /R   (Reverse black and white)					
.IF <BIT DS:[BP].SWITCHES Z REVERSE_SW>  ; IF reverse is OFF			
.THEN					 ; THEN REVERSE BLACK AND WHITE:	
;------------------------------------------------------------------------------ 
;										
; REVERSE BLACK AND WHITE:							
;										
;------------------------------------------------------------------------------ 
;-------Test if the color is BLACK						
       .IF     <RGB.R EQ BLACK_INT> AND ; If black				
       .IF     <RGB.G EQ BLACK_INT> AND ;					
       .IF     <RGB.B EQ BLACK_INT>	;					
       .THEN				; then, replace it with the		
	  MOV	  BEST_CHOICE,0 	;	band mask for white		
	  JMP	  RGB2BAND_END		;	return this band mask		
       .ELSEIF <RGB.R EQ WHITE_INT> AND ; else if, high-intensity white 	
       .IF     <RGB.G EQ WHITE_INT> AND ;					
       .IF     <RGB.B EQ WHITE_INT>	;					
       .THEN				; then, replace it with the		
	  MOV	  RGB.R,BLACK_INT	;	RGB values of black		
	  MOV	  RGB.G,BLACK_INT						
	  MOV	  RGB.B,BLACK_INT						
       .ELSEIF <RGB.R EQ TWO_THIRD> AND ; else if, white			
       .IF     <RGB.G EQ TWO_THIRD> AND ;					
       .IF     <RGB.B EQ TWO_THIRD>	;					
       .THEN				; then, replace it with the		
	  MOV	  RGB.R,BLACK_INT	;	RGB values of black		
	  MOV	  RGB.G,BLACK_INT						
	  MOV	  RGB.B,BLACK_INT						
       .ENDIF									
.ENDIF										
;------------------------------------------------------------------------------ 
;										
; CALCULATE THE GEOMETRIC DISTANCE BETWEEN THE COLORS OF THE PIXEL AND THOSE OF 
; THE PRINTER:									
;										
;------------------------------------------------------------------------------ 
	MOV	BX,DS:[BP].COLORPRINT_PTR	; BX := OFFSET of COLORPRINT	
	ADD	BX,BP								
	MOV	MIN_DIFF,7FFFh			; No match yet, minimum diff.	
						;  is maximum POSITIVE value.	
	XOR	CX,CX								
	MOV	CL,DS:[BP].NUM_PRT_COLOR	; CX := Number of print colors	
										
										
INSPECT_1_PRINT_COLOR:								
	MOV	CUR_DIFF,0			; Current difference := 0	
;------------------------------------------------------------------------------ 
;	Calculate the Red difference:						
;------------------------------------------------------------------------------ 
	MOV	AL,RGB.R							
	SUB	AL,[BX].RED							
;-------Elevate at the power of two						
	MOV	DL,AL				; DX := Red difference		
	IMUL	DL				; AX := Red diff. square	
	ADD	CUR_DIFF,AX			; CURR_DIF + Red diff.		
										
;------------------------------------------------------------------------------ 
;	Calculate the Green difference: 					
;------------------------------------------------------------------------------ 
	MOV	AL,RGB.G							
	SUB	AL,[BX].GREEN							
;-------Elevate at the power of two						
	MOV	DL,AL				; DX := Red difference		
	IMUL	DL				; AX := Red diff. square	
	ADD	CUR_DIFF,AX			; CURR_DIF + Green diff.	
										
;------------------------------------------------------------------------------ 
;	Calculate the Blue difference:						
;------------------------------------------------------------------------------ 
	MOV	AL,RGB.B							
	SUB	AL,[BX].BLUE							
;-------Elevate at the power of two						
	MOV	DL,AL				; DX := Red difference		
	IMUL	DL				; AX := Red diff. square	
	ADD	CUR_DIFF,AX			; CURR_DIF + Blue diff. 	
										
;------------------------------------------------------------------------------ 
;	Check how close is this print color to the screen color:		
;------------------------------------------------------------------------------ 
	MOV	AX,CUR_DIFF		; If this color is better than what we	
       .IF <AX L MIN_DIFF>		;  had before.				
       .THEN				;					
	  MOV	  MIN_DIFF,AX		; then, new minimum distance;		
	  MOV	  AL,[BX].SELECT_MASK	;	get its band mask.		
	  MOV	  BEST_CHOICE,AL	;					
       .ENDIF				;					
										
;------------------------------------------------------------------------------ 
;	Get offset of next COLORPRINT info record:				
;------------------------------------------------------------------------------ 
	ADD	BX,SIZE COLORPRINT_STR						
	LOOP	INSPECT_1_PRINT_COLOR						
										
;------------------------------------------------------------------------------ 
;	BEST_CHOICE contains the print color with the closest RGB values	
;------------------------------------------------------------------------------ 
RGB2BAND_END:									
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	MOV	AL,BEST_CHOICE							
	RET									
BEST_CHOICE	DB	?							
MIN_DIFF	DW	?							
CUR_DIFF	DW	?							
RGB2BAND ENDP									
CODE	ENDS									
	END									

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grcommon.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I modified the procedures STORE_BOX, PRINT_BUFFER,
;**                GET_SCREEN_INFO, DET_CUR_SCAN_LNE_LENGTH, and NEW_PRT_LINE
;**                as follows.
;**  
;**                For STORE_BOX:
;**                  if data_type = data_row, then store printbox in print buffer
;**                     in row format - not column format.
;**  
;**                For PRINT_BUFFER:
;**                  if data_type = data_row, then print one byte at a time.
;**  
;**                For GET_SCREEN_INFO:
;**                  if data_type = data_row
;**                          nb_boxes_per_prt_buf = 8/box_height
;**                          if print_options = rotate
;**                                  nb_scan_lines = screen_width
;**                          else
;**                                  nb_scan_lines = screen_height
;**                          endif
;**                  endif
;**  
;**                For DET_CUR_SCAN_LNE_LENGTH:
;**                  if data_type = data_row
;**                          don't go down the columns to determine the scan_line_length
;**                  endif
;**  
;**                For NEW_PRT_LINE:
;**                  Altered it so send escape number sequence, COUNT or LOWCOUNT and
;**                  HIGHCOUNT, if they are specified before the new keyword DATA.
;**  
;**  
;**                I added the the procedures END_PRT_LINE and GET_COUNT, which
;**                are described below.
;**            
;**                END_PRT_LINE sends escape number sequence, COUNT or LOWCOUNT and
;**                HIGHCOUNT, if they are specified after the new keyword DATA
;**                in the GRAPHICS statement of the profile.  It also sends a
;**                CR & LF for IBM type printers if needed.
;**  
;**                GET_COUNT gets the number of bytes that are going to be sent to the
;**                printer and converts the number to ASCII if DATA_TYPE = DATA_ROW.
;**  
;**  BUG NOTES:     The   following   bug   was  fixed   for   the   pre-release  
;**                 version Q.01.02.
;**  
;**  BUG (mda003)
;**  ------------
;**  
;**  NAME:     GRAPHICS   prints  a CR & LF after  each  scan line unless it  is 
;**            loaded twice.  
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD3.ASM - PARSE_GRAPHICS
;**                                GRCOMMON.ASM - END_PRT_LINE
;**                                GRSHAR.STR - N/A
;**  
;**  CAUSES:   The local variables LOWCOUNT_FOUND, HIGHCOUNT_FOUND CR_FOUND  and 
;**            LF_FOUND used for loading, were incorrectly being used as  global 
;**            variables during printing.
;**  
;**  FIX:      Created  a new variable Printer_Needs_CR_LF in GRSHAR.STR,  which 
;**            is  used  to  determine  in GRCOMMON.ASM  if  it's  necessary  to 
;**            manually  send  a  CR  & LF to the printer  at  print  time.  The 
;**            variable  is  set at load time in GRLOAD3.ASM, if  the  variables 
;**            Data_Found and Build_State are set. 
;**  
;**  DOCUMENTATION NOTES:  This version of GRCOMMON.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;************************************************************
	PAGE	,132								;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRCOMMON.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;										;AN000;
;;	 This file contains the modules common to the Print Screen		;AN000;
;;	 process of GRAPHICS.COM.						;AN000;
;;	 This file is included by both set of Print modules.			;AN000;
;;										;AN000;
;;	 This file MUST BE COMPILED WITH EACH SET OF MODULES since,		;AN000;
;;	 one set is relocated in memory at installation time; all		;AN000;
;;	 references to the common procedures must be resolved from		;AN000;
;;	 within each set of print modules.					;AN000;
;;										;AN000;
;;	 The set of common modules is relocated in memory along with		;AN000;
;;	 the selected set of print modules.					;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	READ_DOT								;AN000;
;;	LOC_MODE_PRT_INFO							;AN000;
;;	STORE_BOX								;AN000;
;;	PRINT_BUFFER								;AN000;
;;	GET_SCREEN_INFO 							;AN000;
;;	SETUP_PRT								;AN000;
;;	RESTORE_PRT								;AN000;
;;	NEW_PRT_LINE								;AN000;
;;	PRINT_BYTE								;AN000;
;;	DET_CUR_SCAN_LNE_LENGTH 						;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;;              Added the following procedures to support printers with horizontal
;;              printer heads, such as an HP PCL printers.
;;      GET_COUNT
;;      END_PRT_LINE
; /\ ~~mda(001) -----------------------------------------------------------------------
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRCTRL.ASM: 						;AN000;
;;	      PRT_SCR	       - Main module for printing the screen.		;AN000;
;;	 FROM FILE  GRBWPRT.ASM:						;AN000;
;;	      PRT_BW_APA       - Main module for printing on BW printer.	;AN000;
;;	 FROM FILE  GRCOLPRT.ASM:						;AN000;
;;	      PRINT_COLOR      - Main module for printing on COLOR printer.	;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;										;AN000;
;;	 This file is included by both GRBWPRT.ASM and GRCOLPRT.ASM and is	;AN000;
;;	 compiled with each of them. However, only one copy is made resident.	;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; LOC_MODE_PRT_INFO: LOCATE DISPLAYMODE PRINTER INFO. FOR THE CURRENT		;AN000;
;		     MODE							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP		= Offset of the shared data area		;AN000;
;		CUR_MODE	= Current video mode				;AN000;
;										;AN000;
;	OUTPUT: CUR_MODE_PTR	= Absolute Offset of the			;AN000;
;				  current DISPLAYMODE INFO record.		;AN000;
;										;AN000;
;		ERROR_CODE	= DISPLAYMODE_INFO_NOT_FOUND if not found.	;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRINT_BW_APA 						;AN000;
;										;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:	DISPLAYMODE_PTR is pointing to the first DISPLAYMODE		;AN000;
; INFO record within the Shared Data Area.					;AN000;
;										;AN000;
; This (chained) list of DISPLAYMODE records is scanned until the record	;AN000;
; for the current mode is found.						;AN000;
;										;AN000;
; Note: All pointers in the DISPLAYMODE records are relative to the beginning	;AN000;
;	of the shared data area. Therefore, we must add the offset of the	;AN000;
;	shared data area (in BP) in order to access the data these pointers	;AN000;
;	are referencing.							;AN000;
;										;AN000;
;	The CUR_MODE_PTR is relative to the segment and references the		;AN000;
;	DISPLAYMODE record for the video mode currently set at print screen	;AN000;
;	time.									;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; FOUND := FALSE								;AN000;
; DO UNTIL FOUND OR END_OF_LIST 						;AN000;
;   Get a display mode information record					;AN000;
;   IF record.DISP_MODE = CUR_MODE						;AN000;
;     THEN FOUND := TRUE							;AN000;
;   ELSE									;AN000;
;     CUR_MODE_PTR := record.NEXT_DISP_MODE					;AN000;
;										;AN000;
;										;AN000;
										;AN000;
LOC_MODE_PRT_INFO PROC NEAR							;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
										;AN000;
	MOV	BX,DS:[BP].DISPLAYMODE_PTR	; [BX] := Current DISPLAYMODE	;AN000;
	ADD	BX,BP				;	   record		;AN000;
	MOV	DL,CUR_MODE			; DL := Current mode		;AN000;
										;AN000;
SCAN_1_DISPLAYMODE_RECORD:							;AN000;
	MOV	SI,[BX].DISP_MODE_LIST_PTR	; [SI] : First mode covered	;AN000;
	ADD	SI,BP				;    by this DISPLAYMODE record ;AN000;
	MOV	CL,[BX].NUM_DISP_MODE		; Scan each mode in the list	;AN000;
	XOR	CH,CH								;AN000;
SCAN_LIST_OF_MODES:								;AN000;
	CMP	CS:[SI],DL			; FOUND ?			;AN000;
	JE	FOUND								;AN000;
	INC	SI				; NO, get next mode in		;AN000;
	LOOP	SCAN_LIST_OF_MODES		;      DISPLAYMODE record	;AN000;
										;AN000;
	CMP	[BX].NEXT_DISP_MODE,-1		; END OF DISPLAYMODE LIST ?	;AN000;
	JE	NOT_FOUND			; Yes, this mode not supported	;AN000;
NEXT_RECORD:					; No,				;AN000;
	MOV	BX,[BX].NEXT_DISP_MODE		;     [BX] := Next record	;AN000;
	ADD	BX,BP				;				;AN000;
	JMP	SHORT SCAN_1_DISPLAYMODE_RECORD 				;AN000;
										;AN000;
FOUND:						; Found:			;AN000;
	MOV	CUR_MODE_PTR,BX 		; Update pointer to current	;AN000;
	JMP	SHORT LOC_MODE_PRT_INFO_END	; DISPLAYMODE record.		;AN000;
										;AN000;
NOT_FOUND:					; Not found:			;AN000;
	MOV	ERROR_CODE,DISPLAYMODE_INFO_NOT_FOUND ; Return error condition	;AN000;
										;AN000;
LOC_MODE_PRT_INFO_END:								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
LOC_MODE_PRT_INFO ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; STORE_BOX : STORE ONE BOX IN THE PRINT BUFFER.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	SI	   = OFFSET OF THE BOX TO BE PRINTED			;AN000;
;		BOX_W	   = BOX WIDTH IN BITS					;AN000;
;		BOX_H	   = BOX HEIGHT IN BITS 				;AN000;
;										;AN000;
;	OUTPUT: PRT_BUF  = THE PRINT BUFFER					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: The print buffer is first shifted left in order to make		;AN000;
; room for the new box (Note: the MSB's are lost; they are assumed to           ;AN000;
; have been printed), then the box is inserted in the low-order bits of 	;AN000;
; the printer buffer.								;AN000;
;										;AN000;
PAGE										;AN000;
;			      EXAMPLE						;AN000;
;			      -------						;AN000;
; BEFORE:				     AFTER:				;AN000;
;										;AN000;
; BOX: 0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      b1  b2  b3								;AN000;
;      b4  b5  b6								;AN000;
;										;AN000;
; PRT_BUF: byte1 byte2 byte3		     PRT_BUF:  byte1 byte2 byte3	;AN000;
;	     0	   1	 0				 1     1     1		;AN000;
;	     1	   0	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 b1    b2    b3 	;AN000;
;    LSB --> 1	   1	 1				 b4    b5    b6 	;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; FOR each byte of the buffer (BOX_W)						;AN000;
;   BEGIN									;AN000;
;   Make room for the box to be inserted					;AN000;
;   Insert the box								;AN000;
;   END 									;AN000;
;										;AN000;
STORE_BOX PROC NEAR								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DI								;AN000;
										;AN000;
	MOV	DI,OFFSET PRT_BUF ; DI := Offset of the Print buffer		;AN000;
       	XOR	BX,BX		        ; BX := Byte index number			;AN000;

; \/ ~~mda(001) -----------------------------------------------------------------------
;               Added the following modification to support printers with
;               vertical print heads, such as HP PCL printers.  The code
;               as is does not work for these printers because the data
;               is being stored in the print buffer with the assumption
;               that the print head is vertical.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>
                PUSH    AX              ; 
                PUSH    DX              ;
                PUSH    BP              ;
                MOV     CL,BOX_W        ; Make room for the bits to be inserted.
                SHL     BYTE PTR [BX][DI],CL    ;
                MOV     CL,DS:[BP].ROW_TO_EXTRACT       ; CL determines which row we're extracting
                XOR     BP,BP           ; Point to first column.
                XOR     DX,DX           ; Clear counter
                XOR     AX,AX           ; Clear register
                                        ;
EXTRACT_NEXT_BIT:                       ;
                                        ;
                SHL     AH,1            ; Make room for next bit
                MOV     AL,DS:[SI][BP]  ; Read column
                SHR     AL,CL           ; Get bit from row we're extracting
                AND     AL,1            ; Isolate bit we got from row we're extracting
                OR      AH,AL           ; Place it in AH
                INC     BP              ; Advance to next column
                INC     DL              ; Inc. counter
                CMP     DL,BOX_W        ; Check if have more bits to extract from the row
                JL      EXTRACT_NEXT_BIT; We do
                OR      DS:[DI][BX],AH  ; We don't so place the row we extracted in the 
                                        ; print buffer.
                POP     BP              ;
                POP     DX              ; 
                POP     AX              ;
       .ELSE                            ;
; /\ ~~mda(001) -----------------------------------------------------------------------
										        ;AN000;
	        MOV	CL,BOX_H	        ; CL := Number of BITS to be shifted		;AN000;
; FOR each column (byte) of the box to be stored in the buffer: 		;AN000;
STORE_1_BYTE:				        					;AN000;
	        SHL	BYTE PTR [BX][DI],CL	; Make room for the bits to be inserted ;AN000;
	        MOV	CH,[BX][SI]		; CH := column of the box to be inserted;AN000;
	        OR	[BX][DI],CH		; Insert the box column in the buffer	;AN000;
	        INC	BL			; Get next column (byte) of the box	;AN000;
	        CMP	BL,BOX_W		; All columns (bytes) of box stored ?	;AN000;
	        JL	STORE_1_BYTE		; No, store next one.			;AN000;
       .ENDIF                                   ; ~~mda(001) Close the IF stmt										        ;AN000;
STORE_BOX_END:									;AN000;
	POP	DI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
STORE_BOX ENDP									;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_BUFFER : PRINT THE BUFFER						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	PRT_BUF  = BYTES TO BE PRINTED					;AN000;
;		BOW_W	 = BOX WIDTH						;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Prints BOX_W bytes.						;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; DO for each column in one pattern						;AN000;
;   BEGIN									;AN000;
;   Print one byte from the buffer						;AN000;
;   END 									;AN000;
;										;AN000;
PRINT_BUFFER PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	BX,OFFSET PRT_BUF						;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               If DATA_TYPE = DATA_ROW then the most we store in the print
;               buffer at one time is one byte.
.IF <DS:[BP].DATA_TYPE EQ DATA_ROW>     ;
	MOV	AL,[BX] 	        ; Print one byte				
	CALL	PRINT_BYTE		;					
	JC	PRINT_BUFFER_END        ; If printer error, quit the loop	
.ELSE
; /\ ~~mda(001) -----------------------------------------------------------------------
	XOR	CX,CX								;AN000;
	MOV	CL,BOX_W							;AN000;
PRINT_1_BUF_COLUMN:								;AN000;
	MOV	AL,[BX] 	; Print one byte				;AN000;
	CALL	PRINT_BYTE							;AN000;
	JC	PRINT_BUFFER_END; If printer error, quit the loop		;AN000;
	INC	BX		; Get next byte 				;AN000;
	LOOP	PRINT_1_BUF_COLUMN						;AN000;
.ENDIF                          ;~~mda(001) close IF stmt
PRINT_BUFFER_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_BUFFER ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; GET_SCREEN_INFO : GET INFORMATION ABOUT HOW TO READ THE SCREEN.		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	SCREEN_HEIGHT	  = Number of pixel rows on the screen		;AN000;
;		SCREEN_WIDTH	  = Number of pixel columns on screen		;AN000;
;		CUR_MODE_PTR	  = Offset of the current DISPLAYMODE info rec. ;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;		SCAN_LINE_MAX_LENGTH = Maximum length of Screen scan line.	;AN000;
;		NB_SCAN_LINES	  = Number of SCAN LINES on the screen		;AN000;
;		CUR_ROW,CUR_COLUMN = Coordinates of the first pixel to be	;AN000;
;					 read on the screen			;AN000;
;		NB_BOXES_PER_PRT_BUF = Number of boxes fitting in the Print	;AN000;
;				       buffer					;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRT_BW_APA							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:									;AN000;
;										;AN000;
;    1) Determine where to start reading the screen.				;AN000;
;	For non-rotated printing, it should start with the top-left		;AN000;
;	corner pixel.								;AN000;
;	For rotated printing, it should start with the low-left corner		;AN000;
;	pixel.									;AN000;
;										;AN000;
;    2) Determine the length of a scan line.					;AN000;
;	For non-rotated printing, it is the WIDTH of the screen.		;AN000;
;	For rotated printing, it is the HEIGHT of the screen.			;AN000;
;										;AN000;
;    3) Determine the number of scan lines on the screen.			;AN000;
;	For non-rotated printing, it is the HEIGHT of the screen divided	;AN000;
;	by the number of boxes fitting in the print buffer.			;AN000;
;	For rotated printing, it is the WIDTH of the screen divided by		;AN000;
;	the number of boxes fitting in the print buffer.			;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; CUR_COLUMN   := 0								;AN000;
; IF printing is sideways							;AN000;
;   THEN									;AN000;
;     CUR_ROW := SCREEN_HEIGHT - 1	  ; Low-left pixel			;AN000;
;     SCAN_LINE_MAX_LENGTH := SCREEN_HEIGHT					;AN000;
;     NB_SCAN_LINES :=	SCREEN_WIDTH / NB_BOXES_PER_PRT_BUF			;AN000;
;   ELSE									;AN000;
;     CUR_ROW := 0			  ; Top-left pixel			;AN000;
;     SCAN_LINE_MAX_LENGTH := SCREEN_WIDTH					;AN000;
;     NB_SCAN_LINES :=	SCREEN_HEIGHT / NB_BOXES_PER_PRT_BUF			;AN000;
;										;AN000;
;										;AN000;
GET_SCREEN_INFO PROC NEAR							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX			; Used for DIV				;AN000;
	PUSH	DX			; Used for DIV				;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Offset DISPLAYMODE info record	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Calculate how many printer boxes fit in the print buffer:			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               The NB_BOXES_PER_PRT_BUF depends on if the printer head is
;               vertical, as in IBM's case, or if it's horizontal, as in
;               HP's case.  If DATA_TYPE is DATA_COL, then we have a vertical
;               print head.  If DATA_TYPE is DATA_ROW, then we have a 
;               horizontal print head.
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ; Print head is horizontal
            MOV	AX,8			; Num := 8 bits / Box width		
            MOV	DL,[BX].BOX_WIDTH	;					
            DIV	DL			;					
            MOV	NB_BOXES_PER_PRT_BUF,AL ;					
       .ELSE                            ;
; /\ ~~mda(001) -----------------------------------------------------------------------
	    MOV	AX,8			; Num := 8 bits / Box heigth		;AN000;
	    MOV	DL,[BX].BOX_HEIGHT						;AN000;
	    DIV	DL								;AN000;
	    MOV	NB_BOXES_PER_PRT_BUF,AL 					;AN000;
       .ENDIF                           ; ~~mda(001) Close IF stmt.
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Determine where to start reading the screen:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	CUR_COLUMN,0		; Reading always start from left of scr ;AN000;
.IF <[BX].PRINT_OPTIONS EQ ROTATE>						;AN000;
.THEN										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Printing is sideways; screen must be read starting in low-left corner.	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AX,SCREEN_HEIGHT						;AN000;
	MOV	SCAN_LINE_MAX_LENGTH,AX ; Scan line length := screen height	;AN000;
	DEC	AX								;AN000;
	MOV	CUR_ROW,AX		; First row := screen height - 1	;AN000;
										;AN000;
;-------Calculate the number of scan lines:					;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               The NB_SCAN_LINES depends on if the printer head is
;               vertical, as in IBM's case, or if it's horizontal, as in
;               HP's case.  If the printer head is horizontal, then we can't
;               make use of the concept of scan lines.  However, we can still
;               use the symbol NB_SCAN_LINES by just stuffing into it the
;               screen width.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ; Print head is horizontal
            MOV	        AX,SCREEN_WIDTH ; DX AX = Screen width			
            CWD                         ;
            MOV         NB_SCAN_LINES,AX;
       .ELSE
; /\ ~~mda(001) -----------------------------------------------------------------------        
            MOV	        AX,SCREEN_WIDTH         ; DX AX = Screen width			;AN000;
	    CWD				        ;					;AN000;
	    XOR	        BX,BX		        ; BX	= Number of boxes per print buf ;AN000;
	    MOV	        BL,NB_BOXES_PER_PRT_BUF ;					;AN000;
	    DIV	        BX			; Screen width / number boxes per buff	;AN000;
	    MOV	        NB_SCAN_LINES,AX	; Number of scan lines := result	;AN000;
           .ENDIF                               ; ~~mda(001) Close IF stmt.

.ELSE										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Printing is not sideways; screen must be read starting in top-left corner	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AX,SCREEN_WIDTH 						;AN000;
	MOV	SCAN_LINE_MAX_LENGTH,AX ; Scan line length := screen width	;AN000;
	MOV	CUR_ROW,0		; First row := 0			;AN000;
										;AN000;
;-------Calculate the number of scan lines:					;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               The NB_SCAN_LINES depends on if the printer head is
;               vertical, as in IBM's case, or if it's horizontal, as in
;               HP's case.  If the printer head is horizontal, then we can't
;               make use of the concept of scan lines.  However, we can still
;               use the symbol NB_SCAN_LINES by just stuffing into it the
;               screen height.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ; Print head is vertical
            MOV	        AX,SCREEN_HEIGHT; DX AX = Screen height			
            CWD                         ;
            MOV         NB_SCAN_LINES,AX;
       .ELSE
; /\ ~~mda(001) -----------------------------------------------------------------------        
 
	MOV	AX,SCREEN_HEIGHT	; DX AX = Screen height 		;AN000;
	CWD				;					;AN000;
	XOR	BX,BX			; BX  = Number of boxes per print buff	;AN000;
	MOV	BL,NB_BOXES_PER_PRT_BUF ;					;AN000;
	DIV	BX			; Screen height/number boxes per buff.	;AN000;
	MOV	NB_SCAN_LINES,AX	; Number of scan lines := result	;AN000;
       .ENDIF                           ; ~~mda(001) Close IF stmt.

.ENDIF										;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
GET_SCREEN_INFO ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; DET_CUR_SCAN_LNE_LENGTH : Determine where is the last non-blank "scan line    ;AN000;
;				column" on the current scan line.               ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;     INPUT:  CUR_ROW,								;AN000;
;	      CUR_COLUMN	  = Coordinates of the top pixel of the current ;AN000;
;				    scan line.					;AN000;
;	      XLT_TAB		  = Color translation table			;AN000;
;										;AN000;
;     OUTPUT: CUR_SCAN_LNE_LENGTH = Number of "columns" of pixels from the      ;AN000;
;				    beginning of the scan line up to		;AN000;
;				    the last non-blank pixel.			;AN000;
;										;AN000;
; DATA	      SCREEN_WIDTH,							;AN000;
; REFERENCED: SCREEN_HEIGHT	  = Dimensions of the screen in pels		;AN000;
;	      SCAN_LINE_MAX_LENGTH= Maximum length of the scan line		;AN000;
;	      ROTATE_SW 	  = ON if printing is sideways			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Determine where is the last non-blank "column" by reading        ;AN000;
; the scan line backwards, one column at a time.				;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; ; Obtain coordinates for the top pixel of the last column on the current	;AN000;
; ; scan line:									;AN000;
; IF printing is sideways							;AN000;
;   THEN									;AN000;
;   CUR_ROW := 0								;AN000;
; ELSE										;AN000;
;   CUR_COLUMN := SCREEN_WIDTH - 1						;AN000;
;										;AN000;
; CUR_SCAN_LNE_LENGTH := SCAN_LINE_MAX_LENGTH					;AN000;
; ; Read a column of pixels on the scan line until a non-blank is found:	;AN000;
; For each column on the screen 						;AN000;
;   CALL FILL_BUFF								;AN000;
; ; Check if PRT_BUF is empty							;AN000;
;   IF buffer is empty								;AN000;
;     THEN DEC	CUR_SCAN_LNE_LENGTH						;AN000;
;	   ; Get next column							;AN000;
;	   IF printing sideways THEN DEC CUR_ROW				;AN000;
;				ELSE DEC CUR_COLUMN				;AN000;
;   ELSE quit the loop								;AN000;
;										;AN000;
DET_CUR_SCAN_LNE_LENGTH PROC NEAR						;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	CUR_ROW 							;AN000;
										;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of XLT_TAB		;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Obtain coordinates of the top pixel for the last column of the current	;AN000;
; scan line:									;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				; then, 				;AN000;
	  MOV	  CUR_ROW,0		;   CUR_ROW := 0			;AN000;
       .ELSE				; else, 				;AN000;
	  MOV	  CX,SCREEN_WIDTH	;   CUR_COLUMN := SCREEN_WIDTH - 1	;AN000;
	  DEC	  CX			;					;AN000;
	  MOV	  CUR_COLUMN,CX 	;					;AN000;
       .ENDIF									;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Read the scan line backwards "column" by "column" until a non-blank is found: ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	CX,SCAN_LINE_MAX_LENGTH ; CX := current length			;AN000;
;										;AN000;
;-------For each "column"                                                       ;AN000;
CHECK_1_COLUMN: 								;AN000;
	MOV	SI,CUR_ROW		; Save coordinates of the column	;AN000;
	MOV	DI,CUR_COLUMN		; in SI, DI				;AN000;
	XOR	DL,DL			; DL := Number of pixels verified in	;AN000;
					;	  one "column"                  ;AN000;
;										;AN000;
;-------For each pixel within that "column"                                     ;AN000;
CHECK_1_PIXEL:									;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask or Intensity		;AN000;
										;AN000;
;-------Check if pixel will map to an empty box:				;AN000;
       .IF <DS:[BP].PRINTER_TYPE EQ BLACK_WHITE> ; If BLACK AND WHITE printer	;AN000;
       .THEN				; then, check for intensity of white	;AN000;
	  CMP	  AL,WHITE_INT		;      If curent pixel not blank	;AN000;
	  JNE	  DET_LENGTH_END	;      THEN, LEAVE THE LOOP		;AN000;
       .ELSE				; else, COLOR printer			;AN000;
	  OR	  AL,AL 		;      IF Band mask not blank		;AN000;
	  JNZ	  DET_LENGTH_END	;      THEN, LEAVE THE LOOP		;AN000;
       .ENDIF									;AN000;
										;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Only if DATA_TYPE is DATA_COL do we have "columns",
;               so skip this section otherwise.
       .IF <DS:[BP].DATA_TYPE EQ DATA_COL> ; Print head is vertical
; /\ ~~mda(001) ----------------------------------------------------------------------- 
;-------All pixels so far on this "column" are blank, get next pixel:           ;AN000;
               .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
               .THEN				;					;AN000;
	                INC CUR_COLUMN		; then, increment column number 	;AN000;
               .ELSE				;					;AN000;
	                INC CUR_ROW			; else, increment row number		;AN000;
               .ENDIF				;					;AN000;
	        INC	DL			; One more pixel checked		;AN000;
	        CMP	DL,NB_BOXES_PER_PRT_BUF ; All pixels for that column done ?	;AN000;
	        JL	CHECK_1_PIXEL		;   No, check next one. 		;AN000;
       .ENDIF                                   ;~~mda(001) Close IF stmt.
										;AN000;
;-------Nothing to print for this column, get next column			;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				; then, 				;AN000;
	  MOV CUR_COLUMN,DI		;   Restore column number		;AN000;
	  INC CUR_ROW			;   Get next row			;AN000;
       .ELSE				; else, 				;AN000;
	  MOV CUR_ROW,SI		;   Restore row number			;AN000;
	  DEC CUR_COLUMN		;   Get next column			;AN000;
       .ENDIF				;					;AN000;
	LOOP CHECK_1_COLUMN		; CX (length) := CX - 1 		;AN000;
										;AN000;
DET_LENGTH_END: 								;AN000;
	MOV	CUR_SCAN_LNE_LENGTH,CX	; Get current length			;AN000;
										;AN000;
	POP	CUR_ROW 							;AN000;
	POP	CUR_COLUMN							;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
DET_CUR_SCAN_LNE_LENGTH ENDP							;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SETUP_PRT : SET UP THE PRINTER FOR PRINTING IN GRAPHIC MODE			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		;AN000;
;			      record for the current mode			;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRT_BW_APA							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Extract the SETUP escape sequence from the DISPLAYMODE		;AN000;
; information record; Send this escape sequence to the printer. 		;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Number of bytes to print := CUR_MODE_PTR.NUM_SETUP_ESC			;AN000;
;										;AN000;
; Get the escape sequence:							;AN000;
; SI := CUR_MODE_PTR.SETUP_ESC_PTR						;AN000;
;										;AN000;
; FOR each byte to be printed							;AN000;
;   PRINT_BYTE [SI]			; Send the byte to the printer		;AN000;
;   INC SI				; Get the next byte			;AN000;
;										;AN000;
SETUP_PRT PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	;AN000;
										;AN000;
	XOR	CX,CX			; CX := Number of bytes to print	;AN000;
	MOV	CL,[BX].NUM_SETUP_ESC	;					;AN000;
.IF <CL G 0>				; If there is at least one		;AN000;
.THEN					; byte to be printed:			;AN000;
	MOV	BX,[BX].SETUP_ESC_PTR	; BX := Offset sequence to send 	;AN000;
	ADD	BX,BP								;AN000;
										;AN000;
SEND_1_SETUP_BYTE:								;AN000;
	MOV	AL,[BX] 		; AL := byte to print			;AN000;
	CALL	PRINT_BYTE		; Send it to the printer		;AN000;
	JC	SETUP_PRT_END		; If printer error, quit the loop	;AN000;
	INC	BX			; Get next byte 			;AN000;
	LOOP	SEND_1_SETUP_BYTE						;AN000;
.ENDIF										;AN000;
SETUP_PRT_END:									;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
SETUP_PRT ENDP									;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; RESTORE_PRT : RESTORE THE PRINTER TO ITS INITIAL STATUS			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		;AN000;
;				 record for the current mode			;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRT_BW_APA							;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Extract the RESTORE escape sequence from the DISPLAYMODE 	;AN000;
; information record; Send this escape sequence to the printer. 		;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Number of bytes to print := CUR_MODE_PTR.NUM_RESTORE_ESC			;AN000;
;										;AN000;
; Get the escape sequence:							;AN000;
; SI := CUR_MODE_PTR.RESTORE_ESC_PTR						;AN000;
; FOR each byte to be printed							;AN000;
;   PRINT_BYTE [SI]			; Send the byte to the printer		;AN000;
;   INC SI				; Get the next byte			;AN000;
;										;AN000;
RESTORE_PRT PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	;AN000;
										;AN000;
	XOR	CX,CX			; CX := Number of bytes to print	;AN000;
	MOV	CL,[BX].NUM_RESTORE_ESC 					;AN000;
.IF <CL G 0>				; If there is at least one		;AN000;
.THEN					; byte to be printed:			;AN000;
	MOV	BX,[BX].RESTORE_ESC_PTR ; BX := Offset sequence to send 	;AN000;
	ADD	BX,BP								;AN000;
										;AN000;
SEND_1_RESTORE_BYTE:								;AN000;
	MOV	AL,[BX] 		; AL := byte to print			;AN000;
	CALL	PRINT_BYTE		; Send it to the printer		;AN000;
	JC	RESTORE_PRT_END 	; If printer error, quit the loop	;AN000;
	INC	BX			; Get next byte 			;AN000;
	LOOP	SEND_1_RESTORE_BYTE						;AN000;
.ENDIF										;AN000;
RESTORE_PRT_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
RESTORE_PRT ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; NEW_PRT_LINE : INITIALIZE THE PRINTER FOR A GRAPHIC LINE			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		;AN000;
;				 record for the current mode			;AN000;
;	       CUR_SCAN_LNE_LENGTH = Number of bytes to send to the printer.	;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;	CALLED BY: PRINT_BAND							;AN000;
;		   PRT_BW_APA							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Extract the GRAPHICS escape sequence from the DISPLAYMODE	;AN000;
; information record; Send this escape sequence to the printer. 		;AN000;
; Then, send the number of bytes that will follow.				;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Number of bytes to print := CUR_MODE_PTR.NUM_GRAPHICS_ESC			;AN000;
;										;AN000;
; Get the escape sequence:							;AN000;
; Set up the 2 bytes containing the number of bytes to send in this sequence.	;AN000;
; SI := CUR_MODE_PTR.GRAPHICS_ESC_PTR						;AN000;
;										;AN000;
; FOR each byte to be printed							;AN000;
;   PRINT_BYTE [SI]			; Send the byte to the printer		;AN000;
;   INC SI				; Get the next byte			;AN000;
;										;AN000;
; Send the byte count								;AN000;
;										;AN000;
										;AN000;
NEW_PRT_LINE PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	DI								;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set up the 2 bytes containing the number of bytes to send in the GRAPHICS seq.;AN000;
; NOTE: number of bytes to send is "CUR_SCAN_LNE_LENGTH * BOX_W"                ;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AL,BOX_W		;   cur_scan_lne_length *		;AN000;
	CBW				;   printer box width = nb bytes to send;AN000;
	MUL	CUR_SCAN_LNE_LENGTH	;     (result in DX AX) 		;AN000;
;-------AX := Number of bytes to print						;AN000;

; \/ ~~mda(001) -----------------------------------------------------------------------
;               Since we have added the key words DATA and COUNT to the		
;               list of allowable words for the GRAPHICS statement
;               we have to take into consideration if the esc. sequence
;               numbers come before of after the word DATA.  Also we have
;               to take into consideration if the printer is expecting
;               to receive the COUNT in binary form or in ASCII form.
;               Note this section of code replaces the section of code
;               which follows it.
        MOV     DI,[BX].GRAPHICS_ESC_PTR        ; DI := offset seq. to send
	XOR	CX,CX				; CX := Length of the escape seq
        MOV	CL,[BX].NUM_GRAPHICS_ESC	;	before the word DATA			
        
       .WHILE <CX NE 0>         ; Doing while loop just in case DATA is the 
                                ; first word after  GRAPHICS.  In that case 
                                ; skip this and send the actual data.
                 MOV    BL,BYTE PTR DS:[BP+DI]            ; Get code.
                                                          ;
                .SELECT                                   ; Case statement
                .WHEN <BL EQ ESC_NUM_CODE>                ; We have an esc. number
       	                PUSH      AX                      ; Save count
                        INC       DI                      ; Point to esc. number
                        MOV       AL,DS:[BP+DI]           ;
                        CALL      PRINT_BYTE              ; Send esc. number
                        JC        NEW_PRT_LINE_ENDP_1     ; If printer error then quit 
                                                          ; the loop and restore registers
                        INC       DI                      ; Point to next tag
                        POP       AX                      ; Restore the count
                        DEC       CX                      ;
                .WHEN <BL EQ COUNT_CODE>                  ; Need to send count in ascii form
       	                PUSH      AX                      ; Save count
                        PUSH      SI                      ;
                        CALL      GET_COUNT               ; Get # bytes to send to printer
                        PUSH      CX                      ; Save counter for outside loop
                        XOR       CH,CH                   ;
                        MOV       CL,DS:[BP].NUM_BYTES_FOR_COUNT        ;
                        LEA       SI,DS:[BP].COUNT        ; Get ptr. to count
                        SUB       SI,CX                   ; Need to send MSB first
                        INC       SI                      ;
                        CLD                               ;
SEND_ASCII_COUNT:                                         ;
                        LODSB                             ;
                        CALL      PRINT_BYTE              ; Print it
                        JC        NEW_PRT_LINE_ENDP_2     ; If printer error then quit 
                                                          ; the loop and restore registers
                        LOOP      SEND_ASCII_COUNT        ;
                        POP       CX                      ; Restore outside loop counter
                        ADD       DI,2                    ; Point to next tag
                        POP       SI                      ;
                        POP       AX                      ; Restore COUNT
                        DEC       CX                      ;
                .WHEN <BL EQ LOWCOUNT_CODE>               ; Sending lowbyte of COUNT 
                        CALL      PRINT_BYTE              ; Print it
                        JC        NEW_PRT_LINE_ENDP       ; If printer error then quit 
                        ADD       DI,2                    ; Point to next tag
                        DEC       CX                      ;
                .WHEN <BL EQ HIGHCOUNT_CODE>              ; Sending highbyte of COUNT
       	                PUSH      AX                      ; Save count 
                        CWD                               ;
                        MOV       BX,100h                 ;
                        DIV       BX                      ; Put highbyte in AL
                        CALL      PRINT_BYTE              ; Print it
                        JC        NEW_PRT_LINE_ENDP_1     ; If printer error then quit 
                                                          ; the loop and restore registers
                        ADD       DI,2                    ; Point to next tag
                                                          ; the loop.
                        POP       AX                      ; Restore count
                        DEC       CX                      ;
                .ENDSELECT                                ;
       .ENDWHILE                                          ;
        ADD	DI,2                                      ; Skip over DATA tag and byte 
                                                          ; so pointing to correct place when 
                                                          ; get to END_PRT_LINE proc.
; /\ ~~mda(001) -----------------------------------------------------------------------

; \/ ~~mda(001) -----------------------------------------------------------------------
;               The following piece of code is replaced by the above piece
;               of code.
;
;;;;    MOV	DI,[BX].LOW_BYT_COUNT_PTR; DI := Offset of LOW byte of		;AN000;
;;;;	ADD	DI,BP			;	 byte count			;AN000;
;;;;	MOV	[DI],AL 		; Store low byte			;AN000;
;;;;	MOV	DI,[BX].HGH_BYT_COUNT_PTR; DI := Offset of HIGH byte of 	;AN000;
;;;;	ADD	DI,BP			;	 byte count			;AN000;
;;;;	MOV	[DI],AH 		; Store high byte			;AN000;
;;;;										;AN000;
;;;;;-------------------------------------------------------------------------------;AN000;
;;;;; Send the GRAPHICS escape sequence to the printer:				;AN000;
;;;;;-------------------------------------------------------------------------------;AN000;
;;;;	XOR	CX,CX				; CX := Length of the escape seq;AN000;
;;;;	MOV	CL,[BX].NUM_GRAPHICS_ESC					;AN000;
;;;;	MOV	BX,[BX].GRAPHICS_ESC_PTR	; BX := Offset sequence to send ;AN000;
;;;;	ADD	BX,BP								;AN000;
;;;;										;AN000;
;;;;SEND_1_GRAPHICS_BYTE:							;AN000;
;;;;	MOV	AL,[BX] 		; AL := byte to print			;AN000;
;;;;	CALL	PRINT_BYTE		; Send it to the printer		;AN000;
;;;;	JC	NEW_PRT_LINE_ENDP	; If printer error, quit the loop	;AN000;
;;;;	INC	BX			; Get next byte 			;AN000;
;;;;	LOOP	SEND_1_GRAPHICS_BYTE						;AN000;
; /\ ~~mda(001) -----------------------------------------------------------------------
JMP     SHORT  NEW_PRT_LINE_ENDP               ; ~~mda(001) Restore registers
        JMP     SHORT  NEW_PRT_LINE_ENDP       ;
NEW_PRT_LINE_ENDP_2:                    ; ~~mda(001) 
        POP     SI
NEW_PRT_LINE_ENDP_1:			; ~~mda(001) 
        POP     AX
NEW_PRT_LINE_ENDP:								;AN000;
	POP	DI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
NEW_PRT_LINE ENDP								;AN000;
PAGE										;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Since we have the keyword DATA, and we allow it to be anywhere
;               on the GRAPHICS line, then it is possible to have an
;               esc. sequence to send to the printer after the data has been
;               sent.  Therefore we need this new procedure.
;===============================================================================
;										
; END_PRT_LINE : SEND THE REST OF THE GRAPHICS LINE			        
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		
;    			      record for the current mode			
;              DI           = Points to the section of the esc. seq that
;                             comes after the keyword DATA.
;										
;	OUTPUT: PRINTER 							
;										
;	CALLED BY: PRT_BW_APA							
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION: Extract the GRAPHICS escape sequence that comes after the keyword
; DATA from the DISPLAYMODE information record; Send this escape sequence to the
; printer. 		                                                        
;										
;										

CR_FOUND        DB      ?       ; So we know if a carriage return has been sent
LF_FOUND        DB      ?       ; So we know if a line feed has been sent

END_PRT_LINE PROC NEAR								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	DI								
										
        MOV     CR_FOUND,NO             ; Initialize
        MOV     LF_FOUND,NO             ; 
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	
										
;-------------------------------------------------------------------------------
; Set up the 2 bytes containing the number of bytes to send in the GRAPHICS seq.
; NOTE: number of bytes to send is "CUR_SCAN_LNE_LENGTH * BOX_W"                
;-------------------------------------------------------------------------------
	MOV	AL,BOX_W		;   cur_scan_lne_length *		
	CBW				;   printer box width = nb bytes to send
	MUL	CUR_SCAN_LNE_LENGTH	;     (result in DX AX) 		
;-------AX := Number of bytes to print						

	XOR	CX,CX				        ; CX := Length of the escape seq
        MOV	CL,[BX].NUM_GRAPHICS_ESC_AFTER_DATA	;after the word DATA		
        

       .WHILE <CX NE 0>         ; Doing a while loop just in case DATA is the 
                                ; last word on the GRAPHICS line.  In that case 
                                ; skip this and send a CR or LF if needed.
                 MOV    BL,BYTE PTR DS:[BP+DI]            ; Get code.

                .SELECT                                   ; Case statement
                .WHEN <BL EQ ESC_NUM_CODE>                ; We have an esc. number
       	                PUSH      AX                      ; Save count
                        INC       DI                      ; Point to esc. number
                        MOV       AL,DS:[BP+DI]           ;
                       .IF <AL EQ CR>                     ; Check if a CR is 
                            MOV     CR_FOUND,YES          ; explicitly stated
                       .ENDIF
                       .IF <AL EQ LF>                     ; Check if a LF is 
                            MOV     LF_FOUND,YES          ; explicitly stated
                       .ENDIF
                        CALL      PRINT_BYTE              ; Send esc. number
                        JC        GOTO_END_PRT_LINE_ENDP_1; If printer error then quit 
                                                          ; the loop and restore registers
                        INC       DI                      ; Point to next tag
                        POP       AX                      ; Restore the count
                        DEC       CX                      ;
                .WHEN <BL EQ COUNT_CODE>                  ; Need to send count in ascii form
       	                PUSH      AX                      ; Save count
                        PUSH      SI                      ;
                        CALL      GET_COUNT               ; Get # of bytes to send to printer
                        PUSH      CX                      ; Save counter for outside loop
                        XOR       CH,CH                   ;
                        MOV       CL,DS:[BP].NUM_BYTES_FOR_COUNT     ;
                        LEA       SI,DS:[BP].COUNT        ; Get ptr. to count
                        SUB       SI,CX                   ; Need to send MSB first
                        INC       SI                      ;
                        CLD                               ;
SEND_THE_ASCII_COUNT:                                     ;
                        LODSB                             ;
                        CALL      PRINT_BYTE              ; Print it
                        JC        GOTO_END_PRT_LINE_ENDP_2     ; If printer error then quit 
                                                          ; the loop and restore registers.
                        LOOP      SEND_THE_ASCII_COUNT    ;
                        POP       CX                      ; Restore outside loop counter
                        ADD       DI,2                    ; Point to next tag
                        POP       SI                      ;
                        POP       AX                      ; Restore COUNT
                        DEC       CX                      ;
                .WHEN <BL EQ LOWCOUNT_CODE>               ; Sending lowbyte of COUNT 
                        CALL      PRINT_BYTE              ; Print it
                        JC        END_PRT_LINE_ENDP       ; If printer error then quit 
                        ADD       DI,2                    ; Point to next tag
                        DEC       CX                      ;
                .WHEN <BL EQ HIGHCOUNT_CODE>              ; Sending highbyte of COUNT
       	                PUSH      AX                      ; Save count
                        CWD                               ;
                        MOV       BX,100h                 ;
                        DIV       BX                      ; Put highbyte in AL
                        CALL      PRINT_BYTE              ; Print it
                        JC        END_PRT_LINE_ENDP_1     ; If printer error then quit
                                                          ; the loop and restore registers
                        ADD       DI,2                    ; Point to next tag
                                                          ; the loop.
                        POP       AX                      ; Restore count
                        DEC       CX                      ;
                .ENDSELECT                                ;
       .ENDWHILE                                          ;
        JMP     SHORT  CR_LF                              ;
GOTO_END_PRT_LINE_ENDP_2:                                 ; Conditional jump was out of range
        JMP     SHORT  END_PRT_LINE_ENDP_2                ;
GOTO_END_PRT_LINE_ENDP_1:                                 ; Conditional jump was out of range
        JMP     SHORT END_PRT_LINE_ENDP_1                 ;
CR_LF:                                                    ;
       .IF <DS:[BP].PRINTER_NEEDS_CR_LF EQ YES>           ; ~~mda(003) We have an IBM type printer  
                                                          ; so we need to do a CR and LF if it 
                                                          ; already hasn't been done.
               .IF <CR_FOUND EQ NO>                       ; It hasn't been done.
                        MOV       AL,CR                   ;
                        CALL      PRINT_BYTE              ;
                        JC        END_PRT_LINE_ENDP       ; If printer error then quit 
               .ENDIF                                     ;
               .IF <LF_FOUND EQ NO>                       ; It hasn't been done.
                        MOV       AL,LF                   ;
                        CALL      PRINT_BYTE              ;
                        JC        END_PRT_LINE_ENDP       ; If printer error then quit 
               .ENDIF                                     ;       
                                                          ;
       .ENDIF                                             ;
JMP     NEW_PRT_LINE_ENDP                                 ; Restore registers
        JMP     SHORT   END_PRT_LINE_ENDP                 ;
END_PRT_LINE_ENDP_2:                                      ; Restore registers										
        POP     SI                                        ;
END_PRT_LINE_ENDP_1:			                  ; Restore registers							
        POP     AX                                        ;
END_PRT_LINE_ENDP:					  ;			
	POP	DI					  ;			
	POP	DX					  ;			
	POP	CX					  ;			
	POP	BX					  ;			
	POP	AX					  ;			
	RET						  ;			
END_PRT_LINE ENDP					  ;			
; /\ ~~mda(001) -----------------------------------------------------------------------
PAGE										;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Since we now can do HP PCL, we have to get the number of
;               bytes that are going to be sent to the printer and convert 
;               the number to ASCII if DATA_TYPE = DATA_ROW.
;===============================================================================;AN000;
;										;AN000;
; GET_COUNT : GET THE NUMBER OF BYTES TO SEND TO THE PRINTER 
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_SCAN_LNE_LENGTH
;              NB_BOXES_PER_PRT_BUF                                            ;AN000;
;										;AN000;
;       output : si	pointer to ascii string
;
;	         si  --> len=4    (hex = 4d2h)
;		         1
;		         2
;		         3
;		         4
;
;	         count (from shared_data_area)
;
;										;AN000;
;	CALLED BY: NEW_PRT_LINE
;                  END_PRT_LINE
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_COUNT 	proc	near
		push	ax	       ;
		push	bx	       ;
		push	cx	       ;
		push	dx	       ;
                push    si             ;

                mov     ax,cur_scan_lne_length  ; Get # bytes to send to
                cwd                             ; the printer
                xor     bh,bh                   ;
                mov     bl,nb_boxes_per_prt_buf ; 
                div     bx                      ;
               .IF <DX NE 0>                    ; So don't lose data when
                     INC        AX              ; have a remainder.
               .ENDIF                           ;

                                                ;
;--------- AX is the # bytes to send to the printer. Now convert it to ascii.
                                                ;
		xor	dx,dx	                ;clear upper 16 bits
		lea	si,ds:[bp].count        ;get pointer
                PUSH    SI                      ; Save ptr.
                MOV     CX,5                    ; Init. COUNT
INIT_COUNT:                                     ;
                MOV     BYTE PTR [SI],0         ;
                DEC     SI                      ;
                LOOP    INIT_COUNT              ;
                POP     SI                      ;
                                                ;
		mov	bx,10	                ; mod 10, div 10
		xor	cx,cx	                ;length counter = 0
hx_asc:                                         ;
		div	bx	                ;div, mod
		add	dl,'0'                  ;add 48 for ASCII
		mov	[si],dl                 ;store it
		dec	si	                ;point to next string element
		inc	cx	                ;inc length counter
		xor	dx,dx	                ;consider only div part for next loop
		cmp	ax,0	                ;end of loops ? (div=0)
		jnz	hx_asc	                ;no
                mov     ds:[bp].num_bytes_for_count,cl     ;save the length
                                                ;
                pop     si                      ;
		pop	dx	                ;
		pop	cx	                ;
		pop	bx	                ;
		pop	ax	                ;
		ret                             ;
GET_COUNT 	endp                            ;
; /\ ~~mda(001) -----------------------------------------------------------------------
PAGE                                            
;
;===============================================================================;AN000;
;										;AN000;
; PRINT_BYTE : SEND A BYTE TO THE PRINTER AT LPT1				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	AL		= Byte to be printed				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;		ERROR_CODE	= PRINTER_ERROR if an error is detected.	;AN000;
;		Carry flag is set in case of error.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_BYTE PROC    NEAR 							;AN000;
	PUSH	AX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
	MOV	DX,0000 	; PRINTER NUMBER				;AN000;
	MOV	AH,00		; REQUEST PRINT 				;AN000;
	INT	17H		; CALL BIOS : SEND THE CHARACTER		;AN000;
										;AN000;
	AND	AH,00101001B	; Test error code returned in AH for		;AN000;
				;   "Out of paper", "I/O error" and "Time-out". ;AN000;
	JNZ	PRINT_BYTE_ERROR; Set the error code if error			;AN000;
	JMP	SHORT PRINT_BYTE_END ; else, return normally			;AN000;
PRINT_BYTE_ERROR:								;AN000;
	MOV	ERROR_CODE,PRINTER_ERROR					;AN000;
	STC			; Set the carry flag to indicate ERROR		;AN000;
PRINT_BYTE_END: 								;AN000;
	POP	DX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_BYTE ENDP 								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; READ_DOT: READ A PIXEL - RETURN A COLOR TRANSLATION TABLE INDEX		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	CUR_MODE   = Current video mode.				;AN000;
;		CUR_ROW,							;AN000;
;		CUR_COLUMN = Coordinates of the pixel to be read.		;AN000;
;		CUR_PAGE   = Active page number 				;AN000;
;										;AN000;
;	OUTPUT: AL	   = Index into COLOR TRANSLATION TABLE.		;AN000;
;										;AN000;
;	DEPENDENCIES : COLOR TRANSLATION TABLE entries must be bytes		;AN000;
;										;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Use VIDEO BIOS INTERRUPT 10H "READ DOT CALL".                    ;AN000;
;										;AN000;
; Depending on the video hardware, the dot returned by BIOS has 		;AN000;
; different meanings.								;AN000;
; With an EGA it is an index into the Palette registers,			;AN000;
; With a CGA it is a number from 0 to 3,  mapping to a specific color		;AN000;
; depending on the background color and the color palette currently		;AN000;
; selected.									;AN000;
;										;AN000;
; The Color Translation table has been set up to hold the correct color 	;AN000;
; mapping for any "dot" in any mode.  Therefore, the dot number returned        ;AN000;
; by INT 10H can be used with any mode as a direct index within that		;AN000;
; table.									;AN000;
;										;AN000;
; With APA Monochrome mode 0FH there are 4 different dots: white,		;AN000;
; blinking white, high-intensity white, and black.				;AN000;
;										;AN000;
; For mode 0FH, the dot returned by interrupt 10 "read dot" call is a byte      ;AN000;
; where only bits 0 and 2 are significant.  These 2 bits must be appended	;AN000;
; together in order to obtain a binary number (from 0 to 3) that will be used	;AN000;
; as an index in the Color Translation table.					;AN000;
;										;AN000;
; For mode 11H, the dot is either 0 (for background color) or 7 (for the	;AN000;
; foreground color) only the LSB is returned.  That is, we return either	;AN000;
; 0 or 1.									;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Call VIDEO BIOS "READ DOT"                                                    ;AN000;
; IF CUR_MODE = 0FH								;AN000;
; THEN										;AN000;
;   Append bits 1 and 3.							;AN000;
; IF CUR_MODE = 11H								;AN000;
; THEN										;AN000;
;   Wipe out bits 1 and 2.							;AN000;
;										;AN000;
READ_DOT PROC NEAR								;AN000;
	PUSH	BX			; Save registers			;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
	MOV	BH,CUR_PAGE							;AN000;
	MOV	DX,CUR_ROW							;AN000;
	MOV	CX,CUR_COLUMN							;AN000;
	MOV	AH,READ_DOT_CALL						;AN000;
	INT	10H			; Call BIOS: AL <-- Dot read		;AN000;
										;AN000;
	CMP	CUR_MODE,0FH		; Is it Mode 0fH ?			;AN000;
	JNE	MODE_11H?		; No, look for mode 11h.		;AN000;
;-------Mode 0Fh is the current mode:						;AN000;
;-------Convert bits 2 and 0 into a 2 bit number:				;AN000;
	MOV	BL,AL			; BL := AL = "Pixel read"               ;AN000;
	AND	BL,00000100B		; Wipe off all bits but bit 2 in BL	;AN000;
	AND	AL,00000001B		; Wipe off all bits but bit 0 in AL	;AN000;
	SHR	BL,1			;  Move bit 2 to bit 1 in BL		;AN000;
	OR	AL,BL			;  Append bit 1 and bit 0		;AN000;
	JMP	SHORT READ_DOT_END	;  Quit.				;AN000;
										;AN000;
MODE_11H?:									;AN000;
	CMP	CUR_MODE,11H		; Is it Mode 0fH ?			;AN000;
	JNE	READ_DOT_END		; No, quit				;AN000;
										;AN000;
;-------Mode 11H is the current mode:						;AN000;
	AND	AL,00000001B		; Keep only the Least significant bit	;AN000;
										;AN000;
READ_DOT_END:									;AN000;
	POP	DX			; Restore registers			;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
READ_DOT ENDP									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\graphics.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Command Entry Point
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; MS DOS GRAPHICS Command
;;                                      
;;										;AN000;
;; File Name:  GRAPHICS.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the GRAPHICS command entry point.			;AN000;
;;	 A jump is made to the GRAPHICS_INSTALL procedure			;AN000;
;;	 in file GRINST.ASM to begin installation processing.			;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRINST.EXT - Externals for GRINST.ASM					;AN000;
;;										;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRINST.ASM: 						;AN000;
;;	      GRAPHICS_INSTALL - Main module for installation.			;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 LINK GRAPHICS GRINT2FH GRPATTRN GRCTRL GRCPSD GRCOLPRT GRBWPRT 	;AN000;
;;	      GRINST GRPARSE grparms GRLOAD GRLOAD2 GRLOAD3;			;AN000;
;;	 EXE2BIN GRAPHICS.EXE GRAPHICS.COM					;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;	A000 - Denotes 4.00 level source.					;AN000;
;;	A001 - PTM1779 - invalid parm msg followed by garbage			;AN001;
;;	       Module affected: GRPARMS.ASM					;AN001;
;;	A002 - PTM2666 - Release environment string before terminating. 	;AN002;
;;	       Module affected: GRINST.ASM					;AN002;
;;	A003 - PTM3915 - Change to include common copyright file.
;;	       Module affected: GRAPHICS.ASM
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
	ORG   100H		       ;; required for .COM			;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
START:				       ;;					;AN000;
				       ;;					;AN000;
	JMP   GRAPHICS_INSTALL	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;
;	INCLUDE COPYRIGH.INC	       ;; included in message services		;AN003;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
CODE   ENDS									;AN000;
       END    START								;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grbwprt.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I added code to the procedures PRINT_BW_PRT and FILL_BUFFER 
;**                to handle the support of HP PCL printers.   I used the algorithm
;**                below for PRINT_BW_PRT.
;**  
;**                  if data_type = data_row
;**                          if cur_scan_lne_length = 0 goto next_coordinates
;**                                  for i:=1 to box_h
;**                                          call new_prt_line
;**                                          save regs.
;**                                          save cur_row & cur_column
;**                                          for j:=1 to cur_scan_lne_lenght/nb_boxes_per_prt_buf 
;**                                          (+1 if remainder)
;**                                                  call fill_buffer
;**                                                  call print_buffer
;**                                          end_for
;**                                          call end_prt_line
;**                                          restore cur_column & cur_row
;**                                          restore regs.
;**                                  end_for
;**                          restore regs.
;**  next_coordinates:       if rotate_sw = on
;**                                  inc cur_column
;**                          else
;**                                  inc cur_row
;**                          endif
;**                  else
;**                        .
;**                        .
;**                        .
;**                          call end_prt_line       ; Print CR & LF
;**                        .
;**                        .
;**                        .
;**                  endif
;**  
;**  DOCUMENTATION NOTES:  This version of GRBWPRT.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE ,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Black and White printing modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRBWPRT.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the code for printing a GRAPHICS screen on a	;AN000;
;;	 BLACK and WHITE printer.						;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;										;AN000;
;;	PRINT_BW_APA								;AN000;
;;	  FILL_BUFFER								;AN000;
;;	    INT2PAT								;AN000;
;;	    PAT2BOX								;AN000;
;;										;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRCTRL.EXT   - Externals for print screen control			;AN000;
;;	 GRCTRL.STR   - Structures and equates for print screen control 	;AN000;
;;	 GRPATTRN.STR - Structures for the printer patterns.			;AN000;
;;										;AN000;
;;	 GRSHAR.STR   - Shared Data Area Structure				;AN000;
;;										;AN000;
;;	 STRUC.INC    - Macros for using structured assembly language		;AN000;
;;										;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRCTRL.ASM: 						;AN000;
;;	      PRT_SCR - Main module for printing the screen.			;AN000;
;;	 TO FILE GRCOMMON.ASM							;AN000;
;;	      Common modules - tools for printing a screen.			;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 This file is included by GRCTRL.ASM					;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
PAGE										;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME		CS:CODE,DS:CODE 					;AN000;
										;AN000;
	PUBLIC	PRINT_BW_APA							;AN000;
	PUBLIC	LEN_OF_BW_MODULES						;AN000;
										;AN000;
.XLIST										;AN000;
INCLUDE GRCTRL.STR			; Stuctures needed			;AN000;
INCLUDE GRSHAR.STR			;  for both set of print modules	;AN000;
INCLUDE GRPATTRN.STR			;					;AN000;
INCLUDE GRCTRL.EXT			; Externals from PRT_SCR control module ;AN000;
INCLUDE STRUC.INC			;					;AN000;
										;AN000;
	PUBLIC PRINT_BW_APA		; Black and white modules,		;AN000;
.LIST										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_BW_APA : PRINT A GRAPHIC MODE SCREEN ON A BLACK AND WHITE PRINTER	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP	 = Offset of the shared data area			;AN000;
;		XLT_TAB  = Color translation table				;AN000;
;		BIOS_INT_5H = Pointer to BIOS int 5h				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:	This procedure	maps  each  pixel of the screen to a box	;AN000;
; of dots on the printer.  The box size depends on the screen resolution	;AN000;
; and  the number  of  bytes per printer line.	It is chosen in order to	;AN000;
; respect the  screen ratio and  is  documented in each printer profile.	;AN000;
;										;AN000;
;     For efficiency and space considerations, the print buffer does not	;AN000;
; hold a full print line.  Bytes representing pixels are printed as soon	;AN000;
; as they are  ready to be printed.  However, the print buffer	is  wide	;AN000;
; enough to hold complete boxes.						;AN000;
;										;AN000;
;     The order  for reading  pixels  off the screen  is  driven  by the	;AN000;
; order bytes  are  expected by the printer.  To print the screen in its	;AN000;
; original orientation we must begin reading it from the top left corner	;AN000;
; and  send  the pixels line by line; to print it sideways, reading will	;AN000;
; start from the bottom left  corner and a "LINE" will now be a vertical        ;AN000;
; screen column read from bottom to top.					;AN000;
;										;AN000;
;     There is	more  to it  however, the  printer  head  is  printing a	;AN000;
; vertical  column of 8 dots  at a time and each pixel read is mapped to	;AN000;
; a box of dots  that is less than  8 dots high  (e.g., 2 cols	x 1 row)	;AN000;
; therefore, many boxes must be stored in the bytes sent to the printer.	;AN000;
;										;AN000;
;     These boxes represent pixels that are one above each other on  the	;AN000;
; screen. We must read enough pixels on one column of the screen to  use	;AN000;
; all 8 bits of the vertical printer head (e.g., if the box size  is 2x1	;AN000;
; then 8  pixels  must be read	and  2 bytes of the print buffer will be	;AN000;
; filled).									;AN000;
;										;AN000;
;     The  PRINT BUFFER  for  any  box size  will be 8 bits high by "BOX        ;AN000;
; WIDTH" bits wide.                                                             ;AN000;
;										;AN000;
;     After the buffer is filled, it is  printed  and  the next "column"        ;AN000;
; of  8 pixels	is read.  Therefore,  the screen  is read "line by line"        ;AN000;
; where a line is  8 pixels high  for a 2x1 box (4 pixels high for a 3x2	;AN000;
; box).  ONE SUCH LINE IS CALLED A SCAN LINE.					;AN000;
;										;AN000;
PAGE										;AN000;
;										;AN000;
; A 350X200 screen mapping to a 3x2 box is read in the following order: 	;AN000;
;										;AN000;
; SCREEN:									;AN000;
;										;AN000;
;	  column column    . . .	column					;AN000;
;	  no. 0  no. 1			no. 349 				;AN000;
;	 ͻ				;AN000;
;  scan  1(0,0) 5(0,1) 	       1397(0,349)				;AN000;
;  line  2(1,0) 6(1,1)  . . . . . . . 1398(1,349)				;AN000;
;  no. 1 3(2,0) 7(2,1) 	       1399(2,349)				;AN000;
;	 4(3,0) 8(3,1) 	       1400(3,349)				;AN000;
;	 					  				;AN000;
;  scan  1401(4,0) 1405(4,1)			      LEGEND:	n(X,Y)		;AN000;
;  line  1402(5,0)   etc,			  				;AN000;
;  no. 2 1403(6,0)	     . . . . .		      n = READ RANK		;AN000;
;	 1404(7,0)				      X = ROW NUMBER		;AN000;
;	     . 				      Y = COLUMN NUMBER	;AN000;
;   etc,     . 				  				;AN000;
;	     . 		    70000(199,349)				;AN000;
;	 ͼ				;AN000;
;										;AN000;
;										;AN000;
; LOGIC :									;AN000;
;										;AN000;
; Initialize printer and local variables.					;AN000;
; CALL	  LOC_MODE_PRT_INFO ; Get printer info related to current mode. 	;AN000;
; CALL	  GET_SCREEN_INFO   ; Get info. about how to read the screen		;AN000;
; CALL	  SETUP_PRT	    ; Set up the printer (Line spacing, etc)		;AN000;
;										;AN000;
; FOR each scan line on the screen (NB_SCAN_LINES)				;AN000;
;   (Note: One scan line maps to one print line)				;AN000;
;   BEGIN									;AN000;
;   CALL DET_CUR_SCAN_LNE_LENGTH ; Determine length in pels of the current	;AN000;
;			  ;  scan line. 					;AN000;
;   IF CUR_SCAN_LNE_LENGTH NE 0 THEN						;AN000;
;     CALL NEW_PRT_LINE     ; Initialize a new printer line			;AN000;
;     DO CUR_SCAN_LNE_LENGTH times ; For each column				;AN000;
;	BEGIN									;AN000;
;	CALL FILL_BUFFER    ; Read top-down enough pels to fill the buffer	;AN000;
;	CALL PRINT_BUFFER   ; Print the buffer					;AN000;
;	IF printing sideways THEN INC CUR_ROW	 ; Get coordinates of next	;AN000;
;			     ELSE INC CUR_COLUMN ;  "column" (vertical chunk of ;AN000;
;	END (for each column)			 ;   a scan line).		;AN000;
;   PRINT_BYTE CR	  ; Print a CR and a LF 				;AN000;
;   PRINT_BYTE LF								;AN000;
;   ; Get coordinates of next scan line:					;AN000;
;   IF printing sideways THEN							;AN000;
;			      ADD CUR_COLUMN,NB_BOXES_PER_PRT_BUF		;AN000;
;			      MOV CUR_ROW,SCREEN_HEIGHT - 1			;AN000;
;			 ELSE							;AN000;
;			      ADD CUR_ROW,NB_BOXES_PER_PRT_BUF			;AN000;
;			      MOV CUR_COLUMN,0					;AN000;
;   END (for each scan line)							;AN000;
;										;AN000;
PRINT_BW_APA PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; INITIALIZATION:								;AN000;
;										;AN000;
;	1) Locate and extract printer DISPLAYMODE information from		;AN000;
;	   the shared data area, calculate the number of boxes fitting		;AN000;
;	   in the printer buffer.						;AN000;
;	2) Determine where to start reading the screen: 			;AN000;
;	     If printing sideways, start in LOW LEFT corner.			;AN000;
;	     If normal printing, start in TOP LEFT corner.			;AN000;
;	   Determine the maximum length for a scan line:			;AN000;
;	     If printing sideways, it is the height of the screen.		;AN000;
;	     For normal printing, it is the width of the screen.		;AN000;
;	   Determine the number of scan lines on the screen.			;AN000;
;	3) Set up the Printer for printing Graphics.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	LOC_MODE_PRT_INFO	; Get printer info related to curr. mode;AN000;
;										;AN000;
;-------Test if DISPLAYMODE info record was found:				;AN000;
       .IF <ERROR_CODE EQ DISPLAYMODE_INFO_NOT_FOUND>				;AN000;
       .THEN									;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; IF no record found,		;AN000;
	  JMP	  PRINT_BW_APA_END	     ; then, return error code		;AN000;
       .ENDIF				     ;	      and quit procedure	;AN000;
;										;AN000;
;-------Get the box size from the DISPLAYMODE info record:			;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Offset current DISPLAYMODE info.;AN000;
	MOV	AH,[BX].BOX_WIDTH	; Take local copy of the box size.	;AN000;
	MOV	BOX_W,AH		;  in BOX_W and BOX_H			;AN000;
	MOV	AL,[BX].BOX_HEIGHT						;AN000;
	MOV	BOX_H,AL							;AN000;
;										;AN000;
;-------Verify if the box size obtained from DISPLAYMODE info. is valid 	;AN000;
       .IF <ZERO AL> OR 		; IF height of the box is 0		;AN000;
       .IF <ZERO AH>			;  OR width of the box is 0		;AN000;
       .THEN				; THEN we can't print:                  ;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; return error code		;AN000;
	  JMP	  PRINT_BW_APA_END	;	and quit			;AN000;
       .ENDIF									;AN000;
;										;AN000;
;-------Get the Print Orientation from the DISPLAYMODE info record		;AN000;
       .IF <[BX].PRINT_OPTIONS EQ ROTATE>; If printing sideways 		;AN000;
       .THEN				;  then:				;AN000;
	  MOV	  ROTATE_SW,ON		;    Rotate switch := "ON"              ;AN000;
       .ENDIF									;AN000;
										;AN000;
;										;AN000;
;-------Initialize print variables and the printer:				;AN000;
	CALL	GET_SCREEN_INFO 	; Get info. about how to read the screen;AN000;
	CALL	SETUP_PRT		; Set up the printer (Line spacing, etc);AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>					;AN000;
       .THEN				; A printer error occurred: quit	;AN000;
	  JMP	  PRINT_BW_APA_END	;					;AN000;
       .ENDIF									;AN000;

	MOV	CX,NB_SCAN_LINES						;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Added the following modification to support printers with
;               vertical print heads, such as HP PCL printers.  
;
;                                       ; .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>
CMP     DS:[BP].DATA_TYPE,DATA_ROW      ;        
JNE     GOTO_ITS_DATA_COLUMN            ;
;-------------------------------------------------------------------------------
;										
; FOR EACH SCAN LINE ON THE SCREEN, WHICH REALLY IS JUST ONE LINE:					
;										
;-------------------------------------------------------------------------------
PRINT_1_LINE_OF_BOXES:                          ;
	CALL	DET_CUR_SCAN_LNE_LENGTH ; Determine how many non-blanks on line 
        CMP     CUR_SCAN_LNE_LENGTH,0           ; .IF <CUR_SCAN_LNE_LENGTH NE 0>
        JE      GOTO_NEXT_COORDINATES           ; If line is not empty then, 			
						;				
	        PUSH	CX			; Save scan line counter	
                XOR     CH,CH                   ; Clear register
                MOV     CL,BOX_H                ; CX is the # of times we need to read
                                                ; a line to print complete boxes.
                MOV     DS:[BP].ROW_TO_EXTRACT,CL ; Determines what row to extract
                DEC     DS:[BP].ROW_TO_EXTRACT  ; zero based
READ_LINE:                                      ;
	        CALL	NEW_PRT_LINE		;  Send escape sequence to the printer 
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR> ; for starting a new line.       
               .THEN				; If a printer error occurred:	       
                        POP     CX              ; Restore counter for how many times we
                        JMP     PRINT_BW_APA_END; need to read line and quit!
               .ENDIF		                ;							
                PUSH    DX                      ;
                PUSH    CX                      ; Save counter for how many times we 
                                                ; need to read line.
	        PUSH    CUR_ROW                 ; Save coordinates where start reading
                PUSH    CUR_COLUMN              ; line.
                MOV     AX,CUR_SCAN_LNE_LENGTH  ; DX:AX = counter for how many pixels need to
                CWD                             ; be read per line
                XOR     BH,BH                   ;
                MOV     BL,NB_BOXES_PER_PRT_BUF ;
                
                DIV     BX                      ;
               .IF <DX NE 0>                    ; So don't lose data when
                     INC        AX              ; have a remainder.
               .ENDIF                           ;
                MOV     CX,AX                   ; loop CX times to read all
                                                ; pixels on scan line.
                JMP     SHORT  PRINT_1_LINE     ; Jumps were out of range
GOTO_NEXT_COORDINATES:                          ;
        JMP     SHORT   NEXT_COORDINATES        ;
GOTO_PRINT_1_LINE_OF_BOXES:                     ;
        JMP     PRINT_1_LINE_OF_BOXES           ;
GOTO_ITS_DATA_COLUMN:                           ; 
        JMP     SHORT   ITS_DATA_COLUMN         ;
PRINT_1_LINE:                                   ;
                CALL    FILL_BUFFER             ; Read enough pixels to fill the buffer
                                                ; convert each to a printer box,
                                                ; extract a row from each box,
                                                ; store it in the print buffer
                CALL    PRINT_BUFFER            ; Print it
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>   ;				       
               .THEN				        ; A printer error occurred:	       
                        POP       CUR_COLUMN            ;
                        POP       CUR_ROW               ;
	                POP	  CX			; Restore counter for how many pixels
                                                        ; needed to read per line      
                        POP       DX                    ;
                        POP       CX                    ; Save scan line counter
	                JMP	  PRINT_BW_APA_END	; and quit				
               .ENDIF					;			       
                LOOP    PRINT_1_LINE                    ; Continue reading, converting, extracting
                                                        ; storing and printing.
	        CALL	END_PRT_LINE		        ;  Send escape sequence to the printer 
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>   ; for ending a line.	       
               .THEN				        ; If a printer error occurred: 
                        POP       CUR_COLUMN            ;
                        POP       CUR_ROW               ;
                        POP       CX                    ; Restore counter for how many times we
                                                        ; needed to read per line      
                        POP       DX                    ;
                        POP       CX                    ; Save scan line counter
                        JMP     PRINT_BW_APA_END; need to read line and quit!
               .ENDIF					;			       
                DEC     DS:[BP].ROW_TO_EXTRACT          ; Extract next row. Note:zero based
                POP     CUR_COLUMN                      ; Restore coordinates of beginning
                POP     CUR_ROW                         ; of "scan" line.
                POP     CX                              ; Restore counter for how many times we
                                                        ; needed to read per line      
                POP     DX                              ;
                LOOP    READ_LINE                       ; Read the line again so we can extract
                                                        ; the other rows out of the printer boxes
                POP      CX                             ; Save scan line counter

NEXT_COORDINATES:                                       ; End of, if line is not empty 
       .IF <CUR_SCAN_LNE_LENGTH EQ 0>                   ; 
                CALL    NEW_PRT_LINE                    ; Send esc. seq. to printer
       .ENDIF                                           ;
       .IF <ROTATE_SW EQ ON>                            ; Get coordinates of next "scan" line
       .THEN                                            ;
                INC CUR_COLUMN                          ;
       .ELSE                                            ;
                INC CUR_ROW                             ;
       .ENDIF                                           ;
        DEC     CX                                      ; Loop was out of range.  Read another
        CMP     CX,0                                    ; "scan" line and print the corresponding
        JNE     GOTO_PRINT_1_LINE_OF_BOXES; printer boxes.
        JMP     SHORT   DONE_WITH_PRINTING              ;

ITS_DATA_COLUMN:                                        ; .ELSE

; /\ ~~mda(001) -----------------------------------------------------------------------
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR EACH SCAN LINE ON THE SCREEN:						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_1_SCAN_LINE:								;AN000;
	CALL	DET_CUR_SCAN_LNE_LENGTH ; Determine how many non-blanks on line ;AN000;
       .IF <CUR_SCAN_LNE_LENGTH NE 0>		; If line is not empty		;AN000;	
       .THEN					; then, 			;AN000;	
                CALL	NEW_PRT_LINE		;  Send escape sequence to the printer	;AN000;
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR> ; for starting a new line.;AN000;	
               .THEN				; If a printer error occurred:	;AN000;	
	                JMP  SHORT PRINT_BW_APA_END	;   Quit !		;AN000;	
               .ENDIF								;AN000;
										;AN000;
	        PUSH	CX			; Save scan line counter	;AN000;
	        MOV	CX,CUR_SCAN_LNE_LENGTH					;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR each column on the current scan line (up to the last non-blank):		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_1_SCAN_COLUMN:								;AN000;
	        CALL	FILL_BUFFER		; Read all pixels on this column,    ;AN000;
					        ;   convert each to a printer box,   ;AN000;
					        ;    store boxes in the print buffer ;AN000;
					        ;     (a buffer contains one "column";AN000;
					        ;      of pixels).		     ;AN000;
	        CALL	PRINT_BUFFER		; Print the buffer.		     ;AN000;
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>				     ;AN000;
               .THEN				; A printer error occurred:	     ;AN000;
	                POP	  CX			; Restore scan line counter and quit	;AN000;
	                JMP	  SHORT  PRINT_BW_APA_END	;			;AN000;
               .ENDIF								;AN000;
										;AN000;
										;AN000;
;-------Get coordinates of next "column":                                       ;AN000;
               .IF <ROTATE_SW EQ ON>		; If printing sideways		;AN000;
               .THEN				;				;AN000;
	                DEC CUR_ROW			; then, get row above on screen	;AN000;
               .ELSE				;				;AN000;
	                INC CUR_COLUMN		; else, get column next right	;AN000;
               .ENDIF				;				;AN000;
										;AN000;
        	LOOP	PRINT_1_SCAN_COLUMN	; Print next column		;AN000;
										;AN000;
	        POP	CX			; Restore scan line counter	;AN000;
       .ENDIF					; Endif line is not empty	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Print a carriage return and a line feed:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Commented out the following and replaced it with the procedure
;               END_PRT_LINE because this procedure takes care of this as well
;               as sending the esc. seq. that comes after the keyword DATA.
;
;       MOV	AL,CR							;AN000;
;	CALL	PRINT_BYTE		        ; Send CR		;AN000;
;	JC	PRINT_BW_APA_END	        ; If printer error, leave;AN000;
;	MOV	AL,LF				;			;AN000;
;	CALL	PRINT_BYTE		        ; Send LF		;AN000;
;	JC	PRINT_BW_APA_END	        ; If printer error, leave;AN000;
;                                               ;
	CALL	END_PRT_LINE		        ;  Send escape sequence to the printer	;AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>   ; for ending a line, and for      ;AN000;
                                                ; doing a CR and LF.
       .THEN				        ; If a printer error occurred:	  ;AN000;
	JMP	SHORT   PRINT_BW_APA_END        ;   Quit !			  ;AN000;
       .ENDIF					;			;AN000;
; /\ ~~mda(001) -----------------------------------------------------------------------

        JMP     SHORT   GET_NEXT_SCAN_LINE      ;~~mda(001) Used this to replace a
GOTO_PRINT_1_SCAN_LINE:                         ; loop that was out or range.
        JMP     PRINT_1_SCAN_LINE               ;
GET_NEXT_SCAN_LINE:                             ;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Get coordinates of next scan line:						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
               .IF <ROTATE_SW EQ ON>		; If printing sideways		;AN000;
               .THEN				; then: 			;AN000;
	                MOV	  AL,NB_BOXES_PER_PRT_BUF ;   AX := Numbers of pels read on row ;AN000;
	                CBW				;				;AN000;
	                ADD	  CUR_COLUMN,AX 	;   CUR_COLUMN + Number of pels read	;AN000;
	                MOV	  AX,SCREEN_HEIGHT	;   CUR_ROW := SCREEN_HEIGHT - 1;AN000;
	                DEC	  AX			;				;AN000;
	                MOV	  CUR_ROW,AX		;				;AN000;
               .ELSE				; else, printing NOT rotated:	;AN000;
	                MOV	  AL,NB_BOXES_PER_PRT_BUF ;   AX := Number of pels read on colum;AN000;
	                CBW				;				;AN000;
	                ADD	  CUR_ROW,AX		;   CUR_ROW + Number of pels read;AN000;
	                MOV	  CUR_COLUMN,0		;   CUR_COLUMN := 0		;AN000;
               .ENDIF				;				;AN000;
;;        LOOP	PRINT_1_SCAN_LINE	;~~mda(001) Commented it out cause loop is  ;AN000;
                                        ;           out of range.
        DEC     CX                      ;~~mda(001) Used this instead of the LOOP
        OR      CX,CX
        JNZ      GOTO_PRINT_1_SCAN_LINE  ;
DONE_WITH_PRINTING:                     ;~~mda(001) Label for endif.										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Restore the printer.								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	RESTORE_PRT							;AN000;
PRINT_BW_APA_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_BW_APA ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; FILL_BUFFER : READS ENOUGH PIXELS TO FILL UP THE PRINT BUFFER.		;AN000;
;		THESE PIXELS ARE MAPPED TO A PRINTER DOT BOX.			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	CUR_COLUMN,							;AN000;
;		CUR_ROW = Coordinates of the first pixel to be read		;AN000;
;		BOXES_PER_PRT_BUF = Number of boxes fitting in the print	;AN000;
;				    buffer					;AN000;
;		XLT_TAB = Color translation table				;AN000;
;										;AN000;
;	OUTPUT: PRT_BUF = PRINT BUFFER						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:									;AN000;
;										;AN000;
;	1) Pixels are read one by one vertically from top to bottom in		;AN000;
;	   the current column of the screen scan line.				;AN000;
;	   NOTE: What is called here a 'column' can actually be a line          ;AN000;
;		 on the physical display.					;AN000;
;	2) Each pixel is mapped to a printer dot box.				;AN000;
;	3) Each Dot box is stored in the printer buffer.			;AN000;
;	4) The coordinates in input are those of the "top" pixel                ;AN000;
;	   and restored when leaving this procedure.				;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Save coordinates of the current "column" (slice of a screen scan line)        ;AN000;
; DO for BOXES_PER_PRT_BUF  (8 / BOX_H) 					;AN000;
;   BEGIN									;AN000;
;   CALL READ_DOT		  ; Read a pixel, get index in XLT_TAB		;AN000;
;   Get pixel intensity from XLT_TAB						;AN000;
;   CALL INT2PAT		  ; Locate pattern corresponding to int.	;AN000;
;   CALL PAT2BOX		  ; Extract box from pattern			;AN000;
;   CALL STORE_BOX		  ; Store the box in the printer buffer 	;AN000;
;   ; Get coordinates of next pixel below:					;AN000;
;   IF printing is sideways THEN INC CUR_COLUMN 				;AN000;
;			    ELSE INC CUR_ROW					;AN000;
;   END 									;AN000;
; Restore initial coordinates.							;AN000;
;										;AN000;
FILL_BUFFER PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Save initial coordinates:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;	        If DATA_TYPE is equal to DATA_ROW then we have a horizontal 
;               print head so we SHOULDN'T save CUR_ROW and CUR_COLUMN because 
;               we are moving down the "scan" line from left to right a little 
;               at a time, that is we don't finish reading the scan line until 
;               we have made repeated calls to this procedure.  Remember since
;               we're dealing with horizontal print heads one scan line is 
;               really just one line.
;                                                  ;
       .IF <DS:[BP].DATA_TYPE NE DATA_ROW>         ;
                                                   ;
	        PUSH	CUR_ROW 		   ;					
	        PUSH	CUR_COLUMN		   ;					
       .ENDIF					   ;					
;/\  ~~mda(001) -----------------------------------------------------------------------
;-------Clear the print buffer: 						;AN000;
	XOR	BX,BX		; For each byte in the PRT_BUF: 		;AN000;
CLEAR_PRT_BUF:									;AN000;
	MOV	PRT_BUF[BX],0	;  Initialize byte to blanks			;AN000;
	INC	BX		;  Get next byte				;AN000;
	CMP	BL,BOX_W	;  All bytes cleared ?				;AN000;
	JL	CLEAR_PRT_BUF	;  No, clear next one.				;AN000;
										;AN000;
	MOV	BX,OFFSET XLT_TAB ; BX := Offset of XLT_TAB			;AN000;
										;AN000;
;-------Fill the print buffer with one box for each pixel read: 		;AN000;
	XOR	CX,CX		; CL := Number of pixels to read		;AN000;
	MOV	CL,NB_BOXES_PER_PRT_BUF 					;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; For each pixel within the current column of the scan line:			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
READ_AND_STORE_1_PIXEL: 							;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Intensity			;AN000;
	CALL	INT2PAT 		; SI := Offset of matching Pattern	;AN000;
	CALL	PAT2BOX 		; Extract CUR_BOX from the pattern.	;AN000;
	MOV	SI,OFFSET CUR_BOX	; Store it in the PRT_BUF		;AN000;
	CALL	STORE_BOX							;AN000;
										;AN000;
;-------Get coordinates of next pixel:						;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               If DATA_TYPE is DATA_ROW then we have a horizontal print head
;               so we need to read the next pixel on the scan line.  Remember
;               since we're dealing with horizontal print heads one scan line
;               is really just one line. For every pixel read we need to store 
;               one row of the corresponding box in the print buffer.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ;
                .IF <ROTATE_SW EQ ON>		; If printing sideways			
                .THEN				;					
	                DEC CUR_ROW		; then, decrement row number   
                .ELSE				;			       
	                INC CUR_COLUMN		; else, increment column number
                .ENDIF				;			       
       .ELSE                                    ;
;/\  ~~mda(001) -----------------------------------------------------------------------
                .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
                .THEN				;					;AN000;
	                INC CUR_COLUMN		; then, increment column number 	;AN000;
                .ELSE				;					;AN000;
	                INC CUR_ROW		; else, increment row number		;AN000;
                .ENDIF				;					;AN000;
       .ENDIF                                   ; ~~mda(001) Close IF stmt.
	LOOP READ_AND_STORE_1_PIXEL						;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Restore initial coordinates:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               If DATA_TYPE = DATA_ROW then we don't restore initial coordinates.
;
       .IF <DS:[BP].DATA_TYPE NE DATA_ROW>         ;
	        POP	CUR_COLUMN		   ;					
	        POP	CUR_ROW 		   ;					
       .ENDIF					   ;					
;/\  ~~mda(001) -----------------------------------------------------------------------
										;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
FILL_BUFFER ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; INT2PAT : MAP AN INTENSITY TO A PATTERN.					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	AL = GREY INTENSITY (0 - 63 = BLACK to WHITE)			;AN000;
;		BOX_W = Number of columns in a box				;AN000;
;		CUR_MODE_PTR = Offset of current DISPLAYMODE info record	;AN000;
;										;AN000;
;	OUTPUT: SI = OFFSET OF THE PATTERN MATCHING THE INTENSITY		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Performs a sequential search in the table of patterns		;AN000;
; until the proper pattern is found.						;AN000;
;										;AN000;
;										;AN000;
; SI = 0 ; FOUND = FALSE							;AN000;
; DO UNTIL FOUND = TRUE 							;AN000;
;   BEGIN									;AN000;
;   IF AL <= Maximum intensity of the current pattern in the table		;AN000;
;     THEN									;AN000;
;	FOUND = TRUE								;AN000;
;     ELSE									;AN000;
;	SI = SI + (BOX_W * 2)							;AN000;
;   END 									;AN000;
;										;AN000;
INT2PAT PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
;-------Calculate the size in bytes of one pattern STRUCTURE: (see GRPATTRN.STR);AN000;
	MOV	DL,BOX_W	; DX := Number of columns in the box		;AN000;
	XOR	DH,DH								;AN000;
	SHL	DL,1		; (DX * 2) = Number of columns in the pattern	;AN000;
	INC	DL		; DL := Size in bytes of one pattern		;AN000;
				;	(includes intensity field)		;AN000;
	MOV	BX,CUR_MODE_PTR ; BX := Offset of current mode			;AN000;
				; SI := Offset of the first pattern		;AN000;
	MOV	SI,[BX].PATTERN_TAB_PTR 					;AN000;
	ADD	SI,BP								;AN000;
										;AN000;
COMPARE_INTENSITY:								;AN000;
	CMP	AL,[SI] 	; Within the range of this pattern ?		;AN000;
	JLE	FOUND_PATTERN	;   Yes, use this pattern.			;AN000;
				;   No, look at next pattern:			;AN000;
	ADD	SI,DX		;     SI := SI + Number columns in pattern)	;AN000;
	JMP	SHORT COMPARE_INTENSITY 					;AN000;
										;AN000;
FOUND_PATTERN:									;AN000;
										;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
										;AN000;
INT2PAT ENDP									;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PAT2BOX : SELECT AND EXTRACT THE PROPER BOX FROM THE PATTERN ACCORDING	;AN000;
;	    TO THE COORDINATES OF THE PIXEL.					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	SI = OFFSET OF CURRENT PATTERN					;AN000;
;		CUR_COLUMN,							;AN000;
;		CUR_ROW  = COORDINATES OF THE CURRENT PIXEL			;AN000;
;										;AN000;
;	OUTPUT: CUR_BOX  = PORTION OF THE PATTERN TO BE PRINTED 		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: If the pixel is on even-even coordinates, then the		;AN000;
; top-left box of the pattern is extracted.					;AN000;
; If its Even-odd --> extract the top-right box.				;AN000;
; Odd-even --> low-left box, and Odd-odd  --> low-right box.			;AN000;
;										;AN000;
PAGE										;AN000;
;  For example., (with a 3x2 box):						;AN000;
;										;AN000;
;  PATTERN (over 6 bytes):							;AN000;
;										;AN000;
;										;AN000;
;	       byte1  byte2  byte3	byte4  byte5  byte6			;AN000;
;										;AN000;
;		 0	0      0	  0	 0	0			;AN000;
;		 0	0      0	  0	 0	0			;AN000;
;		 0	0      0	  0	 0	0			;AN000;
;		 0	0      0	  0	 0	0			;AN000;
; even-even --> dot1   dot2   dot3   |	 dot1	dot2   dot3 <-- even-odd	;AN000;
; (row-column)	dot4   dot5   dot6   |	 dot4	dot5   dot6	box		;AN000;
; box.	       ------------------------------------------------ 		;AN000;
; odd-even  --> dot1   dot2   dot3   |	 dot1	dot2   dot3 <-- odd-odd 	;AN000;
; box		dot4   dot5   dot6   |	 dot4	dot5   dot6	box		;AN000;
;										;AN000;
;										;AN000;
;  The selected box is then stored as follow:					;AN000;
;										;AN000;
;  CUR_BOX:									;AN000;
;		byte1 byte2 byte3						;AN000;
;     MSB ------> 0	0     0 						;AN000;
;     (bit7)	  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		 dot1  dot2  dot3 <-- box					;AN000;
;     LSB ------>dot4  dot5  dot6						;AN000;
;										;AN000;
; LOGIC:									;AN000;
; IF CUR_ROW is odd								;AN000;
; THEN SI := SI + BOX_W 	; Access right portion of pattern		;AN000;
; Build a bit mask in BL of BOX_H bits, right justified.			;AN000;
; FOR each column in the box (BOX_W)						;AN000;
;   Get the pattern column in AL						;AN000;
;   IF CUR_COLUMN is even							;AN000;
;   THEN									;AN000;
;     Move down the column of the top box.					;AN000;
;   AND BL,AL			; BL <-- Column of the desired box		;AN000;
;										;AN000;
;										;AN000;
PAT2BOX PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
										;AN000;
					; SI := Offset of current pattern	;AN000;
	INC	SI			; Skip the MAX INTENSITY field		;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Set SI to either the left or right set of 2 boxes in the pattern:		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	TEST	CUR_ROW,1		; Odd row ?				;AN000;
	JZ	EXTRACT_BOX		;   No,  access left portion of pattern ;AN000;
	MOV	AL,BOX_W		;					;AN000;
	CBW				;					;AN000;
	ADD	SI,AX			;   Yes, access right portion of pattern;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Extract the box:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
EXTRACT_BOX:									;AN000;
;-------Build a bit mask that will be used to keep only BOX_H bits		;AN000;
;-------of the bytes where CUR_BOX is stored.					;AN000;
	XOR	AH,AH			; AH := Box column bit mask		;AN000;
	MOV	AL,BOX_H		; For each row of the box:		;AN000;
INIT_MASK:				;					;AN000;
	SHL	AH,1			;					;AN000;
	OR	AH,1			;    Insert one bit in the mask.	;AN000;
	DEC	AL			;					;AN000;
	CMP	AL,0			;					;AN000;
	JG	INIT_MASK							;AN000;
										;AN000;
	XOR	BX,BX			; BL := Column number within the box	;AN000;
;										;AN000;
;-------For each column of the box:						;AN000;
EXTRACT_1_BOX_COLUMN:								;AN000;
	MOV	AL,[SI] 		; AL := Current column of pattern	;AN000;
	TEST	CUR_COLUMN,1		; If the pixel is on ODD column 	;AN000;
	JNZ	BOTTOM_BOX		;   Then, need bottom box portion	;AN000;
	MOV	CL,BOX_H		;   Else, need top box portion		;AN000;
TOP_BOX:				; Need top box: 			;AN000;
	SHR	AL,CL			;   Shift top box over bottom box	;AN000;
BOTTOM_BOX:				; The box we want is now at bottom	;AN000;
	AND	AL,AH			; Keep only bits from the box		;AN000;
	MOV	CUR_BOX[BX],AL		; Store this box column 		;AN000;
	INC	SI			; Access next column of the pattern	;AN000;
	INC	BX			; One more column stored.		;AN000;
	CMP	BL,BOX_W		; All stored ?				;AN000;
	JL	EXTRACT_1_BOX_COLUMN	;   No, continue			;AN000;
										;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PAT2BOX ENDP									;AN000;
INCLUDE GRCOMMON.ASM								;AN000;
LEN_OF_BW_MODULES EQU $-PRINT_BW_APA						;AN000;
CODE	ENDS									;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grcolprt.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Color printing modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRCOLPRT.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the code for printing a screen (text and graphics)	;AN000;
;;	 on a COLOR printer.							;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;										;AN000;
;;	PRINT_COLOR								;AN000;
;;	  SCAN_FOR_BANDS_APA							;AN000;
;;	  SCAN_FOR_BANDS_TXT							;AN000;
;;	  PRINT_BAND_APA							;AN000;
;;	  PRINT_BAND_TXT							;AN000;
;;	  SET_CURSOR								;AN000;
;;	  SET_COLOR_BAND							;AN000;
;;	  INIT_BLACK_BOX							;AN000;
;;										;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;										;AN000;
;;	 GRCTRL.EXT   - Externals for print screen control			;AN000;
;;	 GRCTRL.STR   - Structures and equates for print screen control 	;AN000;
;;	 GRPATTRN.STR - Structures for the printer patterns.			;AN000;
;;										;AN000;
;;	 GRSHAR.STR   - Shared Data Area Structure				;AN000;
;;										;AN000;
;;	 STRUC.INC    - Macros for using structured assembly language		;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRCTRL.ASM: 						;AN000;
;;	      PRT_SCR - Main module for printing the screen.			;AN000;
;;	 TO FILE GRCOMMON.ASM							;AN000;
;;	      Common modules - tools for printing a screen.			;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;	 Date last updated 5/26/87.						;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
PAGE										;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME		CS:CODE,DS:CODE 					;AN000;
										;AN000;
	PUBLIC	PRINT_MODULE_START     ;; Color modules public			;AN000;
	PUBLIC	PRINT_COLOR	       ;;  procedures				;AN000;
	PUBLIC	LEN_OF_COLOR_MODULES   ;;					;AN000;
				       ;;					;AN000;
.XLIST					;					;AN000;
INCLUDE GRCTRL.STR			; Stuctures needed			;AN000;
INCLUDE GRSHAR.STR			;  for both set of print modules	;AN000;
INCLUDE GRPATTRN.STR			;					;AN000;
					;					;AN000;
INCLUDE GRCTRL.EXT			; Externals from PRT_SCR control module ;AN000;
INCLUDE STRUC.INC			;					;AN000;
.LIST					;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;										;AN000;
;; PRINT_COLOR : PRINT TEXT AND APA MODE SCREEN ON A COLOR PRINTER		;AN000;
;;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP	 = Offset of the shared data area			;AN000;
;		XLT_TAB  = Color translation table				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Main control module for printing of text and graphics			;AN000;
;;   on color printers. 							;AN000;
;;										;AN000;
;;   Calls either the text or graphics mode routine.				;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   PRINT_SCREEN								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   LOC_MODE_PRT_INFO, PRINT_COLOR_APA, PRINT_COLOR_TXT			;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   IF MODE_TYPE = TXT 							;AN000;
;;     THEN CALL PRINT_COLOR_TXT						;AN000;
;;   ELSE (MODE_TYPE = APA)							;AN000;
;;     CALL LOC_MODE_PRT_INFO	 ; Get DISPLAYMODE record from the SHARED AREA	;AN000;
;;     CALL PRINT_COLOR_APA							;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	;AN000;
PRINT_MODULE_START  LABEL BYTE							;AN000;
PRINT_COLOR	PROC NEAR							;AN000;
	JMP	SHORT PRINT_COLOR_BEGIN 					;AN000;
WHITE_BOX	DB	0,0,0,0 ; Print boxes for APA mode			;AN000;
BLACK_BOX	DB	?,?,?,? ;  NOTE: 1 print box = 1 screen pixel		;AN000;
				;   only BOX_W bytes are used out of these 2	;AN000;
				;    boxes.					;AN000;
										;AN000;
REQ_BAND_MASK	DB	?	; Mask = "All color bands needed for the current;AN000;
				;	   print line".                         ;AN000;
										;AN000;
PRINT_COLOR_BEGIN:								;AN000;
.IF <MODE_TYPE EQ TXT>								;AN000;
.THEN										;AN000;
;-------------------------------------------------------------------------------;AN000;
; The screen is in a text mode: 						;AN000;
;-------------------------------------------------------------------------------;AN000;
  CALL PRINT_COLOR_TXT			; Print a text screen on a color printer;AN000;
.ELSE										;AN000;
;-------------------------------------------------------------------------------;AN000;
; The screen is in All Points Addressable mode: 				;AN000;
; Locate and extract printer DISPLAYMODE information from			;AN000;
; the shared data area. 							;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	LOC_MODE_PRT_INFO	; Get printer info related to curr. mode;AN000;
;										;AN000;
;-------Test if DISPLAYMODE info record was found:				;AN000;
       .IF <ERROR_CODE EQ DISPLAYMODE_INFO_NOT_FOUND>				;AN000;
       .THEN									;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; IF no record found,		;AN000;
	  JMP	  SHORT PRINT_COLOR_END      ; then, return error code		;AN000;
       .ENDIF				     ;	      and quit procedure	;AN000;
;										;AN000;
;-------Get the box size from the DISPLAYMODE info record:			;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Offset current DISPLAYMODE info.;AN000;
	MOV	AH,[BX].BOX_WIDTH	; Take local copy of the box size.	;AN000;
	MOV	BOX_W,AH		;  in BOX_W and BOX_H			;AN000;
	MOV	AL,[BX].BOX_HEIGHT						;AN000;
	MOV	BOX_H,AL							;AN000;
;										;AN000;
;-------Verify if the box size obtained from DISPLAYMODE info. is valid 	;AN000;
       .IF <ZERO AL> OR 		; IF height of the box is 0		;AN000;
       .IF <ZERO AH>			;  OR width of the box is 0		;AN000;
       .THEN				; THEN we can't print:                  ;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; return error code		;AN000;
	  JMP	  SHORT PRINT_COLOR_END      ;	     and quit			;AN000;
       .ENDIF									;AN000;
;										;AN000;
;-------Get the Print Orientation from the DISPLAYMODE info record		;AN000;
       .IF <[BX].PRINT_OPTIONS EQ ROTATE>; If printing sideways 		;AN000;
       .THEN				;  then:				;AN000;
	  MOV	  ROTATE_SW,ON		;    Rotate switch := "ON"              ;AN000;
       .ENDIF									;AN000;
  CALL PRINT_COLOR_APA			; Print APA screen on a color printer	;AN000;
.ENDIF										;AN000;
PRINT_COLOR_END:								;AN000;
	RET									;AN000;
PRINT_COLOR ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_COLOR_TXT: PRINT A TEXT MODE SCREEN ON A COLOR PRINTER			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP		     = Offset of the shared data area		;AN000;
;		XLT_TAB 	     = Color translation table			;AN000;
;		SCREEN_WIDTH	     = Maximum length of Screen scan line.	;AN000;
;		SCREEN_HEIGHT	     = Number of SCAN LINES on the screen	;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: The screen is read and printed line by line; character by	;AN000;
; character.									;AN000;
; Each line is first scanned in order to determine what colors are present on	;AN000;
; it and what printer bands will be needed to approximate these colors. 	;AN000;
;										;AN000;
; For each printer color band needed for the current line, this screen line	;AN000;
; is READ AGAIN character by character; If the color of the			;AN000;
; current character must use the current color band to be			;AN000;
; approximated; then, the character is printed. 				;AN000;
;										;AN000;
;										;AN000;
; LOGIC :									;AN000;
;										;AN000;
; Save current coordinates of the cursor.					;AN000;
; Initialize the cursor to the first character to be read  (Top-left of screen) ;AN000;
; FOR each row on the screen (SCREEN_HEIGHT)					;AN000;
;   BEGIN									;AN000;
;   CALL SCAN_FOR_BANDS_TXT(CUR_ROW,CUR_COLUMN,REQ_BAND_MASK)			;AN000;
;   CUR_BAND_MASK := 01H							;AN000;
;   IF REQ_BAND_MASK <> 0 THEN							;AN000;
;	DO 8 TIMES								;AN000;
;	 IF (REQ_BAND_MASK AND CUR_BAND_MASK)=1 THEN				;AN000;
;	    CALL PRINT_BAND_TXT(CUR_ROW,CUR_COLUMN,CUR_BAND_MASK)		;AN000;
;	    CALL PRINT_BYTE(CARRIAGE_RETURN)					;AN000;
;	  ENDIF 								;AN000;
;	  Shift CUR_BAND_MASK one bit left					;AN000;
;	ENDDO									;AN000;
;	CALL PRINT_BYTE(LINE_FEED)						;AN000;
;   ENDIF									;AN000;
;   CUR_COLUMN := 0		    ; Get next row coordinates			;AN000;
;   CUR_ROW    := CUR_ROW + 1							;AN000;
;   END ; FOR each row on the screen						;AN000;
; Restore initial coordinates of the cursor					;AN000;
;										;AN000;
PRINT_COLOR_TXT PROC								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
;										;AN000;
;-------Save coordinates of the cursor on the stack:				;AN000;
	MOV	AH,READ_CURSOR_CALL  ; Read position of the cursor on the screen;AN000;
	MOV	BH,CUR_PAGE	     ;	for the current page			;AN000;
	INT	10H		     ; Call BIOS				;AN000;
	PUSH	DX		     ; DH := Row number, DL := Column number	;AN000;
				     ; CX := Top line and bottom line for cursor;AN000;
				     ;	      (not needed)			;AN000;
;										;AN000;
;-------Initialize the cursor to the first character to be read 		;AN000;
	MOV	CUR_ROW,0	     ; cursor = position (0,0) on the screen	;AN000;
	MOV	CUR_COLUMN,0	     ;	(top-left corner)			;AN000;
	CALL	SET_CURSOR							;AN000;
										;AN000;
	MOV	CX,SCREEN_HEIGHT     ; CX := Number of rows on the screen	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR EACH ROW ON THE SCREEN:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_1_TEXT_LINE:								;AN000;
	CALL	SCAN_FOR_BANDS_TXT	; REQ_BAND_MASK := Print bands needed	;AN000;
					;  for this line			;AN000;
	MOV	DL,01H			; DL :="Current Band printed" mask      ;AN000;
										;AN000;
	; NOTE: The COLORSELECT records are stored sequentially in the		;AN000;
	; Shared Data area. The band mask 00000001 corresponds to the first	;AN000;
	; record, 00000010 to the second, etc.					;AN000;
	; The COLORSELECT record indicates: "How to select the color band"      ;AN000;
	; on the printer (It contains the bytes that must be sent to the printer;AN000;
										;AN000;
	MOV	BX,DS:[BP].COLORSELECT_PTR; BX := relative offset of COLORSELECT;AN000;
	ADD	BX,BP			; BX := absolute offset of COLORSELECT	;AN000;
	PUSH	CX			; Save row counter			;AN000;
	MOV	CX,8			; For up to the maximum number of print ;AN000;
					;  bands with this printer		;AN000;
	;-----------------------------------------------------------------------;AN000;
	;									;AN000;
	; FOR each Color Band available with the ribbon installed on the printer;AN000;
	;									;AN000;
	;-----------------------------------------------------------------------;AN000;
	PRINT_1_COLOR_BAND_TXT: 	  ; Do one pass of the printer head:	;AN000;
	 .IF <BIT REQ_BAND_MASK AND DL>   ; IF this color band is needed	;AN000;
	 .THEN				  ;  by any character on the line	;AN000;
	    CALL SET_COLOR_BAND 	  ; then, select the color band 	;AN000;
	    CALL PRINT_BAND_TXT 	  ;    and do one Print Pass for it.	;AN000;
	   .IF	<BIT ERROR_CODE NZ PRINTER_ERROR>				;AN000;
	   .THEN			  ; A printer error occurred:		;AN000;
	      POP     CX		  ;   Restore the line counter		;AN000;
	      JMP     SHORT  PRINT_COLOR_TXT_END ;    and quit.			;AN000;
	   .ENDIF								;AN000;
	    MOV     AL,CR		  ;    Print a carriage return		;AN000;
	    CALL    PRINT_BYTE							;AN000;
	   .IF	C								;AN000;
	   .THEN			  ; A printer error occurred:		;AN000;
	      POP     CX		  ;   Restore the line counter		;AN000;
	      JMP     SHORT    PRINT_COLOR_TXT_END ;    and quit.			;AN000;
	   .ENDIF			  ; ENDIF printer error 		;AN000;
	 .ENDIF 			  ; ENDIF this color band is needed	;AN000;
	  SHL	  DL,1			  ; Get next Color Band mask		;AN000;
					  ; [BX] := Next COLORSELECT record:	;AN000;
	  MOV	  AL,[BX].NUM_SELECT_ESC  ;	skip the escape bytes		;AN000;
	  XOR	  AH,AH 		  ;					;AN000;
	  ADD	  BX,AX 		  ;					;AN000;
	  INC	  BX			  ;	skip the NUM_SELECT_ESC field	;AN000;
	LOOP	PRINT_1_COLOR_BAND_TXT						;AN000;
	POP	CX			  ; Restore row counter 		;AN000;
;										;AN000;
;-----Print a line feed:							;AN000;
	MOV	AL,LF								;AN000;
	CALL	PRINT_BYTE		; Send the LF				;AN000;
	JC	PRINT_COLOR_TXT_END	; If printer error, quit		;AN000;
;										;AN000;
;-------Get coordinates of the first character in the next scan line:		;AN000;
	INC	CUR_ROW 		;   CUR_ROW + 1 			;AN000;
	MOV	CUR_COLUMN,0		;   CUR_COLUMN := 0			;AN000;
;										;AN000;
;-------Point CURSOR to first character in the next scan line:			;AN000;
	CALL	SET_CURSOR							;AN000;
										;AN000;
	LOOP	PRINT_1_TEXT_LINE	; Print next scan line			;AN000;
										;AN000;
;										;AN000;
;-------Restore CURSOR to its original location (saved on the stack)		;AN000;
PRINT_COLOR_TXT_END:								;AN000;
	POP	DX			; DH := Row number, DL := Column number ;AN000;
	MOV	CL,DH								;AN000;
	MOV	CUR_ROW,CX		; CUR_ROW := Original row number	;AN000;
	MOV	CL,DL								;AN000;
	MOV	CUR_COLUMN,CX		; CUR_COLUMN := Original column number	;AN000;
	CALL	SET_CURSOR		; Set the cursor back there		;AN000;
										;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
PRINT_COLOR_TXT ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SCAN_FOR_BANDS_TEXT: DETERMINE WHAT PRINTER COLOR BANDS ARE NEEDED FOR	;AN000;
;			PRINTING THE COLORS ON THE CURRENT SCREEN LINE. 	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; INPUT:  CUR_ROW	      = row to start scanning				;AN000;
;	  CUR_COLUMN	      = column to start scanning			;AN000;
;	  ROTATE_SW	      = ON if printing is sideways			;AN000;
;										;AN000;
; OUTPUT: REQ_BAND_MASK 							;AN000;
;										;AN000;
;										;AN000;
; DATA STRUCTURE REFERENCED:							;AN000;
;	  XLT_TAB	     = Color translation table				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Read all characters on the current line from left to right.	;AN000;
; For each character, extract its band mask from the color translation table.	;AN000;
; Add the band mask required for this character to the "Required Bands" mask.   ;AN000;
;										;AN000;
; LOGIC :									;AN000;
; Save current coordinates							;AN000;
; DO (SCREEN_WIDTH) TIMES							;AN000;
;   Read a character								;AN000;
;   Get its Band Mask from the color translation table in AL			;AN000;
;   OR REQ_BAND_MASK,AL 	; Add its band mask to the "Required bands" mask;AN000;
;   ; Get coordinates of the next character:					;AN000;
;   INC CUR_COLUMN								;AN000;
; Restore initial coordinates							;AN000;
;										;AN000;
SCAN_FOR_BANDS_TXT PROC NEAR							;AN000;
	PUSH	CUR_ROW 		; Save coordinates			;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	REQ_BAND_MASK,0 	; No Color bands needed so far...	;AN000;
	MOV	CX,SCREEN_WIDTH 	; For each character on the screen row	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR each character on the current scan line:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SCAN_1_CHAR:									;AN000;
;										;AN000;
;-------Read the character at the current cursor position			;AN000;
	CALL	SET_CURSOR		; Set cursor at character to be read	;AN000;
	MOV	AH,READ_CHAR_CALL	; Read one character			;AN000;
	MOV	BH,CUR_PAGE		;  at CUR_PAGE, CUR_COLUMN and CUR_ROW	;AN000;
	INT	10H			; Call BIOS				;AN000;
					; AL:=Character read, AH:=Byte attribute;AN000;
	AND	AH,00001111B		; AH := Foreground color attribute	;AN000;
	XCHG	AL,AH			; AL := AH, used as index in the XLT_TAB;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	XLAT	XLT_TAB 		; AL  = Band mask			;AN000;
;										;AN000;
;-------Obtain what Print bands are required to print the color of this char:	;AN000;
	OR	REQ_BAND_MASK,AL						;AN000;
										;AN000;
	INC	CUR_COLUMN		; Get coordinates of next character	;AN000;
	LOOP	SCAN_1_CHAR		; Scan next character			;AN000;
										;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN		; Restore initial coordinates		;AN000;
	POP	CUR_ROW 							;AN000;
	RET									;AN000;
SCAN_FOR_BANDS_TXT ENDP 							;AN000;
PAGE										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;   PRINT_BAND_TXT: PRINT ALL CHARACTERS ON THE CURRENT LINE THAT ARE THE SAME ;AN000;
;;		     COLOR AS THE CURRENT PRINT BAND.				;AN000;
;;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;  INPUT:  CUR_ROW,								;AN000;
;	   CUR_COLUMN	  : Coordinates of the first character to be read in	;AN000;
;			    the current scan line.				;AN000;
;	   DL		  : Band mask indicating what print band to use 	;AN000;
;			    for this print pass.				;AN000;
;	   SCAN_LINE_LENGTH: Length of the current scan line.			;AN000;
;										;AN000;
;  OUTPUT: PRINTER								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; LOGIC:									;AN000;
;    DO (SCAN_LINE_LENGTH) TIMES						;AN000;
;      CALL BIOS INT 10H Read Character - returns CHAR, COLOR_NUM		;AN000;
;      IF (CUR_BAND_MASK AND XLAT_TAB[COLOR_NUM])=1				;AN000;
;      THEN IF Background color is same as Foreground color			;AN000;
;	    THEN								;AN000;
;	      CALL PRINT_BYTE(SOLID_BOX)					;AN000;
;	    ELSE								;AN000;
;	      CALL PRINT_BYTE(CHAR)						;AN000;
;      ELSE									;AN000;
;	 CALL PRINT_BYTE(blank) 						;AN000;
;      Get coordinates of the next character					;AN000;
;										;AN000;
PRINT_BAND_TXT PROC								;AN000;
SOLID_BOX	EQU	219	; ASCII Code for printing a solid box		;AN000;
BLANK		EQU	32	; ASCII code for printing a space		;AN000;
	PUSH	CUR_COLUMN	; Save column number				;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	MOV	CX,SCREEN_WIDTH ; CX := Number of character on one screen row	;AN000;
;===============================================================================;AN000;
;										;AN000;
; FOR each character on the current row:					;AN000;
;										;AN000;
;===============================================================================;AN000;
PRINT_1_CHAR:									;AN000;
;										;AN000;
;-------Read the character at the current cursor position			;AN000;
	CALL	SET_CURSOR		; Set cursor at character to be read	;AN000;
	MOV	AH,READ_CHAR_CALL	; Read one character			;AN000;
	MOV	BH,CUR_PAGE		;  at CUR_PAGE, CUR_COLUMN and CUR_ROW	;AN000;
	INT	10H			; Call BIOS				;AN000;
					; AL:=Character read, AH:=Byte attribute;AN000;
	MOV	CUR_CHAR,AL							;AN000;
	MOV	DH,AH			; DH := Byte attribute			;AN000;
	AND	DH,11110000B		; DH := Background color		;AN000;
	SHR	DH,1			; DH := Background color right justified;AN000;
	SHR	DH,1								;AN000;
	SHR	DH,1								;AN000;
	SHR	DH,1								;AN000;
	AND	AH,00001111B		; AH := Foreground color right justified;AN000;
;										;AN000;
;-------Test if this character should be printed (need color of the current band;AN000;
	MOV	AL,AH			; AL:=color used as index in the XLT_TAB;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask (DL=current band mask);AN000;
       .IF     <BIT AL AND DL>		;If needs this band to print the color	;AN000;
       .THEN				; of this character			;AN000;
	 .IF	 <AH EQ DH>		; then: when foreground = background	;AN000;
	 .THEN				;	send a solid box		;AN000;
	    MOV     AL,SOLID_BOX	;					;AN000;
	 .ELSE				;	when foreground <> background	;AN000;
	    MOV     AL,CUR_CHAR 	;	send the character		;AN000;
	 .ENDIF 			; Endif foreground = background 	;AN000;
       .ELSE				; else: send a blank			;AN000;
	  MOV	  AL,BLANK		;					;AN000;
       .ENDIF				; Endif color band needed		;AN000;
	CALL	PRINT_BYTE		; Print the byte			;AN000;
	JC	PRINT_BAND_TXT_END	; If printer error occurred: QUIT	;AN000;
	INC CUR_COLUMN			; Else, Get next column; keep going	;AN000;
	LOOP	PRINT_1_CHAR							;AN000;
										;AN000;
PRINT_BAND_TXT_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN		; Restore column number 		;AN000;
	RET									;AN000;
CUR_CHAR	DB ?								;AN000;
PRINT_BAND_TXT ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_COLOR_APA: PRINT AN APA MODE SCREEN ON A COLOR PRINTER			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP	 = Offset of the shared data area			;AN000;
;		XLT_TAB  = Color translation table				;AN000;
;		CUR_MODE_PTR = Coordinates of current DISPLAYMODE info. 	;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Each pixel on the screen is printed as a "box" of dots on the    ;AN000;
; printer. For a screen pixel of a given color, the best color approximation	;AN000;
; is chosen among the color available on the printer.				;AN000;
;										;AN000;
; The printer colors are obtained by selecting a print band. A few more printer ;AN000;
; color are obtained by printing twice (or more times) with different color	;AN000;
; bands.									;AN000;
;										;AN000;
; For example, let's say we have a ribbon on the printer with a YELLOW CYAN     ;AN000;
; MAGENTA ribbon and we read a GREEN pixel on the screen.			;AN000;
;										;AN000;
;   We first determine what "box" size will be used to represent this pixel.    ;AN000;
;   Let's say it's a 3x2 box (this is obtained from the DISPLAYMODE record)     ;AN000;
;   In all cases, we will print this pixel as a 3x2 box of printer dots.	;AN000;
;   That is, we will print 6 dots on the printer for one on the screen. 	;AN000;
;   We do not use any kind of patterns (e,g,. printing only 2 dots out of 6)	;AN000;
;   for printing on the color printer. A screen pixel is either printed 	;AN000;
;   as a "full" box of printer dots or not printed at all (e,g,. if it's white).;AN000;
;										;AN000;
;   Now, from the COLORPRINT records, we know all the colors availables on the	;AN000;
;   printer, and what print bands must be used (or overlaid) in order to	;AN000;
;   obtain them.								;AN000;
;										;AN000;
;   So, we consult these COLORPRINT records one by one comparing how close	;AN000;
;   the color of each of them is to our GREEN pixel. (the colors for our pixel	;AN000;
;   AND for the printer color are both indicated in terms of RGB values)	;AN000;
;   WE PICK THE CLOSEST PRINTER COLOR.						;AN000;
;										;AN000;
;   To conclude, our GREEN pixel will be printed by first selecting the YELLOW	;AN000;
;   band, then sending to the printer a "box".  Then, the BLUE band is selected ;AN000;
;   and the "box" is sent again.                                                ;AN000;
;										;AN000;
; This process is carried line by line. 					;AN000;
;										;AN000;
; For each line, we first read each pixel to see what color bands are going	;AN000;
; to be needed for this line.							;AN000;
;										;AN000;
; Then, we loop for each band available on the printer. 			;AN000;
;										;AN000;
; IF the current line needs the current printer band (i.e.,if any pixel on	;AN000;
;  the line needs this color band in order to achieve its color.		;AN000;
; THEN, we select this color band (we know how to do it from the COLORSELECT	;AN000;
;	record in the Shared Data area) 					;AN000;
;	AND we must read the line again; for each pixel that needs the current	;AN000;
;	band  a "box" is sent to the printer.                                   ;AN000;
;										;AN000;
; LOGIC :									;AN000;
;     CALL INIT_BLACK_BOX		; Initialize a print box		;AN000;
;     CALL GET_SCREEN_INFO							;AN000;
;     CALL SETUP_PRT								;AN000;
;     DO (NB_SCAN_LINES) TIMES							;AN000;
;	  CALL DET_CUR_SCAN_LNE_LENGTH						;AN000;
;	  IF CUR_SCAN_LNE_LENGTH NE 0 THEN					;AN000;
;	    CALL SCAN_FOR_BANDS_APA(CUR_ROW,CUR_COLUMN,REQ_BAND_MASK)		;AN000;
;	    CUR_BAND_MASK := 01H						;AN000;
;	    IF REQ_BAND_MASK <> 0 THEN						;AN000;
;	       DO 8 TIMES							;AN000;
;		  IF (REQ_BAND_MASK AND CUR_BAND_MASK)=1 THEN			;AN000;
;		     CALL NEW_PRT_LINE						;AN000;
;		     CALL PRINT_BAND_APA(CUR_ROW,CUR_COLUMN,CUR_BAND_MASK)	;AN000;
;		     CALL PRINT_BYTE(CARRIAGE_RETURN)				;AN000;
;		  ENDIF 							;AN000;
;		  Shift CUR_BAND_MASK one bit left				;AN000;
;	       ENDDO								;AN000;
;	    ENDIF ; Should make a print pass for this color band		;AN000;
;	    CALL PRINT_BYTE(LINE_FEED)						;AN000;
;	  ENDIF ; Current scan line is not empty				;AN000;
;	  IF rotated print THEN 						;AN000;
;	     CUR_COLUMN := CUR_COLUMN - BOXES_PER_PRT_BUF			;AN000;
;	     CUR_ROW := SAVE_START_ROW						;AN000;
;	  ELSE									;AN000;
;	     CUR_ROW := CUR_ROW + BOXES_PER_PRT_BUF				;AN000;
;	     CUR_COLUMN := SAVE_START_COLUMN					;AN000;
;	  ENDIF 								;AN000;
;     ENDDO ; Number of Scan lines						;AN000;
;     CALL RESTORE_PRT								;AN000;
;										;AN000;
PRINT_COLOR_APA PROC								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
										;AN000;
;-------Initialize print box (A "box" represents one screen pel on the printer) ;AN000;
	CALL INIT_BLACK_BOX							;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;  Determine where to start reading the screen: 				;AN000;
;    If printing sideways, start in LOW LEFT corner.				;AN000;
;    If normal printing, start in TOP LEFT corner.				;AN000;
;  Determine the maximum length for a scan line:				;AN000;
;    If printing sideways, it is the height of the screen.			;AN000;
;    For normal printing, it is the width of the screen.			;AN000;
;  Determine the number of scan lines on the screen.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	GET_SCREEN_INFO 	; Get info. about how to read the screen;AN000;
	CALL	SETUP_PRT		; Set up the printer (Line spacing, etc);AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>					;AN000;
       .THEN				; A printer error occurred: quit	;AN000;
	  JMP	  SHORT  PRINT_COLOR_APA_END	;					;AN000;
       .ENDIF									;AN000;
										;AN000;
	MOV	CX,NB_SCAN_LINES						;AN000;
;----------------------------------------------------------------------------	;AN000;
;										;AN000;
; FOR EACH SCAN LINE ON THE SCREEN (and each print line):			;AN000;
;										;AN000;
;----------------------------------------------------------------------------	;AN000;
PRINT_SCAN_LINE:								;AN000;
	CALL	DET_CUR_SCAN_LNE_LENGTH ; Determine length of the scan line	;AN000;
       .IF <CUR_SCAN_LNE_LENGTH NE 0>	; If line is not empty			;AN000;
       .THEN									;AN000;
	  CALL	  SCAN_FOR_BANDS_APA	  ; REQ_BAND_MASK := Mask for what print;AN000;
					  ;  bands are needed.			;AN000;
	  MOV	  DL,01H		  ; DL := "Current Band to be printed"  ;AN000;
	  MOV	  BX,DS:[BP].COLORSELECT_PTR; BX := Offset of COLORSELECT record;AN000;
	  ADD	  BX,BP 		  ;	("How to select the color band");AN000;
	  PUSH	  CX			  ; Save scan line counter		;AN000;
	  MOV	  CX,8			  ; For up to the maximum number of prin;AN000;
					  ;  bands with this printer		;AN000;
	  ;---------------------------------------------------------------------;AN000;
	  ;									;AN000;
	  ; FOR each Color Band needed: 					;AN000;
	  ;									;AN000;
	  ;---------------------------------------------------------------------;AN000;
       PRINT_1_COLOR_BAND_APA:		  ; Only if this color band is needed:	;AN000;
	   .IF <BIT REQ_BAND_MASK AND DL> ;   Do one pass of the printer head	;AN000;
	   .THEN			  ;					;AN000;
	      CALL    SET_COLOR_BAND	  ; Select the color band on the printer;AN000;
	      CALL    NEW_PRT_LINE	  ; Send escape sequence to the printer ;AN000;
					  ;  for starting a new graphics line	;AN000;
	     .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>				;AN000;
	     .THEN			  ; A printer error occurred:		;AN000;
		POP   CX		  ; Restore the line counter and	;AN000;
		JMP   SHORT  PRINT_COLOR_APA_END ;  return				;AN000;
	     .ENDIF			  ; Endif printer error occurred	;AN000;
										;AN000;
	      CALL PRINT_BAND_APA	  ; Do one Print Pass for current band	;AN000;
	      MOV     AL,CR		  ;   Print a carriage return		;AN000;
	      CALL    PRINT_BYTE						;AN000;
	     .IF      C 		  ; If a printer error occurred 	;AN000;
	     .THEN								;AN000;
		POP   CX		  ; Restore the line counter and	;AN000;
		JMP   SHORT  PRINT_COLOR_APA_END ;  return				;AN000;
	     .ENDIF			  ; End if printer error occurred	;AN000;
	   .ENDIF			  ; End if this color band is needed	;AN000;
	    SHL     DL,1		  ; Get next Color Band mask		;AN000;
					  ; Locate next COLORSELECT record:	;AN000;
	    MOV     AL,[BX].NUM_SELECT_ESC;  skip the escape bytes		;AN000;
	    XOR     AH,AH							;AN000;
	    ADD     BX,AX							;AN000;
	    INC     BX			  ;  skip the NUM_SELECT_ESC field	;AN000;
	  LOOP	  PRINT_1_COLOR_BAND_APA					;AN000;
	  POP	  CX			  ; Restore scan line counter		;AN000;
       .ENDIF ; Scan line length <> 0						;AN000;
;										;AN000;
;-----Print a line feed:							;AN000;
	MOV	AL,LF								;AN000;
	CALL	PRINT_BYTE							;AN000;
	JC	PRINT_COLOR_APA_END	  ; If a printer error occurred: quit	;AN000;
;										;AN000;
;-------Get coordinates of next scan line:					;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				; then: 				;AN000;
	  MOV	  AL,NB_BOXES_PER_PRT_BUF;  AX := Numbers of pels read on row	;AN000;
	  CBW				;					;AN000;
	  ADD	  CUR_COLUMN,AX 	;   CUR_COLUMN + Number of pels read	;AN000;
	  MOV	  AX,SCREEN_HEIGHT	;   CUR_ROW := SCREEN_HEIGHT - 1	;AN000;
	  DEC	  AX			;					;AN000;
	  MOV	  CUR_ROW,AX		;					;AN000;
       .ELSE				; else, printing NOT rotated:		;AN000;
	  MOV	  AL,NB_BOXES_PER_PRT_BUF ; AX := Number of pels read on column ;AN000;
	  CBW				;					;AN000;
	  ADD	  CUR_ROW,AX		;   CUR_ROW + Number of pels read	;AN000;
	  MOV	  CUR_COLUMN,0		;   CUR_COLUMN := 0			;AN000;
       .ENDIF				; End if printing sideways		;AN000;
	LOOP	PRINT_SCAN_LINE 	;					;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Restore the printer (send a Page Eject, etc.) 				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	RESTORE_PRT							;AN000;
PRINT_COLOR_APA_END:								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_COLOR_APA ENDP								;AN000;
PAGE										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;										;AN000;
;;   SCAN_FOR_BANDS_APA : DETERMINE WHAT PRINT BANDS ARE NEEDED FOR THE CURRENT ;AN000;
;;			  PRINT PASS.						;AN000;
;;										;AN000;
;;------------------------------------------------------------------------------;AN000;
;										;AN000;
; INPUT:  CUR_ROW	      : row to start scanning	(word)			;AN000;
;	  CUR_COLUMN	      : column to start scanning (word) 		;AN000;
;	  CUR_SCAN_LNE_LENGTH : length of the current scan line (word)		;AN000;
;	  ROTATE_SW	      = ON if printing is sideways			;AN000;
;										;AN000;
; OUTPUT: REQ_BAND_MASK       : band mask for required bands (byte)		;AN000;
;										;AN000;
;;------------------------------------------------------------------------------;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Shared Data Area								;AN000;
;;   Print Info 								;AN000;
;;   Color Translate Table							;AN000;
;;										;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Read all the dots required for one print line to determine 		;AN000;
;;   the print bands required.	The print line corresponds to several		;AN000;
;;   screen rows (or columns if rotated printing).  The number of		;AN000;
;;   rows / columns per print line is stored in NB_BOXES_PER_PRT_BUF.		;AN000;
;;   The band information is obtained from the Color Translate Table.		;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   PRINT_COLOR_APA								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   READ_DOT, BIOS INT 10H							;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   Save initial coordinates							;AN000;
;;   SAVE_START_COLUMN := CUR_COLUMN						;AN000;
;;   REQ_BAND_MASK := 00H							;AN000;
;;   DO (SCAN_LINE_LENGTH) TIMES						;AN000;
;;	Save coordinates of the "column"                                        ;AN000;
;;	DO (BOXES_PER_PRT_BUF) TIMES						;AN000;
;;	  CALL READ_DOT(IN CUR_ROW,CUR_COLUMN; OUT COLOR_NUM)			;AN000;
;;	   REQ_BAND_MASK := REQ_BAND_MASK OR COLOR_XLAT_TAB[BX] 		;AN000;
;;	   IF rotated print THEN						;AN000;
;;	      Increment CUR_COLUMN						;AN000;
;;	   ELSE 								;AN000;
;;	      Increment CUR_ROW 						;AN000;
;;	   ENDIF								;AN000;
;;	Restore coordinates of the "column"                                     ;AN000;
;;	ENDDO									;AN000;
;;	IF rotated print THEN							;AN000;
;;	   Decrement CUR_ROW							;AN000;
;;	ELSE									;AN000;
;;	   Increment CUR_COLUMN 						;AN000;
;;	ENDIF									;AN000;
;;   ENDDO									;AN000;
;;   Restore initial coordinates						;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	;AN000;
SCAN_FOR_BANDS_APA PROC NEAR							;AN000;
	PUSH	CUR_ROW 							;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	REQ_BAND_MASK,0 	; No Color bands needed so far...	;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	MOV	CX,CUR_SCAN_LNE_LENGTH						;AN000;
;===============================================================================;AN000;
;										;AN000;
; FOR each column on the current scan line (up to the last non=blank):		;AN000;
;										;AN000;
;===============================================================================;AN000;
SCAN_1_COLUMN:									;AN000;
	PUSH	CX			; Save column counter			;AN000;
	PUSH	CUR_ROW 		; Save coordinates of the "column"      ;AN000;
	PUSH	CUR_COLUMN							;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; For each pixel within the current column of the scan line:			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	XOR	CX,CX			; CX := Number of pixels to read	;AN000;
	MOV	CL,NB_BOXES_PER_PRT_BUF ;   within the current "column"         ;AN000;
SCAN_1_PIXEL:									;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask			;AN000;
	OR	REQ_BAND_MASK,AL	; Add bands required for this pixel	;AN000;
										;AN000;
;-------Get coordinates of next pixel:						;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  INC CUR_COLUMN		; then, increment column number 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_ROW			; else, increment row number		;AN000;
       .ENDIF				;					;AN000;
	LOOP SCAN_1_PIXEL							;AN000;
	POP	CUR_COLUMN		; Restore coordinates of the "column"   ;AN000;
	POP	CUR_ROW 		;					;AN000;
	POP	CX			; Restore column counter		;AN000;
										;AN000;
										;AN000;
;-------Get coordinates of next "column":                                       ;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  DEC CUR_ROW			; then, get row above on screen 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_COLUMN		; else, get column next right		;AN000;
       .ENDIF				;					;AN000;
	LOOP	SCAN_1_COLUMN							;AN000;
										;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN							;AN000;
	POP	CUR_ROW 							;AN000;
	RET									;AN000;
SCAN_FOR_BANDS_APA ENDP 							;AN000;
PAGE										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;   PRINT_BAND_APA : PRINT ALL DOTS ON CURRENT LINE THAT NEED THE CURRENT BAND ;AN000;
;;		      TO APPROXIMATE THEIR COLOR.				;AN000;
;;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;  INPUT:  CUR_ROW,								;AN000;
;	   CUR_COLUMN	  : Coordinates of the first pixel to be read in the	;AN000;
;			    current scan line.					;AN000;
;	   DL		  : Band mask indicating what print band to use 	;AN000;
;			    for this print pass.				;AN000;
;	   CUR_SCAN_LNE_LENGTH: Length of the current scan line.		;AN000;
;	   ROTATE_SW	   = ON if printing is sideways 			;AN000;
;										;AN000;
;  OUTPUT: PRINTER								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Shared Data Area								;AN000;
;;   Print Info 								;AN000;
;;   Color Translate Table							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Print all dots on this print line which need the current			;AN000;
;;   band. The print line corresponds to several				;AN000;
;;   screen rows (or columns if rotated printing).  The number of		;AN000;
;;   rows / columns per print line is stored in NB_BOXES_PER_PRT_BUF.		;AN000;
;;   The band information is obtained from the Color Translate Table.		;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   PRINT_COLOR_APA								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   READ_DOT, BIOS INT 10H, STORE_BOX, PRT_BUFFER, PRINT_BYTE			;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   SAVE_START_ROW := CUR_ROW							;AN000;
;;   SAVE_START_COLUMN := CUR_COLUMN						;AN000;
;;										;AN000;
;;   CALL SET_COLOR_BAND	; Select the color for this print pass		;AN000;
;;   DO (SCAN_LINE_LENGTH) TIMES						;AN000;
;;	Save coordinates of the "column"                                        ;AN000;
;;	Clear the print buffer							;AN000;
;;	DO (BOXES_PER_PRT_BUF) TIMES						;AN000;
;;	   CALL READ_DOT(CUR_ROW,CUR_COLUMN,COLOR_NUM)				;AN000;
;;	   IF (CUR_BAND_MASK AND XLAT_TAB[COLOR_NUM])=1 THEN			;AN000;
;;	      CALL STORE_BOX(black box) 					;AN000;
;;	   ELSE 								;AN000;
;;	      CALL STORE_BOX(white box) 					;AN000;
;;	   ENDIF								;AN000;
;;	   IF rotated print THEN						;AN000;
;;	      Decrement CUR_COLUMN						;AN000;
;;	   ELSE 								;AN000;
;;	      Increment CUR_ROW 						;AN000;
;;	   ENDIF								;AN000;
;;	ENDDO									;AN000;
;;	CALL PRINT_BUFFER							;AN000;
;;	Restore coordinates of the "column"                                     ;AN000;
;;	; Get coordinates of the next "column";                                 ;AN000;
;;	IF rotated print THEN							;AN000;
;;	   Decrement CUR_ROW							;AN000;
;;	   CUR_COLUMN := SAVE_START_COLUMN					;AN000;
;;	ELSE									;AN000;
;;	   Increment CUR_COLUMN 						;AN000;
;;	   CUR_ROW := SAVE_START_ROW						;AN000;
;;	ENDIF									;AN000;
;;   ENDDO									;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
PRINT_BAND_APA	    PROC NEAR							;AN000;
	PUSH	CUR_ROW 		; Save coordinates			;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	MOV	CX,CUR_SCAN_LNE_LENGTH						;AN000;
;===============================================================================;AN000;
;										;AN000;
; FOR each column on the current scan line (up to the last non=blank):		;AN000;
; (One "column" contains the number of pixels required to fill the Print buffer);AN000;
;										;AN000;
;===============================================================================;AN000;
PRINT_1_COLUMN: 								;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Clear the print buffer "PRT_BUF"                                              ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	XOR	DI,DI		; DI := Number of bytes cleared in the buffer	;AN000;
	XOR	AX,AX								;AN000;
	MOV	AL,BOX_W	; AX := Number of bytes in the print buffer	;AN000;
CLEAR_BUF:			; For each byte in the PRT_BUF: 		;AN000;
	MOV	PRT_BUF[DI],0	;    Initialize byte to blanks			;AN000;
	INC	DI		;    One more has been cleared			;AN000;
	CMP	DI,AX		;    All bytes cleared ?			;AN000;
	JL	CLEAR_BUF	;	 No, clear next one.			;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Fill up the print buffer "PRT_BUF"                                            ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	PUSH	CX			; Save column counter			;AN000;
	XOR	CX,CX			; CX := Number of pixels to read	;AN000;
	MOV	CL,NB_BOXES_PER_PRT_BUF ;   within the current "column"         ;AN000;
					;    of the scan line			;AN000;
	PUSH	CUR_ROW 		; Save coordinates of the "column"      ;AN000;
	PUSH	CUR_COLUMN							;AN000;
;										;AN000;
; For each pixel within the current column of the scan line:			;AN000;
STORE_1_PIXEL:									;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask			;AN000;
       .IF <BIT AL AND DL>		; If color of the current pixel needs	;AN000;
       .THEN				;  the current printer band		;AN000;
	  MOV	SI,OFFSET BLACK_BOX	; then, store a box in the		;AN000;
	  CALL STORE_BOX		;	 PRT_BUF			;AN000;
       .ELSE				;					;AN000;
	  MOV	SI,OFFSET WHITE_BOX	;  else, store an empty box		;AN000;
	  CALL STORE_BOX		;	  in the PRT_BUF		;AN000;
       .ENDIF									;AN000;
;										;AN000;
;-------Get coordinates of next pixel:						;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  INC CUR_COLUMN		; then, increment column number 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_ROW			; else, increment row number		;AN000;
       .ENDIF				;					;AN000;
	LOOP STORE_1_PIXEL							;AN000;
										;AN000;
	POP	CUR_COLUMN		; Restore coordinates of the "column"   ;AN000;
	POP	CUR_ROW 		;					;AN000;
	POP	CX			; Restore column counter		;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Print the PRT_BUF:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	PRINT_BUFFER							;AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>					;AN000;
       .THEN				; A printer error occurred: QUIT	;AN000;
	  JMP SHORT PRINT_BAND_APA_END	;					;AN000;
       .ENDIF									;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Get coordinates of next "column":                                             ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  DEC CUR_ROW			; then, get row above on screen 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_COLUMN		; else, get column next right		;AN000;
       .ENDIF				;					;AN000;
	LOOP	PRINT_1_COLUMN							;AN000;
										;AN000;
PRINT_BAND_APA_END:								;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN		; Restore initial coordinates		;AN000;
	POP	CUR_ROW 							;AN000;
	RET									;AN000;
PRINT_BAND_APA	ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SET_CURSOR : SET THE CURSOR TO CUR_ROW, CUR_COLUMN AND CUR_PAGE		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	CUR_ROW,							;AN000;
;		CUR_COLUMN  = Coordinates for the cursor (word) 		;AN000;
;		CUR_PAGE    = Page for which to set the cursor (byte)		;AN000;
;										;AN000;
;	OUTPUT: SCREEN								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SET_CURSOR PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	DX								;AN000;
	MOV	DH,BYTE PTR CUR_ROW						;AN000;
	MOV	DL,BYTE PTR CUR_COLUMN						;AN000;
	MOV	BH,CUR_PAGE							;AN000;
	MOV	AH,SET_CURSOR_CALL	; Set cursor request			;AN000;
	INT	10H			; Call BIOS				;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
SET_CURSOR ENDP 								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SET_COLOR_BAND : SET THE PRINTER TO THE CURRENT COLOR BAND			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: BX	= Offset of current COLORSELECT record in the		;AN000;
;			  Shared data area.					;AN000;
;	       DS:[BP]	= Offset of shared data area				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SET_COLOR_BAND PROC NEAR							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
;-------Send the escape sequence for selecting this color band to the printer:	;AN000;
	XOR	CX,CX								;AN000;
	MOV	CL,[BX].NUM_SELECT_ESC	; CX := Number of bytes to send 	;AN000;
	ADD	BX,OFFSET SELECT_ESC	; BX := Offset of bytes to send 	;AN000;
SEND_1_COLORSELECT_BYTE:							;AN000;
	MOV	AL,[BX] 		; AL := Byte to send to printer 	;AN000;
	CALL	PRINT_BYTE		; Send it				;AN000;
	JC	SET_COLOR_BAND_END	; If printer error: return		;AN000;
	INC	BX			; Get next byte 			;AN000;
	LOOP	SEND_1_COLORSELECT_BYTE 					;AN000;
										;AN000;
SET_COLOR_BAND_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
SET_COLOR_BAND ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; INIT_BLACK_BOX: INIT. THE BOX FOR PRINTING APA MODE DOTS ON A COLOR PRINTER.	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BOX_W,								;AN000;
;		BOX_H		= Size of the print box for one pixel.		;AN000;
;										;AN000;
;	OUTPUT: BLACK_BOX	= A box for which all dots are on.		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Initialize the print box used to print a screen pixel.		;AN000;
;										;AN000;
; For example,									;AN000;
; with a size of 3x2 the BLACK_BOX will use 3 bytes:				;AN000;
;										;AN000;
;										;AN000;
;	  byte1     byte2     byte3						;AN000;
;	(column1) (column2) (column3)						;AN000;
;  bit 7 -->0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    1	       1	 1						;AN000;
;  bit 0 -->1	       1	 1						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
INIT_BLACK_BOX PROC NEAR							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
;-------Build one box column:							;AN000;
	XOR	CX,CX								;AN000;
	MOV	CL,BOX_H	; CX := Height in bits of the print box 	;AN000;
	XOR	AL,AL		; AX := Bit mask for creating box column	;AN000;
       .REPEAT			; For height of the box:			;AN000;
	  SHL	  AL,1		;						;AN000;
	  OR	  AL,1		;   Insert one bit in the box column		;AN000;
       .LOOP									;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	AL now contains one box column. 					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
										;AN000;
;-------Replicate this column over all columns of the box.			;AN000;
	XOR	BX,BX		; BX := Index into the BOX			;AN000;
INIT_1_BLACK_COLUMN:								;AN000;
	MOV	BLACK_BOX[BX],AL; Init current column to black box column	;AN000;
	INC	BX		; Get next column				;AN000;
	CMP	BL,BOX_W							;AN000;
	JL	INIT_1_BLACK_COLUMN						;AN000;
										;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
INIT_BLACK_BOX ENDP								;AN000;
INCLUDE GRCOMMON.ASM								;AN000;
LEN_OF_COLOR_MODULES EQU $-PRINT_COLOR						;AN000;
CODE	ENDS									;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grcpsd.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Copy Shared Data
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRCPSD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the COPY_SHARED_DATA module.			;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 COPY_SHARED_DATA - Copy the Shared Data Area from temporary		;AN000;
;;			    build area to resident memory & exit to DOS 	;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 None									;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
	ASSUME CS:CODE,DS:CODE	       ;;					;AN000;
	INCLUDE GRCTRL.EXT	       ;; Bring in external declarations	;AN000;
	INCLUDE GRCTRL.STR	       ;;  for transient command processing	;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC COPY_SHARED_DATA	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   COPY_SHARED_DATA								;AN000;
;;										;AN000;
;; Input Parameters:								;AN000;
;;   DS : SI - points to the Temporary Shared Data Area 			;AN000;
;;   ES : DI - destination for resident Shared Data Area			;AN000;
;;   BP      - offset for new Shared Data Area (same as DI)			;AN000;
;;   AH    - Function code for exiting to DOS:					;AN000;
;;	     31H : Terminate & Stay Resident - if first time			;AN000;
;;	     4CH : Terminate - if already installed				;AN000;
;;   DX    - resident data segment size in paragraphs				;AN000;
;;										;AN000;
;; Output Parameters:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Control Variables								;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Copy the Temporary Shared Data area over the installation modules		;AN000;
;;   and terminate (stay resident).  The data is copied immediately		;AN000;
;;   following this module.							;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   GRAPHICS_INSTALL								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   Copy Temporary Shared Data Area						;AN000;
;;   Set PRINT_SCREEN_ALLOWED to YES						;AN000;
;;   Exit to DOS (Function Code 31 or 4C setup by caller)			;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
COPY_SHARED_DATA  PROC NEAR	       ;;					;AN000;
				       ;;					;AN000;
	REP	MOVSB		       ;; Copy Shared Data from temporary	;AN000;
				       ;;  build area to resident memory	;AN000;
				       ;; Allow print screens now		;AN000;
	MOV	ES:PRINT_SCREEN_ALLOWED,YES					;AN000;
				       ;;					;AN000;
	INT	21H		       ;; Exit					;AN000;
				       ;;					;AN000;
COPY_SHARED_DATA  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
CODE	ENDS									;AN000;
	END COPY_SHARED_DATA							;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grint2fh.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Interrupt 2FH Driver		;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                             
;;										;AN000;
;; File Name:  GRINT2FH.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the Interrupt 2FH driver.				;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 INT_2FH_DRIVER - Interrupt 2FH driver					;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRLOAD.EXT - Externals for profile load				;AN000;
;;	 GRCTRL.EXT - Externals for print screen control			;AN000;
;;	 GRPRINT.EXT - Externals for print modules				;AN000;
;;	 GRCPSD.EXT - Externals for COPY_SHARED_DATA module			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 Calls next Int 2FH handler in the chain.				;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:	
;; ---------------
;;	M001	NSM 	1/30/91	  New int 10 handler to trap alt-prt-sc select
;;				   calls made by ANSI.SYS. For these calls, we
;;				   we need to reinstall our int 5 handler again
;;	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
	PUBLIC	OLD_INT_2FH	       ;;					;AN000;
	PUBLIC	INT_2FH_DRIVER	       ;;					;AN000;
	PUBLIC	INT_10H_DRIVER	       ;;					;AN000;
	PUBLIC	PRT_SCR_2FH_NUMBER     ;;					;AN000;
	PUBLIC	RESIDENT_CODE_SEG      ;;					;AN000;
	PUBLIC	SHARED_DATA_AREA_PTR   ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
.XLIST										;AN000;
INCLUDE STRUC.INC								;AN000;
INCLUDE GRINST.EXT								;AN000;
INCLUDE GRCTRL.EXT								;AN000;
INCLUDE GRCPSD.EXT								;AN000;
.LIST										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module: INT_2FH_DRIVER							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;     Respond to GRAPHICS Int 2FH calls.					;AN000;
;;     The following calls are handled: 					;AN000;
;;										;AN000;
;;	AL = 0  Install Check							;AN000;
;;										;AN000;
;; Invoked By:									;AN000;
;;     INT 2FH instruction.							;AN000;
;;										;AN000;
;; Modules Called:								;AN000;
;;     Lower level INT 2FH handlers.						;AN000;
;;										;AN000;
;; Input Registers:								;AN000;
;;     Install Check - AH=ACH  AL=0						;AN000;
;;										;AN000;
;;										;AN000;
;; Output Registers:								;AN000;
;;     Install Check:  IF GRAPHICS installed					;AN000;
;;			  AH=FFH  AL=FFH					;AN000;
;;			  ES : DI points to Shared Data Area			;AN000;
;;		       ELSE							;AN000;
;;			  AH=ACH  AL=0						;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;     IF AH=ACH THEN								;AN000;
;;	  IF AL=0 THEN								;AN000;
;;	     AH,AL := -1							;AN000;
;;	     ES : DI := SHARED_DATA_AREA_PTR					;AN000;
;;	  ENDIF 								;AN000;
;;	  IRET									;AN000;
;;     ELSE									;AN000;
;;	  IF OLD_INT_2FH is a valid pointer THEN				;AN000;
;;	      Jump to Old Int 2FH						;AN000;
;;	  ELSE									;AN000;
;;	      IRET								;AN000;
;;	  ENDIF 								;AN000;
;;     ENDIF									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
INT_2FH_DRIVER	PROC  NEAR							;AN000;
	JMP	SHORT	INT_2FH 							;AN000;
PRT_SCR_2FH_NUMBER EQU	       0ACH	; 2FH Multiplex interrupt number	;AN000;
					;  assigned to Print Screen.		;AN000;
OLD_INT_2FH	DD    ? 		; Pointer to next 2FH interrupt handler ;AN000;
RESIDENT_CODE_SEG	DW   ?	; Segment for installed stuff			;AN000;
SHARED_DATA_AREA_PTR	DW   ?	; Offset of the start of the			;AN000;
				;  Shared Data Area				;AN000;
										;AN000;
INT_2FH:									;AN000;
;-------------------------------------------------------------------------------;AN000;
; Verify if the 2FH Interrupt call is for our interrupt handler:		;AN000;
;-------------------------------------------------------------------------------;AN000;
       .IF <AH EQ PRT_SCR_2FH_NUMBER> AND;If 2FH call is for us 		;AN000;
       .IF <ZERO AL>			;  and request is "Get install state"   ;AN000;
       .THEN				; then, 				;AN000;
;-------------------------------------------------------------------------------;AN000;
; Yes: return results								;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	DI,CS:SHARED_DATA_AREA_PTR ;  ES:DI :=	Pointer to shared	;AN000;
	PUSH	CS:RESIDENT_CODE_SEG	   ;		 data area		;AN000;
	POP	ES			;					;AN000;
	MOV	AH,0FFH 		; AL and AH := "We are installed"       ;AN000;
	MOV	AL,AH			;					;AN000;
	IRET				; Return to interrupted process 	;AN000;
;-------------------------------------------------------------------------------;AN000;
; No, pass control to next 2FH interrupt handler:				;AN000;
;-------------------------------------------------------------------------------;AN000;
       .ELSE				; else, this call is not for us:	;AN000;
	 .IF <<WORD PTR CS:OLD_INT_2FH> NE 0> AND ;if there is another		;AN000;
	 .IF <<WORD PTR CS:OLD_INT_2FH+2> NE 0> ;  2FH driver			;AN000;
	 .THEN				;	below us then,			;AN000;
	    JMP CS:OLD_INT_2FH		;	  pass control to it		;AN000;
	 .ELSE				;	else, there is nobody to pass	;AN000;
	    IRET			;	  control to, just return.	;AN000;
	 .ENDIF 			;     END If there is a driver below us.;AN000;
      .ENDIF				;  END If this call is for us.		;AN000;
INT_2FH_DRIVER	ENDP								;AN000;
										;AN000;

;/*M001 BEGIN */
;========================================================================
; INT_10h_Driver :
;    int 10 handler to check for alt-prt-sc-select calls (ah=12,bl=20h)
;    Other int 10 calls are passed on. For alt-prt-sc-select calls,
;    old int 10 is called and after return, we reinstall our int 5 (prt_sc)
;    vector back again ( if it was changed by ANSI.SYS).
;=======================================================================
INT_10H_DRIVER	PROC	NEAR

	sti 					; restore interrupts
	cmp	ah,ALTERNATE_SELECT		; see if the call is for
	jnz	go_old_int10			; alt_prt_sc; if so
	cmp	bl,ALT_PRT_SC_SELECT		; call int 10 and then
	jz	Set_Our_Int5_handler		; restore out PRT_SC vector
go_old_int10:						; other int 10 calls
	jmp	DWORD PTR cs:OLD_INT_10H		; ...pass it on.

; the call is for alternate prt Screen int 10
; call the old int 10 handler and then restore our int 5 vector back again

Set_Our_Int5_handler:
	pushf
	call	DWORD PTR cs:OLD_INT_10H	; call the prev.int 10 handler
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	xor	ax,ax		
	mov	ds,ax			; ds-> 0 to get at int.vector table
	mov	si,5 * 4		; ds:si  -> ptr to int 5 vector
	mov	cx,cs		
	mov	dx,offset PRT_SCR

	cli
	mov	ax,ds:[si+2]		; segment for current int 5 vector
	cmp	ax,cx			; is it changed by ROM BIOS
	je	no_int5_chg		
	mov	bx,ds:[si]		
	cmp	bx, dx	;further sanity check  for offset
	je	no_int5_chg		

; cx:dx = our int 5 handler
; ax:bx = current int 5 handler
; store the current int 5 handler as the old handler and install ourselves
; again	

	mov	ds:[si],dx		; store offset
	mov	ds:[si+2],cx		; store segment
	mov	CS:[BIOS_INT_5H],bx	; store old int5 vector
	mov	CS:[BIOS_INT_5H +2],ax

no_int5_chg:
	sti
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax

	iret

INT_10H_DRIVER	ENDP

; /* M001 END */

CODE   ENDS									;AN000;
       END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grinst.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I changed the default printer type from GRAPHICS to HPDEFAULT 
;**                because we have a section in the profile under 'HPDEFAULT' that
;**                will satisfactorily handle all of our printers.  I also changed
;**                the number of bytes for the printer type from 9 to 16 because
;**                of the RUGGEDWRITERWIDE.
;**  
;**  DOCUMENTATION NOTES:  This version of GRINST.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								
	TITLE	DOS - GRAPHICS Command  -	Installation Modules		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;; DOS - GRAPHICS Command
;;                                   
;;										
;; File Name:  GRINST.ASM							
;; ----------									
;;										
;; Description: 								
;; ------------ 								
;;	 This file contains the installation modules for the			
;;	 GRAPHICS command.							
;;										
;;	 GRAPHICS_INSTALL is the main module.					
;;										
;;	 GRAPHICS_INSTALL calls modules in GRLOAD.ASM to load			
;;	 the GRAPHICS profile and GRPARMS.ASM to parse the command line.	
;;										
;;										
;; Documentation Reference:							
;; ------------------------							
;;	 OASIS High Level Design						
;;	 OASIS GRAPHICS I1 Overview						
;;	 DOS 3.3 Message Retriever Interface Supplement. 			
;;	 TUPPER I0 Document - PARSER HIGH LEVEL DESIGN REVIEW			
;;										
;; Procedures Contained in This File:						
;; ----------------------------------						
;;	 GRAPHICS_INSTALL - Main installation module				
;;	 CHAIN_INTERRUPTS - Chain interrupts 5, 2F, EGA Save Pointers		
;;	 COPY_PRINT_MODULES - Throw away one set of print modules		
;;										
;;										
;; Include Files Required:							
;; -----------------------							
;;	 GRLOAD.EXT   - Externals for profile load				
;;	 GRLOAD2.EXT  - Externals for profile load				
;;	 GRCTRL.EXT   - Externals for print screen control			
;;	 GRPRINT.EXT  - Externals for print modules				
;;	 GRCPSD.EXT   - Externals for COPY_SHARED_DATA module			
;;	 GRPARMS.EXT  - External for GRAPHICS command line parsing		
;;	 GRPARSE.EXT  - External for DOS parser 				
;;	 GRBWPRT.EXT  - Externals for Black and white printing modules		
;;	 GRCOLPRT.EXT - Externals for color printing modules			
;;	 GRINT2FH.EXT - Externals for Interrupt 2Fh driver.			
;;										
;;	 GRMSG.EQU    - Equates for the GRAPHICS error messages 		
;;	 SYSMSG.INC   - DOS message retriever					
;;										
;;	 GRSHAR.STR   - Shared Data Area Structure				
;;										
;;	 STRUC.INC    - Macros for using structured assembly language		
;;										
;; External Procedure References:						
;; ------------------------------						
;;	 FROM FILE  GRLOAD.ASM: 						
;;	      LOAD_PROFILE - Main module for profile loading			
;;	 SYSPARSE   - DOS system parser 					
;;	 SYSDISPMSG - DOS message retriever					
;;										
;; Linkage Instructions:							
;; -------------------- 							
;;	 Refer to GRAPHICS.ASM							
;;										
;; Change History:								
;; ---------------								
;; M001	NSM	1/30/91		Install our int 10 handler also along with
;;				int 2f and int 5 handlers to take care of alt
;;				prt-sc select calls made by ANSI.SYS
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       
	ASSUME	CS:CODE,DS:CODE        ;;					
				       ;;					
.XLIST				       ;;					
	INCLUDE GRSHAR.STR	       ;; Include the Shared data area structure
	INCLUDE SYSMSG.INC	       ;; Include DOS message retriever 	
	INCLUDE STRUC.INC	       ;; Include macros - Structured Assembler 
	INCLUDE GRLOAD.EXT	       ;; Bring in external declarations	
	INCLUDE GRLOAD2.EXT	       ;;					
	INCLUDE GRLOAD3.EXT	       ;;					
	INCLUDE GRCTRL.EXT	       ;;					
	INCLUDE GRBWPRT.EXT	       ;;					
	INCLUDE GRCOLPRT.EXT	       ;;					
	INCLUDE GRCPSD.EXT	       ;;					
	INCLUDE GRINT2FH.EXT	       ;;					
	INCLUDE GRCTRL.EXT	       ;;					
	INCLUDE GRPARSE.EXT	       ;;					
	INCLUDE GRPARMS.EXT	       ;;					
	INCLUDE GRMSG.EQU	       ;;					
				       ;;					
MSG_UTILNAME <GRAPHICS> 	       ;; Identify ourself to Message retriever.
				       ;; Include messages			
MSG_SERVICES <MSGDATA>		       ;;					
MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg>  ;;				
MSG_SERVICES <GRAPHICS.CL1,GRAPHICS.CL2,GRAPHICS.CLA,GRAPHICS.CLB,GRAPHICS.CLC> 
.LIST				       ;;					
				       ;;					
PUBLIC GRAPHICS_INSTALL 	       ;;					
PUBLIC CHAIN_INTERRUPTS
PUBLIC TEMP_SHARED_DATA_PTR	       ;;					
PUBLIC PRINTER_TYPE_PARM	       ;;					
PUBLIC PRINTER_TYPE_LENGTH	       ;;					
PUBLIC PROFILE_PATH		       ;;					
PUBLIC PRINTBOX_ID_PTR		       ;;					
PUBLIC PRINTBOX_ID_LENGTH	       ;;					
PUBLIC DEFAULT_BOX		       ;;					
PUBLIC LCD_BOX			       ;;					
PUBLIC NB_FREE_BYTES		       ;;					
PUBLIC SYSDISPMSG		       ;;					
PUBLIC DISP_ERROR		       ;;					
PUBLIC INSTALLED		       ;;					
PUBLIC ERROR_DEVICE		       ;;					
PUBLIC STDERR			       ;;					
PUBLIC STDOUT			       ;;					
PUBLIC RESIDENT_SHARED_DATA_SIZE       ;;					
				       ;;					
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;;										
;; Install Variables								
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
NO		      EQU   0	       ;;					
YES		      EQU   1	       ;;					
INSTALLED	      DB    NO	       ;; YES if GRAPHICS already installed	
				       ;;					
				       ;;					
BYTES_AVAIL_PSP_OFF   EQU   6	       ;; Word number 6 of the PSP is the	
				       ;;  number of bytes available in the	
				       ;;   current segment			
				       ;;					
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;;										
;; GRLOAD (PROFILE LOADING) INPUT PARMS:					
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;\/ ~~mda ----------------------------------------------------------------------------
;               Changed the default printer type from GRAPHICS to HPDEFAULT,
;               which really isn't a printer type.  In the GRAPHICS.PRO
;               file there is a section that starts 'PRINTER HPDEFAULT'
;               that has all the necessary parms to support all HP printers
;               satisfactorily.  Also changed the number of bytes for the
;               printer type from 9 to 16 because of the RUGGEDWRITERWIDE.
;
;	MD 6/4/90 - this is a backwards compatibility problem.	Changed default
;		    back to Graphics

PRINTER_TYPE_PARM    DB    "GRAPHICS",9 DUP(0) ; Printer type			
				       ;;  (default=Graphics)			
;/\ ~~mda -----------------------------------------------------------------------------
PRINTER_TYPE_LENGTH  DB    17	       ;; Printer type maximum length of ASCIIZ 
PROFILE_PATH	     DB    128 DUP(0)  ;;  Profile name with full path		
				       ;;   (Max size for ASCIIZ is 128)	
PRINTBOX_ID_PTR      DW    DEFAULT_BOX ;;  Offset of ASCIIZ string containing	
DEFAULT_BOX	     DB    "STD",14 DUP(0);  the printbox id. (DEFAULT = STD)   
LCD_BOX 	     DB    "LCD",14 DUP(0); ASCIIZ string for the LCD printboxID
PRINTBOX_ID_LENGTH   DB    17	       ;;  Max. length for the printbox id.	
				       ;;   ASCIIZ string			
NB_FREE_BYTES	     DW    ?	       ;;  Number of bytes available in our	
				       ;;   resident segment			
RESIDENT_SHARED_DATA_SIZE  DW ?        ;;  Size in bytes of the RESIDENT Shared 
				       ;;   data area (if GRAPHICS already	
				       ;;    installed).			
END_OF_RESIDENT_CODE DW    ?	       ;; Offset of the end of the code that	
				       ;;  has to be made resident.		
TEMP_SHARED_DATA_PTR DW    ?	       ;; Offset of the temporary Shared area	
				       ;;					
ERROR_DEVICE   DW   STDERR	       ;; Device DISP_ERROR will output 	
				       ;;  messages to (STDERR or STDOUT)	
PAGE										
;===============================================================================
;										
; GRAPHICS_INSTALL : INSTALL GRAPHICS.COM					
;										
;-------------------------------------------------------------------------------
;										
;  INPUT:   Command line parameters						
;	    GRAPHICS profile - A file describing printer characteristics and	
;			       attributes.					
;										
;  OUTPUT:  If first time invoked:						
;	      INT 5 VECTOR and INT 2FH VECTOR are replaced; only the required	
;	      code for printing the screen is made resident.			
;	    else,								
;	      The resident code is updated to reflect changes in printing	
;	      options.								
;										
;-------------------------------------------------------------------------------
;;										
;; DESCRIPTION: 								
;;										
;;   This module intalls GRAPHICS code and data.				
;;										
;;   An INT 2FH driver is also installed.					
;;										
;;   If this driver is already present then, we assume GRAPHICS was installed	
;;   and do not install it again but, simply update the resident code.		
;;										
;;   The resident code contains ONLY the code and data needed for Printing	
;;   the screen. The code needed is determined according to the command line	
;;   parameters and the information extracted from the printer profile. 	
;;										
;;   The printer profile is parsed according to the current hardware setting	
;;   and also to the command line options. The information extracted from	
;;   the profile is stored in a Data area shared between the installation	
;;   process and the Print Screen process.					
;;										
;;   A temporary Shared Data Area is FIRST built at the end of the .COM file	
;;   Before building it, we verify that there is				
;;   enough memory left in the current segment.  If not, the installation	
;;   process is aborted.							
;;										
;;   This temporary Data area when completed will be copied over the		
;;   installation code. Therefore, the file comprising GRAPHICS must be 	
;;   linked in a specific order with the installation modules being last.	
;;										
;;   These modules will be overwritten by the Shared Data area and the EGA	
;;   dynamic save area before we exit and stay resident.			
;;										
;;   The end of the resident code is the end of the Shared Data area, anything	
;;   else beyond that is not made resident.					
;;										
;;   The pointer to the resident Shared Data area is declared within the	
;;   Interrupt 2Fh driver. This pointer is initialized by the installation	
;;   process and points to the shared data area at Print Screen time.		
;;										
;;   Depending on the type of printer attached (i.e., Black and white or Color) 
;;   only one set of modules is made resident during the installation.		
;;										
;;   The set of print modules required is copied over the previous one at	
;;   location "PRINT_MODULE_START". This location is declared within            
;;   GRCOLPRT which must be linked before GRBWPRT				
;;										
;;   When copying one of the 2 sets of print modules we reserve enough space	
;;   for the larger of them. Therefore, if GRAPHICS is already installed but	
;;   is reinvoked with a different printer type which needs a bigger set of	
;;   modules: this new set of modules is simply recopied over the existing	
;;   one in the resident code.							
;;										
;;   The Shared Data area is copied rigth after the set of modules that we keep 
;;   that is, over the unused set of modules.					
;;										
;;										
;-------------------------------------------------------------------------------
;;										
;; Register Conventions:							
;;   BP - points to start of Temp Shared Data (Transiant code)			
;;										
;; Called By:									
;;   Entry point for GRAPHICS command processing.				
;;										
;; External Calls:								
;;   INT 2FH, LOAD_MESSAGES, LOAD_PROFILE, PARSE_PARMS				
;;   CHAIN_INTERRUPTS, COPY_SHARED_DATA, DISPLAY_MESSAGE			
;;   COPY_PRINT_MODULES 							
;;										
;-------------------------------------------------------------------------------
;;										
;; LOGIC:									
;;   Load the message retriever 						
;;   IF carry flag is set (incorrect DOS version) THEN				
;;	Issue message (COMMON1) 						
;;	Exit									
;;   ENDIF									
;;										
;;   Get number of bytes available in the segment from PSP (word 6)		
;;   /* This is needed since we construct a temporary Shared data area at the	
;;   of the .COM file */							
;;										
;;   /* Build Shared Data in temporary area */					
;;   END_OF_RESIDENT_CODE := (end of .COM file) 				
;;   NB_FREE_BYTES    := Number of bytes availables				
;;										
;;   CALL PARSE_PARMS								
;;   IF error THEN	/* PARSE_PARMS will issue messages */			
;;	Exit									
;;   ENDIF									
;;										
;;   CALL LOAD_PROFILE								
;;   IF profile errors THEN							
;;	Exit		/* LOAD_PROFILE will issue messages */			
;;   ENDIF									
;;										
;;   Issue INT 2FH Install Check call (AX=AC00H)				
;;   /* INT 2FH returns ES:[DI] pointing to the shared data area */		
;;   IF already installed THEN							
;;   THEN									
;;	Move NO to PRINT_SCREEN_ALLOWED in resident Shared Data 		
;;	SHARED_DATA_AREA_PTR := DI						
;;   ELSE									
;;	MOV PRINT_SCREEN_ALLOWED,NO						
;;	CALL CHAIN_INTERRUPTS	/* Install INT 5 and INT 2FH vectors */ 	
;;	ES := Our segment							
;;   ENDIF									
;;   /* Keep only Print Black and White or Print Color: */			
;;   CALL COPY_PRINT_MODULES							
;;	/* COPY_SHARED_DATA will terminate & stay resident */			
;;	Set up registers for copy & terminate call				
;;	/* reserve enough memory to handle any printer in the profile*/ 	
;;	jump to COPY_SHARED_DATA module 					
;;   ELSE									
;;	/* Shared Data has been built in place */				
;;	move YES to PRINT_SCREEN_ALLOWED					
;;	Return to DOS								
;;   ENDIF									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
GRAPHICS_INSTALL     PROC NEAR		;					
										
;-------------------------------------------------------------------------------
; Load the error messages							
;-------------------------------------------------------------------------------
   CALL    SYSLOADMSG		    ; Load messages				
  .IF C 			    ; If error when loading messages		
  .THEN 			    ; then,					
     MOV     CX,0		    ;	CX := No substitution in message	
     MOV     AX,1		    ;	AX := msg nb. for "Invalid DOS version" 
     CALL DISP_ERROR		    ;	Display error message			
     JMP     ERROR_EXIT 	    ;	 and quit				
  .ENDIF									
										
;-------------------------------------------------------------------------------
; Get offset of where to build the TEMPORARY Shared Data area (always built)	
;-------------------------------------------------------------------------------
   MOV	   BP,OFFSET LIMIT	     ; Build it at the end of this .COM file	
				     ;	(LIMIT = the offset of the last byte	
				     ;	  of the last .OBJ file linked with	
				     ;	   GRAPHICS)				
   MOV	   TEMP_SHARED_DATA_PTR,BP   ;						
										
;-------------------------------------------------------------------------------
; Determine if GRAPHICS is already installed; get the resident segment value	
;-------------------------------------------------------------------------------
    MOV     AH,PRT_SCR_2FH_NUMBER    ; Call INT 2FH (the Multiplex interrupt)	
    XOR     AL,AL		     ;	for Print Screen handler		
    INT     2FH 		     ;						
										
   .IF <AH EQ 0FFH>		     ; IF already installed			
   .THEN			     ; then,					
   ;----------------------------------------------------------------------------
   ; GRAPHICS is already installed: Get pointer to the EXISTING Shared Data area
   ;----------------------------------------------------------------------------
      MOV     INSTALLED,YES	    ;	Say it's installed                      
      MOV     AX,ES		    ;	Get the segment and offset of the	
      MOV     SHARED_DATA_AREA_PTR,DI;	 resident Shared Data area.		
      MOV     RESIDENT_CODE_SEG,AX  ;	  (returned in ES:DI)			

      MOV  AX,ES:[DI].SD_TOTAL_SIZE ; CX := Size of the existing Shared area	
      MOV  MAX_BLOCK_END, AX

				    ;	Disable print screen because we will	
      MOV     ES:PRINT_SCREEN_ALLOWED,NO ; be updating the resident code.	
   .ELSE			    ; ELSE, not installed:			
   ;------------------------------------------------------------------------	
   ; GRAPHICS is NOT installed: RESIDENT shared data area is in OUR segment	
   ;------------------------------------------------------------------------	
      PUSH    CS		    ; The Shared Data area will be in our	
      POP     RESIDENT_CODE_SEG     ;  segment. 				
   .ENDIF									
;-------------------------------------------------------------------------------
; Determine in AX how many bytes are available for building the TEMPORARY SHARED
; DATA AREA:									
;-------------------------------------------------------------------------------

;   MOV     AX,ES:BYTES_AVAIL_PSP_OFF;AX := Number of bytes availables in	
				    ;  the current segment (as indicated in PSP)
;M000;    mov     ax,0FFFFh		    ; Assume available to top of seg
;M000;
;Check for amount of memory that is free without assuming 64K. This causes
;crashes if it is loaded into UMBs.
;
	push	cx
	mov	ax,offset Limit
	add	ax,15
	mov	cl,4
	shr	ax,cl			;round up to nearest para
	mov	cx,es			;get our PSP seg
	add	ax,cx			;end of load image
	sub	ax,es:[2]		;es:[2] = top of our memory block
	neg	ax			;ax = # of paras free
	test	ax,0f000h		;greater than 64K bytes?
	jz	lt64K			;no
	mov	ax,0ffffh		;stop at 64K
	jmp	short gotfree
lt64K:
	mov	cl,4
	shl	ax,cl			;ax = # of bytes free above us
gotfree:
	pop	cx
;
;M000; End changes;
;

;;;   .IF	<AX B <OFFSET LIMIT>>	    ; If there is no bytes available past	
;;;   .THEN			    ;	the end of our .COM file		
;;;      XOR     AX,AX		    ; then, AX := 0 bytes available		
;;;   .ELSE			    ;						
;;;      SUB     AX,OFFSET LIMIT	    ; else,  AX := Number of FREE bytes 	
;;;   .ENDIF			    ;	     in this segment			
										
;---AX = Number of bytes in our segment available for building the Temp Shared	
;---data area.									
;---IF ALREADY INSTALLED: Get the size of the existing Shared data area.	
;---Since the temporary shared data area will be copied over the resident	
;---shared data area, we do not want to build it any bigger than the one	
;---it will overwrite. Therefore we do not give to LOAD_PROFILE more space	
;---than the size of the existing Shared data area.				
   .IF <INSTALLED EQ YES>	    ; If already installed then,		
   .THEN									
      PUSH CS:RESIDENT_CODE_SEG     ; ES:[DI] := Resident Shared data area	
      POP  ES			    ;						
      MOV  DI,SHARED_DATA_AREA_PTR  ;						
      MOV  CX,ES:[DI].SD_TOTAL_SIZE ; CX := Size of the existing Shared area	
      MOV  RESIDENT_SHARED_DATA_SIZE,CX ; Save size for LOAD_PROFILE		
     .IF <AX A CX>		    ; If AX > size of existing SDA		
	MOV AX,CX		    ; then, AX := Size of existing Shared area	
     .ENDIF			    ;						
   .ENDIF									
				    ;  NB_FREE_BYTES := Number of bytes 	
    MOV     NB_FREE_BYTES,AX	    ;	available for				
				    ;	 building the TEMPORARY shared area	
;-------------------------------------------------------------------------------
; Parse the command line parameters						
;-------------------------------------------------------------------------------
   MOV	   BYTE PTR CS:[BP].SWITCHES,0 ; Init. the command line switches	
   PUSH    CS			   ; Set ES to segment containing the PSP	
   POP	   ES									
   CALL    PARSE_PARMS		   ; Set switches in the Temp. Shared Area	
  .IF C 			   ; If error when parsing the command		
    .THEN			   ; line then, EXIT				
     JMP     ERROR_EXIT 							
  .ENDIF									
;-------------------------------------------------------------------------------
; Parse the printer profile - Build the temporary Shared data area		
;-------------------------------------------------------------------------------
 CALL  LOAD_PROFILE	            ;  Builds profile info in Temporary Shared	
				    ;	Data					
   .IF C			    ; If error when loading the profile 	
   .THEN			    ; then, EXIT				
      JMP     ERROR_EXIT							
   .ENDIF									
										
;-------------------------------------------------------------------------------
; Check if /B was specified with a BLACK and WHITE printer:(invalid combination)
;-------------------------------------------------------------------------------
   .IF <CS:[BP].PRINTER_TYPE EQ BLACK_WHITE> AND				
   .IF <BIT CS:[BP].SWITCHES NZ BACKGROUND_SW>					
   .THEN									
      MOV     AX,INVALID_B_SWITCH     ; Error := /B invalid with B&W prt.	
      MOV     CX,0		      ; No substitution 			
      CALL    DISP_ERROR	      ; Display error message			
      JMP     SHORT ERROR_EXIT	      ;  and quit				
   .ENDIF									
										
;-------------------------------------------------------------------------------
;										
; RELOCATE THE TEMPORARY SHARED DATA AREA AND THE SET OF REQUIRED PRINT MODULES 
;										
; (Discard the set of print modules not needed with the printer attached and	
;  discard all the code not used at print screen time). 			
;										
; If GRAPHICS is already installed then, we copy the				
; Shared Data area and the print modules over the previous ones installed in	
; resident memory.								
;										
; If we are installed for the first time then, we copy those over the		
; installation modules before we exit and stay resident.			
;										
; A temporaty Shared Data area is always created even if a resident one 	
; already exist (it is then, copied over), a set of print modules is recopied	
; only if needed.								
;										
; NOTE: END_OF_RESIDENT_CODE points to the first location over which code	
;	may be relocated.  After data or code is relocated, END_OF_RESIDENT_CODE
;	is updated and points to the next available location for copying code	
;	that will stay resident.						
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; Initialize the pointer to the next available location for resident code:	
;-------------------------------------------------------------------------------
   .IF <INSTALLED EQ NO>	    ; If not installed				
   .THEN			    ; then,					
      MOV     END_OF_RESIDENT_CODE,OFFSET PRINT_MODULE_START			
   .ENDIF			    ;	we make everything up to the print	
				    ;	 modules resident code. 		
;-------------------------------------------------------------------------------
; Keep only the set of print modules that is needed:				
;-------------------------------------------------------------------------------
    CALL    COPY_PRINT_MODULES	    ; Updates END_OF_RESIDENT_CODE		
;-------------------------------------------------------------------------------
; Replace the interrupt vectors and install the EGA dynamic area (if needed)	
;-------------------------------------------------------------------------------
   .IF <INSTALLED EQ NO>	    ; If not already installed			
   .THEN			    ; then,					
;------Release evironment vector						;AN002;
      CALL RELEASE_ENVIRONMENT	    ;	release unneeded environment vector	;AN002;
;------Replace the interrupt vectors						
      MOV   PRINT_SCREEN_ALLOWED,NO ;	Disable Print Screen			
      CALL  CHAIN_INTERRUPTS	    ;	Replace the interrupt vectors		
				    ;	 (END_OF_RESIDENT_CODE is updated)	
      CALL  DET_HW_CONFIG	    ;	Find what display adapter we got	
     .IF <CS:[BP].HARDWARE_CONFIG EQ EGA>;If EGA is present			
     .THEN			    ;	then,					
	 CALL INST_EGA_SAVE_AREA    ;	  Install the EGA dynamic save area	
     .ENDIF			    ;	  (END_OF_RESIDENT_CODE is updated)	
;------Calculate the size of the resident code					
      MOV   DX,END_OF_RESIDENT_CODE ; DX := End of resident code		
      ADD   DX,CS:[BP].SD_TOTAL_SIZE; Add size of Shared Data area		
      MOV   CL,4		    ;						
      SHR   DX,CL		    ; convert to paragraphs			
      INC   DX			    ;  and add 1				
;------Set AX to DOS exit function call - (COPY_SHARED_DATA will exit to DOS)	
      MOV   AH,31H		    ; Function call to terminate but stay	
      XOR   AL,AL		    ;	resident				
   .ELSE									
      MOV   AH,4CH		    ; Function call to terminate		
      XOR   AL,AL		    ; (EXIT to calling process) 		
   .ENDIF									
										
;-------------------------------------------------------------------------------
; Copy the temporary shared data area in the resident code			
;-------------------------------------------------------------------------------
    MOV     CX,CS:[BP].SD_TOTAL_SIZE; CX := MOVSB count for COPY_SHARED_DATA	
    MOV     SI,BP		    ; DS:SI := Temporary Shared data area	
    PUSH    RESIDENT_CODE_SEG	    ; ES:DI := Resident Shared data area:	
    POP     ES			    ;						
   .IF <INSTALLED EQ NO>	    ; If not installed				
   .THEN			    ; then,					
      MOV     DI,END_OF_RESIDENT_CODE;	 DI := End of resident code		
      MOV     BP,DI		    ;	BP := New resident Shared data area	
      MOV     SHARED_DATA_AREA_PTR,DI;	 Update pointer to resident Shar. area	
   .ELSE			    ; else,					
      MOV     DI,SHARED_DATA_AREA_PTR ;   DI := Existing Shared data area	
      MOV     BP,DI		    ;	BP = DI:= Existing Shared data area	
   .ENDIF									
      JMP   COPY_SHARED_DATA	    ; Jump to proc that copies area in new	
				    ;  part of memory and exits to DOS		
ERROR_EXIT:									
   .IF <INSTALLED EQ YES>	    ; If we are already installed, re-enable	
      MOV   ES,RESIDENT_CODE_SEG    ;  print screens				
      MOV   ES:PRINT_SCREEN_ALLOWED,YES 					
   .ENDIF			    ;						
				    ;						
    MOV     AH,4CH		    ; Function call to terminate		
    MOV     AL,1		    ; (EXIT to calling process) 		
    INT     21H 								
GRAPHICS_INSTALL     ENDP							
										
PAGE										
;===============================================================================
;										
; INST_EGA_SAVE_AREA : INSTALL A DYNAMIC SAVE AREA FOR THE EGA PALETTE REGISTERS
;										
;-------------------------------------------------------------------------------
;										
; INPUT:   DS			= Data segment for our code			
;	   END_OF_RESIDENT_CODE = Offset of the end of the resident code	
;										
; OUTPUT:  END_OF_RESIDENT_CODE is updated to point to the end of the code	
;				   that will stay resident.			
;	   SAVE_AREA_PTR in BIOS segment is updated.				
;										
;-------------------------------------------------------------------------------
;;										
;; Data Structures Referenced:							
;;   Shared Data Area								
;;										
;; Description: 								
;;   ************* The EGA Dynamic Save Area will be built over top		
;;   **  NOTE	** of the profile loading modules (file GRLOAD.ASM)		
;;   ************* to avoid having to relocate this area just before		
;;   terminating.  This is safe since the maximum memory used is		
;;   288 bytes and the profile loading modules are MUCH larger than		
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		
;;   GRPRINT.ASM.								
;;										
;; BIOS will update the dynamic save area whenener it's aware the palette       
;; registers have been updated. 						
;;										
;; BIOS 4A8H		BIOS SAVE	       EGA DYNAMIC			
;; POINTER:		POINTER TABLE	       SAVE AREA			
;; Ŀ		Ŀ	       (16 first bytes are the 16	
;;    *>	     		EGA palette registers)		
;; 		Ĵ	       Ŀ			
;;			     *>Ĵ			
;;			Ĵ	       Ĵ			
;;				     	       Ĵ			
;;			Ĵ		     .				
;;				     		     .				
;;			Ĵ		     .	    256 bytes		
;;				     		     .				
;;			Ĵ		     .				
;;				     	       Ĵ			
;;			Ĵ	       Ĵ			
;;				     	       Ĵ			
;;			Ĵ	       Ĵ			
;;				     	       Ĵ			
;;				       			
;;										
;; Called By:									
;;   GRAPHICS_INSTALL								
;;										
;; External Calls:								
;;										
;; Logic:									
;;   IF EGA Dynamic Save Area NOT established THEN				
;;	  /* Required since default table is in ROM */				
;;	  IF Save Table is in ROM						
;;	     Replicate all the Save Area Table in resident RAM just before	
;;	      the Shared Data Area						
;;	  ENDIF 								
;;	  Allocate 256 bytes for EGA Dynamic Save Area just before the		
;;	  Shared Data Area							
;;	  Update END_OF_RESIDENT_CODE						
;;     ENDIF									
;;   RETURN									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
BIOS_SAVE_PTR	     EQU    4A8H       ;; Offset of the BIOS Save Ptr area	
SAVE_AREA_LEN	     EQU    8*4        ;; There are 8 pointers in the Save area 
EGA_DYNAMIC_LEN      EQU    256        ;; Length of the EGA dynamic save area	
; Standard default colours for the Enhanced Graphics Adapter: (rgbRGB values)	
; The following table is necessary in order to initialize the EGA DYNAMIC	
; SAVE AREA when creating it.							
EGA_DEFAULT_COLORS   DB     00h        ;; Black 				
		     DB     01h        ;; Blue					
		     DB     02h        ;; Green 				
		     DB     03h        ;; Cyan					
		     DB     04h        ;; Red					
		     DB     05h        ;; Magenta				
		     DB     14h        ;; Brown 				
		     DB     07h        ;; White 				
		     DB     38h        ;; Dark Grey				
		     DB     39h        ;; Light Blue				
		     DB     3Ah        ;; Light Green				
		     DB     3Bh        ;; Light Cyan				
		     DB     3Ch        ;; Light Red				
		     DB     3Dh        ;; Light Magenta 			
		     DB     3Eh        ;; Yellow				
		     DB     3Fh        ;; Bright white				
		     DB     00h        ;; OVERSCAN register			
										
INST_EGA_SAVE_AREA PROC NEAR							
PUSH	AX									
PUSH	CX									
PUSH	DX									
PUSH	SI									
PUSH	DI									
PUSH	ES									
;-------------------------------------------------------------------------------
; Get the BIOS save pointer table						
;-------------------------------------------------------------------------------
XOR	AX,AX			      ; ES := segment 0 			
MOV	ES,AX									
LES	SI,ES:DWORD PTR BIOS_SAVE_PTR ; ES:[SI] =Current BIOS save table	
.IF <<WORD PTR ES:[SI]+4> EQ 0> AND   ; IF the dynamic save are pointer is	
.IF <<WORD PTR ES:[SI]+6> EQ 0>       ;  null then, it's not defined            
.THEN				      ;   and we have to define it:		
    ;---------------------------------------------------------------------------
    ; The Dynamic EGA save area is NOT DEFINED: 				
    ;---------------------------------------------------------------------------
     MOV   BYTE PTR ES:[SI]+4,0FFH    ; Try to write a byte in the table	
     PUSH  AX			      ; (PUSH AX, POP AX used to create a	
     POP   AX			      ;  small delay)				
    .IF <<WORD PTR ES:[SI]+4> NE 0FFH>;If we can't read our byte back then,     
    .THEN			      ;  the Save Ptrs table is in ROM		
       ;------------------------------------------------------------------------
       ; The Save pointer table is in ROM;					
       ; Copy the BIOS save pointer table from ROM to within our .COM file	
       ;------------------------------------------------------------------------
	PUSH  ES		      ; DS:SI := Offset of BIOS save ptrs table 
	POP   DS		      ; 					
	PUSH  CS		      ; ES:DI := The next available location	
	POP   ES		      ; 	  for installing resident code	
	MOV   DI,CS:END_OF_RESIDENT_CODE ;	   within our .COM file 	
	MOV   CS:OUR_SAVE_TAB_OFF,DI  ; 					
	MOV   CX,SAVE_AREA_LEN	      ;     CX := Length of the table to copy	
	REP   MOVSB		      ;  Replicate the Save Table		
	PUSH  CS								
	POP   DS		      ; Reestablish our data segment		
       ;------------------------------------------------------------------------
       ; Adjust END_OF_RESIDENT_CODE to the next offset available for copying	
       ; resident code and data.						
       ;------------------------------------------------------------------------
	ADD   END_OF_RESIDENT_CODE,SAVE_AREA_LEN				
       ;------------------------------------------------------------------------
       ; Set the pointer in OUR Save ptr table to our EGA dynamic save area	
       ; which we create right after the Save pointer table.			
       ;------------------------------------------------------------------------
	MOV	DI,OUR_SAVE_TAB_OFF    ; DS:[DI] := Our BIOS save ptr tab	
	MOV	AX,END_OF_RESIDENT_CODE; Store its offset			
	MOV	DS:[DI]+4,AX	       ;					
	MOV	WORD PTR DS:[DI]+6,DS  ; Store its segment			
       ;------------------------------------------------------------------------
       ; Initialize our DYNAMIC SAVE AREA with the 16 standard EGA colors	
       ;------------------------------------------------------------------------
										
	LEA  SI,EGA_DEFAULT_COLORS	; DS:[SI] := EGA 16 Default colors	
	MOV  DI,END_OF_RESIDENT_CODE	; ES:[DI] := DYNAMIC SAVE AREA		
	MOV  CX,17			; CX := Number of colors		
	REP  MOVSB			; Initialize the Dynamic save area	
       ;------------------------------------------------------------------------
       ; Set the BIOS Save Pointer to our table of Save pointers:		
       ;------------------------------------------------------------------------
	CLI									
	XOR	AX,AX		       ; ES:BIOS_SAVE_PTR := Our save table:	
	MOV	ES,AX								
	MOV	AX,OUR_SAVE_TAB_OFF						
	MOV	ES:BIOS_SAVE_PTR,AX						
	MOV	ES:BIOS_SAVE_PTR+2,DS						
	STI									
    .ELSE			       ; ELSE save pointer table is in RAM	
       ;------------------------------------------------------------------------
       ; ELSE, the BIOS save pointer table is in RAM:				
       ;------------------------------------------------------------------------
       ;------------------------------------------------------------------------
       ; Set the pointer in THEIR Save ptr table to OUR EGA dynamic save area	
       ;------------------------------------------------------------------------
	MOV   WORD PTR ES:[SI]+6,DS    ; ES:[SI] = The existing table in RAM	
	MOV   AX,END_OF_RESIDENT_CODE						
	MOV   ES:[SI]+4,AX							
    .ENDIF			       ; ENDIF save pointer table is in ROM	
  ;-----------------------------------------------------------------------------
  ; Adjust END_OF_RESIDENT_CODE to the next offset available for copying	
  ; resident code and data.							
  ;-----------------------------------------------------------------------------
   ADD	END_OF_RESIDENT_CODE,EGA_DYNAMIC_LEN					
.ENDIF										
POP	 ES									
POP	 DI									
POP	 SI									
POP	 DX									
POP	 CX									
POP	 AX									
										
RET										
OUR_SAVE_TAB_OFF DW	?							
INST_EGA_SAVE_AREA ENDP 							
PAGE										
;===============================================================================
;										
; CHAIN_INTERRUPTS : INSTALL INT 5 ,INT 10 AND INT 2FH VECTORS				
;										
;-------------------------------------------------------------------------------
;										
; INPUT:   DS			= Data segment for our code			
;	   END_OF_RESIDENT_CODE = Offset of the end of the resident code	
;										
; OUTPUT:  OLD_INT_2FH		  (within INT_2FH_DRIVER)			
;	   BIOS_INT_5H		  (within PRT_SCR module)			
; 	   OLD_INT_10H
;	   END_OF_RESIDENT_CODE is updated to point to the end of the code	
;				   that will stay resident.			
;	   SAVE_AREA_PTR in BIOS segment is updated if an EGA adapter is found	
;										
;-------------------------------------------------------------------------------
;;										
;; Data Structures Referenced:							
;;   Shared Data Area								
;;										
;; Description: 								
;;   Install Interrupts 5 ,10 and 2FH. The old vectors are saved.
;;										
;; Called By:									
;;   GRAPHICS_INSTALL								
;;										
;; External Calls:								
;;   DOS INT 21H Replace vector AH=25h						
;;   DOS INT 21H Get vector AH=35h						
;;										
;; Logic:									
;;   Save interrupt 5 vector in BIOS_INT_5H					
;;   Point interrupt 5 to PRT_SCR module					
;;   Save interrupt 2FH vector in BIOS_INT_2FH					
;;   Point interrupt 2FH to INT_2FH_DRIVER module				
;;   Save interrupt 10h vector in OLD_INT_10h
;;   point interrupt 10h to INT_10H_DRIVER
;;   RETURN									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
CHAIN_INTERRUPTS  PROC NEAR	       ;;					
	PUSH	ES								
	PUSH	BX								
										
;-------------------------------------------------------------------------------
; Replace INTERRUPT 5 vector							
;-------------------------------------------------------------------------------
	MOV	AX,3505H		; Get vector for int 5 request
	INT	21H			; Call DOS				

	MOV	CS:BIOS_INT_5H,BX	; Save the old vector
	MOV	CS:BIOS_INT_5H+2,ES			
						
	MOV	DX,OFFSET PRT_SCR	; DS:DX := Offset of our Print Screen

	MOV	AX,2505H		; Replace vector for int 5 request
	INT	21H			; Call DOS	
										
;-------------------------------------------------------------------------------
; Replace INTERRUPT 2FH vector							
;-------------------------------------------------------------------------------
	MOV	AX,352FH		; Get vector for int 2FH request
	INT	21H			; Call DOS				
										
	MOV	WORD PTR OLD_INT_2FH,BX ; Save the old vector			
	MOV	WORD PTR OLD_INT_2FH+2,ES					
										
	MOV	DX,OFFSET INT_2FH_DRIVER; DS:DX := Offset of our 2FH handler	
										
	MOV	AX,252FH		; Replace vector for int 2FH request
	INT	21H			; Call DOS				
; /* M001 BEGIN */
;------------------------------------------------------------------------------
; Replace INTERRUPT 10 vector						
;------------------------------------------------------------------------------
	MOV	AX,3510H		; Get vector for int10h request
	INT	21H			; Call DOS	
						
	MOV	WORD PTR OLD_INT_10H,BX ; Save the old vector
	MOV	WORD PTR OLD_INT_10H+2,ES		
						
	MOV	DX,OFFSET INT_10H_DRIVER; DS:DX := Offset of our 2FH handler
				
	MOV	AX,2510H		; Replace vector for int10H request
	INT	21H			; Call DOS	
; /* M001 END */
						
	POP	BX			
	POP	ES		
	RET		

CHAIN_INTERRUPTS  ENDP	
;===============================================================================
;										
; COPY_PRINT_MODULES: COPY THE SET OF PRINT MODULES NEEDED OVER THE PREVIOUS ONE
;										
;-------------------------------------------------------------------------------
;										
; INPUT:  BP		       = Offset of the temporary Shared Data area	
;	  END_OF_RESIDENT_CODE = Location of the set of COLOR modules		
;				 (if first time installed)			
;	  CS:[BP].PRINTER_TYPE = Printer type NEEDED				
;	  RESIDENT_CODE_SEG    = Segment containing the resident code		
;										
; OUTPUT: END_OF_RESIDENT_CODE = End of the print modules IS UPDATED		
;				 (If first time installed)			
;										
;-------------------------------------------------------------------------------
;;										
;; Data Structures Referenced:							
;;   Control Variables								
;;   Shared Data Area								
;;										
;; Description: 								
;;   This module trashes one set of print modules (Color or Black & White)	
;;   depending on the type of printer attached.  Since the Shared Data		
;;   (resident version) will reside immediately after the print modules,	
;;   END_OF_RESIDENT_CODE will be set by this modules.				
;;										
;;   The set of COLOR modules is already at the rigth located when installing	
;;   GRAPHICS for the first time. This is true since, the color modules are	
;;   linked before the black and white modules. 				
;;										
;;   Therefore, if we are installing GRAPHICS for the first time and we need	
;;   the color modules then, we do not need to relocate any print modules.	
;;										
;;   When installing GRAPHICS again we first check what is the resident set,	
;;   we recopy a new set only if needed.					
;;										
;; Called By:									
;;   GRAPHICS_INSTALL								
;;										
;; Logic:									
;;   IF color printer THEN							
;;	SI := Offset of BW_PRINT_MODULES					
;;   ELSE									
;;	SI := Offset of COLOR_PRINT_MODULES					
;;   ENDIF									
;;   REP MOVSB		; Copy the set of modules				
;;   END_OF_RESIDENT_CODE := end of the set of modules				
;;   RETURN									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
COPY_PRINT_MODULES  PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	SI								
	PUSH	DI								
	PUSH	ES								
										
;-------------------------------------------------------------------------------
; Determine if we need to relocate the set of print modules, if so, set the	
; source address (DS:SI), the destination address (ES:DI) and the number of	
; bytes to copy (CX).								
;-------------------------------------------------------------------------------
   PUSH    CS:RESIDENT_CODE_SEG 	; ES := Segment containing the resident 
   POP	   ES				;	 code  (Where to copy modules)	
   MOV	   DI,OFFSET PRINT_MODULE_START ; ES:[DI] := Resident print modules	
										
  .IF <INSTALLED EQ NO> 		; IF not installed			
  .THEN 				; THEN, 				
					;   We relocate the print modules	
					;    at the end of the resident code:	
					;     (this is where the color set is)	
     .IF <CS:[BP].PRINTER_TYPE EQ BLACK_WHITE> ; IF we don't want the color set 
     .THEN				;   THEN,				
	MOV NEED_NEW_PRINT_MODULES,YES	;     Say we need new modules		
	MOV SI,OFFSET PRINT_BW_APA	;     DS:[SI] := Black and white modules
	MOV CX,LEN_OF_BW_MODULES	;     CX      := Length of B&W modules	
     .ENDIF				;					
										
  .ELSE 				; ELSE, (We are already installed)	
      MOV     BX,SHARED_DATA_AREA_PTR	;   BX := Offset of Shared Data area	
      MOV     AL,ES:[BX].PRINTER_TYPE	;   AL := Type of the resident set	
     .IF <AL NE CS:[BP].PRINTER_TYPE>	;   IF resident set is not the one	
     .THEN				;   we need THEN,			
	MOV NEED_NEW_PRINT_MODULES,YES	;     Say we need a new set.		
       .IF <CS:[BP].PRINTER_TYPE EQ COLOR>;   IF its color we need then,	
	  MOV SI,OFFSET PRINT_COLOR	;	DS:[SI] := Color set		
	  MOV CX,LEN_OF_COLOR_MODULES	;	CX	:= Length of color mod. 
       .ELSE				;     ELSE				
	  MOV SI,OFFSET PRINT_BW_APA	;	DS:[SI] := B&W set		
	  MOV CX,LEN_OF_BW_MODULES	;	CX	:= Length of B&W mod.	
       .ENDIF				;     ENDIF we need the color set	
     .ENDIF				;   ENDIF we need a new set		
  .ENDIF				; ENDIF we are not installed		
										
										
;-------------------------------------------------------------------------------
; If needed: Copy the required set of print modules				
;-------------------------------------------------------------------------------
  .IF <NEED_NEW_PRINT_MODULES EQ YES>						
  .THEN 									
     CLD			       ; Clear the direction flag		
     REP     MOVSB		       ; Copy the set of print modules		
  .ENDIF			       ; ENDIF needs to copy the print modules	
										
;-------------------------------------------------------------------------------
; Set END_OF_RESIDENT_CODE pointer to the end of the print modules:		
; (Reserve enough space to store the larger set of modules on a 		
;  subsequent install)								
;-------------------------------------------------------------------------------
  .IF <INSTALLED EQ NO> 		; IF first time installed		
  .THEN 				; THEN, 				
     MOV     CX,LEN_OF_COLOR_MODULES	;   Adjust END_OF_RESIDENT_CODE to	
    .IF <CX G LEN_OF_BW_MODULES>	;   contains the larger set of modules. 
    .THEN				;					
       ADD     END_OF_RESIDENT_CODE,LEN_OF_COLOR_MODULES			
    .ELSE									
       ADD     END_OF_RESIDENT_CODE,LEN_OF_BW_MODULES				
    .ENDIF				;					
  .ENDIF									
										
	POP ES									
	POP DI									
	POP SI									
	POP CX									
	POP BX									
	POP AX									
	RET									
NEED_NEW_PRINT_MODULES DB   NO		; True if print modules needed must be	
					;  copied over the other set of print	
					;   modules				
COPY_PRINT_MODULES  ENDP							
										;AN002;
PAGE										;AN002;
;===============================================================================;AN002;
;										;AN002;
; PROCEDURE_NAME: RELEASE_ENVIRONMENT						;AN002;
;										;AN002;
; INPUT:  None. 								;AN002;
;										;AN002;
; OUTPUT: Environment vector released.						;AN002;
;										;AN002;
;-------------------------------------------------------------------------------;AN002;
RELEASE_ENVIRONMENT PROC NEAR							;AN002;
	PUSH	AX			; save regs				;AN002;
	PUSH	BX								;AN002;
	PUSH	ES								;AN002;
	MOV	AH,62H			; function for get the PSP segment	;AN002;
	INT	21H			; invoke INT 21h			;AN002;
	MOV	ES,BX			; BX contains PSP segment - put in ES	;AN002;
	MOV	BX,WORD PTR ES:[2CH]	; get segment of environmental vector	;AN002;
	MOV	ES,BX			; place segment in ES for Free Memory	;AN002;
	MOV	AH,49H			; Free Allocated Memory function call	;AN002;
	INT	21H			; invoke INT 21h			;AN002;
	POP	ES			; restore regs				;AN002;
	POP	BX								;AN002;
	POP	AX								;AN002;
	RET									;AN002;
RELEASE_ENVIRONMENT ENDP							;AN002;
										
PAGE										
;===============================================================================
;										
; PROCEDURE_NAME: DISP_ERROR							
;										
; INPUT:  AX := GRAPHICS message number (documented in GRMSG.EQU)		
;	  CX := Number of substitutions (Needed by SYSDISPMSG)			
;	  DS:[SI] := Substitution list (needed only if CX <> 0) 		
;										
; OUTPUT: Error message is displayed on STANDARD ERROR OUTPUT (STDERR)		
;										
;-------------------------------------------------------------------------------
DISP_ERROR    PROC   NEAR							
	PUSH	BX								
	PUSH	DI								
	PUSH	SI								
	PUSH	BP								
										
	MOV	BX,ERROR_DEVICE    ; Issue message to standard error		
	XOR	DL,DL		   ; No input					
	MOV	DH,UTILITY_MSG_CLASS;It's one of our messages                   
	CALL	SYSDISPMSG	   ; display error message			
										
	POP	BP								
	POP	SI								
	POP	DI								
	POP	BX								
	RET									
DISP_ERROR    ENDP								

include msgdcl.inc										
										
CODE   ENDS									
       END									


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grload2.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:   I  altered  the  procedure  PARSE_VERB  and  added  the  new 
;**                 procedure PARSE_DEFINE and made it public in order to handle 
;**                 the  new  statement DEFINE.  I also made  the  new  variable 
;**                 DATA_TYPE  have  the  default of DATA_COL,  so  the  default 
;**                 assumes  IBM type printers.  
;**  
;**  BUG NOTES:     Bug  mda002  was  completely fixed   for   the   pre-release  
;**                 version  Q.01.02,  whereas  bug mda005  was  only  partially 
;**                 fixed.   In  other  words,  part of bug  mda005  is  in  the 
;**                 released versions D.01.01 & D.01.02.
;**  
;**  BUG (mda002)
;**  ------------
;**  
;**  NAME:     GRAPHICS   prints garbage on PCL  printers  if IBM  printers  are 
;**            listed after HP printers  in the GRAPHICS profile.  
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD2.ASM - PARSE_PRINTER
;**                                GRLOAD2.ASM - PARSE_DEFINE
;**  
;**  CAUSES:   1)   In  the  procedure Parse_Define I was moving values  in  the 
;**                 variable  DATA_TYPE for every DEFINE statement,  instead  of 
;**                 just  for  the  DEFINE statement that  corresponded  to  the 
;**                 printer we were using.
;**  
;**            2)   In the procedure Parse_Printer I was resetting DATA_TYPE  to 
;**                 DATA_COL  if  BUILD_STATE  = YES, but I was doing  it  in  a 
;**                 section  of  code  where BUILD_STATE  would  never  be  YES.  
;**  
;**  FIXES:     1)  Made  a couple of changes in the procedure  Parse_Define  so 
;**                 that  values are moved into the variable DATA_TYPE just  for 
;**                 the  DEFINE  statement  that  corresponds  to  the   printer 
;**                 currently being used.
;**  
;**            2)   I  moved a section of code from the procedure  Parse_Printer 
;**                 to  the  end of the procedure, because this is where  it  is 
;**                 possible for BUILD_STATE to equal YES.  
;**  
;**  BUG (mda005)
;**  ------------
;**  
;**  NAME:     If  a  picture is printed using a 3,1 printbox, the  picture  has 
;**            blank lines throughout  the picture,  which has  the wrong aspect
;**            ratio. 
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD2.ASM - PARSE_PRINTBOX
;**  
;**  CAUSE:    The print buffer was being filled as follows,
;**  
;**                      --------------------------
;**                      | o  o  o  o  o  o  o  o |
;**                      --------------------------
;**                        |_____|  |  |_____|  |
;**                           |     |     |     |              
;**                           |     |     |     |
;**            FROM:       pixel 1  |  pixel 2  |
;**                                 |           |
;**                                 |___________|
;**                                       |
;**                                       |
;**                                       |
;**                               Always left blank
;**  
;**            instead of as follows,
;**  
;**                      --------------------------
;**                      | o  o  o  o  o  o  o  o |
;**                      --------------------------
;**                        |_____|  |_____|  |__|
;**                           |        |       |     
;**                           |        |       |
;**            FROM:       pixel 1  pixel 2  pixel 3
;**  
;**            Note  that  this not only resulted in a strange  picture,  but  a 
;**            picture with the incorrect aspect ratio.  Because in essence  the 
;**            picture  was printed indirectly with a 4,1 printbox  because  for 
;**            every pixel read four bits were sent to the printer.
;**  
;**  FIX:      Because  of time constraints it was decided to print the  picture 
;**            directly  with a 4,1 printbox.  So even though the picture  still 
;**            has the wrong aspect ratio, it at least does not have funny blank 
;**            lines throughout the entire picture.  This fix was implemented by 
;**            changing a 3,1 printbox to a 4,1 printbox.
;**  
;**  DOCUMENTATION NOTES:  This version of GRLOAD2.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Profile Load Modules #2 	;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                   
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE' BYTE     ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
	INCLUDE GRSHAR.STR	       ;;					;AN000;
	INCLUDE GRMSG.EQU	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;;					;AN000;
	INCLUDE GRLOAD.EXT	       ;;					;AN000;
	INCLUDE GRPARSE.EXT	       ;;					;AN000;
	INCLUDE GRPATTRN.STR	       ;;					;AN000;
	INCLUDE GRPATTRN.EXT	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC PARSE_VERB		       ;;					;AN000;
   PUBLIC PARSE_PRINTER 	       ;;					;AN000;
; \/ ~~mda(001) ---------------------------------
;		Added procedure PARSE_DEFINE
;
   PUBLIC PARSE_DEFINE			;
; /\ ~~mda(001) ---------------------------------
   PUBLIC PARSE_DISPLAYMODE	       ;;					;AN000;
   PUBLIC PARSE_PRINTBOX	       ;;					;AN000;
   PUBLIC PARSE_SETUP		       ;;					;AN000;
   PUBLIC PARSE_RESTORE 	       ;;					;AN000;
   PUBLIC TERMINATE_DISPLAYMODE        ;;					;AN000;
   PUBLIC TERMINATE_PRINTER	       ;;					;AN000;
   PUBLIC CUR_PRINTER_TYPE	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Profile Load Variables							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
NO	      EQU   0		       ;;					;AN000;
YES	      EQU   1		       ;;					;AN000;
				       ;;					;AN000;
RESULT_BUFFER	LABEL BYTE	       ;; general purpose result buffer 	;AN000;
		    DB	 ?	       ;; operand type				;AN000;
RESULT_TAG	    DB	 0	       ;; operand tag				;AN000;
		    DW	 ?	       ;; pointer to synonym/keyword		;AN000;
RESULT_VAL	    DB	 ?,?,?,?       ;; returned numeric value		;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   TERMINATE_DISPLAYMODE							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
TERMINATE_DISPLAYMODE	PROC	       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,STMTS_DONE		       ;;					;AN000;
 .IF <PTD_FOUND EQ YES> AND	       ;; For the matched PTD			;AN000;
 .IF <BIT AX NAND BOX> AND	       ;;  issue "Invalid parm value"           ;AN000;
 .IF <PRT_BOX_ERROR EQ NO>	       ;;  message if PRINTBOX ID not		;AN000;
				       ;;  matched in each DISPLAYMODE section	;AN000;
	 PUSH AX		       ;; Save STMT_DONE flags			;AN000;
	 MOV  AX,INVALID_PB	       ;;					;AN000;
	 MOV  CX,0		       ;;					;AN000;
	 CALL DISP_ERROR	       ;;					;AN000;
	 MOV  BUILD_STATE,NO	       ;;					;AN000;
	 MOV  PRT_BOX_ERROR,YES        ;; Issue this message only once		;AN000;
	 POP  AX		       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  AND  AX,GR			       ;; Check for missing statements is last	;AN000;
 .IF <AX NE GR> 		       ;;  DISPLAYMODE section: 		;AN000;
     OR  STMT_ERROR,MISSING	       ;;    GRAPHICS stmt is required		;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
TERMINATE_DISPLAYMODE	ENDP	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   TERMINATE_PRINTER								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
TERMINATE_PRINTER	PROC	       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,BLOCK_END		       ;;					;AN000;
 .IF <AX A MAX_BLOCK_END>	       ;; Keep track of the largest PRINTER	;AN000;
    MOV  MAX_BLOCK_END,AX	       ;;  section so we can allow space for	;AN000;
 .ENDIF 			       ;;  reload with a different printer	;AN000;
				       ;;  type.				;AN000;
				       ;;					;AN000;
				       ;; Check for missing statements		;AN000;
  MOV  AX,STMTS_DONE		       ;;					;AN000;
  AND  AX,DISP			       ;; At least one DISPLAYMODE		;AN000;
 .IF <AX NE DISP>		       ;;  must have been found in last 	;AN000;
     OR  STMT_ERROR,MISSING	       ;;   PRINTER section			;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
TERMINATE_PRINTER	ENDP	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_PRINTER								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
PRINTER_PARSE_PARMS  LABEL WORD        ;; Parser control blocks 		;AN000;
	    DW	 PRINTER_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
PRINTER_P   DB	 0,1		       ;; Required, max parms			;AN000;
	    DW	 PRINTER_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
PRINTER_P1  DW	 2000H		       ;; simple string 			;AN000;
	    DW	 0002H		       ;; Capitalize using character table	;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTER_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTER_P1V    DB   3		       ;; # of value lists			;AN000;
	    DB	 0		       ;; # of range numerics			;AN000;
	    DB	 0		       ;; # of discrete numerics		;AN000;
	    DB	 1		       ;; # of strings				;AN000;
	    DB	 1		       ;; tag: index into verb jump table	;AN000;
PRINTER_P1V1  DW   ?		       ;; string offset 			;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CUR_PRINTER_TYPE   DB  0	       ;; Type of printer currently being	;AN000;
				       ;;  parsed:  1-color 2-b&w		;AN000;
				       ;;					;AN000;
PARSE_PRINTER  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,PRT		       ;;					;AN000;
  MOV  CUR_PRINTER_TYPE,BLACK_WHITE    ;; Assume black & white until we hit	;AN000;
				       ;;  a COLORPRINT 			;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE AND PRT>	       ;; If not the first PRINTER section	;AN000;
     CALL  TERMINATE_DISPLAYMODE       ;;  then clean up the last one and	;AN000;
     CALL  TERMINATE_PRINTER	       ;;    the last DISPLAYMODE section.	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 MOV  AX,FIRST_BLOCK		       ;;					;AN000;
 MOV  BLOCK_START,AX		       ;; Reset block pointers to start 	;AN000;
 MOV  BLOCK_END,AX		       ;;  of variable area			;AN000;
				       ;;					;AN000;
  MOV  STMTS_DONE,PRT		       ;; Clear all bits except for PRT 	;AN000;
  MOV  GROUPS_DONE,0		       ;; Clear 				;AN000;
				       ;;					;AN000;
 .IF <PTD_FOUND EQ YES> 	       ;; PRINTER statement marks the end of	;AN000;
     MOV  PTD_FOUND,PROCESSED	       ;;  the previous PTD			;AN000;
     MOV  BUILD_STATE,NO	       ;; Stop building shared data		;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  CL,TAB_DIR_NB_ENTRIES	       ;; Reset the pattern table copy		;AN000;
  XOR  CH,CH			       ;;  pointers.  These pointers		;AN000;
  MOV  BX,OFFSET TAB_DIRECTORY	       ;;   are established when a pattern	;AN000;
 .REPEAT			       ;;    table is copied to the shared	;AN000;
    MOV [BX].TAB_COPY,-1	       ;;     data area.  Initially they	;AN000;
    ADD BX,SIZE TAB_ENTRY	       ;;      are -1.				;AN000;
 .LOOP				       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,OFFSET PRINTER_TYPE_PARM     ;; Store printer type from command	;AN000;
  MOV  PRINTER_P1V1,AX		       ;;  line in value list			;AN000;
  MOV  DI,OFFSET PRINTER_PARSE_PARMS   ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
				       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
     XOR  CX,CX 		       ;; Don't worry about number of operands  ;AN000;
     CALL SYSPARSE		       ;;					;AN000;
    .IF <AX EQ 9>		       ;; Syntax error is the only thing	;AN000;
	OR  STMT_ERROR,INVALID	       ;;  which can go wrong			;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ 0> OR		       ;;					;AN000;
 .UNTIL <AX EQ -1>		       ;;					;AN000;
				       ;; Printer type parm matched one coded	;AN000;
				       ;;  on the PRINTER statement		;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
    .IF <PTD_FOUND EQ NO>	       ;;					;AN000;
	MOV  PTD_FOUND,YES	       ;; If the printer type matches and	;AN000;
       .IF <PARSE_ERROR EQ NO> AND     ;;  no errors have been found yet	;AN000;
       .IF <PRT_BOX_ERROR EQ NO> AND   ;;					;AN000;
       .IF <MEM_OVERFLOW EQ NO>        ;;					;AN000;
	   MOV BUILD_STATE,YES	       ;;   then start building the shared	;AN000;
       .ENDIF			       ;;    data				;AN000;
    .ENDIF			       ;;					;AN000;
 .ELSE				       ;; No match				;AN000;
    MOV  BUILD_STATE,NO 	       ;;					;AN000;
   .IF <AX NE -1>		       ;; Error during parse			;AN000;
      OR  STMT_ERROR,INVALID	       ;; set error flag for caller		;AN000;
      MOV PARSE_ERROR,YES	       ;; set error flag for caller		;AN000;
   .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
; \/ ~~mda(002) -----------------------------------------------------------------------
 .IF <BUILD_STATE EQ YES>              ;;
      MOV	[BP].DATA_TYPE,DATA_COL;; Set DATA_TYPE back to default of DATA_COL
 .ENDIF                                ;; for new PTD.
; /\ ~~mda(002) -----------------------------------------------------------------------
				       ;;					;AN000;
  RET										;AN000;
				       ;;					;AN000;
PARSE_PRINTER  ENDP								;AN000;
										;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;


;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_DISPLAYMODE								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
DISPMODE_PARSE_PARMS  LABEL WORD       ;; Parser control blocks 		;AN000;
	    DW	 DISPMODE_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
DISPMODE_P   DB   0,1		       ;; Required, max parms			;AN000;
	    DW	 DISPMODE_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
DISPMODE_P1  DW   8000H 	       ;; Numeric				;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 DISPMODE_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
DISPMODE_P1V	DB   1			;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,19		       ;; range 0..19				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_DISPLAYMODE  PROC 	       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,DISP		       ;;					;AN000;
				       ;; Check for a preceeding PRINTER	;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;;					;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; If first DISPLAYMODE...		;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  AX,BLOCK_END	       ;;					;AN000;
	 MOV  [BP].DISPLAYMODE_PTR,AX  ;; Set pointer to first DISPLAYMODE	;AN000;
	 MOV  BLOCK_START,AX	       ;; New block starts after last one	;AN000;
     .ENDIF			       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     CALL TERMINATE_DISPLAYMODE        ;; If not the first DISPLAYMODE then	;AN000;
				       ;;  clean up the last one.		;AN000;
     MOV  DI,BLOCK_START	       ;; DI=pointer to DISPLAYMODE block just	;AN000;
     MOV  AX,BLOCK_END		       ;;  built				;AN000;
    .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	MOV  [BP+DI].NEXT_DISP_MODE,AX ;; Add new block to DISPLAYMODE chain	;AN000;
    .ENDIF			       ;;					;AN000;
     MOV  BLOCK_START,AX	       ;; New block starts after last one	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,SIZE DISPLAYMODE_STR	       ;; Allocate space for new DISPLAYMODE	;AN000;
  CALL	GROW_SHARED_DATA	       ;;  block				;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     MOV  DI,BLOCK_START	       ;; Start of new block			;AN000;
     MOV  [BP+DI].NUM_SETUP_ESC,0	  ;; SETUP, RESTORE are optional so set ;AN000;
     MOV  [BP+DI].NUM_RESTORE_ESC,0	  ;;  to defaults			;AN000;
     MOV  [BP+DI].SETUP_ESC_PTR,-1	  ;;					;AN000;
     MOV  [BP+DI].RESTORE_ESC_PTR,-1	  ;;					;AN000;
     MOV  [BP+DI].BOX_WIDTH,0		  ;;					;AN000;
     MOV  [BP+DI].BOX_HEIGHT,0		  ;;					;AN000;
     MOV  [BP+DI].PRINT_OPTIONS,0	  ;; Default to NO print options	;AN000;
     MOV  [BP+DI].NUM_DISP_MODE,0      ;; Get ready to INC this 		;AN000;
     MOV  [BP+DI].NEXT_DISP_MODE,-1    ;; This is the last DISPLAYMODE for now! ;AN000;
     MOV  AX,BLOCK_END		       ;;					;AN000;
     MOV  [BP+DI].DISP_MODE_LIST_PTR,AX;; Start mode list at end of new block	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,DISP		       ;; Indicate DISPLAYMODE found		;AN000;
  AND  STMTS_DONE,NOT (BOX+GR+SET+REST) ;; Reset flags for PRINTBOX, GRAPHICS	;AN000;
				       ;;  stmts found				;AN000;
  AND  GROUPS_DONE,NOT (GR+SET+REST)   ;; Reset flags for GRAPHICS, SETUP,	;AN000;
				       ;;  RESTORE groups processed		;AN000;
  MOV  DI,OFFSET DISPMODE_PARSE_PARMS  ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If mode is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a mode to the list		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
	     INC  [BP+DI].NUM_DISP_MODE   ;; Bump number of modes in list	;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL   ;; Get mode from result buffer		;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store the mode at end of list 	;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID	  ;; Mode is invalid			;AN000;
	  MOV  PARSE_ERROR,YES		  ;;					;AN000;
	  MOV  BUILD_STATE,NO		  ;;					;AN000;
      .ENDIF				  ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1>		       ;;					;AN000;
				       ;;					;AN000;
  RET										;AN000;
				       ;;					;AN000;
PARSE_DISPLAYMODE  ENDP 							;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_SETUP								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
SETUP_PARSE_PARMS  LABEL WORD	     ;; Parser control blocks			;AN000;
	    DW	 SETUP_P	     ;; 					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
SETUP_P   DB   0,1		    ;; Required, max parms			;AN000;
	    DW	 SETUP_P1	    ;;						;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
SETUP_P1 DW   08000H		    ;; Numeric					;AN000;
	    DW	 0		       ;; nO Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	    ;; Result buffer				;AN000;
	    DW	 SETUP_P1V	    ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
SETUP_P1V    DB   1		    ;; # of value lists 			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,255		       ;; range 0..255				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_SETUP  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,SET		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; DISPLAYMODE must preceed this 	;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND SET>	       ;; Check for previous group of SETUP	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  stmts				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND SET>	       ;; If first SETUP...			;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AX,BLOCK_END	       ;;					;AN000;
	 MOV  [BP+DI].SETUP_ESC_PTR,AX ;; Set pointer to SETUP seq		;AN000;
	 MOV  [BP+DI].NUM_SETUP_ESC,0  ;; Init sequence size			;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,SET		       ;; Indicate SETUP found			;AN000;
 .IF <PREV_STMT NE SET> THEN	       ;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for SETUP group		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET SETUP_PARSE_PARMS     ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If esc byte is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a byte to the sequence		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
	     INC  [BP+DI].NUM_SETUP_ESC   ;; Bump number of bytes in sequence	;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL  ;; Get esc byte from result buffer		;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_SETUP  ENDP		    ;;						;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_RESTORE								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
RESTORE_PARSE_PARMS  LABEL WORD        ;; Parser control blocks 		;AN000;
	    DW	 RESTORE_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
RESTORE_P   DB	 0,1		      ;; Required, max parms			;AN000;
	    DW	 RESTORE_P1	      ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
RESTORE_P1 DW	08000H		      ;; Numeric				;AN000;
	    DW	 0		       ;; nO Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	    ;; Result buffer				;AN000;
	    DW	 RESTORE_P1V	      ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
RESTORE_P1V    DB   1		      ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,255		       ;; range 0..255				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_RESTORE  PROC			 ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,SET		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; DISPLAYMODE must preceed this 	;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND REST>        ;; Check for previous group of RESTORE	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  stmts				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND REST>        ;; If first RESTORE...			;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AX,BLOCK_END	       ;;					;AN000;
	 MOV  [BP+DI].RESTORE_ESC_PTR,AX ;; Set pointer to RESTORE seq		;AN000;
	 MOV  [BP+DI].NUM_RESTORE_ESC,0  ;; Init sequence size			;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,REST		       ;; Indicate RESTORE found		;AN000;
 .IF <PREV_STMT NE REST> THEN		;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for RESTORE group		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET RESTORE_PARSE_PARMS	 ;; parse parms 			;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If esc byte is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a byte to the sequence		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
	     INC  [BP+DI].NUM_RESTORE_ESC   ;; Bump number of bytes in sequence ;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL  ;; Get esc byte from result buffer		;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_RESTORE  ENDP		      ;;					;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_PRINTBOX								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
PRINTBOX_PARSE_PARMS  LABEL WORD	;; Parser control blocks		;AN000;
	    DW	 PRINTBOX_P		;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
PRINTBOX_P  DB	 1,4		       ;; Required, max parms			;AN000;
	    DW	 PRINTBOX_P0	       ;; LCD/STD				;AN000;
	    DW	 PRINTBOX_P1	       ;; width 				;AN000;
	    DW	 PRINTBOX_P1	       ;; height				;AN000;
	    DW	 PRINTBOX_P2	       ;; rotate				;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
PRINTBOX_P0  DW   2000H 	       ;; sTRING - display type 		;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTBOX_P0V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTBOX_P0V	DB   3			;; # of value lists			;AN000;
	    DB	 0		       ;; # of range numerics			;AN000;
	    DB	 0		       ;; # of discrete numerics		;AN000;
	    DB	 1		       ;; # of strings				;AN000;
	    DB	 1		       ;; tag					;AN000;
PRINTBOX_P0V1 DW   ?		       ;; string				;AN000;
				       ;;					;AN000;
PRINTBOX_P1  DW   8001H 	       ;; Numeric - BOX DIMENSIONS		;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTBOX_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTBOX_P1V	DB   1		       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 1,9		       ;; range 1..9				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PRINTBOX_P2  DW   2001H 	       ;; sTRING - ROTATE PARM			;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTBOX_P2V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTBOX_P2V	DB   3			;; # of value lists			;AN000;
	    DB	 0		       ;; # of range numerics			;AN000;
	    DB	 0		       ;; # of discrete numerics		;AN000;
	    DB	 1		       ;; # of strings				;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DW	 ROTATE_STR	       ;; string				;AN000;
ROTATE_STR  DB	 'ROTATE',0            ;;                                       ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PROF_BOX_W  DB	0		       ;; Box width and height extracted from	;AN000;
PROF_BOX_H  DB	0		       ;;  the profile				;AN000;
PRINTBOX_MATCH	     DB  0	       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_PRINTBOX	PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  PRINTBOX_MATCH,NO	       ;; Start out assuming the PRINTBOX ID	;AN000;
  MOV  PROF_BOX_W,0		       ;;  does not match the one requested	;AN000;
  MOV  PROF_BOX_H,0		       ;;					;AN000;
  MOV  CUR_STMT,BOX		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; DISPLAYMODE must preceed PRINTBOX	;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;; Multiple PRINTBOX stmts may be coded	;AN000;
				       ;;  We must decide if this one		;AN000;
				       ;;   matches the requested display type	;AN000;
				       ;;    If not, ignore the statement	;AN000;
  MOV  DI,OFFSET PRINTBOX_PARSE_PARMS  ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,PRINTBOX_ID_PTR	       ;; Insert requested display type in	;AN000;
  MOV  PRINTBOX_P0V1,AX 	       ;;  parser value list			;AN000;
  CALL SYSPARSE 		       ;; PARSE display type			;AN000;
 .IF <AX EQ 0>			       ;; If ID matches then set this flag.	;AN000;
     MOV  PRINTBOX_MATCH,YES	       ;;					;AN000;
     OR   STMTS_DONE,BOX	       ;; Indicate PRINTBOX found		;AN000;
     MOV  AX,PREV_STMT		       ;; Terminate any preceeding groups	;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE horizontal dimension		;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
     MOV  BL,RESULT_VAL 	       ;;					;AN000;

; \/ ~~mda(005) -----------------------------------------------------------------------
;           Presently a 3,1 printbox is not supported for HP PCL printers, but
;           a 4,1 printbox is supported.  The reason for this is that one byte
;           is printed at a time and only two 3,1 print boxes are placed in
;           the one byte print buffer, leaving two blank bits.  This causes
;           the picture to have blank lines running through it and results in
;           a 4,1 printbox.  Instead of placing only two 3,1 print boxes in 
;           the print buffer, two 3,1 print boxes plus a partial 3,1 printbox
;           should be placed in the print buffer.  Another solution is to
;           make the print buffer be three bytes long, and place eight 3,1 
;           print boxes in the three byte long print buffer.  Since the present
;           implementation results in a faulty 4,1 printbox, we change the 3,1
;           printbox to a 4,1 printbox up front.  So even though we still
;           have a 4,1 printbox, at least we will have an accurate picture.
    .IF <[BP].DATA_TYPE EQ DATA_ROW> AND
    .IF <BL EQ 3>
         MOV BL,4
    .ENDIF
; /\ ~~mda(005) -----------------------------------------------------------------------
              
     MOV  PROF_BOX_W,BL 	       ;; Save in local var			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <AX EQ -1>		       ;;					;AN000;
	JMP  PRINTBOX_DONE	       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE vertical dimension		;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
     MOV  BL,RESULT_VAL 	       ;;					;AN000;
     MOV  PROF_BOX_H,BL 	       ;; Save in local var			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <AX EQ -1>		       ;;					;AN000;
	JMP  SHORT   PRINTBOX_DONE     ;;					;AN000;
    .ELSE			       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; Parse ROTATE parm			;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
    .IF <BUILD_STATE EQ YES> AND       ;;					;AN000;
    .IF <PRINTBOX_MATCH EQ YES>        ;;					;AN000;
	PUSH DI 		       ;;					;AN000;
	MOV  DI,BLOCK_START	       ;;					;AN000;
	OR   [BP+DI].PRINT_OPTIONS,ROTATE ;;					;AN000;
	POP  DI 		       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ELSE				       ;;					;AN000;
    .IF <AX EQ -1>		       ;;					;AN000;
	JMP  SHORT   PRINTBOX_DONE     ;;					;AN000;
    .ELSE			       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; CHECK FOR EXTRA PARMS 		;AN000;
 .IF <AX NE -1> 		    ;;						;AN000;
    OR	STMT_ERROR,INVALID	   ;;						;AN000;
    MOV PARSE_ERROR,YES 	   ;;						;AN000;
    MOV BUILD_STATE,NO		   ;;						;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PRINTBOX_DONE:			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BUILD_STATE EQ YES> AND	    ;; Store the PRINTBOX dimensions		;AN000;
 .IF <PRINTBOX_MATCH EQ YES>	    ;;						;AN000;
     PUSH DI			    ;;	in the DISPLAYMODE block		;AN000;
     MOV  DI,BLOCK_START	    ;;						;AN000;
     MOV  AL,PROF_BOX_W 	    ;;						;AN000;
     MOV  [BP+DI].BOX_WIDTH,AL	    ;;						;AN000;
     MOV  AL,PROF_BOX_H 	    ;;						;AN000;
     MOV  [BP+DI].BOX_HEIGHT,AL     ;;						;AN000;
     POP  DI			    ;;						;AN000;
 .ENDIF 			    ;;						;AN000;
				       ;; If we have a B&W printer then 	;AN000;
				       ;;   load the grey patterns for the	;AN000;
				       ;;    requested print box size.		;AN000;
 .IF <CUR_PRINTER_TYPE EQ BLACK_WHITE> NEAR					;AN000;
				       ;;					;AN000;
    .IF <PROF_BOX_W NE 0> AND NEAR	  ;; Dimensions could also be 0 if the	;AN000;
    .IF <PROF_BOX_H NE 0> NEAR		  ;;  printbox ID does not apply to this;AN000;
					  ;;   displaymode, so don't try for    ;AN000;
					  ;;	a pattern!			;AN000;
	MOV  BX,OFFSET TAB_DIRECTORY	  ;;					;AN000;
	MOV  CL,TAB_DIR_NB_ENTRIES	  ;;					;AN000;
	XOR  CH,CH			  ;;					;AN000;
	MOV  DI,BLOCK_START		  ;;					;AN000;
	MOV  AL,PROF_BOX_W		  ;; Requested box width		;AN000;
	MOV  AH,PROF_BOX_H		  ;; Requested box height		;AN000;
       .REPEAT				  ;;					;AN000;
	  .IF <[BX].BOX_W_PAT EQ AL> AND  ;;					;AN000;
	  .IF <[BX].BOX_H_PAT EQ AH>	  ;;					;AN000;
	     .LEAVE			  ;;					;AN000;
	  .ELSE 			  ;;					;AN000;
	      ADD  BX,SIZE TAB_ENTRY	  ;;					;AN000;
	  .ENDIF			  ;;					;AN000;
       .LOOP				  ;;					;AN000;
       .IF <ZERO CX>			  ;;					;AN000;
	   OR  STMT_ERROR,INVALID	  ;; Unsupported box size		;AN000;
	   MOV PARSE_ERROR,YES		  ;;					;AN000;
	   MOV BUILD_STATE,NO		  ;;					;AN000;
       .ELSE NEAR			  ;; Box size OK - pattern tab found	;AN000;
	  .IF <[BX].TAB_COPY NE -1>	  ;; Pointer is NOT null if the table	;AN000;
	      MOV  AX,[BX].TAB_COPY	  ;;  has already been copied to	;AN000;
					  ;;   the shared data area.		;AN000;
	     .IF <BUILD_STATE EQ YES> AND ;;	Point to the copy.		;AN000;
	     .IF <PRINTBOX_MATCH EQ YES>  ;; Establish pointer to table ONLY	;AN000;
		 MOV  [BP+DI].PATTERN_TAB_PTR,AX ;; if the PB ID matched.	;AN000;
		 MOV  AL,[BX].NB_INT	  ;; Number of table entries (intensitie;AN000;
		 MOV  [BP+DI].NUM_PATTERNS,AL ;;				;AN000;
	     .ENDIF			  ;;					;AN000;
	  .ELSE 			  ;; Otherwise we have to copy it.	;AN000;
	   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
	   ;; Copy the table even if the printbox ID didn't match!              ;AN000;
	   ;; This is a simple way to reserve enough space to allow reloading	;AN000;
	   ;; with a different PRINTBOX ID specified on the command line.	;AN000;
	   ;; This scheme avoids storing					;AN000;
	   ;; duplicate tables but may reserve slightly more space		;AN000;
	   ;; (probably only a hundred bytes or so) than			;AN000;
	   ;; could ever be required.  The optimal solution (too		;AN000;
	   ;; complicated!) would involve keeping running totals for each	;AN000;
	   ;; PRINTBOX ID coded.						;AN000;
	   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
					  ;;					;AN000;
	      MOV  DI,BLOCK_END 	  ;; Copy it onto the end of the	;AN000;
					  ;;  current block			;AN000;
	      MOV  DX,DI		  ;; Save start addr of the copy	;AN000;
	      MOV  [BX].TAB_COPY,DX	  ;; Store ptr to copy in the directory ;AN000;
	      MOV  AX,[BX].TAB_SIZE	  ;;					;AN000;
	      CALL GROW_SHARED_DATA	  ;; Allocate room for the table	;AN000;
	     .IF <BUILD_STATE EQ YES>	  ;;					;AN000;
		 MOV  CX,AX		  ;; Number of bytes to copy		;AN000;
		 PUSH SI		  ;; Save parse pointer 		;AN000;
		 MOV  SI,[BX].TAB_OFFSET  ;; Source pointer			;AN000;
		 ADD  DI,BP		  ;; make DI an absolute pointer (dest) ;AN000;
		 REP  MOVSB		  ;; Move it!				;AN000;
		 POP  SI		  ;;					;AN000;
		.IF <PRINTBOX_MATCH EQ YES>  ;; Establish pointer to table ONLY ;AN000;
		    MOV  DI,BLOCK_START      ;; Establish pointer in DISPLAYMODE;AN000;
		    MOV  [BP+DI].PATTERN_TAB_PTR,DX  ;;  info			;AN000;
		    MOV  AL,[BX].NB_INT      ;; Number of table entries (intens);AN000;
		    MOV  [BP+DI].NUM_PATTERNS,AL ;;				;AN000;
		.ENDIF			     ;; 				;AN000;
	     .ENDIF			  ;;					;AN000;
	  .ENDIF			   ;;					;AN000;
       .ENDIF			       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_PRINTBOX	ENDP								;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_VERB 								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
VERB_PARSE_PARMS  LABEL WORD	       ;; Parser control blocks to parse verb	;AN000;
	    DW	 VERB_P 	       ;; Parser control blocks to parse verb	;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
VERB_P	    DB	 0,1		       ;; Required, max parms			;AN000;
	    DW	 VERB_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
VERB_P1     DW	 2000H		       ;; simple string 			;AN000;
	    DW	 0002H		       ;; Capitalize using character table	;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 VERB_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
VERB_P1V    DB	 3			  ;; # of value lists			;AN000;
	    DB	 0			  ;; # of range numerics		;AN000;
	    DB	 0			  ;; # of discrete numerics		;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Changed the number of strings from 9 to 10 because of the
;               new DEFINE statement.
	    DB	 10			  ;; # of strings			;AN000;
;/\  ~~mda(001) ----------------------------------------------------------
	    DB	 0			  ;; tag: index into verb jump table	;AN000;
	    DW	 PRINTER_STRING 	  ;; string offset			;AN000;
	    DB	 2			  ;; tag				;AN000;
	    DW	 DISPLAYMODE_STRING	  ;; string offset			;AN000;
	    DB	 4			  ;; tag				;AN000;
	    DW	 PRINTBOX_STRING	  ;; string offset			;AN000;
	    DB	 6			  ;; tag				;AN000;
	    DW	 SETUP_STRING		  ;; string offset			;AN000;
	    DB	 8			  ;; tag				;AN000;
	    DW	 RESTORE_STRING 	  ;; string offset			;AN000;
	    DB	 10			  ;; tag				;AN000;
	    DW	 GRAPHICS_STRING	  ;; string offset			;AN000;
	    DB	 12			  ;; tag				;AN000;
	    DW	 COLORPRINT_STRING	  ;; string offset			;AN000;
	    DB	 14			  ;; tag				;AN000;
	    DW	 COLORSELECT_STRING	  ;; string offset			;AN000;
	    DB	 16			  ;; tag				;AN000;
	    DW	 DARKADJUST_STRING	  ;; string offset			;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added DEFINE_STRING to the value list.
;
            DB   18                       ;; tag
            DW   DEFINE_STRING            ;; string offset
;/\  ~~mda(001) ----------------------------------------------------------
PRINTER_STRING	    DB 'PRINTER',0        ;;                                    ;AN000;
DISPLAYMODE_STRING  DB 'DISPLAYMODE',0    ;;                                    ;AN000;
PRINTBOX_STRING     DB 'PRINTBOX',0       ;;                                    ;AN000;
SETUP_STRING	    DB 'SETUP',0          ;;                                    ;AN000;
RESTORE_STRING	    DB 'RESTORE',0        ;;                                    ;AN000;
GRAPHICS_STRING     DB 'GRAPHICS',0       ;;                                    ;AN000;
COLORPRINT_STRING   DB 'COLORPRINT',0     ;;                                    ;AN000;
COLORSELECT_STRING  DB 'COLORSELECT',0    ;;                                    ;AN000;
DARKADJUST_STRING   DB 'DARKADJUST',0     ;;                                    ;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added the DEFINE_STRING.
;
DEFINE_STRING       DB 'DEFINE',0         ;;
;/\  ~~mda(001) ----------------------------------------------------------
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_VERB     PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET VERB_PARSE_PARMS      ;; parse parms				;AN000;
  MOV  SI,OFFSET STMT_BUFFER	       ;; the line to parse			;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
  CALL SYSPARSE 		       ;;					;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
    MOV  BL,RESULT_TAG		       ;;					;AN000;
    XOR  BH,BH			       ;; return tag in BX			;AN000;
 .ELSE				       ;;					;AN000;
   .IF <AX NE -1>		       ;; syntax error				;AN000;
      OR  STMT_ERROR,INVALID	       ;; set error flag for caller		;AN000;
   .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET										;AN000;
PARSE_VERB     ENDP								;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;

;\/ ~~mda(001)  -----------------------------------------------------------------------
;               This procedure parses the new statement DEFINE in the
;               graphics profile.  The reason for this new statement
;               is to be able to define the new keyword, DATA, as DATA_ROW
;               or DATA_COL.  This is necessary in order to support HP PCL
;               printers since they print in row format and IBM printers
;               print in column format.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;;										
;; Module Name: 								
;;   PARSE_DEFINE								
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
DEFINE_PARSE_PARMS  LABEL WORD         ;; Parser control blocks 		
	    DW	 DEFINE_P	       ;;					
	    DB	 2		       ;; # of lists				
	    DB	 0		       ;; # items in delimeter list		
	    DB	 1		       ;; # items in end-of-line list		
	    DB	 ';'                   ;; ';' used for comments                 
				       ;;					
DEFINE_P    DB   0,1		       ;; Required, max parms.  If have DEFINE	
				       ;; then must have DEFINE DATA,ROW or
				       ;; DEFINE DATA,COLUMN
	    DW	 DEFINE_P1	       ;;					
	    DB	 0		       ;; # Switches				
	    DB	 0		       ;; # keywords				
				       ;;					
DEFINE_P1   DW	 2000H 	       	       ;; simple string				
	    DW	 2		       ;; Capitalize				
	    DW	 RESULT_BUFFER	       ;; Result buffer 			
	    DW	 DEFINE_P1V	       ;; Value list				
	    DB	 0		       ;; Synomyms				
				       ;;					
				       ;;					
DEFINE_P1V  DB   3		       ;; # of value lists			
	    DB	 0		       ;; # of range numerics			
	    DB	 0		       ;; # of discrete numerics		
	    DB	 3		       ;; 3 STRING VALUES			
	    DB	 1		       ;; tag					
	    DW	 DATA_STR	       ;; ptr					
	    DB	 2		       ;; tag					
	    DW	 ROW_STR	       ;; ptr					
	    DB	 3		       ;; tag					
	    DW	 COL_STR	       ;; ptr					
				       ;;					
DATA_STR    DB  'DATA',0               ;;                                       
ROW_STR     DB  'ROW',0                ;;                                       
COL_STR     DB  'COLUMN',0             ;;                                       
				       ;;					
				       ;;					
ROW_FOUND	 DB  NO 	       ;;					
COL_FOUND        DB  NO 	       ;; Assume column until told otherwise	
DATA_FOUND	 DB  NO		       ;;
				       ;;					
				       ;;					
PARSE_DEFINE	PROC		       ;;					
				       ;;					
  MOV  CUR_STMT,DEF		       ;; 					
 .IF <BIT STMTS_DONE NAND PRT>         ;; If no preceeding PRT stmt		
     OR   STMT_ERROR,MISSING	       ;; then issue error			
     MOV  PARSE_ERROR,YES	       ;;					
     MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
                                       ;;
 .IF <BIT STMTS_DONE AND DISP>	       ;; DISPLAYMODE stmts			
     OR   STMT_ERROR,SEQUENCE	       ;; should NOT have been processed	
     MOV  PARSE_ERROR,YES	       ;;					
     MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
                                       ;;
 .IF <BIT STMTS_DONE AND DEF>	       ;; If another DEF stmt within in this
     OR   STMT_ERROR,INVALID           ;; PTD then issue error			
     MOV  PARSE_ERROR,YES	       ;;					
     MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
				       ;;					
				       ;;					
  MOV  ROW_FOUND,NO	               ;; Flags to indicate whether the ROW,	
  MOV  COL_FOUND,NO		       ;; COLUMN, or DATA parms were found.  	
  MOV  DATA_FOUND,NO                   ;;
				       ;;					
  OR   STMTS_DONE,DEF		       ;; Indicate DEFINE found			
				       ;;					
  MOV  DI,OFFSET DEFINE_PARSE_PARMS    ;; parse parms				
				       ;; SI => the line to parse		
  XOR  DX,DX			       ;;					
 .REPEAT			       ;;					
    XOR  CX,CX			       ;;					
    CALL SYSPARSE		       ;;					
				       ;;					
   .IF <AX EQ 0> NEAR		       ;; If PARM is valid			
	MOV  BL,RESULT_TAG	       ;;					
       .SELECT			       ;;					
       .WHEN <BL EQ 1>		       ;; DATA string				
	   CMP DATA_FOUND,NO           ;; .IF <DATA_FOUND EQ NO> ... .ELSE ...  
	   JNE DATA_ERROR	       ;; Not using .IF macro because jump is 
	   MOV DATA_FOUND,YES	       ;; out of range.
	   JMP CONT_PARSE              ;;
DATA_ERROR:                            ;;
	   OR  STMT_ERROR,INVALID      ;; Duplicate DATA parms			
	   MOV  PARSE_ERROR,YES        ;;					
	   MOV  BUILD_STATE,NO         ;;					
	                               ;;
       .WHEN <BL EQ 2>		       ;; ROW					
	  .IF <ROW_FOUND EQ NO> AND    ;;					
	  .IF <COL_FOUND EQ NO>        ;;					
	       MOV   ROW_FOUND,YES     ;;					
              .IF <BUILD_STATE EQ YES> ;; ~~mda(002) If this is the DEFINE stmt we're using
	           MOV  [BP].DATA_TYPE,DATA_ROW ;; Set DATA_TYPE to DATA_ROW. 	
              .ENDIF
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate ROW parms or combo of	
				       ;; parms ROW and COLUMN
	       MOV  PARSE_ERROR,YES    ;;					
	       MOV  BUILD_STATE,NO     ;;					
	  .ENDIF		       ;;					
                                       ;;
       .WHEN <BL EQ 3>		       ;; COLUMN				
	  .IF <COL_FOUND EQ NO> AND    ;;					
	  .IF <ROW_FOUND EQ NO>        ;;					
	       MOV   COL_FOUND,YES     ;;					
              .IF <BUILD_STATE EQ YES> ;; ~~mda(002) If this is the DEFINE stmt we're using
     	           MOV  [BP].DATA_TYPE,DATA_COL	;; Set DATA_TYPE to DATA_COL. 	
              .ENDIF                   ;;
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate COLUMN parms or combo of	
				       ;; parms COLUMN and ROW
	       MOV  PARSE_ERROR,YES    ;;					
	       MOV  BUILD_STATE,NO     ;;					
	  .ENDIF		       ;;					
       .ENDSELECT		       ;;					
   .ELSE NEAR			       ;;					
      .IF <AX NE -1>		       ;;					
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			
	  MOV  PARSE_ERROR,YES	       ;;					
	  MOV  BUILD_STATE,NO	       ;;					
      .ENDIF			       ;;					
   .ENDIF			       ;;					
CONT_PARSE:                            ;;
 .UNTIL <AX EQ -1> NEAR 	       ;;					
				       ;;					
 .IF  <DATA_FOUND EQ NO>               ;; Missing DATA parm			
      OR   STMT_ERROR,INVALID	       ;;					
      MOV  PARSE_ERROR,YES	       ;;					
      MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
                                       ;;
                                       ;;
 .IF  <ROW_FOUND EQ NO> AND	       ;; Missing ROW or COLUMN parm		
 .IF  <COL_FOUND EQ NO>                ;;
      OR   STMT_ERROR,INVALID	       ;;					
      MOV  PARSE_ERROR,YES	       ;;					
      MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
				       ;;					
  RET				       ;;					
				       ;;					
PARSE_DEFINE	ENDP		       ;;					
				       ;;					
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;/\ ~~mda(001)  -----------------------------------------------------------------------
										;AN000;
LIMIT	LABEL NEAR		       ;;					;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grload3.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:   I restructured the procedure PARSE_GRAPHICS so it can handle 
;**                 the keywords LOWCOUNT, HIGHCOUNT, the new keywords COUNT and 
;**                 DATA, and the escape sequence bytes in any order.
;**  
;**  BUG NOTES:     The   following   bug   was  fixed   for   the   pre-release  
;**                 version Q.01.02.
;**  
;**  BUG (mda003)
;**  ------------
;**  
;**  NAME:     GRAPHICS   prints  a CR & LF after  each  scan line unless it  is 
;**            loaded twice.  
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD3.ASM - PARSE_GRAPHICS
;**                                GRCOMMON.ASM - END_PRT_LINE
;**                                GRSHAR.STR - N/A
;**  
;**  CAUSES:   The local variables LOWCOUNT_FOUND, HIGHCOUNT_FOUND CR_FOUND  and 
;**            LF_FOUND used for loading, were incorrectly being used as  global 
;**            variables during printing.
;**  
;**  FIX:      Created  a new variable Printer_Needs_CR_LF in GRSHAR.STR,  which 
;**            is  used  to  determine  in GRCOMMON.ASM  if  it's  necessary  to 
;**            manually  send  a  CR  & LF to the printer  at  print  time.  The 
;**            variable  is  set at load time in GRLOAD3.ASM, if  the  variables 
;**            Data_Found and Build_State are set. 
;**  
;**  DOCUMENTATION NOTES:  This version of GRLOAD3.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Profile Load Modules #2 	;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                    
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE' BYTE     ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
	INCLUDE GRSHAR.STR	       ;;					;AN000;
	INCLUDE GRMSG.EQU	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;;					;AN000;
	INCLUDE GRLOAD.EXT	       ;;					;AN000;
	INCLUDE GRLOAD2.EXT	       ;;					;AN000;
	INCLUDE GRPARSE.EXT	       ;;					;AN000;
	INCLUDE GRPATTRN.STR	       ;;					;AN000;
	INCLUDE GRPATTRN.EXT	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC PARSE_GRAPHICS	       ;;					;AN000;
   PUBLIC PARSE_COLORSELECT	       ;;					;AN000;
   PUBLIC PARSE_COLORPRINT	       ;;					;AN000;
   PUBLIC PARSE_DARKADJUST	       ;;					;AN000;
   PUBLIC LIMIT 		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Profile Load Variables							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
NO	      EQU   0		       ;;					;AN000;
YES	      EQU   1		       ;;					;AN000;
				       ;;					;AN000;
RESULT_BUFFER	LABEL BYTE	       ;; general purpose result buffer 	;AN000;
		    DB	 ?	       ;; operand type				;AN000;
RESULT_TAG	    DB	 0	       ;; operand tag				;AN000;
		    DW	 ?	       ;; pointer to synonym/keyword		;AN000;
RESULT_VAL	    DB	 ?,?,?,?       ;; returned numeric value		;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_GRAPHICS								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
GRAPHICS_PARSE_PARMS  LABEL WORD       ;; Parser control blocks 		;AN000;
	    DW	 GRAPHICS_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
GRAPHICS_P   DB   0,1		       ;; Required, max parms			;AN000;
	    DW	 GRAPHICS_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
GRAPHICS_P1 DW	 0A000H 	       ;; Numeric OR string			;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 GRAPHICS_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
GRAPHICS_P1V	DB   3		       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,255		       ;; range 0..255				;AN000;
	    DB	 0		       ;; 0 - no actual numerics		;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               Changed the # of string values from 2 to 4 because of the new
;               keywords COUNT and DATA.
	    DB	 4		       ;; 4 STRING VALUES			;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
	    DB	 2		       ;; tag					;AN000;
	    DW	 LOWCOUNT_STR	       ;; ptr					;AN000;
	    DB	 3		       ;; tag					;AN000;
	    DW	 HIGHCOUNT_STR	       ;; ptr					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               Added the following valid string values because of the new
;               keywords COUNT and DATA.
            DB  4                       ; tag
            DW  COUNT_STR               ; ptr
            DB  5                       ; tag
            DW  DATA_STR                ; ptr

COUNT_STR     DB  'COUNT',0             ;
DATA_STR      DB  'DATA',0              ;
;
;/\  ~~mda(001) -----------------------------------------------------------------------
				       ;;					;AN000;
lowcount_str  db  'LOWCOUNT',0         ;;                                       ;AN000;
HIGHcount_str  db  'HIGHCOUNT',0       ;;                                       ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
LOWCOUNT_FOUND	 DB  NO 	       ;;					;AN000;
HIGHCOUNT_FOUND  DB  NO 	       ;;				  	;AN000;

;\/  ~~mda(001) -----------------------------------------------------------------------
;                Added the following so know when get COUNT and DATA.
COUNT_FOUND      DB  NO                 ;
DATA_FOUND       DB  NO                 ;
;
;/\  ~~mda(001) -----------------------------------------------------------------------
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_GRAPHICS	PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,GR		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;;					;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
	
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     MOV  DI,BLOCK_START	       ;;					;AN000;
     MOV  AX,BLOCK_END		       ;;				;AN000;
     MOV  [BP+DI].GRAPHICS_ESC_PTR,AX  ;; Set pointer to GRAPHICS seq		;AN000;
     MOV  [BP+DI].NUM_GRAPHICS_ESC,0   ;; Init sequence size			;AN000;
     MOV  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA,0   ;;~~mda(001) Init sequence size			;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  LOWCOUNT_FOUND,NO	       ;; Flags to indicate whether the LOW	;AN000;
  MOV  HIGHCOUNT_FOUND,NO	       ;;  and HIGHCOUNT parms were found	;AN000;
  MOV  COUNT_FOUND,NO                  ;;~~mda(001) Flags to indicate the COUNT 
  MOV  DATA_FOUND,NO 		       ;;~~mda(001) and DATA parms were found					;AN000;
                                       ;;
  OR   STMTS_DONE,GR		       ;; Indicate GRAPHICS found		;AN000;
				       ;;					;AN000;
  MOV  AX,PREV_STMT		       ;; Terminate any preceeding groups	;AN000;
  OR   GROUPS_DONE,AX		       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET GRAPHICS_PARSE_PARMS  ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
				       ;;					;AN000;
   .IF <AX EQ 0> NEAR		       ;; If PARM is valid			;AN000;
	MOV  BL,RESULT_TAG	       ;;					;AN000;
       .SELECT			       ;;					;AN000;
       .WHEN <BL EQ 1>		       ;; Escape byte				;AN000;
	  PUSH AX		       ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               Changed the 1 to a 2 in the following instruction cause
;               need an extra byte in the sequence to hold the tag that
;               corresponds to esc seq., so during printing we know what to
;               send and in what order.

	  MOV	AX,2		       ;; Add a byte to the sequence		;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               During printing we need to know how many things (things being
;               esc #s, count, lowcount, or highcount) come before
;               the data and how many things go after the data, - not just
;               how many bytes are in the sequence.  So check if dealing with 
;               things that come before the data.

            .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
	        INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.       	
            .ELSE                       ; Bump # of things in seq. that
                INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	    .ENDIF
;/\  ~~mda(001) -----------------------------------------------------------------------
	     MOV  DI,BLOCK_END	       ;;					;AN000;
             MOV  BYTE PTR [BP+DI-2],ESC_NUM_CODE;
	     MOV  AL,RESULT_VAL        ;; Get esc byte from result buffer	;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
       .WHEN <BL EQ 2>		       ;; LOWCOUNT				;AN000;
	   CMP LOWCOUNT_FOUND,NO       ;; ~~mda(001) If no LOWCOUNT or COUNT   ;AN000;
           JNE LOWCNT_ERROR             ; ~~mda(001) then proceed.  Not using
           CMP COUNT_FOUND,NO           ; ~~mda(001) .IF macro cause jump is 
           JNE LOWCNT_ERROR             ; ~~mda(001) out of range
	       MOV   LOWCOUNT_FOUND,YES ;;					;AN000;
	       PUSH AX		       ;;					;AN000;
	       MOV   AX,2	       ;; ~~mda(001) Changed a 1 to a 2 cause	;AN000;
                                        ; ~~mda(001) need extra byte for tag
	       CALL  GROW_SHARED_DATA  ;; Update block end			;AN000;
	      .IF <BUILD_STATE EQ YES> ;;					;AN000;
		  PUSH DI	       ;;					;AN000;
		  MOV  DI,BLOCK_START  ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
                 .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
        	     INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.      
                 .ELSE                       ; Bump # of things in seq. that
                     INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	         .ENDIF
;/\  ~~mda(001) -----------------------------------------------------------------------
	
		  MOV  DI,BLOCK_END    ;; ~~mda(001) Put BLOCK_END in DI not AX.;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               No longer need following 3 instruction cause will have COUNT
;               at a known fixed location in the SHARED_DATA_AREA.
;
;;		  DEC  AX	       ;; Save pointer to low byte		;AN000;
;;		  MOV  [BP+DI].LOW_BYT_COUNT_PTR,AX				;AN000;
;;		  MOV  DI,AX	       ;;			 		;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
                  MOV  BYTE PTR [BP+DI-2],LOWCOUNT_CODE;
		  MOV  BYTE PTR[BP+DI-1],0 ;; ~~mda(001) Added the -1. Store 0 in ;AN000;
		  POP  DI	       ;;		 in place of count      ;AN000;
	      .ENDIF		       ;;					;AN000;
	       POP  AX		       ;;					;AN000;
               JMP  CK_NEXT_PARM        ;~~mda(001) Added jump since can't use .IF macro
 LOWCNT_ERROR:  		       ;;~~mda(001) Added label since can't use .IF macro 
	       OR  STMT_ERROR,INVALID  ;; Duplicate LOWCOUNT parms              ;AN000;
	       MOV  PARSE_ERROR,YES    ;;~~mda(001) or combo of LOWCOUNT & COUNT;AN000;
	       MOV  BUILD_STATE,NO     ;;					;AN000;
       .WHEN <BL EQ 3>		       ;; HIGHCOUNT				;AN000;
	   CMP HIGHCOUNT_FOUND,NO       ;; ~~mda(001) If no HIGHCOUNT or COUNT   ;AN000;
           JNE HIGHCNT_ERROR             ; ~~mda(001) then proceed.  Not using
           CMP COUNT_FOUND,NO           ;  ~~mda(001) .IF macro cause jump is 
           JNE HIGHCNT_ERROR             ; ~~mda(001) out of range
	      MOV   HIGHCOUNT_FOUND,YES ;;					;AN000;
	      PUSH AX		       ;;					;AN000;
	      MOV   AX,2	       ;; ~~mda(001) Changed a 1 to a 2 cause	;AN000;
                                        ; ~~mda(001) need extra byte for tag
	      CALL  GROW_SHARED_DATA   ;; Update block end			;AN000;
	     .IF <BUILD_STATE EQ YES>  ;;					;AN000;
		 PUSH DI	       ;;					;AN000;
		 MOV  DI,BLOCK_START   ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
                .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
	            INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.    
                .ELSE                       ; Bump # of things in seq. that
                    INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	        .ENDIF
;/\  ~~mda(001) -----------------------------------------------------------------------

        	 MOV  DI,BLOCK_END    ;; ~~mda(001) Put BLOCK_END in DI not AX. ;AN000;	
;\/  ~~mda(001) -----------------------------------------------------------------------
;               No longer need following 3 instructions cause will have COUNT
;               at a known fixed location in the SHARED_DATA_AREA.
;
;;		 DEC  AX	       ;; Save pointer to low byte		;AN000;
;;		 MOV  [BP+DI].LOW_BYT_COUNT_PTR,AX				;AN000;
;;	         MOV  DI,AX	       ;;			 		;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
                 MOV  BYTE PTR [BP+DI-2],HIGHCOUNT_CODE;
		 MOV  BYTE PTR[BP+DI-1],0 ;; ~~mda(001) Added the -1. Store 0 in  ;AN000;
		 POP  DI	       ;; place of count					;AN000;
	     .ENDIF		       ;;					;AN000;
	      POP  AX		       ;;					;AN000;
              JMP  CK_NEXT_PARM        ;~~mda(001) Added jump since can't use .IF macro
	
 HIGHCNT_ERROR: 		       ;;~~mda(001) Added label cause can't use .IF macro.					;AN000;
	       OR  STMT_ERROR,INVALID  ;; Duplicate HIGHCOUNT parms	       
	       MOV  PARSE_ERROR,YES    ;; ~~mda(001) or combo of HIGHCOUNT and  ;AN000;
	       MOV  BUILD_STATE,NO     ;; ~~mda(001) COUNT parms                ;AN000;

;\/  ~~mda(001) -----------------------------------------------------------------------
;               Added the following two cases for when have COUNT or DATA on
;               GRAPHICS line.
 
       .WHEN <BL EQ 4>		       ;; COUNT				        
          .IF <COUNT_FOUND EQ NO> AND   ; If haven't found a type of count
	  .IF <LOWCOUNT_FOUND EQ NO> AND;;then proceed.                         
          .IF <HIGHCOUNT_FOUND EQ NO>   ; 
                                        ; 
	      MOV   COUNT_FOUND,YES    ;;					
	      PUSH AX		       ;;					
	      MOV   AX,2	       ;; Add 2 bytes to the seq. cause         
                                        ; need extra byte for tag
	      CALL  GROW_SHARED_DATA   ;; Update block end			
	     .IF <BUILD_STATE EQ YES>  ;;					
		 PUSH DI	       ;;					
		 MOV  DI,BLOCK_START   ;;					
                .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
	            INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.       	
                .ELSE                       ; Bump # of things in seq. that
                    INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	        .ENDIF
        	 MOV  DI,BLOCK_END    ;;                                        	
                 MOV  BYTE PTR [BP+DI-2],COUNT_CODE;
		 MOV  BYTE PTR[BP+DI-1],0 ;; Store 0 in place of count          
		 POP  DI	       ;; 					
	     .ENDIF		       ;;					
	      POP  AX		       ;;					
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate COUNT parms or combo of     
	       MOV  PARSE_ERROR,YES    ;; COUNT, LOWCOUNT or HIGHCOUNT parms    
	       MOV  BUILD_STATE,NO     ;;                                       
	  .ENDIF		       ;;					

       .WHEN <BL EQ 5>		       ;; DATA				        
          .IF <DATA_FOUND EQ NO>        ; If haven't found data then proceed
	      MOV   DATA_FOUND,YES     ;;					
	      PUSH AX		       ;;					
	      MOV   AX,2	       ;; Add 2 bytes to the seq. cause         
                                        ; need extra byte for tag
	      CALL  GROW_SHARED_DATA   ;; Update block end			
	     .IF <BUILD_STATE EQ YES>  ;;					
                 PUSH DI               ;;
        	 MOV  DI,BLOCK_END    ;;                                        
                 MOV  BYTE PTR [BP+DI-2],DATA_CODE;
		 MOV  BYTE PTR[BP+DI-1],0 ;; Store 0 in place of data           
		 POP  DI	       ;; 					
	     .ENDIF		       ;;					
	      POP  AX		       ;;					
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate DATA parms                  
	       MOV  PARSE_ERROR,YES    ;;                                       
	       MOV  BUILD_STATE,NO     ;;                                       
	  .ENDIF		       ;;					
;/\  ~~mda(001) -----------------------------------------------------------------------

       .ENDSELECT		       ;;					;AN000;
   .ELSE NEAR			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;

CK_NEXT_PARM:                           ;~~mda(001) Added label since can't use
                                        ;~~mda(001) .IF macro.
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;

;\/  ~~mda(003) -----------------------------------------------------------------------
 .IF  <DATA_FOUND EQ NO>               ;; We have a printer that requires a					;AN000;
      .IF <BUILD_STATE EQ YES>         ;;
           MOV  [BP].PRINTER_NEEDS_CR_LF,YES; CR, LF to be sent to it
      .ENDIF                           ;;
 .ENDIF                                ;;
;/\  ~~mda(003) -----------------------------------------------------------------------

				       ;;					;AN000;
 .IF  <LOWCOUNT_FOUND EQ NO> OR        ;;					;AN000;
 .IF  <HIGHCOUNT_FOUND EQ NO>	       ;; Missing LOWCOUNT/HIGHCOUNT parms	;AN000;
      .IF  <COUNT_FOUND EQ NO>         ;; ~~mda(001) or missing COUNT parm
           OR   STMT_ERROR,INVALID	       ;;					;AN000;
           MOV  PARSE_ERROR,YES	       ;;					;AN000;
           MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_GRAPHICS	ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_COLORSELECT								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
COLORSELECT_PARSE_PARMS  LABEL WORD    ;; Parser control blocks 		;AN000;
	    DW	 COLORSELECT_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
COLORSELECT_P	   LABEL BYTE	       ;;					;AN000;
CS_NUM_REQ    DB   1,1		       ;; Required, max parms			;AN000;
COLORSELECT_PARM   LABEL  WORD	       ;;					;AN000;
CS_POSITIONAL DW   ?		       ;; Pointer to our positional		;AN000;
	      DB   0		       ;; # Switches				;AN000;
	      DB   0		       ;; # keywords				;AN000;
				       ;;					;AN000;
COLORSELECT_P0	DW   2000H	       ;; sTRING - display type 		;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORSELECT_P0V       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORSELECT_P0V    DB	0		   ;; # of value lists			;AN000;
;	    DB	 0		       ;; # of range numerics			;AN000;
;	    DB	 0		       ;; # of discrete numerics		;AN000;
;	    DB	 1		       ;; # of strings				;AN000;
;	    DB	 1		       ;; tag					;AN000;
;COLORSELECT_P0V1 DW   ?		   ;; string				;AN000;
				       ;;					;AN000;
COLORSELECT_P1	DW   8001H		  ;; Numeric - escape sequence byte	;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORSELECT_P1V	  ;; Value list 			;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORSELECT_P1V    DB	1		  ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 1,255		       ;; range 1..255				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
SEQ_LENGTH_PTR	DW   0		       ;; Number of colorselect statements	;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORSELECT  PROC 	       ;;					;AN000;
				      ;;					;AN000;
  MOV  CUR_STMT,COLS		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;; PRINTER  statemnet must have been	;AN000;
     OR  STMT_ERROR,MISSING	       ;;  processed				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE AND DISP+COLP>    ;; DISDPLAYMODE and COLORPRINT  stmts	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  should NOT have been processed	;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND COLS>        ;; Check for a previous group of 	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  COLORSELECTS within this PTD 	;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND COLS>        ;; If first COLORSELECT...		;AN000;
      MOV  NUM_BANDS,0		       ;; Init number of COLORSELECT bands	;AN000;
     .IF <BUILD_STATE EQ YES>	       ;; Update count and pointer in the	;AN000;
	 MOV  AX,BLOCK_END	       ;;  Shared Data Area header		;AN000;
	 MOV  [BP].COLORSELECT_PTR,AX  ;; Set pointer to COLORSELECT info	;AN000;
	 MOV  [BP].NUM_PRT_BANDS,0     ;; Init NUMBER OF COLORSELECTS		;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,COLS		       ;; Indicate found			;AN000;
 .IF <PREV_STMT NE COLS> THEN	       ;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for COLORSELECT		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV	AX,1			       ;; Make room for sequence length field	;AN000;
  CALL	GROW_SHARED_DATA	       ;;					;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     INC  [BP].NUM_PRT_BANDS	       ;; Inc number of selects 		;AN000;
     MOV  DI,BLOCK_END		       ;;					;AN000;
     MOV  BYTE PTR [BP+DI-1],0	       ;; Init sequence length field		;AN000;
     LEA  AX,[DI-1]		       ;;					;AN000;
     MOV  SEQ_LENGTH_PTR,AX	       ;; Save pointer to length of sequence	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET COLORSELECT_PARSE_PARMS  ;; parse parms			;AN000;
  MOV  CS_NUM_REQ,1		       ;; Change to 1 required parameters	;AN000;
  MOV  AX,OFFSET COLORSELECT_P0        ;; Point to control block for the band	;AN000;
  MOV  CS_POSITIONAL,AX 	       ;;  ID.	(Dealing with only 1 positional ;AN000;
				       ;;  parameter at a time was the only way ;AN000;
				       ;;   I could get SYSPARSE to handle	;AN000;
				       ;;    the COLORSELECT syntax!)		;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the band ID			;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
     RET			       ;;  statement.				;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  PUSH	ES			       ;; We got a band id........		;AN000;
  PUSH	DI			       ;;					;AN000;
				       ;;					;AN000;
  LES	DI,DWORD PTR RESULT_VAL        ;; Get pointer to the parsed band id	;AN000;
 .IF <<BYTE PTR ES:[DI+1]> NE 0>       ;; Make sure the band id is only 	;AN000;
     OR  STMT_ERROR,INVALID	       ;;  one byte long			;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  BL,NUM_BANDS		       ;;					;AN000;
  XOR  BH,BH			       ;;					;AN000;
 .IF <BX EQ MAX_BANDS> THEN	       ;; Watch out for too many COLORSELECTs	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     SHL  BX,1			       ;; calc index to store band in value list;AN000;
     MOV  AL,ES:[DI]		       ;; get BAND ID FROM PARSEr		;AN000;
     MOV  BAND_VAL_LIST[BX],AL	       ;;					;AN000;
     INC  NUM_BANDS		       ;; bump number of bands			;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  POP  DI			       ;;					;AN000;
  POP  ES			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,OFFSET COLORSELECT_P1        ;; Switch to numeric positional parm!!!	;AN000;
  MOV  CS_POSITIONAL,AX 	       ;;					;AN000;
  MOV  CS_NUM_REQ,0		       ;; Change to 0 required parameters	;AN000;
  XOR  DX,DX			       ;; PARSE the sequence of escape bytes	;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If esc byte is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a byte to the sequence		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,SEQ_LENGTH_PTR    ;;					;AN000;
	     INC  byte ptr [BP+DI]     ;; Bump number of bytes in sequence	;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL        ;; Get esc byte from result buffer	;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORSELECT  ENDP 	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_COLORPRINT								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
COLORPRINT_PARSE_PARMS	LABEL WORD    ;; Parser control blocks			;AN000;
	    DW	 COLORPRINT_P	      ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
COLORPRINT_P	  LABEL BYTE	       ;;					;AN000;
	      DB   3,4		       ;; Required,MAX				;AN000;
	      DW   COLORPRINT_P0       ;; Numeric: Red value			;AN000;
	      DW   COLORPRINT_P0       ;; Green value				;AN000;
	      DW   COLORPRINT_P0       ;; Blue value				;AN000;
	      DW   COLORPRINT_P1       ;; Band ID ... REPEATING 		;AN000;
	      DB   0		       ;; # Switches				;AN000;
	      DB   0		       ;; # keywords				;AN000;
				       ;;					;AN000;
COLORPRINT_P0  DW   8000H	       ;; Numeric - RGB value			;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORPRINT_P0V        ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORPRINT_P0V	 DB   1 	       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,63		       ;; range 0..63				;AN000;
				       ;;					;AN000;
COLORPRINT_P1  DW   2001H	       ;; sTRING - Band ID			;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORPRINT_P1V        ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORPRINT_P1V	  DB   3	       ;; # of value lists			;AN000;
	    DB	 0		       ;; 0 - no range numerics 		;AN000;
	    DB	 0		       ;; 0 - no actual numerics		;AN000;
NUM_BANDS   DB	 0		       ;; number of band values 		;AN000;
	    DB	 01H		       ;; tag: TAGS ARE BAND MASKS		;AN000;
	    DW	 BAND_PTR_1	       ;; ptr					;AN000;
	    DB	 02H		       ;; tag					;AN000;
	    DW	 BAND_PTR_2	       ;; ptr					;AN000;
	    DB	 04H		       ;; tag					;AN000;
	    DW	 BAND_PTR_3	       ;; ptr					;AN000;
	    DB	 08H		       ;; tag					;AN000;
	    DW	 BAND_PTR_4	       ;; ptr					;AN000;
	    DB	 10H		       ;; tag					;AN000;
	    DW	 BAND_PTR_5	       ;; ptr					;AN000;
	    DB	 20H		       ;; tag					;AN000;
	    DW	 BAND_PTR_6	       ;; ptr					;AN000;
	    DB	 40H		       ;; tag					;AN000;
	    DW	 BAND_PTR_7	       ;; ptr					;AN000;
	    DB	 80H		       ;; tag					;AN000;
	    DW	 BAND_PTR_8	       ;; ptr					;AN000;
				       ;;					;AN000;
MAX_BANDS   EQU  8		       ;;					;AN000;
				       ;;					;AN000;
BAND_VAL_LIST  LABEL BYTE	       ;;					;AN000;
BAND_PTR_1  DB	 ?,0		       ;;					;AN000;
BAND_PTR_2  DB	 ?,0		       ;;					;AN000;
BAND_PTR_3  DB	 ?,0		       ;;					;AN000;
BAND_PTR_4  DB	 ?,0		       ;;					;AN000;
BAND_PTR_5  DB	 ?,0		       ;;					;AN000;
BAND_PTR_6  DB	 ?,0		       ;;					;AN000;
BAND_PTR_7  DB	 ?,0		       ;;					;AN000;
BAND_PTR_8  DB	 ?,0		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORPRINT  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,COLP		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;; PRINTER  statemnet must have been	;AN000;
     OR  STMT_ERROR,MISSING	       ;;  processed				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE AND DISP>	       ;; DISPLAYMODE stmts			;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  should NOT have been processed	;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND COLP>        ;; Check for a previous group of 	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  COLORPRINTS within this PTD		;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_PRINTER_TYPE,COLOR	       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND COLP>        ;; If first COLORPRINT...		;AN000;
     .IF <BUILD_STATE EQ YES>	       ;; Update count and pointer in the	;AN000;
	 MOV  AX,BLOCK_END	       ;;  Shared Data Area header		;AN000;
	 MOV  [BP].COLORPRINT_PTR,AX   ;; Set pointer to COLORPRINT info	;AN000;
	 MOV  [BP].PRINTER_TYPE,COLOR  ;;					;AN000;
	 MOV  [BP].NUM_PRT_COLOR,0     ;; Init NUMBER OF COLORPRINTS		;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     INC  [BP].NUM_PRT_COLOR	       ;; Inc number of selects 		;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,COLP		       ;; Indicate found			;AN000;
 .IF <PREV_STMT NE COLP> THEN	       ;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for COLORPRINT		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV	AX,BLOCK_END		       ;; Start a new block			;AN000;
  MOV	BLOCK_START,AX		       ;;					;AN000;
  MOV	AX,SIZE COLORPRINT_STR	       ;; Make room for COLORPRINT info 	;AN000;
  CALL	GROW_SHARED_DATA	       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET COLORPRINT_PARSE_PARMS  ;; parse parms 			;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the RED value			;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 PUSH  DI		       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;; Store RED value in COLORPRINT info	;AN000;
	 MOV  [BP+DI].RED,AL	       ;;					;AN000;
	 POP  DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the GREEN value 		;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 PUSH  DI		       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;; Store GREEN value in COLORPRINT info	;AN000;
	 MOV  [BP+DI].GREEN,AL	       ;;					;AN000;
	 POP  DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the BLUE value			;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 PUSH  DI		       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;; Store BLUE value in COLORPRINT info	;AN000;
	 MOV  [BP+DI].BLUE,AL	       ;;					;AN000;
	 POP  DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     PUSH  DI			       ;;					;AN000;
     MOV   DI,BLOCK_START	       ;;					;AN000;
     MOV   [BP+DI].SELECT_MASK,0       ;; Initialize band select mask		;AN000;
     POP   DI			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  XOR  DX,DX			       ;; For each band found "OR" the item     ;AN000;
 .REPEAT			       ;;  tag into the select mask		;AN000;
    MOV  CX,3			       ;; Avoid getting too many parms error	;AN000;
    CALL SYSPARSE		       ;;  from parser				;AN000;
   .IF <AX EQ 0>		       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	  PUSH	DI		       ;;					;AN000;
	  MOV	DI,BLOCK_START	       ;;					;AN000;
	  MOV	AL,RESULT_TAG	       ;;					;AN000;
	  OR	[BP+DI].SELECT_MASK,AL ;; OR the mask for this band into the	;AN000;
				       ;;  select mask for this color		;AN000;
	  POP	DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORPRINT  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_DARKADJUST								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
DARKADJUST_PARSE_PARMS	LABEL WORD    ;; Parser control blocks			;AN000;
	    DW	 DARKADJUST_P	      ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
DARKADJUST_P	  LABEL BYTE	       ;;					;AN000;
	      DB   1,1		       ;; Required,MAX				;AN000;
	      DW   DARKADJUST_P0       ;; Numeric: adjust value 		;AN000;
	      DB   0		       ;; # Switches				;AN000;
	      DB   0		       ;; # keywords				;AN000;
				       ;;					;AN000;
DARKADJUST_P0  DW   4000H	       ;; Signed Numeric - adjust value 	;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 DARKADJUST_P0V        ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
DARKADJUST_P0V	 DB   1 	       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 -63,63 	       ;; range -63,63				;AN000;
;;;;***********************************;;					;AN000;
				       ;;					;AN000;
										;AN000;
PARSE_DARKADJUST  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,DARK		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;; PRINTER  statemnet must have been	;AN000;
     OR  STMT_ERROR,MISSING	       ;;  processed				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,DARK		       ;; Indicate found			;AN000;
				       ;; Terminate any preceeding groups	;AN000;
  MOV  AX,PREV_STMT		       ;;					;AN000;
  OR   GROUPS_DONE,AX		       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET DARKADJUST_PARSE_PARMS  ;; parse parms 			;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the ADJUST VALUE		;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;;					;AN000;
	 MOV  [BP].DARKADJUST_VALUE,AL ;;					;AN000;
     .ENDIF			       ;;					;AN000;
      CALL SYSPARSE		       ;; CHECK FOR EXTRA PARMS 		;AN000;
     .IF <AX NE -1>		       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_DARKADJUST  ENDP		       ;;					;AN000;
										;AN000;
LIMIT	LABEL NEAR		       ;;					;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grload.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I added an entry in the VERB_JMP_TAB and the equate DEF to 
;**                handle the new statement DEFINE.  I also made the new variable
;**                DATA_TYPE have the default of DATA_COL in the procedure
;**                LOAD_PROFILE, so the default assumes IBM type printers.
;**  
;**  DOCUMENTATION NOTES:  This version of GRLOAD.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Profile Load Modules		;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                     
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE' BYTE     ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
	INCLUDE GRSHAR.STR	       ;;					;AN000;
	INCLUDE GRPARSE.EXT	       ;;					;AN000;
	INCLUDE GRLOAD2.EXT	       ;;					;AN000;
	INCLUDE GRLOAD3.EXT	       ;;					;AN000;
	INCLUDE GRMSG.EQU	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC  LOAD_PROFILE 							;AN000;
   PUBLIC  GROW_SHARED_DATA							;AN000;
   PUBLIC  BLOCK_START								;AN000;
   PUBLIC  BLOCK_END								;AN000;
   PUBLIC  FIRST_BLOCK								;AN000;
   PUBLIC  MAX_BLOCK_END							;AN000;
   PUBLIC  GROUPS_DONE								;AN000;
   PUBLIC  STMTS_DONE								;AN000;
   PUBLIC  STMTS_DONE								;AN000;
   PUBLIC  PTD_FOUND								;AN000;
   PUBLIC  BUILD_STATE								;AN000;
   PUBLIC  STMT_ERROR								;AN000;
   PUBLIC  FILE_ERROR								;AN000;
   PUBLIC  PARSE_ERROR								;AN000;
   PUBLIC  END_OF_FILE								;AN000;
   PUBLIC  MEM_OVERFLOW 							;AN000;
   PUBLIC  STMT_BUFFER								;AN000;
   PUBLIC  CUR_STMT								;AN000;
   PUBLIC  PREV_STMT								;AN000;
   PUBLIC  PRT_BOX_ERROR							;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Profile Load Variables							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
NO	      EQU   0		       ;;					;AN000;
YES	      EQU   1		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   LOAD_PROFILE								;AN000;
;;										;AN000;
;; Input Parameters:								;AN000;
;;   DS,ES,SS - points to our transient segment 				;AN000;
;;										;AN000;
;; Output Parameters:								;AN000;
;;   Temporary Shared Data Area 						;AN000;
;;   Carry flag set if errors in profile.					;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Shared Data Area								;AN000;
;;   Profile Load Variables							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Build the profile information in the Temporary Shared Data Area.		;AN000;
;;   The information will be built for the printer type parsed off		;AN000;
;;   the command line.	ALL Printer Type Descriptions will be			;AN000;
;;   parsed to issue error messages and determine the maximum			;AN000;
;;   amount of resident memory required for initial load.			;AN000;
;;   The Shared Data Area begins with a fixed length section			;AN000;
;;   and then has several variable length sections.  PROFILE_BUILD_PTR		;AN000;
;;   is used to build the variable length sections by serving			;AN000;
;;   as a running pointer to the sections as they are built.			;AN000;
;;										;AN000;
;; Register Usage:								;AN000;
;;   BP - points to beginning of Temp Shared Data				;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   GRAPHICS_INSTALL								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   PARSE_PRINTER, PARSE_DISPLAYMODE, PARSE_SETUP, PARSE_RESTORE		;AN000;
;;   PARSE_PRINTBOX, PARSE_GRAPHICS, PARSE_COLORSELECT, 			;AN000;
;;   PARSE_COLORPRINT, GET_STATEMENT						;AN000;
;;   SYSPARSE									;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   IF profile path not specified  THEN					;AN000;
;;	PROFILE_PATH := "GRAPHICS.PRO"  /* Current directory */                 ;AN000;
;;	Open profile using PROFILE_PATH 					;AN000;
;;	IF error during open THEN						;AN000;
;;	   PROFILE_PATH := ARG(V0) with "GRAPHICS.COM" replaced                 ;AN000;
;;	     by "GRAPHICS.PRO"                                                  ;AN000;
;;	   Open profile using PROFILE_PATH					;AN000;
;;	   IF error during open THEN						;AN000;
;;	      Issue "Cannot find profile" msg                                   ;AN000;
;;	      Set carry flag							;AN000;
;;	      RETURN								;AN000;
;;	   ENDIF								;AN000;
;;	ENDIF									;AN000;
;;   ELSE									;AN000;
;;	Open profile using specified path					;AN000;
;;	IF error during open THEN						;AN000;
;;	   Issue "Cannot find profile" msg                                      ;AN000;
;;	   Set carry flag							;AN000;
;;	   RETURN								;AN000;
;;	ENDIF									;AN000;
;;   ENDIF									;AN000;
;;   /* don't start building until we find our printer type*/                   ;AN000;
;;   PARSE_MODE := NOBUILD							;AN000;
;;   MAX_BUILD_PTR := 0 							;AN000;
;;   CALL GROW_SHARED_DATA(PROFILE-BUILD_PTR,size of FIXED PART 		;AN000;
;;     of Shared Data Area)							;AN000;
;;   WHILE (not end of file) AND (no I/O error) DO				;AN000;
;;	CALL GET_STATEMENT							;AN000;
;;	IF I/O error THEN							;AN000;
;;	   Issue error message							;AN000;
;;	ELSE									;AN000;
;;	   CALL SYSPARSE to parse the statement verb				;AN000;
;;	   IF verb found THEN							;AN000;
;;	      IF invalid verb THEN						;AN000;
;;		 Issue error message						;AN000;
;;		 PARSE_MODE := ERROR						;AN000;
;;	      ELSE								;AN000;
;;		 CASE statement verb						;AN000;
;;		    PRINTER:							;AN000;
;;		       CALL PARSE_PRINTER					;AN000;
;;		    DISPLAYMODE:						;AN000;
;;		       CALL PARSE_DISPLAYMODE					;AN000;
;;		    PRINTBOX:							;AN000;
;;		       CALL PARSE_PRINTBOX					;AN000;
;;		    SETUP:							;AN000;
;;		       CALL PARSE_SETUP 					;AN000;
;;		    RESTORE:							;AN000;
;;		       CALL PARSE_RESTORE					;AN000;
;;		    GRAPHICS:							;AN000;
;;		       CALL PARSE_GRAPHICS					;AN000;
;;		    COLORPRINT: 						;AN000;
;;		       CALL PARSE_COLORPRINT					;AN000;
;;		    COLORSELECT:						;AN000;
;;		       CALL PARSE_COLORSELECT					;AN000;
;;		 ENDCASE							;AN000;
;;		 IF error on statement THEN					;AN000;
;;		    IF OVERFLOW bit set in RETURN_CODE THEN			;AN000;
;;		       Issue "Insufficient memory" message                      ;AN000;
;;		       RETURN to caller 					;AN000;
;;		    ELSE							;AN000;
;;		       IF MISSING bit set in RETURN_CODE THEN			;AN000;
;;			  Issue "required statement missing" message            ;AN000;
;;		       ENDIF							;AN000;
;;		       IF INVALID bit set in RETURN_CODE THEN			;AN000;
;;			  Issue "statement invalid" message                     ;AN000;
;;		       ENDIF							;AN000;
;;		       IF SEQUENCE bit set in RETURN_CODE THEN			;AN000;
;;			  Issue "out of sequence" message                       ;AN000;
;;		       ENDIF							;AN000;
;;		       display the statement in error				;AN000;
;;		    ENDIF							;AN000;
;;		    PARSE_MODE := ERROR 					;AN000;
;;		 ENDIF								;AN000;
;;	      ENDIF								;AN000;
;;	   ENDIF								;AN000;
;;	ENDIF									;AN000;
;;   ENDWHILE									;AN000;
;;										;AN000;
;;   /* Check length of last PTD */						;AN000;
;;   IF PROFILE_BUILD_PTR > MAX_BUILD_PTR THEN					;AN000;
;;	MAX_BUILD_PTR := PROFILE_BUILD_PTR					;AN000;
;;   ENDIF									;AN000;
;;										;AN000;
;;   /* Make sure all required statements were in previous */			;AN000;
;;   /* Printer Type Description */						;AN000;
;;   /* Must have completed PRINTER, DISPLAYMODE, PRINTBOX and */		;AN000;
;;   /* GRAPHICS statements */							;AN000;
;;   IF PRT+DISP+BOX+GR bits not all set in STMTS_DONE THEN			;AN000;
;;	Issue "required statement missing" message                              ;AN000;
;;	Display "END OF FILE."                                                  ;AN000;
;;   ENDIF									;AN000;
;;										;AN000;
;;   IF errors during build THEN						;AN000;
;;	set carry flag								;AN000;
;;   ELSE									;AN000;
;;	SD_TOTAL_SIZE := MAX_BUILD_PTR - TEMP_SHARED_DATA_PTR			;AN000;
;;   ENDIF									;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
FILE_NOT_FOUND	EQU  2		       ;; DOS Int21H error codes		;AN000;
PATH_NOT_FOUND	EQU  3		       ;;					;AN000;
				       ;;					;AN000;
SUBLIST     LABEL  BYTE 	       ;; Message substituion list for stmt #	;AN000;
	    DB	11		       ;; sublist size				;AN000;
	    DB	0		       ;;					;AN000;
	    DW	STMT_NUM	       ;; \ Dword pointer to item		;AN000;
SUBLIST_SEG DW	?		       ;; /					;AN000;
	    DB	1		       ;; Substitution #			;AN000;
;; Flag format	a0sstttt	       ;;					;AN000;
	    DB	00100001B	       ;; Unsigned binary word - left align	;AN000;
;;;;	    DB	00000000B	       ;; charcater				;AN000;
	    DB	0		       ;; max field width			;AN000;
	    DB	1		       ;; min width width			;AN000;
	    DB	' '                    ;; pad characeter                        ;AN000;
				       ;;					;AN000;
STMT_NUM    DW	0		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
FILE_ERROR  DB	0		       ;; Error opening or reading PROFILE	;AN000;
PARSE_ERROR DB	0		       ;; Syntax errors in PROFILE		;AN000;
END_OF_FILE	DB  0		       ;; 1 if end of file			;AN000;
MEM_OVERFLOW  DB  0		       ;; 1 if insufficient memory		;AN000;
				       ;;					;AN000;
STMT_ERROR  DB	0		       ;; Error flag for individual stmt errors ;AN000;
MISSING     EQU 1		       ;; Required statement missing		;AN000;
INVALID     EQU 2		       ;; Invalid statement format		;AN000;
SEQUENCE    EQU 4		       ;; Statement out of sequence		;AN000;
				       ;;					;AN000;
DEFAULT_PATH	  DB "GRAPHICS.PRO",0  ;;                                       ;AN000;
BUFFER	    DB	64 DUP("$")            ;;                                       ;AN000;
				       ;;					;AN000;
HANDLE	    DW	0		       ;; Profile handle			;AN000;
				       ;;					;AN000;
BUILD_STATE DB	0		       ;; 1 if we are currently building	;AN000;
				       ;;  data.  0 means syntax checking	;AN000;
				       ;;   only				;AN000;
				       ;;					;AN000;
				       ;; Keep track of whether this PTD	;AN000;
				       ;;  matches the type requested		;AN000;
PTD_FOUND   DB	0		       ;; Values are NO (0), YES (1) and	;AN000;
PROCESSED   EQU 2		       ;;  PROCESSED (2)			;AN000;
				       ;;					;AN000;
VERB	    DB	0		       ;; PTR into VERB_JMP_TAB 		;AN000;
				       ;;					;AN000;
VERB_JMP_TAB  LABEL WORD	       ;;					;AN000;
	DW  OFFSET PARSE_PRINTER       ;;					;AN000;
	DW  OFFSET PARSE_DISPLAYMODE   ;;					;AN000;
	DW  OFFSET PARSE_PRINTBOX      ;;					;AN000;
	DW  OFFSET PARSE_SETUP	       ;;					;AN000;
	DW  OFFSET PARSE_RESTORE       ;;					;AN000;
	DW  OFFSET PARSE_GRAPHICS      ;;					;AN000;
	DW  OFFSET PARSE_COLORPRINT    ;;					;AN000;
	DW  OFFSET PARSE_COLORSELECT   ;;					;AN000;
	DW  OFFSET PARSE_DARKADJUST    ;;					;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added the following so that LOAD_PROFILE will parse the
;               DEFINE statement.
;
        DW  OFFSET PARSE_DEFINE         ;
;/\  ~~mda(001) ----------------------------------------------------------
				       ;;					;AN000;
STMTS_DONE   DW  0		       ;;					;AN000;
GROUPS_DONE  DW  0		       ;;					;AN000;
PREV_STMT    DW  0		       ;;					;AN000;
CUR_STMT     DW  0		       ;;					;AN000;
				       ;;					;AN000;
PRT	EQU  1			       ;; Bit masks for STMTS_DONE and		;AN000;
DISP	EQU  2			       ;;  GROUPS_DONE.  There is one		;AN000;
BOX	EQU  4			       ;;   bit for each statement except	;AN000;
GR	EQU  8			       ;;    DARKADJUST 			;AN000;
SET	EQU  10H		       ;;					;AN000;
REST	EQU  20H		       ;;					;AN000;
COLS	EQU  40H		       ;;					;AN000;
COLP	EQU  80H		       ;;					;AN000;
DARK	EQU  100H		       ;;					;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added the following for the DEFINE statement.
;
DEF     EQU  200H
;/\  ~~mda(001) ----------------------------------------------------------
				       ;;					;AN000;
BLOCK_START  DW  ?		       ;; Extents of the variable size block	;AN000;
BLOCK_END    DW  ?		       ;;  currently being built		;AN000;
				       ;; These are relative to the		;AN000;
				       ;;  start of the Shared Data Area	;AN000;
				       ;;   so the area can be relocated	;AN000;
MAX_BLOCK_END	DW  0		       ;; End of largest PTD contained		;AN000;
				       ;;  in profile				;AN000;
FIRST_BLOCK  DW  ?		       ;; Pointer to first variable block	;AN000;
				       ;;  (end of fixed part)			;AN000;
PRT_BOX_ERROR  DB  0		       ;;					;AN000;
				       ;;					;AN000;
LOAD_PROFILE  PROC NEAR 	       ;;					;AN000;
				       ;;					;AN000;
  PUSH	CS			       ;;					;AN000;
  POP	SUBLIST_SEG		       ;; setup segment for message sublist	;AN000;
				       ;;					;AN000;
  CALL OPEN_FILE		       ;;					;AN000;
 .IF <FILE_ERROR EQ YES>	       ;; Check for error during open		;AN000;
     STC			       ;;					;AN000;
     RET			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  BP,TEMP_SHARED_DATA_PTR	       ;; BP points to START of Shared Data	;AN000;
  MOV  AX,SIZE SHARED_DATA_AREA_STR    ;; size of fixed part of Shared Data	;AN000;
  MOV  BLOCK_END,0		       ;; Initialize BLOCK_START,BLOCK_END	;AN000;
  MOV  [BP].DARKADJUST_VALUE,0	       ;; Init some values in the fixed 	;AN000;
  MOV  [BP].NUM_PRT_COLOR,0	       ;;  area 				;AN000;
  MOV  [BP].COLORPRINT_PTR,-1	       ;;					;AN000;
  MOV  [BP].NUM_PRT_BANDS,0	       ;;					;AN000;
  MOV  [BP].COLORSELECT_PTR,-1	       ;;					;AN000;
  MOV  [BP].PRINTER_TYPE,BLACK_WHITE   ;;					;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Make the default DATA_TYPE be DATA_COL for the IBM printers.
;
  MOV [BP].DATA_TYPE,DATA_COL           ;
;/\  ~~mda(001) ----------------------------------------------------------
  CALL GROW_SHARED_DATA 	       ;;  to the first byte after the		;AN000;
				       ;;   fixed part of Shared Data		;AN000;
     MOV  AX,BLOCK_END		       ;; Variable size data will be built	;AN000;
     MOV  BLOCK_START,AX	       ;;  starting at BLOCK_START		;AN000;
     MOV  FIRST_BLOCK,AX	       ;; Save start of variable data		;AN000;
				       ;;					;AN000;
     MOV  SI,BUFFER_PTR 	       ;; Set up SI for GET_BYTE		;AN000;
     CALL GET_BYTE		       ;; Get first byte from file		;AN000;
     MOV  NEXT_BYTE,AL		       ;;  and store it 			;AN000;
     MOV  BUFFER_PTR,SI 	       ;; Save SI for next GET_BYTE		;AN000;
    .WHILE <END_OF_FILE EQ NO> AND     ;; Keep parsing until end of file or	;AN000;
    .WHILE <FILE_ERROR EQ NO>	       ;;  file error occurs			;AN000;
       MOV STMT_ERROR,0 	       ;; Clear parse error flags		;AN000;
       CALL GET_STATEMENT	       ;; Get next profile statement		;AN000;
       INC  STMT_NUM		       ;;					;AN000;
      .IF NC			       ;; Carry flag set if get unsuccessful	;AN000;
	  CALL PARSE_VERB	       ;; Index into verb jump table returned	;AN000;
				       ;;  in BX				;AN000;
	 .IF <AX EQ 0> THEN	       ;; AX=0 if there is a recognized 	;AN000;
	    MOV  AX,CUR_STMT	       ;;					;AN000;
	    MOV  PREV_STMT,AX	       ;; Save last statement verb		;AN000;
	    CALL VERB_JMP_TAB[BX]      ;;  statement to parse			;AN000;
	 .ELSEIF <AX NE -1> THEN       ;;					;AN000;
	    OR	 STMT_ERROR,INVALID    ;;					;AN000;
	    MOV  PARSE_ERROR,YES       ;;					;AN000;
	    MOV  BUILD_STATE,NO        ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	 .IF <STMT_ERROR NE 0>	       ;; An error was detected 		;AN000;
	    CALL SHOW_PARSE_ERROR      ;;					;AN000;
	    MOV PARSE_ERROR,YES        ;;					;AN000;
	    MOV STMT_ERROR,0	       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
    .ENDWHILE			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE  AND PRT>	       ;; Must have at least one PRINTER	;AN000;
     CALL TERMINATE_DISPLAYMODE        ;; Terminate the last PRINTER and	;AN000;
     CALL TERMINATE_PRINTER	       ;;  DISPLAYMODE sections 		;AN000;
 .ELSE				       ;;					;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
 .IF <STMT_ERROR NE 0>		       ;;					;AN000;
     CALL  SHOW_PARSE_ERROR	       ;; Issue Profile syntax messages 	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,3E00H 		       ;; Close the file			;AN000;
  MOV  BX,HANDLE		       ;;					;AN000;
  INT  21H			       ;;					;AN000;
				       ;;					;AN000;
 .IF <PARSE_ERROR EQ YES>	       ;;					;AN000;
      MOV  AX,SYNTAX_ERRORS	       ;; Issue "Syntax errors found in         ;AN000;
      MOV  CX,0 		       ;;  profile" message.                    ;AN000;
      CALL DISP_ERROR		       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <PTD_FOUND EQ NO>		       ;; Did we find the requested printer	;AN000;
      MOV  AX,INVALID_PRT	       ;;  type?  If not issue error		;AN000;
      MOV  CX,0 		       ;;  message.				;AN000;
      CALL DISP_ERROR		       ;;					;AN000;
      MOV  PARSE_ERROR,YES	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <PARSE_ERROR EQ YES> OR	       ;;					;AN000;
 .IF <PRT_BOX_ERROR EQ YES> OR	       ;;					;AN000;
 .IF <FILE_ERROR EQ YES>	       ;; Set carry flag if profile load	;AN000;
     STC			       ;;  was unsuccessful			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <MEM_OVERFLOW EQ YES>	       ;; Everthing else was OK BUT we ran	;AN000;
	.IF <INSTALLED EQ YES>	       ;;  out of memory!!!			;AN000;
	    MOV   AX,NB_FREE_BYTES     ;;					;AN000;
	   .IF <AX LT RESIDENT_SHARED_DATA_SIZE>				;AN000;
	       MOV   AX,NO_MEMORY      ;; We ran out of physical memory!	;AN000;
	   .ELSE		       ;;					;AN000;
	       MOV   AX,UNABLE_RELOAD  ;; Allocated shared data is too small	;AN000;
	   .ENDIF		       ;;					;AN000;
	.ELSE			       ;;					;AN000;
	    MOV   AX,NO_MEMORY	       ;; We ran out of physical memory 	;AN000;
	.ENDIF			       ;;					;AN000;
	 MOV   CX,0		       ;;					;AN000;
	 CALL  DISP_ERROR	       ;;					;AN000;
	 STC			       ;; Indicate unsuccessful 		;AN000;
    .ELSE			       ;;					;AN000;
	 MOV  AX,MAX_BLOCK_END	       ;; Extent of largest PRINTER section	;AN000;
	 MOV  [BP].SD_TOTAL_SIZE,AX    ;;  we parsed.				;AN000;
	 CLC			       ;; SUCCESSFUL LOAD!!!!			;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
LOAD_PROFILE  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   SHOW_PARSE_ERROR								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
CARRAIGE_RET   EQU  13		       ;;					;AN000;
LINE_FEED      EQU  10		       ;;					;AN000;
				       ;;					;AN000;
SHOW_PARSE_ERROR   PROC 	       ;;					;AN000;
				       ;;					;AN000;
  MOV  ERROR_DEVICE,STDOUT	       ;; profile syntax messages to STDOUT	;AN000;
				       ;;					;AN000;
 .IF <BIT STMT_ERROR AND MISSING>						;AN000;
    PUSH SI		    ;;							;AN000;
    MOV  AX,MISSING_STMT    ;;							;AN000;
    MOV  CX,1		    ;;							;AN000;
    MOV  SI,OFFSET SUBLIST  ;;							;AN000;
    CALL DISP_ERROR	    ;;							;AN000;
    POP  SI		    ;;							;AN000;
 .ENDIF 		    ;;							;AN000;
 .IF <BIT STMT_ERROR AND INVALID>						;AN000;
    PUSH SI		    ;;							;AN000;
    MOV  AX,INVALID_STMT    ;;							;AN000;
    MOV  CX,1									;AN000;
    MOV  SI,OFFSET SUBLIST  ;;							;AN000;
    CALL DISP_ERROR	    ;;							;AN000;
    POP  SI		    ;;							;AN000;
 .ENDIF 		    ;;							;AN000;
 .IF <BIT STMT_ERROR AND SEQUENCE>						;AN000;
    PUSH SI		    ;;							;AN000;
    MOV  AX,OUT_SEQ_STMT    ;;							;AN000;
    MOV  CX,1									;AN000;
    MOV  SI,OFFSET SUBLIST  ;;							;AN000;
    CALL DISP_ERROR	    ;;							;AN000;
    POP  SI		    ;;							;AN000;
 .ENDIF 		    ;;	                                                ;AN000;
				       ;;					;AN000;
  MOV  DI,STMT_END_INDEX  ;;							;AN000;
  MOV  STMT_BUFFER[DI],'$'           ;; For display                             ;AN000;
  MOV  AH,9			     ;; 					;AN000;
  MOV  DX,OFFSET STMT_BUFFER							;AN000;
  INT  21H			     ;; 					;AN000;
  MOV  DL,CARRIAGE_RET		     ;; 					;AN000;
  MOV  AH,2			     ;; 					;AN000;
  INT  21H			     ;; 					;AN000;
  MOV  DL,LINE_FEED		     ;; 					;AN000;
  MOV  AH,2			     ;; 					;AN000;
  INT  21H			     ;; 					;AN000;
				       ;;					;AN000;
  MOV  ERROR_DEVICE,STDERR	       ;; reset to STDERR			;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
SHOW_PARSE_ERROR   ENDP 	       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   OPEN_FILE									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
OPEN_FILE     PROC NEAR 	       ;;					;AN000;
				       ;;					;AN000;
 .IF <PROFILE_PATH NE 0>	       ;; If a path was specified then		;AN000;
     MOV  DX,OFFSET PROFILE_PATH       ;;  try and open it			;AN000;
     MOV  AX,3D00H		       ;;					;AN000;
     INT  21H			       ;; Open it				;AN000;
    .IF C			       ;; Open error if carry flag set		;AN000;
       .IF <AX EQ FILE_NOT_FOUND> OR   ;; Check for error other than		;AN000;
       .IF <AX EQ PATH_NOT_FOUND>      ;;  file not found			;AN000;
	   MOV	 AX,PROFILE_NOT_FOUND  ;;					;AN000;
	   MOV	 CX,0		       ;;					;AN000;
	   CALL  DISP_ERROR	       ;; Issue "File not found" common msg     ;AN000;
	   MOV	 FILE_ERROR,YES        ;;					;AN000;
       .ELSE			       ;;					;AN000;
	   CALL  FILE_ERROR_PROC       ;; Issue "Open error"                    ;AN000;
       .ENDIF			       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	MOV  HANDLE,AX		       ;;					;AN000;
    .ENDIF			       ;; File opened OK			;AN000;
 .ELSE				       ;; No path parameter			;AN000;
     MOV  DX,OFFSET DEFAULT_PATH       ;; Try and open "GRAPHICS.PRO"           ;AN000;
     MOV  AX,3D00H		       ;;					;AN000;
     INT  21H			       ;; Open it				;AN000;
    .IF C			       ;; Open error if carry flag set		;AN000;
       .IF <AX EQ FILE_NOT_FOUND> OR   ;; Check for file not found error	;AN000;
       .IF <AX EQ PATH_NOT_FOUND>      ;;					;AN000;
	   CALL COPY_ARGV0	       ;;					;AN000;
	   MOV	DX,OFFSET PROFILE_PATH ;; Try and open "GRAPHICS.PRO" in        ;AN000;
	   MOV	AX,3D00H	       ;;  ARGV0 directory			;AN000;
	   INT	21H		       ;;					;AN000;
	  .IF C 		       ;; Issue "File not found" common msg     ;AN000;
	     .IF <AX EQ FILE_NOT_FOUND> OR					;AN000;
	     .IF <AX EQ PATH_NOT_FOUND> 					;AN000;
		 MOV   AX,PROFILE_NOT_FOUND  ;; 				;AN000;
		 MOV   CX,0		     ;; 				;AN000;
		 CALL  DISP_ERROR	     ;; Issue "File not found"common MSG;AN000;
		 MOV   FILE_ERROR,YES	     ;; 				;AN000;
	     .ELSE		       ;;					;AN000;
		 CALL  FILE_ERROR_PROC ;; Issue "Open error"                    ;AN000;
	     .ENDIF		       ;;					;AN000;
	  .ELSE 		       ;;					;AN000;
	      MOV  HANDLE,AX	       ;;					;AN000;
	  .ENDIF		       ;; File opened OK			;AN000;
       .ELSE			       ;;					;AN000;
	   CALL  FILE_ERROR_PROC       ;; Issue "Open error"                    ;AN000;
       .ENDIF			       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	MOV  HANDLE,AX		       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
OPEN_FILE     ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   COPY_ARGV0 								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
COPY_ARGV0  PROC		       ;;					;AN000;
				       ;;					;AN000;
  PUSH	 ES			       ;;					;AN000;
  PUSH	 DI			       ;;					;AN000;
  PUSH	 SI			       ;;					;AN000;
				       ;;					;AN000;
  MOV	 DI,2CH 		       ;; Locate environment string		;AN000;
  MOV	 ES,[DI]		       ;;					;AN000;
  XOR	 SI,SI			       ;;					;AN000;
  .WHILE <<WORD PTR ES:[SI]> NE 0>     ;;					;AN000;
     INC   SI			       ;;					;AN000;
  .ENDWHILE			       ;;					;AN000;
  ADD	 SI,4			       ;;					;AN000;
  LEA	 DI,PROFILE_PATH	       ;; Move string to work area		;AN000;
  .REPEAT			       ;;					;AN000;
     MOV    AL,ES:[SI]		       ;;					;AN000;
     MOV    [DI],AL		       ;;					;AN000;
     INC    SI			       ;;					;AN000;
     INC    DI			       ;;					;AN000;
  .UNTIL <<BYTE PTR ES:[SI]> EQ 0>     ;;					;AN000;
  MOV	 BYTE PTR [DI],0	       ;;					;AN000;
  MOV	 BYTE PTR [DI]-3,"P"           ;; Change COM to PRO                     ;AN000;
  MOV	 BYTE PTR [DI]-2,"R"           ;;                                       ;AN000;
  MOV	 BYTE PTR [DI]-1,"O"           ;;                                       ;AN000;
				       ;;					;AN000;
  POP	    SI			       ;;					;AN000;
  POP	    DI			       ;;					;AN000;
  POP	    ES			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
COPY_ARGV0  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   FILE_ERROR_PROC								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
FILE_ERROR_PROC  PROC		       ;;					;AN000;
  MOV	AX,FILE_ERRORS		       ;;					;AN000;
  MOV	CX,0			       ;;					;AN000;
  CALL	DISP_ERROR		       ;;					;AN000;
  MOV	FILE_ERROR,YES		       ;;					;AN000;
  RET				       ;;					;AN000;
FILE_ERROR_PROC  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   GET_STATEMENT								;AN000;
;;										;AN000;
;; Input Parameters:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Output Parameters:								;AN000;
;;   PROFILE_LINE								;AN000;
;;   RETURN CODE : 0 - successfull read 					;AN000;
;;		 : 1 - end of file						;AN000;
;;		 : 2 - error during read					;AN000;
;;										;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Get a statement from the profile.						;AN000;
;;   The file read in 512 byte buffers and parsed into				;AN000;
;;   lines by the presence of a carriage return at the end of each line.	;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   LOAD_PROFILE								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   FOUND := FALSE								;AN000;
;;   RETURN_CODE := 0								;AN000;
;;   WHILE NOT FOUND DO 							;AN000;
;;	IF end of buffer THEN							;AN000;
;;	   Read next profile record into buffer 				;AN000;
;;	   IF successful read THEN						;AN000;
;;	      point to first byte in buffer					;AN000;
;;	   ELSE 								;AN000;
;;	      IF end of file THEN						;AN000;
;;		 Close profile							;AN000;
;;		 RETURN_CODE := 1						;AN000;
;;		 FOUND := TRUE							;AN000;
;;	      ELSE								;AN000;
;;		 RETURN_CODE := 2						;AN000;
;;		 FOUND := TRUE							;AN000;
;;	      ENDIF								;AN000;
;;	   ENDIF								;AN000;
;;	ENDIF									;AN000;
;;	copy byte to PROFILE_LINE						;AN000;
;;	IF byte in buffer is a CR THEN						;AN000;
;;	   FOUND := TRUE							;AN000;
;;	ENDIF									;AN000;
;;   ENDWHILE									;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
FOUND  DB   0			       ;;					;AN000;
				       ;;					;AN000;
CARRIAGE_RET	EQU 13		       ;;					;AN000;
LINE_FEED	EQU 10		       ;;					;AN000;
NEXT_BYTE	DB  0		       ;; Save area for byte just read		;AN000;
BUFFER_SIZE	EQU 512 	       ;;					;AN000;
FILE_BUFFER	DB  512 DUP(0)	       ;;					;AN000;
BUFFER_PTR	DW  512 	       ;;					;AN000;
BUFFER_END	DW  512 	       ;;					;AN000;
STMT_BUFFER	DB  255 DUP(0)	       ;;					;AN000;
		DB  ?		       ;; In case we have to insert a CR	;AN000;
		DB  ?		       ;;  and a LF				;AN000;
		DB  ?		       ;; Too put the "$" for displaying the    ;AN000;
				       ;;  line.				;AN000;
				       ;;					;AN000;
STMT_END_INDEX	DW  ?		       ;;					;AN000;
MAX_STMT_LEN	EQU 255 	       ;;					;AN000;
CR_FOUND	DB  0		       ;; 1 if we found a line terminator	;AN000;
				       ;;					;AN000;
GET_STATEMENT PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  FOUND,NO 		       ;;					;AN000;
  MOV  STMT_ERROR,0		       ;; Clear error flags			;AN000;
  XOR  DI,DI			       ;; Index for extracted statement 	;AN000;
  MOV  SI,BUFFER_PTR		       ;; Init file buffer ptr			;AN000;
				       ;;					;AN000;
  MOV  AL,NEXT_BYTE		       ;; Restore current byte			;AN000;
  MOV  CR_FOUND,NO		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
 .WHILE <FOUND EQ NO> AND	       ;; Keep parsing until we find a stmt	;AN000;
 .WHILE <FILE_ERROR EQ NO> AND	       ;;  or a file error occurs		;AN000;
 .WHILE <END_OF_FILE EQ NO>	       ;;   or we reach end of file		;AN000;
   .IF <CR_FOUND EQ YES>	       ;;					;AN000;
      .IF <AL EQ LINE_FEED>	       ;; Return the line feed as well		;AN000;
	 .IF <DI NA MAX_STMT_LEN>      ;; Truncate lines longer than MAX	;AN000;
	     MOV  STMT_BUFFER[DI],AL   ;;  MOVE TO statement buffer		;AN000;
	     INC  DI		       ;; Point to next byte in file buffr	;AN000;
	  .ELSE 		       ;;					;AN000;
	      OR   STMT_ERROR,INVALID  ;; Line has been truncated > ERROR	;AN000;
	      MOV  PARSE_ERROR,YES     ;;					;AN000;
	      MOV  BUILD_STATE,NO      ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  CALL GET_BYTE 	       ;; Get the first byte of next statement	;AN000;
      .ENDIF			       ;;					;AN000;
       MOV  FOUND,YES		       ;; Time to leave this WHILE		;AN000;
       MOV  NEXT_BYTE,AL	       ;; Save the byte we just read		;AN000;
   .ELSE			       ;;					;AN000;
      .IF <DI NA MAX_STMT_LEN>	       ;; Truncate lines longer than MAX	;AN000;
	  MOV  STMT_BUFFER[DI],AL      ;; move byte to statement buffer 	;AN000;
	  INC  DI		       ;; Point to next byte in file buffer	;AN000;
      .ELSE			       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; Line has been truncated > ERROR	;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
      .IF <AL EQ CARRIAGE_RET>	       ;; Found a line terminator		;AN000;
	  MOV  CR_FOUND,YES	       ;; Indicate carriage return found	;AN000;
      .ENDIF			       ;;  and go through once more to		;AN000;
       CALL GET_BYTE		       ;;   check for a line feed		;AN000;
   .ENDIF			       ;;					;AN000;
 .ENDWHILE			       ;;					;AN000;
				       ;;					;AN000;
 .IF <STMT_BUFFER[DI-1] NE CARRIAGE_RET> AND		 ;;			;AN000;
 .IF <STMT_BUFFER[DI-1] NE LINE_FEED>		      ;;			;AN000;
     MOV  STMT_BUFFER[DI],CARRIAGE_RET ;;					;AN000;
     MOV  STMT_BUFFER[DI+1],LINE_FEED  ;;					;AN000;
     INC  DI			       ;;					;AN000;
     INC  DI			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  MOV STMT_END_INDEX,DI 	       ;;					;AN000;
  MOV BUFFER_PTR,SI		       ;; Save buffer ptr for next time 	;AN000;
				       ;;					;AN000;
 .IF <END_OF_FILE EQ YES>	       ;;					;AN000;
     .IF <DI EQ 0>		       ;; Clear carry if we read something	;AN000;
	STC			       ;;  and no file error occured otherwise	;AN000;
     .ELSE			       ;;   set carry indicating unsuccessful	;AN000;
	CLC			       ;;    get.				;AN000;
     .ENDIF			       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <FILE_ERROR EQ YES>	       ;;					;AN000;
	 STC			       ;;					;AN000;
     .ELSE			       ;;					;AN000;
	 CLC			       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
GET_STATEMENT ENDP		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   GET_BYTE									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
GET_BYTE      PROC		       ;;					;AN000;
				       ;;					;AN000;
 .IF <SI EQ BUFFER_END> 	       ;; If buffer empty do another read	;AN000;
     MOV  AH,3FH		       ;;					;AN000;
     MOV  DX,OFFSET FILE_BUFFER        ;;					;AN000;
     MOV  CX,BUFFER_SIZE	       ;;					;AN000;
     MOV  BX,HANDLE		       ;;					;AN000;
     INT  21H			       ;;					;AN000;
    .IF C			       ;; Carry set by DOS if file error	;AN000;
	CALL FILE_ERROR_PROC	       ;;					;AN000;
    .ELSE			       ;;					;AN000;
       .IF <AX EQ 0>		       ;; End of file if AX=0			;AN000;
	   MOV	END_OF_FILE,YES        ;;					;AN000;
	   MOV	AH,3EH		       ;; Close the file			;AN000;
	   MOV	BX,HANDLE	       ;;					;AN000;
	   INT	21H		       ;;					;AN000;
       .ELSE			       ;;					;AN000;
	   MOV BUFFER_END,AX	       ;; Number of bytes read			;AN000;
	   XOR SI,SI		       ;; Buffer pointer := 0			;AN000;
       .ENDIF			       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <FILE_ERROR EQ YES> OR	       ;;					;AN000;
 .IF <END_OF_FILE EQ YES>	       ;;					;AN000;
     STC			       ;; Unsuccessful get			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <<FILE_BUFFER[SI]> EQ 1AH>	;; cHECK for EOF marker 		;AN000;
	MOV END_OF_FILE,YES	       ;;					;AN000;
	STC			       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	MOV  AL,FILE_BUFFER[SI] 	  ;; Return byte in AL			;AN000;
	INC  SI 			  ;;					;AN000;
	CLC				  ;; Successful get			;AN000;
    .ENDIF				  ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
GET_BYTE      ENDP		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   GROW_SHARED_DATA								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
GROW_SHARED_DATA  PROC		       ;;					;AN000;
  PUSH BX			       ;;					;AN000;
  ADD  BLOCK_END,AX		       ;; Grow the current block by AX		;AN000;
  MOV  BX,BLOCK_END		       ;;					;AN000;
 .IF <BX A NB_FREE_BYTES>	       ;; Check for overflow			;AN000;
     MOV  BUILD_STATE,NO	       ;; Stop building shared data		;AN000;
     MOV  MEM_OVERFLOW,YES	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  POP  BX			       ;;					;AN000;
  RET				       ;;					;AN000;
GROW_SHARED_DATA  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grpattrn.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Common modules			;AN000;
.xlist										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                               
;;										;AN000;
;; File Name:  GRPATTRN.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the grey patterns used by PRT_BW_APA for printing	;AN000;
;;	 on a Black and White printer.						;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	none									;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	GRPATTRN.STR	- Structures for patterns.				;AN000;
;;										;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;										;AN000;
;;	Called by PRT_BW_APA from file GRBWPRT.ASM				;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
.list										;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME		CS:CODE,DS:CODE 					;AN000;
INCLUDE GRPATTRN.STR								;AN000;
										;AN000;
PUBLIC	TAB_DIRECTORY								;AN000;
PUBLIC	TAB_DIR_NB_ENTRIES							;AN000;
PUBLIC	PAT_4X2 								;AN000;
PUBLIC	PAT_4X4 								;AN000;
PUBLIC	PAT_6X2 								;AN000;
PUBLIC	PAT_8X2 								;AN000;
PUBLIC	PAT_6X4 								;AN000;
PUBLIC	PAT_8X4 								;AN000;
PUBLIC	PAT_8X6 								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; PATTERN DIRECTORY:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
TAB_DIR_NB_ENTRIES DB 7 							;AN000;
TAB_DIRECTORY LABEL BYTE							;AN000;
; ENTRY = <OFFSET PATTERN TABLE, TABLE SIZE, BOX_W, BOX_H,			;AN000;
;	   NUNBER OF PATTERNS(INTENSITIES) >					;AN000;
	TAB_ENTRY <OFFSET PAT_4X2,-1,40,2,1,8 > 				;AN000;
	TAB_ENTRY <OFFSET PAT_4X4,-1,40,2,2,8 > 				;AN000;
	TAB_ENTRY <OFFSET PAT_6X2,-1,70,3,1,10> 				;AN000;
	TAB_ENTRY <OFFSET PAT_8X2,-1,108,4,1,12>				;AN000;
	TAB_ENTRY <OFFSET PAT_6X4,-1,119,3,2,17>				;AN000;
	TAB_ENTRY <OFFSET PAT_8X4,-1,162,4,2,18>				;AN000;
	TAB_ENTRY <OFFSET PAT_8X6,-1,171,4,3,19>				;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 4X2 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_4X2 LABEL BYTE								;AN000;
; PATTERN=<MAXIMUM INTENSITY, 1ST COLUMN (top is left bit), 2ND, 3RD, 4TH >	;AN000;
	    PAT_4X2_STR < 5,11B,11B,11B,11B>					;AN000;
	    PAT_4X2_STR <13,11B,10B,01B,11B>					;AN000;
	    PAT_4X2_STR <20,10B,11B,01B,10B>					;AN000;
	    PAT_4X2_STR <28,10B,01B,01B,10B>					;AN000;
	    PAT_4X2_STR <36,10B,00B,01B,10B>					;AN000;
	    PAT_4X2_STR <47,10B,00B,01B,00B>					;AN000;
	    PAT_4X2_STR <58,10B,00B,00B,00B>					;AN000;
	    PAT_4X2_STR <63,00B,00B,00B,00B>					;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 4X4 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_4X4 LABEL BYTE								;AN000;
; PATTERN=<MAXIMUM INTENSITY, 1ST COLUMN (top is left bit), 2ND, 3RD, 4TH >	;AN000;
	    PAT_4X4_STR < 5,1111B,1111B,1111B,1111B>				;AN000;
	    PAT_4X4_STR <13,1111B,1010B,0101B,1111B>				;AN000;
	    PAT_4X4_STR <20,1010B,1111B,0101B,1010B>				;AN000;
	    PAT_4X4_STR <28,1010B,0101B,0101B,1010B>				;AN000;
	    PAT_4X4_STR <36,1010B,0000B,0101B,1010B>				;AN000;
	    PAT_4X4_STR <47,1010B,0000B,0101B,0000B>				;AN000;
	    PAT_4X4_STR <58,1010B,0000B,0000B,0000B>				;AN000;
	    PAT_4X4_STR <63,0000B,0000B,0000B,0000B>				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 6X2 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_6X2 LABEL BYTE								;AN000;
	    PAT_6X2_STR < 3,11B,11B,11B,11B,11B,11B>				;AN000;
	    PAT_6X2_STR < 8,11B,11B,10B,11B,11B,01B>				;AN000;
	    PAT_6X2_STR <15,10B,01B,10B,11B,10B,01B>				;AN000;
	    PAT_6X2_STR <21,01B,10B,10B,01B,10B,10B>				;AN000;
	    PAT_6X2_STR <28,01B,10B,10B,01B,10B,00B>				;AN000;
	    PAT_6X2_STR <36,10B,01B,00B,10B,01B,00B>				;AN000;
	    PAT_6X2_STR <45,00B,10B,00B,01B,00B,10B>				;AN000;
	    PAT_6X2_STR <53,10B,00B,00B,01B,00B,00B>				;AN000;
	    PAT_6X2_STR <60,10B,00B,00B,00B,00B,00B>				;AN000;
	    PAT_6X2_STR <63,00B,00B,00B,00B,00B,00B>				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 8X2 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_8X2 LABEL BYTE								;AN000;
	    PAT_8X2_STR < 3,11B,11B,11B,11B,11B,11B,11B,11B>			;AN000;
	    PAT_8X2_STR < 9,11B,11B,10B,11B,11B,10B,11B,01B>			;AN000;
	    PAT_8X2_STR <15,10B,11B,01B,11B,10B,11B,00B,11B>			;AN000;
	    PAT_8X2_STR <21,10B,01B,11B,10B,01B,10B,01B,10B>			;AN000;
	    PAT_8X2_STR <27,10B,01B,01B,10B,10B,01B,01B,10B>			;AN000;
	    PAT_8X2_STR <33,00B,10B,01B,10B,00B,01B,10B,01B>			;AN000;
	    PAT_8X2_STR <39,10B,00B,10B,01B,00B,10B,00B,01B>			;AN000;
	    PAT_8X2_STR <45,10B,00B,01B,00B,10B,00B,01B,00B>			;AN000;
	    PAT_8X2_STR <51,10B,00B,00B,01B,00B,00B,10B,00B>			;AN000;
	    PAT_8X2_STR <56,10B,00B,00B,00B,01B,00B,00B,00B>			;AN000;
	    PAT_8X2_STR <61,10B,00B,00B,00B,00B,00B,00B,00B>			;AN000;
	    PAT_8X2_STR <63,00B,00B,00B,00B,00B,00B,00B,00B>			;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 6X4 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_6X4 LABEL BYTE								;AN000;
	    PAT_6X4_STR < 3,1111B,1111B,1111B,1111B,1111B,1111B>		;AN000;
	    PAT_6X4_STR < 8,1111B,1111B,1101B,1111B,1111B,1011B>		;AN000;
	    PAT_6X4_STR <13,1111B,1111B,0101B,1011B,1111B,1010B>		;AN000;
	    PAT_6X4_STR <16,0101B,1111B,0101B,1010B,0101B,1010B>		;AN000;
	    PAT_6X4_STR <20,0101B,1110B,0101B,1010B,0101B,1010B>		;AN000;
	    PAT_6X4_STR <24,1010B,0101B,1010B,0101B,0010B,0101B>		;AN000;
	    PAT_6X4_STR <28,1010B,0101B,1000B,0101B,0010B,0101B>		;AN000;
	    PAT_6X4_STR <32,1010B,0101B,1000B,1001B,0010B,0100B>		;AN000;
	    PAT_6X4_STR <37,1010B,0000B,1010B,0101B,0000B,0101B>		;AN000;
	    PAT_6X4_STR <40,0100B,0001B,1000B,0010B,1000B,0101B>		;AN000;
	    PAT_6X4_STR <45,0100B,0010B,1000B,0010B,0100B,0001B>		;AN000;
	    PAT_6X4_STR <49,1010B,0000B,1000B,0101B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <52,1010B,0000B,0000B,0101B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <55,0000B,1000B,0000B,0010B,0000B,0100B>		;AN000;
	    PAT_6X4_STR <58,1000B,0000B,0000B,0010B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <61,1000B,0000B,0000B,0000B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <63,0000B,0000B,0000B,0000B,0000B,0000B>		;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 8X4 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_8X4 LABEL BYTE								;AN000;
	    PAT_8X4_STR < 1,1111B,1111B,1111B,1111B,1111B,1111B,1111B,1111B>	;AN000;
	    PAT_8X4_STR < 4,1010B,1111B,1111B,1111B,1010B,1111B,1111B,1111B>	;AN000;
	    PAT_8X4_STR < 7,1010B,1111B,1101B,1111B,1010B,1111B,0111B,1111B>	;AN000;
	    PAT_8X4_STR <10,1010B,0111B,1110B,0101B,1010B,1101B,1011B,0101B>	;AN000;
	    PAT_8X4_STR <13,1001B,1110B,0110B,1001B,0110B,1011B,1001B,0110B>	;AN000;
	    PAT_8X4_STR <18,1010B,0101B,1110B,0101B,1010B,0101B,1010B,0101B>	;AN000;
	    PAT_8X4_STR <24,1010B,0101B,0101B,1010B,1010B,0101B,0101B,1010B>	;AN000;
	    PAT_8X4_STR <30,1010B,0101B,1010B,0000B,0101B,1010B,0101B,0000B>	;AN000;
	    PAT_8X4_STR <36,1010B,0000B,1010B,0101B,0000B,1010B,0000B,0101B>	;AN000;
	    PAT_8X4_STR <42,1010B,0000B,0101B,0000B,1010B,0000B,0101B,0000B>	;AN000;
	    PAT_8X4_STR <46,0010B,1000B,0000B,0010B,1000B,0001B,0100B,0001B>	;AN000;
	    PAT_8X4_STR <48,1010B,0000B,0101B,0000B,0000B,1010B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <50,0010B,0000B,1000B,0010B,0000B,0100B,0001B,0000B>	;AN000;
	    PAT_8X4_STR <53,1010B,0000B,0000B,0000B,0101B,0000B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <56,0000B,1000B,0000B,0000B,0100B,0000B,0000B,0010B>	;AN000;
	    PAT_8X4_STR <59,1000B,0000B,0000B,0000B,0010B,0000B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <62,1000B,0000B,0000B,0000B,0000B,0000B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <63,0000B,0000B,0000B,0000B,0000B,0000B,0000B,0000B>	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 8X6 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_8X6 LABEL BYTE								;AN000;
	  PAT_8X6_STR < 1,111111B,111111B,111111B,111111B,111111B,111111B,111111B,111111B>;AN000;
	  PAT_8X6_STR < 4,011011B,111111B,111111B,111111B,110110B,111111B,111111B,111111B>;AN000;
	  PAT_8X6_STR < 7,101010B,011111B,111111B,110101B,101010B,011111B,111111B,110101B>;AN000;
	  PAT_8X6_STR <10,101010B,010101B,111111B,101010B,010101B,101010B,111111B,010101B>;AN000;
	  PAT_8X6_STR <13,011011B,100100B,111011B,100100B,011011B,100100B,011111B,100100B>;AN000;
	  PAT_8X6_STR <17,101010B,010101B,101010B,010101B,101010B,010101B,101010B,010101B>;AN000;
	  PAT_8X6_STR <21,101010B,010101B,101010B,010101B,001010B,010101B,101010B,010101B>;AN000;
	  PAT_8X6_STR <25,010100B,101010B,010101B,001010B,100100B,010001B,101110B,000001B>;AN000;
	  PAT_8X6_STR <29,000000B,010101B,101010B,010101B,000000B,101010B,010101B,101010B>;AN000;
	  PAT_8X6_STR <33,010010B,100101B,011000B,100010B,001101B,100000B,001010B,100100B>;AN000;
	  PAT_8X6_STR <37,100100B,001010B,010000B,001001B,100010B,001101B,010000B,001010B>;AN000;
	  PAT_8X6_STR <41,100000B,010010B,100100B,000010B,101000B,000101B,010000B,001010B>;AN000;
	  PAT_8X6_STR <45,100010B,001000B,000010B,100000B,010100B,000001B,100100B,000000B>;AN000;
	  PAT_8X6_STR <49,101000B,000001B,000100B,010000B,000010B,100000B,001000B,000101B>;AN000;
	  PAT_8X6_STR <53,101010B,000000B,000000B,000000B,010101B,000000B,000000B,000000B>;AN000;
	  PAT_8X6_STR <57,000000B,010000B,000000B,000100B,000000B,100000B,000000B,000010B>;AN000;
	  PAT_8X6_STR <60,100000B,000000B,000000B,000000B,000100B,000000B,000000B,000000B>;AN000;
	  PAT_8X6_STR <62,100000B,000000B,000000B,000000B,000000B,000000B,000000B,000000B>;AN000;
	  PAT_8X6_STR <63,000000B,000000B,000000B,000000B,000000B,000000B,000000B,000000B>;AN000;
CODE	ENDS										  ;AN000;
	END										  ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grparms.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Command line parsing module	;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                   
;;										;AN000;
;; File Name:  GRPARMS.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;										;AN000;
;;	 This file contains modules for parsing the GRAPHICS.COM		;AN000;
;;	 command line; using the DOS PARSER.					;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;	 DOS 3.3 Message Retriever Interface Supplement. 			;AN000;
;;	 TUPPER I0 Document - PARSER HIGH LEVEL DESIGN REVIEW			;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 PARSE_PARMS	  - Parse the command line				;AN000;
;;	 GET_R		  - Get /R						;AN000;
;;	 GET_B		  - Get /B						;AN000;
;;	 GET_LCD	  - Get /LCD						;AN000;
;;	 GET_PRINTBOX	  - Get /PRINTBOX					;AN000;
;;	 GET_PROFILE	  - Get the profile path and file name			;AN000;
;;	 GET_TYPE	  - Get the printer type				;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRINST.EXT  - Externals for installation modules			;AN000;
;;	 GRPARSE.EXT - Externals for the DOS parser code			;AN000;
;;	 GRSHAR.STR  - Shared Data Area Structure				;AN000;
;;	 GRMSG.EQU   - Equates for GRAPHICS.COM error messages			;AN000;
;;	 STRUC.INC   - Macros for using structured assembly language		;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRINST.ASM: 						;AN000;
;;	      GRAPHICS_INSTALL - Main module for the installation of GRAPHICS	;AN000;
;;	 SYSPARSE - DOS system parser						;AN000;
;;	 SYSDISPMSG - DOS message retriever					;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME	CS:CODE,DS:CODE 						;AN000;

PARSE_PARMS PROC NEAR								;AN000;
	jmp	PARSE_PARMS_START						;AN000;
PUBLIC PARSE_PARMS								;AN000;

	EXTRN	ERROR_DEVICE: WORD	; grinst.asm

.XLIST										;AN000;
INCLUDE GRMSG.EQU		; Include GRAPHICS error messages equates	;AN000;
INCLUDE GRSHAR.STR		; Include the Shared data area structure	;AN000;
INCLUDE GRINST.EXT		; Include externals for the installation module ;AN000;
INCLUDE GRPARSE.EXT		; Include externals for the DOS parse code	;AN000;
INCLUDE STRUC.INC		; Include macros for using STRUCTURES		;AN000;
.LIST										;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PARSE_PARMS : PARSE THE COMMAND LINE PARAMETERS.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	DS,ES		= SEGMENT CONTAINING THE PROGRAM PREFIX SEGMENT ;AN000;(PSP)
;										;AN000;
;	OUTPUT: SWITCHES	= A bit mask in the shared data area indicating ;AN000;
;				  which command line switches are set.		;AN000;
;		PROFILE_PATH	= The profile file name and path (ASCIIZ string);AN000;
;		PRINTBOX_ID_PTR = Offset of the printbox id (ASCIIZ string)	;AN000;
;		PRINTER_TYPE_PARM = printer type (ASCIIZ string)		;AN000;
;		CARRY FLAG IS SET if an error occurred				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Call the DOS parser to parse the command line parameters 	;AN000;
; of the GRAPHICS  command line which is obtained from the PSP (Program Segment ;AN000;
; Prefix).									;AN000;
;										;AN000;
; The format of the command line is:						;AN000;
;										;AN000;
;										;AN000;
;	GRAPHICS  {prt_type {profile}}	 {/R}  {/B}  {[/LCD | /PRINTBOX:id]}	;AN000;
;										;AN000;
;	(All arguments are optional, /PRINTBOX can be spelled /PB.)		;AN000;
;										;AN000;
; If no printer type is specified then, a null pointer is returned.		;AN000;
; If no profile name is supplied then, a null string is returned.		;AN000;
; If "/LCD" is specified then, a pointer to the printbox id: "LCD" is returned. ;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
; Set addressibility to the command line parameters in the PSP			;AN000;
; CALL SYSPARSE       ; Call the system parser					;AN000;
; While not (End Of Line) AND no error						;AN000;
;   IF argument is the profile name						;AN000;
;   THEN Get the profile name							;AN000;
;   IF argument is the printbox switch						;AN000;
;   THEN Get the printbox id							;AN000;
;   IF argument is a /r 							;AN000;
;   THEN Get /r 								;AN000;
;   IF argument is /b								;AN000;
;   THEN Get /b 								;AN000;
;   IF argument /lcd								;AN000;
;   THEN Get /lcd								;AN000;
;   CALL SYSPARSE								;AN000;
; If error									;AN000;
; Then display the appropriate error message					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; BIT MASK INDICATING THE COMMAND LINE SWITCHES PARSED SO FAR:			;AN000;
;-------------------------------------------------------------------------------;AN000;
SWITCH_PARSED DB   0								;AN000;
GOT_R	      EQU  1			; Found /R				;AN000;
GOT_B	      EQU  2			; Found /B				;AN000;
GOT_LCD       EQU  4			; Found /LCD				;AN000;
GOT_PRINTBOX  EQU  8			; Found /PB:id or /PRINTBOX:id		;AN000;
										;AN000;
;===============================================================================;AN000;
;										;AN000;
; CONTROL BLOCK DEFINITIONS FOR THE PARSER:					;AN000;
;										;AN000;
;===============================================================================;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; PARMS INPUT BLOCK								;AN000;
;-------------------------------------------------------------------------------;AN000;
PARMS LABEL WORD								;AN000;
	DW	PARMSX			; Offset of parms extension block	;AN000;
	DB	0			; No delimiters to define		;AN000;
					;  or end of line markers.		;AN000;
										;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; PARMS EXTENSION BLOCK : Describe what's on the command line                   ;AN000;
;-------------------------------------------------------------------------------;AN000;
PARMSX	LABEL BYTE								;AN000;
	DB	0,2			; Max. 2 positional parameters		;AN000;
	DW	TYPE_CTL		; Offset of type control block		;AN000;
	DW	PROF_CTL		; Offset of profile control block	;AN000;
										;AN000;
	DB	5			; Max. 4 switch types			;AN000;
	DW	PRINTBOX_CTL		; Offset of control for Printbox	;AN000;
	DW	R_CTL			; Offset of control for /R		;AN000;
	DW	B_CTL			; Offset of control for /B		;AN000;
	DW	LCD_CTL 		; Offset of control for /LCD		;AN000;
	DW	?_CTL                   ; offset of control for /?
										;AN000;
	DB	0			; No keywords				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the printer type parameter:						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
TYPE_CTL LABEL	WORD								;AN000;
	DW	2001H		 ; Optional simple string			;AN000;
	DW	0002H		 ; Capitalize it				;AN000;
	DW	TYPE_RESULT	 ; Offset of result buffer for printer type	;AN000;
	DW	NO_VALUES	 ; No values (NOTE: The type returned is checked;AN000;
	DB	0		 ;		   for validity by LOAD_PROFILE);AN000;
										;AN000;
NO_VALUES	DB	0							;AN000;
										;AN000;
TYPE_RESULT	LABEL BYTE							;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Pointer to string found			;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of the PROFILE parameter: 				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
										;AN000;
PROF_CTL LABEL WORD								;AN000;
	DW	0201H		; File spec. - Optional 			;AN000;
	DW	0001h		; Capitalize					;AN000;
	DW	PROFILE_RESULT	; Offset of result buffer for Profile		;AN000;
	DW	NO_VALUES	; No values needed				;AN000;
	DB	0								;AN000;
										;AN000;
										;AN000;
PROFILE_RESULT	LABEL BYTE							;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of string				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of /R							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
R_CTL	LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	R_RESULT	; Offset of result buffer for a simple switch	;AN000;
	DW	NO_VALUES	; No values can be given with these switches.	;AN000;
	DB	1		; 1 name for this switch			;AN000;
	DB	"/R",0          ;   Reverse                                     ;AN000;
										;AN000;
R_RESULT LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;

;----------------------------------------------------------------------------
;			
; Describe the format of /?
;			
;----------------------------------------------------------------------------
?_CTL	LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	?_RESULT	; Offset of result buffer for a simple switch
	DW	NO_VALUES	; No values can be given with these switches.
	DB	1		; 1 name for this switch	
	DB	"/?",0   
										;AN000;
?_RESULT LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;

;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of /B							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
B_CTL	LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	B_RESULT	; Offset of result buffer for a simple switch	;AN000;
	DW	NO_VALUES	; No values can be given with these switches.	;AN000;
	DB	1		; 1 name allowed for this switch		;AN000;
	DB	"/B",0          ;   Background                                  ;AN000;
										;AN000;
B_RESULT LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of /LCD							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
LCD_CTL LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	LCD_RESULT	; Offset of result buffer for a /LCD		;AN000;
	DW	NO_VALUES	; No values can be given with these switches.	;AN000;
	DB	1		; 1 name:					;AN000;
	DB	"/LCD",0        ;  /LCD                                         ;AN000;
										;AN000;
LCD_RESULT  LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of the PRINTBOX switch:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINTBOX_CTL LABEL WORD 							;AN000;
	DW	2001H		; Optional simple string			;AN000;
	DW	0001H		; Capitalize					;AN000;
	DW	PRINTBOX_RESULT ; Offset of result buffer for Printbox		;AN000;
	DW	NO_VALUES	; Values will be validated when loading profile ;AN000;
	DB	2		; 2 synomym for this switch:			;AN000;
	DB	"/PRINTBOX",0   ;                                               ;AN000;
	DB	"/PB",0                                                         ;AN000;
										;AN000;
PRINTBOX_RESULT LABEL BYTE							;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;
										;AN000;
;===============================================================================;AN000;
;										;AN000;
; DOS "MESSAGE RETRIEVER" Substitution list control block:                      ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SUBLIST        LABEL DWORD		   ; List for substitution:		;AN000;
	       DB	11		   ; Size of this list			;AN000;
	       DB	0		   ; Reserved				;AN000;
SAVE_SI        DD	?		   ; Ptr to data item			;AN001;
	       DB	1		   ; Variable to be substitued: %1	;AN000;
	       DB	00010000B	   ; %1 is an ASCIIZ string left justifi;AN000;ed
	       DB	0		   ; Unlimited size for %1		;AN000;
	       DB	1		   ; Minimum size is 1 character	;AN000;
	       DB	" "                ; Delimiter is "space"               ;AN000;
										;AN000;
;===============================================================================;AN000;
;										;AN000;
; START OF EXECUTABLE CODE:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
										;AN000;
PARSE_PARMS_START:								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
	PUSH	ES								;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set up addressibility for the parser						;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	SI,81H			; DS:SI := Command line parameters	;AN000;
					;  to be parsed 			;AN000;
	PUSH	CS								;AN000;
	POP	ES								;AN000;
	LEA	DI,PARMS		; ES:DI := Parms control block		;AN000;
;(deleted ;AN001;) XOR DX,DX		; CX,DX must be zero for the		;AN000;
	XOR	CX,CX			; Initially, CX should be zero		;AN001;
	MOV	AX,0			; No error yet				;AN000;
;-------------------------------------------------------------------------------;AN000;
; Parse FIRST argument								;AN000;
;-------------------------------------------------------------------------------;AN000;
;(deleted ;AN001;) CALL SYSPARSE	; Get one argument from the command line;AN000;
	CALL	CALL_SYSPARSE		; Get one argument from the command line;AN001;
;(deleted ;AN001;) MOV BX,DX		; BX := Offset of result block		;AN000;
.WHILE <AX EQ RC_NO_ERROR>		; While there is no error		;AN000;
;-------------------------------------------------------------------------------;AN000;
; Get the argument:								;AN000;
;-------------------------------------------------------------------------------;AN000;
       .SELECT									;AN000;
       .WHEN <BX EQ <OFFSET ?_RESULT>>
          MOV	[ERROR_DEVICE], STDOUT       ; output to stdout
	  MOV	AX, MSG_OPTIONS_FIRST        ; number of first 'option' msg
	  XOR	CX, CX                       ; specify no subst
PRMORE:	  CALL  DISP_ERROR                   ; DISP_ERROR is a mistaken name
; in this case.  I use it because it is the existing routine for printing out
; messages, and it is named so because the only messages graphics would 
; display are error messages.  Hence disp_error writes out to STDERR.  I 
; could write another message-display interface to sysdispmsg, but this one 
; works fine, I just wanted to note that the name disp_error gives the wrong
; impression here.
	  INC	AX
	  CMP	AX, MSG_OPTIONS_LAST + 1     ; another msg to do
	  JB	PRMORE
          MOV	[ERROR_DEVICE], STDERR       ; set output back to stderr
	  STC                                ; pretend to have an error so
; that graphics now cleans up and goes home without further action
	  JMP   PPST
       .WHEN <BX EQ <OFFSET TYPE_RESULT>>					;AN000;
	  CALL	GET_TYPE							;AN000;
       .WHEN <BX EQ <OFFSET PROFILE_RESULT>>					;AN000;
	  CALL	GET_PROFILE_NAME						;AN000;
       .WHEN <BX EQ <OFFSET LCD_RESULT >>					;AN000;
	  CALL	GET_LCD 							;AN000;
       .WHEN <BX EQ <OFFSET R_RESULT>>						;AN000;
	  CALL	GET_REVERSE							;AN000;
       .WHEN <BX EQ <OFFSET B_RESULT>>						;AN000;
	  CALL	GET_BACKGROUND							;AN000;
       .WHEN <BX EQ <OFFSET PRINTBOX_RESULT>>					;AN000;
	  CALL	GET_PRINTBOX_ID 						;AN000;
       .OTHERWISE								;AN000;
;-------No result block was returned by the parser				;AN000;
	STC				; Set error				;AN000;
       .ENDSELECT								;AN000;
       .LEAVE C 			; IF error occurred while parsing the	;AN000;
					;  previous argument, exit the loop:	;AN000;
					;   stop parsing the command line.	;AN000;
;-------------------------------------------------------------------------------;AN000;
; Parse next argument:								;AN000;
;-------------------------------------------------------------------------------;AN000;
;(deleted ;AN001;) XOR DX,DX		;					;AN000;
;(deleted ;AN001;) CALL SYSPARSE	; Get one argument from the command line;AN000;
	CALL	CALL_SYSPARSE		; Get one argument from the command line;AN001;
;(deleted ;AN001;) MOV BX,DX		; ES:BX := Offset of result block	;AN000;
.ENDWHILE									;AN000;

;-------------------------------------------------------------------------------;AN000;
; Check for error, select and display an error message				;AN000;
;-------------------------------------------------------------------------------;AN000;
.IF <AL NE RC_EOL>			; IF an error occurred			;AN000;
.THEN					; then, display error message		;AN000;
    MOV 	CX,0			; Assume no substitutions		;AN000;
   .SELECT				; (CX := Number of substitutions	;AN000;
   .WHEN <AL EQ RC_TOO_MANY>		; When RC = Too many parameters 	;AN000;
	MOV	AX,TOO_MANY_PARMS	;   (AL = Message number to display)	;AN000;
   .WHEN <AL EQ RC_Not_In_Val>		; When RC = Not in value list provided	;AN000;
	MOV	AX,VALUE_NOT_ALLOWED	;   (AL = Message number to display)	;AN000;
   .WHEN <AL EQ RC_Not_In_Sw>		; When RC = Not in switch list provided ;AN000;
	MOV	CX,1			;   1 substitution in this message	;AN000;
	MOV	BYTE PTR [SI],0 	; PUT NUL AT END OF THIS PARM		;AN001;
	LEA	SI,SUBLIST		;   DS:[SI]:="Invalid parm" Substitution;AN000; list
;(deleted ;AN001;) LES DX,ES:[BX+4]	;   ES:DX := Offset of offending parm.	;AN000;
;(deleted ;AN001;) MOV [SI]+2,DX	;   Store offset to this offender in the;AN000;
	MOV	[SI]+4,ES		;    substitution list control block	;AN000;
	MOV	AX,INVALID_PARM 	;   AL := 'Invalid parameter' msg number;AN000;
   .WHEN <AL EQ RC_INVLD_COMBINATION>	; When RC = Invalid combination of parms;AN000;
	MOV	AX,INVALID_COMBINATION	;   (AL = Message number to display)	;AN000;
   .WHEN <AL EQ RC_DUPLICATE_PARMS>	; When RC = Invalid combination of parms;AN000;
	MOV	AX,DUPLICATE_PARM	;   (AL = Message number to display)	;AN000;
   .OTHERWISE				;					;AN000;
	MOV	AX,FORMAT_NOT_CORRECT	; RC = Anything else, tell the user	;AN000;
					;	something is wrong with his	;AN000;
   .ENDSELECT				;	 command line.			;AN000;
    CALL DISP_ERROR			; Display the selected error message	;AN000;
    STC 				; Indicate parse error occurred 	;AN000;
.ENDIF										;AN000;
										;AN000;
PPST:	POP	ES								;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET				; Return to GRAPHICS_INSTALL		;AN000;
										;AN000;
PARSE_PARMS ENDP								;AN000;
CALL_SYSPARSE PROC NEAR 		;COMMON INVOCATION OF SYSPARSE		;AN001;
;INPUT: - CX=ORDINAL VALUE							;AN001;
;	  DS:SI=WHERE COMMAND LINE IS, SAVED IN "SAVE_SI"                       ;AN001;
;	  ES:DI=WHERE PARMS DESCRIPTOR BLOCK IS 				;AN001;
;OUTPUT:  CX=NEW ORDINAL VALUE							;AN001;
;	  BX=OFFSET OF RESULT BLOCK, IF ONE IS RETURNED 			;AN001;
;	  SI=OFFSET OF CHAR BEYOND PARSED PARM IN COMMAND LINE			;AN001;
										;AN001;
	XOR	DX,DX			;CLEAR DX FOR PARSER			;AN001;
	MOV	WORD PTR SAVE_SI,SI	;REMEMBER WHERE TO START LOOKING	;AN001;
	CALL	SYSPARSE		;GO PARSE THE NEXT PARM 		;AN001;
										;AN001;
	MOV	BX,DX			; BX := Offset of result block		;AN001;
	RET				;RETURN TO CALLER			;AN001;
CALL_SYSPARSE ENDP								;AN001;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_PROFILE							;AN000;
;										;AN000;
; INPUT:  ES:[BX] := Result block						;AN000;
;										;AN000;
; OUTPUT: PROFILE_PATH = The profile file name and path (ASCIIZ string) 	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_PROFILE_NAME PROC								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Get the name of the profile path found on the command line:			;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	DI,ES:[BX+4]	; DI := Offset of filename found		;AN000;
	XOR	BX,BX		; BX := Byte index				;AN000;
	MOV	SI,OFFSET PROFILE_PATH	; [BX][SI] := Where to store it 	;AN000;
										;AN000;
.IF <<BYTE PTR [DI]> NE 0>	; Don't copy a NULL parm                        ;AN000;
  .REPEAT			; While not end of path name (NULL terminated)	;AN000;
	MOV	AL,[BX][DI]	; Copy the byte (including the NULL)		;AN000;
	MOV	[BX][SI],AL							;AN000;
	INC	BX		; Get next one					;AN000;
  .UNTIL <<BYTE PTR [BX-1][DI]> EQ 0> ; 					;AN000;
.ENDIF										;AN000;
										;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	CLC									;AN000;
	RET									;AN000;
GET_PROFILE_NAME ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_TYPE							;AN000;
;										;AN000;
; INPUT:  ES:[BX] := Result block						;AN000;
;	  PRINTER_TYPE_LENGTH := Maximum length for the printer type string	;AN000;
;										;AN000;
; OUTPUT: PRINTER_TYPE_PARM = ASCIIZ string containing				;AN000;
;			       the Printer type.				;AN000;
;	  AX		    = Error code					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_TYPE PROC									;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;---------------------------------------------------------------------- 	;AN000;
; Overwrite the DEFAULT TYPE with the type found on the command line		;AN000;
;---------------------------------------------------------------------- 	;AN000;
  MOV	  SI,ES:[BX+4]		       ; DS:SI := Offset of printer type found	;AN000;
 .IF <<BYTE PTR [SI]> NE 0>	       ; Do not copy an empty string		;AN000;
 .THEN				       ;					;AN000;
    MOV     CL,PRINTER_TYPE_LENGTH     ; CX := Maximum number of bytes		;AN000;
    XOR     CH,CH		       ;	to copy 			;AN000;
    MOV     DI,OFFSET PRINTER_TYPE_PARM; ES:DI := Where to store it		;AN000;
    REP     MOVSB		       ; Copy the string			;AN000;
  ;----------------------------------------------------------------------	;AN000;
  ; Verify that the string supplied is not too long:				;AN000;
  ;----------------------------------------------------------------------	;AN000;
   .IF	<<BYTE PTR [DI-1]> EQ 0>       ; If the last byte is a null		;AN000;
   .THEN			       ; then, the string was not longer	;AN000;
				       ;       than the maximum 		;AN000;
      CLC			       ;   Clear the carry flag = No error	;AN000;
   .ELSE			       ; else, string provided is too long	;AN000;
      MOV  AX,RC_Not_In_Sw	       ;   Error := RC for Invalid parm 	;AN000;
      STC			       ; Set error				;AN000;
   .ENDIF			       ; ENDIF string too long			;AN000;
 .ENDIF 			       ; ENDIF string provided			;AN000;
										;AN000;
GET_TYPE_END:									;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
GET_TYPE  ENDP									;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_REVERSE							;AN000;
;										;AN000;
; INPUT:  ES:[BX]	:= Result block 					;AN000;
;	  SWITCH_PARSED := The command line switches parsed so far (bit mask)	;AN000;
;										;AN000;
; OUTPUT: CS:[BP].SWITCHES (Bit mask in the Shared data area) is updated	;AN000;
;			    with the value of the switch found. 		;AN000;
;	  GOT_R is set in SWITCH_PARSED 					;AN000;
;	  AX		:= Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_REVERSE	PROC								;AN000;
										;AN000;
	TEST	SWITCH_PARSED,GOT_R		; If already parsed this switch ;AN000;
	JNZ	DUPLICATE_R			; then, error			;AN000;
	OR	SWITCH_PARSED,GOT_R		; else, say we parsed it.	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set the Reverse switch in the Shared data area				;AN000;
;-------------------------------------------------------------------------------;AN000;
	OR	CS:[BP].SWITCHES,REVERSE_SW	; Set the command line switch	;AN000;
	CLC					; Clear the error flag		;AN000;
	JMP	SHORT GET_REVERSE_END		; Return			;AN000;
										;AN000;
DUPLICATE_R:					; Already got this switch	;AN000;
	MOV	AX,RC_DUPLICATE_PARMS		; AX := error message number	;AN000;
	STC					; SET ERROR			;AN000;
GET_REVERSE_END:								;AN000;
										;AN000;
	RET									;AN000;
GET_REVERSE	ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_BACKGROUND						;AN000;
;										;AN000;
; INPUT:  ES:[BX] := Result block						;AN000;
;	  SWITCH_PARSED := The command line switches parsed so far (bit mask)	;AN000;
;										;AN000;
; OUTPUT: CS:[BP].SWITCHES (Bit mask in the Shared data area) is updated	;AN000;
;			    with the value of the switch found. 		;AN000;
;										;AN000;
;	  GOT_B is set in SWITCH_PARSED 					;AN000;
;	  AX		:= Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_BACKGROUND	PROC								;AN000;
										;AN000;
	TEST	SWITCH_PARSED,GOT_B		; If already parsed this switch ;AN000;
	JNZ	DUPLICATE_B			; then, error			;AN000;
	OR	SWITCH_PARSED,GOT_B		; else, say we parsed it.	;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set the switch in the Shared data area					;AN000;
;-------------------------------------------------------------------------------;AN000;
	OR	CS:[BP].SWITCHES,BACKGROUND_SW	; Set the command line switch	;AN000;
	CLC					; Clear the error flag		;AN000;
	JMP	SHORT GET_BACKGROUND_END	; Return			;AN000;
										;AN000;
DUPLICATE_B:					; Already got this switch	;AN000;
	MOV	AX,RC_DUPLICATE_PARMS		; AX := error message number	;AN000;
	STC					; SET ERROR			;AN000;
										;AN000;
GET_BACKGROUND_END:								;AN000;
	RET									;AN000;
GET_BACKGROUND	ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_LCD							;AN000;
;										;AN000;
; INPUT:  SWITCH_PARSED   := The command line switches parsed so far (bit mask) ;AN000;
;										;AN000;
; OUTPUT: PRINTBOX_ID_PTR := Point to /LCD ASCIIZ string.			;AN000;
;	  GOT_B is set in SWITCH_PARSED 					;AN000;
;	  AX		  := Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Data Referenced:								;AN000;
;										;AN000;
;	  LCD_BOX = An ASCIIZ string representing the LCD printbox id.		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_LCD PROC									;AN000;
										;AN000;
	TEST	SWITCH_PARSED,GOT_LCD	   ; If already parsed this switch	;AN000;
	JNZ	DUPLICATE_LCD		   ; then, error: Duplicate switch	;AN000;
	TEST	SWITCH_PARSED,GOT_PRINTBOX ; If printbox already mentioned	;AN000;
	JNZ	BAD_COMBINATION 	   ; then, error: Invalid combination	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set the pointer to the print box id to "LCD"                                  ;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AX,OFFSET LCD_BOX	   ; PRINTBOX id := LCD 		;AN000;
	MOV	PRINTBOX_ID_PTR,AX	   ; Save pointer to this printbox id.	;AN000;
	OR	SWITCH_PARSED,GOT_LCD	   ; Say we found this switch		;AN000;
	CLC				   ; Clear the error flag		;AN000;
	JMP	SHORT GET_LCD_END	   ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /LCD was already parsed:							;AN000;
;-------------------------------------------------------------------------------;AN000;
DUPLICATE_LCD:				   ; Already got this switch		;AN000;
	MOV	AX,RC_DUPLICATE_PARMS	   ; AX := error message number 	;AN000;
	STC				   ; SET ERROR				;AN000;
	JMP	SHORT GET_LCD_END	   ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /PRINTBOX was already parsed: 						;AN000;
;-------------------------------------------------------------------------------;AN000;
BAD_COMBINATION:			   ; /LCD and /PRINTBOX invalid at same ;AN000;
	MOV	AX,RC_INVLD_COMBINATION    ;  time, Set the error flag		;AN000;
	STC				   ;   AX := Error code 		;AN000;
										;AN000;
GET_LCD_END:									;AN000;
	RET									;AN000;
GET_LCD 	ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_PRINTBOX							;AN000;
;										;AN000;
; INPUT:  ES:[BX]	:= Result block 					;AN000;
;	  SWITCH_PARSED := The command line switches parsed so far (bit mask)	;AN000;
;										;AN000;
; OUTPUT: DEFAULT_BOX	:= Is overwritten to contain the printbox id. found on	;AN000;
;			    the command line.					;AN000;
;	  GOT_PRINTBOX is set in SWITCH_PARSED					;AN000;
;	  AX		:= Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_PRINTBOX_ID PROC								;AN000;
										;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Test for error in the printbox statement:					;AN000;
;-------------------------------------------------------------------------------;AN000;
	TEST	SWITCH_PARSED,GOT_LCD	    ; If /LCD	  already mentioned	;AN000;
	JNZ	BAD_COMBINATION2	    ; then, error: Invalid combination	;AN000;
	TEST	SWITCH_PARSED,GOT_PRINTBOX  ; If already parsed this switch	;AN000;
	JNZ	DUPLICATE_PRINTBOX	    ; then, error: Duplicate switch	;AN000;
										;AN000;
	MOV	DI,ES:[BX+4]		    ; DI := Offset of switch VALUE found;AN000;
										;AN000;
       .IF <<BYTE PTR [DI]> EQ 0>	    ; IF no printbox id 		;AN000;
       .THEN				    ; then,				;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 ; No printbox id. was found:						;AN000;
	 ;----------------------------------------------------------------------;AN000;
	  MOV	  AX,FORMAT_NOT_CORRECT     ;	AX := Error code		;AN000;
	  STC				    ;	Set the error flag		;AN000;
       .ELSE				    ; else,				;AN000;
	  OR	  SWITCH_PARSED,GOT_PRINTBOX;	Say we found this switch	;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 ; Overwrite DEFAULT_BOX with the Printbox id. found			;AN000;
	 ;----------------------------------------------------------------------;AN000;
	  MOV	  CL,PRINTBOX_ID_LENGTH     ;	  CX := Maximum number of bytes ;AN000;
	  XOR	  CH,CH 		    ;		 to copy		;AN000;
	  MOV	  SI,DI 		    ;	  [DS][SI] :=  Value found	;AN000;
	  MOV	  DI,OFFSET DEFAULT_BOX     ;	  [ES][DI] :=  Default value	;AN000;
	  REP	  MOVSB 		    ;	  Copy the string		;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 ; Verify that the Printbox id. string is not too long: 		;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 .IF  <<BYTE PTR [DI-1]> EQ 0>	    ; If the last byte is a null	;AN000;
	 .THEN				    ; then, the string was not longer	;AN000;
					    ;	    than the maximum		;AN000;
	    CLC 			    ;	Clear the carry flag = No error ;AN000;
	 .ELSE				    ; else, string provided is too long ;AN000;
	    MOV  AX,RC_Not_In_Sw	    ;	Error := RC for Invalid parm	;AN000;
	    STC 			    ; Set error 			;AN000;
	 .ENDIF 			    ; ENDIF printbox id. too long	;AN000;
       .ENDIF				    ; ENDIF printbox id. provided	;AN000;
										;AN000;
	JMP	SHORT GET_PRINTBOX_END	    ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /PRINTBOX was already parsed: 						;AN000;
;-------------------------------------------------------------------------------;AN000;
DUPLICATE_PRINTBOX:			    ; Already got this switch		;AN000;
	MOV	AX,RC_DUPLICATE_PARMS	    ; AX := error message number	;AN000;
	STC				    ; SET ERROR 			;AN000;
	JMP	SHORT GET_PRINTBOX_END	    ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /LCD was already parsed:							;AN000;
;-------------------------------------------------------------------------------;AN000;
BAD_COMBINATION2:			    ; /LCD and /PRINTBOX invalid at same;AN000;
	MOV	AX,RC_INVLD_COMBINATION     ;  time, Set the error flag 	;AN000;
	STC				    ;	AX := Error code		;AN000;
										;AN000;
GET_PRINTBOX_END:								;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	RET									;AN000;
GET_PRINTBOX_ID ENDP								;AN000;
										;AN000;
CODE  ENDS									;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\grparse.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Profile Load Modules #2 
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set assemble switches for parse code that is not required!!			;AN000;
;-------------------------------------------------------------------------------;AN000;
DateSW	      EQU     0 							;AN000;
TimeSW	      EQU     0 							;AN000;
CmpxSW	      EQU     0 							;AN000;
DrvSW	      EQU     0 							;AN000;
QusSW	      EQU     0 							;AN000;
KeySW	      EQU     0 							;AN000;
;Val1SW        EQU     0							;AN000;
;Val2SW        EQU     0							;AN000;

	include version.inc										;AN000;
       PUBLIC  SYSPARSE 	       ;;					;AN000;
       INCLUDE PARSE.ASM	       ;; parser code				;AN000;
				       ;;					;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\graphics\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybcpsd.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBCPSD.INC
;; ----------
;;
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBCPSD.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    COPY_SD_AREA:NEAR     ;;
                                       ;;
        EXTRN    SD_DEST_PTR :BYTE     ;;
        EXTRN    SHARED_DATA :BYTE     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybcmd.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBCMD.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;;
;; Description:
;; ------------
;;       External declarations for procedures in file KEYCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                              ;;
        EXTRN    KEYB_COMMAND        :NEAR    ;;
                                              ;;
        EXTRN    KEYBSYS_FILE_HANDLE:WORD     ;;
        EXTRN    CP_TAB_OFFSET:DWORD          ;;
        EXTRN    STATE_LOGIC_OFFSET:DWORD     ;;
        EXTRN    SYS_CODE_PAGE:WORD           ;;
        EXTRN    KEYBCMD_LANG_ENTRY_PTR:DWORD ;;
        EXTRN    DESIG_CP_BUFFER:WORD         ;;
        EXTRN    DESIG_CP_OFFSET:WORD         ;;
        EXTRN    NUM_DESIG_CP:WORD            ;;
        EXTRN    TB_RETURN_CODE:WORD          ;;
        EXTRN    FILE_BUFFER:BYTE             ;;
;****************CNS****************************
        EXTRN    ID_PTR_SIZE:WORD             ;;
;****************CNS****************************
        EXTRN    LANG_PTR_SIZE:WORD           ;;
        EXTRN    CP_PTR_SIZE:WORD             ;;
;****************CNS****************************
        EXTRN    NUM_ID:WORD                  ;;
;****************CNS****************************
        EXTRN    NUM_LANG:WORD                ;;
        EXTRN    NUM_CP:WORD                  ;;
        EXTRN    SHARED_AREA_PTR:DWORD        ;;
        EXTRN    SD_SOURCE_PTR:BYTE           ;;
        EXTRN    TEMP_SHARED_DATA:BYTE        ;;
                                              ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybcpsd.asm ===
PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
;  File Name:  KEYBCPSD.ASM
;  ----------
;
;
;  Description:
;  ------------
;	 Copies the SHARED_DATA_AREA into a part of memory that
;	 can be left resident. All relative pointers must already
;	 be recalculated to this new position.
;	 THIS FILE MUST BE THE LAST OF THE RESIDENT FILES WHEN KEYB IS LINKED.
;
;
;  Procedures Contained in This File:
;  ----------------------------------
;
;  Include Files Required:
;  -----------------------
;	INCLUDE KEYBSHAR.INC
;	INCLUDE KEYBCMD.INC
;	INCLUDE KEYBTBBL.INC
;
;  External Procedure References:
;  ------------------------------
;	 FROM FILE  ????????.ASM:
;	      procedure - description???
;
;  Linkage Information:  Refer to file KEYB.ASM
;  --------------------
;
;  Change History:
;  ---------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC	SD_DEST_PTR
	PUBLIC	COPY_SD_AREA
	PUBLIC	SHARED_DATA

	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBCMD.INC
	INCLUDE KEYBTBBL.INC

CODE	SEGMENT PUBLIC 'CODE'

	ASSUME	CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: COPY_SD_AREA
;
;  Description:
;
;  Input Registers:
;
;  Output Registers:
;      N/A
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SD		EQU   SHARED_DATA
TSD		EQU  TEMP_SHARED_DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_SD_AREA	PROC   NEAR

   REP	MOVS	ES:BYTE PTR [DI],DS:[SI]	; Copy SHARED_DATA_AREA to
						;	new part of memory

	MOV	BYTE PTR ES:SD.TABLE_OK,1	; Activate processing flag
	INT	21H				; Exit


COPY_SD_AREA	ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		db	'SHARED DATA'
SD_DEST_PTR	LABEL	BYTE

SHARED_DATA   SHARED_DATA_STR <>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE   ENDS
       END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keyb.asm ===
PAGE    ,132
        TITLE   MS-DOS 5.0 KEYB Command  -  Root Module

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MS-DOS 5.0 - NLS Support - KEYB Command
; (c) Copyright Microsoft Corp 1987-1991
;
; File Name:  KEYB.ASM
; ----------
;
;
; Description:
; ------------
;       Contains root module for KEYB command.  This module is the
;       KEYB command entry point.  KEYB is an external command included
;       with MS DOS 5.0 to provide keyboard support for 14 languages.
;       KEYB will jump immediately into the command processing in
;       file KEYBCMD.  All resident code is included before KEYBCMD
;       in the linkage list.
;
;
; Procedures Contained in This File:
; ----------------------------------
;
;
; Include Files Required:
; -----------------------
;       KEYBCMD.INC - External declarations for transient command
;           processing routines
;
; External Procedure References:
; ------------------------------
;       FROM FILE  KEYCMD.ASM:
;            KEYB_COMMAND - Main routine for transient command processing.
;
; Linkage Instructions:
; --------------------
;       Link in .COM format.  Resident code/data is in files KEYB thru
;       KEYBCPSD.
;
;       LINK KEYB+KEYBI9+KEYBI9C+KEYBI2F+KEYBCPSD+KEYBMSG+
;            COMMSUBS+KEYBTBBL+KEYBCMD;
;       EXE2BIN KEYB.EXE KEYB.COM
;
; Change History:
; ---------------
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


CODE    SEGMENT PUBLIC 'CODE' BYTE

        INCLUDE KEYBCMD.INC            ; Bring in external declarations
                                       ;  for transient command processing
        ASSUME  CS:CODE,DS:CODE
        ORG   100H                     ; required for .COM


START:

        JMP   KEYB_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CODE   ENDS
       END    START

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\commsubs.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;;
;; File Name:  CONVERT.INC
;; ----------
;;
;; Root File Name:  KEYBCMD.ASM
;; ---------------
;;
;;
;; Description:
;; ------------
;;       External declarations for procedures in file KEYBCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    FIND_SYS_TYPE   :NEAR ;;
        EXTRN    FIND_KEYB_TYPE  :NEAR ;;
                                       ;;
        EXTRN    HW_TYPE         :WORD ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\kbmsg.inc ===
;;

;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;

ACT_KEYB    DB	  'Current keyboard code: ','$'                               ;;
ACT_KEYB_CP DB	  '  code page: ','$'                                         ;;
ACT_CON_CP  DB	  'Current CON code page: ','$'                               ;;
INV_L	    DB	  'Invalid keyboard code specified',10,13,'$'                 ;;
INV_I	    DB	  'Invalid keyboard ID specified',10,13,'$'                 ;;
INV_CP	    DB	  'Invalid code page specified',10,13,'$'                     ;;
INV_S	    DB	  'Invalid syntax',10,13,'$'                                  ;;
INV_FN	    DB	  'Bad or missing Keyboard Definition File',10,13,'$'         ;;
INV_KEYB_Q  DB	  'KEYB has not been installed',10,13,'$'                     ;;
INV_CON_Q   DB	  'Active code page not available from CON device',10,13,'$'  ;;
NOT_DESIG   DB	  'Code page specified has not been prepared',10,13,'$'       ;;
NOT_SUPP    DB	  'One or more CON code pages invalid for given keyboard code',10,13,'$' ;;
NOT_VALID1  DB	  'Code page requested (','$'                                 ;;
NOT_VALID2  DB	  ') is not valid for given keyboard code',10,13,'$'               ;;
WARNING_1   DB	  'Code page specified is inconsistent with the selected code page',10,13,'$'  ;;
INV_COMBO   DB	  'ID code specified is inconsistent with the selected keyboard code',13,'$'  ;;
MEMORY_OVERF DB   'Unable to create KEYB table in resident memory',10,13,'$'  ;;
CR_LF	    DB	  10,13,'$'                                                   ;;
									      ;;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybcmd.asm ===
PAGE    ,132
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
; File Name:  KEYBCMD.ASM
; ----------
;
;
; Description:
; ------------
;        Contains transient command processing modules for KEYB command.
;
; Procedures contained in this file:
; ----------------------------------
;       KEYB_COMMAND:    Main routine for command processing.
;       PARSE_PARAMETERS:  Validate syntax of parameters included
;           on command line.
;       BUILD_PATH: Find KEYBOARD.SYS file and validate language and/or
;           code page.
;       INSTALL_INT_VECTORS:  Install our INT 9, INT 2F Drivers
;       NUMLK_ON:  Turn on the NUM LOCK LED
;       FIND_FIRST_CP: Determine first code page for given language in the
;           Keyboard Definition file.
;
; Include Files Required:
; -----------------------
;       KEYBMSG.INC
;       KEYBEQU.INC
;       KEYBSYS.INC
;       KEYBI9C.INC
;       KEYBI9.INC
;       KEYBI2F.INC
;       KEYBSHAR.INC
;       KEYBDCL.INC
;       KEYBTBBL.INC
;       COMMSUBS.INC
;       KEYBCPSD.INC
;       POSTEQU.SRC
;       DSEG.SRC
;
; External Procedure References:
; ------------------------------
;       FROM FILE  KEYBTBBL.ASM:
;             TABLE_BUILD - Create the shared area containing all keyboard tables.
;             STATE_BUILD - Build all states within the table area
;        FROM FILE  KEYBMSG.ASM:
;             KEYB_MESSAGES - All messages
;
; Change History:
;
;  Modified for DOS 3.40 -      Nick Savage , IBM Corporation
;                               Wilf Russell, IBM Canada Laboratory
;                               DCR ???? -KEYBAORD SECURITY LOCK - CNS
;
;
;                               PTM 3906 - KEYB messages do not conform
;                                          to spec. Error message does
;                               3/24/88            not pass back the bogus command
;                                          line argument.             - CNS
;
; PTMP3955 ;KEYB component to free environment and close handles 0 - 4
;
; 3/24/88
;
; 9/26/89 jwg Moved code from resident module and reduce code size.
;
;;;;;;;;;;;;;

        PUBLIC  KEYB_COMMAND

;*****************CNS********************
        PUBLIC  ID_TAB_OFFSET
;*****************CNS********************

        PUBLIC  CP_TAB_OFFSET
        PUBLIC  STATE_LOGIC_OFFSET
        PUBLIC  SYS_CODE_PAGE
        PUBLIC  KEYBCMD_LANG_ENTRY_PTR
        PUBLIC  DESIG_CP_BUFFER
        PUBLIC  DESIG_CP_OFFSET
        PUBLIC  KEYBSYS_FILE_HANDLE
        PUBLIC  NUM_DESIG_CP
        PUBLIC  TB_RETURN_CODE
        PUBLIC  FILE_BUFFER
        PUBLIC  FB

;*****************CNS********************
        PUBLIC  ID_PTR_SIZE
        PUBLIC  LANG_PTR_SIZE
        PUBLIC  CP_PTR_SIZE
        PUBLIC  NUM_ID
        PUBLIC  NUM_LANG
        PUBLIC  NUM_CP
        PUBLIC  SHARED_AREA_PTR
;*****************CNS********************

        PUBLIC  SD_SOURCE_PTR
        PUBLIC  TEMP_SHARED_DATA

        PUBLIC  FOURTH_PARM
        PUBLIC  ONE_PARMID
        PUBLIC  FTH_PARMID
        PUBLIC  ID_FOUND
        PUBLIC  BAD_ID
        PUBLIC  ALPHA
        EXTRN   PARSE_PARAMETERS:NEAR
        extrn   pswitches:byte

;***CNS
        EXTRN   SECURE_FL:BYTE
        EXTRN   CUR_PTR:WORD
        EXTRN   OLD_PTR:WORD
        EXTRN   ERR_PART:WORD
;***CNS

        .xlist
        INCLUDE SYSMSG.INC             ;  message retriever
        .list

MSG_UTILNAME <KEYB>                    ;  identify to message retriever

CODE    SEGMENT PUBLIC 'CODE'

        .xlist
        INCLUDE KEYBEQU.INC
        INCLUDE KEYBSYS.INC
        INCLUDE KEYBI9.INC
        INCLUDE KEYBI9C.INC
        INCLUDE KEYBI2F.INC
        INCLUDE KEYBSHAR.INC
        INCLUDE KEYBDCL.INC
        INCLUDE KEYBTBBL.INC
        INCLUDE COMMSUBS.INC
        INCLUDE KEYBCPSD.INC
        .xlist
        INCLUDE POSTEQU.INC
        INCLUDE DSEG.INC

        .list
        ASSUME  CS:CODE,DS:CODE

;;;;;;;;;;;;;
;
; Module: KEYB_COMMAND
;
; Description:
;     Main routine for transient command processing.
;
; Input Registers:
;     DS - points to our data segment
;
; Output Registers:
;     Upon termination, if an error has occurred in which a keyboard table
;     was not loaded, the AL register will contain the a error flag. This
;     flag is defined as follows:
;             AL:= 1 - Invalid language, code page, or syntax
;                  2 - Bad or missing Keyboard Definition File
;                  3 - KEYB could not create a table in resident memory
;                  4 - An error condition was received when communicating
;                      with the CON device
;                  5 - Code page requested has not been designated
;                  6 - The keyboard table for the requested code page cannot
;                      be found in resident keyboard table.
;
; Logic:
;     IF KEYB has NOT been previously loaded THEN
;         Set SHARED_AREA_PTR to TEMP_SHARED_AREA
;         INSTALLED_KEYB := 0
;         Get HW_TYPE (set local variable)
;     ELSE
;         Set SHARED_AREA_PTR to ES:SHARED_AREA
;         Get HW_TYPE (set local variable)
;         Set TABLE_OK := 0
;         INSTALLED_KEYB := 1
;
;     IF CPS-CON has been loaded THEN
;         INSTALLED_CON := 1
;
;*********************************** CNS *************************************
;     Call PARSE_PARAMETERS := Edit ID or language, code page,
;                                           and path parameters,ID on command line
;*********************************** CNS *************************************
;     Check all return codes:
;     IF any parameters are invalid THEN
;         Display ERROR message
;     ELSE
;         IF no language parm specified
;                                AND code page is not invalid
;                                                    AND syntax is valid THEN
;            Process QUERY:
;            IF KEYB is installed THEN
;                Get and display active language from SHARED_DATA_AREA
;                Get invoked code page from SHARED_DATA_AREA
;                Convert to ASCII
;                Display ASCII representation of code page, CR/LF
;*********************************** CNS *************************************
;            IF ALTERNATE FLAG SET
;                Get and display active ID from SHARED_DATA_AREA
;                Convert to ASCII
;                Display ASCII representation of ID, CR/LF
;*********************************** CNS *************************************
;            IF CPS-CON is installed THEN
;                Get selected code page info from CON
;                Convert to ASCII
;                Display ASCII representation of code page, CR/LF
;            EXIT without staying resident
;
;         ELSE
;            Call BUILD_PATH := Determine location of Keyboard definition file
;            Open the file
;            IF error in opening file THEN
;               Display ERROR message and EXIT
;            ELSE
;               Save handle
;               Set address of buffer
;               READ header of Keyboard definition file
;               IF error in reading file THEN
;                  Display ERROR message and EXIT
;               ELSE
;                  Check signature for correct file
;                  IF file signature is correct THEN
;                     READ language table
;                     IF error in reading file THEN
;                         Display ERROR message and EXIT
;                     ELSE
;                         Use table to verify language parm
;                         Set pointer values
;                         IF code page was specified
;                             READ language entry
;                             IF error in reading file THEN
;                                  Display ERROR message and EXIT
;                             ELSE
;                                  READ Code page table
;                                  IF error in reading file THEN
;                                      Display ERROR message and EXIT
;                                  ELSE
;                                      Use table to verify code page parm
;                                      Set pointer values
;     IF CPS-CON is not installed THEN
;           Set number of code pages = 1
;           IF CODE_PAGE_PARM was specified THEN
;              Copy CODE_PAGE_PARM into table of code pages to build
;           ELSE
;              Call FIND_FIRST_CP := Define the system code page (1st in Keyb Def file)
;              Copy SYSTEM_CP into table of code pages to build
;     ELSE
;           Issue INT 2F ; 0AD03H  to get table of Designated code pages
;           Set number of designated code pages (HWCP + Desig CP)
;           Issue INT 2F ; 0AD02H  to get invoked code page
;           IF CODE_PAGE_PARM was specified THEN
;              Check that CODE_PAGE_PARM is in the list of designated code pages
;              IF CODE_PAGE_PARM is in the list of designated code pages THEN
;                   Copy specified CP into table of code pages to build
;                   IF a CP has been selected AND is inconsistent with specified CP
;                       Issue WARNING message
;              ELSE
;                   Display ERROR message
;           ELSE
;              IF a code page has been invoked THEN
;                   Copy invoked code page into table of code pages to build
;              ELSE
;                   Call FIND_FIRST_CP := Define the system code page (1st in Keyb Def file)
;                   Copy SYSTEM_CP into table of code pages to build
;
;     IF KEYB has not been previously installed THEN
;         Call FIND_SYS_TYPE := Determine system type
;         Call INSTALL_INT_9 := Install INT 9 handler
;         Call FIND_KEYB_TYPE := Determine the keyboard type
;
;     Call TABLE_BUILD := Build the TEMP_SHARED_DATA_AREA
;
;     IF return codes from TABLE_BUILD are INVALID THEN
;         IF KEYB_INSTALLED := 0 THEN
;             Call REMOVE_INT_9
;         Display corresponding ERROR message
;         EXIT without staying resident
;     ELSE
;         IF any of the designated CPs were invalid in the build THEN
;             Issue WARNING message
;         Close the Keyboard definition file
;         IF KEYB had NOT already been installed THEN
;             IF keyboard is a Ferrari_G AND system is not an XT THEN
;             Call NUMLK_ON := Turn the NUM LOCK LED on
;             IF extended INT 16 support required THEN
;                Install extended INT 16 support
;             Call INSTALL_INT_9_NET := Let network know about INT 9
;             Call INSTALL_INT_2F := Install the INT 2F driver
;             Activate language
;             Get resident end and copy TEMP_SHARED_DATA_AREA into SHARED_DATA_AREA
;             EXIT but stay resident
;         ELSE
;             IF this was not a query call AND exit code was valid THEN
;                Activate language
;                Get resident end and copy TEMP_SHARED_DATA_AREA into SHARED_DATA_AREA
;             EXIT without staying resident
;     END
;
;;;;;;;;;;;;;

INVALID_PARMS        EQU  1           ;  EXIT return codes
BAD_KEYB_DEF_FILE    EQU  2
MEMORY_OVERFLOW      EQU  3
CONSOLE_ERROR        EQU  4
CP_NOT_DESIGNATED    EQU  5
KEYB_TABLE_NOT_LOAD  EQU  6
BAD_DOS_VER          EQU  7
EXIT_RET_CODE        DB   0

;******************** CNS ***********
ID_VALID             EQU  0
ID_INVALID           EQU  1
NO_ID                EQU  2
LANGUAGE_VALID       EQU  0
LANGUAGE_INVALID     EQU  1             ;  Return Codes
NO_LANGUAGE          EQU  2             ;    from
NO_IDLANG            EQU  3
;******************** CNS ***********

CODE_PAGE_VALID      EQU  0             ;     EDIT_LANGUAGE_CODE
CODE_PAGE_INVALID    EQU  1
NO_CODE_PAGE         EQU  2
VALID_SYNTAX         EQU  0
INVALID_SYNTAX       EQU  1

ACT_KEYB             EQU  2
ACT_ID               EQU  3
ACT_KEYB_CP          EQU  4
ACT_CON_CP           EQU  5
INV_L                EQU  6             ;  message numbers...
INV_I                EQU  7
INV_CP               EQU  8
INV_S                EQU  18
INV_FN               EQU  9
INV_KEYB_Q           EQU  10
INV_CON_Q            EQU  11
NOT_DESIG            EQU  12
NOT_SUPP             EQU  13
NOT_VALID            EQU  14
WARNING_1            EQU  15
INV_COMBO            EQU  16
MEMORY_OVERF         EQU  17
help_1st             equ  300
help_last            equ  306
CR_LF                DB   10,13,'$'

FOURTH_PARM     DB      0               ;  switch was specified
ONE_PARMID      DB      0               ;  id given as positional
FTH_PARMID      DB      0               ;  id given as switch
ID_FOUND        DB      0               ;  id was good (in k.d. file)
BAD_ID          DB      0               ;  id was bad (from parse)
ALPHA           DB      0               ;  first parm a language id

ID_DISPLAYED    DB      0               ;  Indicating ID already displayed

SUBLIST_NUMBER LABEL BYTE               ;  sublist for numbers
               DB       11              ;  size
               DB       0
PTR_TO_NUMBER  DW       ?               ;  offset ptr
SEG_OF_NUMBER  DW       ?               ;  segment
               DB       1
               DB       10100001B       ;  flag
               DB       4               ;  max width (YST)
               DB       1               ;  min width
               DB       " "             ;  filler


SUBLIST_ASCIIZ LABEL BYTE               ;  sublist for asciiz
               DB       11              ;  size
               DB       0
PTR_TO_ASCIIZ  DW       ?               ;  offset ptr
SEG_OF_ASCIIZ  DW       ?               ;  segment
               DB       1
               DB       00010000B       ;  flag
               DB       2               ;  max width
               DB       2               ;  min width
               DB       " "             ;  filler

NUMBER_HOLDER  DW       ?               ;  used for message retriever

;***CNS
SUBLIST_COMLIN LABEL BYTE               ;  sublist for asciiz
               DB       11              ;  size
               DB       0
PTR_TO_COMLIN  DW       ?               ;  offset ptr
SEG_OF_COMLIN  DW       ?
               DB       0
               DB       LEFT_ALIGN+CHAR_FIELD_ASCIIZ  ;  flag

               DB       0               ;  max width
               DB       1               ;  min width
               DB       " "             ;  filler


STRING_HOLDER  DB       64 DUP(0)
;***CNS

FILE_BUFFER          DB   FILE_BUFFER_SIZE dup (0); Buffer for Keyboard Def file
FB                   EQU  FILE_BUFFER   ;m for 32 language entries)
DESIG_CP_BUFFER      DW   28 DUP(?)     ; (Room for 25 code pages)
DESIG_CP_BUF_LEN     DW   $-DESIG_CP_BUFFER ; Length of code page buffer
NUM_DESIG_CP         DW   0
CP_TAB_OFFSET        DD   ?

;******************  CNS  ******************
TOTAL_SIZE           DW   0
PASS_LANG            DW   0
ID_TAB_OFFSET        DD   ?
;******************  CNS  ******************

STATE_LOGIC_OFFSET   DD   -1
KEYBSYS_FILE_HANDLE  DW   ?
TB_RETURN_CODE       DW   1
DESIG_CP_OFFSET      DW   OFFSET DESIG_CP_BUFFER
SYS_CODE_PAGE        DW   0
DESIG_LIST           DW   0
QUERY_CALL           DB   0

KB_MASK              EQU  02h

SIGNATURE            DB   0FFh,'KEYB   '
SIGNATURE_LENGTH     DW   8

;******************  CNS  ***************************
NUM_ID               DW   0
ERR4ID               DB   0
NUM_LANG             DW   0
NUM_CP               DW   0
ID_PTR_SIZE          DW   SIZE KEYBSYS_ID_PTRS
;******************  CNS  ***************************

LANG_PTR_SIZE        DW   SIZE KEYBSYS_LANG_PTRS
CP_PTR_SIZE          DW   SIZE KEYBSYS_CP_PTRS
KEYBCMD_LANG_ENTRY_PTR DD ?

KEYB_INSTALLED       DW   0
CON_INSTALLED        DW   0
SHARED_AREA_PTR      DD   0
GOOD_MATCH           DW   0

;******************  CNS  ***************************;
LANGUAGE_ASCII       DB   '??',0

CMD_PARM_LIST        PARM_LIST <>

;----------  TABLES FOR EXTENDED KEYBOARD SUPPORT CTRL CASE  ---------


RPL_K8  LABEL   BYTE                    ;-------- CHARACTERS ---------
        DB      27,-1,00,-1,-1,-1       ; Esc, 1, 2, 3, 4, 5
        DB      30,-1,-1,-1,-1,31       ; 6, 7, 8, 9, 0, -
        DB      -1,127,148,17,23,5      ; =, Bksp, Tab, Q, W, E
        DB      18,20,25,21,09,15       ; R, T, Y, U, I, O
        DB      16,27,29,10,-1,01       ; P, [, ], Enter, Ctrl, A
        DB      19,04,06,07,08,10       ; S, D, F, G, H, J
        DB      11,12,-1,-1,-1,-1       ; K, L, ;, ', `, LShift
        DB      28,26,24,03,22,02       ; \, Z, X, C, V, B
        DB      14,13,-1,-1,-1,-1       ; N, M, ,, ., /, RShift
        DB      150,-1,' ',-1           ; *, Alt, Space, CL
                                        ;--------- FUNCTIONS ---------
        DB      94,95,96,97,98,99       ; F1 - F6
        DB      100,101,102,103,-1,-1   ; F7 - F10, NL, SL
        DB      119,141,132,142,115,143 ; Home, Up, PgUp, -, Left, Pad5
        DB      116,144,117,145,118,146 ; Right, +, End, Down, PgDn, Ins
        DB      147,-1,-1,-1,137,138    ; Del, SysReq, Undef, WT, F11, F12
L_CTRL_TAB      EQU     $-RPL_K8

;;;;;;;;;;;;;;;;
;    Program Code
;;;;;;;;;;;;;;;;

KEYB_COMMAND  PROC NEAR
        CALL    SYSLOADMSG              ;load messages
        JNC     VERSION_OK              ;if no carry then version ok

        CALL    SYSDISPMSG              ;error..display version error
        MOV     AL,BAD_DOS_VER          ;bad DOS version
        MOV     EXIT_RET_CODE,AL
        JMP     KEYB_EXIT_NOT_RESIDENT  ;exit..non resident

VERSION_OK:
        MOV     SEG_OF_NUMBER,CS        ;initialize..
        MOV     SEG_OF_ASCIIZ,CS        ;  ..sublists
        MOV     BP,OFFSET CMD_PARM_LIST         ;pointer for parm list
        MOV     WORD PTR SHARED_AREA_PTR,ES ; ES segment

KEYB_INSTALL_CHECK:
        MOV     AX,0AD80H               ; KEYB install check
        INT     2FH
        CMP     AL,-1                   ; If flag is not 0FFh THEN
        JE      INSTALLED_KEYB

        MOV     WORD PTR SHARED_AREA_PTR+2,OFFSET TSD
        JMP     short CON_INSTALL_CHECK

INSTALLED_KEYB:
        MOV     KEYB_INSTALLED,1        ; Set KEYB_INSTALLED flag = YES
        MOV     WORD PTR SHARED_AREA_PTR,ES ; Save segment of SHARED_DATA_AREA
        MOV     WORD PTR SHARED_AREA_PTR+2,DI ;Save offset of SHARED_DATA_AREA

        MOV     AX,ES:[DI].KEYB_TYPE
        MOV     HW_TYPE,AX
        MOV     ES:[DI].TABLE_OK,0      ; Do not allow processing
        PUSH    CS                      ;         while building table
        POP     ES                      ; Reset ES until required

CON_INSTALL_CHECK:
        MOV     AX,0AD00H               ; CONSOLE install check
        INT     2FH
        CMP     AL,-1                   ; If flag is not 0FFh THEN
        jnz     call_first_stage

        MOV     CON_INSTALLED,1                 ; Set CON_INSTALLED flag = YES

CALL_FIRST_STAGE:
        PUSH    CS
        POP     ES
        CALL    PARSE_PARAMETERS        ; Validate parameter list

        test    pswitches,1             ; /? option?
        jz      no_help                         ; brif not

        mov     ax,help_1st             ; first help msg
help_loop:
        push    ax
        MOV     BX,STDOUT               ; to standard out
        xor     cx,cx                   ; no replacements
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        LEA     SI,SUBLIST_ASCIIZ       ; ptr to sublist
        CALL    SYSDISPMSG
        pop     ax
        inc     ax
        cmp     ax,help_last
        jbe     help_loop

        mov     exit_ret_code,invalid_parms ; return "invalid parms"
        jmp     KEYB_EXIT_NOT_RESIDENT



no_help:

BEGIN_PARM_CHECK:                       ; CHECK ALL RETURN CODES
        MOV     DL,[BP].RET_CODE_3
        CMP     DL,1                    ; Check for invalid syntax
        JNE     VALID1
        JMP     ERROR3

VALID1:
        MOV     DL,[BP].RET_CODE_1      ; Check for invalid language parm
        CMP     DL,1
        JNE     VALID2
        JMP     ERROR1

VALID2:
        MOV     DL,[BP].RET_CODE_2      ; Check for invalid code page parm
        CMP     DL,1
        JNE     VALID3
        JMP     ERROR2

VALID3:
        MOV     DL,[BP].RET_CODE_1      ; Check for query command
        CMP     DL,2
        JE      QUERY


;******************************* CNS **
        CMP     DL,3                    ; Get a status of the codepage
        JE      QUERY                   ; language, and possible ID code
;******************************* CNS **

        JMP     NOT_QUERY
                                        ; IF QUERY is requested THEN
QUERY:
        MOV     QUERY_CALL,DL
        MOV     AX,KEYB_INSTALLED       ;     If KEYB is installed THEN
        or      ax,ax
        JE      QUERY_CONTINUE1

        MOV     DI,WORD PTR SHARED_AREA_PTR+2   ; Get offset of
        MOV     ES,WORD PTR SHARED_AREA_PTR     ;        shared area
        MOV     BX,WORD PTR ES:[DI].ACTIVE_LANGUAGE ; Get active language
        or      bx,bx                           ; if no language...
        JE      I_MESSAGE                       ;  then id was specified


L_MESSAGE:
        MOV     WORD PTR LANGUAGE_ASCII,BX ; Display Language
        LEA     SI,LANGUAGE_ASCII       ; sublist points to...
        MOV     PTR_TO_ASCIIZ,SI        ; language code asciiz string
        MOV     AX,ACT_KEYB             ; display 'Current keyboard code'
        MOV     BX,STDOUT               ; to standard out
        MOV     CX,1                    ; one replacement
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        LEA     SI,SUBLIST_ASCIIZ       ; ptr to sublist
        CALL    SYSDISPMSG
        JMP     short KEYB_L_FINISHED

I_MESSAGE:
        MOV     BX,WORD PTR ES:[DI].INVOKED_KBD_ID ;  get id code.
        MOV     NUMBER_HOLDER,BX        ;  transfer number to temp loc.
        LEA     SI,NUMBER_HOLDER        ;  sublist points to...
        MOV     PTR_TO_NUMBER,SI        ;  code page word
        MOV     AX,ACT_ID               ;  display 'Current ID:  '
        MOV     BX,STDOUT               ;  to standard out
        MOV     CX,1                    ;  one replacement
        MOV     DH,UTILITY_MSG_CLASS    ;  utility message
        XOR     DL,DL                   ;  no input
        LEA     SI,SUBLIST_NUMBER       ;  ptr to sublist
        CALL    SYSDISPMSG
        MOV     ID_DISPLAYED,1          ;  ID was displayed.
        JMP     short KEYB_L_FINISHED

QUERY_CONTINUE1:
        MOV     AX,INV_KEYB_Q
        MOV     BX,STDOUT               ;  Else
        XOR     CX,CX                   ;   Display message that KEYB
        MOV     DH,UTILITY_MSG_CLASS    ;   has not been installed
        XOR     DL,DL
        CALL    SYSDISPMSG
        JMP     short KEYB_CP_FINISHED

KEYB_L_FINISHED:
        MOV     BX,ES:[DI].INVOKED_CP_TABLE ; Get invoked code page

        MOV     NUMBER_HOLDER,BX        ;  transfer number to temp loc.
        LEA     SI,NUMBER_HOLDER        ;  sublist points to...
        MOV     PTR_TO_NUMBER,SI        ;  code page word
        MOV     AX,ACT_KEYB_CP          ;  display '  code page: '
        MOV     BX,STDOUT               ;  to standard out
        MOV     CX,1                    ;  one replacement
        MOV     DH,UTILITY_MSG_CLASS    ;  utility message
        XOR     DL,DL                   ;  no input
        LEA     SI,SUBLIST_NUMBER       ;  ptr to sublist
        CALL    SYSDISPMSG
        CMP     ID_DISPLAYED,1          ;  was id displayed?
        JE      KEYB_CP_FINISHED        ;  yes..continue.

        MOV     BX,WORD PTR ES:[DI].INVOKED_KBD_ID ;  get id code.
        or      bx,bx                   ;  no id given
        JE      KEYB_CP_FINISHED

        MOV     NUMBER_HOLDER,BX        ;  transfer number to temp loc.
        LEA     SI,NUMBER_HOLDER        ;  sublist points to...
        MOV     PTR_TO_NUMBER,SI        ;  code page word
        MOV     AX,ACT_ID               ;  display 'Current ID:  '
        MOV     BX,STDOUT               ;  to standard out
        MOV     CX,1                    ;  one replacement
        MOV     DH,UTILITY_MSG_CLASS    ;  utility message
        XOR     DL,DL                   ;  no input
        LEA     SI,SUBLIST_NUMBER       ;  ptr to sublist
        CALL    SYSDISPMSG

        MOV     AH,09H                  ;  need a CR_LF here.
        MOV     DX,OFFSET CR_LF
        INT     21H

KEYB_CP_FINISHED:
        MOV     AX,CON_INSTALLED        ;  If CON has been installed THEN
        or      ax,ax
        JNE     GET_ACTIVE_CP
        JMP     short CON_NOT_INSTALLED

GET_ACTIVE_CP:
        MOV     AX,0AD02H               ;  Get active code page
        INT     2FH                     ;   information from the console
        JNC     DISPLAY_ACTIVE_CP
        JMP     ERROR5

DISPLAY_ACTIVE_CP:
        MOV     NUMBER_HOLDER,BX        ; transfer number to temp loc.
        LEA     SI,NUMBER_HOLDER        ; sublist points to...
        MOV     PTR_TO_NUMBER,SI        ; code page word
        MOV     AX,ACT_CON_CP           ; display 'Current CON code page: '
        MOV     BX,STDOUT               ; to standard out
        MOV     CX,1                    ; one replacement
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        LEA     SI,SUBLIST_NUMBER       ; ptr to sublist
        CALL    SYSDISPMSG

        JMP     KEYB_EXIT_NOT_RESIDENT  ;  Exit from Proc

CON_NOT_INSTALLED:                      ; ELSE
        MOV     AX,INV_CON_Q
        MOV     BX,STDOUT               ; Else
        XOR     CX,CX                   ;       Display message that CON does
        MOV     DH,UTILITY_MSG_CLASS    ;         not have active code page
        XOR     DL,DL
        CALL    SYSDISPMSG
        JMP     KEYB_EXIT_NOT_RESIDENT  ; Exit from Proc

NOT_QUERY:                              ; IF not a query function requested
        CALL    BUILD_PATH              ; Determine location of KEYBOARD.SYS
                                        ;  ...and open file.

        JNC     VALID4                  ; If no error in opening file then
        JMP     ERROR4

VALID4:
        MOV     KEYBSYS_FILE_HANDLE,AX  ; Save handle
        MOV     BP,OFFSET CMD_PARM_LIST ; Set base pointer for structures
        MOV     BX,KEYBSYS_FILE_HANDLE  ; Retrieve the file handle
        MOV     DX,OFFSET FILE_BUFFER   ; Set address of buffer

;************************* CNS ********;
        cmp     [BP].RET_CODE_4,ID_VALID ; CNS is there an ID available
        je      ID_TYPED                ; if so go find out if it is
        jmp     short GET_LANG          ; a 1st or 4th parm, if not must
                                        ; must be a language
ID_TYPED:

        call    SCAN_ID                         ; scan the table for the ID
        cmp     ID_FOUND,1              ; if a legal ID check and see if
        jne     LOST_ID                         ; it is a first or fourth parm

        cmp     FTH_PARMID,1            ; if it is a fourth parm go
        je      GET_ID                  ; check for language compatibility
        jmp     short Language_found    ; otherwise it must be a first
                                        ; parm id value

LOST_ID:                                ; otherwise must be a bogus match
                                        ; between language and ID codes
                                        ;  or the ID code does not exist
        jmp     ERR1ID                  ; in the table
;************************* CNS ***********;

GET_LANG:                                ; Must be a language/or a 1st parm ID


        XOR     DI,DI                   ; Set number
        LEA     CX,[DI].KH_NUM_LANG+2   ;        bytes to read header

        MOV     AH,3FH                  ; Read header of the Keyb Def file
        INT     21H
        JNC     VALID5                  ; If no error in opening file then
        JMP     ERROR4

VALID5:
        CLD                             ;  all moves/scans forward
        MOV     CX,SIGNATURE_LENGTH
        MOV     DI,OFFSET SIGNATURE     ; Verify matching
        MOV     SI,OFFSET FB.KH_SIGNATURE ;          signatures
        REPE    CMPSB
        JE      LANGUAGE_SPECIFIED
        JMP     ERROR4
                                        ; READ the language table
LANGUAGE_SPECIFIED:
        MOV     AX,FB.KH_NUM_LANG
        MOV     NUM_LANG,AX             ; Save the number of languages
        MUL     LANG_PTR_SIZE           ; Determine # of bytes to read
        MOV     DX,OFFSET FILE_BUFFER   ; Establish beginning of buffer
        MOV     CX,AX
        CMP     CX,SIZE FILE_BUFFER     ; Make sure buffer is not to small
        JBE     READ_LANG_TAB
        JMP     ERROR4

READ_LANG_TAB:
        MOV     AH,3FH                  ; Read language table from
        INT     21H                     ;              Keyb Def file
        JNC     READ_VALID              ; If no error in opening file then
        JMP     ERROR4                  ; Else display ERROR message

READ_VALID:
        MOV     CX,NUM_LANG             ;    Number of valid codes
        MOV     DI,OFFSET FILE_BUFFER   ;    Point to correct word in table

SCAN_LANG_TABLE:                        ; FOR language parm
        MOV     AX,[BP].LANGUAGE_PARM   ;    Get parameter
        CMP     [DI].KP_LANG_CODE,AX    ;    Valid Code ??
        JE      LANGUAGE_FOUND          ; If not found AND more entries THEN

        ADD     DI,LANG_PTR_SIZE        ;         Check next entry
        DEC     CX                      ;    Decrement count of entries
        JNE     SCAN_LANG_TABLE                 ; Else
        JMP     ERROR1                  ;    Display error message

;**************************** CNS ****
GET_ID:                                 ; CNS - Must be an ID value
        mov     cx,1                    ; initialize ctr value for # of ids

SEARCH_ID:                              ; minimum per country
;                                       ; There is atleast 1 ID for each country
        or      cx,cx                   ; check for any more IDs left to check
        jne     FINDID                  ; Country has more than one ID check
        jmp     END_IDCHK               ; Country & ID has been found or value
                                        ; is zero
FINDID:

        push    di                      ; save the current language entry ptr
        push    cx                      ; save the minimum # of ids before
                                        ; reading the table data from the disk
;**************************** CNS ***********

LANGUAGE_FOUND:
        MOV     CX,WORD PTR [DI].KP_ENTRY_PTR+2         ; Get offset of lang entry
        MOV     DX,WORD PTR [DI].KP_ENTRY_PTR   ;       in the Keyb Def file
        MOV     WORD PTR KEYBCMD_LANG_ENTRY_PTR,DX ; Save
        MOV     WORD PTR KEYBCMD_LANG_ENTRY_PTR+2,CX ;  offset
        MOV     AH,42H                          ; Move file pointer to
        MOV     AL,0                            ;  location of language
        INT     21H                             ;  entry
        JNC     LSEEK_VALID
        JMP     ERROR4

LSEEK_VALID:
        MOV     DI,AX
        MOV     CX,SIZE KEYBSYS_LANG_ENTRY-1    ; Set number
                                                ;  bytes to read header
        MOV     DX,OFFSET FILE_BUFFER
        MOV     AH,3FH                  ; Read language entry in
        INT     21H                     ;  Keyb Def file
        JNC     VALID6a                         ; If no error in file then
        JMP     ERROR4

;**************************** CNS **********************************************


valid6a:
        cmp     FOURTH_PARM,1           ; Is the ID a 4th Parm
        jne     VALID6                  ; if not get out of routine, otherwise
        pop     cx                      ; restore # of ids for the country
                                        ; Check to see if this is the first
                                        ; time checking the primary ID
        cmp     cx,1                    ; if there is just one ID check to make
        jne     CHK4PARM                ; sure both flags are not set
                                        ; this should not be necessary w/ new parser

        cmp     FTH_PARMID,1            ; is the ID flag for switch set
        jne     CHK1N4                  ; is the flag set only for the 4th
        cmp     FOURTH_PARM,1           ; if set only for the switch proceed
        jne     CHK1N4                  ; if not must be a positional
        mov     cl,fb.kl_num_id                 ; get the number of IDs available from the table
        mov     FTH_PARMID,0            ; turn switch flag off so the table
                                        ; counter will not be reset

                                        ;ids available for the
CHK1N4:                                 ;country
        cmp     ONE_PARMID,1            ; this was to be done if
        jne     CHK4PARM                ; two the positional
        cmp     FOURTH_PARM,0           ; and switch was specified
        jne     CHK4PARM                ; this should never happen

        pop     di                      ; if the parser is intact
        jmp     error3                  ; report error & exit

CHK4PARM:                               ; check on the first ID
        cmp     FOURTH_PARM,1           ; ID was a switch
        jne     ABORT_LOOP              ; otherwise get out of routine
        call    IDLANG_CHK              ; check the ID
        jmp     short ADVANCE_PTR       ; advance to the next position

ABORT_LOOP:
        xor     cx,cx                   ; end loop

ADVANCE_PTR:
        pop     di                      ;restore entry value

        dec     cx                      ; # of ids left to check
        je      NO_ADVANCE              ; if 0, don't advance table position
        cmp     GOOD_MATCH,1            ; check to see if ID matched language
        je      NO_ADVANCE              ; if equal do not advance

        add     di,LANG_PTR_SIZE        ; step to the next entry
                                        ; in the table

NO_ADVANCE:

        jmp     SEARCH_ID               ; for the country

;                                       ; end of ID check for country

END_IDCHK:

        cmp     FOURTH_PARM,1           ; see if id was found
        jne     VALID6
        cmp     GOOD_MATCH,0            ; none found
        jne     VALID6                  ; report error

        mov     [bp].ret_code_4,1       ; incompatible lang code
        mov     al,[bp].ret_code_4      ; id combo
        jmp     err2id

                                        ; otherwise found it
                                        ; continue to build tbl
;**************************** CNS **********************************************

VALID6:
        MOV     AX,WORD PTR FB.KL_LOGIC_PTR     ; Save the offset of the state
        MOV     WORD PTR STATE_LOGIC_OFFSET,AX  ;    logic section
        MOV     AX,WORD PTR FB.KL_LOGIC_PTR+2   ; Save the offset of the state
        MOV     WORD PTR STATE_LOGIC_OFFSET+2,AX ;   logic section

        MOV     DL,[BP].RET_CODE_2      ; IF code page was specified
        CMP     DL,2
        JNE     CODE_PAGE_SPECIFIED
        JMP     short DONE

CODE_PAGE_SPECIFIED:                  ;  Then

;************************** CNS ***************************************
        xor     ah,ah
        MOV     Al,FB.KL_NUM_CP
;************************** CNS ***************************************

        MOV     NUM_CP,AX               ; Save the number of code pages
        MUL     CP_PTR_SIZE             ; Determine # of bytes to read
        MOV     DX,OFFSET FILE_BUFFER   ; Establish beginning of buffer
        MOV     CX,AX
        CMP     CX,SIZE FILE_BUFFER     ; Make sure buffer is not to small
        JBE     VALID7
        JMP     ERROR4

VALID7:
        MOV     AH,3FH                  ; Read code page table from
        INT     21H                     ;       Keyb Def file
        JNC     VALID8                  ; If no error in opening file then
        JMP     ERROR4

VALID8:
        MOV     CX,NUM_CP               ;    Number of valid codes
        MOV     DI,OFFSET FILE_BUFFER   ;    Point to correct word in table

SCAN_CP_TABLE:                          ; FOR code page parm
        MOV     AX,[BP].CODE_PAGE_PARM  ;    Get parameter
        CMP     [DI].KC_CODE_PAGE,AX    ;    Valid Code ??
        JE      CODE_PAGE_FOUND                 ; If not found AND more entries THEN

        ADD     DI,CP_PTR_SIZE          ;    Check next entry
        DEC     CX                      ;    Decrement count of entries
        JNE     SCAN_CP_TABLE           ; Else
;;; if we can not find the CP, simply use the first one available for
;;; the language. This was done for NT because users can not really specified
;;; the code page id via KEYB.COM. By using the first CP, we maintain the
;;; compatibility with dos(keyb gr will succeed even the currnt code page is
;;; invalid for German layout
;;;
ifdef NOT_NTVDM
       JMP	 ERROR2 		 ;    Display error message
else
	mov	cx, 1
	mov	NUM_DESIG_CP, cx
	mov	[si].NUM_DESIGNATES, cx
	jmp	short SET_TO_SYSTEM_CP

endif

CODE_PAGE_FOUND:
        MOV     AX,WORD PTR [DI].KC_ENTRY_PTR
        MOV     WORD PTR CP_TAB_OFFSET,AX
        MOV     AX,WORD PTR [DI].KC_ENTRY_PTR+2
        MOV     WORD PTR CP_TAB_OFFSET+2,AX

DONE:
        MOV     SI,OFFSET DESIG_CP_BUFFER

        MOV     AX,CON_INSTALLED        ;  If CON is NOT installed THEN
        or      ax,ax
        JE      SYSTEM_CP
        JMP     short GET_DESIG_CPS

SYSTEM_CP:
        MOV     CX,1
        MOV     NUM_DESIG_CP,CX                 ; Set number of CPs = 1
        MOV     [SI].NUM_DESIGNATES,CX

        MOV     DL,[BP].RET_CODE_2      ; Check if code page parm
        or      dl,dl                   ;    was specified
        JNE     SET_TO_SYSTEM_CP

        MOV     DX,[BP].CODE_PAGE_PARM
        MOV     [SI].DESIG_CP_ENTRY,DX  ; Load specified code page into
        JMP     READY_TO_BUILD_TABLE    ;      designated code page list

SET_TO_SYSTEM_CP:
        CALL    FIND_FIRST_CP           ; Call routine that sets the first
        or      ax,ax                   ;   table found in the Keyb Def file
        JE      SET_TO_SYSTEM_CP2       ;       to the system code page
        JMP     ERROR4

SET_TO_SYSTEM_CP2:
        MOV     SYS_CODE_PAGE,BX
        MOV     [BP].CODE_PAGE_PARM,BX
        MOV     [SI].DESIG_CP_ENTRY,BX  ;    Move sys CP into desig list
        JMP     READY_TO_BUILD_TABLE

GET_DESIG_CPS:                          ;  ELSE
        MOV     AX,0AD03H
        PUSH    CS                      ; Make sure ES is set
        POP     ES
        LEA     DI,DESIG_CP_BUFFER
        MOV     CX,DESIG_CP_BUF_LEN
        INT     2FH                     ; Get all designated code pages
        JNC     SET_DESIG_VARIABLES     ;  from console
        JMP     ERROR5

SET_DESIG_VARIABLES:
        MOV     CX,[SI].NUM_DESIGNATES
        ADD     CX,[SI].NUM_HW_CPS
        MOV     NUM_DESIG_CP,CX                 ; Set number of Designated CPs

BUFFER_CREATED:
        MOV     AX,0AD02H
        INT     2FH                     ; Get invoked code page

SET_TO_CP_INVOKED:
        MOV     DL,[BP].RET_CODE_2      ; IF code page parm was specified
        or      dl,dl
        JNE     SET_TO_INVOKED_CP

        MOV     CX,NUM_DESIG_CP
        MOV     DESIG_LIST,SI
        JMP     short TEST_IF_DESIGNATED

SET_TO_INVOKED_CP:
        CMP     AX,1                    ; IF a code page has been invoked
        JNE     SET_TO_INVOKED_CP3

        CALL    FIND_FIRST_CP           ; Call the routine that sets the
        or      ax,ax                   ; first code page in the Keyb Def
        JE      SET_TO_INVOKED_CP2      ;  file to the system code page
        JMP     ERROR4

SET_TO_INVOKED_CP2:
        MOV     [BP].CODE_PAGE_PARM,BX
        MOV     SYS_CODE_PAGE,BX

        JMP     short TEST_IF_DESIGNATED

SET_TO_INVOKED_CP3:
        MOV     [BP].CODE_PAGE_PARM,BX

TEST_IF_DESIGNATED:
        MOV     DX,[BP].CODE_PAGE_PARM
        CMP     [SI].DESIG_CP_ENTRY,DX  ; Is Code page specified in the list
        JE      CODE_PAGE_DESIGNATED    ;   of designated code pages ?

NEXT_DESIG_CP:
        ADD     SI,2                    ; Check next code page
        DEC     CX                      ; If all designated code pages have
        JNZ     TEST_IF_DESIGNATED      ;   been checked Then ERROR
        JMP     ERROR6

CODE_PAGE_DESIGNATED:
        CMP     SYS_CODE_PAGE,0
        JNE     READY_TO_BUILD_TABLE
        CMP     AX,1                    ; IF a code page has been invoked
        JE      READY_TO_BUILD_TABLE
        CMP     [BP].CODE_PAGE_PARM,BX  ; IF Invoked CP <> Specified CP
        JE      READY_TO_BUILD_TABLE    ;        Issue warning

;***************************************************************************
        PUSH    BX
        PUSH    CX
        MOV     AX,WARNING_1
        MOV     BX,STDOUT
        XOR     CX,CX
        MOV     DH,UTILITY_MSG_CLASS
        XOR     DL,DL
        CALL    SYSDISPMSG
        POP     CX
        POP     BX
;***************************************************************************


READY_TO_BUILD_TABLE:

        MOV     AX,KEYB_INSTALLED
        or      ax,ax                   ; Else if KEYB has not been installed
        JNE     BUILD_THE_TABLE

        CALL    FIND_SYS_TYPE           ; Determine system type for INT 9 use

;------ LOAD IN SPECIAL INT 9 HANDLER AND SPECIAL TABLES

        CALL    INSTALL_INT_9           ; Install INT 9

        CALL    FIND_KEYB_TYPE          ; Determine keyboard type table use

BUILD_THE_TABLE:
        CALL    TABLE_BUILD             ; Build the TEMP_SHARED_DATA_AREA

CHECK_ERRORS:
                                        ; Take appropriate action considering
        MOV     CX,TB_RETURN_CODE       ;  return codes from TABLE_BUILD
        jcxz    CHECK_FOR_INV_CP        ; If return code is not 0

        MOV     AX,KEYB_INSTALLED       ; If KEYB has not been installed,
        or      ax,ax
        JNE     CHECK_ERROR_CONTINUE

        CALL    REMOVE_INT_9            ;     remove installed vector

CHECK_ERROR_CONTINUE:
        CMP     CX,1                    ; If return code = 1
        JNE     CHECK_ERROR2
        JMP     ERROR1                  ;     display error message

CHECK_ERROR2:
        CMP     CX,2                    ; If return code = 2
        JNE     CHECK_ERROR3
        JMP     ERROR2

CHECK_ERROR3:
        CMP     CX,3                    ; If return code = 3
        JNE     CHECK_ERROR4
        JMP     ERROR3                  ;     display error message

CHECK_ERROR4:
        CMP     CX,4                    ; If return code = 4
        JNE     CHECK_ERROR5A
        JMP     ERROR4                  ;     display error message

CHECK_ERROR5A:
        CMP     CX,5                    ; If return code = 5
        JNE     CHECK_ERROR6A
        JMP     ERROR5A                         ;     display error message

CHECK_ERROR6A:
        JMP     ERROR6A                         ; If return code not 0,1,2,3,4 then
                                        ;      display error message
CHECK_FOR_INV_CP:
        MOV     CX,CPN_INVALID          ; Check if any CPs were not loaded
        jcxz    TERMINATE               ;   If some were invalid, issue
                                        ;       warning message

;***************************************************************************
        PUSH    BX
        PUSH    CX
        MOV     AX,NOT_SUPP
        MOV     BX,STDOUT               ;  WARNING
        XOR     CX,CX                   ;   MESSAGE
        MOV     DH,UTILITY_MSG_CLASS
        XOR     DL,DL
        CALL    SYSDISPMSG
        POP     CX
        POP     BX
;***************************************************************************

TERMINATE:
        MOV     AH,3EH                  ;  Close the KEYBOARD.SYS file
        MOV     BX,KEYBSYS_FILE_HANDLE  ;  if open
        or      bx,bx
        JE      KEYB_EXIT
        INT     21H

        MOV     AX,KEYB_INSTALLED
        or      ax,ax
        JE      KEYB_EXIT
        JMP     KEYB_EXIT_NOT_RESIDENT

KEYB_EXIT:
        TEST    SD.KEYB_TYPE,G_KB       ; Q..FERRARI G??
        JZ      NO_FERRARI_G            ; N..LEAVE NUMLK ALONE
        TEST    SD.SYSTEM_FLAG,PC_XT    ;   Q..PC/XT?
        JNZ     NO_FERRARI_G            ;   Y..LEAVE NUMLK ALONE
        TEST    SD.KEYB_TYPE,P_KB       ;      Q..FERRARI P??
        JNZ     NO_FERRARI_G            ;      Y..LEAVE NUMLK ALONE

;***CNS
        CMP     SECURE_FL,1             ; IF SECURITY FLAG SET
        JNE     NO_FERRARI_G            ; DON'T TURN ON NUM_LK

;***CNS
        CALL    NUMLK_ON                ;    N..TURN NUMLK ON

NO_FERRARI_G:
        TEST    SD.SYSTEM_FLAG,EXT_16   ; extended INT 16 support?
        JZ      SKIP_CTRL_COPY
                                       ; Yes, load extened CTRL case table

        MOV     CX,L_CTRL_TAB          ; CX = LENGTH OF EXTENDED TABLE
        MOV     SI,OFFSET CS:RPL_K8    ; POINT TO EXT. CTRL TABLES
        MOV     DI,OFFSET CS:K8        ; POINT TO REGULAR CTRL TABLE
        CLD
        REP     MOVSB                  ; OVERLAY WITH EXT. CTRL TABLE

SKIP_CTRL_COPY:
        CALL    INSTALL_INT_9_NET       ; Let the network know about INT 9
                                        ;     (if the network is installed)
        CALL    INSTALL_INT_2F          ; Install INT 2F

        MOV     AX,0AD82H               ; Activate language
        MOV     BL,-1
        INT     2FH

        MOV     AH,31H                  ; Function call to terminate but stay
        XOR     AL,AL                   ;   resident
        MOV     DI,OFFSET SD_DEST_PTR   ; Initialize destination ptr

        MOV     DX,ES:TSD.RESIDENT_END  ; Get resident end

        CALL    COPY_SDA_SETUP          ; Set up move common code

        JMP     COPY_SD_AREA            ; Jump to proc that copies area in new
                                        ;       part of memory

;***************************** CNS **************************************
ERR1ID:
;************************************************************************

        MOV     AX,INV_I                ; invalid ID message
        MOV     BX,STDOUT               ;  to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,INVALID_PARMS
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     KEYB_EXIT_NOT_RESIDENT
ERR2ID:
;***************************************************************************

        MOV     AX,INV_COMBO            ; invalid combination message
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,INVALID_PARMS
        MOV     EXIT_RET_CODE,AL

;**************************************************************************
        JMP     KEYB_EXIT_NOT_RESIDENT
;***************************** CNS ****************************************

ERROR1:
;***************************************************************************
        MOV     AX,INV_L                ; invalid language code
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message

        MOV     AL,INVALID_PARMS
        MOV     EXIT_RET_CODE,AL
;***************************************************************************

        JMP     KEYB_EXIT_NOT_RESIDENT
ERROR2:
;***************************************************************************
        MOV     AX,INV_CP               ; invalid code page message
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message

        MOV     AL,INVALID_PARMS
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     KEYB_EXIT_NOT_RESIDENT
ERROR3:
;***************************************************************************

        MOV     AX,INV_S                ; invalid syntax message
        MOV     BX,STDOUT               ; to standard out
;***CNS

        LEA     DI,STRING_HOLDER        ;Set PTR to look at the STRING
        PUSH    SI                      ;Save current SI index
        PUSH    AX
        MOV     AX,OLD_PTR              ;Last locale of the end of a PARAM
        SUB     CUR_PTR,AX              ;Get the length via the PSP
        MOV     SI,CUR_PTR
        MOV     CX,SI                   ;Save it in CX to move in the chars
        POP     AX                      ;Restore the PTR to the command line position

        MOV     SI,OLD_PTR              ;Last locale of the end of a PARAM
        REP     MOVSB                   ;Move in the chars until no more

        LEA     DI,STRING_HOLDER        ;Set PTR to look at the STRING


        POP     SI                      ;Restore the PTR to the command line position

        MOV     CX,1                    ;One replacement
        MOV     PTR_TO_COMLIN,DI        ; language code asciiz string


        PUSH    AX
        MOV     AX,DS                   ; language code asciiz string
        MOV     SEG_OF_COMLIN,AX
        POP     AX

        MOV     AX,ERR_PART
ifdef	BILINGUAL
	or	ax,ax
	jnz	ERR03_GO
	mov	ax,8			; Value Disallow
ERR03_GO:
endif
        LEA     SI,SUBLIST_COMLIN
        MOV     DH,PARSE_ERR_CLASS      ; parse error message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,INVALID_PARMS
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     short KEYB_EXIT_NOT_RESIDENT
ERROR4:
;***************************************************************************

        MOV     AX,INV_FN               ; bad or missing file message
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,BAD_KEYB_DEF_FILE
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     short KEYB_EXIT_NOT_RESIDENT
ERROR5:
;***************************************************************************

        MOV     AX,INV_CON_Q            ; CON code page not available.
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,CONSOLE_ERROR
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     short KEYB_EXIT_NOT_RESIDENT
ERROR5A:
;***************************************************************************

        MOV     AX,MEMORY_OVERF                 ; not enough resident memory.
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,MEMORY_OVERFLOW
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     short KEYB_EXIT_NOT_RESIDENT
ERROR6:
;***************************************************************************

        MOV     AX,NOT_DESIG            ; code page not prepared.
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,CP_NOT_DESIGNATED
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     short KEYB_EXIT_NOT_RESIDENT
ERROR6A:
;***************************************************************************

        MOV     NUMBER_HOLDER,BX        ; transfer number to temp loc.
        LEA     SI,NUMBER_HOLDER        ; sublist points to...
        MOV     PTR_TO_NUMBER,SI        ; code page word
        MOV     AX,NOT_VALID            ; display 'Code page requested....'
        MOV     BX,STDOUT               ; to standard out
        MOV     CX,1                    ; one replacement
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        LEA     SI,SUBLIST_NUMBER       ; ptr to sublist
        CALL    SYSDISPMSG

        MOV     AL,KEYB_TABLE_NOT_LOAD
        MOV     EXIT_RET_CODE,AL

;***************************************************************************

KEYB_EXIT_NOT_RESIDENT:
        MOV     AH,04CH
        MOV     AL,QUERY_CALL           ; Check if this was a query call
        or      al,al
        JNE     KEYB_EXIT3              ;  IF yes then EXIT

        MOV     AL,EXIT_RET_CODE        ; Check if return code was valid
        or      al,al
        JNE     KEYB_EXIT3              ;  IF not then EXIT

COPY_INTO_SDA:
        MOV     AX,0AD82H               ; Activate language
        MOV     BL,-1
        INT     2FH

        MOV     AH,04CH
        MOV     AL,EXIT_RET_CODE
        MOV     DI,WORD PTR SHARED_AREA_PTR+2   ; Initialize destination ptr
        MOV     ES,WORD PTR SHARED_AREA_PTR
        MOV     DX,[BP].RESIDENT_END

        CALL    COPY_SDA_SETUP         ; Set up move common code

        JMP     COPY_SD_AREA           ; Jump to proc that copies area in new

KEYB_EXIT3:
        MOV     AL,EXIT_RET_CODE
        MOV     DI,WORD PTR SHARED_AREA_PTR+2   ; Initialize destination ptr
        MOV     ES,WORD PTR SHARED_AREA_PTR
        MOV     ES:[DI].TABLE_OK,1
        INT     21H

KEYB_COMMAND  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: COPY_SDA_SETUP
;
; Description:
;     Common setup logic for exit
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_SDA_SETUP  PROC    NEAR

        push    ax                      ;save existing values
        push    es
        mov     ax,cs:[2ch]             ;check offset for address containin environ.
        or      ax,ax
        je      NO_FREEDOM

        mov     es,ax
        mov     ax,4900H                ;make the free allocate mem func
        int     21h

NO_FREEDOM:
        pop     es                      ;restore existing values
        push    bx
                                        ;Terminate and stay resident
        mov     bx,4                    ;1st close file handles
                                        ;STDIN,STDOUT,STDERR
closeall:
        mov     ah,3eh
        int     21h
        dec     bx
        jnz     closeall

        pop     bx
        pop     ax

        MOV     CL,4                    ; Convert into paragrahs
        SHR     DX,CL
        INC     DX

        MOV     SI,OFFSET SD_SOURCE_PTR         ; Initialize source ptr
        XOR     BP,BP
        LEA     BX,[BP].ACTIVE_LANGUAGE
        ADD     DI,BX                   ; Adjust for portion not copied
        ADD     SI,BX                   ; Adjust for portion not copied

        MOV     CX,SD_LENGTH            ; Set length of SHARED_DATA_AREA
        SUB     CX,BX                   ; Adjust for portion not copied

        RET

COPY_SDA_SETUP  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: NUMLK_ON
;
; Description:
;     Turn  Num Lock On.
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;     Set Num Lock bit in BIOS KB_FLAG
;     Issue Int 16 to update lights
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NUMLK_ON     PROC

        PUSH    ES
        PUSH    AX

        MOV     AX,DATA
        MOV     ES,AX

        OR      ES:KB_FLAG,NUM_STATE    ; Num Lock state active
        MOV     AH,1                    ; Issue keyboard query call to
        INT     16H                     ;  have BIOS update the lights

        POP     AX
        POP     ES
        RET

NUMLK_ON   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_9
;
; Description:
;     Install our INT 9 driver.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;       Get existing vector
;       Install our vector
;       Return
;

INSTALL_INT_9        PROC

        PUSH    ES

        MOV     AH,35H                  ; Get int 9 vector
        MOV     AL,9
        INT     21H                     ; Vector in ES:BX

        PUSH    ES                      ; Save segment ES:
        PUSH    CS
        POP     ES
        MOV     WORD PTR ES:SD.OLD_INT_9,BX ; Offset
        POP     AX                      ; Recover ES: segment
        MOV     WORD PTR ES:SD.OLD_INT_9+2,AX ; Segment

        MOV     AH,25H
        MOV     AL,9
        MOV     DX,OFFSET KEYB_INT_9    ; Let DOS know about our handler
        INT     21H

        POP     ES
        RET

INSTALL_INT_9        ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_9_NET
;
; Description:
;
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;       IF network is installed THEN
;         Let it know about our INT 9
;       Return
;

INSTALL_INT_9_NET    PROC

        PUSH    ES

        TEST    SD.SYSTEM_FLAG,PC_NET   ; TEST FOR PC_NETWORK
                                        ; IF NOT THE NETWORK INSTALLED
        JZ      INSTALL_9_DONE_NET      ; SKIP THE PC NETWORK HANDSHAKE

                                        ; ES:BX TO CONTAIN INT 9 ADDR
        MOV     BX,OFFSET KEYB_INT_9
        MOV     AX,0B808H               ; FUNCTION FOR PC NETWORK TO INSTALL
                                        ; THIS ADDRESS FOR THEIR JUMP TABLE
        INT     2FH                     ; TELL PC_NET TO USE MY ADDR TO CHAIN TO

INSTALL_9_DONE_NET:
        POP     ES
        RET

INSTALL_INT_9_NET    ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_2F
;
; Description:
;     Install our INT 2F drivers.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;       Get existing vectors
;       Install our vectors
;       Return
;
;
INSTALL_INT_2F    PROC

        MOV     AH,35H                  ; Get int 2f vector
        MOV     AL,2FH
        INT     21H                     ; Vector in ES:BX

        PUSH    ES                      ; Save segment ES:
        PUSH    CS
        POP     ES
        MOV     WORD PTR ES:SD.OLD_INT_2F,BX ; Offset
        POP     AX                      ; Recover ES: segment
        MOV     WORD PTR ES:SD.OLD_INT_2F+2,AX ; Segment

        MOV     AH,25H                  ; Set int 9 vector
        MOV     AL,2FH
        MOV     DX,OFFSET KEYB_INT_2F   ; Vector in DS:DX
        INT     21H


        RET

INSTALL_INT_2F    ENDP

;
;
; Module: REMOVE_INT_9
;
; Description:
;     Remove our INT 9 driver.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;       Get old vector
;       Install old vector
;       Return
;

REMOVE_INT_9        PROC

        PUSH    DS
        PUSH    ES
        MOV     ES,WORD PTR SHARED_AREA_PTR
        MOV     AX,WORD PTR ES:SD.OLD_INT_9+2   ; int 9 vector - segment
        MOV     DS,AX
        MOV     DX,WORD PTR ES:SD.OLD_INT_9     ; int 9 vector - offset

        MOV     AH,25H                  ; Set int 9 vector
        MOV     AL,9
        INT     21H

REMOVE_9_DONE:
        POP     ES
        POP     DS
        RET

REMOVE_INT_9             ENDP



IDLANG_CHK      PROC    NEAR

        mov     ax,fb.kl_id_code        ;get the id code from the table
        cmp     ax,[bp].id_parm         ;compare it to value taken
        jne     end_match               ;from the switch-- if found
        cmp     ALPHA,0                 ;a keyboard code was specified
        je      a_match                 ;no lang & a match

        mov     ax,fb.kl_lang_code      ;compare lang codes
        cmp     ax,[BP].LANGUAGE_PARM   ;they are equal
        je      a_match

        jmp     short end_match                 ;if not found go check next
                                        ;id for the same country

a_match:
        mov     good_match,1            ;report the ids match

end_match:
        ret

    IDLANG_CHK  ENDP
;*********************** CNS *******************;

;**********************************SCAN_ID***********************;
; New variables defined - NUM_ID,ADRSS_LANG,ID_PTR_SIZE,ID_FOUND
;****************************************************************;


SCAN_ID PROC    NEAR

        xor     di,di                   ;clear di to set at the
                                        ;beginning of KEYBSYS STRUCTURE


        lea     cx,[di].kh_num_ID+4     ; set number of bytes to read header

        mov     ah,3fh
        int     21h
        jnc     VAL5ID
        jmp     short BAD_TAB            ;bad table message

 VAL5ID:

        mov     cx,SIGNATURE_LENGTH
        mov     di,offset SIGNATURE
        mov     si,offset FB.KH_SIGNATURE
        repe    CMPSB
        je      ID_SPECIFIED
        jmp     short BAD_TAB



 ID_SPECIFIED:

        mov     ax,FB.KH_NUM_ID
        mov     NUM_ID,ax               ; save # of IDs
        mul     ID_PTR_SIZE             ; determine # of bytes to read
        push    ax                      ; save current # of bytes to read for
                                        ; ID values only
        mov     ax,FB.KH_NUM_LANG       ; add on lang data in table
        mul     LANG_PTR_SIZE           ; data that comes before the ID data
        mov     cx,ax                   ; save that value for the size compare
        mov     PASS_LANG,cx
        pop     ax                      ; restore the info for # of ID bytes to read

        add     cx,ax                   ; add that value to get total in CX
        mov     TOTAL_SIZE,cx           ; save the total size
        cmp     cx,size FILE_BUFFER
        jbe     READ_ID_TAB
        jmp     short BAD_TAB


READ_ID_TAB:
        mov     dx,offset FILE_BUFFER
        mov     ah,3fh                  ;read language table from
        int     21h                     ;keyb defn file
        jnc     READ_IDVAL
        jmp     short BAD_TAB

READ_IDVAL:

        mov     cx,NUM_ID
        mov     di,offset FILE_BUFFER
        add     di,PASS_LANG

SCAN_ID_TAB:

        mov     ax,[bp].ID_PARM
        cmp     [di].KP_ID_CODE,ax
        je      ID_HERE

        add     di,ID_PTR_SIZE
        dec     cx
        jne     SCAN_ID_TAB

        jmp     short FINALE

BAD_TAB:
        mov     ERR4ID,1
        jmp     short FINALE

ID_HERE:
        mov     ID_FOUND,1              ;reset ptr for
                                        ;current country
FINALE:
        ret

SCAN_ID         ENDP

;*******************************SCAN_ID END******;
;
; Module: BUILD_PATH
;
; Description:
;     Build the complete filename of the Keyboard Definition File
;*************************************WGR*********************
;     and open the file.
;+++++++++++++++++++++++++++++++++++++WGR+++++++++++++++++++++
;
; Input Registers:
;     DS - points to our data segment
;     ES - points to our data segment
;     BP - offset of parmeter list
;
; Output Registers:
;************************************WGR**********************
;     CARRY CLEAR
;           AX = HANDLE
;     CARRY SET (ERROR)
;           NONE
;++++++++++++++++++++++++++++++++++++WGR++++++++++++++++++++++
;    The complete filename will be available in FILE_NAME
;
; Logic:
;
;    Determine whether path parameter was specified
;    IF length is zero THEN
;****************************************WGR******************
;       Try to open file in ACTIVE directory
;       IF failed THEN
;         Try to open file in ARGV(0) directory
;         IF failed THEN
;           Try to open file in ROOT directory (for DOS 3.3 compatibility)
;           ENDIF
;         ENDIF
;       ENDIF
;    ELSE
;       Copy path from PSP to FILE_NAME memory area
;       Try to open USER SPECIFIED file
;++++++++++++++++++++++++++++++++++++++++WGR++++++++++++++++++
;
;

KEYBOARD_SYS    DB   '\KEYBOARD.SYS',00
KEYB_SYS_ACTIVE DB   'KEYBOARD.SYS',00
KEYB_SYS_LENG   EQU  14
KEYB_SYS_A_LENG EQU  13

ifdef JAPAN
PUBLIC          FILE_NAME
endif ; JAPAN
FILE_NAME       DB   128 DUP(0)
ifdef JAPAN
PUBLIC     keyb_table
keyb_table label byte             ; keyboard definition file search table
;               len  driver name sub type
           db    9, 'KEYAX.SYS', 1
           db    9, 'KEY01.SYS', 2
           db    9, 'KEY02.SYS', 3
           db    10,'KEYJ31.SYS',4
           db    0
endif ; JAPAN
FILE_NOT_FOUND  EQU  2
PATH_NOT_FOUND  EQU  3
;
;  Program Code
;

BUILD_PATH    PROC  NEAR

        CLD
        MOV     DI,OFFSET FILE_NAME     ; Get the offset of the filename
        MOV     CX,[BP].PATH_LENGTH     ; If path is specified then
        jcxz    APPEND_KEYB_SYS

        MOV     SI,[BP].PATH_OFFSET     ;   Get the offset of the path

        REPE    MOVSB                   ;   Copy each char of the specified

        MOV     AX,3D00H                ; Open the KEYBOARD.SYS file
        MOV     DX,OFFSET FILE_NAME
        INT     21H
        RET                             ;   path into the filename location

APPEND_KEYB_SYS:
        MOV     SI,OFFSET KEYB_SYS_ACTIVE ;  copy name for active directory
        MOV     CX,KEYB_SYS_A_LENG      ;  to file name variable.
        REPE    MOVSB

        MOV     AX,3D00H                ; try to open it.
        MOV     DX,OFFSET FILE_NAME
        INT     21H

        jnc     opened_ok               ; brif no error opening

        cmp     ax,PATH_NOT_FOUND       ; was it path?
        jz      open_err_1
        cmp     ax,FILE_NOT_FOUND       ; or file not found?
        jnz     open_err_2

open_err_1:
        CALL    COPY_ARGV0              ; yes....try ARGV(0) directory.
        MOV     AX,3D00H
        MOV     DX,OFFSET FILE_NAME
        INT     21H

        jnc     opened_ok               ; done if open ok

        cmp     ax,PATH_NOT_FOUND       ; if path or file not found, try root
        jz      open_err_3
        cmp     ax,FILE_NOT_FOUND
        jnz     open_err_2

open_err_3:
        MOV     SI,OFFSET KEYBOARD_SYS  ; try ROOT directory.
        MOV     DI,OFFSET FILE_NAME
        MOV     CX,KEYB_SYS_LENG
        REPE    MOVSB

        MOV     AX,3D00H
        MOV     DX,OFFSET FILE_NAME
        INT     21H

        jmp     short opened_ok

open_err_2:
        stc                             ; some other error, set error flag

opened_ok:

        RET

BUILD_PATH      ENDP


COPY_ARGV0  PROC

        PUSH    ES
        PUSH    DI
        PUSH    SI
        PUSH    CX

        MOV     DI,2CH                 ; Locate environment string
        MOV     ES,[DI]
        XOR     SI,SI

carv0_loop:
        cmp     word ptr es:[si],0      ; find ARGV(0) string
        jz      carv0_loop_exit
        inc     si
        jmp     carv0_loop

carv0_loop_exit:
        ADD     SI,4
        LEA     DI,FILE_NAME            ; move string to work area

carv0_loop1:
        MOV     AL,ES:[SI]
        MOV     [DI],AL
        INC     SI
        INC     DI
        cmp     byte ptr es:[si],0
        jnz     carv0_loop1

carv0_loop2:
        dec     di
        cmp     byte ptr [di],'\'       ; scan back to first character after "\"
        jz      carv0_loop2_exit
        cmp     byte ptr [di],0
        jnz     carv0_loop2

carv0_loop2_exit:
        INC     DI
        PUSH    CS
        POP     ES
        LEA     SI,KEYB_SYS_ACTIVE      ; copy in "KEYBOARD.SYS"
        MOV     CX,KEYB_SYS_A_LENG
        REPE    MOVSB

        POP     CX
        POP     SI
        POP     DI
        POP     ES
        RET

COPY_ARGV0  ENDP

;
;
; Module: FIND_FIRST_CP
;
; Description:
;     Check the keyboard definition file for the first code page
;
; Input Registers:
;     DS - points to our data segment
;     ES - points to our data segment
;     BP - offset of parmeter list
;
; Output Registers:
;           NONE
;
; Logic:
;   Open the file
;   IF error in opening file THEN
;       Display ERROR message and EXIT
;   ELSE
;       Save handle
;       Set address of buffer
;       READ header of Keyboard definition file
;       IF error in reading file THEN
;          Display ERROR message and EXIT
;       ELSE
;          Check signature for correct file
;          IF file signature is correct THEN
;             READ language table
;             IF error in reading file THEN
;                 Display ERROR message and EXIT
;             ELSE
;                 Use table to verify language parm
;                 Set pointer values
;                 IF code page was specified
;                     READ language entry
;                     IF error in reading file THEN
;                          Display ERROR message and EXIT
;                     ELSE
;                          READ first code page
;                          IF error in reading file THEN
;                              Display ERROR message and EXIT
;   RET
;
;

FIND_FIRST_CP PROC  NEAR

        PUSH    CX                      ; Save everything that
        PUSH    DX                      ;  that will be changed
        PUSH    SI
        PUSH    DI

        MOV     BX,KEYBSYS_FILE_HANDLE  ; Get handle
        MOV     DX,WORD PTR KEYBCMD_LANG_ENTRY_PTR   ; LSEEK file pointer
        MOV     CX,WORD PTR KEYBCMD_LANG_ENTRY_PTR+2 ;  to top of language entry
        MOV     AH,42H
        MOV     AL,0                    ; If no problem with
        INT     21H                     ;     Keyb Def file Then
        JNC     FIND_FIRST_BEGIN
        JMP     short FIND_FIRST_CP_ERROR4

FIND_FIRST_BEGIN:
        MOV     DI,AX
        MOV     CX,SIZE KEYBSYS_LANG_ENTRY-1 ; Set number
                                        ;       bytes to read header
        MOV     DX,OFFSET FILE_BUFFER
        MOV     AH,3FH                  ; Read language entry in
        INT     21H                     ;        keyboard definition file
        JNC     FIND_FIRST_VALID4       ; If no error in opening file then
        JMP     short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID4:

;************************** CNS *******;
        xor     ah,ah
        MOV     Al,FB.KL_NUM_CP
;************************** CNS *******;

        MUL     CP_PTR_SIZE             ; Determine # of bytes to read
        MOV     DX,OFFSET FILE_BUFFER   ; Establish beginning of buffer
        MOV     CX,AX
        CMP     CX,SIZE FILE_BUFFER     ; Make sure buffer is not to small
        JBE     FIND_FIRST_VALID5

        JMP   short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID5:
        MOV     AH,3FH                  ; Read code page table from
        INT     21H                     ;            keyboard definition file
        JNC     FIND_FIRST_VALID6       ; If no error in opening file then
        JMP     short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID6:
        MOV     CX,NUM_CP               ; Number of valid codes
        MOV     DI,OFFSET FILE_BUFFER   ; Point to correct word in table

        MOV     BX,[DI].KC_CODE_PAGE    ; Get parameter
        XOR     AX,AX
        JMP     short FIND_FIRST_RETURN

FIND_FIRST_CP_ERROR4:
        MOV     AX,4

FIND_FIRST_RETURN:
        POP     DI
        POP     SI
        POP     DX
        POP     CX

        RET

FIND_FIRST_CP  ENDP

        .xlist
MSG_SERVICES <MSGDATA>
MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg>
MSG_SERVICES <KEYB.CL1>
MSG_SERVICES <KEYB.CL2>
MSG_SERVICES <KEYB.CLA>
        .list
;
; Temp Shared Data Area
; Contains data which is required by
; both the resident and transient KEYB code.
; All keyboard tables are stored in this area
; Structures for this area are in file KEYBSHAR.INC
;
        db      'TEMP SHARED DATA'
SD_SOURCE_PTR   LABEL      BYTE
TEMP_SHARED_DATA SHARED_DATA_STR <>

CODE    ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\commsubs.asm ===
PAGE	,132
	TITLE	 MS DOS 5.0 - NLS Support - KEYB Command

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  MS DOS 5.0 - NLS Support - KEYB Command
;  (C) Copyright Microsoft Corp 1987-1991
;
;  File Name:  COMMSUBS.ASM
;  ----------
;
;  Description:
;  ------------
;	 Common subroutines used by NLS support
;
;  Documentation Reference:
;  ------------------------
;	 None
;
;  Procedures Contained in This File:
;  ----------------------------------
;
;	 FIND_HW_TYPE - Determine the keyboard and system unit types and
;	       set the corresponding flags.
;
;  Include Files Required:
;  -----------------------
;	 None
;
;  External Procedure References:
;  ------------------------------
;	 FROM FILE  ????????.ASM:
;	      ????????? - ???????
;
;  Change History:
;  ---------------
;  Sept 1989 For 4.02.
;		Add required JMP $+2 between OUT/IN in KEYB_SECURE,
;		remove unnecessary code and re-document routine.
;		Remove unnecessary PUSH/POP's around call to KEYB_SECURE.
;		Fix bug in FIND_KEYB_TYPE of READ ID flags not being
;		cleared on PS/2's when keyboard is security locked.
;		Clean up BIOS DATA & Extended DATA area access, use ES:.
;		Arrange KB type checks into special case group and 8042.
;		Fix delay loop timeout bug at WT_ID with REFRESH BIT type
;		fixed timeout delay of 15ms.  When the KBX flag is set
;		by BIOS, the READ_ID is done and PORT 60h is ID_2 byte.
;		AT (FCh) type machines all have the Refresh Bit at 61h.
;		Change SND_DATA_AT proc to a general send command routine
;		with REFRESH BIT timout logic and move the P-Layout test
;		into FIND_KEYB_TYPE.  Allows P-kb on all 8042 systems.
;		Add untranslated ID_2 byte to P-layout support for newer
;		PS/2's with hardware logic instead of 8042 if AT type.
;
;  Feb 1990 For 4.03.
;  PTM 6660	Add default to PC_386 type for new/unsupported system.
;		Move determination code from KEYBI9C.ASM for original PC.
;		Add Patriot/Sebring determination code for HOT Replug
;		so that INT 9 handler can alter keyboard Scan Code set.
;		Unknown system default= PC_386 with Patriot/Sebring test.
;		Add EXT_122 check for 122 key keyboard to SYSTEM_FLAG.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC	FIND_SYS_TYPE
	PUBLIC	FIND_KEYB_TYPE
	PUBLIC	HW_TYPE 
	PUBLIC	SECURE_FL
ifdef JAPAN
                                        ;       EXTRN's to KEYBI9C.ASM
        EXTRN   BEEP_DELAY:WORD         ; Value for error beep delay
        EXTRN   S_122_MARKER:BYTE       ; 122 key marker F8 or E0
        EXTRN   READ_ID2:BYTE           ; Second byte of last READ ID
        EXTRN   SCAN_CODE_SET:BYTE      ; 01 for non SBCS keyboard (default)
                                        ; 81h or 82h for DBCS keyboard
                                        ; This value is used at hot replug.
        EXTRN   keyb_table:byte         ; keyboard search table
        EXTRN   FILE_NAME:byte          ; keyboard definition file name
endif ; JAPAN

	INCLUDE KEYBEQU.INC
	INCLUDE KEYBCPSD.INC
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBI9C.INC
	INCLUDE KEYBCMD.INC
	INCLUDE DSEG.INC
	INCLUDE POSTEQU.INC
ifdef JAPAN
        INCLUDE KEYBDCL.INC
endif ; JAPAN


CODE	SEGMENT PUBLIC 'CODE'

	ASSUME	CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: FIND_SYS_TYPE
;
;  Description:
;      Determine the type of system we are running on.
;      SYSTEM_FLAG (in active SHARED_DATA) are set to
;      indicate the system type.
;      This routine is only called the first time KEYB is being installed.
;
;
;  Input Registers:
;      DS - points to our data segment
;
;  Output Registers:
;      NONE
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ROM	SEGMENT AT	0F000H
		ORG	0FFFBH
SYSROM_DATE	DW	?		; OFFSET OF ROM YEAR DIGIT

PC1DATE_ID	EQU	03138H		; YEAR ROM WAS RELEASED IN ASCII

		ORG	0FFFEH
ROMID		DB	?
					; SEGMENT F000. (F000:FFFE)

ROMPC1		EQU	0FFH		; ID OF PC1 hardware
ROMXT		EQU	0FEH		; ID OF PC-XT/PORTABLE hardware
ROMAT		EQU	0FCH		; ID OF PCAT
ROMXT_ENHAN	EQU	0FBH		; ID OF ENHANCED PCXT
ROMPAL		EQU	0FAH		; ID FOR PALACE
ROMLAP		EQU	0F9H		; ID FOR PC LAP (P-14)
ROM_RU_386	EQU	0F8H		; ID FOR ROUNDUP-386

ROM	ENDS

ifdef JAPAN
RTN_EXT_BIOS_DATA_SEG   EQU     0C1H    ; INT15H SUB FUNCTION  M005 -- JP9009
endif ; JAPAN
ROMEXT	SEGMENT AT 00000H		; ADDRESS SHOULD NOT BE FIXED AT 09FC0H
					; This just a dummy segment value, as
		ORG	0003BH		;  INT 15h - function C1 call will load
KEYBID1 	DB	?		;  ES: dynamically depending on where
					;  the ROMEXT segment is located.
					;  (9FC0 was only for old 640K systems)
ifdef JAPAN
                ORG     00117H          ;                    ;JP9009
EXT_BIOS_DATA_KBD_ID    DW      ?       ; KEYBOARD ID(xxABH) ;JP9009
endif ; JAPAN
ROMEXT	ENDS				;  ( ES:003B )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_SYS_TYPE	       PROC  NEAR

	MOV	AX,ROM			; Set segmant to look at ROM
	MOV	DS,AX			;    using the data segment
	ASSUME	DS:ROM

	MOV	AX,SYSROM_DATE		; Get BIOS year date
	PUSH	AX			; save it on stack
	MOV	AL,ROMID		; Get hardware ID
	PUSH	AX			; save it

	PUSH	CS			; Set data seg back to code
	POP	DS
	ASSUME	DS:CODE 

	MOV	AH,092H 		; SET INVALID CALL FOR INT16  83 KEYS
	INT	16H			; CALL BIOS
	CMP	AH,80H			; IS EXTENDED INTERFACE THERE? 101/102
	JA	CHECK_PC_NET		;  NO, SKIP FLAG

	OR	SD.SYSTEM_FLAG,EXT_16	; Default is extended INT 16 support

	MOV	AH,0A2H 		; SET INVALID CALL FOR INT16  101 KEYS
	INT	16H			; CALL BIOS
	CMP	AH,80H			; IS EXTENDED INTERFACE THERE? 122/
	JA	CHECK_PC_NET		;  NO, SKIP FLAG

	OR	SD.SYSTEM_FLAG,EXT_122	; Also extended 122 keyboard support

CHECK_PC_NET:
	MOV	AH,30H			; GET DOS VERSION NUMBER
	INT	21H			; MAJOR # IN AL, MINOR # IN AH
	CMP	AX,0A03H		; SENSITIVE TO 3.10 OR >
	JB	CHECK_SYSTEM		; EARLIER VERSION OF DOS NOTHING
					; WAS ESTABLISHED FOR THIS SITUATION
	PUSH	ES			; Save ES just in case
	MOV	AX,3509H		; GET INT VECTOR 9 CONTENTS
	INT	21H			; ES:BX WILL = CURRENT INT9 VECTOR
					; SEE IF WE ARE THE 1ST ONES LOADED
	MOV	CX,ES			; INTO THE INT 9.  WITH DOS 3.1 WE CAN
	POP	ES			; HANDSHAKE WITH THE PC NETWORK BUT
	CMP	CX,0F000H		; BUT NO ONE ELSE CAN BE HOOK IN FIRST
	JE	CHECK_SYSTEM		; INT VECTOR 9 POINTS TO ROM, OK

	MOV	AX,0B800H		; ASK IF PC NETWORK IS INSTALLED
	INT	2FH
	or	al,al			; not installed if al=0
	JE	CHECK_SYSTEM		; SOMEBODY HAS LINKED THE INT VECTOR 9
					; & I'M GOING TO DROP RIGHT IN AS USUAL
	OR	SD.SYSTEM_FLAG,PC_NET	; INDICATE PC NET IS RUNNING

CHECK_SYSTEM:
ifdef JAPAN
                                        ; Determine if REFRESH BIT works OK    ;AN012
        MOV     BEEP_DELAY,36           ; Set error beep delay for XT machines ;AN012
        XOR     CX,CX                   ; Clear timeout loop counter           ;AN012
CHECK_SYST5:                                                                   ;AN012
        IN      AL,PORT_B               ; Read current system status port      ;AN012
        AND     AL,REFRESH_BIT          ; Mask all but refresh bit             ;AN012
        LOOPNZ  CHECK_SYST5             ; Loop till we see the bit OFF         ;AN012
        JCXZ    CHECK_SYST7             ; Exit if it fails to go OFF           ;AN012
CHECK_SYST6:                                                                   ;AN012
        IN      AL,PORT_B               ; Read current system status port      ;AN012
        AND     AL,REFRESH_BIT          ; Mask all but refresh bit             ;AN012
        LOOPZ   CHECK_SYST6             ; Loop till we see the bit ON          ;AN012
        JCXZ    CHECK_SYST7             ; Exit if it fails to go ON            ;AN012
        MOV     BEEP_DELAY,19           ; Set Refresh delay loop constant      ;AN012
CHECK_SYST7:                                                                   ;AN012
        PUSH    ES                      ; Check for broken INT 16h BIOS        ;AN013
        MOV     AH,0C0h                 ; Configuration function               ;AN013
        INT     15h                     ; System services call                 ;AN013
        JC      CHECK_SYST8             ; Skip if not supported by system      ;AN013
                                        ;       Check Model/submodel/revision  ;AN013
        CMP     word ptr ES:[BX+2],019F8h ; Initial ship level of 122 broken   ;AN013
        JNE     CHECK_SYST8             ; Skip if not broken INT 16h model/sub ;AN013
        CMP     byte ptr ES:[BX+4],005h ; Is it the bad revision level         ;AN013
        JA      CHECK_SYST8             ; Skip if not the broken code          ;AN013
                                        ;  ELSE                                ;AN013
        MOV     S_122_MARKER,0          ; Change 122 key F8h marker to an 00h  ;AN013
                                        ; F8,19,05 and below do not support F8 ;AN013
CHECK_SYST8:                                                                   ;AN013
        POP     ES                      ; Restore                              ;AN013
endif ; JAPAN
	POP	AX			; get code back
	POP	BX			; get date back off of stack
					; Is the hardware a PCjr
					; Is the hardware a PC1 or XT ?
	CMP	AL,ROMXT
	JAE	ITS_AN_XT		; IF (FE) OR (FF) THEN ITS AN XT
	CMP	AL,ROMXT_ENHAN		; IF (FB) IT IS ALSO AN XT
	JNE	TEST_PC_AT		; IF not then check for next type

ITS_AN_XT:
	OR	SD.SYSTEM_FLAG,PC_XT	; system type
					; Check the ROM level in the system
	CMP	BX,PC1DATE_ID		; Is it the ORIGINAL PC1 version?
	JNE	SHORT FIND_SYS_END	; Done if not

	OR	SD.SYSTEM_FLAG,PC_81	; Else set the Original PC1 flag
	JMP	SHORT FIND_SYS_END

TEST_PC_AT:
					; Is the hardware an AT ?
	CMP	AL,ROMAT		; (FC)
	JNE	TEST_P12		; IF not then check for next type

	OR	SD.SYSTEM_FLAG,PC_AT	; system type with 8042 V2 interface

	JMP	SHORT FIND_SYS_END

TEST_P12:
	CMP	AL,ROMLAP		; IS this a Convertible (F9) (P12)?
	JNE	TEST_PAL		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_LAP	; system type
	JMP	SHORT FIND_SYS_END

TEST_PAL:
	CMP	AL,ROMPAL		; IS this a Model 30 (FA) (PALACE)?
	JNE	TEST_RU_386		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_PAL	; system type
ifdef JAPAN
        MOV     BEEP_DELAY,88           ; Set error beep delay for 8086 machine;AN012
endif ; JAPAN
	JMP	SHORT FIND_SYS_END

TEST_RU_386:
	CMP	AL,ROM_RU_386		; IS this a PS/2 with a 386 (F8)?
	JNE	TEST_SYS_NEW		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_386	; System type with 8042 V3
	CALL	SP_8042 		; Determine if 8042 is Patriot/Sebring
	JMP	SHORT FIND_SYS_END

TEST_SYS_NEW:
					; ASSUME 8042 TYPE IF UNKNOWN
	OR	SD.SYSTEM_FLAG,PC_386	; Default system type with 8042 V3
	CALL	SP_8042 		; Determine if 8042 is Patriot/Sebring


FIND_SYS_END:

	RET

FIND_SYS_TYPE	    ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: FIND_KEYB_TYPE
;
;  Description:
;      Determine the type of keyboard we are running on.
;      KEYB_TYPE (in SHARED_DATA) is set to indicate the keyboard type.
;      This routine is only called the first time KEYB is being installed.
;      It is called after the new Interrupt 9 handler is installed.
;
;  Input Registers:
;      DS - points to our data segment
;
;  Output Registers:
;      NONE
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

HW_TYPE 	DW	0
SECURE_FL	DB	0

ifndef JAPAN
;RESERVED ADDRESS 013h BITS 1 & 2

PASS_MODE	equ	00000001B
SERVER_MODE	equ	00000010B
SECRET_ADD	equ	13h
PORT_70 	equ	70h		; CMOS ADDRESS PORT
PORT_71 	equ	71h		; CMOS DATA PORT
endif ; !JAPAN

ID_1		EQU	0ABh			; Keyboard ID_1 for FERRARI
TID_2		EQU	041h	   ;;AB41	; Keyboard ID_2 for FERRARI_G
ID_2U		EQU	083h	   ;;AB83	; Keyboard ID_2 for FERRARI_G
TID_2A		EQU	054h	   ;;AB54	; Keyboard ID_2 for FERRARI_P
ID_2AU		EQU	084h	   ;;AB84	; Keyboard ID_2 for FERRARI_P
ID_2JG		EQU	090h	   ;;AB90	; Keyboard ID_2 for JPN G
ID_2JP		EQU	091h	   ;;AB91	; Keyboard ID_2 for JPN P
ID_2JA		EQU	092h	   ;;AB92	; Keyboard ID_2 for JPN A

P_KB_ID 	DB	08

	extrn	pswitches:byte

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_KEYB_TYPE	      PROC  NEAR

; we need these code until be prepared code for NTVDM (MSKK)
; KKFIX Make it KK specific 10/17/96
ifdef JAPAN
;if 1 
;ifdef NOT_NTVDM

	PUSH	ES
	PUSH	DS

	MOV	AX,DATA 
	MOV	ES,AX			; ES points to BIOS data
	ASSUME	ES:DATA 

	MOV	AX,ROM			; Set segmant to look at ROM
	MOV	DS,AX			;    using the data segment
	ASSUME	DS:ROM

	MOV	AL,ROMID		; Get hardware ID

	PUSH	CS			; Set data segment to CODE
	POP	DS
	ASSUME	DS:CODE 

	test	pswitches,2		; /e switch true?
	jz	no_force_enh
	or	es:KB_FLAG_3,KBX	; force enhanced kbd support on
no_force_enh:

	MOV	HW_TYPE,G_KB		; Default keyboard is G_KB

	CMP	AL,ROMLAP		; IS this a P12? (CONVERTABLE)
	JNE	TEST_PC_XT_2		; IF not then check for next type

	MOV	HW_TYPE,P12_KB		; IF yes then set flag
	JMP	FIND_KEYB_END		; Done

TEST_PC_XT_2:
					; Is the hardware a PC1 or XT ?
	CMP	AL,ROMXT
	JAE	ITS_AN_XT_2		; IF FE OR FF THEN ITS AN XT
	CMP	AL,ROMXT_ENHAN		; IF FB IT IS ALSO AN XT
	JNE	TEST_PS_30_2		; IF not then check for next type

ITS_AN_XT_2:
	TEST	ES:KB_FLAG_3,KBX	; IS THE ENHANCED KEYBOARD INSTALLED?
	JZ	ITS_AN_XT_3
ifndef JAPAN
	JMP	SHORT FIND_KEYB_END	; Yes, exit
else ; JAPAN
	JMP	FIND_KEYB_END		; Yes, exit
endif ; JAPAN

ITS_AN_XT_3:
	MOV	HW_TYPE,XT_KB		; NO, normal XT keyboard
ifndef JAPAN
	JMP	SHORT FIND_KEYB_END
else ; JAPAN
	JMP	FIND_KEYB_END
endif ; JAPAN

TEST_PS_30_2:
	CMP	AL,ROMPAL		; IS this a PS/2 MODEL 30 or 25
	JNE	TEST_PC_AT_2		; IF not then check for next type

	MOV	AH,0C1H 		; Make extended bios data area call to
	INT	15H			; get the segment address for accessing
	JNC	ITS_AN_PS2_30		; the PALACE (only) keyboard byte area.
ifndef JAPAN
	JMP	SHORT FIND_KEYB_END	; JC   Assume Keyboard type G if error,
else ; JAPAN
	JMP	FIND_KEYB_END		; JC   Assume Keyboard type G if error,
endif ; JAPAN
					; Otherwise EXTENDED BIOS DATA RETURNED
					; in the ES: and ES:003Bh is keyboard

ITS_AN_PS2_30:				; ID byte reserved for PALACE.
					; Set segment to look at extended ROM
	ASSUME	ES:ROMEXT		;    using the ES: segment
					; SEG ES: value returned by INT15h - C1
	MOV	AL,KEYBID1		; Get keyboard ID

	ASSUME	ES:NOTHING		; Don't use ES: for anything else

	AND	AL,0FH			; Remove high nibble
	CMP	AL,P_KB_ID		; IF keyboard is a FERRARI P THEN
	JNE	ITS_AN_PS2_30G
	OR	HW_TYPE,P_KB		;    Set the HW_TYPE flag to P keyboard

ITS_AN_PS2_30G: 
	JMP	SHORT FIND_KEYB_END	; Done

					; (Insert any more special cases here.)

;	At this point, all special case or older keyboard/system
;	types have been determined and HW_TYPE correctly set.
;	(PC, XT, XT Enhansed, CONVERTABLE, Model 30/25)
;
;	Assume now that the system has an 8042 type keyboard
;	interface and can be sent a READ ID command to determine
ifndef JAPAN
;	the type of keyboard installed.  The old AT keyboard is
;	handled as a special case of no security bits set and no
;	response to a READ ID command.	If security bits are set
;	and no KBX flag is set as a result of the READ ID, then
;	the interface is assumed to be locked and the default of
;	G-keyboard is taken as the keyboard ID can not be read.
else ; JAPAN
;       the type of keyboard installed.  First we check to see if the          ;AN011
;       interface is inhibited by either the password lock (PS/2) or a         ;AN011
;       keylock.  If not, we set Read ID in process, clear last ID byte 2      ;AN011
;       read by the KEYBI9C INT 9h handler, send a READ ID command to the      ;AN011
;       keyboard and wait for the second ID byte save location to change.      ;AN011
;       A timeout of this operation indicates either an old AT style keyboard  ;M000
;       or no keyboard attached and we set the type of keyboard to AT_KB,      ;AN011
;       unless the KBX flag has been turned on by the /E switch, default G_KB. ;AN011
;       Any E0 will force KBX on, but APPS will not see it unless /E was used. ;AN011
;       Mouse/AUX conflicts are handled by an extra long delay here and a      ;AN011
;       retry loop, checking that the returned value for ID 2 is not invalid.  ;AN011
;                                                                              ;AN011
;       However if the interface is inhibited we will check to see if this     ;AN011
;       is a DBCS enabled machine, that does a READ ID during POST and saves   ;AN011
;       the keyboard ID in the extended data area, and use this data.  We      ;AN011
;       also set a flag indicating the security mode is set, so that the       ;AN011
;       correct Scan Code Set can be sent to the keyboard when it is unlocked. ;AN011
;       If not a DBCS machine we will again default to the G-keyboard.         ;M000
endif ; JAPAN

TEST_PC_AT_2:

	ASSUME	ES:DATA 		; READ ID COMMAND TO TEST FOR A KBX

ifndef JAPAN
	MOV	ES:KB_FLAG_3,RD_ID	; INDICATE THAT A READ ID IS BEING DONE
					;  and clear KBX flag if set
	MOV	AL,0F2H 		; SEND THE READ ID COMMAND
	CALL	SND_DATA_AT
					; Wait 40ms for READ ID to complete
	MOV	CX,DLY_15ms		; Load count for 15ms (15,000/15.086)

WT_ID:					;      Fixed time wait loop on AT's
	TEST	ES:KB_FLAG_3,KBX	; TEST FOR KBX SET by BIOS interrupt 9h
	JNZ	DONE_AT_2		; Exit wait loop if/when flag gets set
else ; JAPAN
        AND     ES:KB_FLAG_3,NOT LC_E0+LC_AB ; Clear hidden code and first ID  ;AN011
                                             ; Do not clear the KBX flag (/E)  ;AN011
        MOV     BL,5                    ; Set READ ID retry count to 5 tries   ;AN011
                                                                               ;AN011
        IN      AL,STATUS_PORT          ; Check for the KEYBOARD INHIBIT bit   ;AN011
        TEST    AL,KYBD_INH             ;  to see if server mode or keylocked. ;AN011
        JNZ     ASK_KEYBOARD            ; If not inhibited, ask the keyboard ID;AN011
        JMP     ASK_ROM_BIOS            ; If inhibited, see if POST read the ID;AN011

ASK_KEYBOARD:                           ;       ASK keyboard it's ID           ;AN011
        MOV     READ_ID2,0              ; Clear READ ID byte 2 save location   ;AN011
                                        ; INT 9h will now set it to ID byte 2  ;AN011
        OR      ES:KB_FLAG_3,RD_ID      ; INDICATE THAT A READ ID IS BEING DONE;AN011
                                        ;  and do not clear KBX flag set by /E ;AN011
if 0 ; can not send read id command. (MSKK)
	MOV	AL,0F2H 		; SEND THE READ ID COMMAND
	CALL	SND_DATA_AT
endif
                                        ; Wait 30ms for READ ID to complete    ;AN011
        MOV     CX,DLY_15ms*2           ; Load count for 30ms (15,000/15.086)*2;AN011

WT_ID:					;      Fixed time wait loop on AT's
        CMP     READ_ID2,0              ; TEST FOR BIOS interrupt 9h to set ID ;AN011
	JNZ	DONE_AT_2		; Exit wait loop if/when flag gets set

        TEST    ES:KB_FLAG_3,RD_ID+LC_AB; Test for unexpected scan code ending ;AN012
        JZ      ID_ERROR                ;  READ ID or clearing hang condition  ;AN012
endif ; JAPAN

	IN	AL,PORT_B		; Read current system status port
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JZ	WT_ID			; No, wait for change, else continue

ifdef JAPAN
ID_ERROR:                               ; Read ID error exit, must clear CX    ;AN011
endif ; JAPAN
	MOV	AH,AL			; Save new refresh bit state
	LOOP	WT_ID			; WAIT OTHERWISE

					; BE SURE READ ID FLAGS GOT RESET
	AND	ES:KB_FLAG_3,NOT RD_ID+LC_AB ; Clear READ ID state flags
ifdef JAPAN
                                        ; As no ID byte 2 was read/set         ;AN011
        DEC     BL                      ; Decrement retry counter              ;AN011
        JNZ     ASK_KEYBOARD            ; Try five times to get a valid ID     ;AN011

        TEST    ES:KB_FLAG_3,KBX        ; Is the KBX flag ON from /E switch    ;AN011
        JNZ     KBX_OK                  ; If ON, use default G_KB as keyboard  ;AN011

        MOV     HW_TYPE,AT_KB           ; NO, AT KBD if no KBX and no security ;AN011
KBX_OK:                                                                        ;AN011
        JMP     SHORT FIND_KEYB_END     ; EXIT                                 :AN011
else ; !JAPAN
					; As no KBX flag set
	CALL	KEYB_SECURE		; SEE IF THE KEYBOARD SECURITY IS
					; ACTIVATED AT THIS POINT
	JNC	ASSUME_AT		; SECURITY UNAVAILABLE OR AN AT KB

	MOV	SECURE_FL,1		; SECURITY IS ACTIVE
	JMP	SHORT FIND_KEYB_END	; ASSUME IT IS A G_KB  WITH
					; NUM LOCK OFF
ASSUME_AT:
	MOV	HW_TYPE,AT_KB		; NO, AT KBD if no KBX and no security
	JMP	SHORT FIND_KEYB_END	; EXIT
endif ; !JAPAN

DONE_AT_2:				;      LAST PORT 60h VALUE IS ID_2 BYTE
ifndef JAPAN
	IN	AL,PORT_A		; Re-read last byte from keyboard input
else ; JAPAN
;AN011                                   ;  IN al,60h here causes missed ID2's

        MOV     AL,READ_ID2             ; Get the ID2 byte just read by KEYBI9C;AN011
        DEC     BL                      ; Decrement READ ID retry counter      ;AN011
        JZ      ID_USE                  ; Skip range check if retries exhausted;AN011

        CMP     AL,ID_1                 ; Did we get the ID1 byte twice        ;AN011
        JE      ASK_KEYBOARD            ; Retry read ID if this happens        ;AN011

        CMP     AL,TID_2                ; Check that the ID read is valid range;AN011
        JB      ASK_KEYBOARD            ; Try again if not 41h or greater      ;AN011
ID_USE:                                                                        ;AN011

;       M005 -- begin changed section

        CALL    SET_KBD_ID_TO_ROM_EXT   ; This is DBCS requirement. There are  ;JP9009
                                        ; five kinds of DBCS keyboards. We     ;JP9009
                                        ; need to distinguish them.            ;JP9009
        CMP     AL, ID_2JG              ; Was it old DBCS keyboards?           ;JP9009
        JAE     CHECK_WHAT_DBCS_KBD     ; Check what it is.                    ;JP9009
DONE_AT_FOR_G_P_TYPE:                                                          ;JP9011

;       M005 -- end changed section
endif ; JAPAN
	CMP	AL,TID_2A		; Was it the P-layout keyboard
	JE	DONE_AT_3		; Go set P type keyboard

	CMP	AL,ID_2AU		; Was it the P-layout untranslated
	JNE	DONE_AT_4		; Continue if not

DONE_AT_3:
	OR	HW_TYPE,P_KB		; Set HW_TYPE for P-layout keyboard
DONE_AT_4:
					; EXIT


FIND_KEYB_END:				; EXIT POINT
	MOV   AX,HW_TYPE		;      Get default or determined type
ifndef JAPAN
	MOV   SD.KEYB_TYPE,AX		;      Place into shared data area

	POP   DS
	POP   ES
else ; JAPAN
;       M005 -- begin changed section

;                                                                      ;JP9009
; New DBCS keyboards' ID is the same as that of SBCS 101/102 key       ;JP9009
; keyboard. So, we can distinguish them only by the language parameter ;JP9009
; string.                                                              ;JP9009
;                                                                      ;JP9009
;+ AN015-- Delete this out for now per request of Japanese.
;+         They can not assume ID's for other countries.  Actually we
;+         need a better way to determine if DBCS mode should be made active.
;+         This really need to be handled in the KEYBOARD.SYS files and set here.
;+
;AN015         MOV     CX, WORD PTR [BP].LANGUAGE_PARM; Get language specified.       ;JP9009
;AN015         CMP     CX, 'PJ'                ; Japanese keyboard?                   ;JP9009
;AN015         JE      DBCS_KEYBOARD                                                  ;JP9009
;AN015         CMP     CX, 'OK'                ; Korea keyboard?                      ;JP9009
;AN015         JE      DBCS_KEYBOARD                                                  ;JP9009
;AN015         CMP     CX, 'RP'                ; PRC keyboard?                        ;JP9009
;AN015         JE      DBCS_KEYBOARD                                                  ;JP9009
;AN015         CMP     CX, 'AT'                ; Taiwan keyboard?                     ;JP9009
;AN015         JNE     SBCS_KEYBOARD                                                  ;JP9009
;AN015 DBCS_KEYBOARD:                                                                 ;JP9009

;JP9110        CMP     WORD PTR [BP].LANGUAGE_PARM,'PJ' ; Japanese keyboard language  ;AN015
        CALL    IS_DBCS_KEYBOARD_LAYOUT ; DBCS layout?                  ;JP9110
        JNE     SBCS_KEYBOARD                    ; Skip DBCS if not            ;AN015

        OR      AX, DBCS_KB             ; Set it as DBCS keyboard              ;JP9009
        OR      SD.SYSTEM_FLAG,DBCS_OK  ; Set DBCS flag for INT 9 handler      ;AN013

; Determine keyboard sub type for Japanese keyboard
        push    si

        push    ds
        pop     es
	ASSUME	ES:CODE 

        MOV     si,offset FILE_NAME
        xor     dx,dx

        push    ax
find_filename:
        lodsb
        and     al,al                   ; extract only file name
        jz      check_def_file
        cmp     al,'\'
        jnz     find_filename

        mov     dx,si
        jmp     short find_filename

check_def_file:
        and     dx,dx
        jz      check_end

        lea     si,keyb_table
check_file2:
        xor     cx,cx
        lodsb
        and     al,al
        jz      check_end

        mov     cl,al
        mov     di,dx
        repe    cmpsb                   ; find match driver name
        jz      match_driver

        add     si,cx
        inc     si
        jmp     check_file2

match_driver:
        mov     cl,[si]

check_end:
        pop     ax                      ; key type
        or      al,cl                   ; add keyboard sub type

        pop     si

SBCS_KEYBOARD:                                                                 ;JP9009

;       M005 -- end changed section

	MOV   SD.KEYB_TYPE,AX		;      Place into shared data area

	POP   DS
	POP   ES
	RET

;       M005 -- begin changed section

ASK_ROM_BIOS:                                                                  ;JP9010
        OR      SD.SYSTEM_FLAG, SECURITY_ACTIVE ; Set keyboard LOCK active,    ;AN011
                                        ; it will clear when password entered  ;AN011
        MOV     SECURE_FL,1             ; SECURITY IS ACTIVE                   ;AN011
        PUSH    ES                      ;                                      ;JP9011
        MOV     AH, RTN_EXT_BIOS_DATA_SEG; GET EXTENDED BIOS DATA AREA SEGMENT ;JP9010
        INT     15H                     ;                                      ;JP9010
        ASSUME  ES:ROMEXT               ;                                      ;JP9009
;AN011        MOV     AL, BYTE PTR ES:EXT_BIOS_DATA_KBD_ID + 1;                      ;JP9010
        MOV     AX,ES:EXT_BIOS_DATA_KBD_ID ; Get both bytes of ID              ;AN011
        ASSUME  ES:DATA                 ;                                      ;JP9009
        POP     ES                      ; AH = HIGH BYTE OF KEYBOARD ID        ;JP9011
        JC      FIND_KEYB_END           ;      0 IF NOT SUPPORTED              ;JP9011
         CMP    AL,ID_1                 ; Is this valid READ ID data           ;AN011
         JNE    FIND_KEYB_END           ; Exit if not supported on this system ;AN011
         MOV    AL,AH                   ; Move READ ID byte 2 into register    ;AN011
         CMP     AL, ID_2JG             ;                                      ;JP9010
         JB      DONE_AT_FOR_G_P_TYPE   ; WE GOT KEYB_TYPE FROM ROM BIOS, SO   ;JP9011
                                        ; RETURN TO NORMAL PROCEDURE           ;JP9011
CHECK_WHAT_DBCS_KBD:                                                           ;JP9009
;JP9110        MOV     HW_TYPE, (DBCS_OLD_G_KB or DBCS_OLD_P_KB)                      ;JP9009
        OR      HW_TYPE, (DBCS_OLD_G_KB or DBCS_OLD_P_KB)               ;JP9110
        CMP     AL, ID_2JA              ; Was it old DBCS A keyboard?          ;JP9009
        JNE     SET_SCAN_TABLE          ; Go if old DBCS G/P keyboard.         ;JP9009
;JP9110        MOV     HW_TYPE, DBCS_OLD_A_KB                                         ;JP9009
        AND     HW_TYPE, NOT (DBCS_OLD_G_KB or DBCS_OLD_P_KB)           ;JP9110
        OR      HW_TYPE, DBCS_OLD_A_KB                                  ;JP9110
SET_SCAN_TABLE:                                                                ;JP9009
        MOV     AL,82h                  ; SELECT SCAN CODE SET 82              ;JP9009
        TEST    SD.SYSTEM_FLAG,PS_8042   ; If in passthru mode without 8042    ;JP9009
        JZ      CHANGE_SCAN_TABLE       ; then set scan code set 81            ;JP9009
        MOV     AL,81h                  ; SELECT SCAN CODE SET 81              ;JP9009
CHANGE_SCAN_TABLE:                                                             ;JP9009
        MOV     SCAN_CODE_SET, AL       ; 81h or 82h for old DBCS keyboard     ;JP9009
                                        ; This is also used at hot replug.     ;JP9009
        CMP     SECURE_FL, 1            ; IF SECURITY ACTIVE, RETURN           ;JP9010
;        JE      FIND_KEYB_END           ;                                      ;JP9010
        JNE      FIND_KEYB_SCAN                                        ; QFESP4
        JMP      FIND_KEYB_END                                         ; QFESP4
FIND_KEYB_SCAN:                                                        ; QFESP4
        MOV     AL,SCAN_CODE_CMD        ; SELECT SCAN CODE SET COMMAND         ;JP9009
        CALL    SND_DATA_AT             ; SEND IT DIRECTLY TO THE KEYBOARD     ;JP9009
        MOV     AL, SCAN_CODE_SET       ; SCAN CODE SET                        ;JP9009
        CALL    SND_DATA_AT             ; SEND IT TO THE KEYBOARD              ;JP9009
;        JMP     SHORT DONE_AT_4                                                ;JP9009
        JMP     DONE_AT_4                                              ; QFESP4


;  Module: SET_KBD_ID_TO_ROM_EXT
;  Description:
;       This routine sets keyboard ID to the corresponding extended BIOS
;       data area, even if ROM BIOS does not support 'Return Keyboard ID
;       (INT16H, AH=0AH)'. DBCS DOS supports it by some software if ROM
;       BIOS does not support it.
;       Input:
;               AL = High byte of keyboard ID
;                    Assumes low byte is 'ABH'.
;       Output:
;               none
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                      ;JP9009
SET_KBD_ID_TO_ROM_EXT   PROC    NEAR    ;                                      ;JP9009
        PUSH    ES                      ;                                      ;JP9009
        PUSH    AX                      ;                                      ;JP9009
        MOV     AH, RTN_EXT_BIOS_DATA_SEG;                                     ;JP9009
        INT     15H                     ; Get extended BIOS data area          ;JP9009
        JC      NOT_SET_KBD_ID          ;                                      ;JP9009
            ASSUME  ES:ROMEXT           ; EXTENDED BIOS DATA AREA              ;JP9009
            MOV     AH, AL              ; AH = KBD ID 2ND BYTE                 ;JP9009
            MOV     AL, 0ABH            ; ASSUME KBD ID = xxABH                ;JP9009
            MOV     ES:EXT_BIOS_DATA_KBD_ID, AX; Set KBD ID to ext. BIOS data  ;JP9009
            ASSUME  ES:DATA             ; NORMAL BIOS DATA AREA                ;JP9009
NOT_SET_KBD_ID:                                                                ;JP9009
        POP     AX                      ;                                      ;JP9009
        POP     ES                      ;                                      ;JP9009
        RET                             ;                                      ;JP9009
SET_KBD_ID_TO_ROM_EXT   ENDP            ;                                      ;JP9009
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                      ;JP9009
;       M005 -- end changed section

;                                                                       ;JP9110
;       Check if the specified keyboard layout is DBCS one or not.      ;JP9110
;                                                                       ;JP9110
;       Input:  BP = CMD_PARM_LIST                                      ;JP9110
;       Output: ZF = Zero if DBCS layout                                ;JP9110
;                    Non-Zero if not                                    ;JP9110
;                                                                       ;JP9110
IS_DBCS_KEYBOARD_LAYOUT         PROC    NEAR                            ;JP9110
        CMP     WORD PTR [BP].LANGUAGE_PARM,'PJ' ; Japanese layout?     ;JP9110
        RET                                                             ;JP9110
IS_DBCS_KEYBOARD_LAYOUT         ENDP                                    ;JP9110

endif ; JAPAN
else
;; BUGBUG
;; don't do the read id under nt because the keyboard h/w interrupt is
;; disabled at this moment. We should be able to get the keyboard type
;; from GetKeyboardType API after beta.
;; We simply pretend the keyboard is a 101/102 keyboard whithout checking
;; -- softpc only support 101/102 keys keyboard.

	PUSH	ES
	push	ds
	mov	ax, cs
	mov	ds, ax
	assume	ds:CODE

	MOV	AX,DATA 
	MOV	ES,AX			; ES points to BIOS data
	assume	es:DATA
	or	es:KB_FLAG_3,KBX	; force enhanced kbd support on
;;Set this to one will turn on the NUM lock when we are going to exit and keep
;; resident. This is not necessary because ntvdm host code controls num lock
;; states and the rest of system.
;;	mov	SECURE_FL, 1
;;
	mov	ax, G_KB		; enhanced keyboard
	mov	HW_TYPE, ax
	mov	SD.KEYB_TYPE, ax
	pop	ds
	POP	ES
	assume	ES:nothing
endif
	RET

FIND_KEYB_TYPE		ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: SND_DATA_AT
;
;  Description:
;	THIS ROUTINE HANDLES TRANSMISSION OF PC/AT COMMAND AND DATA BYTES
;	TO THE KEYBOARD AND RECEIPT OF ACKNOWLEDGEMENTS.  IT ALSO
;	HANDLES ANY RETRIES IF REQUIRED
;
;
;  Input Registers:
;      DS - points to our data segment
;      ES - points to the BIOS data segment
;
;  Output Registers:
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_DATA_AT PROC   NEAR 
	PUSH	AX			; SAVE REGISTERS
	PUSH	BX			; *
	PUSH	CX
	MOV	BH,AL			; SAVE TRANSMITTED BYTE FOR RETRIES
	MOV	BL,3			; LOAD RETRY COUNT

;----  WAIT FOR 8042 INTERFACE NOT BUSY

SD0:					; RETRY entry
	CALL	CHK_IBF 		; Wait for command to be accepted

	CLI				; DISABLE INTERRUPTS
	AND	ES:KB_FLAG_2,NOT (KB_FE+KB_FA+KB_ERR)	; CLEAR ACK, RESEND AND
							; ERROR FLAGS
	MOV	AL,BH			; REESTABLISH BYTE TO TRANSMIT
	OUT	PORT_A,AL		; SEND BYTE

	JMP	$+2			; Delay for 8042 to accept command
	STI				; ENABLE INTERRUPTS

;-----	WAIT FOR COMMAND TO BE ACCEPTED BY KEYBOARD

	MOV	CX,DLY_15ms		; Timout for 15 ms (15,000/15.086)

SD1:					;	Fixed timout wait loop on AT's
	TEST	ES:KB_FLAG_2,KB_FE+KB_FA; SEE IF EITHER BIT SET
	JNZ	SD3			; IF SET, SOMETHING RECEIVED GO PROCESS

	IN	AL,PORT_B		; Read current system status port
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JE	SD1			; No, wait for change, else continue

	MOV	AH,AL			; Save new refresh bit state
	LOOP	SD1			; OTHERWISE WAIT

SD2:
	DEC	BL			; DECREMENT RETRY COUNT
	JNZ	SD0			; RETRY TRANSMISSION

	OR	ES:KB_FLAG_2,KB_ERR	; TURN ON TRANSMIT ERROR FLAG
	JMP	SHORT SD4		; RETRIES EXHAUSTED FORGET TRANSMISSION

SD3:
	TEST	ES:KB_FLAG_2,KB_FA	; SEE IF THIS IS AN ACKNOWLEDGE
	JZ	SD2			; IF NOT, GO RESEND

SD4:
	POP	CX			; RESTORE REGISTERS
	POP	BX
	POP	AX			; *
	RET				; RETURN, GOOD TRANSMISSION

SND_DATA_AT ENDP

ifndef JAPAN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; KEYBOARD SECURITY LOGIC
;
; CHECK THE CMOS RAM BYTE AT CMOS LOCATION HEX 013H
; CHECK TO SEE IF EITHER BITS 1 (PASSWORD) OR 2 (SERVER MODE) ARE SET ON
; IF EITHER BIT IS SET ON THE SYSTEM IS A MOD 50 on up
;    RETurn CARRY FLAG ON indicating keyboard interface may be disabled.
; OTHERWISE NO SECURITY ENABLED OR THE SYSTEM IS AN OLD AT.
;    RETurn CARRY FLAG OFF indicating keyboard interface not disabled.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

KEYB_SECURE	PROC	NEAR

	CLI				; DISABLE INTERRUPTS WHILE DOING
					; ADDRESS WRITE AND CMOS READ
	MOV	AL,SECRET_ADD		; WRITE ADDRESS OF CMOS BYTE WITH
	OUT	PORT_70,AL		; BITS FOR THE PASSWORD AND SERVER
					; MODE STATE TO PORT 70H
	JMP	$+2			; I/O Delay required
	IN	AL,PORT_71		; READ CMOS DATA BYTE WITH THE
					; PASSWORD AND SERVER SECURITY
	STI				; ENABLE THE INTERRUPTS
	TEST	AL,PASS_MODE+SERVER_MODE; CHECK & SEE IF THE BITS ARE ON
					; TEST clears CARRY flag
	JZ	SECURE_RET		; EXIT NO CARRY if neither set

	STC				; SET THE SECURITY FLAG ON
					; System is NOT an AT but the
SECURE_RET:				; keyboard interface maybe locked

	RET

KEYB_SECURE	ENDP
endif ; !JAPAN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; 8042 TYPE DETERMINATION
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SP_8042 PROC	NEAR			; Determine if 8042 is Patriot/Sebring
	PUSH	AX			; Save work register
	PUSH	CX			; Save count register
ifdef JAPAN
;       M005 -- begin changed section

        IN      AL, STATUS_PORT         ; In server password mode, no answer   ;JP9010
        TEST    AL, KYBD_INH            ; is returned from the following logic.;JP9010
        JZ      GET_FROM_ROM_BIOS       ; So, ask ROM BIOS.                    ;JP9010

;       M005 -- end changed section
endif ; JAPAN
	MOV	CX,24			; Limit AUX inputs if they are playing
					;  with the mouse while loading KEYB

SP__2:
	MOV	AL,DIS_KBD		; Disable command to clear 8042 output
	OUT	STATUS_PORT,AL		; Sending allows receive to complete
	STI				; Allow any pending AUX interrupt
	CALL	CHK_IBF 		; Wait for command to be accepted

	CLI				; Block interrupts until password set
	IN	AL,STATUS_PORT		; Read 8042 status byte
	TEST	AL,MOUSE_OBF		; Check for AUX data pending at output
	LOOPNZ	SP__2			; Loop till AUX inputs are cleared

	IN	AL,PORT_A		; Read to clear int's on SX  ;PTR660243
	MOV	AL,20h			; Read 8042 controller's command byte
	OUT	STATUS_PORT,AL		; Send command to 8042 interface
	CALL	CHK_IBF 		; Wait for command to be accepted
	MOV	CX,DLY_15ms		; Timeout 15 milliseconds (15000/15.086

SP__5:
ifdef JAPAN
        IN      AL,STATUS_PORT          ; Read status (command) port           ;AN012
        TEST    AL,OUT_BUF_FULL         ; Check for output buffer empty        ;AN012
        JNZ     SP__6                   ; Loop until OBF is ON                 ;AN012
endif ; JAPAN
	IN	AL,PORT_B		; Read current refresh output bit
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JZ	SHORT SP__5		; No?, wait for change, else continue

	MOV	AH,AL			; Save new refresh bit state
ifndef JAPAN
	IN	AL,STATUS_PORT		; Read status (command) port
	TEST	AL,OUT_BUF_FULL 	; Check for output buffer empty
	LOOPZ	SP__5			; Loop until OBF is on or timeout
else ; JAPAN
        LOOP    SP__5                   ; Loop until OBF is ON or timeout      ;AN012
SP__6:                                                                         ;AN012
endif ; JAPAN

	IN	AL,PORT_A		; Get the command byte
	TEST	AL,01000000b		; Check for translate bit on
	JNZ	SP_EXIT 		; Done if it is on to begin with

ifdef JAPAN
SP_EXIT_0:                              ; M005 ;JP9010
endif ; JAPAN
	OR	SD.SYSTEM_FLAG,PS_8042	; Set PATRIOT/SEBRING type 8042
					;  with Translate scan codes set OFF
SP_EXIT:
	MOV	AL,ENA_KBD		; Enable command for keyboard
	OUT	STATUS_PORT,AL		; Send to 8042
	CALL	CHK_IBF 		; Wait for command to be accepted
	IN	AL,PORT_A		; Read to clear int's on SX  ;PTR660243
	POP	CX			; Recover user register
	POP	AX			; Recover user register
	STI				; Enable inteerutps again
	RET				; Return to caller

ifdef JAPAN
;       M005 -- begin added section

RTN_SYSTEM_CONFIG       EQU     0C0H    ; INT15H SUB FUNCTION                  ;JP9010
FEATURE_INFO_2          EQU     006H    ; FEATURE INFO2 OFFSET IN CONFIG DATA  ;JP9010
NON_8042_CONTROLLER     EQU     004H    ; THIS BIT ON IF NON-8042 CONTROLLER   ;JP9010
GET_FROM_ROM_BIOS:                      ; WE CAN ONLY ASK ROM BIOS WHICH TYPE  ;JP9010
        PUSH    ES                      ; OF KEYBOARD CONTROLLER IS ATTACHED.  ;JP9010
        PUSH    BX                      ;                                      ;JP9010
        MOV     AH, RTN_SYSTEM_CONFIG   ;                                      ;JP9010
        INT     15H                     ;                                      ;JP9010
        JC      RTN_SYS_CONFIG_NOT_SUPPORTED; IN CASE NOT SUPPORTED, IT MUST   ;JP9010
                                        ; BE 8042. BELIEVE IT.                 ;JP9010
        TEST    BYTE PTR  ES:[BX+FEATURE_INFO_2], NON_8042_CONTROLLER          ;JP9010
        POP     BX                      ;                                      ;JP9010
        POP     ES                      ;                                      ;JP9010
        JNZ     SP_EXIT_0               ; IF NON-8042, SET THE FLAG            ;JP9010
        JMP     SHORT SP_EXIT           ;                                      ;JP9010
RTN_SYS_CONFIG_NOT_SUPPORTED:           ;                                      ;JP9010
        POP     BX                      ;                                      ;JP9010
        POP     ES                      ;                                      ;JP9010
        JMP     SHORT SP_EXIT           ;                                      ;JP9010

;       M005 -- end added section
endif ; JAPAN

SP_8042 ENDP

CODE	ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybi9.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI9.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBI9.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    KEYB_STATE_PROCESSOR:NEAR

	EXTRN	 FLAGS_TO_TEST:BYTE    ;;  (YST)
                                       ;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybi2f.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI2F.INC
;; ----------
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBI2F.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    KEYB_INT_2F:NEAR      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybdcl.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBDCL.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Common declarations for structures in procedures for KEYB.COM
;;
;; Change History:
;; ---------------
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
PARM_LIST	 STRUC		       ;;
;*******************CNS******************
;*******************CNS******************
    RET_CODE_1	    DB	 0	       ;;  \
    RET_CODE_2	    DB	 0	       ;;  |
    RET_CODE_3	    DB	 0	       ;;  |
;*******************CNS******************
    RET_CODE_4	    DB	 0	       ;;  |;AN000;
;*******************CNS******************
    LANGUAGE_PARM   DW	 ?	       ;;   }  PARAMETER
    CODE_PAGE_PARM  DW	 ?	       ;;  |	    LIST
    PATH_OFFSET     DW	 ?	       ;;  |
    PATH_LENGTH     DW	 0	       ;;  /
;*******************CNS******************
    ID_PARM	    DW	 ?	       ;AN000;
;*******************CNS******************
PARM_LIST	 ENDS		       ;;
				       ;;
DESIG_CP_STRUC	 STRUC		       ;;
    NUM_DESIGNATES  DW	 ?	       ;;
    NUM_FONTS	    DW	 ?	       ;;
    NUM_HW_CPS	    DW	 ?	       ;;
    DESIG_CP_ENTRY  DW	 ?	       ;;
DESIG_CP_STRUC	  ENDS		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybi9.asm ===
PAGE    ,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBI9.ASM
; ----------
;
; Description:
; ------------
;       Converts scan codes to ASCII for non-US keyboards.
;       This orutine uses the tables loaded into the SHARED_DATA_AREA
;       from KEYBOARD.SYS by the KEYB_COMMAND module.
;
;
; Procedures Contained in This File:
; ----------------------------------
;       KEYB_STATE_PROCESSOR - Scan to ASCII translator.
;
; External Procedure References:
; ------------------------------
;       None.
;
; Linkage Information:  Refer to file KEYB.ASM
; --------------------
;
; Change History:
; ---------------
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        INCLUDE KEYBEQU.INC
        INCLUDE DSEG.INC               ; System data segments
        INCLUDE POSTEQU.INC            ; System equates
        INCLUDE KEYBSHAR.INC
        INCLUDE KEYBI2F.INC
        INCLUDE KEYBI9C.INC
        INCLUDE KEYBCPSD.INC
        INCLUDE KEYBCMD.INC

        PUBLIC KEYB_STATE_PROCESSOR


        PUBLIC FLAGS_TO_TEST           ;; (YST)
        PUBLIC NLS_FLAG_1              ;; (YST)


CODE    SEGMENT PUBLIC 'CODE'

        ASSUME  CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: KEYB_STATE_PROCESSOR
;
; Description:
;     Convert scan to ASCII using the tables loaded into the
;     SHARED_DATA_AREA.  Conversion is directed by the STATE LOGIC
;     commands contained in the SHARED_DATA_AREA.  This routine
;     interprets those commands.
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;     Enable interrupts
;     Save registers
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BREAK_CODE    EQU  80H

HOT_KEY_ACTIVE  DB   0                 ; 1 if hot key is active


                                       ; These are copies of the BIOS FLAGS
FLAGS_TO_TEST    LABEL BYTE            ;  KB_FLAG, KB_FLAG_1,2,3
KB_SHADOW_FLAGS  DB   NUM_BIOS_FLAGS DUP(0)
EXT_KB_FLAG      DB   0                ; Extended KB Flag for shift states
NLS_FLAG_1       DB   0                ; NLS Flags for dead key etc
NLS_FLAG_2       DB   0                ;  .

SAVED_NLS_FLAGS  DB   0,0              ; Saved copy of the NLS flags

OPTION_BYTE     DB    0                ; Set by OPTION command

KB_FLAG_PTRS    DW   OFFSET KB_FLAG    ; These are pointers to the BIOS flags
                DW   OFFSET KB_FLAG_1  ;  we must test
                DW   OFFSET KB_FLAG_2
                DW   OFFSET KB_FLAG_3

XLAT_TAB_PTR    DW   0                 ; pointer to xlat tables for cur state

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


NEST_LEVEL      DB   0
PROCESS_LEVEL   DB   0
TAKE_ELSE       DB   0
BUSY_FLAG       DB   0                 ; Flag to prevent re-entry

CMD_JUMP_TABLE  LABEL  WORD
        DW   OFFSET  IFF_PROC          ; CODE  0
        DW   OFFSET  ANDF_PROC         ;       1
        DW   OFFSET  ELSEF_PROC        ;       2
        DW   OFFSET  ENDIFF_PROC       ;       3
        DW   OFFSET  XLATT_PROC        ;       4
        DW   OFFSET  OPTION_PROC       ;       5
        DW   OFFSET  SET_FLAG_PROC     ;       6
        DW   OFFSET  PUT_ERROR_PROC    ;       7
        DW   OFFSET  IFKBD_PROC        ;       8
        DW   OFFSET  GOTO_PROC         ;       9
        DW   OFFSET  BEEP_PROC         ;       A
        DW   OFFSET  RESET_NLS_PROC    ;       B
        DW   OFFSET  RESET_NLS1_PROC   ;       C
        DW   OFFSET  UNKNOWN_COMMAND   ;       D
        DW   OFFSET  UNKNOWN_COMMAND   ;       E
        DW   OFFSET  UNKNOWN_COMMAND   ;       F


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

KEYB_STATE_PROCESSOR   PROC   NEAR

        TEST   byte ptr CS:SD.TABLE_OK,1
        JNZ    WE_HAVE_A_TABLE
        CLC                            ; BACK TO US INT 9
        RET
WE_HAVE_A_TABLE:

        PUSH   DS                      ; save DS
        PUSH   ES                      ; save ES
        PUSH   AX                      ; save scan code for caller
        PUSH   BX                      ; save shift states for caller

        PUSH   CS
        POP    DS                      ; DS = our seg
        MOV    BX,DATA
        MOV    ES,BX                   ; addressability to BIOS data


        CMP     COUNTRY_FLAG,0FFH      ; Q..country mode?
        JE      INIT_STATE_PROCESSING  ; Y..continue
        JMP     GOTO_BIOS              ; N..exit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; -------STATE SECTION PROCESSING-------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INIT_STATE_PROCESSING:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set NLS shift flags EITHER_SHIFT, EITHER_ALT, EITHER_CTRL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                                       ; Q..in shift state?
        TEST   ES:KB_FLAG,RIGHT_SHIFT+LEFT_SHIFT
        JNZ    IN_SHIFT_STATE          ; Y..go set bit
        AND    EXT_KB_FLAG,NOT EITHER_SHIFT ; N..clear bit
        JMP    SHORT TEST_CTL
IN_SHIFT_STATE:
        OR     EXT_KB_FLAG,EITHER_SHIFT
TEST_CTL:
        TEST   ES:KB_FLAG,CTL_SHIFT    ; Q..in control state?
        JNZ    IN_CTL_STATE            ; Y..go set bit
        TEST   ES:KB_FLAG_3,R_CTL_SHIFT ; Q..how bout the right ctl?
        JNZ    IN_CTL_STATE            ; Y..go set the bit
        AND    EXT_KB_FLAG,NOT EITHER_CTL ; N..clear the bit
        JMP    SHORT TEST_ALT
IN_CTL_STATE:
        OR     EXT_KB_FLAG,EITHER_CTL
TEST_ALT:
        TEST   ES:KB_FLAG,ALT_SHIFT    ; Q..in alt state?
        JNZ    IN_ALT_STATE            ; Y..go set bit
        TEST   ES:KB_FLAG_3,R_ALT_SHIFT ; Q..how bout the right alt?
        JNZ    IN_ALT_STATE            ; Y..go set the bit
        AND    EXT_KB_FLAG,NOT EITHER_ALT ; N..clear the bit
        JMP    SHORT COPY_FLAGS
IN_ALT_STATE:
        OR     EXT_KB_FLAG,EITHER_ALT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copy BIOS KB flags from BIOS data seg into the
; FLAGS_TO_TEST structure.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_FLAGS:
        MOV    CX,NUM_BIOS_FLAGS
        xor    si,si                    ; pointers to the BIOS flags
        xor    di,di                    ; create shadow copies
MOVE_NEXT_FLAG:
        MOV    BX,KB_FLAG_PTRS[SI]     ; pointer to next flag
        MOV    AL,ES:[BX]              ; flag in AL
        MOV    KB_SHADOW_FLAGS[DI],AL  ; save it in the shadow table
        INC    DI
        INC    SI
        INC    SI
        LOOP   MOVE_NEXT_FLAG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Interpret State Logic Commands
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_STATES:
        MOV    OPTION_BYTE,0           ; clear options
        MOV    SI,SD.LOGIC_PTR
        LEA    SI,[SI].SL_LOGIC_CMDS
NEXT_COMMAND:
        XOR    BH,BH                   ; ????
        MOV    BL,[SI]                 ; command byte in BL
        SHR    BL,1
        SHR    BL,1
        SHR    BL,1
        SHR    BL,1                    ; ISOLATE COMMAND CODE
        SHL    BL,1                    ; command code * 2
        JMP    CMD_JUMP_TABLE[BX]      ; go process command
UNKNOWN_COMMAND:
        JMP    FATAL_ERROR             ; bad news


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    IFKBD_DONE              ; N..don't process

        MOV    AX,[SI+1]               ; Keyboard Type Flag

        TEST   SD.KEYB_TYPE,AX         ; Q..are we the right system?
        JNZ    IFKBD_TEST_OK           ; Y..
IFKBD_TEST_FAILED:
        MOV    TAKE_ELSE,YES           ; test failed - take ELSE
        JMP    SHORT IFKBD_DONE
IFKBD_TEST_OK:
        INC    PROCESS_LEVEL           ; process commands within IF
        MOV    TAKE_ELSE,NO
IFKBD_DONE:
        INC    NEST_LEVEL              ; IFKBD increments nest level
        INC    SI                      ; bump past IFKBD
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PUT_ERROR_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    PUT_ERROR_DONE          ; N..don't process
        MOV    DI,SD.ACTIVE_XLAT_PTR   ; pointer to active Xlat Section
        MOV    AL,[SI+1]               ; state id in AL
        CALL   PUT_ERROR               ; check active section
        JC     PUT_ERROR_DONE          ; carry set if translation found
        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   PUT_ERROR

PUT_ERROR_DONE:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

PUT_ERROR      PROC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search for a state whose ID matches the ID
; on the PUT_ERROR command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        CLC
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
PE_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     PE_EXIT                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     PE_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT PE_NEXT_STATE

PE_STATE_MATCH:
        MOV    AX,[DI].XS_ERROR_CHAR   ; get error char in AX
        CALL   BUFFER_FILL
        STC                            ; indicate that we found the state
PE_EXIT:
        RET

PUT_ERROR   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GOTO_BIOS:
        CLC                            ; clear carry flag indicating
        POP   BX                       ;  we should continue INT 9
        POP   AX                       ;   processing
        POP   ES
        POP   DS
        RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IFF_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    IFF_DONE                ; N..don't process IFF
        MOV    BL,[SI]                 ; command byte
        AND    BL,FLAG_ID_BITS         ; isolate flag id
        XOR    BH,BH
        MOV    AL,FLAGS_TO_TEST[BX]    ; flag in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT test?
        JNZ    ITS_A_NOT
        TEST   AL,[SI]+1               ; Y..check for bit set
        JNZ    IFF_MATCH
        JZ     IFF_NO_MATCH
ITS_A_NOT:
        TEST   AL,[SI]+1               ; Y..check for bit clear
        JZ     IFF_MATCH
IFF_NO_MATCH:
        MOV    TAKE_ELSE,YES           ; flag test failed - take ELSE
        JMP    SHORT IFF_DONE
IFF_MATCH:
        INC    PROCESS_LEVEL           ; process commands within IF
        MOV    TAKE_ELSE,NO

IFF_DONE:
        INC    NEST_LEVEL              ; IFF increments nest level
        INC    SI                      ; bump past IFF
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELSEF_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    CHECK_TAKE_ELSEF        ; N..check for take_else
        DEC    PROCESS_LEVEL           ; Y..we just finished the "IF" block
        JMP    short ELSEF_DONE        ;    so we are finished with IFF/ELSEF
CHECK_TAKE_ELSEF:
        CMP    TAKE_ELSE,YES           ; Q..are we scanning for ELSE?
        JNE    ELSEF_DONE              ; N..done
        DEC    NEST_LEVEL              ; ELSEF itself is back a level
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    NOT_THIS_ELSEF          ; N..this else is not the one
        INC    PROCESS_LEVEL           ; Y..process ELSEF block
        MOV    TAKE_ELSE,NO            ; reset
NOT_THIS_ELSEF:
        INC    NEST_LEVEL              ; stuff within the ELSEF is up a level

ELSEF_DONE:
        INC    SI                      ; bump past ELSEF
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIFF_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    ENDIFF_DONE             ; N..don't adjust process level
        DEC    PROCESS_LEVEL           ; Y..we just finished the IF/ELSE
ENDIFF_DONE:
        DEC    NEST_LEVEL              ; ENDIF decrements nest level
        INC    SI                      ; bump past ENDIF
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Translations may be in the Common or Specific
; Sections.  Search the Specific section first
; then the common section.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
XLATT_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    XLATT_DONE              ; N..next command
        MOV    DI,SD.ACTIVE_XLAT_PTR   ; pointer to active Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   TRANSLATE               ; check active section
        JC     XLATT_FOUND             ; carry set if translation found
        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   TRANSLATE
        JNC    XLATT_DONE
XLATT_FOUND:
        OR     EXT_KB_FLAG,SCAN_MATCH  ; set flag indicating scan matched
        TEST   OPTION_BYTE,EXIT_IF_FOUND ; Q..exit
        JZ     XLATT_DONE
        JMP    EXIT                    ; Y..BYE

XLATT_DONE:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

TRANSLATE PROC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search for a state whose ID matches the ID
; on the XLATT command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        CLC
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
TP_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     TP_EXIT                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     TP_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT TP_NEXT_STATE

TP_STATE_MATCH:
        AND    EXT_KB_FLAG,NOT SCAN_MATCH  ; reset flag before search
        PUSH   SI                      ; save pointer to next command
        LEA    SI,[DI].XS_FIRST_TAB    ; point to first xlat table
        MOV    XLAT_TAB_PTR,SI         ; start of XLAT tables
        MOV    AL,SCAN_CODE            ; restore incoming scan code
        JMP    SHORT NEXT_XLAT_TAB
TP_DONE:                               ; return here from XLAT
        POP    SI
TP_EXIT:
        RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Check xlate tables for matching scan code
; The xlate table can be in one of two forms:
;    Type 1 = Table contains buffer entries only.
;             Scan code is used as an index into xlat table
;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;             Table must be searched for matching scan.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NEXT_XLAT_TAB:
        MOV    SI,XLAT_TAB_PTR         ; pointer to xlat tables
        CMP    [SI].XLAT_TAB_SIZE,0    ; Q..any more xlat tables?
        JNE    PROCESS_XLAT_TAB        ; Y..check um
        JMP    TP_DONE                 ; N..done
PROCESS_XLAT_TAB:
        MOV    DL,[SI].XLAT_OPTIONS    ; save translate options IN DL
        MOV    BX,[SI].XLAT_TAB_SIZE   ; Y..calc pointer to next xlat tab
        ADD    BX,SI
        MOV    XLAT_TAB_PTR,BX         ; pointer to next xlat tab
        TEST   DL,TYPE_2_TAB           ; Q..is this a type 2 table?
        JZ     TYPE_1_LOOKUP           ; N..go do table lookup
TYPE_2_SEARCH:                         ; Y..search table
        XOR    CH,CH
        MOV    CL,[SI].XLAT_NUM        ; number of xlat entries
        MOV    BX,DEFAULT_TAB_2_ENT_SZ ; default entry size
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..are buffer entries ASCII only?
        JZ     NEXT_TAB_2_ENTRY        ; N..continue
        MOV    BX,ASC_ONLY_TAB_2_ENT_SZ ; Y..set size in BX
NEXT_TAB_2_ENTRY:                      ; entry size is in BX
        jcxz    next_xlat_tab           ;   brif last entry
        CMP    AL,[SI].XLAT_SCAN       ; Q..scan match?
        JE     FOUND_TAB_2_ENTRY       ; Y..go create buffer entry
        ADD    SI,BX                   ; point to next entry
        LOOP   NEXT_TAB_2_ENTRY
        JMP    SHORT NEXT_XLAT_TAB
FOUND_TAB_2_ENTRY:                     ; Q..set scan code to 0?
        MOV    AH,AL                   ; default scan code in AH
        MOV    AL,[SI].XLAT_2_BUF_ENTRY ; ASCII code from table in AL
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..are buffer entries ASCII only?
        JNZ    BUFFER_ENTRY_READY      ; Y..buffer entry is ready
        MOV    AH,[SI].XLAT_2_BUF_ENTRY+1 ; N..scan code from table as well
        JMP    SHORT BUFFER_ENTRY_READY ; go put entry in buffer

TYPE_1_LOOKUP:
        CMP    AL,[SI].XLAT_SCAN_LO    ; Q..is scan in range of this table?
        JB     NEXT_XLAT_TAB           ; N..next table
        CMP    AL,[SI].XLAT_SCAN_HI    ; Q..is scan in range of this table?
        JA     NEXT_XLAT_TAB           ; N..next table
        SUB    AL,[SI].XLAT_SCAN_LO    ; convert scan code to xlat index
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..ASCII only in xlat ?
        JZ     TWO_BYTE_LOOKUP         ; N..go do 2-byte lookup
        LEA    BX,[SI].XLAT_1_BUF_ENTRY ; Y..do 1-byte lookup
        XLAT   [SI].XLAT_1_BUF_ENTRY   ; ASCII code in AL
        MOV    AH,SCAN_CODE            ; SCAN in AH
        JMP    SHORT BUFFER_ENTRY_READY ; go put entry in buffer
TWO_BYTE_LOOKUP:
        MOV    BL,2                    ; multiply scan index
        MUL    BL                      ;  by two
        MOV    BX,AX                   ; real index in BX
        MOV    AX,WORD PTR [SI].XLAT_1_BUF_ENTRY[BX] ; get 2-byte buffer entry
                                       ;  AL=ASCII  AH=SCAN
BUFFER_ENTRY_READY:
        TEST   DL,ZERO_SCAN            ; Q..set scan part to zero?
        JZ     NO_ZERO_SCAN            ; N..
        XOR    AH,AH                   ; scan = 0
NO_ZERO_SCAN:
        CALL   BUFFER_FILL             ; go put entry in buffer
        STC                            ; indicate translation found
        JMP    TP_DONE

TRANSLATE ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPTION_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    DONE_OPTION             ; N..done
        MOV    AL,[SI]+1               ; mask in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT?
        JNZ    AND_MASK
        OR     OPTION_BYTE,AL          ; N..OR in the mask bits
        JMP    short DONE_OPTION
AND_MASK:
        NOT    AL
        AND    OPTION_BYTE,AL          ; Y..AND out the mask bits
DONE_OPTION:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    RN_DONE                 ; N..don't process
        MOV    NLS_FLAG_1,0
        MOV    NLS_FLAG_2,0


        MOV    COPY_NLS1_FLAG,0        ;; (YST)


RN_DONE:
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This PROC only for Yugoslavian (Cyrillic)
;; keyboard from CRAZY IBM (YST)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RESET_NLS1_PROC:                       ;;
        MOV    AL,NEST_LEVEL           ;;
        CMP    AL,PROCESS_LEVEL        ;; Q..nest level = process level?
        JNE    RN1_DONE                 ;; N..don't process
        MOV    NLS_FLAG_1, 1            ;;
        MOV    NLS_FLAG_2,0            ;;
        MOV    COPY_NLS1_FLAG, 1        ;; (YST)
RN1_DONE:                               ;;
        INC    SI                      ;;
        JMP    NEXT_COMMAND            ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BEEP_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    BP_DONE                 ; N..don't process
        MOV    BEEP_PENDING,YES        ; set beep pending flag. the beep
                                       ;  will be done just before iret
BP_DONE:
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOTO_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    GOTO_DONE               ; N..don't process
        MOV    BL,[SI]                 ; command byte in BL
        AND    BL,NOT COMMAND_BITS     ; remove command code
        OR     BL,BL                   ; Q..goto label?
        JZ     GOTO_LABEL              ; Y..go jump
        CMP    BL,EXIT_INT_9_FLAG      ; Q..SPECIAL - Exit Int 9?
        JNE    NOT_EXIT_INT_9          ; N..
        JMP    EXIT                    ; Y..bye bye
NOT_EXIT_INT_9:
        CMP    BL,EXIT_STATE_LOGIC_FLAG ; Q..SPECIAL - Exit State Logic?
        JNE    NOT_EXIT_S_L            ; N..
        JMP    GOTO_BIOS               ; Y..goto bios
NOT_EXIT_S_L:
        JMP    FATAL_ERROR             ; garbage in that command
GOTO_LABEL:
        ADD    SI,[SI]+1               ; bump by relative offset
        MOV    PROCESS_LEVEL,0         ; reset process and nest level
        MOV    NEST_LEVEL,0
GOTO_DONE:
        ADD    SI,3                    ; bump to next command
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ANDF_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    ANDF_DONE               ; N..don't process ANDF
        MOV    BL,[SI]                 ; command byte
        AND    BL,FLAG_ID_BITS         ; isolate flag id
        XOR    BH,BH
        MOV    AL,FLAGS_TO_TEST[BX]    ; flag in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT test?
        JNZ    ANDF_NOT
        TEST   AL,[SI]+1               ; Y..check for bit set
        JNZ    ANDF_DONE               ; if set then remain in IFF
        JZ     ANDF_NO_MATCH
ANDF_NOT:
        TEST   AL,[SI]+1               ; Y..check for bit clear
        JZ     ANDF_DONE               ; if clear then remain in IFF
ANDF_NO_MATCH:
        MOV    TAKE_ELSE,YES           ; flag test failed - take ELSE
        DEC    PROCESS_LEVEL           ; IFF would have inc'd - so dec
ANDF_DONE:
        INC    SI                      ; bump past ANDF
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SET_FLAG Command.
; Flag Table must be in the Common Section
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SET_FLAG_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    SF_DONE                 ; N..don't process

        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id in AL
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
SF_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     SF_DONE                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     SF_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT SF_NEXT_STATE

SF_STATE_MATCH:
        AND    EXT_KB_FLAG,NOT SCAN_MATCH  ; reset flag before search
        PUSH   SI                      ; save pointer to next command
        LEA    SI,[DI].XS_FIRST_TAB    ; point to table
        MOV    AL,SCAN_CODE            ; restore incoming scan code
        MOV    CX,[SI]                 ; number of entries
        jcxz    sf_restore              ; done if no entries
        INC    SI                      ; Y..Bump to first entry
        INC    SI
NEXT_SF_ENTRY:
        CMP    AL,[SI]                 ; Q..scan match?
        JE     FOUND_SF_ENTRY          ; Y..go set flag
        ADD    SI,3                    ; point to next entry
        LOOP   NEXT_SF_ENTRY
        JMP    SHORT SF_RESTORE        ; no match found
FOUND_SF_ENTRY:
        MOV    NLS_FLAG_1,0            ; clear all NLS bits
        MOV    NLS_FLAG_2,0
        MOV    BL,[SI]+1               ; flag id in BX
        XOR    BH,BH
        MOV    AL,[SI]+2               ; mask in AL
        OR     FLAGS_TO_TEST[BX],AL    ; set the bit
        OR     EXT_KB_FLAG,SCAN_MATCH  ; set flag indicating scan matched


        MOV    AL,NLS_FLAG_1           ;; copy NLS_FLAG_1 to the (YST)
        MOV    COPY_NLS1_FLAG,AL       ;; public place (YST)


        TEST   OPTION_BYTE,EXIT_IF_FOUND ; Q..exit
        JZ     SF_RESTORE
        POP    SI
        JMP    short EXIT
SF_RESTORE:
        POP    SI
SF_DONE:
        INC    SI                      ; bump past command
        INC    SI
        JMP    NEXT_COMMAND


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Fatal Error routine.  Come here when
; we have a critical error such as an
; invalid State Logic Command.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FATAL_ERROR:
        JMP   SHORT EXIT               ; end the int 9 processing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Exit point.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EXIT:
        MOV   BUSY_FLAG,NO
        STC                            ; indicate we should end INT 9
        POP   BX                       ;  processing
        POP   AX
        POP   ES
        POP   DS
        RET

KEYB_STATE_PROCESSOR   ENDP



CODE   ENDS
       END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybi9c.asm ===
PAGE    ,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;  File Name:  KEYBI9C.ASM
;  ----------
;
;
;  Description:
;  ------------
;        Interrupt 9 mainline.
;        This routine handles all US keyboard support for the following
;        system units:  PC, PC-XT, PC-AT, PC Convertible, PC-XT/286
;                       Models 25 and 30 (PALACE),
;                       PS/2's - all 8042 based 80286, 80386 and 80486.
;                              - all PATRIOT and SEBRING based systems.
;        KEYB_STATE_PROCESSOR is called for non-US keyboard support.
;
;
;
;  Procedures Contained in This File:
;  ----------------------------------
;        KEYB_INT_9 - Interrupt 9
;
;  External Procedure References:
;  ------------------------------
;        FROM FILE  KEYBI9.ASM:
;             KEYB_STATE_PROCESSOR - Non US keyboard support.
;
;  Linkage Information:  Refer to file KEYB.ASM
;  --------------------
;
;  Change History:
;  ---------------
;  ; - DCR 478 -        KEYBOARD INT SPLICING Nick Savage  ;deleted by AN005
;  ; - PTM 3090         ENABLING RIGHT CTL FOR RE-BOOTING
;  ; - PTM 60XX         PICK UP ALL KEYBOARD BIOS PTR's AND DCR's TO BRING
;                       INT 9h  UP TO THE TOPHAT (80486) SUPPORT LEVEL. '89  jwg
;          PTR 6600736  Keep INT's disabled till after PORT 60h read.
;          PTR 6600756  EXTRA EOI ISSUED IF INTERRUPTS SATURATED **********
;                          NOTE: This is a fix for a BIOS bug that goes all
;                           the way back to the first AT.  The rationale for
;                           the fix is as follows:
;           (deleted AN005)     A stack frame is created upon entry (BP) and
;                               CHK_EOI is called to check the frame. If no
;                               EOI has been issued, CHK_EOI does it and
;                               resets the frame, preventing any additinal
;                               EOI's from being issued on subsequent calls
;                               to CHK_EOI.  All direct EOI's in the code
;                               have been replaced with calls to CHK_EOI.
;
;  ;Ax004; - PTM 2555   KEYB command locks keyboard. 10/5/89;cja
;                       ; jwg 11/09/98 Updates - Wild Mouse, etc workaround.....
;  ; - PTM 5802         Restructure Interrupt Splicing to correct lost Mouse
;                       interrupt when LED's are updated.  Make it apply to
;                       all systems. Essentially remove all code added by AN001.
;                       Remove stack frame logic of AN003 and PTR 6600756 and do
;                       an early EOI.  Requires a CLI at K38B and other places.
;                       Remove Chk_ibf before 60h.
;                       Re-write ERROR_BEEP to make processor speed independent
;                       for AT and PS/2 systems and right tone if interrupts.
;                       Make SHIP_IT handle call on PC machines.
;                       Use BP to hold system flags during interrupt processing.
;          PTR 6602049  Fix problem with Pause Key hanging system if Mouse
;                       driver is using polled mode.  (Port 60h hangs.)
;          PTR 6602247  Change JMP at K40 to stop extra Enable Keyboard cmd.
;          PTR 6602319  Fix interrupt window on System Request key allowing
;                       following scan code(s) to be processed out of sequence.
;          PTR 6602355  Fix Print Screen clearing E0 state flags too late.
;  ; - ;deleted         Add code the clear "Wild Mouse" condition at PAUSE wait.
;  ; -  PTM 6660        Move determination code for original PC1 to COMMSUBS.ASM
;          - ;jwg 2/90  Add Patriot/Sebring HOT REPLUG code so keyboard can be
;                       switched back to Scan Code Set 1 if repluged.  LIB LITE
;  ; -  PTM 6680        Remove code attempting to re-sync BIOS flags with reset
;                       Keyboard.  Test case simulators can/are sending invalid
;                       sequence of AA,AA.  Must leave BIOS flags alone on POR.
;  ; -  PTM 6716        MicroSoft WORKS (German version) reentrancy problem with
;          - ;jwg 3/90  NLS state processor and save scan code.  LED update ACK
;                       overlays memory before NLS processing of scan code.
;                       Remove AN006 "Wild Mouse" reset code, field tests done.
;  ; -  PTM ????        Fix read ID logic to recognize 122 keyboards and set the
;	     ;jwg 8/90	KBX flag on any enhansed keyboard.
;  ; -  PTM ????        Add 122 Keyboard key support tables.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        INCLUDE KEYBEQU.INC
        INCLUDE DSEG.INC                ; System data segments
        INCLUDE POSTEQU.INC             ; System equates
        INCLUDE KEYBSHAR.INC
        INCLUDE KEYBI2F.INC
        INCLUDE KEYBI9.INC
        INCLUDE KEYBCPSD.INC
        INCLUDE KEYBCMD.INC

include bop.inc
include vint.inc

        PUBLIC  KEYB_INT_9
        PUBLIC  K8                      ; CTRL case tables
        PUBLIC  SCAN_CODE
        PUBLIC  BUFFER_FILL
        PUBLIC  COUNTRY_FLAG


        PUBLIC COPY_NLS1_FLAG          ;; (YST)


        PUBLIC  BEEP_PENDING
        PUBLIC  ERROR_BEEP
        PUBLIC  CHK_IBF
ifdef JAPAN
	PUBLIC	S_122_MARKER		; 122 KEYBOARD F8/00 marker
	PUBLIC	BEEP_DELAY		; Error beep delay, default=19
	PUBLIC	SCAN_CODE_SET		; Keyboard Scan Code Set in use
	PUBLIC	READ_ID2		; Second byte read on last READ ID
endif ; JAPAN



ID_1            EQU     0ABH            ; 1ST ID CHARACTER FOR KBX
TID_2           EQU     041H            ; US G-LAYOUT
TID_2A          EQU     054H            ; US P-LAYOUT

;UNTRANSLATED 2ND ID CHAR FOR KBDX
ID_2U           EQU     083H            ; US G-LAYOUT (PATRIOT)
ID_2AU          EQU     084H            ; US P-LAYOUT (PATRIOT)
ID_122          EQU     086H            ; 2ND ID CHARACTER FOR 122-KEYBOARD
ID_2JG          EQU     090H            ; JPN G-LAYOUT
ID_2JP          EQU     091H            ; JPN P-LAYOUT
ID_2JA          EQU     092H            ; JPN A-LAYOUT

ifdef JAPAN
S_XKBD_SCAN	EQU	0A6h		; Highest Character Code For Enhanced
S_122_MARK	EQU	0F8h		; Marker for EXTENDED 122 keys DCR 1815
endif ; JAPAN

DIAGS   SEGMENT AT 0FFFFH
        ORG     0
RESET   LABEL   FAR
DIAGS   ENDS


CODE    SEGMENT PUBLIC 'CODE'
        ASSUME  CS:CODE,DS:DATA


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   TABLE OF SHIFT KEYS AND MASK VALUES
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;------ KEY_TABLE
K6      LABEL   BYTE
        DB      INS_KEY                 ; INSERT KEY
        DB      CAPS_KEY,NUM_KEY,SCROLL_KEY,ALT_KEY,CTL_KEY
        DB      LEFT_KEY,RIGHT_KEY
K6L     EQU     $-K6

;------ MASK_TABLE
K7      LABEL   BYTE
        DB      INS_SHIFT               ; INSERT MODE SHIFT
        DB      CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT,ALT_SHIFT,CTL_SHIFT
        DB      LEFT_SHIFT,RIGHT_SHIFT

;----------  TABLES FOR ALT CASE  -----
;------ ALT-INPUT-TABLE
K30     LABEL   BYTE
        DB      82,79,80,81,75
        DB      76,77,71,72,73          ; 10 NUMBERS ON KEYPAD
;------ SUPER-SHIFT-TABLE
        DB      16,17,18,19,20,21       ; A-Z TYPEWRITER CHARS
        DB      22,23,24,25,30,31
        DB      32,33,34,35,36,37
        DB      38,44,45,46,47,48
        DB      49,50
K30_LEN         EQU     $-K30-10

;------ ALT-INPUT-FUNCTION-TABLE   53H - 7EH
K30A    LABEL   BYTE
        DB      -1,-1,-1,-1,139,140     ; Del, SysReq, Undef, WT, F11, F12
        DB      -1,235,218,219,220      ; Undef, PA1, F13, F14, F15
        DB      -1,-1,-1,-1,-1          ; Pause, Undef 5F-62
        DB      221,222,223,226,227     ; F16, F17, F18, F19, F20,
        DB      228,229,230,231         ; F21, F22, F23, F24,
        DB      -1,243,-1,-1            ; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,253 	                ; K#74, Clear,
ifdef NOT_NTVDM
;;*     DB             -1,-1,-1         ;              Undef, K#109, Undef
;;*     DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, Undef
else
        DB             -1,-1,-1         ;              Undef, K#109, Undef
        DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, K#107
endif
ifdef JAPAN
	DB	-1			; 07Eh, 07Fh.  DBCS Pseudo codes.
					;  H_LAST_SCAN must be 07Fh for DBCS
endif ; JAPAN

H_LAST_SCAN     EQU     $-K30A+52h      ; Largest valid scan code in table
                                        ;  K30A K8 K15 K14 must have same ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  K8 is overlaid by K8_RPL (from module KEYB_COMMAND)
;  if extended INT 16 support is available
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

K8      LABEL   BYTE                    ;-------- CHARACTERS ---------
        DB      27,-1,00,-1,-1,-1       ; Esc, 1, 2, 3, 4, 5
        DB      30,-1,-1,-1,-1,31       ; 6, 7, 8, 9, 0, -
        DB      -1,127,-1,17,23,5       ; =, Bksp, Tab, Q, W, E
        DB      18,20,25,21,09,15       ; R, T, Y, U, I, O
        DB      16,27,29,10,-1,01       ; P, [, ], Enter, Ctrl, A
        DB      19,04,06,07,08,10       ; S, D, F, G, H, J
        DB      11,12,-1,-1,-1,-1       ; K, L, ;, ', `, LShift
        DB      28,26,24,03,22,02       ; \, Z, X, C, V, B
        DB      14,13,-1,-1,-1,-1       ; N, M, ,, ., /, RShift
        DB      '*',-1,' ',-1           ; *, Alt, Space, CL
                                        ;--------- FUNCTIONS ---------
        DB      94,95,96,97,98,99       ; F1 - F6
        DB      100,101,102,103,-1,-1   ; F7 - F10, NL, SL
        DB      119,-1,132,-1,115,-1    ; Home, Up, PgUp, -, Left, Pad5
        DB      116,-1,117,-1,118,-1    ; Right, +, End, Down, PgDn, Ins
        DB      -1,-1,-1,-1,137,138     ; Del, SysReq, Undef, WT, F11, F12
                                        ;---------- 122 KEYBOARD not overlaid
        DB      -1,234,206,207,208      ; Undef, PA1, F13, F14, F15
        DB      -1,-1,-1,-1,-1          ; Pause, Undef 5F-62
        DB      209,210,211,212,213     ; F16, F17, F18, F19, F20,
        DB      214,215,216,217         ; F21, F22, F23, F24,
        DB      -1,242,-1,-1            ; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,252                  ; K#74, Clear,
ifdef NOT_NTVDM
;;*     DB             -1,-1,-1         ;              Undef, K#109, Undef
;;*     DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, Undef
else
        DB             -1,-1,-1         ;              Undef, K#109, Undef
        DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, K#107
endif
ifdef JAPAN
	DB	-1                      ; 07Eh, 07Fh.  DBCS Pseudo codes.
endif ; JAPAN

;-----  TABLES FOR LOWER CASE (USA)  --

K10     LABEL   BYTE
        DB      27,'12345'
        DB      '67890-'
        DB      '=',08,09,'qwe'
        DB      'rtyuio'
        DB      'p[]',0DH,-1,'a'        ; LETTERS, Return, Ctrl
        DB      'sdfghj'
        DB      "kl;'`",-1              ; LETTERS, L Shift
        DB      '\zxcvb'
        DB      'nm,./'
        DB      -1,'*',-1,' \'          ; R Shift, *, Alt, Sp, CL (REALLY WT KEY)

;------ LC TABLE SCAN
        DB      59,60,61,62,63          ; BASE STATE OF F1 - F10
        DB      64,65,66,67,68
        DB      -1,-1                   ; NL, SL

;------ KEYPAD TABLE
K15     LABEL   BYTE
        DB      71,72,73,-1,75,-1       ; Home, Up, PgUp, -1, Left, -1
        DB      77,-1,79,80,81,82       ; Right, -1, End, Down, PgDn, Ins
        DB      83                      ; Del
        DB      -1,-1,'\',133,134       ; SysRq, Undef, WT, F11, F12
ifndef JAPAN
        DB      -1,232,182,183,184      ; Undef, PA1, F13, F14, F15
else ; JAPAN
	DB	-1,232,236,237,238	; Undef, PA1, F13, F14, F15
endif ; JAPAN
        DB      -1,-1,-1,-1,-1          ; Pause, Undef 5F-62
ifndef JAPAN
        DB      185,186,187,188,189     ; F16, F17, F18, F19, F20,
        DB      190,191,192,193         ; F21, F22, F23, F24,
else ; JAPAN
	DB	239,244,245,246,247	; F16, F17, F18, F19, F20,
	DB	248,249,250,192 	; F21, F22, F23, F24,
endif ; JAPAN
        DB      -1,240,-1,-1            ; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,251                  ; K#74, Clear,
ifdef NOT_NTVDM
;;*     DB             -1,-1,-1         ;              Undef, K#109, Undef
;;*     DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, Undef
else
        DB             -1,-1,-1         ;              Undef, K#109, Undef
        DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, K#107
endif
ifdef JAPAN
	DB      -1                      ; 07Eh, 07Fh.  DBCS Pseudo codes.
endif ; JAPAN

;-------  TABLES FOR UPPER CASE (USA)

K11     LABEL   BYTE
        DB      27,'!@#$%'
        DB      '^&*()_'
        DB      '+',08,00,'QWE'
        DB      'RTYUIO'
        DB      'P{}',0DH,-1,'A'        ; LETTERS, Return, Ctrl
        DB      'SDFGHJ'
        DB      'KL:"~',-1              ; LETTERS, L Shift
        DB      '|ZXCVB'
        DB      'NM<>?'
        DB      -1,'*',-1,' |'          ; R Shift, *, Alt, Sp, CL (REALLY WT KEY)

;------ UC TABLE SCAN
K12     LABEL   BYTE
        DB      84,85,86,87,88          ; SHIFTED STATE OF F1 - F10
        DB      89,90,91,92,93
        DB      -1,-1                   ; NL, SL

;------ NUM STATE TABLE
K14     LABEL   BYTE
        DB      '789-456+1230.'         ; NUMLOCK STATE OF KEYPAD KEYS
        DB      -1,-1,'|',135,136       ; SysRq, Undef, WT, F11, F12
ifndef JAPAN
        DB      -1,233,194,195,196      ; Undef, PA1, F13, F14, F15
else ; JAPAN
	DB	-1,233,193,195,196	; Undef, PA1, F13, F14, F15
endif ; JAPAN
        DB      -1,-1,-1,-1,-1          ; Pause, Undef 5F-62
        DB      197,198,199,200,201     ; F16, F17, F18, F19, F20,
        DB      202,203,204,205         ; F21, F22, F23, F24,
        DB      -1,241,-1,-1            ; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,251                  ; K#74, Clear,
ifdef NOT_NTVDM
;;*     DB             -1,-1,-1         ;              Undef, K#109, Undef
;;*     DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, Undef
else
        DB             -1,-1,-1         ;              Undef, K#109, Undef
        DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, K#107
endif
ifdef JAPAN
        DB      -1                      ; 07Eh, 07Fh.  DBCS Pseudo codes.
endif ; JAPAN
PAGE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: KEYB_INT_9
;
;  Description:
;      Entry point for interrupt 9 processing.
;
;  Input Registers:
;      None
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		EVEN			; Keep KEYB_INT_9 entry on even boundry
BEEP_PENDING	DB	NO		; YES if a beep is needed
SCAN_CODE	DB	0		; Last SCAN code read

KEYB_INT_9      PROC   NEAR

         JMP  SHORT KB_INT_1            ;; (YST)
COPY_NLS1_FLAG  DB       0              ;; (YST)
COUNTRY_FLAG    DB      -1              ; WHERE THE INT9 VECTOR POINTS
ifdef JAPAN
READ_ID2	DB	0		; Second byte from last READ ID
BEEP_DELAY	DW	19		; Error beep delay, 19=Refresh loop,
					;  the half cycle time for 1745 hz
SCAN_CODE_SET	DB	01h		; In case of old DBCS keyboards, this
					;  may be 81h or 82h.  Default is 01
S_122_MARKER	DB	0F8h		; Marker for 122-KEYBOARD KEYS DCR 1815
					;  Changed to E0 depending on INT 16h
	EVEN				; Force to even location
endif ; JAPAN
KB_INT_1:

                                        ; Do NOT enable interrupts untill after
                                        ;  PORT 60h has been read.  INT 15h has
                                        ;  interrupt window, do EOI, fast pass.
        PUSH    BP                      ; Reserved in KEYBi9c for SD.SYSTEM_FLAG
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    SI
        PUSH    DI
        PUSH    DS
        PUSH    ES
        CLD                             ; FORWARD DIRECTION
        MOV     BX,DATA                 ; SET UP ADDRESSING
        MOV     DS,BX                   ; DS POINTS AT THE ROM BIOS DATA AREA
        MOV     BP,CS:SD.SYSTEM_FLAG    ; GET CS:SD.SYSTEM_FLAG, AND USE BP


ifdef NOT_NTVDM
;/* --  WAIT TILL KEYBOARD DISABLE COMMAND CAN BE ACCEPTED
        MOV     AL,DIS_KBD              ; DISABLE THE KEYBOARD COMMAND
        CALL    SHIP_IT                 ; EXECUTE DISABLE
else
        mov     ah, 1                   ; notify I9 entry to softpc
        BOP     09h
        nop                             ; Carbon copy traces for
        nop                             ; "in al,PORT_A"
endif                                   ; keep it traceable

        IN      AL,PORT_A               ; READ IN THE CHARACTER


;/* --  SYSTEM HOOK  INT 15H - FUNCTION 4FH  (ON HARDWARE INTERRUPT LEVEL 9H)

        MOV     AH,04FH                 ; SYSTEM INTERCEPT - KEY CODE FUNCTION
        STC                             ; SET CY= 1 (IN CASE OF IRET)
        INT     15H                     ; CASSETTE CALL   (AL)= KEY SCAN CODE
                                        ;  RETURNS CY= 1 FOR INVALID FUNCTION

ifdef NOT_NTVDM
                                        ; EARLY  EOI for all interrupts done
                                        ;  after INT 15h to prevent re-entrancy
        XCHG    BX,AX                   ; SAVE SCAN CODE
        MOV     AL,EOI                  ; END OF INTERRUPT COMMAND (EARLY EOI)
        OUT     INTA00,AL               ; SEND EOI TO INTERRUPT CONTROL PORT
        XCHG    BX,AX                   ; RECOVER SCAN CODE
endif

        JC      KB_INT_02               ; CONTINUE IF CARRY FLAG SET ((AL)=CODE)
        JMP     K26                     ; EXIT IF SYSTEM HANDLED SCAN CODE
                                        ;  EXIT HANDLES ENABLE

;/* --- CHECK FOR A POSSIBLE HOT REPLUG AND A POR COMPLETE CODE
KB_INT_02:                              ;       (AL)= SCAN CODE

ifdef NOT_NTVDM
; ntvdm we don't do keyboard resets\power on stuff
;
                                        ;       CHECK FOR POR
        CMP     AL,KB_OK                ; CHECK FOR POSSIBLE KEYBOARD POR CHAR
        JNE     KB_INT_03               ; CONTINUE NOT A POR OF AA
                                        ;       CHECK FOR ENHANSED KEYB
        TEST    KB_FLAG_3,LC_E0                 ; WAS E0h LAST SCAN CODE?    DCR467
        JNZ     KB_INT_03               ; SKIP KB POR IF IT WAS
                                        ;       CHECK FOR LEFT SHIFT BREAK
        TEST    KB_FLAG,LEFT_SHIFT      ; IS LEFT SHIFT ACTIVE?
        JNZ     KB_INT_03               ; SKIP KB POR IF IT WAS
                                        ;       KEYBOARD POWER ON DETECTED
        MOV     CS:BEEP_PENDING,YES     ; INDICATE WE NEED A BEEP
        MOV     KB_FLAG_2,0             ; CLEAR ALL LED FLAGS TO FORCE UPDATE
                                        ; LEAVE OTHERS SO KB SIMULATORS WORK

        TEST    BP,PS_8042              ; SYSTEM USING 8042 & SCAN CODE SET 01?
        JZ      KB_INT_03               ; SKIP IF SYSTEM USES DEFAULT SCS 02
                                        ;       PATRIOT/SEBRING 8042 GATE ARRAY
        MOV     AL,SCAN_CODE_CMD        ; SELECT SCAN CODE SET COMMAND
        CALL    SND_DATA                ; SEND IT DIRECTLY TO THE KEYBOARD
        MOV     AL,01h                  ; SELECT SCAN CODE SET 01
        CALL    SND_DATA                ; SEND IT TO THE KEYBOARD
        MOV     AL,KB_OK                ; RESTORE POR SCAN CODE IN (AL)
endif

KB_INT_03:

;/* --- CHECK FOR A RESEND COMMAND TO KEYBOARD

        ;; NTVDM STI                             ; ENABLE INTERRUPTS AGAIN
        CMP     AL,KB_RESEND            ; IS THE INPUT A RESEND
        JE      KB_INT_4                ; GO IF RESEND

;/* --- CHECK FOR RESPONSE TO A COMMAND TO KEYBOARD

        CMP     AL,KB_ACK               ; IS THE INPUT AN ACKNOWLEDGE
        JNZ     KB_INT_2                ; GO IF NOT

;/* --- A COMMAND TO THE KEYBOARD WAS ISSUED

        ;; NTVDM CLI                             ; DISABLE INTERRUPTS
        OR      KB_FLAG_2,KB_FA         ; INDICATE ACK RECEIVED
        JMP     K26                     ; RETURN IF NOT (ACK RETURNED FOR DATA)

;/* --- RESEND THE LAST BYTE

KB_INT_4:
        ;; NTVDM CLI                             ; DISABLE INTERRUPTS
        OR      KB_FLAG_2,KB_FE         ; INDICATE RESEND RECEIVED
        JMP     K26                     ; RETURN IF NOT (ACK RETURNED FOR DATA)


;/* --- UPDATE MODE INDICATORS IF CHANGE IN STATE

KB_INT_2:
        PUSH    AX                      ; SAVE DATA IN
        CALL    MAKE_LED                ; GO GET MODE INDICATOR DATA BYTE
        MOV     BL, KB_FLAG_2           ; GET PREVIOUS BITS
        XOR     BL,AL                   ; SEE IF ANY DIFFERENT
        AND     BL,KB_LEDS              ; ISOLATE INDICATOR BITS
        JZ      UP0                     ; IF NO CHANGE BYPASS UPDATE
        CALL    SND_LED                 ; GO TURN ON MODE INDICATORS
UP0:    POP     AX                      ; RESTORE DATA IN

;---------------------------------------------------------------------
;             START OF KEY PROCESSING                                -
;---------------------------------------------------------------------

        MOV     AH,AL                   ; SAVE SCAN CODE IN AH ALSO
                                        ; END OF RE-ENTRANT CODE PATHS
        MOV     CS:SCAN_CODE,AL         ; SAVE SCAN CODE TO BE PROCESSED BY KEYB

;------ TEST FOR OVERRUN SCAN CODE FROM KEYBOARD

        CMP     AL,KB_OVER_RUN          ; IS THIS AN OVERRUN CHAR?
        JNZ     K16                     ; NO, TEST FOR SHIFT KEY

        MOV     CS:BEEP_PENDING,YES
        JMP     K26                     ; BUFFER_FULL_BEEP, EXIT

K16:

        PUSH    CS
        POP     ES                      ; ESTABLISH ADDRESS OF TABLES
        MOV     BH, KB_FLAG_3           ; LOAD FLAGS FOR TESTING

;------ TEST TO SEE IF A READ_ID IS IN PROGRESS

        TEST    BH,RD_ID+LC_AB          ; ARE WE DOING A READ ID?
        JZ      NOT_ID                  ; CONTINUE IF NOT
        JNS     TST_ID_2                ; IS THE RD_ID FLAG ON?
        CMP     AL,ID_1                 ; IS THIS THE 1ST ID CHARACTER?
        JNE     RST_RD_ID
        OR      KB_FLAG_3,LC_AB         ; INDICATE 1ST ID WAS OK
RST_RD_ID:
        AND     KB_FLAG_3,NOT RD_ID     ; RESET THE READ ID FLAG
        JMP     SHORT ID_EX             ; AND EXIT


;------ CHECK 2ND US KBD ID - FOR SETTING NUM LOCK ON
TST_ID_2:
        AND     KB_FLAG_3,NOT LC_AB     ; RESET FLAG
        OR      KB_FLAG_3,KBX           ; INDICATE ENHANCED KEYBOARD WAS FOUND
ifdef JAPAN
					; If it responds to a read ID command
	MOV	CS:READ_ID2,AL		; Save ID just read for ID checks
endif ; JAPAN
        CMP     AL,TID_2                ; IS THIS US G-LAYOUT KBD  w 8042
        JE      NUM_LOCK_000            ;  JUMP IF SO
        CMP     AL,ID_2U                ; IS THIS US G-LAYOUT KBD  w/o 8042
        JE      NUM_LOCK_000            ;  JUMP IF SO
        CMP     AL,ID_122               ; IS THIS THE 122 KEY ENHANCED KEYBOARD
        JE      NUM_LOCK_000            ;  JUMP IF SO

;------ CHECK 2ND JAPANESE KBD ID       ;DCR355

        CMP     AL,ID_2JG               ; IS THIS JPN KBD - G ?
        JE      NUM_LOCK_000            ; JUMP IF SO
        CMP     AL,ID_2JA               ; IS THIS JPN KBD - A ?
	JNE	ID_EX			; EXIT IF NUM LOCK NOT REQUIRED
                                        ;  These ID's do not set NUM LOCK ON
                                        ;  ID_2AU = US P-LAYOUT KBD  w/o 8042
                                        ;  TID_2A = US P-LAYOUT KBD  w 8042
                                        ;  ID_2JP = JPN KBD - P

;------ A READ ID SAID THAT IT WAS ENHANCED KEYBOARD

NUM_LOCK_000:
        TEST    BH,SET_NUM_LK           ; SHOULD WE SET NUM LOCK?
        JZ      ID_EX                   ; EXIT IF NOT
        OR      KB_FLAG,NUM_STATE       ; FORCE NUM LOCK ON
        CALL    SND_LED                 ; GO SET THE NUM LOCK INDICATOR
ID_EX:
        JMP     K26                     ; EXIT
PAGE
NOT_ID:
ifdef JAPAN
;	M005 -- Kermit merge changes + AN013				       ;AN013

	TEST	BP,DBCS_OK		; Is a DBCS keyboard active?	;JP9009;AN013
	JZ	NOT_DBCS		; Skip DBCS shift case checks	       ;AN013

	MOV	BL,KB_FLAG		; Get shift key state flags now ;JP9009;AN013
	; ntraid:mskkbug#3516: Alt+Capslock does not work	11/9/93 yasuho
	CALL	DBCS_keyboard_support	; Go check for special shift key;JP9009;AN013
					; We can't call because this is edited
					; scan code directly. I comment it.
					; 8/31/93 NT-J
NOT_DBCS:								       ;AN013
;	M005 -- End changes + AN013
endif ; JAPAN
        CMP     AL,MC_E0                ; IS THIS THE GENERAL MARKER CODE?
        JNE     TEST_E1
        OR      KB_FLAG_3,LC_E0+KBX     ; SET FLAG BIT, SET KBX, AND
        JMP     SHORT EXIT              ; THROW AWAY THIS CODE

TEST_E1:
        CMP     AL,MC_E1                ; IS THIS THE PAUSE KEY?
        JNE     NOT_HC
        OR      KB_FLAG_3,LC_E1+KBX     ; SET FLAG, PAUSE KEY MARKER CODE
EXIT:   JMP     K26A                    ; THROW AWAY THIS CODE

NOT_HC:
        AND     AL,07FH                 ; TURN OFF THE BREAK BIT
        TEST    BH,LC_E0                ; LAST CODE THE E0 MARKER CODE?
        JZ      NOT_LC_E0               ; JUMP IF NOT

        MOV     CX,2                    ; LENGTH OF SEARCH
        MOV     DI,OFFSET K6+6          ; IS THIS A SHIFT KEY?
        REPNE   SCASB                   ; CHECK IT
        JNE     K16A                    ; NO, CONTINUE KEY PROCESSING
        JMP     SHORT K16B              ; YES, THROW AWAY & RESET FLAG

NOT_LC_E0:
        TEST    BH,LC_E1                ; LAST CODE THE E1 MARKER CODE?
        JZ      T_SYS_KEY               ; JUMP IF NOT

        MOV     CX,4                    ; LENGTH OF SEARCH
        MOV     DI,OFFSET K6+4          ; IS THIS AN ALT, CTL, OR SHIFT?
        REPNE   SCASB                   ; CHECK IT
        JE      EXIT                    ; THROW AWAY IF SO

        CMP     AL,NUM_KEY              ; IS IT THE PAUSE KEY?
        JNE     K16B                    ; NO, THROW AWAY & RESET FLAG
        TEST    AH,80H                  ; YES, IS IT THE BREAK OF THE KEY?
        JNZ     K16B                    ;  YES, THROW THIS AWAY, TOO
        TEST    KB_FLAG_1,HOLD_STATE    ;  NO, ARE WE PAUSED ALREADY?
        JNZ     K16B                    ;      YES, THROW AWAY
        JMP     K39P                    ;  NO, THIS IS THE REAL PAUSE STATE
PAGE
;------ TEST FOR SYSTEM KEY

T_SYS_KEY:
        CMP     AL,SYS_KEY              ; IS IT THE SYSTEM KEY?
        JNE     K16A                    ; CONTINUE IF NOT

        TEST    AH,080H                 ; CHECK IF THIS A BREAK CODE
        ;; NTVDM CLI                           ; DISABLE INTERRUPTS     PTR 6602319
        JNZ     K16C                    ; DON'T TOUCH SYSTEM INDICATOR IF TRUE

        TEST    KB_FLAG_1,SYS_SHIFT     ; SEE IF IN SYSTEM KEY HELD DOWN
        JNZ     K16B                    ; IF YES, DON'T PROCESS SYSTEM INDICATOR

        OR      KB_FLAG_1,SYS_SHIFT     ; INDICATE SYSTEM KEY DEPRESSED

ifdef NOT_NTVDM
        MOV     AL,ENA_KBD              ; INSURE KEYBOARD IS ENABLED
        CALL    SHIP_IT                 ; EXECUTE ENABLE
else
        mov     ah, 3                   ; K27A exit notify
        BOP     09h
endif
        MOV     AX,08500H               ; FUNCTION VALUE FOR MAKE OF SYSTEM KEY
        INT     15H                     ; USER INTERRUPT
        JMP     K27A                    ; END PROCESSING

K16B:   JMP     K26                     ; IGNORE SYSTEM KEY

K16C:   AND     KB_FLAG_1,NOT SYS_SHIFT; TURN OFF SHIFT KEY HELD DOWN

ifdef NOT_NTVDM
        MOV     AL,ENA_KBD              ; INSURE KEYBOARD IS ENABLED
        CALL    SHIP_IT                 ; EXECUTE ENABLE
else
        mov     ah, 3                   ; K27A exit notify
        BOP     09h
endif

        MOV     AX,08501H               ; FUNCTION VALUE FOR BREAK OF SYSTEM KEY
        INT     15H                     ; USER INTERRUPT
        JMP     K27A                    ; IGNORE SYSTEM KEY
PAGE
;------ TEST FOR SHIFT KEYS
;
; HERE IS WHERE KB_FLAGS ARE SET.  WHAT HAPPENS IS, THE SYSTEM SEARCHES TABLE
; 'K6' FOR THE KEY.  IF FOUND, IT GETS THE APPROPRIATE BIT FROM TABLE 'K7'
; AND SETS IT ON. (TABLES ARE ALL AT THE TOP OF THIS ROUTINE)  FLAGS FOR THE
; SECOND ALT AND CTRL ARE SET IN KB_FLAG_3 AND HAVE THE SAME BIT POSITIONS AS
; THEIR ORIGINAL COUNTERPARTS IN KB_FLAG

K16A:   MOV     BL, KB_FLAG             ; PUT STATE FLAGS IN BL
        MOV     DI,OFFSET K6            ; SHIFT KEY TABLE
        MOV     CX,K6L                  ; LENGTH
        REPNE   SCASB                   ; LOOK THROUGH THE TABLE FOR A MATCH
        MOV     AL,AH                   ; RECOVER SCAN CODE
        JE      K17                     ; JUMP IF MATCH FOUND
        JMP     K25                     ; IF NO MATCH, THEN SHIFT NOT FOUND

;------ SHIFT KEY FOUND

K17:    SUB     DI,OFFSET K6+1          ; ADJUST PTR TO SCAN CODE MTCH
        MOV     AH,CS:K7[DI]            ; GET MASK INTO AH
        MOV     CL,2                    ; SET UP COUNT FOR FLAG SHIFTS
        TEST    AL,80H                  ; TEST FOR BREAK KEY
        JZ      K17C
        JMP     K23                     ; JUMP IF BREAK

;------ SHIFT MAKE FOUND, DETERMINE SET OR TOGGLE

K17C:   CMP     AH,SCROLL_SHIFT
        JAE     K18                     ; IF SCROLL SHIFT OR ABOVE, TOGGLE KEY

;------ PLAIN SHIFT KEY, SET SHIFT ON

        CMP     COUNTRY_FLAG,0FFh       ; ARE WE IN FOREIGN LANG MODE?
        JNE     K17C1                   ;  NO, US MODE, JUMP
        CMP     AL,ALT_KEY              ; IS THIS THE ALT KEY?
        JNE     K17C1                   ;  NO, NORMAL KEY
                                        ;**CNS

K17C1:  OR      KB_FLAG,AH              ; TURN ON SHIFT BIT
K17C2:  TEST    AH,CTL_SHIFT+ALT_SHIFT  ; IS IT ALT OR CTRL?
        JZ      K17F                    ;  NO, JUMP
K17D:   TEST    BH,LC_E0                ; IS THIS ONE OF THE NEW KEYS?
        JZ      K17E                    ;  NO, JUMP
        OR      KB_FLAG_3,AH            ; SET BITS FOR RIGHT CTRL, ALT
;        JMP     K26                    ; INTERRUPT_RETURN
        jmp     short K17G              ; (YST)

K17E:   SHR     AH,CL                   ; MOVE FLAG BITS TWO POSITIONS
        OR      KB_FLAG_1,AH            ; SET BITS FOR LEFT CTRL, ALT
;        JMP     K26                    ; INTERRUPT RETURN
        jmp     short K17G              ; (YST)

K17F:
        TEST    CS:SD.SPECIAL_FEATURES,TYPEWRITER_CAPS_LK
        JZ      K17G                    ; N..all done
        CMP     COUNTRY_FLAG,0FFh       ; ARE WE IN LANG MODE?
        JNE     K17G                    ;  NO, ALL DONE WITH SHIFT KEY

;------ If keyboard is P12 then we still need to release caps_lk

        TEST    BP,PC_LAP               ;  IS THIS A P12 KEYBOARD?
        JNZ     REMOVE_CAPS_SHIFT

        TEST    BH,KBX                  ; THIS THE ENHANCED KEYBOARD?
        JZ      K17G                    ;  NO, ALL DONE WITH SHIFT KEY
REMOVE_CAPS_SHIFT:
        AND     KB_FLAG,NOT CAPS_SHIFT ;  YES, TAKE KB OUT OF C_L STATE
        CALL    SND_LED                 ;   AND UPDATE THE LED INDICATORS
K17G:


; ===========================================
;   Russian Keyboard (YST)
; ===========================================
        CMP     COUNTRY_FLAG,0FFh       ; ARE WE IN FOREIGN LANG MODE?   (YST)
        JNE     K17H                    ; NO, US MODE, RETURN            (YST)
        TEST    CS:SD.SPECIAL_FEATURES,SHIFTS_TO_LOGIC; CAN OUR STATE    (YST)
                                        ; LOGIC SUPPORT THIS CALL?       (YST)
        JZ      K17H                    ; NO, RETURN                     (YST)
        OR      CS:FLAGS_TO_TEST[EXT_KB_FLAG_ID],SHIFTS_PRESSED;         (YST)
                                        ; SET FLAG FOR STATE LOGIC       (YST)
        CALL    KEYB_STATE_PROCESSOR    ; ********                       (YST)
        AND     CS:FLAGS_TO_TEST[EXT_KB_FLAG_ID],NOT SHIFTS_PRESSED;     (YST)
                                        ; CLEAR FLAG AFTER USE           (YST)
; ===========================================
;   End of Russian Keyboard (YST)
; ===========================================


K17H:   JMP     K26                     ;  RETURN

;------ TOGGLED SHIFT KEY, TEST FOR 1ST MAKE OR NOT

K18:                                    ; SHIFT-TOGGLE
        TEST    BL,CTL_SHIFT            ; CHECK CTL SHIFT STATE
        JZ      K18A                    ; JUMP IF NOT CTL STATE
        JMP     K25                     ; JUMP IF CTL STATE
K18A:   CMP     AL,INS_KEY              ; CHECK FOR INSERT KEY
        JNE     K22                     ; JUMP IF NOT INSERT KEY
        TEST    BL,ALT_SHIFT            ; CHECK FOR ALTERNATE SHIFT
        JZ      K18B                    ; JUMP IF NOT ALTERNATE SHIFT
        JMP     K25                     ; JUMP IF ALTERNATE SHIFT
K18B:   TEST    BH,LC_E0                ; IS THIS THE NEW INSERT KEY?
        JNZ     K22                     ; YES, THIS ONE'S NEVER A "0"
K19:    TEST    BL,NUM_STATE            ; CHECK FOR BASE STATE
        JNZ     K21                     ; JUMP IF NUM LOCK IS ON
        TEST    BL,LEFT_SHIFT+RIGHT_SHIFT  ; TEST FOR SHIFT STATE
        JZ      K22                        ; JUMP IF BASE STATE
K20:    MOV     AH,AL                   ; PUT SCAN CODE BACK IN AH
        JMP     K25                     ; NUMERAL "0", STNDRD. PROCESSING

K21:    TEST    BL,LEFT_SHIFT+RIGHT_SHIFT  ; MIGHT BE NUMERIC
        JZ      K20                        ; IS NUMERIC, STD. PROC.

K22:                                    ; SHIFT TOGGLE KEY HIT; PROCESS IT
        TEST    AH, KB_FLAG_1           ; IS KEY ALREADY DEPRESSED?
        JZ      K22A
        JMP     K26                     ; JUMP IF KEY ALREADY DEPRESSED
K22A:   OR      KB_FLAG_1,AH            ; INDICATE THAT THE KEY IS DEPRESSED
        XOR     KB_FLAG,AH              ; TOGGLE THE SHIFT STATE

        TEST    CS:SD.SPECIAL_FEATURES,TYPEWRITER_CAPS_LK
        JZ      K22C                    ; N..all done

;------ If keyboard is P12 then we do not toggle

        TEST    BP,PC_LAP               ;  IS THIS A P12 KEYBOARD?
        JNZ     LAP_SO_DONT_TOGGLE

        TEST    BH,KBX                  ; THIS THE ENHANCED KEYBOARD?
        JZ      K22C                    ;  NO, ALL DONE WITH TOGGLE KEYS

LAP_SO_DONT_TOGGLE:
        CMP     CS:COUNTRY_FLAG,0FFh    ; ARE WE IN FOREIGN LANG MODE?
        JNE     K22C                    ;  NO, NO SPECIAL STUFF FOR U.S.
        TEST    AH,CAPS_SHIFT           ; IS IT THE CAPS_LOCK KEY?
        JZ      K22C                    ;  NO, NOTHING ELSE TO DO
        OR      KB_FLAG,AH              ;  YES, SET CAPS_LOCK (NOT TOGGLE)

K22C:

;------ TOGGLE LED IF CAPS, NUM, OR SCROLL KEY DEPRESSED

        TEST    AH,CAPS_SHIFT+NUM_SHIFT+SCROLL_SHIFT ; SHIFT TOGGLE?
        JZ      K22B                    ; GO IF NOT
        PUSH    AX                      ; SAVE SCAN CODE AND SHIFT MASK
        CALL    SND_LED                 ; GO TURN MODE INDICATORS ON
        POP     AX                      ; RESTORE SCAN CODE

K22B:   CMP     AL,INS_KEY              ; TEST FOR 1ST MAKE OF INSERT KEY
        JNE     K26                     ; JUMP IF NOT INSERT KEY
        MOV     AH,AL                   ; SCAN CODE IN BOTH HALVES OF AX
        JMP     K28                     ; FLAGS UPDATED, PROC. FOR BUFFER

;------ BREAK SHIFT FOUND

K23:                                    ; BREAK-SHIFT-FOUND
        CMP     AH,SCROLL_SHIFT         ; IS THIS A TOGGLE KEY?
        NOT     AH                      ; INVERT MASK
        JAE     K24                     ; YES, HANDLE BREAK TOGGLE
        AND     KB_FLAG,AH              ; TURN OFF SHIFT BIT
        CMP     AH,NOT CTL_SHIFT        ; IS THIS ALT OR CTL?
        JA      K23D                    ;  NO, ALL DONE

        TEST    BH,LC_E0                ; 2ND ALT OR CTL?
        JZ      K23A                    ; NO, HANDLE NORMALLY
        AND     KB_FLAG_3,AH            ; RESET BIT FOR RIGHT ALT OR CTL
        JMP     SHORT K23B              ; CONTINUE
K23A:   SAR     AH,CL                   ; MOVE THE MASK BIT TWO POSITIONS
        AND     KB_FLAG_1,AH            ; RESET BIT FOR LEFT ALT OR CTL
K23B:   MOV     AH,AL                   ; SAVE SCAN CODE
        MOV     AL, KB_FLAG_3           ; GET RIGHT ALT & CTRL FLAGS
        CMP     COUNTRY_FLAG,0FFH       ; ARE WE IN LANGUAGE MODE?
        JNE     K23C                    ;  NO, LEAVE RIGHT FLAGS AS IS
;**CNS
        AND     AL,NOT GRAPH_ON         ;  YES, FILTER OUT THE ALT_GR KEY
;**CNS
K23C:   SHR     AL,CL                   ; MOVE TO BITS 1 & 0
        OR      AL, KB_FLAG_1           ; PUT IN LEFT ALT & CTL FLAGS
        SHL     AL,CL                   ; MOVE BACK TO BITS 3 & 2
        AND     AL,ALT_SHIFT+CTL_SHIFT  ; FILTER OUT OTHER GARBAGE
        OR      KB_FLAG,AL              ; PUT RESULT IN THE REAL FLAGS
        MOV     AL,AH                   ; RECOVER SAVED SCAN CODE

K23D:   CMP     AL,ALT_KEY+80H          ; IS THIS ALTERNATE SHIFT RELEASE
        JNE     K26                     ; INTERRUPT_RETURN

;------ ALTERNATE SHIFT KEY RELEASED, GET THE VALUE INTO BUFFER

        MOV     AL, ALT_INPUT
        xor     ah,ah                   ; scan code of 0
        MOV     ALT_INPUT,AH            ; ZERO OUT THE FIELD
        or      al,al                   ; was the input = 0?
        JE      K26                     ; INTERRUPT_RETURN
        CALL    BUFFER_FILL_ANY_CHAR    ; Put in buffer, but use this
                                        ;  entry point to avoid trashing
                                        ;   an ASCII code of 255
        JMP     SHORT K26               ; INTERRUPT_RETURN

K24:                                    ; BREAK-TOGGLE
        AND     KB_FLAG_1,AH            ; INDICATE NO LONGER DEPRESSED
        JMP     SHORT K26               ; INTERRUPT_RETURN

;------ TEST FOR HOLD STATE
                                        ; AL, AH = SCAN CODE
K25:                                    ; NO-SHIFT-FOUND
        CMP     AL,80H                  ; TEST FOR BREAK KEY
        JAE     K26                     ; NOTHING FOR BREAK CHARS FROM HERE ON
        TEST    KB_FLAG_1,HOLD_STATE    ; ARE WE IN HOLD STATE
        JZ      K28                     ; BRANCH AROUND TEST IF NOT
        CMP     AL,NUM_KEY
        JE      K26                     ; CAN'T END HOLD ON NUM_LOCK
        AND     KB_FLAG_1,NOT HOLD_STATE  ; TURN OFF THE HOLD STATE BIT

K26:
        AND     KB_FLAG_3,NOT LC_E0+LC_E1 ; RESET LAST CHAR H.C. FLAG

K26A:                                   ; INTERRUPT-RETURN
ifdef  NOT_NTVDM
        ;; NTVDM CLI                             ; TURN OFF INTERRUPTS
        CALL    ERROR_BEEP              ; CHECK FOR ERROR BEEP PENDING

        CMP     CS:BUFFER_ENTRY_OK,YES  ; HAS A CHARACTER BEEN PLACED IN BUFFER
        JNE     K27                     ;  NO, SKIP POST

        MOV     byte ptr CS:BUFFER_ENTRY_OK,NO  ; CLEAR POST CHARACTER IN BUFFER FLAG
        MOV     AX,09102H               ; MOVE IN POST CODE & TYPE
        INT     15H                     ; PERFORM OTHER FUNCTION
K27:
        MOV     AL,ENA_KBD              ; ENSURE KEYBOARD IS ENABLED (AT PS/2)
        CALL    SHIP_IT                 ; EXECUTE ENABLE
else

        mov     ah, 2
        mov     bh, CS:BEEP_PENDING
        mov     bl, CS:BUFFER_ENTRY_OK
        MOV     byte ptr CS:BUFFER_ENTRY_OK,NO
        MOV     byte ptr CS:BEEP_PENDING,NO
        BOP     09h
endif


K27A:   ;; NTVDM CLI                             ; DISABLE INTERRUPTS
        POP     ES                      ; RESTORE REGISTERS
        POP     DS                      ; *
        POP     DI                      ; *
        POP     SI                      ; *
        POP     DX                      ; *
        POP     CX                      ; *
        POP     BX                      ; *
        POP     AX                      ; *
        POP     BP                      ; *

        jmp DOIRET                            ; RETURN
PAGE
;------ NOT IN HOLD STATE
                                        ; AL, AH = SCAN CODE (ALL MAKES)
K28:                                    ; NO-HOLD-STATE
        CMP     AL,H_LAST_SCAN          ; TEST FOR OUT-OF-RANGE SCAN CODES
        JA      SHORT K26               ; IGNORE IF OUT-OF-RANGE
ifndef JAPAN
        TEST    BP,EXT_122              ; IS EXTENDED 122 KEYBOARD SUPPORT OK
else ; JAPAN
					; Must pass 07Eh and 07Fh DBCS pseudo's;AN013
					; IS DBCS KEYBOARD support code active ;AN013
	TEST	BP,EXT_122+DBCS_OK	;  or EXTENDED 122 KEYBOARD support OK ;AN013
endif ; JAPAN
        JNZ     K28_122                 ; SKIP NON-122 OUT-OF-RANGE CHECK

ifdef NOT_NTVDM
        CMP     AL,88                   ; TEST FOR OUT-OF-RANGE SCAN CODES
else
        CMP     AL,7Eh                  ; MAX SCANCODE ON BRAZILIAN ABNT KBD
endif
        JA      K26                     ; IGNORE IF OUT-OF-RANGE

K28_122:
        TEST    BL,ALT_SHIFT            ; ARE WE IN ALTERNATE SHIFT?
        JZ      K28A                    ; JUMP IF NOT ALTERNATE

        TEST    BH,KBX                  ; IS THIS THE ENHANCED KEYBOARD?
        JZ      K29                     ; NO, ALT STATE IS REAL

        TEST    KB_FLAG_1,SYS_SHIFT     ; YES, IS SYSREQ KEY DOWN?
        JZ      K29                     ;  NO, ALT STATE IS REAL
;**CNS
         TEST    AH,LC_E0               ; IS IT THE ALT_GR KEY?
         JZ      K28A                   ; YES,   DON'T SET KB_FLAG

         TEST    AL,R_ALT_SHIFT         ; TURN ON SHIFT BIT
         JNZ     K29                    ; TURN ON SHIFT BIT
;**CNS

K28A:   JMP     K38                     ;  YES, THIS IS PHONY ALT STATE
                                        ;       DUE TO PRESSING SYSREQ

;------ TEST FOR RESET KEY SEQUENCE (CTL ALT DEL) OR HOT KEY DEPRESSED

K29:                                    ; TEST-RESET
        TEST    BL,CTL_SHIFT            ; ARE WE IN CONTROL SHIFT ALSO?
ifndef JAPAN
        JZ      K31                     ; NO_RESET
else ; JAPAN
	JZ	K31C			; NO_RESET, Not in Ctrl state
endif ; JAPAN
        CMP     AL,DEL_KEY              ; SHIFT STATE IS THERE, TEST KEY
        JNE     K31A                    ; NO_RESET,  TRANSLATE TABLE SWAP

;------ CTL-ALT-DEL HAS BEEN FOUND, DO I/O CLEANUP

        MOV     RESET_FLAG,1234H        ; SET FLAG FOR RESET FUNCTION
        AND     WORD PTR  KB_FLAG_3,KBX ; CLEAR ALL FLAG BITS EXCEPT KBX   PED 6-25-86
        JMP     RESET                   ; JUMP TO POWER ON DIAGNOSTICS

ifdef JAPAN
;------ SET COUNTRY FLAG TO INDICATE WHICH TABLE WE'RE USING, FOREIGN OR DOMESTIC

K31A:	CMP	AL,CS:SD.HOT_KEY_ON_SCAN ; TEST FOR HOT KEY TO US
	JNE	K31B
	MOV	CS:COUNTRY_FLAG,00	; SET FLAG FOR DOMESTIC KEY'S
	JMP	K26			; INTERRUPT RETURN

K31B:	CMP	AL,CS:SD.HOT_KEY_OFF_SCAN ; TEST FOR HOT KEY TO FOREIGN
	JNE	K31C			; IF NOT TEST FOR FRONT ENGRAV
	MOV	CS:COUNTRY_FLAG,0FFH	; SET FLAGS FOR FOREIGN KEY'S
	JMP	K26			; INTERRUPT RETURN


;------ ALT STATE, OR CTRL AND ALT DOWN BUT NO HOT KEY F1/F2 OR DEL KEY        ;AN014

K31C:	CMP	CS:COUNTRY_FLAG,0FFH	; Check for country translate flag set ;AN014
	JNE	K31			; Else try ALT_KEY_PAD special cases   ;AN014

	CALL	KEYB_STATE_PROCESSOR	; Let NLS handle it's differences      ;AN014
	JC	K32A	;K26		;    TRANSLATIONS FOUND - EXIT
endif ; JAPAN

;------ IN ALTERNATE SHIFT, RESET NOT FOUND

K31:                                    ; NO-RESET
        CALL    KEYB_STATE_PROCESSOR
ifndef JAPAN
        JC      K26                     ;    TRANSLATIONS FOUND - EXIT
else ; JAPAN
	JNC	K310
        JMP     K26                     ;    TRANSLATIONS FOUND - EXIT
K310:
endif ; JAPAN

        CMP     AL,57                   ; TEST FOR SPACE KEY
        JNE     K311                    ; NOT THERE
        MOV     AL,' '                  ; SET SPACE CHAR
        JMP     K57                     ; BUFFER_FILL
K311:
        TEST    BP,EXT_16               ; IS EXTENDED INT 16 LOADED?
        JZ      K32                     ;  NO, SKIP THIS EXTENDED STUFF
        CMP     AL,15                   ; TEST FOR TAB KEY
        JNE     K312                    ; NOT THERE
        MOV     AX,0A500h               ; SET SPECIAL CODE FOR ALT-TAB
        JMP     K57                     ; BUFFER_FILL
K312:
        CMP     AL,74                   ; TEST FOR KEYPAD -
        JE      K312A                   ; GO PROCESS
        CMP     AL,78                   ; TEST FOR KEYPAD +
        JNE     K32                     ; SKIP TEST FOR LANG SWAP & CONT.
K312A:  JMP     K37B                    ; GO PROCESS

ifndef JAPAN
;------ SET COUNTRY FLAG TO INDICATE WHICH TABLE WE'RE USING, FOREIGN OR DOMESTIC

K31A:   CMP     AL,CS:SD.HOT_KEY_ON_SCAN ; TEST FOR HOT KEY TO US
        JNE     K31B
        MOV     CS:COUNTRY_FLAG,00      ; SET FLAG FOR DOMESTIC KEY'S
        JMP     K26                     ; INTERRUPT RETURN

K31B:   CMP     AL,CS:SD.HOT_KEY_OFF_SCAN ; TEST FOR HOT KEY TO FOREIGN
        JNE     K31C                    ; IF NOT TEST FOR FRONT ENGRAV
        MOV     CS:COUNTRY_FLAG,0FFH    ; SET FLAGS FOR FOREIGN KEY'S
        JMP     K26                     ; INTERRUPT RETURN


;------ ALT, CTRL DOWN ; NO HOT KEY

K31C:   CMP     CS:COUNTRY_FLAG,0FFH
        JNE     K32                     ; TRY ALT_KEY_PAD
        CALL    KEYB_STATE_PROCESSOR
        JC      K32A    ;K26            ;    TRANSLATIONS FOUND - EXIT
endif ; !JAPAN

;------ LOOK FOR KEY PAD ENTRY

K32:                                    ; ALT-KEY-PAD
        MOV     DI,OFFSET K30           ; ALT-INPUT-TABLE
        MOV     CX,10                   ; LOOK FOR ENTRY USING KEYPAD
        REPNE   SCASB                   ; LOOK FOR MATCH
        JNE     K33                     ; NO_ALT_KEYPAD
        TEST    BH,LC_E0                ; IS THIS ONE OF THE NEW KEYS?
        JNZ     K37C                    ;  YES, JUMP, NOT NUMPAD KEY
        SUB     DI,OFFSET K30+1         ; DI NOW HAS ENTRY VALUE
        MOV     AL, ALT_INPUT           ; GET THE CURRENT BYTE
        MOV     AH,10                   ; MULTIPLY BY 10
        MUL     AH
        ADD     AX,DI                   ; ADD IN THE LATEST ENTRY
        MOV      ALT_INPUT,AL           ; STORE IT AWAY
K32A:   JMP     K26                     ; THROW AWAY THAT KEYSTROKE

;------ LOOK FOR SUPERSHIFT ENTRY

K33:                                    ; NO-ALT-KEYPAD
        MOV      ALT_INPUT,0            ; ZERO ANY PREVIOUS ENTRY INTO INPUT
                                        ; DI,ES ALREADY POINTING
        MOV     CX,K30_LEN              ; NORMALLY 26, BUT 27 FOR FR, DUE
                                        ;  TO THE ";" KEY BEING "M"
        REPNE   SCASB                   ; LOOK FOR MATCH IN ALPHABET
        JE      K37A                    ; MATCH FOUND, GO FILL THE BUFFER

;------ LOOK FOR TOP ROW OF ALTERNATE SHIFT

K34:                                    ; ALT-TOP-ROW
        CMP     AL,2                    ; KEY WITH '1' ON IT
        JB      K37B                    ; MUST BE ESCAPE
        CMP     AL,13                   ; IS IT IN THE REGION
        JA      K35                     ;  NO, ALT-SOMETHING ELSE
        ADD     AH,118                  ; CONVERT PSEUDO SCAN CODE TO RANGE
        JMP     SHORT K37A              ; GO FILL THE BUFFER

;------ TRANSLATE ALTERNATE SHIFT PSEUDO SCAN CODES

K35:                                    ; ALT-FUNCTION
        CMP     AL,F11_M                ; IS IT F11 or GREATER ?
        JB      K35A                    ;  NO, BRANCH
        SUB     AL,52h                  ; SET UP TO SEARCH ALT-FUNCTION-TABLE
        MOV     BX,OFFSET K30A          ; BASE CASE TABLE
        JMP     K64                     ; CONVERT TO PSEUDO SCAN

K35A:   TEST    BH,LC_E0                ; DO WE HAVE ONE OF THE NEW KEYS?
        JZ      K37                     ;  NO, JUMP
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 LOADED?
        JZ      K37                     ;  NO, DO COMPATIBLE OUTPUT
        CMP     AL,28                   ; TEST FOR KEYPAD ENTER
        JNE     K35B                    ; NOT THERE
        MOV     AX,0A600h               ; SPECIAL CODE
        JMP     K57                     ; BUFFER FILL
K35B:   CMP     AL,83                   ; TEST FOR DELETE KEY
        JE      K37C                    ; HANDLE WITH OTHER EDIT KEYS
        CMP     AL,53                   ; TEST FOR KEYPAD /
        JNE     K32A                    ; NOT THERE, NO OTHER E0 SPECIALS
        MOV     AX,0A400h               ; SPECIAL CODE
        JMP     K57                     ; BUFFER FILL

K37:    CMP     AL,59                   ; TEST FOR FUNCTION KEYS (F1)
        JB      K37B                    ;  NO FN, HANDLE W/OTHER EXTENDED
        CMP     AL,68                   ; IN KEYPAD REGION?
                                        ; OR NUMLOCK, SCROLLOCK?
        JA      K32A                    ; IF SO, IGNORE
        ADD     AH,45                   ; CONVERT TO PSEUDO SCAN CODE

K37A:   xor     al,al                   ; ASCII CODE OF ZERO
        JMP     K57                     ; PUT IT IN THE BUFFER

K37B:
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 LOADED?
        JZ      K32A    ;K26               ;  NO, IGNORE THIS ONE
        MOV     AL,0F0h                 ; USE SPECIAL ASCII CODE
        JMP     K57                     ; PUT IT IN THE BUFFER

K37C:
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 LOADED?
        JZ      K37A                    ;  NO, DO COMPATIBLE OUTPUT
        ADD     AL,80                   ; CONVERT SCAN CODE (EDIT KEYS)
        MOV     AH,AL                   ; (SCAN CODE NOT IN AH FOR INSERT)
        JMP     K37A                    ; PUT IT IN THE BUFFER
PAGE
;------ NOT IN ALTERNATE SHIFT

K38:                                    ; NOT-ALT-SHIFT
                                        ; BL STILL HAS SHIFT FLAGS
        TEST    BL,CTL_SHIFT            ; ARE WE IN CONTROL SHIFT?
        JNZ     K38A                    ;  YES, START PROCESSING
        JMP     K44                     ; NOT-CTL-SHIFT

;------ CONTROL SHIFT, TEST SPECIAL CHARACTERS

;------ TEST FOR BREAK

K38A:   CMP     AL,SCROLL_KEY           ; TEST FOR BREAK
        JNE     K39                     ; JUMP, NO-BREAK
        TEST    BP,PC_LAP               ; IS THIS THE LAP COMPUTER?
        JNZ     K38B                    ;  YES, THIS IS CTRL-BREAK
        TEST    BH,KBX                  ; IS THIS THE ENHANCED KEYBOARD?
        JZ      K38B                    ;  NO, BREAK IS VALID
        TEST    BH,LC_E0                ;  YES, WAS LAST CODE AN E0?
        JZ      K39                     ;   NO-BREAK, TEST FOR PAUSE

K38B:
        ;; NTVDM CLI                             ; Disable interrupts because EOI issued
        MOV     BX, BUFFER_HEAD         ; RESET BUFFER TAIL TO BUFFER HEAD
        MOV      BUFFER_TAIL,BX
        MOV      BIOS_BREAK,80H         ; TURN ON BIOS_BREAK BIT

;-------- ENABLE KEYBOARD

ifdef NOT_NTVDM
        MOV     AL,ENA_KBD              ; ENABLE KEYBOARD
        CALL    SHIP_IT                 ; EXECUTE ENABLE
else
        mov     ah, 4
        BOP     09h
endif
        INT     1BH                     ; BREAK INTERRUPT VECTOR
        SUB     AX,AX                   ; PUT OUT DUMMY CHARACTER
        JMP     K57                     ; BUFFER_FILL

;-------- TEST FOR PAUSE

K39:                                    ; NO-BREAK
        CMP     AL,NUM_KEY              ; LOOK FOR PAUSE KEY
        JNE     K41                     ; NO-PAUSE
        TEST    BH,KBX                  ; IS THIS THE ENHANCED KEYBOARD?
        JZ      K39P                    ;  NO, THIS IS A VALID PAUSE
        TEST    BP,PC_LAP               ; IS THIS THE LAP COMPUTER?
        JZ      K41                     ;  NO, IT'S NOT PAUSE THIS TIME
K39P:   OR      KB_FLAG_1,HOLD_STATE    ; TURN ON THE HOLD FLAG

;-------- ENABLE KEYBOARD

        MOV     AL,ENA_KBD              ; ENABLE KEYBOARD
        CALL    SHIP_IT                 ; EXECUTE ENABLE

ifdef NOT_NTVDM

;------ DURING PAUSE INTERVAL, TURN CRT BACK ON

        CMP     CRT_MODE,7              ; IS THIS BLACK AND WHITE CARD
        JAE     K40                     ; YES, NOT CGA MODES NOTHING TO DO
        MOV     DX,03D8H                ; PORT FOR COLOR CARD
        MOV     AL,CRT_MODE_SET         ; GET THE VALUE OF THE CURRENT MODE
        OUT     DX,AL                   ; SET THE CRT MODE, SO THAT CRT IS ON
K40:                                    ; PAUSE-LOOP
        TEST    BP,PC_LAP               ; IS THIS THE LAP COMPUTER?
        JZ      K40A                    ;  NO, SKIP THE BATTERY LIFE STUFF
        MOV     AX,4104H                ; FUNCTION 41, AL=04=RETURN IF 0
        MOV     BX,HOLD_STATE*100H      ; BH=HOLD_STATE, BL=0=NO TIME OUT
        PUSH    DS                      ; MAKE ES:DI POINT TO KB_FLAG_1
        POP     ES
        MOV     DI,OFFSET  KB_FLAG_1
        INT     15H                     ; SLEEP UNTIL OUT OF HOLD

;------ CHECK FOR AUX ADAPTER INPUT PENDING
K40A:
        MOV CX,100                      ; COUNT FOR WAIT LOOP
else
        mov     ah, 3                   ; K27A exit notify
        BOP     09h
        call DOSTI
K40A:
        mov   cx, 16
        xor   ax, ax
        BOP   BOP_WAITIFIDLE            ; idle bop
endif
K40B:
        TEST    KB_FLAG_1,HOLD_STATE    ; ARE WE IN HOLD STATE
        JZ K40E                         ; EXIT IF NOT

ifdef NOT_NTVDM
        TEST    BP,PC_XT+PC_LAP                 ; Check for systems without AUX BIOS
        JNZ     K40B                    ; For them, just loop on hold flag

        IN      AL,STATUS_PORT          ; READ CURRENT STATUS
        AND     AL,MOUSE_OBF+OUT_BUF_FULL ; MASK OFF ALL BUT MOUSE DATA BITS
        CMP     AL,MOUSE_OBF+OUT_BUF_FULL ; IS THERE STILL MOUSE DATA PENDING?
endif
        LOOPE   K40B                    ; WAIT FOR MOUSE DATA TO GO
        JNE     K40A                    ; CONTINUE IF PAUSE STATE              ;an005
K40E:
ifndef NOT_NTVDM
        call    DOCLI
endif
        AND     KB_FLAG_1,NOT HOLD_STATE ; CLEAR HOLD STATE FLAG
        JMP     K27A                    ; INTERRUPT_RETURN_NO_EOI      PTR 2247

;------ TEST SPECIAL CASE KEY 55

K41:                                    ; NO-PAUSE
        CMP     AL,55                   ; TEST FOR */PRTSC KEY
        JNE     K42                     ; NOT-KEY-55
        TEST    BP,PC_LAP               ; IS THIS THE LAP COMPUTER?
        JZ      K41B                    ;  NO, JUMP
        TEST    BH,LC_E0                ;  YES, WAS LAST CODE AN E0?
        JZ      K41A                    ;    NO, THIS IS THE PRTSC KEY
        JMP     SHORT K42B              ;    YES, E0 MEANS THE "*" KEY

K41B:   TEST    BH,KBX                  ; IS THIS THE ENHANCED KEYBOARD?
        JZ      K41A                    ;  NO, CTL-PRTSC IS VALID
        TEST    BH,LC_E0                ;  YES, WAS LAST CODE AN E0?
        JZ      K42B                    ;   NO, TRANSLATE TO A FUNCTION
K41A:   MOV     AX,114*256              ; START/STOP PRINTING SWITCH
        JMP     K57                     ; BUFFER_FILL

;------ SET UP TO TRANSLATE CONTROL SHIFT

K42:                                    ; NOT-KEY-55
ifdef JAPAN
	CMP	CS:COUNTRY_FLAG,0FFH	; Check for country translate flag set
	JNE	K42US			; Skip overhead if not in country mode
endif ; JAPAN
	CALL	KEYB_STATE_PROCESSOR
        JC      K449    ;K26            ; TRANSLATIONS FOUND - EXIT
ifdef JAPAN
K42US:
endif ; JAPAN
        CMP     AL,15                   ; IS IT THE TAB KEY?
        JE      K42B                    ;  YES, XLATE TO FUNCTION CODE
        CMP     AL,53                   ; IS IT THE / KEY?
        JNE     K42A                    ;  NO, NO MORE SPECIAL CASES
        TEST    BH,LC_E0                ;  YES, IS IT FROM THE KEYPAD?
        JZ      K42A                    ;   NO, JUST TRANSLATE
        MOV     AX,9500h                ;   YES, SPECIAL CODE FOR THIS ONE
        JMP     K57                     ;   BUFFER FILL

K42A:   MOV     BX,OFFSET K8            ; SET UP TO TRANSLATE CTL
        CMP     AL,59                   ; IS IT IN CHARACTER TABLE?
        JB      K45F                    ;  YES, GO TRANSLATE CHAR
K42B:   MOV     BX,OFFSET K8            ; SET UP TO TRANSLATE CTL
        JMP     K64                     ;  NO, GO TRANSLATE_SCAN
PAGE
;------ NOT IN CONTROL SHIFT

K44:
ifdef JAPAN
	CMP	CS:COUNTRY_FLAG,0FFH	; Check for country translate flag set
	JNE	K44US			; Skip overhead if not in country mode
endif ;JAPAN
	CALL	KEYB_STATE_PROCESSOR
        JC      K449    ;K26            ; TRANSLATIONS FOUND - EXIT
ifdef JAPAN
K44US:
endif ; JAPAN
        CMP     AL,55                   ; PRINT SCREEN KEY?
        JNE     K45                     ; NOT-PRINT-SCREEN
        TEST    BP,PC_LAP               ; IS THIS THE LAP COMPUTER?
        JZ      K441                    ;  NO, JUMP
        TEST    BH,LC_E0                ;  YES, WAS LAST CODE THE MARKER?
        JZ      K44A                    ;       NO, TEST THE SHIFT STATE
        JMP     SHORT K45C              ;       YES, XLATE TO "*" CHAR
K441:   TEST    BH,KBX                  ; IS THIS ENHANCED KEYBOARD?
        JZ      K44A                    ; NO, TEST FOR SHIFT STATE
        TEST    BH,LC_E0                ; YES, LAST CODE A MARKER?
        JNZ     K44B                    ;  YES, IS PRINT SCREEN
        JMP     SHORT K45C              ;  NO, XLATE TO "*" CHARACTER
K44A:   TEST    BL,LEFT_SHIFT+RIGHT_SHIFT  ;NOT 101 KBD, SHIFT KEY DOWN?
        JZ      K45C                       ; NO, XLATE TO "*" CHARACTER

;------ ISSUE INTERRUPT TO PERFORM PRINT SCREEN FUNCTION
K44B:
        ;; NTVDM CLI                         ; DISABLE INTERRUPTS           PTR 2355
        AND     KB_FLAG_3,NOT LC_E0+LC_E1 ;ZERO OUT THESE FLAGS

ifdef NOT_NTVDM
        MOV     AL,ENA_KBD              ; INSURE KEYBOARD IS ENABLED
        CALL    SHIP_IT                 ; EXECUTE ENABLE
else
        mov     ah, 3                   ; K27A exit notify
        BOP     09h
endif
        PUSH    BP                      ; SAVE POINTER (compatibility)
        INT     5H                      ; ISSUE PRINT SCREEN INTERRUPT
        POP     BP                      ; RESTORE POINTER
        JMP     K27A                    ; EXIT WITHOUT EXTRA EOI OR ENABLE

K449:
        JMP     K26                     ; EXIT

;------ HANDLE THE IN-CORE KEYS
K45:                                    ; NOT-PRINT-SCREEN
        CMP     AL,58                   ; TEST FOR IN-CORE AREA
        JA      K46                     ; JUMP IF NOT

        TEST    BH,GRAPH_ON             ; IS ALT GRAPHICS ON?              AEV
        JNZ     K449    ;K26            ; YES, TRASH KEYSTROKE

        CMP     AL,53                   ; IS THIS THE "/" KEY?
        JNE     K45A                    ;  NO, JUMP
        TEST    BH,LC_E0                ; WAS LAST CODE THE MARKER?
        JNZ     K45C                    ;  YES, TRANSLATE TO CHARACTER

K45A:   MOV     CX,K30_LEN              ; LENGTH OF SEARCH
        MOV     DI,OFFSET K30+10        ; POINT TO TABLE OF A-Z CHARS
        REPNE   SCASB                   ; IS THIS A LETTER KEY?
        JNE     K45B                    ;  NO, SYMBOL KEY

        TEST    BL,CAPS_STATE           ; ARE WE IN CAPS_LOCK?
        JNZ     K45D                    ; TEST FOR SURE
K45B:   TEST    BL,LEFT_SHIFT+RIGHT_SHIFT ; ARE WE IN SHIFT STATE?
        JNZ     K45E                      ; YES, UPPERCASE
                                          ; NO, LOWERCASE
K45C:   MOV     BX,OFFSET K10           ; TRANSLATE TO LOWERCASE LETTERS
        JMP     SHORT K56
K45D:                                   ; ALMOST-CAPS-STATE
        TEST    BL,LEFT_SHIFT+RIGHT_SHIFT ; CL ON. IS SHIFT ON, TOO?
        JNZ     K45C                    ; SHIFTED TEMP OUT OF CAPS STATE
K45E:   MOV     BX,OFFSET K11           ; TRANSLATE TO UPPERCASE LETTERS
K45F:   JMP     SHORT K56


;------ TEST FOR KEYS F1 - F10
K46:                                    ; NOT IN-CORE AREA
        CMP     AL,68                   ; TEST FOR F1 - F10
        JA      K47                     ; JUMP IF NOT
        JMP     SHORT K53A              ; YES, GO DO FN KEY PROCESS


;------ HANDLE THE NUMERIC PAD KEYS

K47:                                    ; NOT F1 - F10
        CMP     AL,83                   ; TEST FOR NUMPAD KEYS
        JA      K52                     ; JUMP IF NOT

;------ KEYPAD KEYS, MUST TEST NUM LOCK FOR DETERMINATION
K48:    CMP     AL,74                   ; SPECIAL CASE FOR MINUS
        JE      K45E                    ; GO TRANSLATE (US & WT ARE SAME)
        CMP     AL,78                   ; SPECIAL CASE FOR PLUS
        JE      K45E                    ; GO TRANSLATE (US & WT ARE SAME)
        TEST    BH,LC_E0                ; IS THIS ONE OF THE NEW KEYS?
        JNZ     K49                     ;  YES, TRANSLATE TO BASE STATE

        TEST    BL,NUM_STATE            ; ARE WE IN NUM_LOCK?
        JNZ     K50                     ; TEST FOR SURE
        TEST    BL,LEFT_SHIFT+RIGHT_SHIFT  ; ARE WE IN SHIFT STATE?
        JNZ     K51                        ; IF SHIFTED, REALLY NUM STATE

;------ BASE CASE FOR KEYPAD
K49:    CMP     AL,76                   ; SPECIAL CASE FOR BASE STATE 5
        JNE     K49A                    ; CONTINUE IF NOT KEYPAD 5
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 LOADED?
        JZ      K59     ;K26            ;  NO, INGORE

        MOV     AL,0F0h                 ; SPECIAL ASCII CODE
        JMP     SHORT K57               ; BUFFER FILL
K49A:   MOV     BX,OFFSET K10           ; BASE CASE TABLE
        JMP     SHORT K64               ; CONVERT TO PSEUDO SCAN

;------ MIGHT BE NUM LOCK, TEST SHIFT STATUS
K50:    TEST    BL,LEFT_SHIFT+RIGHT_SHIFT       ;ALMOST-NUM-STATE
        JNZ     K49                     ; SHIFTED TEMP OUT OF NUM STATE
K51:    JMP     SHORT K45E              ; REALLY_NUM_STATE
                                        ; (US & WT ARE SAME)

;------ TEST FOR THE NEW KEY ON WT KEYBOARDS

K52:                                    ; NOT A NUMPAD KEY
        CMP     AL,86                   ; IS IT THE NEW WT KEY?
        JNE     K53                     ; JUMP IF NOT
        MOV     AL,58                   ; WE'RE GOING TO PULL A SNEAKY
        JMP     K45                     ; TRICK HERE. WT TABLES ARE TOO SHORT TO
                                        ; XLATE 86, SO WE'LL CHANGE IT TO CAPS_LOCK
                                        ; AND PUT THE CHAR IN THE TABLES IN THE C_L
                                        ; POSITION, SINCE C_L SCAN CODES NEVER GET
                                        ; HERE ANYWAY.

;------ MUST BE F11 OR F12

K53:    TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 THERE?
        JZ      K59                     ;  NO, INGORE F11 & F12 (NEAR RET)
                                        ; F1 - F10 COME HERE, TOO
K53A:   TEST    BL,LEFT_SHIFT+RIGHT_SHIFT ;TEST SHIFT STATE
        JZ      K49                     ;   JUMP, LOWERCASE PSEUDO SC'S

        MOV     BX,OFFSET K11           ; UPPER CASE PSEUDO SCAN CODES
        JMP     SHORT K64               ; TRANSLATE_SCAN
PAGE
;------ TRANSLATE THE CHARACTER

K56:                                    ; TRANSLATE-CHAR
        DEC     AL                      ; CONVERT ORIGIN
        XLAT    CS:K11                  ; CONVERT THE SCAN CODE TO ASCII
        TEST    KB_FLAG_3,LC_E0         ; IS THIS A NEW KEY?
        JZ      K57                     ;  NO, GO FILL BUFFER
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 THERE?
        JZ      K57                     ;  NO, DO COMPATIBLE OUTPUT
        MOV     AH,MC_E0                ;  YES, PUT SPECIAL MARKER IN AH
        JMP     SHORT K57               ; PUT IT INTO THE BUFFER

;------ TRANSLATE SCAN FOR PSEUDO SCAN CODES

K64:                                    ; TRANSLATE-SCAN-ORGD
        DEC     AL                      ; CONVERT ORIGIN
        XLAT    CS:K8                   ; CTL TABLE SCAN
        MOV     AH,AL                   ; PUT VALUE INTO AH
        xor     al,al                   ; ZERO ASCII CODE
        TEST    KB_FLAG_3,LC_E0                 ; IS THIS A NEW KEY?
        JZ      K57                     ;  NO, GO FILL BUFFER
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 THERE?
        JZ      K57                     ;  NO, DO COMPATIBLE OUTPUT
        MOV     AL,MC_E0                ;  YES, PUT SPECIAL MARKER IN AL

;------ PUT CHARACTER INTO BUFFER

K57:                                    ; BUFFER-FILL
ifdef JAPAN
	CMP	AH,0E0h 		; Was this the Ctrl-Enter key? DCR 1815;AN013
	JE	Short K57N122		; Do not add 122 key marker    DCR 1815;AN013
	CMP	AH,S_XKBD_SCAN		; Is it non 122-keyboard key?  DCR 1815;AN013
	JBE	Short K57N122		; Yes, skip add of 122 marker  DCR 1815;AN013
	CMP	CS:S_122_MARKER,0	;  Check special INT 16h case flag     ;AN013
	JE	K57N122 		;  Skip F8 marker, if INT 16h broken   ;AN013
	MOV	AL,S_122_MARK		; Add special marker F8 if 122 DCR 1815;AN013
K57N122:								       ;AN013
endif ; JAPAN
	CALL	BUFFER_FILL
K59:
        JMP     K26                     ;-- THAT'S ALL FOLKS --

KEYB_INT_9   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: BUFFER_FILL
;
;  Description:
;      Generate keyboard buffer entry
;
;  Input Registers:
;      AX - the buffer entry
;      DS - BIOS data segment
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BUFFER_ENTRY_OK DB      NO              ; YES if character put into buffer

BUFFER_FILL     PROC   NEAR

;        CMP     AL,-1                   ; IS THIS AN IGNORE CHAR
;        JE      K61B                    ; YES, EXIT (commented YST)
        CMP     AH,-1                   ; LOOK FOR -1 PSEUDO SCAN
        JE      K61B                    ; EXIT
;
;  BUFFER_FILL_ANY_CHAR is an alternate entry point to this PROC.
;  Entry at this point will avoid trashing ASCII values of 255.
;
BUFFER_FILL_ANY_CHAR  LABEL  NEAR

        PUSH    SI
        PUSH    BX
        PUSH    DS                      ; This routine may be called
                                        ;  externally so make sure DS points
        MOV     BX,DATA                 ;   to BIOS data
        MOV     DS,BX

        ;; NTVDM cli                             ; disable interrupts  P724
        MOV     BX, BUFFER_TAIL         ; GET THE END POINTER TO THE BUFFER
        MOV     SI,BX                   ; SAVE THE VALUE
        INC     BX                      ; MOVE TO NEXT WORD IN LIST
        INC     BX

;; VERIFY IF THE CURRENT ROM LEVEL IN THE SYSTEM IS FOR THE ORIGINAL PC1

        TEST    BP,PC_81                ; CHECK FOR '81 DATE FLAG SET
ifndef JAPAN
        JNE     NOT_PC1                 ; IF IT'S A LATER ROM RELEASE, BRANCH
else ; JAPAN
	JZ	NOT_PC1 		; IF IT'S A LATER ROM RELEASE, BRANCH
endif ; JAPAN

        CMP     BX,OFFSET KB_BUFFER_END ; AT END OF BUFFER?
        JNE     K5                      ; NO, CONTINUE
        MOV     BX,OFFSET  KB_BUFFER    ; YES, RESET TO BUFFER BEGINNING
        JMP     SHORT K5
NOT_PC1:
        CMP     BX, BUFFER_END          ; AT END OF BUFFER?
        JNE     K5                      ; NO, CONTINUE
        MOV     BX, BUFFER_START        ; YES, RESET TO BUFFER BEGINNING
K5:
        CMP      BX,BUFFER_HEAD         ; HAS THE BUFFER WRAPPED AROUND
        JE      K62                     ; BUFFER_FULL_BEEP
        MOV     [SI],AX                 ; STORE THE VALUE
        MOV      BUFFER_TAIL,BX         ; MOVE THE POINTER UP
        MOV     CS:BUFFER_ENTRY_OK,YES  ; INDICATE WE PUT SOMETHING IN BUFFER
        JMP     SHORT K61A
K62:
        MOV     CS:BEEP_PENDING,YES     ; INDICATE WE NEED A BEEP
K61A:
        POP     DS
        POP     BX
        POP     SI
        ;; NTVDM sti                             ; enable interrupts  P724
K61B:
        RET
BUFFER_FILL     ENDP

PAGE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: ERROR_BEEP
;
;  Description:
;      General routine to generate beep tones
;
;  Input Registers:
;      None
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


ERROR_BEEP      PROC    NEAR

	CMP	 CS:BEEP_PENDING,YES	 ; Q..SHOULD WE BEEP?
        JNE     NO_BEEP

        MOV     CS:BEEP_PENDING,NO      ; Reset BEEP required
ifndef NOT_NTVDM
        mov     ah, 0eh
        mov     al, 07h
        int     10h

else
        MOV     CX,216-32               ; NUMBER OF CYCLES FOR 1/8 SECOND TONE
        IN      AL,PORT_B               ; Get control info
        PUSH    AX
LOOP01:
        AND     AL,0FCH                 ; Turn off timer gate and speaker
        OUT     PORT_B,AL               ; output to control - speaker off
        CALL    WAITFB                  ; half cycle time for tone
        OR      AL,2                    ; turn on speaker
        CLI                             ; Disable interrupts for 1/2 cycle, 300u
        OUT     PORT_B,AL               ; output to control
        CALL    WAITFB                  ; another half cycle
        STI                             ; Enable interrupts between 1/2 cycle
        LOOP    LOOP01

        POP     AX
        OUT     PORT_B,AL               ; Restore control
        MOV     CX,32*2                 ; Short delay count of 32 cycles
LOOP02:
        CALL    WAITFB                  ; Add a short delay to complete 1/8 sec
        LOOP    LOOP02                  ; Repeat
        CLI                             ; Disable interrupts
endif

NO_BEEP:
        RET                             ; RETURN
ERROR_BEEP      ENDP


ifdef NOT_NTVDM
WAITFB  PROC    NEAR                    ;       DELAY FOR  (CX)*15.085737 US
        PUSH    AX                      ; SAVE WORK REGISTER (AH)
        PUSH    CX                      ; SAVE COUNT
        MOV     CX,19                   ; The half cycle time for 1745 hz
        TEST    BP,PC_AT+PC_386         ; IF THE SYSTEM IS AN 80x86
        JNZ     WAITF1                  ; SKIP TO REFRESH BIT DELAY

WAITF0:
        NOP                             ; Force two fetch cycles on Model 30
        LOOP    WAITF0                  ; SOFTWARE DELAY LOOP ON 808x MACHINES

        JMP     SHORT WAITFE            ; EXIT

WAITF1:                                 ;       USE TIMER 1 OUTPUT BITS
        IN      AL,PORT_B               ; READ CURRENT COUNTER OUTPUT STATUS
        AND     AL,REFRESH_BIT          ; MASK FOR REFRESH DETERMINE BIT
        CMP     AL,AH                   ; DID IT JUST CHANGE
        JE      WAITF1                  ; WAIT FOR A CHANGE IN OUTPUT LINE

        MOV     AH,AL                   ; SAVE NEW FLAG STATE
        LOOP    WAITF1                  ; DECREMENT HALF CYCLES TILL COUNT END
WAITFE:

        POP     CX                      ; RESTORE COUNT
        POP     AX                      ; RESTORE (AH)
        RET                             ; RETURN  (CX)= 0

WAITFB  ENDP
endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       SHIP_IT
;
;       THIS ROUTINE HANDLES TRANSMISSION OF COMMAND AND DATA BYTES
;       TO THE KEYBOARD CONTROLLER.
;
;       On entry the AL contains the command byte.
;       On Enable keyboard commands, the reset keyboard input latch is done
;       if the system is the old PC type.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SHIP_IT PROC    NEAR

ifdef NOT_NTVDM
;------- TEST SYSTEM TYPE
        PUSHF                           ; SAVE FLAGS    P725
        CLI                             ; DISABLE INTERRUPTS TILL DATA SENT

        TEST    BP,PC_XT+PC_LAP
        JZ      SI5                     ; USE AT 8042 COMMAND IF NOT PC TYPE

        CMP     AL,ENA_KBD              ; CHECK FOR ENABLE KEYBOARD COMMAND
        JNE     SI9                     ; SKIP ENABLE RESET
                                        ;   FOR PC, XT, P12: RESET THE KEYBOARD
        PUSH    AX                      ; SAVE AX
        IN      AL,KB_CTL               ; GET THE CONTROL PORT
        MOV     AH,AL                   ; SAVE VALUE
        OR      AL,80H                  ; RESET BIT FOR KEYBOARD ON PC/PC-XT
        OUT     KB_CTL,AL
        XCHG    AH,AL                   ; GET BACK ORIGINAL CONTROL
        OUT     KB_CTL,AL               ; KB HAS BEEN RESET
        POP     AX                      ; RESTORE AX
                                        ; EXIT as NOT next system
SI5:
        TEST    BP,PC_AT+PC_386         ; IF THE SYSTEM IS NOT AN 80x86
        JZ      SI9                     ; MACHINE, EXIT THIS PROC.

;------- WAIT FOR COMMAND TO BE ACCEPTED;

        CALL    chk_ibf                 ; GO READ KEYBOARD CONTROLLER STATUS
endif

        OUT     STATUS_PORT,AL          ; SEND TO KEYBOARD CONTROLLER

ifdef NOT_NTVDM
SI9:                                    ; ENABLE INTERRUPTS AGAIN
        POPF                            ; RESTORE FLAGS P725
endif
        RET                             ; RETURN TO CALLER
SHIP_IT ENDP

ifdef NOT_NTVDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       SND_DATA
;
;       THIS ROUTINE HANDLES TRANSMISSION OF COMMAND AND DATA BYTES
;       TO THE KEYBOARD AND RECEIPT OF ACKNOWLEDGEMENTS.  IT ALSO
;       HANDLES ANY RETRIES IF REQUIRED
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_DATA PROC   NEAR
        PUSH    AX                      ; SAVE REGISTERS
        PUSH    BX                      ; *
        PUSH    CX
        MOV     BH,AL                   ; SAVE TRANSMITTED BYTE FOR RETRIES

        MOV     BL,3                    ; LOAD RETRY COUNT
SD0:
        CLI                             ; DISABLE INTERRUPTS
        AND     KB_FLAG_2,NOT (KB_FE+KB_FA+kb_err) ; CLEAR ACK, RESEND and
                                                    ; error flags

        CALL    CHK_IBF                 ; Wait for command accepted

        MOV     AL,BH                   ; REESTABLISH BYTE TO TRANSMIT
        OUT     PORT_A,AL               ; SEND BYTE
        STI                             ; ENABLE INTERRUPTS
        MOV     CX,DLY_15MS             ; DELAY FOR 15 ms TIMEOUT
SD1:    TEST    KB_FLAG_2,KB_FE+KB_FA   ; SEE IF EITHER BIT SET
        JNZ     SD3                     ; IF SET, SOMETHING RECEIVED GO PROCESS
        IN      AL,PORT_B               ; WAIT LOOP USING REFRESH BIT
        AND     AL,REFRESH_BIT
        CMP     AL,AH
        JE      SD1                     ; KEEP TESTING
        MOV     AH,AL                   ; DEC CX ON REFRESH TIC
        LOOP    SD1                     ; KEEP TESTING
                                        ; !! TIMEOUT !!

SD2:    DEC     BL                      ; DECREMENT RETRY COUNT
        JNZ     SD0                     ; RETRY TRANSMISSION
        OR      KB_FLAG_2,KB_ERR        ; TURN ON TRANSMIT ERROR FLAG
        JMP     SHORT SD4               ; RETRIES EXHAUSTED FORGET TRANSMISSION

SD3:    TEST    KB_FLAG_2,KB_FA         ; SEE IF THIS IS AN ACKNOWLEDGE
        JZ      SD2                     ; IF NOT, GO RESEND

SD4:    POP     CX                      ; RESTORE REGISTERS
        POP     BX
        POP     AX                      ; *
        RET                             ; RETURN, GOOD TRANSMISSION
SND_DATA ENDP
endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       SND_LED
;
;       THIS ROUTINE TURNS ON THE MODE INDICATORS.
;
; NTVDM - we do not need to update led's as this is controlled
;         by the host\system. We also assume that interrupts are
;         off upon entry
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_LED PROC    NEAR
ifdef NOT_NTVDM
        CLI                             ; TURN OFF INTERRUPTS

        TEST    BP,PC_AT+PC_386         ; IF THE SYSTEM IS NOT A 80x86
        JZ      SL1                     ; MACHINE, EXIT THIS PROC
endif

        TEST    KB_FLAG_2,KB_PR_LED     ; CHECK FOR MODE INDICATOR UPDATE
        JNZ     SL1                     ; DONT UPDATE AGAIN IF UPDATE UNDERWAY
        OR      KB_FLAG_2,KB_PR_LED     ; TURN ON UPDATE IN PROCESS
ifdef NOT_NTVDM
        MOV     AL,LED_CMD              ; LED CMD BYTE
        CALL    SND_DATA                ; SEND DATA TO KEYBOARD
        CLI
endif
        CALL    MAKE_LED                ; GO FORM INDICATOR DATA BYTE
        AND     KB_FLAG_2,0F8H                  ; CLEAR MODE INDICATOR BITS
        OR      KB_FLAG_2,AL            ; SAVE PRESENT INDICATORS FOR NEXT TIME

        mov   ah, 3                     ; inform softpc to set lights
        BOP   16h


ifdef NOT_NTVDM
        TEST    KB_FLAG_2,KB_ERR        ; TRANSMIT ERROR DETECTED
        JNZ     SL2                     ;  YES, BYPASS SECOND BYTE TRANSMISSION
        CALL    SND_DATA                ; SEND DATA TO KEYBOARD
        CLI                             ; TURN OFF INTERRUPTS
        TEST    KB_FLAG_2,KB_ERR        ; TRANSMIT ERROR DETECTED
        JZ      SL3                     ; IF NOT, DONT SEND AN ENABLE COMMAND
SL2:    MOV     AL,KB_ENABLE            ; GET KEYBOARD CSA ENABLE COMMAND
        CALL    SND_DATA                ; SEND DATA TO KEYBOARD
        CLI                             ; TURN OFF INTERRUPTS
endif

SL3:    AND     KB_FLAG_2,NOT(KB_PR_LED+KB_ERR) ; TURN OFF MODE INDICATOR
                                        ; UPDATE AND TRANSMIT ERROR FLAG
SL1:
ifdef NOT_NTVDM
        STI                             ; ENABLE INTERRUPTS
endif
        RET                             ; RETURN TO CALLER
SND_LED ENDP
PAGE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       MAKE_LED
;
;       THIS ROUTINE FORMS THE DATA BYTE NECESSARY TO TURN ON/OFF
;       THE MODE INDICATORS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MAKE_LED PROC   NEAR
        PUSH    CX                      ; SAVE CX
        MOV     AL, KB_FLAG             ; GET CAPS & NUM LOCK INDICATORS
        AND     AL,CAPS_STATE+NUM_STATE+SCROLL_STATE ; ISOLATE INDICATORS
        MOV     CL,4                    ; SHIFT COUNT
        ROL     AL,CL                   ; SHIFT BITS OVER TO TURN ON INDICATORS
        AND     AL,07H                  ; MAKE SURE ONLY MODE BITS ON
        POP     CX
        RET                             ; RETURN TO CALLER
MAKE_LED ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       CHK_IBF
;
;  Description:
;      Waits for a keyboard command to be accepted
;       wait until ibf = 0   (empty)
;
;  Input Registers:
;      None
;
;  Output Registers:
;       ZF=0    time out & IBF still full
;       ZF=1    IBF is empty
;
;       ---------------------------------------------------------------
;       This procedure replaces the previous one which used a software
;       timing loop.   (For 80286, 80386 and 80486 based machines.)
;       ---------------------------------------------------------------
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

chk_ibf proc    near

        push    ax                      ; Save register used
        push    cx
	mov	cx,DLY_15MS		; Timeout 15 milleseconds (15000/15.086;
chk_ibfl:
ifdef JAPAN
	in	al,status_port		; Read status port
	test	al,inpt_buf_full	; Check for input buffer empty
	jz	chk_ibfe		; Exit if IBF off, no command pending
endif ; JAPAN
        in      al,PORT_B               ; Read current refresh output bit
        and     al,refresh_bit          ; Mask all but refresh bit
        cmp     al,ah                   ; Did it change? (or first pass thru)
        jz      short chk_ibfl          ; No, wait for change, else continue

        mov     ah,al                   ; Save new refresh bit state
ifndef JAPAN
        in      al,status_port          ; Read status port
        test    al,inpt_buf_full        ; Check for input buffer empty
        loopnz  chk_ibfl                ; Loop until input buf empty or timeout;
else ; JAPAN
	loop	chk_ibfl		; Loop until timeout		       
chk_ibfe:				;  or exit when Input Buffer Full off
endif ; JAPAN
        pop     cx
        pop     ax                      ; Restore register used
        ret                             ; Return to caller

chk_ibf endp

ifdef JAPAN
;***********************************************************************;JP9009
;*								       *;JP9009
;*		      DBCS Common Keyboard Support		       *;JP9009
;*								       *;JP9009
;*	The DBCS common keyboard unique scan code is mapped to the     *;JP9009
;*	temporary scan code. It is again mapped to the corresponding   *;JP9009
;*	scan code/character code according the current shift staes.    *;JP9009
;*								       *;JP9009
;***********************************************************************;JP9009
									;JP9009
DBCS_keyboard_support	proc	near					;JP9009
	cmp	al, 80h 			; Ignore break keys	;JP9009
	jae	leave_it_to_common_method				;JP9009
;AN013	  test	  cs:SD.KEYB_TYPE, DBCS_KB	  ; DBCS keyboard?	  ;JP9009
;AN013	    jz	    leave_it_to_common_method				  ;JP9009
	cmp	cs:SD.INVOKED_CP_TABLE, 932	; DBCS code page?	;JP9009
	jb	leave_it_to_common_method				;JP9009
		call	DBCS_keyboard_common_support			;JP9009
		test	cs:SD.KEYB_TYPE, DBCS_OLD_KB			;JP9009
		jz	leave_it_to_common_method_1			;JP9009
			call	DBCS_old_keyboard_support		;JP9009
	leave_it_to_common_method_1:					;JP9009
		mov	ah, al		; ah = al = 'make' scan code    ;JP9009
		mov	cs:scan_code, al; Set this because we don't know;JP9009
					; who will use it later.	;JP9009
    leave_it_to_common_method:						;JP9009
	ret								;JP9009
DBCS_keyboard_support	endp						;JP9009
									;JP9009
PSEUDO_SC_ALPHANUMERIC	equ	7eh					;JP9009
PSEUDO_SC_HIRAGANA	equ	7fh					;JP9009
									;JP9009
DBCS_keyboard_common_support	proc	near				;JP9009
	; Check if it is the Alphanumeric key or Kanji NO key		;JP9009
	; of the DBCS new keyboard.					;JP9009
	cmp	al, 3ah 			; CAPS key ?		;JP9009
	jne	leave_it_to_common_method_2	; if not		;JP9009

	mov	cx,cs:SD.KEYB_TYPE                                      ;QFESP4
	and     cx,07h
	cmp	cx,2				; 106 kbd?
	jz	check_key_status
	cmp	cx,3				; IBM-5576 002/003 kbd?
	jz	check_key_status
	cmp	cx,0				; 101 kbd?
	jnz	leave_it_to_common_method_2

	test	bl,(ALT_SHIFT or CTL_SHIFT or LEFT_SHIFT or RIGHT_SHIFT)
	jz	leave_it_to_common_method_2
        push    bx
        and     bl,(ALT_SHIFT or CTL_SHIFT)
	cmp	bl,(ALT_SHIFT or CTL_SHIFT)	;press alt and ctl ?
        pop     bx
	jz	leave_it_to_common_method_2
	jmp	short convert_to_alphanumeric_2

    check_key_status:							;QFESP4
	test	bl, ALT_SHIFT						;JP9009
	jnz	convert_to_alphanumeric 				;JP9009
	test	bl, (LEFT_SHIFT or RIGHT_SHIFT) 			;JP9009
	jnz	leave_it_to_common_method_2				;JP9009
	jmp	short convert_to_alphanumeric_2 			;JP9009
    convert_to_alphanumeric:						;JP9009
	    test    cs:SD.KEYB_TYPE, DBCS_OLD_A_KB			;JP9009
	    jnz     leave_it_to_common_method_2 			;JP9009
    convert_to_alphanumeric_2:						;JP9009
		mov	al, PSEUDO_SC_ALPHANUMERIC			;JP9009
    leave_it_to_common_method_2:					;JP9009
	ret								;JP9009
DBCS_keyboard_common_support	endp					;JP9009
									;JP9009

;***********************************************************************;JP9009
;*								       *;JP9009
;*		      DBCS Old Keyboard Support 		       *;JP9009
;*								       *;JP9009
;*	The old DBCS keyboard unique scan codes is mapped to the       *;JP9009
;*	temporary scan code. It is again mapped to the corresponding   *;JP9009
;*	scan code/character code according the current shift staes.    *;JP9009
;*								       *;JP9009
;***********************************************************************;JP9009
									;JP9009
DBCS_old_keyboard_support	proc	near				;JP9009
	mov	cx,cs:SD.KEYB_TYPE
	and     cx,07h
	cmp	cx,2				; 106 kbd?
	jz	check_old_key_status
	cmp	cx,3				; IBM-5576 002/003 kb?
	jne	not_right_ALT_nor_hiragana
check_old_key_status:

	cmp	al, 38h 						;JP9009
	jne	not_right_ALT_nor_hiragana				;JP9009
	test	ds:KB_FLAG_3, LC_E0					;JP9009
	jz	not_right_ALT_nor_hiragana				;JP9009
		mov	al, PSEUDO_SC_HIRAGANA				;JP9009
		and	ds:KB_FLAG_3, not LC_E0 			;JP9009
    not_right_ALT_nor_hiragana: 					;JP9009
	ret								;JP9009
DBCS_old_keyboard_support	endp					;JP9009
endif ; JAPAN

DOSTI proc    near
      FSTI
      ret
DOSTI endp

DOCLI proc    near
      FCLI
      ret
DOCLI endp

DOIRET:
      FIRET

CODE    ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybequ.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBEQU.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Include file containing equates used by all KEYB modules.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
YES		EQU	1		;;
NO		EQU	0		;;
					;;
INT_2F_SUB_FUNC EQU	0ADH		;; our subfunction code for int 2f
SD		EQU	SHARED_DATA	;;
TSD		EQU	TEMP_SHARED_DATA;;
					;;
DLY_15ms	EQU	995		;; 15mS DELAY = (15000/15.086)
MOUSE_OBF	EQU	00100000b	;; AUX DATA PRESENT BIT AT STATUS_PORT
SCAN_CODE_CMD	EQU	0F0h		;; SELECT SCAN CODE SET COMMAND TO KB
					;;
ifdef NOT_NTVDM
FILE_BUFFER_SIZE equ	300		;; buffer used for reading keyboard.sys
else
FILE_BUFFER_SIZE equ	40 * 2 * 6	;;
endif
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybi2f.asm ===
PAGE    ,132
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBI2F.ASM
; ----------
;
; Description:
; ------------
;       Contains Interrupt 2F handler.
;
; Procedures Contained in This File:
; ----------------------------------
;       KEYB_INT_2F - Interupt 2F handler
;
; Include Files Required:
; -----------------------
;       INCLUDE KEYBEQU.INC
;       INCLUDE KEYBSHAR.INC
;       INCLUDE KEYBMAC.INC
;       INCLUDE KEYBCMD.INC
;       INCLUDE KEYBCPSD.INC
;       INCLUDE KEYBI9C.INC
;
; External Procedure References:
; ------------------------------
;       FROM FILE  ????????.ASM:
;               procedure - description????????????????????????????????
;
; Linkage Information:  Refer to file KEYB.ASM
; --------------------
;
; Change History:
; ---------------

        INCLUDE KEYBEQU.INC
        INCLUDE KEYBSHAR.INC
ifndef JAPAN
        INCLUDE KEYBMAC.INC
endif ; !JAPAN
        INCLUDE KEYBCMD.INC
        INCLUDE KEYBCPSD.INC
        INCLUDE KEYBI9C.INC

        PUBLIC KEYB_INT_2F

        EXTRN  ERROR_BEEP:NEAR


        EXTRN  NLS_FLAG_1:BYTE         ;; (YST)


CODE    SEGMENT PUBLIC 'CODE'

        ASSUME  CS:CODE,DS:nothing

; Module: KEYB_INT_2F
;
; Description:
;
; Input Registers:
;       AH = 0ADH
; ifdef JAPAN
;	AL = 80,81,82,83
; else
;       AL = 80,81,82
; endif
;
; Output Registers:
;       N/A
;
; Logic:
;       IF AH = 0ADh THEN        (this call is for us)
;       Set carry flag to 0
;       IF AL = 80 THEN
;         Get major and minor
;         Get SEG:OFFSET of SHARED_DATA_AREA
;
;       IF AL = 81 THEN
;         Get FIRST_XLAT_PTR
;         FOR each table
;               IF code page requested = code page value at pointer THEN
;               Set INVOKED_CODE_PAGE
;               Set ACTIVE_XLAT_PTR
;               EXIT
;               ELSE
;               Get NEXT_SECT_PTR
;         NEXT table
;         IF no corresponding code page found THEN
;               Set carry flag
;
;       IF AL = 82 THEN
;         IF BL = 00 THEN
;               Set COUNTRY_FLAG = 00
;         ELSE IF BL = 0FFH THEN
;               Set COUNTRY_FLAG = 0FFH
;         ELSE
;               Set carry flag
; ifdef JAPAN
;	IF AL = 83 THEN
;	  Return BL=COUNTRY_FLAG
; endif
;       JMP to previous INT 2FH handler

CP_QUERY        EQU     80H
CP_INVOKE       EQU     81H
CP_LANGUAGE     EQU     82H
ifdef JAPAN
CP_QLANGUAGE	EQU	83H
endif ; JAPAN


GET_KB_MODE     EQU   83H              ;; ONLY FOR RUSSIAN (YST)
SET_KB_MODE     EQU   84H              ;; ONLY FOR RUSSIAN


VERSION_MAJOR   EQU     01H
VERSION_MINOR   EQU     00H

CARRY_FLAG      EQU     01H

KEYB_INT_2F     PROC

        cmp     ah,INT_2F_SUB_FUNC      ; is it for us?
        jz      our_i2f_interrupt

i2f_chain:

;       Under DOS 5, it is always safe for us to assume that there was
;         an existing Int2f vector for us to continue to.

        jmp     cs:sd.old_int_2f

our_i2f_interrupt:

        push    bp
        mov     bp,sp
        and     word ptr [bp]+6,not carry_flag ; pre-clear carry
        call    do_our_i2f              ; pass bp.6 -> flags to functions

        pop     bp
        jmp     i2f_chain

do_our_i2f:
        CMP     AL,CP_QUERY             ; Q..query CP?
        JNE     INT_2F_CP_INVOKE        ; N..next

        MOV     AX,-1                   ; Y..process query
        mov     bx,(version_major shl 8) + version_minor
        MOV     DI,OFFSET SD
        PUSH    CS
        POP     ES
        ret

INT_2F_CP_INVOKE:
        CMP     AL,CP_INVOKE            ; Q..invoke CP?
        JNE     INT_2F_CP_LANGUAGE      ; N..next

        MOV     SI,cs:SD.FIRST_XLAT_PTR         ; Get FIRST_XLAT_PTR

INT_2F_NEXT_SECTION:
        CMP     SI,-1
        JE      INT_2F_ERROR_FLAG

        cmp     bx,cs:[SI].XS_CP_ID     ; is this the code page we want?
        JNE     INT_2F_CP_INVOKE_CONT1

        MOV     cs:SD.ACTIVE_XLAT_PTR,SI ; IF Yes, Set the ACTIVE_XLAT_PTR
        MOV     cs:SD.INVOKED_CP_TABLE,BX ;     record new code page
        ret

INT_2F_CP_INVOKE_CONT1:
        MOV     SI,cs:[SI].XS_NEXT_SECT_PTR ; Chain to NEXT_SECT_PTR
        JMP     INT_2F_NEXT_SECTION     ;       NEXT_SECTION

INT_2F_ERROR_FLAG:
        mov     ax,1                    ; ***???  why do we return error code
;                                       ;   only in this case?????
i2f_reterror:
        or      word ptr [bp]+6,carry_flag ; set carry to int2f caller
        ret

INT_2F_CP_LANGUAGE:
        CMP     AL,CP_LANGUAGE          ; Q..Set default language??


ifdef JAPAN
	jnz	INT_2F_CP_QLANG		; go check for query language
else ; !JAPAN
        jnz     int2f_ret               ; don't handle undefined functions
endif ; !JAPAN

;       Now, if BL=0 or 0ffh, we'll set COUNTRY_FLAG to that value.

        inc     bl
        cmp     bl,2                    ; set carry if bl is legal
        dec     bl                      ; restore old value, preserve carry
        jnc     i2f_reterror            ; done if error

        MOV     cs:COUNTRY_FLAG,BL      ;       Set COUNTRY_FLAG to 0 or 0ffh
;; ============================================================
;;       ONLY FOR RUSSIAN KEYBOARD !!!!!
;; ============================================================
        jmp     short int2f_ret

INT_2F_KB_MODE_ERROR_FLAG:             ;;   ==== (YST) ===                                       ;;
INT_2F_GET_KB_MODE:                    ;; (YST)-----------------------------
        CMP   AL,GET_KB_MODE           ;; Q..Get keyboard mode?            |
        JNE   INT_2F_SET_KB_MODE       ;; N..next                          |
;        PUSH  DS                       ;;
;        PUSH  BX                       ;;
;        PUSH  CX                       ;;
;        PUSH  SI                       ;;
;        push  cs
;        pop   ds
        XOR   AX,AX                    ;;                                  |
        OR    AL,cs:COUNTRY_FLAG          ;; Q..CTRL+ALT+F1 was pressed?      |
        JZ    INT_2F_GET_KB_MODE_DONE  ;; Y..return AX = 0                 |
                                       ;; Q..is current driver switchable? |
        TEST  WORD PTR CS:SD.SPECIAL_FEATURES,SWITCHABLE  ;;               |
        JZ    INT_2F_GET_KB_MODE_DONE  ;; N..return AX = 0FFH              |
        MOV   AL,cs:NLS_FLAG_1            ;; Y..return <keyb NL mode+1>       |------------------\
        AND   AL,1                     ;;                                  | if RUS_MODE = 1 | >   S
        INC   AX                       ;;                                  |------------------/    A
                                       ;;                                  |
INT_2F_GET_KB_MODE_DONE:               ;; For DOS 5 normal exit            |
        RET                            ;;                                  |
                                       ;;                                  |
INT_2F_SET_KB_MODE:                    ;;                                  |
        CMP   AL,SET_KB_MODE           ;; Q..Set keyboard mode?            |
        JNE   int2f_ret                ;; N..next                          |
                                       ;;                                  |
        MOV   BH,cs:NLS_FLAG_1            ;;                                  |
                                       ;;                                  |
        TEST  BL,0FEH                  ;; Q..BL equ 0 or 1?                |---------------------
        JNZ   INT_2F_KB_MODE_ERROR_FLAG;; N..Set CARRY flag                |                    |
        AND   BH,0FEH                  ;; Y..Set NL mode                   |  if RUS_MODE = 1   |
        OR    BH,BL                    ;;                                  |                    |
                                       ;;                                  |---------------------
                                       ;;                                  |
        MOV   cs:NLS_FLAG_1,BH            ;; Store this value                 |
                                       ;;                                  |
                                       ;;                                  |
                                       ;;                                  |
                                       ;; (YST)-----------------------------

int2f_ret:
        ret

ifdef JAPAN
INT_2F_CP_QLANG:
	CMP	AL,CP_QLANGUAGE
	jnz	int2f_ret

	mov	bl,cs:COUNTRY_FLAG
	ret
endif ; JAPAN

KEYB_INT_2F     ENDP

CODE    ENDS
        END

;; ========================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybi9c.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI9C.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBI9C.ASM
;;
;; Change History:
;; ---------------
;; Delete unused externs
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
        EXTRN   KEYB_INT_9:NEAR         ;;
        EXTRN   K8:BYTE                 ;;
        EXTRN   BUFFER_FILL:NEAR        ;;
        EXTRN   COUNTRY_FLAG:BYTE       ;;
        EXTRN   COPY_NLS1_FLAG:BYTE     ;; (YST)
        EXTRN   BEEP_PENDING:BYTE       ;;
        EXTRN   SCAN_CODE:BYTE          ;;
        EXTRN   CHK_IBF:NEAR            ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybmsg.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBMSG.INC
;; ----------
;;
;; Root File Name:  KEYBCMD.ASM (KEYB.ASM)
;; ---------------
;;
;; Description:
;; ------------
;;	 External declarations for procedures in file KEYBCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	EXTRN	 ACT_KEYB_CP :BYTE     ;;
	EXTRN	 ACT_CON_CP  :BYTE     ;;
	EXTRN	 ACT_KEYB    :BYTE     ;;
	EXTRN	 INV_L	     :BYTE     ;;
	EXTRN	 INV_I	     :BYTE     ;;
	EXTRN	 INV_CP      :BYTE     ;;
	EXTRN	 INV_S	     :BYTE     ;;
	EXTRN	 INV_FN      :BYTE     ;;
	EXTRN	 INV_KEYB_Q  :BYTE     ;;
	EXTRN	 INV_CON_Q   :BYTE     ;;
	EXTRN	 NOT_DESIG   :BYTE     ;;
	EXTRN	 NOT_SUPP    :BYTE     ;;
	EXTRN	 NOT_VALID1  :BYTE     ;;
	EXTRN	 NOT_VALID2  :BYTE     ;;
	EXTRN	 WARNING_1   :BYTE     ;;
	EXTRN	 INV_COMBO   :BYTE     ;;
	EXTRN	 CR_LF	     :BYTE     ;;
	EXTRN	 MEMORY_OVERF :BYTE    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybmac.inc ===
.XLIST

;     *   IBM CONFIDENTIAL   *   Jan 9 1990   *

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PC DOS 3.3 - NLS Support - Keyboard Definition File
;; (C) Copyright IBM Corp 198?,...
;;
;; File Name:  KEYBMAC.INC
;; ----------
;;
;; Author:     Bill Devlin  - IBM Canada Laboratory - May 1986
;; -------     ???????????
;;
;; Description:
;; ------------
;;       Include file containing macros for the Keyboard Definition File.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Dead key flags
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
ACUTE               EQU   80H          ;; NLS_FLAG_1
GRAVE               EQU   40H          ;;
DIARESIS            EQU   20H          ;;
CIRCUMFLEX          EQU   10H          ;;
CEDILLA             EQU   08H          ;;
TILDE               EQU   04H          ;;
RUS_MODE            EQU   01H          ;; Added YST for Cyrillic keyboard
LAT_MODE            EQU   00H          ;; 1/21/91
                                       ;; NLS_FLAG_2 : nothing defined yet
CARON               EQU   80H
BREVE               EQU   40H
OVERCIRCLE          EQU   20H
OGONEK              EQU   10H
OVERDOT             EQU   08H
DOUBLEACUTE         EQU   04H

                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State IDs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DEAD_LOWER          EQU    1           ;; dead keys on lower shift
DEAD_UPPER          EQU    2           ;;
ALPHA_LOWER         EQU    3           ;;
ALPHA_UPPER         EQU    4           ;;
NON_ALPHA_LOWER     EQU    5           ;;
NON_ALPHA_UPPER     EQU    6           ;;
THIRD_SHIFT         EQU    7           ;;
ACUTE_LOWER         EQU    8           ;;
ACUTE_UPPER         EQU    9           ;;
ACUTE_SPACE         EQU   10           ;;
GRAVE_LOWER         EQU   11           ;;
GRAVE_UPPER         EQU   12           ;;
GRAVE_SPACE         EQU   13           ;;
DIARESIS_LOWER      EQU   14           ;;
DIARESIS_UPPER      EQU   15           ;;
DIARESIS_SPACE      EQU   16           ;;
CIRCUMFLEX_LOWER    EQU   17           ;;
CIRCUMFLEX_UPPER    EQU   18           ;;
CIRCUMFLEX_SPACE    EQU   19           ;;
CEDILLA_LOWER       EQU   20           ;;
CEDILLA_UPPER       EQU   21           ;;
CEDILLA_SPACE       EQU   22           ;;
CEDILLA_CEDILLA     EQU   23           ;;
DEAD_THIRD          EQU   24           ;;
ACUTE_ACUTE         EQU   25           ;;
GRAVE_GRAVE         EQU   26           ;;
DIARESIS_DIARESIS   EQU   27           ;;
CIRCUMFLEX_CIRCUMFLEX EQU 28           ;;
FOURTH_SHIFT        EQU   29           ;;
DEAD_FOURTH         EQU   30           ;;
TILDE_LOWER         EQU   31           ;;
TILDE_UPPER         EQU   32           ;;
TILDE_SPACE         EQU   33           ;;
TILDE_TILDE         EQU   34           ;;
ALT_CASE            EQU   35           ;;
CTRL_CASE           EQU   36           ;;
NUMERIC_PAD         EQU   37           ;;
DIVIDE_SIGN         EQU   38           ;;
BOTLH_CAPS          EQU   39           ;;
BOTRH_CAPS          EQU   40           ;;
BOTLH_F_CAPS        EQU   41           ;;
BOTRH_F_CAPS        EQU   42           ;;
RUS_MODE_SET        EQU   43           ;;   Added YST for Cyrillic keyboard
                                       ;;
;************************************************
; Mihindu 11/30/90 - Added Eastern Europe support
;************************************************
CARON_SPACE         EQU   43
CARON_LOWER         EQU   44
CARON_UPPER         EQU   45
BREVE_SPACE         EQU   46
BREVE_LOWER         EQU   47
BREVE_UPPER         EQU   48
OVERCIRCLE_SPACE    EQU   49
OVERCIRCLE_LOWER    EQU   50
OVERCIRCLE_UPPER    EQU   51
OGONEK_SPACE        EQU   52
OGONEK_LOWER        EQU   53
OGONEK_UPPER        EQU   54
OVERDOT_SPACE       EQU   55
OVERDOT_LOWER       EQU   56
OVERDOT_UPPER       EQU   57
DOUBLEACUTE_SPACE   EQU   58
DOUBLEACUTE_LOWER   EQU   59
DOUBLEACUTE_UPPER   EQU   60

;******************************************************
;  M000 --- new state for KDFJP.ASM (Kermit)    *******
;******************************************************

DBCS_OLD_A         EQU   61             ; M000 (JP9009)

NON_ALPHA_LOWER_LAT    EQU   62
NON_ALPHA_UPPER_LAT    EQU   63
ALPHA_LOWER_LAT        EQU   64
ALPHA_UPPER_LAT        EQU   65
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Logic Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;

UNKNOWN = 255

FIND_FLAG MACRO  FLAG_MASK
       IFIDN <FLAG_MASK>,<SCAN_MATCH>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_SHIFT>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<CAPS_STATE>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<NUM_STATE>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_CTL>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_ALT>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<LEFT_SHIFT>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<RIGHT_SHIFT>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<ALT_SHIFT>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<CTL_SHIFT>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<R_ALT_SHIFT>
          FLAG_ID = KB_FLAG_3_ID
       ELSE
       IFIDN <FLAG_MASK>,<R_CTL_SHIFT>
          FLAG_ID = KB_FLAG_3_ID
       ELSE
       IFIDN <FLAG_MASK>,<TILDE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<ACUTE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<GRAVE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<DIARESIS>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CEDILLA>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CIRCUMFLEX>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CARON>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<BREVE>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OVERCIRCLE>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OGONEK>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OVERDOT>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<DOUBLEACUTE>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<LC_E0>
          FLAG_ID = KB_FLAG_3_ID
       ELSE
;; ============================================================
;; For Cyrillic keyboards (YST)
;; ============================================================
       IFIDN <FLAG_MASK>,<SHIFTS_PRESSED>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<RUS_MODE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<LAT_MODE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
;; ============================================================
;; End of Cyrillic keyboards (YST)
;; ============================================================
          FLAG_ID = UNKNOWN
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FLAG MACRO  FLAG_MASK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
          IF2
              %OUT Unknown parameter FLAG_MASK on FLAG MACRO
          ENDIF
       ELSE
          DB FLAG_ID
          DB FLAG_MASK
       ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFF MACRO  FLAG_MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
         NOT_BIT = 00000000B
    ELSE
         IFIDN <MASK_TYPE>,<NOT>
             NOT_BIT = 00001000B
         ELSE
             MAC_OK = 0
             IF2
                 %OUT Unknown parameter MASK_TYPE on IFF MACRO
             ENDIF
         ENDIF
    ENDIF
    IF MAC_OK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
          IF2
              %OUT Unknown parameter FLAG_MASK on IFF MACRO
          ENDIF
       ELSE
          DB IFF_COMMAND+NOT_BIT+FLAG_ID
          DB FLAG_MASK
       ENDIF
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD MACRO  SYS
       DB IFKBD_COMMAND
       DW SYS
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ANDF MACRO  FLAG_MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
         NOT_BIT = 00000000B
    ELSE
         IFIDN <MASK_TYPE>,<NOT>
             NOT_BIT = 00001000B
         ELSE
             MAC_OK = 0
             IF2
                 %OUT Unknown parameter MASK_TYPE on ANDF MACRO
             ENDIF
         ENDIF
    ENDIF
    IF MAC_OK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
          IF2
              %OUT Unknown parameter FLAG_MASK on ANDF MACRO
          ENDIF
       ELSE
          DB ANDF_COMMAND+NOT_BIT+FLAG_ID
          DB FLAG_MASK
       ENDIF
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELSEF  MACRO
       DB  ELSEF_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIFF MACRO
       DB  ENDIFF_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
XLATT  MACRO STATE
       DB  XLATT_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PUT_ERROR_CHAR  MACRO STATE
       DB  PUT_ERROR_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPTION MACRO MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
         NOT_BIT = 00000000B
    ELSE
         IFIDN <MASK_TYPE>,<NOT>
             NOT_BIT = 00001000B
         ELSE
             MAC_OK = 0
             IF2
                 %OUT Unknown parameter MASK_TYPE on OPTION MACRO
             ENDIF
         ENDIF
    ENDIF
    IF MAC_OK
       DB  OPTION_COMMAND+NOT_BIT
       DB  MASK
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SET_FLAG  MACRO STATE
       DB  SET_FLAG_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS  MACRO
       DB  RESET_NLS_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS1  MACRO
       DB  RESET_NLS1_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BEEP   MACRO
       DB  BEEP_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOTO    MACRO GOTO_OFFSET
       DB  GOTO_COMMAND
       DW  GOTO_OFFSET-$-2
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EXIT_INT_9  MACRO
       DB  GOTO_COMMAND+EXIT_INT_9_FLAG
       DW  0
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EXIT_STATE_LOGIC  MACRO
       DB  GOTO_COMMAND+EXIT_STATE_LOGIC_FLAG
       DW  0
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECK_FOR_CORE_KEY MACRO
       DB  CHECK_CORE_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybshar.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1991
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSHAR.INC
;; ----------
;;
;; Description:
;; ------------
;;       Include file containing structure definitions Shared Data Area
;;       for the Shared Data Area.
;;       The Shared Data Area contains data which is required by
;;       both the resident and transient KEYB code.  The Shared
;;       Data Area is allocated in the KEYBI2F file and will be
;;       resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;; ;jwg  ; - Feb 1990 For 4.03.
;; ;AN007; -           Add Patriot/Sebring determination code for HOT Replug
;;                      so that INT 9 handler can alter keyboard Scan Code set.
;; ;M030                Merged IBM (Kermit - JP), KEYBOARD.SYS and KEYB.COM
;;                        versions of this file into one.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SHARED_DATA_STR defines the initial fixed length portion of the
;; Shared Data Area.
;; Tables are loaded beginning at TABLE_AREA in the following order:
;;  State Logic
;;  Common Translate Section
;;  Specific Translate Sections for
;;   each code page
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;; SPECIAL_FEATURES equates:
TYPEWRITER_CAPS_LK  EQU    8000H        ;; typewriter style caps lock
                                        ;;
JR_HOT_KEY_1_2  equ     4000h           ;; M030 Merged back for kdfcf.asm
;;========================================
;; Added YST for Cyrillic keyboards
;; 1/21/90
;;========================================
SHIFTS_TO_LOGIC     EQU    2000H       ;; - transfer CTRL, SHIFT, ALT keys
                                       ;;   to LOGIC section
                                       ;;
SWITCHABLE          EQU    1000H       ;; - Driver can use NLS/Def mode
                                       ;;   switching (like Rus/Lat mode)
                                       ;;   Used for Int 2Fh, function 0AD83h answer
;;========================================
;; End of YST
;;========================================
JR_KB           equ     8000h           ;; M030 Merged back for kdfcf.asm
                                        ;; Some useful scan codes:
F1_SCAN     EQU   59                    ;; F1
F2_SCAN     EQU   60                    ;; F2
                                        ;;
                                        ;;      SYSTEM_FLAG / Hardware equates:
                                        ;;   INT 16h and remote support
EXT_16          EQU     8000H           ;; extended INT 16h support is there
EXT_122         EQU     4000H           ;; extended INT 16h for 122 is there
;               EQU     2000H           ;;  unused
PC_NET          EQU     1000H           ;; flag PC Net is installed
                                        ;;   System type/hardware support flags
PC_81           EQU     0800H           ;; flag for Original PC
PC_XT           EQU     0400H           ;; code for PC, PC/XT, PORTABLE
PC_LAP          EQU     0200H           ;; code for Convertiable (p-12)
PC_PAL          EQU     0080H           ;; code for Model 30 (PALACE)
PC_AT           EQU     0040H           ;; code for PC-AT  with 8042
PC_386          EQU     0020H           ;; code for PS/2's with 8042 (WRANGLER)
PS_8042         EQU     0010H           ;; 8042 is a Patriot/Sebring type array;AN007;jwg
                                        ;;  or system set translate OFF (SCS=01)
SECURITY_ACTIVE         EQU     0008h   ; M030  ;; Server password mode is active
;                               ; M030  ;;  This bit becomes off from on when
;                               ; M030  ;;  correct password is entered JP9010
ifdef JAPAN
DBCS_OK 	EQU	0002h		;; DBCS scan codes are OK allowed
endif ; JAPAN
                                        ;;
                                        ;; HOT_KEY_FLAG EQUATES:
US_MODE     EQU   0                     ;;  hot key is active => US
LANG_MODE   EQU   0FFH                  ;;  hot key is inactive
                                        ;;
                                        ;; -----------------------------------
SHARED_DATA_STR     STRUC               ;; SHARED DATA AREA
                                        ;;
OLD_INT_9           DD    0             ;; saved int 9 vector
OLD_INT_2F          DD    0             ;; saved int 2F vector
                    dd    0             ;; reserved
KEYB_TYPE           DW    0             ;; type of keyboard
SYSTEM_FLAG         DW    0             ;; system configuration flags
TABLE_OK            DB    0             ;; flag to INT 9 that table is built
                    db    5 dup (0)     ;; reserved
                                        ;;
                                        ;; Table copy begins here:
ACTIVE_LANGUAGE     DB    'US'          ;; language code
INVOKED_CP_TABLE    DW    437           ;; ptr to table for invoked code page
INVOKED_KBD_ID      DW    0             ;; WGR invoked keyboard id.            ;AN000
ACTIVE_XLAT_PTR     DW    -1            ;; ptr to active Specific Translate Sect
FIRST_XLAT_PTR      DW    -1            ;; ptr to first Specific Translate Sect
RESIDENT_END        DW    0ffffh        ;; offset of last byte in resident mem
LOGIC_PTR           DW    -1            ;; ptr to State Logic
COMMON_XLAT_PTR     DW    -1            ;; ptr to Common Translate Section
SPECIAL_FEATURES    DW    ?             ;; special Features
TABLE_OVERFLOW      DB    0             ;; overflow flag for table rebuild
HOT_KEY_ON_SCAN     DB    ?             ;; scan codes to use with ALT+CTRL
HOT_KEY_OFF_SCAN    DB    ?             ;;  to turn hot key on and off
                    DB    4 DUP(0)      ;; reserved
TABLE_AREA          DB    ?             ;; tables loaded here:
                                        ;;  State Logic
                                        ;;  Common Translate Section
                                        ;;  Specific Translate Sections for
                                        ;;   each code page
SHARED_DATA_STR     ENDS                ;;
                                        ;;
                                        ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic equates.
;; Contains equates for our NLS Flags and for the State Logic
;; commands.
;; State Logic command macros are defined in KEYBMAC.INC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
STATE_LOGIC_STR STRUC                   ;;
                                        ;;
SL_LOGIC_LEN    DW   ?                  ;; length of state logic
SL_SPECIAL_FEATURES   DW   ?            ;;
SL_LOGIC_CMDS   DB   0                  ;; state logic commands begin here
                                        ;;
STATE_LOGIC_STR ENDS                    ;;
                                        ;;
                                        ;;
NUM_BIOS_FLAGS      EQU   4             ;;
NUM_NLS_FLAGS       EQU   2             ;; '+1' below is the EXT_KB_FLAG
NUM_FLAGS           EQU   NUM_BIOS_FLAGS+NUM_NLS_FLAGS+1
                                        ;;
                                        ;;
EITHER_SHIFT        EQU   80H           ;; EXT_KB_FLAG : our own shift state
EITHER_CTL          EQU   40H           ;;  flags
EITHER_ALT          EQU   20H           ;;
SCAN_MATCH          EQU   08H           ;; set if scan code found in XLATT
                                        ;; or SET_FLAG searches
                                        ;;
SHIFTS_PRESSED      EQU   04H          ;; set if any SHIFT, ALT, CTRL key
                                       ;; pressed (added YST for Cyrillic keyb.)
                                        ;;
KB_FLAG_ID          EQU   0             ;; Flag ID's as coded in IFF and ANDF
KB_FLAG_1_ID        EQU   1             ;;  commands
KB_FLAG_2_ID        EQU   2             ;;
KB_FLAG_3_ID        EQU   3             ;;
EXT_KB_FLAG_ID      EQU   4             ;;
NLS_FLAG_1_ID       EQU   5             ;;
NLS_FLAG_2_ID       EQU   6             ;;
                                        ;;
COMMAND_BITS        EQU   0F0H          ;; Mask to isolate command code
SUB_CMD_BITS        EQU   0FH           ;; mask to isolate sub command code
NOT_TEST            EQU   08H           ;; NOT bit in IFF, ANDF
COMMAND_SHIFT       EQU   4             ;; shift amount for command code
FLAG_ID_BITS        EQU   07H           ;; mask to isolate flag id in IFF, ANDF
NUM_COMMANDS        EQU   0CH           ;; number of commands
                                        ;;
IFF_COMMAND         EQU   00H           ;;
ANDF_COMMAND        EQU   10H           ;;
ELSEF_COMMAND       EQU   20H           ;;
ENDIFF_COMMAND      EQU   30H           ;;
XLATT_COMMAND       EQU   40H           ;;
OPTION_COMMAND      EQU   50H           ;;
SET_FLAG_COMMAND    EQU   60H           ;;
PUT_ERROR_COMMAND   EQU   70H           ;;
IFKBD_COMMAND       EQU   80H           ;;
GOTO_COMMAND        EQU   90H           ;;
BEEP_COMMAND        EQU   0A0H          ;;
RESET_NLS_COMMAND   EQU   0B0H          ;;
CHECK_CORE_COMMAND  EQU   0C0H          ;;
                                        ;;
                                        ;;
EXIT_INT_9_FLAG         EQU  01H        ;; Special forms of GOTO.  These
EXIT_STATE_LOGIC_FLAG   EQU  02H        ;;  values are in the right nibble
                                        ;;   of the GOTO command.
                                        ;;
                                        ;; PROCESSING OPTIONS:
EXIT_IF_FOUND       EQU   80H           ;; exit INT 9 if a translation
                                        ;;  match is found
                                        ;;
ANY_KB               EQU   0FFFFH       ;;
XT_KB                EQU   4000H        ;;
AT_KB                EQU   2000H        ;;
G_KB                 EQU   1000H        ;;
P_KB                 EQU   0800H        ;;
P12_KB               EQU   0400H        ;;
DBCS_OLD_A_KB        EQU   0080H ; M030         ;; JP9009
DBCS_OLD_P_KB        EQU   0040H ; M030         ;; JP9009
DBCS_OLD_G_KB        EQU   0020H ; M030         ;; JP9009
DBCS_OLD_KB          EQU   00C0H ; M030         ;; JP9009
DBCS_KB                      EQU   0020H ; M030         ;; JP9009
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table Sections.  Both the Specific and Common
;; Translate Sections are formatted as follows.
;;
;; The Specific Translate Sections are chained together using the
;; XS_NEXT_SECT_PTR field (-1 if last section).
;; Translate Sections contains multiple States.
;; A State contains the translate tables for a single
;; shift state (IE lower case, upper case ....)
;; Each State may contain multiple translate tables.
;;
;; The Translate Section layout is defined using several STRUCs.
;; These STRUCs are allocated in the Shared Data Area as follows:
;;
;;       XLAT_SECT_STR            ; header info for the section
;;          STATE_STR             ; header for state #1
;;            XLAT_STR            ;   first translate tab for state #1
;;            XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;            XLAT_STR            ;   second translate tab
;;            XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;            ...
;;          STATE_STR             ; header for state #2
;;            XLAT_STR
;;            XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;            ...
;;         ...
;;
;; A State may contain a "Set_Flag" table instead of translate tables.
;; These tables are used to set the NLS flags instead of generating
;; ASCII codes (for example: to remember dead key states).
;; There can be only on Set_Flag table per state.
;; The Set_Flag table layout is defined in the SET_FLAG_STR STRUC.
;;
;; So some states will contain translate tables (to generate ASCII codes)
;; and some states will contain a Set_Flag table (to record dead key
;; status).
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
XLAT_SECT_STR       STRUC               ;;
                                        ;;
XS_NEXT_SECT_PTR       DW    ?          ;; Pointer to next Specific Translate
                                        ;;  Section
XS_CP_ID               DW    ?          ;; code page id
XS_FIRST_STATE         DB    ?          ;;
                                        ;;
XLAT_SECT_STR       ENDS                ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State structure.
;; The last State is a null State containing only the
;; XS_STATE_LEN field with a value of 0.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
STATE_STR           STRUC               ;;
                                        ;;
XS_STATE_LEN     DW    ?                ;; length of state section
XS_STATE_ID      DB    ?                ;; State ID
XS_KBD_TYPE      DW    ?                ;; Keyboard Type
XS_ERROR_CHAR    DW    ?                ;; Buffer entry for error character
XS_FIRST_TAB     DB    ?                ;;
                                        ;;
STATE_STR           ENDS                ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table structures.
;; There may be many translate tables in a State.  The last
;; table is a null table containing only the XLAT_TAB_SIZE field with
;; a value of 0.
;; The xlate table can be in one of two forms:
;;    Type 1 = Table contains buffer entries only.
;;             Scan code is used as an index into xlat table
;;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;;             Table must be searched for matching scan.
;; Type 1 is the default.  Type 2 tables should be identified by setting
;; the TYPE_2_TAB bit in XLAT_OPTIONS.
;; Buffer entries default to 2-bytes per entry.
;; Optionally the table may contain ASCII codes only
;; (1-byte entries).  This is specified by setting the ASCII_ONLY bit
;; in XLAT_OPTIONS.  2-byte buffer entries are coded ASCII,SCAN.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
                                        ;; Translate options:
ASCII_ONLY          EQU   80H           ;; Only ASCII codes listed - use
                                        ;;  incoming scan for buffer entry
TYPE_2_TAB          EQU   40H           ;; search xlat table for matching scan
ZERO_SCAN           EQU   20H           ;; set the scan half of the buffer
                                        ;;  entry to 0
                                        ;;
NULL_ASCII_CODE     EQU   -1            ;;
                                        ;;
DEFAULT_TAB_2_ENT_SZ   EQU   3          ;;
ASC_ONLY_TAB_2_ENT_SZ  EQU   2          ;;
                                        ;;
                                        ;;
XLAT_STR            STRUC               ;;
                                        ;;
XLAT_TAB_SIZE       DW    ?             ;; Size in bytes of this table -
                                        ;;  includes this field, options etc.
XLAT_OPTIONS        DB    ?             ;; xlat options
                                        ;; XLAT TABLE IS HERE
XLAT_STR            ENDS                ;;
                                        ;;
XLAT_TYPE_1_STR     STRUC               ;; use scan code as index into table
                    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_SCAN_LO        DB    ?             ;; Scan code
XLAT_SCAN_HI        DB    ?             ;;  range
XLAT_1_BUF_ENTRY    DB    ?             ;; The table itself
XLAT_TYPE_1_STR     ENDS                ;;
                                        ;;
XLAT_TYPE_2_STR     STRUC               ;; search table for scan
                    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_NUM            DB    ?             ;; number of scans
XLAT_SCAN           DB    ?             ;; Scan code
XLAT_2_BUF_ENTRY    DB    ?             ;; The table itself
XLAT_TYPE_2_STR     ENDS                ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set_Flag Tables.
;; State Sections immediately following the LAST_ENTRYs.
;; Dead key definitions.  If the scan matches then
;; set the bit in NLS_FLAGs indicated in DK_MASK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
SF_ENT_SZ     EQU   3                   ;; size of entry
                                        ;;
SET_FLAG_STR        STRUC               ;;
                                        ;;
SF_NUM              DB    0             ;; Number of entries
SF_SCAN_CODE        DB    0             ;; scan code
SF_FLAG_ID          DB    0             ;; flag id
SF_FLAG_MASK        DB    0             ;; flag mask
                                        ;;
SET_FLAG_STR        ENDS                ;;
                                        ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybtbbl.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;;
;; File Name:  KEYBTBBL.INC
;; ----------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions Shared Data Area
;;	 for the Shared Data Area.
;;	 The Shared Data Area contains data which is required by
;;	 both the resident and transient KEYB code.  The Shared
;;	 Data Area is allocated in the KEYBI2F file and will be
;;	 resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					       ;;
	EXTRN	 TABLE_BUILD   :NEAR	       ;;
	EXTRN	 FIND_CP_TABLE :NEAR	       ;;
					       ;;
	EXTRN	 CPN_INVALID   :WORD	       ;;
	EXTRN	 SD_LENGTH     :WORD	       ;;
					       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybsys.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSYS.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions and equates
;;	 for the KEYBOARD.SYS file.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; File header - contains pointers to keyboard tables for each language
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_HEADER	STRUC		       ;;
				       ;;
KH_SIGNATURE	DB   0FFh,'KEYB   '    ;; signature
KH_RESV_1	DB   8 DUP(0)	       ;; reserved
KH_MAX_COM_SZ	DW   0	      ;AN000;**chg  ;; maximum size of Common Xlat Sect
KH_MAX_SPEC_SZ	DW   0	      ;AN000;;**chg   ;; max size of Specific Xlat Sect
KH_MAX_LOGIC_SZ DW   0	      ;AN000;;**chg   ;; max size of State Logic
KH_RESV_2	Dw   0	      ;AN000;;**chg   ;; reserved CNS
KH_NUM_ID	Dw   0		       ;AN000;;; ************* CNS
KH_NUM_LANG	DW   0		       ;; number of languages
KH_LANG_PTRS	DB   0		       ;; language pointers start here
;********************* CNS **********************
;KH_NUM_ID	  DW   0		 ;; number of languages
;KH_ID_PTRS	  DB   0		 ;; id pointers start here
;********************* CNS **********************
KEYBSYS_HEADER	ENDS		       ;;
;******************CNS*******************
KEYBSYS_ID_PTRS STRUC

KP_ID_CODE	DW   0		       ;AN000;
KP_LANG_PTR	DD   0		       ;AN000;

KEYBSYS_ID_PTRS ENDS
				       ;;
;*****************CNS********************
KEYBSYS_LANG_PTRS STRUC 	       ;;
				       ;; Next two entries repeat:
KP_LANG_CODE	DW   0		       ;;   language code
KP_ENTRY_PTR	DD   0		       ;;   language entry pointer
				       ;;
KEYBSYS_LANG_PTRS ENDS		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Language Entry - pointed to by KH_ENTRY_PTR in KEYBSYS_HEADER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_LANG_ENTRY  STRUC	       ;;
				       ;;
KL_LANG_CODE	DW   'XX'              ;; language code
KL_ID_CODE	DW   0		       ;; reserved (ID CODE)
KL_LOGIC_PTR	DD   0	       ;AC000;;**chg  ;; State Logic pointer
KL_NUM_ID	DB   0	       ;AN000;;CNS    ;; number of valid IDs for this lang
KL_NUM_CP	DB   0		       ;; number of valid CPs for this lang
KL_CP_PTRS	DB   0		       ;; CP table pointers start here
				       ;;
KEYBSYS_LANG_ENTRY  ENDS	       ;;
				       ;;
KEYBSYS_CP_PTRS     STRUC	       ;;
				       ;; Next two entries repeat:
KC_CODE_PAGE	DW   0		       ;;  code page
KC_ENTRY_PTR	DD   0		       ;; ptr to Specific Translate Section
				       ;;
KEYBSYS_CP_PTRS     ENDS	       ;;
				       ;;
				       ;;
;; Everything from here down is new
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic - pointed to by KL_LOGIC_PTR in KEYBSYS_LANG_ENTRY
;; Common Translate Section follows immediately after the State Logic.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_STATE_LOGIC STRUC	       ;;
				       ;;
KT_LOGIC_LEN	DW   ?		       ;; length of state logic
KT_SPECIAL_FEATURES  DW  ?	       ;; Special Features (see KEYBSHAR.INC)
KT_LOGIC_CMDS	DB   0		       ;; state logic commands begin here
				       ;;
KEYBSYS_STATE_LOGIC ENDS	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Section - Common and Specific Translate Sections
;; are both in this form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_XLAT_SECT   STRUC	       ;;
				       ;;
KX_SECTION_LEN	 DW    ?	       ;; Length of this section
KX_CP_ID	 DW    ?	       ;; code page id
KX_FIRST_STATE	 DB    ?	       ;;
				       ;;
KEYBSYS_XLAT_SECT   ENDS	       ;;
				       ;;
				       ;;
KEYBSYS_STATE	    STRUC	       ;;
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	     ;; Translate Sections contains multiple States.
	     ;; A State contains the translate tables for a single
	     ;; shift state (IE lower case, upper case ....)
	     ;; The last State is a null State containing only the
	     ;; KX_STATE_LEN field with a value of 0.
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
KX_STATE_LEN	 DW    ?	       ;; length of state section
KX_STATE_ID	 DB    ?	       ;; State ID
KX_KBD_TYPE	 DW    ?	       ;; Keyboard Type
KX_ERROR_CHAR	 DW    ?	       ;; Buffer entry for error character
KX_FIRST_XLAT	 DB    ?	       ;; XLAT tables begin here
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	     ;; Each State consists of multiple translate tables.
	     ;; The last translate table within a state is a null
	     ;; table containing only the
	     ;; KX_XLAT_LEN field with a value of 0.
	     ;; Refer to KEYBSHAR.INC for translate table format.
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_STATE	    ENDS	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\parser.asm ===
PAGE	,132
TITLE	PARSE CODE AND CONTROL BLOCKS FOR KEYB.COM

;****************** START OF SPECIFICATIONS **************************
;
;  MODULE NAME: PARSER.ASM
;
;  DESCRIPTIVE NAME: PARSES THE COMMAND LINE PARAMETERS FOR KEYB.COM
;
;  FUNCTION: THE COMMAND LINE IN THE PSP IS PARSED FOR PARAMETERS.
;
;  ENTRY POINT: PARSE_PARAMETERS
;
;  INPUT: BP POINTS TO PARAMETER LIST
;	  DS & ES POINT TO PSP
;
;  AT EXIT:
;     PARAMETER LIST FILLED IN AS REQUIRED.
;
;  INTERNAL REFERENCES:
;
;     ROUTINES: SYSPARSE - PARSING CODE
;
;     DATA AREAS: PARMS - PARSE CONTROL BLOCK FOR SYSPARSE
;
;  EXTERNAL REFERENCES:
;
;     ROUTINES: N/A
;
;     DATA AREAS: PARAMETER LIST BLOCK TO BE FILLED.
;
;  NOTES:
;
;  REVISION HISTORY:
;	 A000 - DOS Version 3.40
;  3/24/88 AN003 - P3906 PARSER changes to return "bogus" parameter on the
;	       "Parameter value not allowed " message - CNS
;  5/12/88 AN004 - P4867 /ID:NON-Numeric hangs the sytem as a 1st positional
;
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
;****************** END OF SPECIFICATIONS ****************************

INCLUDE KEYBDCL.INC

ID_VALID	EQU	0
ID_INVALID	EQU	1
NO_ID		EQU	2

LANGUAGE_VALID	EQU	0
LANGUAGE_INVALID EQU	1
NO_LANGUAGE	EQU	2

NO_IDLANG	EQU	3

CODE_PAGE_VALID EQU	0
CODE_PAGE_INVALID EQU	1
NO_CODE_PAGE	EQU	2
VALID_SYNTAX	EQU	0
INVALID_SYNTAX	EQU	1

COMMAND_LINE_START EQU	81H
RC_EOL		EQU	-1
RC_NO_ERROR	EQU	0
RC_OP_MISSING	EQU	2
RC_NOT_IN_SW	EQU	3

;***CNS P4867 1st CHECK for /ID:ALPHA

RC_SW_FIRST	EQU	9

;***CNS P4867 1st CHECK for /ID:ALPHA

ERROR_COND	EQU	-1
NUMBER		EQU	1
STRING		EQU	3
FILE_SPEC	EQU	5
MAX_ID		EQU	999
LANG_LENGTH	EQU	2

INVALID_SWITCH	EQU	3
TOO_MANY	EQU	1
INVALID_PARAM	EQU	10
VALUE_DISALLOW	EQU	8


	PUBLIC	PARSE_PARAMETERS ; near procedure for parsing command line
	PUBLIC	CUR_PTR 	; near procedure for parsing command line
	PUBLIC	OLD_PTR 	; near procedure for parsing command line
	PUBLIC	ERR_PART	; near procedure for parsing command line

	EXTRN	BAD_ID:BYTE	; WGR to match old code
	EXTRN	FOURTH_PARM:BYTE ; WGR to match old code
	EXTRN	ONE_PARMID:BYTE	; WGR to match old code
	EXTRN	FTH_PARMID:BYTE	; WGR to match old code
	EXTRN	ALPHA:BYTE	; WGR to match old code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Set assemble switches for parse code that is not required!!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DateSW		EQU	0
TimeSW		EQU	0
CmpxSW		EQU	0
DrvSW		EQU	0
QusSW		EQU	0
KeySW		EQU	0
Val1SW		EQU	0
Val2SW		EQU	0
Val3SW		EQU	0


CODE	SEGMENT PUBLIC 'CODE' BYTE
	ASSUME	CS:CODE,DS:CODE

	.XLIST
	INCLUDE	PARSE.ASM	; Parsing code
	.LIST


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PARM control blocks for KEYB
; Parsing command line as follows:
;
; KEYB [lang],[cp],[[d:][path]KEYBOARD.SYS][/ID:id][/e][/?]
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARMS	LABEL	WORD
	DW	PARMSX
	DB	0		; no extra delimeters or EOLs.

PARMSX	LABEL	BYTE
	DB	0,3		; min,max positional operands
	DW	LANG		; pointer to control block
	DW	CP		; pointer to control block
	DW	FILE_NAME	; pointer to control block
	DB	3		; 3 switches
	DW	ID_VALUE	; pointer to control block
	dw	help_value	; pointer to control block
	dw	ext_value	; pointer to control block
	DB	0		; no keywords

LANG	LABEL	WORD
	DW	0A001H		; sstring or numeric value (optional)
	DW	0002H		; cap result by char table (sstring)
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

CP	LABEL	WORD
	DW	8001H		; numeric
	DW	0		; no functions
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

FILE_NAME LABEL WORD
	DW	0201H		; file spec
	DW	0001H		; cap by file table
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

ID_VALUE LABEL	WORD
	DW	8010H		; numeric
	DW	0		; no functions
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	1		; 1 switch synonym
id_name:
	DB	"/ID",0 	; ID switch

help_value label	word
	dw	0		; no values
	dw	0		; no functions
	dw	RESULT_BUF	; result
	dw	novals		; no value checking done
	db	1		; 1 switch synonym
help_name:
	db	"/?",0		; /? switch

ext_value label	word
	dw	0		; no values
	dw	0		; no functions
	dw	result_buf	; result
	dw	novals		; no value checking done
	db	1		; 1 switch synonym
ext_name:
	db	"/E",0		; /e switch


NOVALS	LABEL	BYTE
	DB	0		; no value checking done

RESULT_BUF	LABEL BYTE
RESULT_TYPE	DB	0	; type returned (number, string, etc.)
		DB	?	; matched item tag (if applicable)
RESULT_SYN_PTR	DW	?	; synonym ptr (if applicable)
RESULT_VAL	DD	?	; value

LOOP_COUNT	DB	0	; keeps track of parameter position

;***CNS
CUR_PTR        DW	0	; keeps track of parameter position
OLD_PTR        DW	0	; keeps track of parameter position
ERR_PART       DW	0	; keeps track of parameter position
;***CNS
				;..and reports an error condition

	public	pswitches
pswitches	db	0	; bit 0, /?, bit 1 /e

TEMP_FILE_NAME DB	128 DUP(0) ; place for file name

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PARSE_PARAMETERS
;
; FUNCTION:
; THIS PROCEDURE PARSES THE COMMAND LINE PARAMETERS IN THE PSP FOR
; KEYB.COM. THE PARAMETER LIST BLOCK IS FILLED IN ACCORDINGLY.
;
; AT ENTRY: AS ABOVE.
;
; AT EXIT:
;    AS ABOVE.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARSE_PARAMETERS       PROC	NEAR

	XOR	AX,AX				; setup default parameters.
	MOV	[BP].RET_CODE_1,NO_IDLANG
	MOV	[BP].RET_CODE_2,NO_CODE_PAGE
	MOV	[BP].RET_CODE_3,VALID_SYNTAX
	MOV	[BP].RET_CODE_4,NO_ID
	MOV	[BP].PATH_LENGTH,AX
	LEA	DI,PARMS			; setup parse blocks
	MOV	SI,COMMAND_LINE_START

	call	save_curptr

	XOR	CX,CX
	XOR	DX,DX
	CALL	SYSPARSE

kbs_10:
	cmp	ax,RC_EOL		; while not end of line and...
	jnz	kbs_11
	jmp	kbs_12
kbs_11:
	cmp	LOOP_COUNT,ERROR_COND	; parameters valid, do...
	jnz	kbs_13
	jmp	kbs_12

kbs_13:
	cmp	ax,RC_NOT_IN_SW		; invalid switch?
	jz	kbs_08
	cmp	ax,RC_SW_FIRST
	jnz	kbs_09

kbs_08:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; set invalid syntax flag.
	MOV	LOOP_COUNT,ERROR_COND		; set error flag to exit parse.

;***CNS
	MOV	ERR_PART,INVALID_SWITCH
	call	save_curptr
;***CNS

	jmp	kbs_10

kbs_09:

	cmp	RESULT_SYN_PTR,offset id_name	; was /id:xxx switch found?
	jnz	not_id_switch


	MOV	AX,WORD PTR RESULT_VAL+2 ; is it valid?
	OR	AX,AX
	jnz	kbs_01

	mov	ax,word ptr RESULT_VAL
	cmp	ax,MAX_ID
	jna	kbs_02

kbs_01:

	MOV	[BP].RET_CODE_1,ID_INVALID	; no...invalid id.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error.
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	mov	bad_id,1

	MOV	[ERR_PART],VALUE_DISALLOW	; SET ERROR TYPE FOR DISPLAY
	call	save_curptr

	jmp	short kbs_03

kbs_02:
	MOV	[BP].RET_CODE_4,ID_VALID ; yes...set return code 4.
	MOV	[BP].ID_PARM,AX
	mov	fourth_parm,1
	mov	fth_parmid,1

	jmp	short kbs_03


not_id_switch:
	cmp	RESULT_SYN_PTR,offset help_name	; was /? switch found?
	jnz	not_help_switch

	or	pswitches,1			; set flag for /?
	jmp	short kbs_03

not_help_switch:
	cmp	RESULT_SYN_PTR,offset ext_name
	jnz	kbs_07

	or	pswitches,2			; set flag for /e
	jmp	short kbs_03


kbs_07:
	INC	LOOP_COUNT		; positional encountered...
	cmp	LOOP_COUNT,1		; check for language
	jnz	kbs_04

	CALL	PROCESS_1ST_PARM

	call	save_curptr

	jmp	short kbs_03

kbs_04:
	cmp	LOOP_COUNT,2		; check for code page
	jnz	kbs_05

	CALL	 PROCESS_2ND_PARM

	call	save_curptr

	jmp	short kbs_03

kbs_05:
	cmp	LOOP_COUNT,3		; check for file name
	jnz	kbs_06

	CALL	PROCESS_3RD_PARM

	call	save_curptr

	jmp	short kbs_03

;	all other cases

kbs_06:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; too many parms

	call	save_curptr

	MOV	ERR_PART,TOO_MANY
	MOV	LOOP_COUNT,ERROR_COND	; set error flag to exit parse.
kbs_03:
	MOV	RESULT_TYPE,0		; reset result block.
	CALL	SYSPARSE		; parse next parameter.

	jmp	kbs_10

kbs_12:
	cmp	[bp].RET_CODE_4,ID_VALID
	jnz	kbs_14				; ensure that if switch was
	cmp	[bp].RET_CODE_1,LANGUAGE_VALID	; used, it was valid keyword
	jz	kbs_14

	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	 ; code was used..

;***CNS
	call	save_curptr
	MOV	ERR_PART,VALUE_DISALLOW
;***CNS

kbs_14:
	RET

PARSE_PARAMETERS       ENDP

save_curptr	proc	near

	PUSH	AX			;Save environment
	MOV	AX,CUR_PTR		;Set advancing ptr to end of argument
	MOV	OLD_PTR,AX		;after saving the beginning the string
	MOV	CUR_PTR,SI
	POP	AX			;Restore the environment
	ret

save_curptr	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_1ST_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE FIRST POSITIONAL PARAMETER. THIS SHOULD
; BE THE LANGUAGE ID OR THE KEYBOARD ID.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR LANGUAGE ID.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_1ST_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR		; error on parse?
	jng	kbs_23

	MOV	[BP].RET_CODE_1,LANGUAGE_INVALID ; yes...set invalid language
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	 ; and syntax error..
	MOV	LOOP_COUNT,ERROR_COND		 ; set flag to exit parse.
	MOV	ERR_PART,AX

	jmp	kbs_18

kbs_23:
	cmp	RESULT_TYPE,NUMBER	; was this a number (id?)
	jnz	kbs_24

	MOV	AX,WORD PTR RESULT_VAL+2 ; yes...check to see if
	OR	AX,AX			; within range.
	jnz	kbs_19

	MOV	AX,WORD PTR RESULT_VAL
	cmp	ax,max_id
	jna	kbs_17

kbs_19:
	MOV	[BP].RET_CODE_1,ID_INVALID	; no...invalid id.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error.
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	mov	bad_id,1

	jmp	short kbs_18

kbs_17:
	MOV	[BP].RET_CODE_1,ID_VALID	; valid id...set
	MOV	[BP].RET_CODE_4,ID_VALID	; valid id...set
	MOV	[BP].ID_PARM,AX			; and value moved into block
	MOV	LOOP_COUNT,4			; there should be no more parms
	mov	one_parmid,1

	jmp	short kbs_18

kbs_24:
	cmp	RESULT_TYPE,STRING	; must be a string then???
	jnz	kbs_26

	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	DS
	LDS	SI,RESULT_VAL		; get ptr to string
	MOV	DI,BP
	ADD	DI,LANGUAGE_PARM	; point to block for copy.
	MOV	CX,LANG_LENGTH		; maximum length = 2
	LODSB				; load AL with 1st char..

kbs_16:
	jcxz	kbs_15			; do twice, unless only 1 char
	or	al,al
	jz	kbs_15

	STOSB				; store
	DEC	CX			; dec count
	LODSB				; load

	jmp	kbs_16

kbs_15:

	or	cx,cx			; if there was less than 2 or..
	jnz	kbs_20
	or	al,al			;  greater than 2 chars, then..
	jz	kbs_21

kbs_20:
	MOV	[BP].RET_CODE_1,LANGUAGE_INVALID ; invalid.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	ERR_PART,INVALID_PARAM
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse.

	jmp	short kbs_22

kbs_21:
	MOV	[BP].RET_CODE_1,LANGUAGE_VALID	; valid language has been copied
	MOV	ALPHA,1				; language found

kbs_22:
	POP	DS
	POP	CX
	POP	DI
	POP	SI
	jmp	short kbs_18

;	omitted parameter...

kbs_26:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; invalid since further parameters.
kbs_18:
	RET

PROCESS_1ST_PARM       ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_2ND_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE 2ND POSITIONAL PARAMETER. THIS SHOULD
; BE THE CODE PAGE, IF REQUESTED.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR CODE PAGE.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_2ND_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR			; if parse error
	jle	kbs_32

	MOV	[BP].RET_CODE_2,CODE_PAGE_INVALID ; mark invalid..
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	MOV	ERR_PART,AX

	jmp	short kbs_31

kbs_32:

	cmp	RESULT_TYPE,NUMBER		; was parameter specified?
	jnz	kbs_30

	MOV	AX,WORD PTR RESULT_VAL+2	; yes..if code page not..
	OR	AX,AX

	jnz	kbs_27

	MOV	AX,WORD PTR RESULT_VAL		; valid..then

	cmp	ax,MAX_ID
	jna	kbs_28

kbs_27:
	MOV	[BP].RET_CODE_2,CODE_PAGE_INVALID ; mark invalid..
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse

	jmp	short kbs_31

kbs_28:
	MOV	[BP].RET_CODE_2,CODE_PAGE_VALID	; else...valid code page
	MOV	[BP].CODE_PAGE_PARM,AX		; move into parm

	jmp	short kbs_31

kbs_30:
	MOV	[BP].RET_CODE_2,NO_CODE_PAGE	; mark as not specified.
kbs_31:
	RET

PROCESS_2ND_PARM      ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_3RD_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE 3RD POSITIONAL PARAMETER. THIS SHOULD
; BE THE KEYBOARD DEFINITION FILE PATH, IF SPECIFIED.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR FILE NAME.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_3RD_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR		; if parse error, then...
	jle	kbs_33

	MOV	[BP].RET_CODE_3,INVALID_SYNTAX ; syntax error.
	MOV	LOOP_COUNT,ERROR_COND	; set flag to exit parse
	MOV	ERR_PART,AX

	jmp	short kbs_34

kbs_33:

	cmp	RESULT_TYPE,FILE_SPEC
	jnz	kbs_34

	PUSH	DS
	PUSH	SI
	PUSH	DI
	PUSH	CX
	LDS	SI,RESULT_VAL		; load offset of file name
	LEA	DI,TEMP_FILE_NAME
	MOV	[BP].PATH_OFFSET,DI	; copy to parameter block
	XOR	CX,CX
	LODSB				; count the length of the path.

kbs_35:
	or	al,al
	jz	kbs_36

	STOSB
	LODSB
	INC	CX
	jmp	short kbs_35

kbs_36:
	MOV	[BP].PATH_LENGTH,CX	; copy to parameter block
	POP	CX
	POP	DI
	POP	SI
	POP	DS
kbs_34:
	RET

PROCESS_3RD_PARM ENDP

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\keybtbbl.asm ===
PAGE	,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBTBBL.ASM
; ----------
;
; Description:
; ------------
;	Build SHARED_DATA_AREA with parameters specified
;	in KEYBCMD.ASM
;
; Documentation Reference:
; ------------------------
;	None
;
; Procedures Contained in This File:
; ----------------------------------
;	TABLE_BUILD: Build the header sections of the SHARED_DATA_AREA
;	STATE_BUILD: Build the state sections in the table area
;	FIND_CP_TABLE: Given the language and code page parm, determine the
;		offset of the code page table in KEYBOARD.SYS
;
; Include Files Required:
; -----------------------
;	KEYBSHAR.INC
;	KEYBSYS.INC
;	KEYBDCL.INC
;	KEYBI2F.INC
;
; External Procedure References:
; ------------------------------
;	None
;
; Change History:
; ---------------
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC TABLE_BUILD
	PUBLIC FIND_CP_TABLE
	PUBLIC CPN_INVALID
	PUBLIC SD_LENGTH

CODE	SEGMENT PUBLIC 'CODE'

	INCLUDE KEYBEQU.INC
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBSYS.INC
	INCLUDE KEYBCMD.INC
	INCLUDE KEYBDCL.INC
	INCLUDE COMMSUBS.INC
	INCLUDE KEYBCPSD.INC

	ASSUME  cs:CODE,ds:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: TABLE_BUILD
;
; Description:
;	Create the table area within the shared data structure. Each
;	table is made up of a descriptor plus the state sections.
;	Translate tables are found in the Keyboard definition file and are
;	copied into the shared data area by means of the STATE_BUILD
;	routine.
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	bp - points at beginning of CMD_PARM_LIST
;
;	SHARED_DATA_STR must be allocated in memory
;
;	The following variables must also be passed from KEYB_COMMAND
;	 KEYBSYS_FILE_HANDLE is set to file handle after opening file
;	 CP_TAB_OFFSET is the offset of the CP table in the SHARED_DATA_AREA
;	 STATE_LOGIC_OFFSET is the offset of the state section in the SHARED_DATA_AREA
;	 SYS_CODE_PAGE is the binary representation of the system CP
;	 KEYBCMD_LANG_ENTRY_PTR is a pointer to the lang entry in KEY DEF file
;	 DESIG_CP_BUFFER is the buffer which holds a list of designated CPs
;	 DESIG_CP_OFFSET:WORD is the offset of that list
;	 NUM_DESIG_CP is the number of CPs designated
;	 FILE_BUFFER is the buffer to read in the KEY DEF file
;**********CNS ***************************************
;	 ID_PTR_SIZE is the size of the ID ptr structure
;**********CNS ***************************************
;	 LANG_PTR_SIZE is the size of the lang ptr structure
;	 CP_PTR_SIZE is the size of the CP ptr structure
;	 NUM_CP is the number of CPs in the KEYB DEF file for that lang
;	 SHARED_AREA_PTR segment and offset of the SHARED_DATA_AREA
;
;
; Output Registers:
;	cx - RETURN_CODE :=  0  - Table build successful
;			  1  - Table build unsuccessful - ERROR 1
;					(Invalid language parm)
;			  2  - Table build unsuccessful - ERROR 2
;					(Invalid Code Page parm)
;			  3  - Table build unsuccessful - ERROR 3
;					(Machine type unavaliable)
;			  4  - Table build unsuccessful - ERROR 4
;					(Bad or missing keyboard def file)
;			  5  - Table build unsuccessful - ERROR 5
;					(Memory overflow occurred)
; Logic:
;	Calculate Offset difference between TEMP and SHARED_DATA_AREAs
;	Get LANGUAGE_PARM and CODE_PAGE_PARM from parm list
;	Call FIND_CP_TABLE := Determine whether CP is valid for given language
;	IF CP is valid THEN
;	Store them in the SHARED_DATA_AREA
;	Prepare to read Keyboard definition file by LSEEKing to the top
;	READ the header
;	Store maximum table values for calculation of RES_END
;	Set di to point at TABLE_AREA within SHARED_DATA_AREA
;	FOR the state logic section of the specified language:
;		IF STATE_LOGIC_PTR is not -1 THEN
;		LSEEK to state logic section in keyboard definition file
;		READ the state logic section into the TABLE_AREA
;		Set the hot keyb scan codes
;		Set the LOGIC_PTR in the header
;	FOR the common translate section:
;		IF Length parameter is not 0 THEN
;		Build state
;		Set the COMMON_XLAT_PTR in the header
;	FOR the specific translate sections:
;	Establish addressibility to list of designated code pages
;	FOR each code page
;		IF CP_ENTRY_PTR is not -1 THEN
;		Determine offset of CP table in Keyb Def file
;		IF CP table not avaliable THEN
;			Set CPN_INVALID flag
;		ELSE
;			LSEEK to CPn state section in keyboard definition file
;			IF this is the invoked code page THEN
;			Set ACTIVE_XLAT_PTR in SHARED_DATA_AREA
;			Update RESIDENT_END ptr
;			Build state
;	Update RESIDENT_END ptr
;	End
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FB		EQU	FILE_BUFFER
KB_MASK		EQU	02H

FIRST_XLAT_TAB	DW	0
NEXT_SECT_PTR	DW	-1

MAX_COM_SIZE	DW	?
MAX_SPEC_SIZE	DW	?
MAX_LOGIC_SIZE	DW	?

RESIDENT_END_ACC DW	0
SA_HEADER_SIZE	DW	SIZE SHARED_DATA_STR;
PARM_LIST_OFFSET DW	?
;********************CNS*************************
TB_ID_PARM	DW	0
;********************CNS*************************
TB_LANGUAGE_PARM DW	0
TB_CODE_PAGE_PARM DW	0

CPN_INVALID	DW	0

KEYB_INSTALLED	DW	0
SD_AREA_DIFFERENCE DW	0
SD_LENGTH	DW	2000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TABLE_BUILD	  PROC NEAR

	mov	ax,OFFSET SD_SOURCE_PTR	; Setup the difference
	sub	ax,OFFSET SD_DesT_PTR	; value used to calculate
	mov	SD_AREA_DIFFERENCE,ax	; new ptr values for
					;  SHARED_DATA_AREA
	mov	ax,[bp].ID_PARM		; Get id parameter
	mov	TB_ID_PARM,ax
	mov	ax,[bp].LANGUAGE_PARM	; Get language parameter
	mov	TB_LANGUAGE_PARM,ax
	mov	bx,[bp].CODE_PAGE_PARM	; Get code page parameter
	mov	TB_CODE_PAGE_PARM,bx
					; Make sure code page is
	call	FIND_CP_TABLE		;   valid for the language
	jcxz	TB_CHECK_CONTINUE1	; IF code page is found
	jmp	TB_ERROR6		;  for language THEN

TB_CHECK_CONTINUE1:
	mov	bp,OFFSET SD_SOURCE_PTR	; Put language parm and
	mov	ax,TB_ID_PARM		;  id parm and..
	mov	es:[bp].INVOKED_KBD_ID,ax
	mov	bx,TB_CODE_PAGE_PARM
	mov	es:[bp].INVOKED_CP_TABLE,bx	; code page parm into the
	mov	ax,TB_LANGUAGE_PARM		;  SHARED_DATA_AREA
	mov	word ptr es:[bp].ACTIVE_LANGUAGE,ax

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	xor	dx,dx			; LSEEK file pointer
	xor	cx,cx			;  back to top of file
	mov	ax,4200h		; If no problem with
	int	21H			;  Keyboard Def file THEN
	jnc	TB_START
	jmp	TB_ERROR4

TB_START:				; Else
	xor	di,di			; Set number
	lea	cx,[di].KH_NUM_ID+2	; M006 -- read a few extra entries
	mov	dx,OFFSET FILE_BUFFER	; Move contents into file buffer
	mov	ah,3FH			;  READ
	push	cs
	pop	ds
	int	21H			;  File
	jnc	TB_CONTINUE1
	jmp	TB_ERROR4

TB_CONTINUE1:
	cmp	cx,ax
	je	TB_ERROR_CHECK1
ifndef JAPAN
	mov	cx,4
	jmp	TB_CPN_INVALID
else ; JAPAN
tb_err4_j:				; M006
	jmp	TB_ERROR4		; M002
endif ; JAPAN

TB_ERROR_CHECK1:
ifdef JAPAN
	cmp	FB.KH_NUM_ID,0		; M006 -- is it an old KEYBOARD.SYS?
	jz	tb_err4_j		; M006 --  bomb out if so
endif ; JAPAN
	mov	cx,FB.KH_MAX_COM_SZ	; Save values for RESIDENT_END
	mov	MAX_COM_SIZE,cx		;  calculation
	mov	cx,FB.KH_MAX_SPEC_SZ
	mov	MAX_SPEC_SIZE,cx
	mov	cx,FB.KH_MAX_LOGIC_SZ
	mov	MAX_LOGIC_SIZE,cx

	LEA	di,[bp].TABLE_AREA	; Point at beginning of table area
					;		di ---> TABLE_AREA
ifdef JAPAN
;	M002 -- begin added section
;
;	Before we go ANY further, let's see if we actually have room
;	   for our worst case memory allocation needs.  Notice that
;	   we're actually trusting the MAX fields from the KEYBOARD
;	   definition file.  If it lies to us and has fields bigger
;	   than these MAX values, we may crash over memory we don't
;	   own during initialization.

	mov	ax,NUM_DESIG_CP
	mul	MAX_SPEC_SIZE
	or	dx,dx			; error if overflowed 16 bits
	jnz	mem_alloc_err

	add	ax,SA_HEADER_SIZE
	jc	mem_alloc_err
	add	ax,MAX_LOGIC_SIZE
	jc	mem_alloc_err
	add	ax,MAX_COM_SIZE
	jc	mem_alloc_err

;	Note that ax could be used for the RESIDENT_END_ACC value,
;	  but since this check is being added late in the testing
;	  cycle, we'll leave that calculation alone.

	add	ax,di			; get the ending offset of temp buffer
	jc	mem_alloc_err

	add	ax,15
	jc	mem_alloc_err
	mov	cl,4			; convert to paragraph
	shr	ax,cl
	mov	cx,ax
	mov	ax,cs			; get our code segment
	add	ax,cx			; this is our ending segment
	cmp	ax,cs:[2]		; compare against psp:2
	jb	mem_alloc_ok
mem_alloc_err:
	jmp	TB_ERROR5
mem_alloc_ok:

;	M002 -- end added section
endif ; JAPAN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	** FOR STATE LOGIC SECTION FOR LANG **
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_STATE_BEGIN:
	mov	bx,KEYBSYS_FILE_HANDLE		; Get handle
	mov	cx,word ptr STATE_LOGIC_OFFSET+2
	mov	dx,word ptr STATE_LOGIC_OFFSET	; Get LSEEK file pointer

	cmp	dx,-1			; If no language table then
	jnz	TB_STATE_CONTINUE1	;  jump to code page begin
	jmp	TB_CP_BEGIN

TB_STATE_CONTINUE1:			; Else
	mov	ax,4200h		; LSEEK to begin of state logic sect
	int	21H			;	Keyboard Def file THEN
	jnc	TB_STATE_CONTINUE2
	jmp	TB_ERROR4

TB_STATE_CONTINUE2:
	mov	dx,ax
	mov	word ptr SB_STATE_OFFSET+2,cx	;  Save the offset of the
	mov	word ptr SB_STATE_OFFSET,dx	;	states in Keyb Def file

	sub	di,SD_AREA_DIFFERENCE	; Adjust for relocation
	mov	es:[bp].LOGIC_PTR,di	; Set because this is state
	add	di,SD_AREA_DIFFERENCE	; Adjust for relocation

	mov	cx,4			; Set number bytes to read length and
					;	special features
	mov	dx,OFFSET FILE_BUFFER	; Set the buffer address
	mov	ah,3FH			; Read from the Keyb Def file
	int	21H
	jnc	TB_STATE_CONTINUE3
	jmp	TB_ERROR4

TB_STATE_CONTINUE3:
	cmp	cx,ax
	je	TB_ERROR_CHECK2
ifndef JAPAN
	mov	cx,4
	jmp	TB_CPN_INVALID
else ; JAPAN
	jmp	TB_ERROR4
endif ; JAPAN

TB_ERROR_CHECK2:
	mov	ax,FB.KT_SPECIAL_FEATURES	; Save the special features in the
	mov	es:[bp].SPECIAL_FEATURES,ax	;	SHARED_DATA_AREA


	mov	es:[bp].HOT_KEY_ON_SCAN,F1_SCAN
	mov	es:[bp].HOT_KEY_OFF_SCAN,F2_SCAN

HOT_KEY_SET:
	mov	cx,FB.KT_LOGIC_LEN	; Set length of section to read
	or	cx,cx
	jnz	TB_STATE_CONTINUE4

	dec	cx			; cx = -1
	mov	es:[bp].LOGIC_PTR,cx
	jmp	short SB_COMM_BEGIN

TB_STATE_CONTINUE4:
	mov	es:[di],cx		; Store length parameter in
	add	di,2			;	  SHARED_DATA_AREA
	mov	cx,FB.KT_SPECIAL_FEATURES ; Save the special features
	mov	es:[di],cx
	add	di,2
	mov	cx,FB.KT_LOGIC_LEN	; Set length of section to read
	sub	cx,4			; Adjust for what we have already read
	mov	dx,di			; Set the address of SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH			; Read logic section from the
	int	21H			;	Keyb Def file
	push	cs
	pop	ds
	jnc	TB_STATE_CONTINUE5
	jmp	TB_ERROR4

TB_STATE_CONTINUE5:
	cmp	cx,ax
	je	TB_ERROR_CHECK3
ifndef JAPAN
	mov	cx,4
	jmp	TB_CPN_INVALID
else ; JAPAN
	jmp	TB_ERROR4
endif ; JAPAN

TB_ERROR_CHECK3:
	add	di,cx			; Set di at new beginning of area
					;		TABLE_AREA
					;		STATE_LOGIC
	mov	cx,RESIDENT_END_ACC	;	di --->
	add	cx,SA_HEADER_SIZE
	add	cx,MAX_LOGIC_SIZE
	mov	RESIDENT_END_ACC,cx	;  Refresh Resident end size

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	** FOR COMMON TRANSLATE SECTION FOR LANG **
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SB_COMM_BEGIN:
	mov	cx,SIZE KEYBSYS_XLAT_SECT-1 ; Set number bytes to read header
	mov	dx,di			; Set the SHARED_DATA_AREA address
	push	es
	pop	ds
	mov	ah,3FH			; Read from the Keyb Def file
	int	21H
	push	cs
	pop	ds
	jnc	TB_STATE_CONTINUE6
	jmp	TB_ERROR4

TB_STATE_CONTINUE6:
	mov	cx,es:[di].KX_SECTION_LEN; Set length of section to read
	jcxz	TB_CP_BEGIN

	mov	cx,word ptr SB_STATE_OFFSET	;  Save the offset of the
	add	cx,FB.KT_LOGIC_LEN
	mov	word ptr SB_STATE_OFFSET,cx	;  Save the offset of the
	sub	di,SD_AREA_DIFFERENCE		;   Adjust for relocation
	mov	es:[bp].COMMON_XLAT_PTR,di
	add	di,SD_AREA_DIFFERENCE		;   Adjust for relocation

	call	STATE_BUILD
					; di set at new beginning of area
					;		TABLE_AREA
					;		STATE_LOGIC
					;		COMMON_XLAT_SECTION
	mov	cx,RESIDENT_END_ACC
	add	cx,MAX_COM_SIZE
	mov	RESIDENT_END_ACC,cx	;  Refresh resident end size

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	FOR alL DESIGNATED OR INVOKED CODE PAGES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_CP_BEGIN:						; Get the offset to
	mov	cx,OFFSET DESIG_CP_BUFFER.DESIG_CP_ENTRY ; the beginning of the
	mov	DESIG_CP_OFFSET,cx			; table of designated
							; code pages
TB_CPN_BEGIN:
	mov	ax,word ptr es:[bp].ACTIVE_LANGUAGE  ; Get the active language
	mov	cx,NUM_DESIG_CP		; Get the number of CPs
	or	cx,cx			; IF we have done all requested CPs
	jnz	TB_CPN_VALID1
	jmp	TB_DONE			;	Then done

TB_CPN_VALID1:
	mov	si,[DESIG_CP_OFFSET]
	mov	bx,[si]			; Get the CP
	cmp	bx,-1
	jnz	TB_CPN_CONTINUE1
	jmp	short TB_CPN_REPEAT

TB_CPN_CONTINUE1:			; ELSE
	push	di
	call	FIND_CP_TABLE		;	Find offset of code page table
	pop	di

	jcxz	TB_CPN_VALID		;  brif valid code page for language
	mov	CPN_INVALID,cx		;	Set flag and go to next CP
	jmp	short TB_CPN_REPEAT	; Else

TB_CPN_VALID:
	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	cx,word ptr CP_TAB_OFFSET+2  ; Get offset of the code page
	mov	dx,word ptr CP_TAB_OFFSET ;	in the Keyb Def file

	cmp	dx,-1			; Test if code page is blank
	jnz	TB_CPN_CONTINUE2
	jmp	short TB_CPN_REPEAT	; If it is then go get next CP

TB_CPN_CONTINUE2:
	mov	ax,4200h		; LSEEK to table in Keyb Def file
	int	21H			;	Keyb Def file Then
	jnc	TB_CPN_CONTINUE3
	jmp	TB_ERROR4

TB_CPN_CONTINUE3:
	mov	dx,ax
	mov	word ptr SB_STATE_OFFSET+2,cx	;  Save the offset of the
	mov	word ptr SB_STATE_OFFSET,dx	;	states in Keyb Def file

	mov	cx,TB_CODE_PAGE_PARM	;  If this code page is the
	mov	si,[DESIG_CP_OFFSET]	;	invoked code page
	cmp	cx,[si]
	jnz	TB_CPN_CONTINUE4	;  Then

	sub	di,SD_AREA_DIFFERENCE	;  Adjust for relocation
	mov	es:[bp].ACTIVE_XLAT_PTR,di ;  Set active xlat section
	add	di,SD_AREA_DIFFERENCE	;  Adjust for relocation

TB_CPN_CONTINUE4:
	sub	di,SD_AREA_DIFFERENCE	;  Adjust for relocation
	mov	es:[bp].FIRST_XLAT_PTR,di ;	  Set flag
	add	di,SD_AREA_DIFFERENCE	;  Adjust for relocation

TB_CPN_CONTINUE5:
	CALL	STATE_BUILD		;  Build state
					;		TABLE_AREA
	jcxz	TB_CPN_REPEAT		;    COMMON_XLAT_SECTION,SPECIFIC...
	jmp	TB_ERROR4		;	di --->

TB_CPN_REPEAT:
	mov	cx,RESIDENT_END_ACC
	add	cx,MAX_SPEC_SIZE	;  Refresh resident end size
	mov	RESIDENT_END_ACC,cx

	mov	cx,DESIG_CP_OFFSET
	add	cx,2			; Adjust offset to find next code page
	mov	DESIG_CP_OFFSET,cx

	mov	cx,NUM_DESIG_CP		; Adjust the number of code pages left
	dec	cx
	mov	NUM_DESIG_CP,cx

	jmp	TB_CPN_BEGIN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_DONE:
	mov	cx,RESIDENT_END_ACC	;  Set final calculated value
	add	cx,bp
	sub	cx,SD_AREA_DIFFERENCE		;  Adjust for relocation
	mov	es,word ptr SHARED_AREA_PTR	;	Set segment
	mov	bp,word ptr SHARED_AREA_PTR+2
	cmp	cx,es:[bp].RESIDENT_END
	JNA	TB_DONE_CONTINUE1
	jmp	short TB_ERROR5

TB_DONE_CONTINUE1:
	cmp	es:[bp].RESIDENT_END,-1
	jnz	DONT_REPLACE
	push	cs
	pop	es
	mov	bp,OFFSET SD_SOURCE_PTR
	mov	es:[bp].RESIDENT_END,cx ;  Save resident end
	jmp	short CONTINUE_2_END

DONT_REPLACE:
	push	cs
	pop	es
	mov	bp,OFFSET SD_SOURCE_PTR

CONTINUE_2_END:
	sub	cx,OFFSET SD_DesT_PTR	;  Calculate # of bytes to copy
	mov	SD_LENGTH,cx

	xor	cx,cx			;  Set valid completion return code
	mov	TB_RETURN_CODE,cx
	ret

ifndef JAPAN
;	M002 -- dead code deleted.  The following label was only
;		branched to with cx==4.  Those calls were all
;		replaced with direct JMPs to TB_ERROR4, which was
;		assumed to set cx=4 in other places anyway.
TB_CPN_INVALID:
	cmp	cx,1			;  Set error 1 return code
	jnz	TB_ERROR2
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR2:
	cmp	cx,2			;  Set error 2 return code
	jnz	TB_ERROR3
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR3:
	cmp	cx,3			;  Set error 3 return code
	jnz	TB_ERROR4
	mov	TB_RETURN_CODE,cx
	ret
endif ; !JAPAN

TB_ERROR4:
ifndef JAPAN
	cmp	cx,4			;  Set error 4 return code
	jnz	TB_ERROR5
else ; JAPAN
	mov	cx,4		; M002	; set error 4 return code
endif ; JAPAN
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR5:
	mov	cx,5			;  Set error 5 return code
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR6:
	mov	bx,TB_CODE_PAGE_PARM
	mov	cx,6
	mov	TB_RETURN_CODE,cx	;  Set error 6 return code
	ret

TABLE_BUILD	  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: STATE_BUILD
;
; Description:
;	Create the state/xlat section within the specific translate section.
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	SB_STATE_OFFSET - offset to the beginning of the info in Keyb Def SYS
;	di - offset of the beginning of the area used to build states
;
;	KEYBSYS_FILE_HANDLE - handle of the KEYBOARD.SYS file
;
; Output Registers:
;	di  - offset of the end of the area used by STATE_BUILD
;
;	cx - Return Code := 0  -  State build successful
;			    4  -  State build unsuccessful
;				    (Bad or missing Keyboard Def file)
;
; Logic:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

END_OF_AREA_PTR	DW	0
SB_FIRST_STATE	DW	0
SB_STATE_LENGTH	DW	0
SB_STATE_OFFSET	DD	0
STATE_LENGTH	DW	0
RESTORE_BP	DW	?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

STATE_BUILD	  PROC NEAR

	mov	si,di			;  Get the tally pointer
	mov	END_OF_AREA_PTR,di	;  Save pointer

	mov	RESTORE_bp,bp		;  Save the base pointer

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	dx,word ptr SB_STATE_OFFSET	; LSEEK file pointer
	mov	cx,word ptr SB_STATE_OFFSET+2	;	back to top of XLAT table
	mov	ax,4200h		; If no problem with
	int	21H			;   Keyboard Def file THEN
	jnc	SB_FIRST_HEADER
	jmp	SB_ERROR4

SB_FIRST_HEADER:
	xor	bp,bp
	LEA	cx,[bp].KX_FIRST_STATE	; Set number of bytes to read header
	mov	dx,di
	push	es
	pop	ds
	mov	ah,3FH			; read in the header
	int	21H
	push	cs
	pop	ds
	jnc	SB_HEAD_CONTINUE1
	jmp	SB_ERROR4

SB_HEAD_CONTINUE1:
	mov	dx,NEXT_SECT_PTR
	cmp	dx,-1
	je	SB_HEAD_CONTINUE2
	sub	dx,SD_AREA_DIFFERENCE	;  Adjust for relocation

SB_HEAD_CONTINUE2:
	mov	es:[di].XS_NEXT_SECT_PTR,dx
	cmp	dx,-1
	je	SB_HEAD_CONTINUE3
	add	dx,SD_AREA_DIFFERENCE	;  Adjust for relocation

SB_HEAD_CONTINUE3:
	add	di,cx			; Update the di pointer

SB_NEXT_STATE:
	xor	bp,bp			;  Set number
	LEA	cx,[bp].KX_STATE_ID	;	bytes to read state length
	mov	dx,di			;  Read the header into the
	mov	bx,KEYBSYS_FILE_HANDLE	;	SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH
	int	21H

SB_CONTINUE1:
	push	cs			; Reset the data segment
	pop	ds
	mov	cx,es:[di].KX_STATE_LEN ; If the length of the state section
	mov	STATE_LENGTH,cx
	add	di,2			;  is zero then done
	jcxz	SB_DONE

	xor	bp,bp			;  Set number
	LEA	cx,[bp].KX_FIRST_XLAT-2 ;	bytes to read state length
	mov	dx,di			;  Read the header into the
	mov	bx,KEYBSYS_FILE_HANDLE	;	SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH
	int	21H

SB_CONTINUE1A:
	push	cs			; Reset the data segment
	pop	ds
	sub	di,2
	mov	ax,es:[di].XS_KBD_TYPE	; Get the keyboard type def
	test	ax,HW_TYPE		; Does it match our hardware?
	JNZ	SB_CONTINUE2
	mov	dx,es:[di].XS_STATE_LEN ; No, then
	LEA	cx,[bp].KX_FIRST_XLAT
	sub	dx,cx
	xor	cx,cx
	mov	ah,42H			;  LSEEK past this state
	mov	al,01H
	int	21H
	jmp	SB_NEXT_STATE

SB_CONTINUE2:				; Yes, then
	mov	ax,SIZE STATE_STR-1
	add	di,ax			; Set PTR and end of header

SB_XLAT_TAB_BEGIN:			; Begin getting xlat tables
	mov	bx,KEYBSYS_FILE_HANDLE
	LEA	dx,[bp].KX_FIRST_XLAT	; Adjust for what we have already read
	mov	cx,STATE_LENGTH
	sub	cx,dx
	mov	dx,di
	push	es
	pop	ds
	mov	ah,3FH			; Read in the xlat tables
	int	21H
	push	cs
	pop	ds
	jnc	SB_CONTINUE4
	jmp	short SB_ERROR4

SB_CONTINUE4:
	cmp	cx,ax
	je	SB_ERROR_CHECK1
	jmp	short SB_ERROR4

SB_ERROR_CHECK1:
	add	di,cx			; Update the end of area ptr

	mov	si,di
	jmp	SB_NEXT_STATE

SB_DONE:
	mov	ax,-1
	mov	si,END_OF_AREA_PTR
	mov	NEXT_SECT_PTR,si

	mov	bp,RESTORE_bp
	ret

SB_ERROR1:
	mov	cx,1
	ret

SB_ERROR2:
	mov	cx,2
	ret

SB_ERROR3:
	mov	cx,3
	ret

SB_ERROR4:
	mov	cx,4
	ret


STATE_BUILD	  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: FIND_CP_TABLE
;
; Description:
;	Determine the offset of the specified code page table in KEYBOARD.SYS
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	ax - ASCII representation of the language parm
;	bx - binary representation of the code page
;
;	KEYBSYS_FILE_HANDLE - handle of the KEYBOARD.SYS file
;
; Output Registers:
;	CP_TAB_OFFSET - offset of the CP table in KEYBOARD.SYS
;
;	cx - Return Code := 0  -  State build successful
;			    2  -  Invalid Code page for language
;			    4  -  Bad or missing Keyboard Def file
; Logic:
;
;	READ language table
;	IF error in reading file THEN
;	 Display ERROR message and EXIT
;	ELSE
;	 Use table to verify language parm
;	 Set pointer values
;	 IF code page was specified
;		READ language entry
;		IF error in reading file THEN
;		  Display ERROR message and EXIT
;		ELSE
;		  READ Code page table
;		  IF error in reading file THEN
;			Display ERROR message and EXIT
;		  ELSE
;			Use table to get the offset of the code page parm
;	ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_CP_PARM	  DW	?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_CP_TABLE	  PROC  NEAR


	mov	FIND_CP_PARM,bx	  ; Save Code page

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	dx,word ptr KEYBCMD_LANG_ENTRY_PTR ; LSEEK file pointer
	mov	cx,word ptr KEYBCMD_LANG_ENTRY_PTR+2 ;  to top of language entry
	mov	ax,4200h		; If no problem with
	int	21H			;   Keyb Def file Then
	jnc	FIND_BEGIN
	jmp	short FIND_CP_ERROR4

FIND_BEGIN:
	mov	di,ax
	mov	cx,SIZE KEYBSYS_LANG_ENTRY-1	; Set number
						;	bytes to read header
	mov	dx,OFFSET FILE_BUFFER
	mov	ah,3FH			; Read language entry in
	int	21H			;	KEYBOARD.SYS file
	jnc	FIND_VALID4		; If no error in opening file then
	jmp	short FIND_CP_ERROR4

FIND_VALID4:

;****************************** CNS ****************************************
	xor	ah,ah
	mov	al,FB.KL_NUM_CP
;****************************** CNS ****************************************

	mov	NUM_CP,ax		; Save the number of code pages
	MUL	CP_PTR_SIZE		; Determine # of bytes to read
	mov	dx,OFFSET FILE_BUFFER	; Establish beginning of buffer
	mov	cx,ax
	cmp	cx,FILE_BUFFER_SIZE	; Make sure buffer is not to small
	jbe	FIND_VALID5
	jmp	short FIND_CP_ERROR4

FIND_VALID5:
	mov	ah,3FH			; Read code page table from
	int	21H			;	KEYBOARD.SYS file
	jnc	FIND_VALID6		; If no error in opening file then
	jmp	short FIND_CP_ERROR4

FIND_VALID6:
	mov	cx,NUM_CP		;  Number of valid codes
	mov	di,OFFSET FILE_BUFFER	;  Point to correct word in table

F_SCAN_CP_TABLE:			; FOR code page parm
	mov	ax,FIND_CP_PARM		;	Get parameter
	cmp	[di].KC_CODE_PAGE,ax	;	Valid Code ??
	je	F_CODE_PAGE_FOUND	; If not found AND more entries THEN
	add	di,LANG_PTR_SIZE	;	Check next entry
	loop	F_SCAN_CP_TABLE		;    Decrement count & loop


	jmp	short FIND_CP_ERROR2	;  Display error message

F_CODE_PAGE_FOUND:
	mov	ax,word ptr [di].KC_ENTRY_PTR
	mov	word ptr CP_TAB_OFFSET,ax
	mov	ax,word ptr [di].KC_ENTRY_PTR+2
	mov	word ptr CP_TAB_OFFSET+2,ax

	xor	cx,cx
	ret

FIND_CP_ERROR1:
	mov	cx,1
	ret

FIND_CP_ERROR2:
	mov	cx,2
	ret

FIND_CP_ERROR3:
	mov	cx,3
	ret

FIND_CP_ERROR4:
	mov	cx,4
	ret

FIND_CP_TABLE	 ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE	ENDS
	END	TABLE_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\keyb\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\loadfix.asm ===
FindStruc	struc

	db	21 dup (?)		;reserved area
Attr	db	?			;attribute of file
Time	dw	?			;time of last write
Date	dw	?			;date of last write
Fsize	dd	?			;filesize
Fname	db	13 dup (?)		;filename

FindStruc	ends

CMDSIZE		equ	94h		;current resident size of
					;command.com is 94h paras

code	segment byte public 'CODE'
	assume	cs:code, ds:code, es:code

	org	100h
public	start
start:
	mov	sp,offset MyStack		;set ss:sp to our stack

	mov	ax,offset EndProg
	add	ax,15
	mov	cl,4
	shr	ax,cl			;para size of this program
	mov	bx,ax			;bx = this program's size
	mov	cx,es
	add	ax,cx			;ax = top of this program
	sub	ax,1000h - CMDSIZE		;are we below the first 64K?
	jae	no_mem			;no, dont reserve memory
	neg	ax			;additional memory to be reserved
	add	bx,ax
no_mem:					;bx = #paras needed
	mov	ah,4ah
	int	21h			;resize to desired size
;
;Prepare to execute the desired program
;
	call	Exec_prepare
	jnc	do_exec

	mov	al,1	   		;return error
	jmp	short exit
do_exec:
	cmp	helpflg,1
	je 	do_help
	mov	ah,4bh
	mov	dx,offset ExecPath
	mov	bx,offset ExecBlk
	int	21h			;do the Exec
	jc	exec_err		;error while executing
;
;No error on execution. Get the return code of the program we executed and
;return that as our return code.
;
	mov	ah,4dh
	int	21h			;al = return code now
exit:
	mov	ah,4ch
	int	21h			;terminate ourselves
exec_err:
	mov	dx,offset ErrMsg		;Error executing command.com
ifdef BILINGUAL
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset ErrMsg2
@@:
endif
	mov	al,1
	call	dispmsg
	jmp	short	exit
do_help:
	mov	dx,offset HelpMsg		;Display help for loadfix
ifdef BILINGUAL
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset HelpMsg2
@@:
endif
	call	dispmsg
	xor	al,al
	jmp	short exit

;***
;Dispmsg -- Displays messages that are terminated by '$'
;
;Input:	ds:dx = pointer to message
;
;Output: None
;
;Registers: ax
;***

dispmsg	proc	near

	mov	ah,9
	int	21h
	ret

dispmsg	endp

;***
;Exec_prepare -- Searches the environment for the COMSPEC and sets up the
;command line and FCBs for the Exec call
;
;Input:	None
;
;Output: Carry set => error. Error message is displayed here
;	Carry clear => all parameters set successfully
;
;Registers: ax, cx, dx, si, di
;***

Exec_prepare	proc	near

	push	ds
	push	es

	mov	si,81h			;ds:si points at our command line
	call	skip_white		;skip all leading whitespace

	cmp	byte ptr [si],0dh		;Did we hit a CR?
	je	no_parms		;yes, no parameters given
;
;Check if we have a /? here
;
	cmp	byte ptr [si],'/'
	jne	no_help
	cmp	byte ptr [si+1],'?'
	jne	no_help

	inc	helpflg   		;/? given -- print help
	jmp	short exefnd

no_help:
	mov	dx,si			;ds:dx now points at the program

	mov	si,offset CmdOpt
	mov	di,offset CmdParms
	inc	di
	mov	cl,CmdOptLen
	xor	ch,ch
	rep	movsb

	mov	si,dx
	xor	cx,cx
st_lp:
	lodsb
	stosb
	inc	cx
	cmp	al,0dh
	jne	st_lp

	dec	cx
	add	cl,CmdOptLen		;command line cannot be >128
	mov	CmdParms,cl

	mov	si,offset CmdParms

	mov	word ptr CmdPtr,si
	mov	word ptr CmdPtr+2,cs		;store command line pointer

	mov	word ptr Fcb1+2,cs
	mov	word ptr Fcb2+2,cs

	call	find_comspec
	jc	no_comspec

	mov	si,offset ExecPath
	xchg 	si,di
	push	ds
	push	es
	pop	ds
	pop	es
comspec_lp:
	lodsb
	stosb
	or	al,al
	jnz	comspec_lp

exefnd:
	clc
execp_ret:
	pop	es
	pop	ds
	ret
no_parms:
	mov	dx,offset NoParms
ifdef BILINGUAL
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset NoParms2
@@:
endif
	call	dispmsg
	stc
	jmp	short execp_ret
no_comspec:
	mov	dx,offset NoComspec
ifdef BILINGUAL
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset NoComspec2
@@:
endif
	call	dispmsg
	stc
	jmp	short execp_ret

Exec_prepare	endp

;***
;skip_white -- Skips all whitespace characters until it hits a non-whitespace
;
;Input: ds:si = string to be looked at
;
;Output: ds:si points at the first non-whitespace char in the string
;
;Registers: ax, si
;***

skip_white	proc	near
	
	lodsb
	cmp	al,20h			;Blank?
	je	skip_white		;yes, skip
	cmp	al,9			;Tab?
	je	skip_white		;yes, skip

	dec	si			;point at the first non-white

	ret

skip_white	endp

;***
;find_comspec -- searches in the environment for the COMSPEC variable
;
;Input: None
;
;Output: es:di points at the arguments of the COMSPEC= variable
;
;Registers: si
;***

find_comspec	proc	near

	mov	si,offset Comspec_Text

;
; input: ds:si points to a "=" terminated string
; output: es:di points to the arguments in the environment
;	  zero is set if name not found
;	  carry flag is set if name not valid format
;
	call	find				; find the name
	jc	done_findp			; carry means not found
	call	scasb1				; scan for = sign
done_findp:
	ret

find_comspec	endp

;***
;find -- scans the environment for the variable whose name is passed in
;
;Input: ds:si points at the environment variable to be scanned for
;
;Output: es:di points at the environment variable
;
;Registers: ax, di
;***

find	proc	near

	cld
	call	count0				; cx = length of name
	mov	es,es:[2ch]			; get environment segment
;
;Bugbug: What if the environment segment here is 0?
;
	xor	di,di

find1:
	push	cx
	push	si
	push	di

find11:
	lodsb
	inc	di
	cmp	al,es:[di-1]
	jnz	find12
	loop	find11

find12:
	pop	di
	pop	si
	pop	cx
	jz	end_find
	push	cx
	call	scasb2				; scan for a nul
	pop	cx
	cmp	byte ptr es:[di],0
	jnz	find1
	stc					; indicate not found
end_find:
	ret

find	endp

;***
;count0 -- returns length of string until the first '=' char
;
;Input: ds:si points at the string
;
;Output: cx = length until '='
;
;Registers: di
;***

count0	proc	near

	mov	di,si				;ds = es = cs

	push	di				; count number of chars until "="
	call	scasb1
	pop	cx
	sub	di,cx
	xchg	di,cx
	ret

count0	endp

;***
;scasb1 -- scans string for the first '='
;scasb2 -- scans string for the first null
;
;Input: es:di = string
;
;Output: es:di points after the desired char
;
;Registers: ax, cx
;***

scasb1	proc	near

	mov	al,'='                          ; scan for an =
	jmp	short scasbx
scasb2:
	xor	al,al				; scan for a nul
scasbx:
	mov	cx,100h
	repnz	scasb
	ret

scasb1	endp


ifdef BILINGUAL
IsDBCSCodePage	proc	near
	push	ax
	push	bx

	mov	ax,4f01h		; get code page
	xor	bx,bx
	int	2fh

ifdef JAPAN
	cmp	bx,932
endif
ifdef KOREA
	cmp	bx,949
endif
ifdef TAIWAN
	cmp	bx,950
endif
ifdef PRC
	cmp	bx,936
endif

	pop	bx
	pop	ax
	ret
IsDBCSCodePage	endp
endif


;**************************
;Data
;**************************

ExecBlk	label	word
	dw	0
CmdPtr	dd	?
Fcb1	dw	offset MyFcb1
	dw	?
Fcb2	dw	offset MyFcb2
	dw	?

	dw	128 dup (1)
MyStack	label	word

CmdOpt	db	'/C '
CmdOptLen 	db	$ - CmdOpt

CmdParms	db	128 dup (?)		;buffer to hold prog to be Exec'ed

ExecPath	db	67 dup (?)		;holds path to COMMAND.COM

ComSpec_Text	db	'COMSPEC=',0

MyFcb1	db	0
	db	11 dup (' ')

MyFcb2	db	0
	db	11 dup (' ')

Helpflg	db	0			;default is no help

include	loadmsg.msg

EndProg	label	byte

code	ends
	end	start



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\loadfix\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\memctrlc.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/*******************************************************************/
/*	MEMCTRLC.C																		*/
/*																						*/
/*		This module contains the Ctrl-C handler put in by Mem when 	*/
/*	it links in UMBs. On a Ctrl-C, UMBs are delinked if they were	*/
/* 	explicitly enabled by Mem. The old Ctrl-C handler is restored 	*/
/* 	and Mem then exits. If we dont do this, UMBs remain linked in	*/
/*	after a Ctrl-C and as a result lot of old programs dont run.	*/
/*																						*/
/*******************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <dos.h>

extern char LinkedIn;
extern void (interrupt far *OldCtrlc)();
#pragma warning(4:4762)

void interrupt cdecl far MemCtrlc (unsigned es, unsigned ds,
			unsigned di, unsigned si, unsigned bp, unsigned sp,
			unsigned bx, unsigned dx, unsigned cx, unsigned ax )
{
	union REGS inregs;

	((void)es), ((void)ds),	((void)si),	((void)bp), ((void)sp);
	((void)bx), ((void)dx), ((void)bx), ((void)dx), ((void)cx);
	((void)di), ((void)ax);

	if ( LinkedIn )	/* Did we link in UMBs */
	{
		inregs.x.ax = 0x5803;
		inregs.x.bx = 0;
		intdos( &inregs, &inregs );	/* Delink UMBs */
	}

	_dos_setvect( 0x23, OldCtrlc ); /* Restore previous ctrlc handler */

	exit(0);	/* Exit Mem */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\memex.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/* MEMEX.C - expanded and extended memory handling functions for MEM.C.
*/

#include "ctype.h"
#include "conio.h"			/* need for kbhit prototype */
#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "version.h"			/* MSKK02 07/18/89 */
#include "mem.h"
#include "xmm.h"
#include "versionc.h"


/**/

void DisplayEMSDetail()
  {

#define EMSGetHandleName 0x5300 	/* get handle name function */
#define EMSGetHandlePages 0x4c00	/* get handle name function */
#define EMSCODE_83	0x83		/* handle not found error */
#define EMSMaxHandles	256		/* max number handles */

  int	HandleIndex;			/* used to step through handles */
  char	HandleName[9];			/* save area for handle name */
  unsigned long int HandleMem;		/* memory associated w/handle */
  char	TitlesPrinted = FALSE;		/* flag for printing titles */

  HandleName[0] = NUL;			/* initialize the array 	*/

  Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

  segread(&SegRegs);

  SegRegs.es = SegRegs.ds;

  for (HandleIndex = 0; HandleIndex < EMSMaxHandles; HandleIndex++)
    {

    InRegs.x.ax = EMSGetHandleName;	/* get handle name */
    InRegs.x.dx = HandleIndex;		/* handle in question */
    InRegs.x.di = (unsigned int) HandleName;	/* point to handle name */
    int86x(EMS, &InRegs, &OutRegs, &SegRegs);

    HandleName[8] = NUL;		/* make sure terminated w/nul */

    if (OutRegs.h.ah != EMSCODE_83)
      {
      InRegs.x.ax = EMSGetHandlePages;	/* get pages assoc w/this handle */
      InRegs.x.dx = HandleIndex;
      int86x(EMS, &InRegs, &OutRegs, &SegRegs);
      HandleMem = OutRegs.x.bx;
      HandleMem *= (long) (16l*1024l);

      if (!TitlesPrinted)
	{
	Sub0_Message(Title3Msg,STDOUT,Utility_Msg_Class);
	Sub0_Message(Title4Msg,STDOUT,Utility_Msg_Class);
	TitlesPrinted = TRUE;
	}

      if (HandleName[0] == NUL) strcpy(HandleName,"        ");
      EMSPrint(HandleMsg,
	       STDOUT,
	       Utility_Msg_Class,
	       &HandleIndex,
	       HandleName,
	       &HandleMem);
      }

    }					/* end	 for (HandleIndex = 0; HandleIndex < EMSMaxHandles;HandleIndex++) */

  return;

  }					/* end of DisplayEMSDetail */



/**/

void DisplayExtendedSummary()
  {

  unsigned long int	  EXTMemoryTot;
  unsigned long int	  XMSMemoryTot;
  unsigned long int	  HMA_In_Use;
  unsigned		  DOS_Is_High,DOS_in_ROM;

  InRegs.h.ah = (unsigned char) 0x52;                                           /* Get SysVar Pointer   ;an001; dms;*/
  intdosx(&InRegs,&OutRegs,&SegRegs);                                           /* Invoke interrupt     ;an001; dms;*/

  FP_SEG(SysVarsPtr) = SegRegs.es;                                              /* put pointer in var   ;an001; dms;*/
  FP_OFF(SysVarsPtr) = OutRegs.x.bx;                                            /*                      ;an001; dms;*/
  if ((SysVarsPtr) -> ExtendedMemory != 0)                                      /* extended memory?     ;an001; dms;*/
  {                                                                             /* yes                  ;an001; dms;*/
      EXTMemoryTot = (long) (SysVarsPtr) -> ExtendedMemory;                     /* get total EM size    ;an001; dms;*/
      EXTMemoryTot *= (long) 1024l;                                             /*  at boot time        ;an001; dms;*/
      Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);                        /* print blank line     ;an001; dms;*/
      Sub1_Message(EXTMemoryMsg,STDOUT,Utility_Msg_Class,&EXTMemoryTot);        /* print total EM mem   ;an001; dms;*/

      OutRegs.x.cflag = 0;                                                      /* clear carry flag     ;an001; dms;*/
      InRegs.x.ax = GetExtended;                                                /* get extended mem     ;an001; dms;*/
                                                                                /*   available                      */
      int86(CASSETTE, &InRegs, &OutRegs);                                       /* INT 15h call         ;an001; dms;*/

      EXTMemoryTot = (unsigned long) OutRegs.x.ax * 1024l;				 /* returns 1K mem blocks;an001; dms;*/

      /* subtract out VDisk usage.  Note assumption that VDisk usage doesn't
      *  exceed 64Mb.  Don't bother if there is no extended memory
      */
      if (EXTMemoryTot != 0)
	      EXTMemoryTot -= (unsigned long) (CheckVDisk() * 1024l);

      Sub1_Message(EXTMemAvlMsg,STDOUT,Utility_Msg_Class,&EXTMemoryTot);	/* display available	;an001; dms;*/

      /* if an XMS driver is present, INT 15 may return 0 as the amount
      *  of extended memory available.	In that case, call the XMS
      *  driver to find out the amount of XMS free.  Don't call XMS
      *  unconditionally, because that will cause it to claim memory
      *  if it has not already done so.
      *
      *  However, it is possible, with the newer versions of Himem,
      *  for XMS memory and INT 15 memory to coexist.  There is no
      *  completely reliable way to detect this situation, but we
      *  do know that if Himem is installed, DOS is high, and INT 15
      *  memory exists, then we are configured that way.  In that case,
      *  we can make calls to Himem without disrupting the memory environment.
      *  Otherwise we can't.
      */
      if (XMM_Installed())
      {

	  InRegs.x.ax = 0x3306;		/* get DOS version info */
	  intdos(&InRegs, &OutRegs);	/* call DOS */
	  DOS_Is_High = (OutRegs.h.dh & DOSHMA);	
	  DOS_in_ROM = (OutRegs.h.dh & DOSROM);

	  if (DOS_Is_High || EXTMemoryTot == 0)
	  {	  /* make this check only if we won't disrupt environment */
		  /* get and display XMS memory available */
		  XMSMemoryTot = XMM_QueryTotalFree() * 1024l;
		  Sub1_Message(XMSMemAvlMsg,STDOUT,Utility_Msg_Class,
			       &XMSMemoryTot);
	  }

	  /* get and display HMA status */
	  /* DOS High implies HMA is in use */
	  if (DOS_Is_High) 
		if (DOS_in_ROM)
			Sub0_Message(ROMDOSMsg,STDOUT,Utility_Msg_Class);
		else
			Sub0_Message(HMADOSMsg,STDOUT,Utility_Msg_Class);

	  /* DOS isn't, check if HMA in use, but only if we can quietly */
	  else if (EXTMemoryTot == 0)
	  {
		  HMA_In_Use = XMM_RequestHMA(0xffff);
		  if (HMA_In_Use)
			Sub0_Message(HMANotAvlMsg,STDOUT,Utility_Msg_Class);
		  else
		  {
			XMM_ReleaseHMA();
			Sub0_Message(HMAAvlMsg,STDOUT,Utility_Msg_Class);
		  }
	   }
      }
  }
}				      /* end of DisplayExtendedSummary */





/**/

void DisplayEMSSummary()
  {

  unsigned long int	  EMSFreeMemoryTot;
  unsigned long int	  EMSAvailMemoryTot;

  Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

  InRegs.x.ax = EMSGetFreePgs;		    /* get total number unallocated pages */
  int86x(EMS, &InRegs, &OutRegs, &SegRegs);

  EMSFreeMemoryTot = OutRegs.x.bx;	    /* total unallocated pages in  BX */
  EMSFreeMemoryTot *= (long) (16l*1024l);

  EMSAvailMemoryTot = OutRegs.x.dx;	    /* total pages */
  EMSAvailMemoryTot *= (long) (16l*1024l);

  Sub1_Message(EMSTotalMemoryMsg,STDOUT,Utility_Msg_Class,&EMSAvailMemoryTot);
  Sub1_Message(EMSFreeMemoryMsg,STDOUT,Utility_Msg_Class,&EMSFreeMemoryTot);

  return;

  }					/* end of DisplayEMSSummary */





/**/


char EMSInstalled()
  {

  unsigned int	EMSStatus;
  unsigned int	EMSVersion;

  char		EmsName[8];
  void far	*EmsNameP;


  if (EMSInstalledFlag == 2)
    {
    EMSInstalledFlag = FALSE;
    InRegs.h.ah = GET_VECT;		  /* get int 67 vector */
    InRegs.h.al = EMS;
    intdosx(&InRegs,&OutRegs,&SegRegs);


    /* only want to try this if vector is non-zero */


    if ((SegRegs.es != 0) && (OutRegs.x.bx != 0))
      {

      EmsNameP = EmsName;
      movedata(SegRegs.es, 0x000a, FP_SEG(EmsNameP), FP_OFF(EmsNameP), 8);
      if (strncmp(EmsName, "EMMXXXX0", 8))
	return (EMSInstalledFlag);

      InRegs.x.ax = EMSGetStat; 	  /* get EMS status */
      int86x(EMS, &InRegs, &OutRegs, &SegRegs);
      EMSStatus = OutRegs.h.ah; 	  /* EMS status returned in AH */

      InRegs.x.ax = EMSGetVer;		  /* get EMS version */
      int86x(EMS, &InRegs, &OutRegs, &SegRegs);
      EMSVersion = OutRegs.h.al;	  /* EMS version returned in AL */

      if ((EMSStatus == 0) && (EMSVersion >= DOSEMSVER))
	EMSInstalledFlag = TRUE;
      } 				  /* end ((SegRegs.es != 0) && (OutRegs.x.bx != 0)) */

    }					/* end if (EMSInstalledFlag == 2) */


  return(EMSInstalledFlag);


  }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\mem.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
  /* MEM.H - general equates and externals for the MEM command.
  *  Extracted from the original MEM.C file.
  */

/* Structure definitions */

struct	DEVICEHEADER {
	struct DEVICEHEADER far *NextDeviceHeader;
	unsigned		Attributes;
	unsigned		Strategy;
	unsigned		Interrupt;
	char			Name[8];
	};


struct	SYSIVAR {
	char far *DpbChain;
	char far *SftChain;
	char far *Clock;
	char far *Con;
	unsigned  MaxSectorSize;
	char far *BufferChain;
	char far *CdsList;
	char far *FcbChain;
	unsigned  FcbKeepCount;
	unsigned char BlockDeviceCount;
	char	  CdsCount;
	struct DEVICEHEADER far *DeviceDriverChain;
	unsigned  NullDeviceAttributes;
	unsigned  NullDeviceStrategyEntryPoint;
	unsigned  NullDeviceInterruptEntryPoint;
	char	  NullDeviceName[8];
	char	  SpliceIndicator;
	unsigned  DosParagraphs;
	char far *DosServiceRntryPoint;
	char far *IfsChain;
	unsigned  BufferValues;
	unsigned  LastDriveValue;
	char	  BootDrive;
	char	  MoveType;
	unsigned  ExtendedMemory;
	};


struct	ARENA	 {
	char	 Signature;
	unsigned Owner;
	unsigned Paragraphs;
	char	 Dummy[3];
	char	 OwnerName[8];
	};

struct sublistx {
	 unsigned char size;	       /* sublist size			       */
	 unsigned char reserved;       /* reserved for future growth	       */
	 unsigned far *value;	       /* pointer to replaceable parm	       */
	 unsigned char id;	       /* type of replaceable parm	       */
	 unsigned char flags;	       /* how parm is to be displayed	       */
	 unsigned char max_width;      /* max width of replaceable field       */
	 unsigned char min_width;      /* min width of replaceable field       */
	 unsigned char pad_char;       /* pad character for replaceable field  */
	};

struct mem_classif {			/* M003 - struct for storing sizes */
	unsigned int psp_add;		/* 	acc. to PSPs 		  */
	unsigned int mem_conv;		/* conv.mem for PSP */
	unsigned int mem_umb;		/* umb mem for PSP */
};

/* miscellaneous defines */

#define DA_TYPE 	0x8000;
#define DA_IOCTL	0x4000;

#define a(fp)	((char) fp)

/* relevant DOS functions */

#define GET_VECT	0x35
#define GET_UMB_LINK_STATE 0x5802
#define SET_UMB_LINK_STATE 0x5803
#define LINK_UMBS	1
#define UNLINK_UMBS	0

#define EMS		0x67

#define CASSETTE	0x15		/* interrupt to get extended memory */

#define DOSEMSVER	0x40		/* EMS version */

#define EMSGetStat	0x4000		/* get stat */
#define EMSGetVer	0x4600		/* get version */
#define EMSGetFreePgs	0x4200		/* get free pages */

#define GetExtended	0x8800		/* get extended memory size */


/* defines used by total memory determination */
#define GET_PSP 	(unsigned char ) 0x62		 /* get PSP function call */

#define MEMORY_DET	0x12		/* BIOS interrupt used to get total memory size */

#define FALSE	 (char)(1==0)
#define TRUE	 !(FALSE)
#define CR	 '\x0d'
#define LF	 '\x0a'
#define NUL	 (char) '\0'
#define TAB	 '\x09'
#define BLANK	' '

#define	MAX_CLDATA_INDEX	100
	/* max index no for mem_table array */
	/* this is the max no of progs or free arenas that mem/c  can used */
	/* to process ; if the memory is fragmented and too many progs are */
	/* loaded such that this no exceeds 100, we terminate with errmsg */

/* external variables */

extern	      unsigned DOS_TopOfMemory; 	/* PSP Top of memory from 'C' init code  */					       /* ;an005; */
extern	      unsigned far	   *ArenaHeadPtr;
extern	      struct   SYSIVAR far *SysVarsPtr;

extern	      unsigned UMB_Head;
extern	      unsigned LastPSP;

extern	      char    OwnerName[128];
extern	      char    TypeText[128];
extern	      char    cmd_line[128];
extern	      char    far *cmdline;

extern	      char    UseArgvZero;
extern	      char    EMSInstalledFlag;

extern	      union    REGS    InRegs;
extern	      union    REGS    OutRegs;
extern	      struct   SREGS   SegRegs;

extern	      int      DataLevel;
extern	      int      Classify;
extern	      int      i;

extern	      int      BlockDeviceNumber;
extern	      char     *Parse_Ptr;						      /* ;an003; dms; pointer to command      */
extern	      struct mem_classif mem_table[MAX_CLDATA_INDEX];
extern		  int	   noof_progs;

extern	      struct sublistx sublist[5];

extern	      char    *SingleDrive;
extern	      char    *MultipleDrives;
extern	      char    *UnOwned;
extern	      char    *Ibmbio;
extern	      char    *Ibmdos;


/* function prototypes */

int	 main(void);
int      printf();
int      sprintf();
int      strcmp(const char *, const char *);
int	 sscanf();
void	 exit(int);
int	 kbhit();
char	 *OwnerOf(struct ARENA far *);
char	 *TypeOf(struct ARENA far *);
unsigned long AddressOf(char far *);
void	CSwitch_init(void);

char	 EMSInstalled(void);
void	 DisplayEMSSummary(void);
void	 DisplayEMSDetail(void);

void	 DisplayBaseSummary(void);
void	 DisplayExtendedSummary(void);
unsigned CheckDOSHigh(void);
unsigned CheckVDisk(void);

unsigned int DisplayBaseDetail(void);

void	DisplayClassification(void);		/* M003 */
unsigned long 	DispMemClass(int);		/* M003 */
void	DispBigFree(char,unsigned int);		/* M003 */

unsigned int AddMem_to_PSP(unsigned int,unsigned long,unsigned long);  /* M003 */

void	 GetFromArgvZero(unsigned,unsigned far *);

void	 DisplayDeviceDriver(struct   DEVICEHEADER far *,int);

void	 parse_init(void);

void	 Parse_Message(int,int,unsigned char,char far *);
void	 Sub0_Message(int,int,unsigned char);
void	 Sub1_Message(int,int,unsigned char,unsigned long int *);
void	 Sub2_Message(int,int,unsigned char,char *,int);
void	 Sub3_Message(int,int,unsigned char,
		      char *,
		      unsigned long int *,
		      int);

void	 Sub4_Message(int,int,unsigned char,
		      unsigned long int *,
		      int,
		      unsigned long int *,
		      int);

void	 Sub4a_Message(int,int,unsigned char,
		      unsigned long int *,
		      char *,
		      unsigned long int *,
		      char *);

void	EMSPrint(int,int,unsigned char,
		 int *,
		 char *,
		 unsigned long int *);

void SubC2_Message(int,int,unsigned long int*,char*);	/* M003 */

void	 SubC4_Message(int,int,char *,int,	/* M003 */
		      unsigned long int *,
		      char *);

extern void sysloadmsg(union REGS *, union REGS *);
extern void sysdispmsg(union REGS *, union REGS *);
extern void sysgetmsg(union REGS *, struct SREGS *, union REGS *);
extern void parse(union REGS *, union REGS *);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\mem.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */

/*----------------------------------------------------------------------+
|                                                                       |
|                                                                       |
|       Title:          MEM                                             |
|                                                                       |
|       Syntax:                                                         |
|                                                                       |
|               From the DOS command line:                              |
|                                                                       |
|               MEM                                                     |
|                       - Used to display DOS memory map summary.       |
|                                                                       |
|               MEM /PROGRAM                                            |
|                       - Used to display DOS memory map.               |
|                                                                       |
|               MEM /DEBUG                                              |
|                       - Used to display a detailed DOS memory map.    |
|                                                                       |
|       AN001 - PTM P2914 -> This PTM relates to MEM's ability to report|
|                            the accurate total byte count for EM       |
|                            memory.                                    |
|                                                                       |
|       AN002 - PTM P3477 -> MEM was displaying erroneous base memory   |
|                            information for "Total" and "Available"    |
|                            memory.  This was due to incorrect logic   |
|                            for RAM carving.                           |
|                                                                       |
|       AN003 - PTM P3912 -> MEM messages do not conform to spec.       |
|               PTM P3989                                               |
|                                                                       |
|               Date: 1/28/88                                           |
|                                                                       |
|       AN004 - PTM P4510 -> MEM does not give correct DOS size.        |
|                                                                       |
|               Date: 4/27/88                                           |
|                                                                       |
|       AN005 - PTM P4957 -> MEM does not give correct DOS size for     |
|                            programs loaded into high memory.          |
|                                                                       |
|               Date: 6/07/88                                           |
|									|
|	Revision History						|	
|	================						|
|									|
|	M000	SR	8/27/90	Added new Ctrl-C handler to delink UMBs |
|									|
|	M003	NSM	12/28/90 Added a New switch /Classify which     |
|			groups programs in conv and UMB and gives sizes |
|			in decimal and hex.				|
|                                                                       |
+----------------------------------------------------------------------*/

/**/

#include "ctype.h"
#include "conio.h"			/* need for kbhit prototype */
#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "parse.h"
#include "version.h"			/* MSKK02 07/18/89 */
#include "mem.h"

/**/

/* All global declarations go here */

	char	*SingleDrive = "%c:" ;
	char	*MultipleDrives = "%c: - %c:" ;
	char	*UnOwned = "----------" ;
#if IBMCOPYRIGHT                                                        /*EGH*/
        char    *Ibmbio = "IBMBIO" ;                                    /*EGH*/
        char    *Ibmdos = "IBMDOS" ;                                    /*EGH*/
#else                                                                   /*EGH*/
        char    *Ibmbio = "IO    " ;
        char    *Ibmdos = "MSDOS " ;
#endif                                                                  /*EGH*/
	char  LinkedIn = 0;	/* Flag set when mem links in UMBs :M000 */
	void (interrupt far *OldCtrlc)(); /* Old Ctrlc handler save vector :M000*/

/*----------------------------------------------------------------------+
|       define structure used by parser                                 |
+----------------------------------------------------------------------*/

struct p_parms	p_p;

struct p_parmsx p_px;

struct p_control_blk p_con1;
struct p_control_blk p_con2;
struct p_control_blk p_con3;
struct p_control_blk p_con4;

struct p_result_blk  p_result1;
struct p_result_blk  p_result2;
struct p_result_blk  p_result3;
struct p_result_blk  p_result4;

struct p_value_blk p_noval;


/**/

	struct sublistx sublist[5];

	unsigned far	     *ArenaHeadPtr;
	struct	 SYSIVAR far *SysVarsPtr;

	char	OwnerName[128];
	char	TypeText[128];
	char	cmd_line[128];
	char	far *cmdline;

	unsigned UMB_Head;
	unsigned LastPSP=0;

	char	UseArgvZero = TRUE;
	char	EMSInstalledFlag = (char) 2;

	union	 REGS	 InRegs;
	union	 REGS	 OutRegs;
	struct	 SREGS	 SegRegs;

	int	 DataLevel;
	int	 Classify;		/* M003 */
	int	 i;

	int	 BlockDeviceNumber;
        char	*Parse_Ptr;                                                     /* ;an003; dms; pointer to command      */

	struct mem_classif mem_table[100];	/* M003 */
	int	noof_progs = 0;		/* no of entries in mem_table above */

/**/

void interrupt cdecl far MemCtrlc (unsigned es, unsigned ds,
			unsigned di, unsigned si, unsigned bp, unsigned sp,
			unsigned bx, unsigned dx, unsigned cx, unsigned ax );


int	 main()
{
	unsigned char	UMB_Linkage;
	unsigned int rc=0;		/* init to NO ERROR */


	sysloadmsg(&InRegs,&OutRegs);
	if ((OutRegs.x.cflag & CarryFlag) == CarryFlag)
		{
		sysdispmsg(&OutRegs,&OutRegs);
		exit(1);
		}


	InRegs.h.ah = (unsigned char) 0x62;					/* an000; dms; get the PSP		*/
	intdosx(&InRegs, &InRegs, &SegRegs);					/* an000; dms; invoke the INT 21	*/

	FP_OFF(cmdline) = 0x81; 						/* an000; dms; offset of command line	*/
	FP_SEG(cmdline) = InRegs.x.bx;						/* an000; dms; segment of command line	*/

	i = 0;									/* an000; dms; init index		*/
	while ( *cmdline != (char) '\x0d' ) cmd_line[i++] = *cmdline++; 	/* an000; dms; while no CR		*/
	cmd_line[i++] = (char) '\x0d';						/* an000; dms; CR terminate string	*/
	cmd_line[i++] = (char) '\0';						/* an000; dms; null terminate string	*/

	DataLevel = Classify = 0;	/* M003 */
	CSwitch_init();			/* M003: init data structures for */
					/*       Classify */
	parse_init();								/* an000; dms; init for parser		*/
	InRegs.x.si = (unsigned)cmd_line;					/* an000; dms; initialize to command ln.*/
	InRegs.x.cx = (unsigned)0;						/* an000; dms; ordinal of 0		*/
	InRegs.x.dx = (unsigned)0;						/* an000; dms; init pointer		*/
	InRegs.x.di = (unsigned)&p_p;						/* an000; dms; point to ctrl blocks	*/
        Parse_Ptr   = cmd_line;                                       /*;an003; dms; point to command         */

	parse(&InRegs,&OutRegs);						/* an000; dms; parse command line	*/
	while (OutRegs.x.ax == p_no_error)					/* an000; dms; good parse loop		*/
		{
		if (p_result4.P_SYNONYM_Ptr == (unsigned int)p_con4.p_keyorsw)
		{
			for (i = MSG_OPTIONS_FIRST; i <= MSG_OPTIONS_LAST; i++)
				Sub0_Message(i, STDOUT, Utility_Msg_Class);
			return(0);
 		}
		if (p_result1.P_SYNONYM_Ptr == (unsigned int)p_con1.p_keyorsw ||   /* DEBUG switch	       */
		    p_result1.P_SYNONYM_Ptr == (unsigned int)p_con1.p_keyorsw +
						(strlen(p_con1.p_keyorsw)+1))
			DataLevel = 2;						   /* flag DEBUG switch        */

		if (p_result2.P_SYNONYM_Ptr == (unsigned int)p_con2.p_keyorsw ||   /* PROGRAM switch	       */
		    p_result2.P_SYNONYM_Ptr == (unsigned int)p_con2.p_keyorsw +
						(strlen(p_con2.p_keyorsw)+1))
			DataLevel = 1;	    /* flag PROGRAM switch	*/

/* M003 BEGIN - parsing for switch /C */
		if (p_result3.P_SYNONYM_Ptr == (unsigned int)p_con3.p_keyorsw ||   /* Classify switch	       */
		    p_result3.P_SYNONYM_Ptr == (unsigned int)p_con3.p_keyorsw +
						(strlen(p_con3.p_keyorsw)+1))
	 	{
			DataLevel = 1;	/* treat this similar to /P switch */
			Classify = 1;
		}
/* M003 END */

		Parse_Ptr = (char *) (OutRegs.x.si);					    /* point to next parm	*/
		parse(&OutRegs,&OutRegs);					    /* parse the line		*/
		if (OutRegs.x.ax == p_no_error) 				    /* check for > 1 switch	*/
			OutRegs.x.ax = p_too_many;				    /* flag too many		*/
		}

	if (OutRegs.x.ax != p_rc_eol)						    /* parse error?		*/
		{
		Parse_Message(OutRegs.x.ax,STDERR,Parse_Err_Class,(char far *)Parse_Ptr);		    /* display parse error	*/
		exit(1);							    /* exit the program 	*/
		}

	/* Store the current Ctrl-C handler and replace with our
		Ctrl-C handler :M000
	*/
	OldCtrlc = _dos_getvect( 0x23 ); /* M000 */
	_dos_setvect( 0x23, MemCtrlc );	/* M000 */

	if (DataLevel > 0)
	{
		/* save current state of UMB linkage */
		InRegs.x.ax = GET_UMB_LINK_STATE;
		intdos(&InRegs, &OutRegs);
		if (!(UMB_Linkage = OutRegs.h.al))
		{  /* UMBs not presently linked, so do it now */
			InRegs.x.ax = SET_UMB_LINK_STATE;
			InRegs.x.bx = LINK_UMBS;
			intdos(&InRegs, &OutRegs);
			LinkedIn++;	/* Indicate that we have linked in UMBs :M000 */
		}

		rc = DisplayBaseDetail();		/* go show the memory state */

		/* restore original UMB link state */
		if (!UMB_Linkage)		/* weren't linked originally */
		{
			InRegs.x.ax = SET_UMB_LINK_STATE;
			InRegs.x.bx = UNLINK_UMBS;
			intdos(&InRegs, &OutRegs);  /* take 'em out again */
			LinkedIn--;
		}
	}
	if (!rc) {	/* if no error in DisplayBaseDetail */
			/* go display other things and summary */
		Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
		/* M003 BEGIN - Display summary acc. to option chosen */
		if (Classify)
			DisplayClassification();
		else
			DisplayBaseSummary();	/* display low memory totals */
		/* M003 END */

		if (EMSInstalled() && (DataLevel > 1))
		  DisplayEMSDetail();	/* display EMS memory totals */


		if (EMSInstalled())
		  DisplayEMSSummary();	/* display EMS memory totals */

		DisplayExtendedSummary(); /* display extended memory summary */
					/* NOTE: we don't display status of
					 * HMA because to enquire about its
					 * status can cause XMS to kick in
					 *
					 * If we didn't care about that, then
					 * display HMA status here.
					 */
	}	/* end of if (!rc) */

	/* If user did not issue Ctrl-C till here, we just remove the handler */
	_dos_setvect( 0x23, OldCtrlc );	/* M000 */

	return(rc);			/* end of MEM main routine */

	}

/**/

unsigned long AddressOf(Pointer)
char far *Pointer;
{

	unsigned long SegmentAddress,OffsetAddress;

	SegmentAddress = (unsigned long) (FP_SEG(Pointer)) * 16l;
	OffsetAddress = (unsigned long) (FP_OFF(Pointer));

	return( SegmentAddress + OffsetAddress);

	}

/*----------------------------------------------------------------------+
|                                                                       |
|  SUBROUTINE NAME:     PARSE_INIT                                      |
|                                                                       |
|  SUBROUTINE FUNCTION:                                                 |
|                                                                       |
|       This routine is called by the FILESYS MAIN routine to initialize|
|       the parser data structures.                                     |
|                                                                       |
|  INPUT:                                                               |
|       none                                                            |
|                                                                       |
|  OUTPUT:                                                              |
|       properly initialized parser control blocks                      |
|                                                                       |
+----------------------------------------------------------------------*/
void parse_init()
  {
  p_p.p_parmsx_address	  = &p_px;	/* address of extended parm list */
  p_p.p_num_extra	  = 0;

  p_px.p_minp		  = 0;
  p_px.p_maxp		  = 0;
  p_px.p_maxswitch	  = 4;
  p_px.p_control[0]	  = &p_con1;
  p_px.p_control[1]	  = &p_con2;
  p_px.p_control[2]       = &p_con3;
  p_px.p_control[3]       = &p_con4;
  p_px.p_keyword	  = 0;

  p_con1.p_match_flag	  = p_none;
  p_con1.p_function_flag  = p_cap_file;
  p_con1.p_result_buf	  = (unsigned int)&p_result1;
  p_con1.p_value_list	  = (unsigned int)&p_noval;
  p_con1.p_nid		  = 2;
  strcpy(p_con1.p_keyorsw,"/DEBUG"+NUL);
  strcpy(p_con1.p_keyorsw + (strlen(p_con1.p_keyorsw)+1),"/D"+NUL);

  p_con2.p_match_flag	  = p_none;
  p_con2.p_function_flag  = p_cap_file;
  p_con2.p_result_buf	  = (unsigned int)&p_result2;
  p_con2.p_value_list	  = (unsigned int)&p_noval;
  p_con2.p_nid		  = 2;
  strcpy(p_con2.p_keyorsw,"/PROGRAM"+NUL);
  strcpy(p_con2.p_keyorsw + (strlen(p_con2.p_keyorsw)+1),"/P"+NUL);

  p_con3.p_match_flag	  = p_none;
  p_con3.p_function_flag  = p_cap_file;
  p_con3.p_result_buf	  = (unsigned int)&p_result3;
  p_con3.p_value_list	  = (unsigned int)&p_noval;
  p_con3.p_nid		  = 2;
  strcpy(p_con3.p_keyorsw,"/CLASSIFY"+NUL);
  strcpy(p_con3.p_keyorsw + (strlen(p_con3.p_keyorsw)+1),"/C"+NUL);

  p_con4.p_match_flag	  = p_none;
  p_con4.p_function_flag  = p_none;
  p_con4.p_result_buf	  = (unsigned int)&p_result4;
  p_con4.p_value_list	  = (unsigned int)&p_noval;
  p_con4.p_nid		  = 1;
  strcpy(p_con4.p_keyorsw,"/?"+NUL);

  p_noval.p_val_num	  = 0;

  p_result1.P_Type	  = 0;
  p_result1.P_Item_Tag	  = 0;
  p_result1.P_SYNONYM_Ptr = 0;
  p_result1.p_result_buff = 0;

  p_result2.P_Type	  = 0;
  p_result2.P_Item_Tag	  = 0;
  p_result2.P_SYNONYM_Ptr = 0;
  p_result2.p_result_buff = 0;

  p_result3.P_Type	  = 0;
  p_result3.P_Item_Tag	  = 0;
  p_result3.P_SYNONYM_Ptr = 0;
  p_result3.p_result_buff = 0;

  return;

  }					/* end parse_init */


/************************************************************************/
/* Parse_Message                - This routine will print only those    */
/*                                messages that require 1 replaceable   */
/*                                parm.                                 */
/*                                                                      */
/*      Inputs  : Msg_Num       - number of applicable message          */
/*                Handle        - display type                          */
/*                Message_Type  - type of message to display            */
/*                Replace_Parm  - pointer to parm to replace            */
/*                                                                      */
/*      Outputs : message                                               */
/*                                                                      */
/************************************************************************/

void Parse_Message(Msg_Num,Handle,Message_Type,parse_ptr)
                        
int             Msg_Num; 
int             Handle;  
unsigned char   Message_Type;
char far *parse_ptr;
                            
{                          
                         
                                     
	if (parse_ptr) {
		sublist[1].value     = (unsigned far *)parse_ptr;
		sublist[1].size      = Sublist_Length; 
		sublist[1].reserved  = Reserved;      
		sublist[1].id        = 0;            
		sublist[1].flags     = Char_Field_ASCIIZ+Left_Align;
		sublist[1].max_width = 40;
		sublist[1].min_width = 01;
		sublist[1].pad_char  = Blank; 
	
        	InRegs.x.cx = SubCnt1;    
	}
	else
        	InRegs.x.cx = 0;    
                                     
        InRegs.x.ax = Msg_Num;      
        InRegs.x.bx = Handle;      
        InRegs.h.dl = No_Input;  
        InRegs.h.dh = Message_Type; 
        InRegs.x.si = (unsigned int)&sublist[1]; 
        sysdispmsg(&InRegs,&OutRegs); 
        return;                     
}                                  


/* M003 BEGIN */
/*----------------------------------------------------------------------+
|                                                                       |
|  SUBROUTINE NAME:     CSwitch_init                                    |
|                                                                       |
|  SUBROUTINE FUNCTION:                                                 |
|                                                                       |
|       This routine is called by the FILESYS MAIN routine to initialize|
|       the C(lassify) switch related data structures.                  |
|                                                                       |
|  INPUT:                                                               |
|       none                                                            |
|                                                                       |
|  OUTPUT:                                                              |
|       properly initialized C switch related Data structures 		|
|                                                                       |
+----------------------------------------------------------------------*/
void CSwitch_init()
{
	int i;
	int *ptr;

	ptr = (int *) (mem_table);

	for (i=sizeof(mem_table)/2;i>0;i--)
		*ptr++ = 0;

	noof_progs=0;
}

/* M003 END */
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\msgdef.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/************************************************************************/
/* MSGDEF.H		- This include file defines each message type	*/
/*			  that can occur in MEM.  These defines will	*/
/*			  be used by MEM to build the proper message.	*/
/*									*/
/*	Date	: 10/29/87						*/
/************************************************************************/
#include "version.h"                                                    /*EGH*/

#define NewLineMsg			10
#define Title1Msg			11
#define Title2Msg			12
#define Title3Msg			13
#define Title4Msg			14
#define MainLineMsg			15
#define DriverLineMsg			16
#define DeviceLineMsg			17
#define TotalMemoryMsg			18
#define AvailableMemoryMsg		19
#define FreeMemoryMsg			20
#define EMSTotalMemoryMsg		21
#define EMSFreeMemoryMsg		22
#define EXTMemoryMsg			23
#define InterruptVectorMsg		24
#define ROMCommunicationAreaMsg 	25
#define DOSCommunicationAreaMsg 	26
#if IBMCOPYRIGHT                                                        /*EGH*/
#define IbmbioMsg                       56                              /*EGH*/
#define IbmdosMsg                       57                              /*EGH*/
#else                                                                   /*EGH*/
#define IbmbioMsg                       27
#define IbmdosMsg			28
#endif                                                                  /*EGH*/
#define SystemDataMsg			29
#define SystemProgramMsg		30
#define SystemDeviceDriverMsg		31
#define InstalledDeviceDriverMsg	32
#define SingleDriveMsg			33
#define MultipleDrivesMsg		34
#define ConfigBuffersMsg		35
#define ConfigFilesMsg			36
#define ConfigFcbsMsg			37
#define ConfigStacksMsg 		38
#define ConfigDeviceMsg 		39
#define ConfigIFSMsg			40
#define ConfigLastDriveMsg		41
#define ConfigInstallMsg		45	/* gga */
#define UnownedMsg			42
#define BlankMsg			43
#define HandleMsg			44
#define EXTMemAvlMsg			46	/* ;an001; dms;*/
#define StackMsg			47
#define FreeMsg 			48
#define ProgramMsg			49
#define EnvironMsg			50
#define DataMsg 			51
#define XMSMemAvlMsg			52
#define HMAAvlMsg			53
#define HMANotAvlMsg			54
#define HMADOSMsg			55
#define ROMDOSMsg			58
#define CTtlConvMsg			59
#define CTtlUMBMsg			60
#define CTotalFreeMsg			61
#define	CFreeMsg			62
#define CTtlNameMsg			63
#define CTtlUScoreMsg			64
#define CSumm1Msg			65
#define CSumm2Msg			66
#define CSumm3Msg			67
#define CMemFragMsg			68
#define SystemMsg			69
#define CSumm1AMsg			70

#define	MSG_OPTIONS_FIRST	300
#define	MSG_OPTIONS_LAST	304

#ifdef JAPAN
#define	AdddrvMsg			400
#endif

#define ParseError1Msg			01
#define ParseError10Msg 		10

/************************************************************************/
/*		Message Retriever Standard Equates			*/
/************************************************************************/

#define Ext_Err_Class			0x0001
#define Parse_Err_Class 		0x0002
#define Utility_Msg_Class		0x00ff
#define No_Handle			0xffff
#define No_Replace			0x0000
#define Sublist_Length			0x000b
#define Reserved			0x0000
#define Left_Align			0x0000
#define Right_Align			0x0080
#define Char_Field_Char 		0x0000
#define Char_Field_ASCIIZ		0x0010
#define Unsgn_Bin_Byte			0x0011
#define Unsgn_Bin_Word			0x0021
#define Unsgn_Bin_DWord 		0x0031
#define Sgn_Bin_Byte			0x0012
#define Sgn_Bin_Word			0x0022
#define Sgn_Bin_DWord			0x0032
#define Bin_Hex_Byte			0x0013
#define Bin_Hex_Word			0x0023
#define Bin_Hex_DWord			0x0033
#define No_Input			0x0000
#define STDIN				0x0000
#define STDOUT				0x0001
#define STDERR				0x0002
#define Blank				0x0020

#define SubCnt1 			0x0001
#define SubCnt2 			0x0002
#define SubCnt3 			0x0003
#define SubCnt4 			0x0004
#define SubCnt5 			0x0005

#define CarryFlag			0x0001

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\membase.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/* MEMBASE.C - MEM routines for determining and displaying memory usage
*  for conventional memory.
*/

#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "version.h"
#include "mem.h"

/**/

/* go through the arena and print out the program name,size etc for /P switch */
/* but just keep storing them in a datastruct for later disp. for /C switch   */

unsigned int	DisplayBaseDetail()
{

	struct	 ARENA far *ThisArenaPtr;
	struct	 ARENA far *NextArenaPtr;
	struct	 ARENA far *ThisConfigArenaPtr;
	struct	 ARENA far *NextConfigArenaPtr;

	struct	 DEVICEHEADER far *ThisDeviceDriver;

	int	 SystemDataType;
	char	 SystemDataOwner[64];
	unsigned int far *UMB_Head_ptr;

	unsigned int long	Out_Var1;
	unsigned int long	Out_Var2;
	char			Out_Str1[64];
	char			Out_Str2[64];
	unsigned int msgno;

	InRegs.h.ah = (unsigned char) 0x52;
	intdosx(&InRegs,&OutRegs,&SegRegs);

	FP_SEG(SysVarsPtr) = FP_SEG(UMB_Head_ptr) = SegRegs.es;
	FP_OFF(SysVarsPtr) = OutRegs.x.bx;

	FP_OFF(UMB_Head_ptr) = 0x8c; /* ptr to UMB_HEAD in DOS Data */
	UMB_Head = *UMB_Head_ptr;

	if (!Classify)
	    Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
	if (DataLevel > 0)
	{
		if (!Classify) {
			Sub0_Message(Title1Msg,STDOUT,Utility_Msg_Class);
			Sub0_Message(Title2Msg,STDOUT,Utility_Msg_Class);
		}
	}

	InRegs.h.ah = (unsigned char) 0x30;
	intdos(&InRegs, &OutRegs);

	if ( (OutRegs.h.al != (unsigned char) 3) || (OutRegs.h.ah < (unsigned char) 40) )
		UseArgvZero = TRUE;
	   else UseArgvZero = FALSE;

	/* Display stuff below DOS  */
	Out_Var1 = 0l;
	Out_Var2 = 0x400l;
	if (Classify)				/* M003 */
		/* classify this memory also as part of DOS */
	    { if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
	else
	    Sub4_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     BlankMsg,
		     &Out_Var2,
		     InterruptVectorMsg);

	Out_Var1 = 0x400l;
	Out_Var2 = 0x100l;
	if (Classify)
		/* classify this memory also as part of DOS */
	    { if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
	else
	    Sub4_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     BlankMsg,
		     &Out_Var2,
		     ROMCommunicationAreaMsg);

	Out_Var1 = 0x500l;
	Out_Var2 = 0x200l;
	if (Classify)
		/* classify this memory also as part of DOS */
	    {	if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
	else
	    Sub4_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     BlankMsg,
		     &Out_Var2,
		     DOSCommunicationAreaMsg);

	/* Display the DOS data */

	/* Display the BIO data location and size */

	if (!Classify)
		Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);


	Out_Var1 = 0x700l;
	Out_Var2 = (long) (FP_SEG(SysVarsPtr) - 0x70)*16l;
	if (Classify)
		/* classify this memory also as part of DOS */
	    {	if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
	else
	    Sub4_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     IbmbioMsg,
		     &Out_Var2,
		     SystemDataMsg);

	/* Display the Base Device Driver Locations and Sizes */

	/*********************************************************************/
        /* to do this get the starting address of the internal driver header */
        /* chain. Start from the first header and get the address of the     */
        /* first header.  Display the driver name and address by calling     */
        /* "DISPLAYDEVICEDRIVER".  Repeat this for next driver on the chain  */
        /* until the last driver.  Note that driver name is in the header.   */
        /* The driver header addrs is in the system variable table from      */
        /* INT 21H fun 52H call.                                             */
	/*********************************************************************/

	BlockDeviceNumber = 0;

	for (ThisDeviceDriver = SysVarsPtr -> DeviceDriverChain;
	      (FP_OFF(ThisDeviceDriver) != 0xFFFF);
	       ThisDeviceDriver = ThisDeviceDriver -> NextDeviceHeader)
	      { if ( FP_SEG(ThisDeviceDriver) < FP_SEG(SysVarsPtr) )
			DisplayDeviceDriver(ThisDeviceDriver,SystemDeviceDriverMsg);
		}

	/* Display the DOS data location and size */

        FP_SEG(ArenaHeadPtr) = FP_SEG(SysVarsPtr);                                                                               /* ;an004; */
        FP_OFF(ArenaHeadPtr) = FP_OFF(SysVarsPtr) - 2;                                                                           /* ;an004; */
                                                                                                                                 /* ;an004; */
        FP_SEG(ThisArenaPtr) = *ArenaHeadPtr;                                                                                    /* ;an004; */
        FP_OFF(ThisArenaPtr) = 0;                                                                                                /* ;an004; */
	if (!Classify)
	    Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

	Out_Var1 = (long) FP_SEG(SysVarsPtr) * 16l;
        Out_Var2 = (long) ((AddressOf((char far *)ThisArenaPtr)) - Out_Var1);                                                    /* ;ac004; */
	if (Classify)
		/* classify this memory also as part of DOS */
	    {	if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
	else
	    Sub4_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     IbmdosMsg,
		     &Out_Var2,
		     SystemDataMsg);

	if (!Classify)
	   Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

	/* Display the memory data */

/* IO.SYS data area contains BUFFERS, FCBs, LAST DRIVE etc.  They are contained 	       */
/* in a one huge memory block.  This block has a seg iD 0008.  This seg ID can                 */
/* be found from the block header owner area.  This seg id 0008:0000                           */
/* points to the buffer table as shown below.  If seg id is 0008:000, then                     */
/* using the seg id find the table.  Each entry is contained in a sub block                    */
/* within the main block.  Each sub block has header and this header contains                  */
/* id such as B for BUFFER,  X for FCBs,  I for IFS,  D for external device                    */
/* drivers.  Go through the sub blocks and display the name ans size. that's all.              */
/*                                                                                             */
/* If the block contains D, then it contains external drivers.  The driver name                */
/* is not in the sub block.  So we have to find the driver name from the driver                */
/* header chain.  To do this get the address of the driver chain from syster                   */
/* variable table from INT 21H FN 52H call.  Go through the chain and findout                  */
/* the name.  Display name from the header and the size we got from the sub block.             */
/*                                                                                             */
/*                                                                                             */
/* After this main block, comes other buffer blocks which contains programs                    */
/* such as command.com, doscolor, even MEM.  From these blocks, get the program                */
/* name and the size and display them too.                                                     */
/*                                                                                             */
/* 0008:000->------------------          -------------------                                   */
/*           | BUFFERS        | -------->|B (signature)    | Block header                      */
/*           ------------------          -------------------                                   */
/*           | FCBs           | --       |                 |                                   */
/*           ------------------   |      | Buffers data    |                                   */
/*           | IFSs           |   |      |                 |                                   */
/*           ------------------   |      |                 |                                   */
/*           | LAST DRIVE     |   |      |                 |                                   */
/*           ------------------   |      --------------------                                  */
/*           | EXTERN DRIVER 1|   |                                                            */
/*           ------------------   |          -------------------                               */
/*           | EXTERN DRIVER 2|   | -------->|X (signature)    | Block header                  */
/*           ------------------              -------------------                               */
/*           | EXTERN DRIVER 3|              |                 |                               */
/*           ------------------              | Buffers data    |                               */
/*                                           |                 |                               */
/*                                           |                 |                               */
/*                                           |                 |                               */
/*                                           --------------------                              */
/*                                                                                             */
/* For DOS 5.0, there are some additions to the above.	Basically, we have
/* three possible memory maps, to wit:
/*
/*    DOS Loads Low			     DOS loads high
/*    70:0 - BIOS data			     70:0 - BIOS data
/*	     DOS data				    DOS data
/*	     BIOS + DOS code			    Sysinit data (arena name SD)
/*	       (arena owner 8, name "SC")	    VDisk header (arena name SC)
/*	     Sysinit data (arean owner 8, name SD)
/*
/*    DOS tries to load high but fails
/*    70:0 - BIOS data
/*	     DOS data
/*	     Sysinit data (arena name SD)
/*	     DOS + BIOS code (arena name SC)
/*
/*    We have to detect the special arena ownership marks and display them
/*    correctly.  Everything after DOS and BIOS data should have an arena header
/******************************************************************************/

	while (ThisArenaPtr -> Signature != (char) 'Z')
	      {
																 /* MSKK02  */
#ifdef JAPAN
		if (ThisArenaPtr -> Owner == 8 || ThisArenaPtr -> Owner == 9 )
#else
		if (ThisArenaPtr -> Owner == 8)
#endif
		      {
			FP_SEG(NextArenaPtr) = FP_SEG(ThisArenaPtr) + ThisArenaPtr -> Paragraphs + 1;
			FP_OFF(NextArenaPtr) = 0;

			Out_Var1 = AddressOf((char far *)ThisArenaPtr);
			Out_Var2 = (long) (ThisArenaPtr -> Paragraphs) * 16l;
			if (ThisArenaPtr->OwnerName[0] == 'S' &&
			    ThisArenaPtr->OwnerName[1] == 'C')
			{      /* display message for BIOS and DOS code */
			   if (Classify)
		 	   /* classify this memory also as part of DOS */
				{ if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
			   else {
				msgno = (FP_SEG(ThisArenaPtr) < UMB_Head) ? IbmdosMsg:SystemMsg;
				Sub4_Message(MainLineMsg,
					     STDOUT,
					     Utility_Msg_Class,
					     &Out_Var1,
					     msgno,
					     &Out_Var2,
					     SystemProgramMsg);
				Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
			    }
			}
			else /* display message for data */
			{
			if (!Classify)
			    Sub4_Message(MainLineMsg,
				     STDOUT,
				     Utility_Msg_Class,
				     &Out_Var1,
#ifdef JAPAN
				     (ThisArenaPtr -> Owner == 8) ? IbmbioMsg : AdddrvMsg,
				     &Out_Var2,
				     (ThisArenaPtr -> Owner == 8) ? SystemDataMsg : ProgramMsg );
#else
				     IbmbioMsg,
				     &Out_Var2,
				     SystemDataMsg);
#endif

			FP_SEG(ThisConfigArenaPtr) = FP_SEG(ThisArenaPtr) + 1;
			FP_OFF(ThisConfigArenaPtr) = 0;


			while ( (FP_SEG(ThisConfigArenaPtr) > FP_SEG(ThisArenaPtr)) &&
				(FP_SEG(ThisConfigArenaPtr) < FP_SEG(NextArenaPtr))    )
			      {
				strcpy(SystemDataOwner," ");
				switch(ThisConfigArenaPtr -> Signature)
				      {
					case 'B':
						SystemDataType = ConfigBuffersMsg;
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					case 'D':
						SystemDataType = ConfigDeviceMsg;
						if (AddMem_to_PSP(ThisConfigArenaPtr->Owner,((long)FP_SEG(ThisConfigArenaPtr)*16l) ,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						strcpy(SystemDataOwner,OwnerOf(ThisConfigArenaPtr));
						break;
					case 'F':
						SystemDataType = ConfigFilesMsg;
						if (AddMem_to_PSP(8,((long)FP_SEG(ThisConfigArenaPtr) *16l),((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					case 'I':
						SystemDataType = ConfigIFSMsg;
						strcpy(SystemDataOwner,OwnerOf(ThisConfigArenaPtr));
						if (AddMem_to_PSP(ThisConfigArenaPtr->Owner,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					case 'L':
						SystemDataType = ConfigLastDriveMsg;
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					case 'S':
						SystemDataType = ConfigStacksMsg;
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					case 'T':					 /* gga */
						SystemDataType = ConfigInstallMsg;	 /* gga */
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;					 /* gga */
					case 'X':
						SystemDataType = ConfigFcbsMsg;
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
                                                break;

                                        // NTVDM for special kbd\mouse drivers
                                        case 'Q':
                                                SystemDataType = SystemProgramMsg;
                                                strcpy(SystemDataOwner,OwnerOf(ThisConfigArenaPtr));
                                                if (AddMem_to_PSP(ThisConfigArenaPtr->Owner,((long)FP_SEG(ThisConfigArenaPtr)*16l) ,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
                                                break;
#ifdef JAPAN
					case '?':
						SystemDataType = DataMsg;
						break;
#endif
                                        default:
						SystemDataType = BlankMsg;
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					}

          /****************************************************/
          /*  Found one, now display the owner name and size  */
          /****************************************************/

				Out_Var1 = ((long) ThisConfigArenaPtr -> Paragraphs) * 16l;
				if (!Classify)
				   Sub3_Message(DriverLineMsg,
					     STDOUT,
					     Utility_Msg_Class,
					     SystemDataOwner,
					     &Out_Var1,
					     SystemDataType );

				NextConfigArenaPtr = ThisConfigArenaPtr;
				FP_SEG(NextConfigArenaPtr) += NextConfigArenaPtr -> Paragraphs + 1;
				if (ThisConfigArenaPtr -> Signature == (char) 'D')
				      {

					FP_SEG(ThisDeviceDriver) = FP_SEG(ThisConfigArenaPtr) + 1;
					FP_OFF(ThisDeviceDriver) = 0;
/* start MSKK bug fix - MSKK01 */
					while ( (FP_SEG(ThisDeviceDriver) > FP_SEG(ThisConfigArenaPtr)) &&
						(FP_SEG(ThisDeviceDriver) < FP_SEG(NextConfigArenaPtr))    ) {
						DisplayDeviceDriver(ThisDeviceDriver,InstalledDeviceDriverMsg);
						ThisDeviceDriver = ThisDeviceDriver -> NextDeviceHeader;
					     }
/* end MSKK bug fix - MSKK01 */			
					}

				FP_SEG(ThisConfigArenaPtr) += ThisConfigArenaPtr -> Paragraphs + 1;

				}
			   }
			}
		 else {

/*******************************************************************************/
/* If not BIOS table, it is a program like MEM, etc.			       */
/* calculate the size of the block occupied by the program and display program */
/* name and size                                                               */
/*******************************************************************************/

		      Out_Var1 = AddressOf((char far *)ThisArenaPtr);
		      Out_Var2 = ((long) (ThisArenaPtr -> Paragraphs)) * 16l;
		      strcpy(Out_Str1,OwnerOf(ThisArenaPtr));
		      strcpy(Out_Str2,TypeOf(ThisArenaPtr));
		      if (Classify)
			{ if (AddMem_to_PSP(ThisArenaPtr->Owner,Out_Var1,Out_Var2)) return(1); }
		      else
		      	Sub4a_Message(MainLineMsg,
				   STDOUT,
				   Utility_Msg_Class,
				   &Out_Var1,
				   Out_Str1,
				   &Out_Var2,
				   Out_Str2);
			}

		FP_SEG(ThisArenaPtr) += ThisArenaPtr -> Paragraphs + 1;

		}
	Out_Var1 = AddressOf((char far *)ThisArenaPtr);
	Out_Var2 = ((long) (ThisArenaPtr -> Paragraphs)) * 16l;
	strcpy(Out_Str1,OwnerOf(ThisArenaPtr));
	strcpy(Out_Str2,TypeOf(ThisArenaPtr));
	if (Classify)
	    { if (AddMem_to_PSP(ThisArenaPtr->Owner,Out_Var1,Out_Var2)) return(1); }
	else
	   Sub4a_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     Out_Str1,
		     &Out_Var2,
		     Out_Str2);


	return(0); 			/* end of MEM main routine */

	}



/**/

void	 DisplayDeviceDriver(ThisDeviceDriver,DeviceDriverType)
struct	 DEVICEHEADER far *ThisDeviceDriver;
int	 DeviceDriverType;
{
	char	 LocalDeviceName[16];
	int	 i;

	if (DataLevel < 2) return;

	if ( ((ThisDeviceDriver -> Attributes) & 0x8000 ) != 0 )
	      { for (i = 0; i < 8; i++) LocalDeviceName[i] = ThisDeviceDriver -> Name[i];
		LocalDeviceName[8] = NUL;

		Sub2_Message(DeviceLineMsg,
			     STDOUT,
			     Utility_Msg_Class,
			     LocalDeviceName,
			     DeviceDriverType);

		}

	 else {
		if ((int) ThisDeviceDriver -> Name[0] == 1)
			sprintf(&LocalDeviceName[0],SingleDrive,'A'+BlockDeviceNumber);
		   else sprintf(&LocalDeviceName[0],MultipleDrives,
				'A'+BlockDeviceNumber,
				'A'+BlockDeviceNumber + ((int) ThisDeviceDriver -> Name[0]) - 1);

		Sub2_Message(DeviceLineMsg,
			     STDOUT,
			     Utility_Msg_Class,
			     LocalDeviceName,
			     DeviceDriverType);

		BlockDeviceNumber += (int) (ThisDeviceDriver -> Name[0]);

		}

	return;

	}


/**/

void DisplayBaseSummary()
	{

	struct	PSP_STRUC
		{
		unsigned int	int_20;
		unsigned int	top_of_memory;
		};

	char	 far *CarvedPtr;

	unsigned long int total_mem;		  /* total memory in system */
	unsigned long int avail_mem;		  /* avail memory in system */
	unsigned long int free_mem;		  /* free memory */
	unsigned long biggest_free;			/* largest free block now :M001 */
	struct	 PSP_STRUC far *PSPptr;

/* skip a line */
	Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

/*  get PSP info */
	InRegs.h.ah = GET_PSP;			/* get PSP function call */
	intdos(&InRegs,&OutRegs);

	FP_SEG(PSPptr) = OutRegs.x.bx;		/* PSP segment */
	FP_OFF(PSPptr) = 0;			/* offset 0 */

/* Get total memory in system */
	int86(MEMORY_DET,&InRegs,&OutRegs);

/* Convert to bytes */
	total_mem = (unsigned long int) OutRegs.x.ax * 1024l;
        avail_mem = total_mem;

/* M004 BEGIN */
/* Adjust for XBDA size */
/* XBDA size should be added to total mem size reported by INT 12 */
/* IFF XBDA is placed just at the end of conv.mem */
/* IF EMM386 or QEMM is loaded, XBDA gets relocated to EMM driver mem */
/* and int 12 reports correct size of memory in this case */

	InRegs.x.bx = 0;
	InRegs.x.ax = 0xc100;
	int86x(0x15, &InRegs, &OutRegs, &SegRegs);
	if (OutRegs.x.cflag == 0)
	{
		if (total_mem == ((unsigned long)SegRegs.es) * 16ul) {
			FP_SEG(CarvedPtr) = SegRegs.es;
			FP_OFF(CarvedPtr) = 0;
			total_mem = total_mem + ( (unsigned long int) (*CarvedPtr) * 1024l) ;   /* ;an002; dms;adjust total for */
		}
        }	/* RAM carve value  */
/* M004 END */

	Sub1_Message(TotalMemoryMsg,STDOUT,Utility_Msg_Class,&total_mem);

	Sub1_Message(AvailableMemoryMsg,STDOUT,Utility_Msg_Class,&avail_mem);

/* Calculate the total memory used.   PSP segment * 16. Subtract from total to
   get free_mem */
	free_mem = (DOS_TopOfMemory * 16l) - (FP_SEG(PSPptr)*16l);								 /* ;an000;ac005; */

	/* Get largest free block in system :M001 */

	InRegs.x.ax = 0x4800;	/* M001 */
	InRegs.x.bx = 0xffff;	/* M001 */
	intdos(&InRegs, &OutRegs);	/* M001 */
	biggest_free = OutRegs.x.bx * 16L; /* Size of largest block now :M001 */

	/* The largest free block in the system is either the block we are
		currently in or the block we have allocated. We can either be the
		topmost program or be loaded in a hole or UMB. In either case, the
		larger of the 2 values gives us the largest free block :M001
	*/

	if ( biggest_free > free_mem )	/* M001 */
		free_mem = biggest_free;		/* M001 */

	Sub1_Message(FreeMemoryMsg,STDOUT,Utility_Msg_Class,&free_mem);

	return;

	}			/* end of display_low_total */


/**/


char *OwnerOf(ArenaPtr)
struct ARENA far *ArenaPtr;
{

	char	 far *StringPtr;
	char	     *o;
	unsigned far *EnvironmentSegmentPtr;
	unsigned     PspSegment;
	int	     i,fPrintable;

	o = &OwnerName[0];
	*o = NUL;
	sprintf(o,UnOwned);

	PspSegment = ArenaPtr -> Owner;


	if (PspSegment == 0) sprintf(o,Ibmdos);
	 else if (PspSegment == 8) sprintf(o,Ibmbio);
	  else {
		FP_SEG(ArenaPtr) = PspSegment-1;	/* -1 'cause Arena is 16 bytes before PSP */
		StringPtr = (char far *) &(ArenaPtr -> OwnerName[0]);
/* M002 BEGIN */
		fPrintable = TRUE;


/* Chars below 0x20 (Space) and char 0x7f are not printable in US and
 * European Code pages.  The following code checks for it and does not print
 * such names.  - Nagara 11/20/90
 */

		for (i = 0; i < 8;i++,StringPtr++) {
#ifdef DBCS
			if ( ((unsigned char)*StringPtr < 0x20) | ((unsigned char)*StringPtr == 0x7f) ) {
#else
			if ( (*StringPtr < 0x20) | (*StringPtr == 0x7f) ) {
#endif
					/* unprintable char ? */	
			   if (*StringPtr) fPrintable = FALSE;	
			   break;
			}
		    }

		if (fPrintable) {	/*  the name is printable */
			StringPtr = (char far *) &(ArenaPtr -> OwnerName[0]);
			for (i = 0; i < 8;i++)
				*o++ = *StringPtr++;
			*o = (char) '\0';
		    }
/* M002 END */
		}

	if (UseArgvZero) GetFromArgvZero(PspSegment,EnvironmentSegmentPtr);

	return(&OwnerName[0]);

	}


/**/

void	     GetFromArgvZero(PspSegment,EnvironmentSegmentPtr)
unsigned     PspSegment;
unsigned far *EnvironmentSegmentPtr;
{

	char	far *StringPtr;
	char	*OutputPtr;
	unsigned far *WordPtr;

	OutputPtr = &OwnerName[0];

	if (UseArgvZero)
	      {
		if (PspSegment < FP_SEG(ArenaHeadPtr))
		      {
			if (*OutputPtr == NUL) sprintf(OutputPtr,Ibmdos);
			}
		 else {
			FP_SEG(EnvironmentSegmentPtr) = PspSegment;
			FP_OFF(EnvironmentSegmentPtr) = 44;

/*			   FP_SEG(StringPtr) = *EnvironmentSegmentPtr;	*/
			FP_SEG(StringPtr) = FP_SEG(EnvironmentSegmentPtr);
			FP_OFF(StringPtr) = 0;

			while ( (*StringPtr != NUL) || (*(StringPtr+1) != NUL) ) StringPtr++;

			StringPtr += 2;
			WordPtr = (unsigned far *) StringPtr;

			if (*WordPtr == 1)
			      {
				StringPtr += 2;
				while (*StringPtr != NUL)
					*OutputPtr++ = *StringPtr++;
				*OutputPtr++ = NUL;

				while ( OutputPtr > &OwnerName[0] )
				      { if (*OutputPtr == (char) '.') *OutputPtr = NUL;
					if ( (*OutputPtr == (char) '\\') || (*OutputPtr == (char) ':') )
					      { OutputPtr++;
						break;
						}
					OutputPtr--;
					}

				}

			}
		}

	strcpy(&OwnerName[0],OutputPtr);

	return;

	}


/**/


char *TypeOf(Header)
struct ARENA far *Header;
{

	char	     *t;
	unsigned     PspSegment;
	unsigned far *EnvironmentSegmentPtr;
        unsigned int Message_Number;
        char far     *Message_Buf;
        unsigned int i;

	t = &TypeText[0];
	*t = NUL;

        Message_Number = 0xff;                                                  /* ;an000; initialize number value      */
	if (Header -> Owner == 8) Message_Number = StackMsg;
	if (Header -> Owner == 0) Message_Number = FreeMsg;

	PspSegment = Header -> Owner;
	if (PspSegment < FP_SEG(ArenaHeadPtr))
		{
                if (Message_Number == 0xff) Message_Number = BlankMsg;
		}
	else {
		FP_SEG(EnvironmentSegmentPtr) = PspSegment;
		FP_OFF(EnvironmentSegmentPtr) = 44;


                if (PspSegment == FP_SEG(Header)+1)
                        Message_Number = ProgramMsg;
                else if ( *EnvironmentSegmentPtr == FP_SEG(Header)+1 )
                        Message_Number = EnvironMsg;
                else
                        Message_Number = DataMsg;

                }

	InRegs.x.ax = Message_Number;
	InRegs.h.dh = Utility_Msg_Class;
	sysgetmsg(&InRegs,&SegRegs,&OutRegs);

	FP_OFF(Message_Buf)    = OutRegs.x.si;
	FP_SEG(Message_Buf)    = SegRegs.ds;

        i = 0;
        while ( *Message_Buf != (char) '\x0' )
                TypeText[i++] = *Message_Buf++;
        TypeText[i++] = '\x0';


	return(t);

	}
/* M003 BEGIN */
/*----------------------------------------------------------------------*/
/*  AddMem_to_PSP						        */
/*	Entry:	PSP_ADDR	(to which this mem. should be added)	*/
/*		ARENA_START_ADDR					*/
/*		Length_of_Arena						*/
/*	Exit:	mem_table updated.			      		*/
/*		returns 1 if more than MAX_CL_ENTRIES in mem_table	*/
/*		   else 0						*/
/*									*/
/* CAVEATS:						  		*/
/* --------								*/
/* 1. any system area (BIOS,SYSINIT,DOS ) code/data is listed as belonging */
/*    to PSP 8.							        */
/*									*/
/* 2. We look at the UMB_HEAD in DOS DATA to determine whether an arena */
/*    is in UMB or not; For the Arena at the UMB boundary, we add one   */
/*    para to conv. and remaining to UMB portion of that PSP	        */
/*									*/
/* 3. Any free memory is always added as a new entry in the mem_table   */
/*    instead of just adding the sizes to an existing FREE entry        */
/*    Free memory gets added to the previous free memory if they are    */
/*    contiguous							*/
/*									*/
/* 4. The no of programs/free arenas cannot exceed a max of (100)	*/
/*    (defined by MAX_CLDATA_INDEX )       				*/
/*    If the memory is fragmented and a lot of small TSRs loaded such   */
/*    that we exceed this limit, we TERMINATE				*/
/*									*/
/* 5. Mem occupied by this MEM are also reported as FREE mem		*/
/*									*/
/*----------------------------------------------------------------------*/

unsigned int AddMem_to_PSP(psp,start_addr,length)
unsigned int psp;
unsigned long start_addr,length;
{
	unsigned int para_no,len_in_paras,CurPSP;
	int i;
	extern unsigned int _psp;
	
	para_no = (unsigned int)(start_addr >> 4);	/* convert to paras*/
	len_in_paras = (unsigned int)(length >> 4);	/* convert to paras */

	CurPSP = psp;

	if (psp == _psp) psp = 0;	/* treat MEM's arenas as FREE */

	if (!psp) {
	   if (LastPSP == _psp) {	/* if the prev.arena was MEM */
		i = noof_progs -1;	/* look at the last entry */
		if (mem_table[i].psp_add != psp) /* was the last entry free ?*/
			i++;
		else len_in_paras++;	/* account for one free arena header */
	   }
	   else i = noof_progs; /* new entry for FREE mem */
	}
	else
	    for (i = 0;i < noof_progs;i++)
		if (mem_table[i].psp_add == psp) break;

	/* if psp is not already listed in the table, add it */
	if (i == noof_progs) {
		if (noof_progs == MAX_CLDATA_INDEX) {
			/* use parse error message proc to display err msg */
			Parse_Message(CMemFragMsg,STDERR,Utility_Msg_Class,(char far *) NULL);
			return(1);
		}
		mem_table[i].psp_add = psp;
		noof_progs++;
	}

	/* add the memory to the table entry */

	if (para_no < UMB_Head)
		mem_table[i].mem_conv += len_in_paras;
	else if (para_no == UMB_Head) {
		mem_table[i].mem_conv++;
		mem_table[i].mem_umb = len_in_paras-1;
	}
	else mem_table[i].mem_umb += len_in_paras;
	LastPSP = CurPSP;
	return(0);
}
		
/**/
/************************************************************************/
/* DisplayClassification						*/
/*	Main display proc for /C switch 				*/
/*									*/	
/* ENTRY:	none							*/
/*									*/	
/* EXIT:	none 							*/
/*									*/
/*	find out if UMB is available by going through mem_table entries */
/*	(also find out MEM's size from these entries)			*/
/*	display memory break up for conventional memory			*/
/*	if (UMB in system) display memmory break up for UMB memory	*/
/*	display the total free size (= total free in conv.+total_free   */
/*		in UMB + MEM's size )					*/
/*	call DispBigFree to display the largest prog. sizes in Conv.&UMB*/
/*									*/	
/************************************************************************/

#define CONVONLY 0
#define UMBONLY	1

void DisplayClassification()
{
	unsigned long tot_freemem=0L;
	char ShDSizeName[12];
	int i;
	unsigned int cur_psp;
	char fUMBAvail=0;


	/*  get PSP info */

	InRegs.h.ah = GET_PSP;			/* get PSP function call */
	intdos(&InRegs,&OutRegs);

	cur_psp = OutRegs.x.bx;			/* psp of MEM */

	for (i=0;i <noof_progs;i++) {
		if (mem_table[i].mem_umb)
			fUMBAvail = TRUE;
		if (mem_table[i].psp_add == cur_psp) {
		   tot_freemem += (long)(mem_table[i].mem_conv + mem_table[i].mem_umb);
		   if (fUMBAvail) break;
		}
	}
	tot_freemem *=16l;	/* convert to bytes */

	Sub0_Message(CTtlConvMsg,STDOUT,Utility_Msg_Class);
	Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
	tot_freemem += DispMemClass(CONVONLY);

	Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

	if (fUMBAvail) {
		Sub0_Message(CTtlUMBMsg,STDOUT,Utility_Msg_Class);
		Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
		tot_freemem += DispMemClass(UMBONLY);

		Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
	}

	sprintf(ShDSizeName," (%5.1fK)",((float)tot_freemem)/1024l );
	i = (fUMBAvail) ? CSumm1Msg:CSumm1AMsg;
	SubC2_Message(i,STDOUT,&tot_freemem, ShDSizeName);

	DispBigFree(fUMBAvail,cur_psp);

}
/************************************************************************/
/* DispMemClass								*/
/*		(displays the progs and FREE sizes in either the   	*/
/*		conventional or UMB)					*/
/*									*/	
/* ENTRY:	memtype => Conventional(0) /UMB (1)			*/
/*									*/	
/* EXIT:	total_freemem_size (in bytes)				*/
/*									*/
/*	go through mem_table entries and display NON-ZERO size, NON-FREE */
/*		entries in the given mem_type				*/
/*	go through mem_table entries and display NON_ZERO size, FREE	*/
/*		entries in the given mem_type				*/
/*	calculate the total free mem size in the given mem type &return */
/*									*/
/* CAVEATS:								*/
/*	Arenas marked as belonging to MSDOS (code) in UMB are displayed */
/*	as SYSTEM							*/
/*									*/	
/************************************************************************/

unsigned long DispMemClass(memtype)
int memtype;
{
	int i,msgtype;
	unsigned int cur_memsize;
	unsigned long memsize;
	char *nameptr;
	char ShDSizeName[12];
	unsigned long tot_free = 0;
	struct ARENA far *ArenaPtr;

	Sub0_Message(CTtlNameMsg,STDOUT,Utility_Msg_Class);
	Sub0_Message(CTtlUScoreMsg,STDOUT,Utility_Msg_Class);

	for (i=0; i <noof_progs; i++) {

		cur_memsize = (memtype == CONVONLY) ? mem_table[i].mem_conv:mem_table[i].mem_umb;
		if (!cur_memsize) continue;
		if (!mem_table[i].psp_add) continue;
		msgtype = 0;
		if (mem_table[i].psp_add == 8) 	/* if DOS area */
			msgtype = (memtype == CONVONLY)?IbmdosMsg:SystemMsg;
		if (!msgtype) {
			FP_SEG(ArenaPtr) = mem_table[i].psp_add-1;	
				/* -1 'cause Arena is 16 bytes before PSP */
			FP_OFF(ArenaPtr) = 0;
			nameptr = OwnerOf(ArenaPtr);
		}
		else nameptr = NULL;

		memsize = ((long) cur_memsize) *16l;
		sprintf(ShDSizeName," (%5.1fK)",((float)memsize)/1024l );
		SubC4_Message(MainLineMsg,STDOUT,nameptr,msgtype,&memsize, ShDSizeName);
		
	}
	for (i=0; i <noof_progs; i++) {

		if (mem_table[i].psp_add) continue;
		cur_memsize = (memtype == CONVONLY) ? mem_table[i].mem_conv:mem_table[i].mem_umb;
		if (!cur_memsize) continue;
		tot_free += (long) cur_memsize;

		memsize = ((long) cur_memsize) *16l;
		sprintf(ShDSizeName," (%5.1fK)",((float)memsize)/1024l );
		SubC4_Message(MainLineMsg,STDOUT,NULL,CFreeMsg,&memsize, ShDSizeName);
		
	}

	tot_free *= 16l;
	sprintf(ShDSizeName," (%5.1fK)",((float)tot_free )/1024l );
	Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
	SubC2_Message(CTotalFreeMsg,STDOUT,&tot_free, ShDSizeName);

	return(tot_free);
		

}
/************************************************************************/
/* DispBigFree								*/
/* ENTRY:	UMBAvailable? (flag) 1-> there is UMB			*/
/*		MEM's PSP						*/
/* EXIT:	none (largest prog.sizes displayed)			*/
/*	This finds out and displays the largest contig.mem available in */
/*	in Conventional and UMB memory 					*/
/*	This calculation is done assuming that MEM is not loaded 	*/
/*									*/	
/************************************************************************/

void DispBigFree(fUMBAvail,cur_psp)
char fUMBAvail;
unsigned int cur_psp;
{

	int i;
	unsigned int ConvBigFree = 0;
	unsigned int UMBBigFree = 0;
	unsigned long TmpBigFree;
	char ShDSizeName[12];
	unsigned far *Env_ptr;
	unsigned int env_mem,BigFree;
	char fMEMHigh;
	

	/* assume that the biggest free size is the top of mem we got when */
	/* MEM was loaded */

	FP_SEG(Env_ptr) = cur_psp;
	FP_OFF(Env_ptr) = 44;	/* get the env for MEM */
	FP_SEG(Env_ptr) = (*Env_ptr)-1;	/* get to arena for env. */
	FP_OFF(Env_ptr) = 3;	/* get the size of environment */
	env_mem = *Env_ptr + 1; /* 1 extra para for arena header */

	fMEMHigh = (char)((cur_psp > UMB_Head) ? 1:0);

	BigFree = DOS_TopOfMemory  - cur_psp;

	if (fMEMHigh ) 	/* mem was loaded higher */
		UMBBigFree = BigFree;
	else
		ConvBigFree = BigFree;

	for (i =0; i<noof_progs;i++) {
		if (mem_table[i].psp_add) continue; /* skip non-FREE entries */
		if (mem_table[i].mem_conv > ConvBigFree)
			ConvBigFree = mem_table[i].mem_conv;
		if (mem_table[i].mem_umb > UMBBigFree)
			UMBBigFree = mem_table[i].mem_umb;
	}

	if (fMEMHigh) {	/* MEM was loaded high */
		if (FP_SEG(Env_ptr) > UMB_Head) /* env also in UMB */
			if (UMBBigFree == (BigFree + env_mem))
				UMBBigFree = BigFree;
	}
	else {		/* MEM was loaded low */
		if (FP_SEG(Env_ptr) < UMB_Head) /* env also in Conv */
			if (ConvBigFree == (BigFree + env_mem))
				ConvBigFree = BigFree;
	}


	TmpBigFree = ((unsigned long)ConvBigFree) * 16l;
	sprintf(ShDSizeName," (%5.1fK)",((float)TmpBigFree)/1024l );
	SubC2_Message(CSumm2Msg,STDOUT,&TmpBigFree, ShDSizeName);

	if (fUMBAvail) {
		TmpBigFree = ((unsigned long)UMBBigFree) * 16l;
		sprintf(ShDSizeName," (%5.1fK)",((float)TmpBigFree)/1024l );
		SubC2_Message(CSumm3Msg,STDOUT,&TmpBigFree, ShDSizeName);
	}

}
/* M003 END */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\parse.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/*  */
/*----------------------------------------------------------------------+
|									|
| This file contains the structures and defines that are needed to use	|
| the parser from a C program.						|
|									|
|									|
| Date: 	5-21-87 						|
|									|
+----------------------------------------------------------------------*/


#define p_len_parms		4		/* length of p_parms  */
#define p_i_use_default 	0		/* no extra stuff specified */
#define p_i_have_delim		1		/* extra delimiter specified  */
#define p_i_have_eol		2		/* extra EOL specified */

struct p_parms
	{
	struct p_parmsx *p_parmsx_address;	/* address of p_parmsx */
	unsigned char	p_num_extra;		/* number of extra stuff */
	unsigned char	p_len_extra_delim;	/* length of extra delimiter */
	char		p_extra_delim[30];	/* extra delimiters */
	};

struct p_parmsx
	{
	unsigned char	p_minp; 		/* Minimum positional number */
	unsigned char	p_maxp; 		/* Maximum positional number  */
	unsigned char	p_maxswitch;		/* Maximum switches	*/
	struct p_control_blk *p_control[4];	/* Address of the 1st CONTROL block */
	unsigned char	p_keyword;		/* Keyword count */
	};


struct p_control_blk
	{
	unsigned int	p_match_flag;		/* Controls type matched */
	unsigned int	p_function_flag;	/* Function should be taken */
	unsigned int	p_result_buf;		/* Result buffer address */
	unsigned int	p_value_list;		/* Value list address */
	unsigned char	p_nid;			/* # of keyword/SW synonyms */
	char		p_keyorsw[32];		/* keyword or sw */
	};

/* Match_Flags */

#define p_num_val		0x8000		/* Numeric Value */
#define p_snum_val		0x4000		/* Signed numeric value */
#define p_simple_s		0x2000		/* Simple string */
#define p_date_s		0x1000		/* Date string */
#define p_time_s		0x0800		/* Time string */
#define p_cmpx_s		0x0400		/* Complex string */
#define p_file_spc		0x0200		/* File Spec */
#define p_drv_only		0x0100		/* Drive Only */
#define p_qu_string		0x0080		/* Quoted string */
#define p_ig_colon		0x0010		/* Ignore colon at end in match */
#define p_repeat		0x0002		/* Repeat allowed */
#define p_optional		0x0001		/* Optional */
#define p_none			0x0000

/*----------------------------------------------------------------------+
|									|
|  Function flags							|
|									|
+----------------------------------------------------------------------*/

#define p_cap_file		0x0001		/* CAP result by file table */
#define p_cap_char		0x0002		/* CAP result by character table */
#define p_rm_colon		0x0010		/* Remove ":" at the end */



#define p_nval_none		0		/* no value list ID */
#define p_nval_range		1		/* range list ID */
#define p_nval_value		2		/* value list ID */
#define p_nval_string		3		/* string list ID */
#define p_len_range		9		/* Length of a range choice(two DD plus one DB) */
#define p_len_value		5		/* Length of a value choice(one DD plus one DB) */
#define p_len_string		3		/* Length of a string choice(one DW plus one DB) */

/*----------------------------------------------------------------------+
|									|
|  Value block structure						|
|									|
+----------------------------------------------------------------------*/

struct p_value_blk
	{
	unsigned char p_val_num;
	};


/*----------------------------------------------------------------------+
|									|
|  Result block structure						|
|									|
+----------------------------------------------------------------------*/

struct p_result_blk
	{
	unsigned char	P_Type; 		/* Type returned */
	unsigned char	P_Item_Tag;		/* Matched item tag */
	unsigned int	P_SYNONYM_Ptr;		/* pointer to Synonym list returned */
	unsigned long int p_result_buff;	/* result value */
	};

/*----------------------------------------------------------------------+
|									|
|  type 								|
|									|
+----------------------------------------------------------------------*/

#define p_eol			0		/* End of line */
#define p_number		1		/* Number */
#define p_list_idx		2		/* List Index */
#define p_string		3		/* String */
#define p_complex		4		/* Complex */
#define p_file_spec		5		/* File Spec */
#define p_drive 		6		/* Drive */
#define p_date_f		7		/* Date */
#define p_time_f		8		/* Time */
#define p_quoted_string 	9		/* Quoted String */

#define p_no_tag		0x0FF		/* No ITEM_TAG found */

/*----------------------------------------------------------------------+
|									|
|  following return code will be returned in the AX register.		|
|									|
+----------------------------------------------------------------------*/

#define p_no_error		0		/* No error */
#define p_too_many		1		/* Too many operands */
#define p_op_missing		2		/* Required operand missing */
#define p_not_in_sw		3		/* Not in switch list provided */
#define p_not_in_key		4		/* Not in keyword list provided */
#define p_out_of_range		6		/* Out of range specified */
#define p_not_in_val		7		/* Not in value list provided */
#define p_not_in_str		8		/* Not in string list provided */
#define p_syntax		9		/* Syntax error */
#define p_rc_eol		0x0ffff 	/* End of command line */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\chkvdisk.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
; Check for existence of a VDisk header.  Check the beginning of the segment
; addressed by the INT 19 vector, and, if XMS is available to give us
; A20 toggling, check at the 1Mb boundary.  We don't do the latter check
; if we can't do the A20 switch.
;
; Return the size of the VDisk if found.
;

; Checking for a VDISK header at 1Mb is currently disabled.  This is because
; the XMS calls used to access the HMA will cause INT 15 memory to
; be claimed if there are currently no Himem or XMS users, and the MEM
; command shouldn't disturb the memory environment in that way.
; We rely on VDisk allocators to use the INT 19 approach to signal
; their memory usage.  According to Ray Duncan, this may not be
; entirely reliable, but this is probably better than adding the
; code necessary to do lots of INT 15 block moves to interrogate
; the extended memory arena.

CHECKXMS	equ	0		; set to non-zero to enable checking
					; of the HMA for VDisk headers.

.MODEL	SMALL
.CODE

	extrn	_XMM_Installed	:Near
	extrn	_XMM_QueryA20	:Near
	extrn	_XMM_EnableA20	:Near
	extrn	_XMM_DisableA20 :Near

;----------------------------------------------------------------------------
;
; following piece of code will be moved into a para boundary. And the para
; address posted in seg of int 19h vector. Offset of int 19h will point to
; VDint19. This is to protect HMA from apps which use VDISK header method
; to determine free extended memory.
;
; For more details read "power programming" column by Ray Duncan in the
; May 30 1989 issue of PC Magazine (pp 377-388) [USING EXTENDED MEMORY,PART 1]
;
;----------------------------------------------------------------------------
;
StartVDHead	label	byte
;
;-------------- what follows is a dummy device driver header (not used by DOS)
;
		dd	0		; link to next device driver
		dw	8000h		; device attribute
		dw	0		; strategy routine offset
		dw	0		; interrupt routine offset
		db	1		; number of units
		db	7 dup(0)	; reserved area
VDiskSig1	db	'VDISK'

VLEN1		equ	($-offset VDiskSig1)

		db	'  V3.3'	; vdisk label
		db	15 dup (0)	; pad
VDiskEnd1	dw	0		; bits 0-15 of free HMA
		db	11h		; bits 16-23 of free HMA (1M + 64K)

VDInt19:
		db	0eah		; jmp to old vector
OldVDInt19	dd	?		; Saved int 19 vector

EndVDHead	label	byte
;
;
VDiskHMAHead	db	0,0,0		; non-bootable disk
VDiskSig2	db	'VDISK'

VLEN2		equ	($-offset VDiskSig2)

		db	'3.3'		; OEM - signature
		dw	128		; number of bytes/sector
		db	1		; sectors/cluster
		dw	1		; reserved sectors
		db	1		; number of FAT copies
		dw	64		; number of root dir entries
		dw	512		; number of sectors
		db	0feh		; media descriptor
		dw	6		; number of sectors/FAT
		dw	8		; sectors per track
		dw	1		; number of heads
		dw	0		; number of hodden sectors
VDiskEnd2	dw	440h		; Start of free HMA in K (1M+64K)
EndVDiskHMAHead	label	byte
;
;
;----------------------------------------------------------------------------
;
; procedure : IsVDiskInstalled
;
;		Checks for the presence of VDISK header at 1MB boundary
;		& INT 19 vector.  Returns number of Kb used as Vdisk
;
; Inputs  : none
; Outputs : AX = size of VDisk in Kb, 0 if none found
; Uses	  : AX, CX
;
;----------------------------------------------------------------------------
;
		public _CheckVDisk

_CheckVDisk	proc   near
		push	bp
		push	si		; Save regs
		push	di
		push	es
		push	ds

		mov	ax,3519h	; Get Int Vector 19h
		int	21h
					; set registers for CMPS
		mov	di, offset VDiskSig1 - offset StartVDHead
		mov	cx, VLEN1
		push	cs
		pop	ds
		mov	si, offset VDiskSig1
		rep	cmpsb
IF NOT CHECKXMS
		jnz	cvd_NoDisk
ELSE
		jnz	cvd_checkXMS	; jump if we didn't find it
ENDIF

;
; Get the first free address in Kb, and determine the number of Kb used
; above 1Mb.  First free address in a 24-bit address, so divide by 1024
; to get number of Kb
;
		mov	di,offset VDiskEnd1 - offset StartVDHead
		mov	ax,es:[di]+1	; load top 16 bits of end address
		shr	ax,1
		shr	ax,1		; fast divide of 24 bits by 1024
		test	es:[di],03FFh	; check for rounding
		jz	@F
		inc	ax		; round up if needed
@@:
IF NOT CHECKXMS
		jmp	short cvd_End

ELSE
		pop	ds		; clear top of stack
		jmp	short cvd_End	; AX now has size in Kb


;
; Ensure that A20 is on before we check above 1Mb.  If XMS is not
; installed, we punt, and assume no VDisk
;

cvd_checkXMS:
		pop	ds		; get DS again
		call	_XMM_Installed
		or	ax,ax
		jz	cvd_NoDisk	; No XMS, assume no VDisk

;
; Get and save current A20 state, get A20 on
;
		call	_XMM_QueryA20
		push	ax		; save current state
		or	ax,ax		; already on?
		jnz	cvd_A20On	; yes, don't turn it on
		call	_XMM_EnableA20	; turn it on

cvd_A20On:
		push	ds		; save DS again
		mov	ax, 0ffffh
		mov	ds, ax
		mov	si, 10h+(offset VDiskSig2 - offset VDiskHMAHead)
		mov	ax,cs
		mov	es,ax
		mov	di, offset VDiskSig2
		mov	cx, VLEN2
		rep	cmpsb
		jne	@F		; if no header, turn off A20 now
					; get first free address in Kb
		mov	si,offset VDiskEnd2 - offset VDiskHMAHead
		mov	ax,[si]
@@:
		pop	ds		; get original DS again
		pop	ax		; get original A20 state
		pushf			; save result of header check
		or	ax,ax		; was A20 already on?
		jnz	@F		; jump if yes
		call	_XMM_DisableA20 ; else turn it off again

@@:
		popf			; get result of header check
		je	cvd_End 	; jump if present

ENDIF		; CHECKXMS

cvd_NoDisk:
		mov	ax,1024 	; set up to return 0

cvd_End:
		sub	ax,1024 	; discount first 1Mb from first
					; free address to get size in Kb
IF NOT CHECKXMS
		pop	ds
ENDIF
		pop	es
		pop	di
		pop	si
		pop	bp
		ret
_CheckVDisk endp

		end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\xmm.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/*
 *	XMS Driver C Interface Routine Definitions
 *
 */

unsigned	XMM_Installed(void);

long	XMM_Version(void);
long	XMM_RequestHMA(unsigned);
long	XMM_ReleaseHMA(void);
long	XMM_GlobalEnableA20(void);
long	XMM_GlobalDisableA20(void);
long	XMM_EnableA20(void);
long	XMM_DisableA20(void);
long	XMM_QueryA20(void);
long	XMM_QueryLargestFree(void);
long	XMM_QueryTotalFree(void);
long	XMM_AllocateExtended(unsigned);
long	XMM_FreeExtended(unsigned);
long	XMM_MoveExtended(struct XMM_Move *);
long	XMM_LockExtended(unsigned);
long	XMM_UnLockExtended(unsigned);
long	XMM_GetHandleLength(unsigned);
long	XMM_GetHandleInfo(unsigned);
long	XMM_ReallocateExtended(unsigned, unsigned);
long	XMM_RequestUMB(unsigned);
long	XMM_ReleaseUMB(unsigned);

struct	XMM_Move {
	unsigned long	Length;
	unsigned short	SourceHandle;
	unsigned long	SourceOffset;
	unsigned short	DestHandle;
	unsigned long	DestOffset;
};

#define	XMSERROR(x)	(char)((x)>>24)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\_parse.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
page	       60,132
name	       _parse
title	       C to PARSER interface
;-------------------------------------------------------------------
;
;	MODULE: 	_parse
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 parser
;
;	CALLING FORMAT:
;			parse(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

;	extrn	sysparse:far

	public	_parse

;-------------------------------------------------------------------
;FarSW	 equ	 0	 ; make sysparse be a NEAR proc
;TimeSW  equ	 0	 ; Check time format
;FileSW  equ	 0	 ; Check file specification
;CAPSW	 equ	 0	 ; Perform CAPS if specified
;CmpxSW  equ	 0	 ; Check complex list
;NumSW	 equ	 1	 ; Check numeric value
;KeySW	 equ	 0	 ; Support keywords
;SwSW	 equ	 1	 ; Support switches
;Val1SW  equ	 1	 ; Support value definition 1
;Val2SW  equ	 1	 ; Support value definition 2
;Val3SW  equ	 0	 ; Support value definition 3
;DrvSW	 equ	 0	 ; Support drive only format
;QusSW	 equ	 0	 ; Support quoted string format
;-------------------------------------------------------------------




_TEXT	SEGMENT BYTE PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT WORD PUBLIC 'BSS'
_BSS	ENDS


DGROUP	GROUP	CONST, _BSS, _DATA


_DATA	segment word public 'DATA'

	assume	cs:DGROUP
	assume	ss:dgroup

	public	SysParse

;-------------------------------------------------------------------
.xlist
include version.inc
include parse.asm		; include the parser
.list
;-------------------------------------------------------------------

		public	CallParser
CallParser	proc	far

	push	ds
	PUSH	ES

	push	cs
	pop	ds
	assume	ds:DGROUP

	push	cs
	pop	es
	assume	es:DGROUP

	nop

	call	SysParse

	POP	ES
	pop	ds

	ret

CallParser	endp



_DATA	ends

_TEXT	segment byte public 'CODE'

	ASSUME	CS:_TEXT
	ASSUME	DS:DGROUP
	ASSUME	ES:NOTHING
	ASSUME	SS:DGROUP

_parse	proc	near

	push	bp		; save user's base pointer
	mov	bp,sp		; set bp to current sp
	push	di		; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4]	; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]	; load di
	push	ax		; the di value from inregs is now on stack

	mov	ax,[di+00]	; get inregs.x.ax
	mov	bx,[di+02]	; get inregs.x.bx
	mov	cx,[di+04]	; get inregs.x.cx
	mov	dx,[di+06]	; get inregs.x.dx
	mov	si,[di+08]	; get inregs.x.si
	pop	di		; get inregs.x.di from stack

	push	bp		; save base pointer

;-------------------------------------------------------------------
;-------------------------------------------------------------------

	call	CallParser	; call the parser

;-------------------------------------------------------------------
;-------------------------------------------------------------------

	pop	bp		; restore base pointer
	push	di		; the di value from call is now on stack
	mov	di,[bp+6]	; fix di (arg 1)

	mov	[di+00],ax	; load outregs.x.ax
	mov	[di+02],bx	; load outregs.x.bx
	mov	[di+04],cx	; load outregs.x.cx
	mov	[di+06],dx	; load outregs.x.dx
	mov	[di+08],si	; load outregs.x.si

	xor	ax,ax		; clear ax
	lahf			; get flags into ax
	mov	[di+0ch],ax	; load outregs.x.cflag

	pop	ax		; get di from stack
	mov	[di+0ah],ax	; load outregs.x.di

;-------------------------------------------------------------------

	pop	si		; restore registers
	pop	di
	mov	sp,bp		; restore sp
	pop	bp		; restore user's bp
	ret

_parse	endp

_TEXT	ends			; end code segment
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\submsg.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/* SUBMSG.C - Message retriever interface functions for MEM command.
*/

#include "ctype.h"
#include "conio.h"			/* need for kbhit prototype */
#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "version.h"			/* MSKK02 07/18/89 */
#include "mem.h"

/**/


/************************************************************************/
/* SUB0_MESSAGE 		- This routine will print only those	*/
/*				  messages that do not require a	*/
/*				  a sublist.				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub0_Message(Msg_Num,Handle,Message_Type)					     /* print messages with no subs	     */

int		Msg_Num;
int		Handle;
unsigned char	Message_Type;
										/*     extended, parse, or utility	*/
	{
	InRegs.x.ax = Msg_Num;							/* put message number in AX		*/
	InRegs.x.bx = Handle;							/* put handle in BX			*/
	InRegs.x.cx = No_Replace;						/* no replaceable subparms		*/
	InRegs.h.dl = No_Input; 						/* no keyboard input			*/
	InRegs.h.dh = Message_Type;						/* type of message to display		*/
	sysdispmsg(&InRegs,&OutRegs);					       /* display the message		       */

	return;
	}


/************************************************************************/
/* SUB1_MESSAGE 		- This routine will print only those	*/
/*				  messages that require 1 replaceable	*/
/*				  parm. 				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Parm	- pointer to parm to replace		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub1_Message(Msg_Num,Handle,Message_Type,Replace_Parm)

int		Msg_Num;
int		Handle;
unsigned char	Message_Type;
										/*     extended, parse, or utility	*/
unsigned long int    *Replace_Parm;						/* pointer to message to print		*/

{


	{

	sublist[1].value     = (unsigned far *)Replace_Parm;
	sublist[1].size      = Sublist_Length;
	sublist[1].reserved  = Reserved;
	sublist[1].id	     = 1;
	sublist[1].flags     = Unsgn_Bin_DWord+Right_Align;
	sublist[1].max_width = 10;
	sublist[1].min_width = 10;
	sublist[1].pad_char  = Blank;

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt1;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}


/************************************************************************/
/* SUB2_MESSAGE 		- This routine will print only those	*/
/*				  messages that require 2 replaceable	*/
/*				  parms.				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Parm1 - pointer to parm to replace		*/
/*		  Replace_Parm2 - pointer to parm to replace		*/
/*		  Replace_Parm3 - pointer to parm to replace		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub2_Message(Msg_Num,Handle,Message_Type,
	     Replace_Parm1,
	     Replace_Message1)

int		Msg_Num;
int		Handle;
unsigned char	Message_Type;
int		Replace_Message1;
										/*     extended, parse, or utility	*/
char	*Replace_Parm1; 							/* pointer to message to print		*/
{


	{
		switch(Msg_Num)
			{
			case	DeviceLineMsg:

				sublist[1].value     = (unsigned far *)Replace_Parm1;
				sublist[1].size      = Sublist_Length;
				sublist[1].reserved  = Reserved;
				sublist[1].id	     = 1;
				sublist[1].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[1].max_width = 0x0008;
				sublist[1].min_width = 0x0008;
				sublist[1].pad_char  = Blank;

				InRegs.x.ax = Replace_Message1;
				InRegs.h.dh = Message_Type;
				sysgetmsg(&InRegs,&SegRegs,&OutRegs);

				FP_OFF(sublist[2].value)    = OutRegs.x.si;
				FP_SEG(sublist[2].value)    = SegRegs.ds;
				sublist[2].size      = Sublist_Length;
				sublist[2].reserved  = Reserved;
				sublist[2].id	     = 2;
				sublist[2].flags     = Char_Field_ASCIIZ+Right_Align;
				sublist[2].max_width = 00;
				sublist[2].min_width = 10;
				sublist[2].pad_char  = Blank;
				break;
			}

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt2;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}

/************************************************************************/
/* SUB3_MESSAGE 		- This routine will print only those	*/
/*				  messages that require 3 replaceable	*/
/*				  parms.				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Parm1 - pointer to parm to replace		*/
/*		  Replace_Parm2 - pointer to parm to replace		*/
/*		  Replace_Parm3 - pointer to parm to replace		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub3_Message(Msg_Num,Handle,Message_Type,
	     Replace_Parm1,
	     Replace_Parm2,
	     Replace_Message1)

int		  Msg_Num;
int		  Handle;
unsigned char	  Message_Type;
char		  *Replace_Parm1;
unsigned long int *Replace_Parm2;
int		  Replace_Message1;
										/*     extended, parse, or utility	*/
{


	{
		switch(Msg_Num)
			{
			case	DriverLineMsg:

				sublist[1].value     = (unsigned far *)Replace_Parm1;
				sublist[1].size      = Sublist_Length;
				sublist[1].reserved  = Reserved;
				sublist[1].id	     = 1;
				sublist[1].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[1].max_width = 0x0008;
				sublist[1].min_width = 0x0008;
				sublist[1].pad_char  = Blank;

				sublist[2].value     = (unsigned far *)Replace_Parm2;
				sublist[2].size      = Sublist_Length;
				sublist[2].reserved  = Reserved;
				sublist[2].id	     = 2;
				sublist[2].flags     = Bin_Hex_DWord+Right_Align;
				sublist[2].max_width = 0x0006;
				sublist[2].min_width = 0x0006;
				sublist[2].pad_char  = 0x0030;

				InRegs.x.ax = Replace_Message1;
				InRegs.h.dh = Message_Type;
				sysgetmsg(&InRegs,&SegRegs,&OutRegs);

				FP_OFF(sublist[3].value)    = OutRegs.x.si;
				FP_SEG(sublist[3].value)    = SegRegs.ds;
				sublist[3].size      = Sublist_Length;
				sublist[3].reserved  = Reserved;
				sublist[3].id	     = 3;
				sublist[3].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[3].max_width = 00;
				sublist[3].min_width = 10;
				sublist[3].pad_char  = Blank;
				break;

			case	HandleMsg:
				sublist[1].value     = (unsigned far *)Replace_Parm1;
				sublist[1].size      = Sublist_Length;
				sublist[1].reserved  = Reserved;
				sublist[1].id	     = 1;
				sublist[1].flags     = Unsgn_Bin_Byte+Right_Align;
				sublist[1].max_width = 0x0009;
				sublist[1].min_width = 0x0009;
				sublist[1].pad_char  = Blank;

				sublist[2].value     = (unsigned far *)Replace_Parm2;
				sublist[2].size      = Sublist_Length;
				sublist[2].reserved  = Reserved;
				sublist[2].id	     = 2;
				sublist[2].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[2].max_width = 0x0008;
				sublist[2].min_width = 0x0008;
				sublist[2].pad_char  = Blank;

				InRegs.x.ax = Replace_Message1;
				InRegs.h.dh = Message_Type;
				sysgetmsg(&InRegs,&SegRegs,&OutRegs);

				FP_OFF(sublist[3].value)    = OutRegs.x.si;
				FP_SEG(sublist[3].value)    = SegRegs.ds;
				sublist[3].size      = Sublist_Length;
				sublist[3].reserved  = Reserved;
				sublist[3].id	     = 3;
				sublist[3].flags     = Bin_Hex_DWord+Right_Align;
				sublist[3].max_width = 00;
				sublist[3].min_width = 10;
				sublist[3].pad_char  = Blank;
				break;

			}

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt3;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}


/************************************************************************/
/* SUB4_MESSAGE 		- This routine will print only those	*/
/*				  messages that require 4 replaceable	*/
/*				  parms.				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Parm1 - pointer to parm to replace		*/
/*		  Replace_Parm2 - pointer to parm to replace		*/
/*		  Replace_Parm3 - pointer to parm to replace		*/
/*		  Dynamic_Parm	- parm number to use as replaceable	*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub4_Message(Msg_Num,Handle,Message_Type,
	     Replace_Value1,
	     Replace_Message1,
	     Replace_Value2,
	     Replace_Message2)

int			Msg_Num;
int			Handle;
unsigned char		Message_Type;
unsigned long int	*Replace_Value1;
int			Replace_Message1;
unsigned long int	*Replace_Value2;
int			Replace_Message2;
										/*     extended, parse, or utility	*/
{


	{
		switch(Msg_Num)
			{
			case	MainLineMsg:

				sublist[1].value     = (unsigned far *)Replace_Value1;
				sublist[1].size      = Sublist_Length;
				sublist[1].reserved  = Reserved;
				sublist[1].id	     = 1;
				sublist[1].flags     = Bin_Hex_DWord+Right_Align;
				sublist[1].max_width = 06;
				sublist[1].min_width = 06;
				sublist[1].pad_char  = 0x0030;

				InRegs.x.ax	   = Replace_Message1;
				InRegs.h.dh	   = Message_Type;
				sysgetmsg(&InRegs,&SegRegs,&OutRegs);

				FP_OFF(sublist[2].value)    = OutRegs.x.si;
				FP_SEG(sublist[2].value)    = SegRegs.ds;
				sublist[2].size      = Sublist_Length;
				sublist[2].reserved  = Reserved;
				sublist[2].id	     = 2;
				sublist[2].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[2].max_width = 0x0008;
				sublist[2].min_width = 0x0008;
				sublist[2].pad_char  = Blank;

				sublist[3].value     = (unsigned far *)Replace_Value2;
				sublist[3].size      = Sublist_Length;
				sublist[3].reserved  = Reserved;
				sublist[3].id	     = 3;
				sublist[3].flags     = Bin_Hex_DWord+Right_Align;
				sublist[3].max_width = 06;
				sublist[3].min_width = 06;
				sublist[3].pad_char  = 0x0030;

				InRegs.x.ax = Replace_Message2;
				InRegs.h.dh = Message_Type;
				sysgetmsg(&InRegs,&SegRegs,&OutRegs);

				FP_OFF(sublist[4].value)    = OutRegs.x.si;
				FP_SEG(sublist[4].value)    = SegRegs.ds;
				sublist[4].size      = Sublist_Length;
				sublist[4].reserved  = Reserved;
				sublist[4].id	     = 4;
				sublist[4].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[4].max_width = 0;
				sublist[4].min_width = 10;
				sublist[4].pad_char  = Blank;
				break;
			}

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt4;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}



/************************************************************************/
/* SUB4a_MESSAGE		- This routine will print only those	*/
/*				  messages that require 4 replaceable	*/
/*				  parms.				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Parm1 - pointer to parm to replace		*/
/*		  Replace_Parm2 - pointer to parm to replace		*/
/*		  Replace_Parm3 - pointer to parm to replace		*/
/*		  Dynamic_Parm	- parm number to use as replaceable	*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub4a_Message(Msg_Num,Handle,Message_Type,
	     Replace_Value1,
	     Replace_Message1,
	     Replace_Value2,
	     Replace_Message2)

int			Msg_Num;
int			Handle;
unsigned char		Message_Type;
unsigned long int	*Replace_Value1;
char			*Replace_Message1;
unsigned long int	*Replace_Value2;
char			*Replace_Message2;

{


	{
		switch(Msg_Num)
			{
			case	MainLineMsg:

				sublist[1].value     = (unsigned far *)Replace_Value1;
				sublist[1].size      = Sublist_Length;
				sublist[1].reserved  = Reserved;
				sublist[1].id	     = 1;
				sublist[1].flags     = Bin_Hex_DWord+Right_Align;
				sublist[1].max_width = 06;
				sublist[1].min_width = 06;
				sublist[1].pad_char  = 0x0030;

				sublist[2].value     = (unsigned far *)Replace_Message1;
				sublist[2].size      = Sublist_Length;
				sublist[2].reserved  = Reserved;
				sublist[2].id	     = 2;
				sublist[2].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[2].max_width = 0x0008;
				sublist[2].min_width = 0x0008;
				sublist[2].pad_char  = Blank;

				sublist[3].value     = (unsigned far *)Replace_Value2;
				sublist[3].size      = Sublist_Length;
				sublist[3].reserved  = Reserved;
				sublist[3].id	     = 3;
				sublist[3].flags     = Bin_Hex_DWord+Right_Align;
				sublist[3].max_width = 06;
				sublist[3].min_width = 06;
				sublist[3].pad_char  = 0x0030;

				sublist[4].value     = (unsigned far *)Replace_Message2;
				sublist[4].size      = Sublist_Length;
				sublist[4].reserved  = Reserved;
				sublist[4].id	     = 4;
				sublist[4].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[4].max_width = 0;
				sublist[4].min_width = 10;
				sublist[4].pad_char  = Blank;
				break;
			}

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt4;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}


/************************************************************************/
/* EMSPrint			- This routine will print the message	*/
/*				  necessary for EMS reporting.		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void EMSPrint(Msg_Num,Handle,Message_Type,
	     Replace_Value1,
	     Replace_Message1,
	     Replace_Value2)

int			Msg_Num;
int			Handle;
unsigned char		Message_Type;
int			*Replace_Value1;
char			*Replace_Message1;
unsigned long int	*Replace_Value2;
										/*     extended, parse, or utility	*/
{

	{
	sublist[1].value     = (unsigned far *)Replace_Value1;
	sublist[1].size      = Sublist_Length;
	sublist[1].reserved  = Reserved;
	sublist[1].id	     = 1;
	sublist[1].flags     = Unsgn_Bin_Word+Right_Align;
	sublist[1].max_width = 03;
	sublist[1].min_width = 03;
	sublist[1].pad_char  = Blank;

	sublist[2].value     = (unsigned far *)Replace_Message1;
	sublist[2].size      = Sublist_Length;
	sublist[2].reserved  = Reserved;
	sublist[2].id	     = 2;
	sublist[2].flags     = Char_Field_ASCIIZ+Left_Align;
	sublist[2].max_width = 0x0008;
	sublist[2].min_width = 0x0008;
	sublist[2].pad_char  = Blank;

	sublist[3].value     = (unsigned far *)Replace_Value2;
	sublist[3].size      = Sublist_Length;
	sublist[3].reserved  = Reserved;
	sublist[3].id	     = 3;
	sublist[3].flags     = Bin_Hex_DWord+Right_Align;
	sublist[3].max_width = 06;
	sublist[3].min_width = 06;
	sublist[3].pad_char  = 0x0030;

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt3;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}

/* M003 BEGIN - output procs for C switch */
/************************************************************************/
/* SUBC4_MESSAGE		- This routine will print only those	*/
/*				  messages that require 4 replaceable	*/
/*				  parms.(for Classify Switch)		*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Message1 - pointer to a Replacement message	*/
/*		  Replace_Value1 - pointer to parm to replace		*/
/*		  Replace_Message2 - pointer to a Replacement message	*/
/*		  Replace_Value2 - pointer to parm to replace		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void SubC4_Message(Msg_Num,Handle,
	     Replace_Message1,Msg_Type,
	     Replace_Value1,
	     Replace_Message2)

int			Msg_Num;
int			Handle,Msg_Type;
unsigned long int	*Replace_Value1;
char			*Replace_Message1,*Replace_Message2;

{

	switch(Msg_Type)
		{
		case	IbmdosMsg:
		case	CFreeMsg:
		case	SystemMsg:
			InRegs.x.ax = Msg_Type;
			InRegs.h.dh = Utility_Msg_Class;
			sysgetmsg(&InRegs,&SegRegs,&OutRegs);
			FP_OFF(sublist[1].value)    = OutRegs.x.si;
			FP_SEG(sublist[1].value)    = SegRegs.ds;
			break;
		default:
			sublist[1].value = (unsigned far *) Replace_Message1;
			break;
	}
	sublist[1].size      = Sublist_Length;
	sublist[1].reserved  = Reserved;
	sublist[1].id	     = 1;
	sublist[1].flags     = Char_Field_ASCIIZ+Left_Align;
	sublist[1].max_width = 0x0008;
	sublist[1].min_width = 0x0008;
	sublist[1].pad_char  = Blank;

	sublist[2].value     = (unsigned far *)Replace_Value1;
	sublist[2].size      = Sublist_Length;
	sublist[2].reserved  = Reserved;
	sublist[2].id	     = 2;
	sublist[2].flags     = Unsgn_Bin_DWord+Right_Align;
	sublist[2].max_width = 10;
	sublist[2].min_width = 10;
	sublist[2].pad_char  = Blank;

	sublist[3].value     = (unsigned far *) Replace_Message2;
	sublist[3].size      = Sublist_Length;
	sublist[3].reserved  = Reserved;
	sublist[3].id	     = 3;
	sublist[3].flags     = Char_Field_ASCIIZ+Left_Align;
	sublist[3].max_width = 0x0009;
	sublist[3].min_width = 0x0009;
	sublist[3].pad_char  = Blank;

	sublist[4].value     = (unsigned far *)Replace_Value1;
	sublist[4].size      = Sublist_Length;
	sublist[4].reserved  = Reserved;
	sublist[4].id	     = 4;
	sublist[4].flags     = Bin_Hex_DWord+Right_Align;
	sublist[4].max_width = 06;
	sublist[4].min_width = 06;
	sublist[4].pad_char  = Blank;


	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt4;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Utility_Msg_Class;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	return;
}
/************************************************************************/
/* SUBC2_MESSAGE 		- This routine will print only those	*/
/*				  messages that require 2 replaceable	*/
/*				  parms (for Classify Switch).		*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Replace_Parm1 - pointer to parm to replace		*/
/*		  Replace_Message1 - pointer to replace message 	*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void SubC2_Message(Msg_Num,Handle, Replace_Parm1,
	     Replace_Message1)

int		Msg_Num;
int		Handle;
unsigned long int *Replace_Parm1;
char *Replace_Message1;
{

	sublist[1].value     = (unsigned far *)Replace_Parm1;
	sublist[1].size      = Sublist_Length;
	sublist[1].reserved  = Reserved;
	sublist[1].id	     = 1;
	sublist[1].flags     = Unsgn_Bin_DWord+Right_Align;
	sublist[1].max_width = 10;
	sublist[1].min_width = 10;
	sublist[1].pad_char  = Blank;

	sublist[2].value     = (unsigned far *)Replace_Message1;
	sublist[2].size      = Sublist_Length;
	sublist[2].reserved  = Reserved;
	sublist[2].id	     = 2;
	sublist[2].flags     = Char_Field_ASCIIZ+Left_Align;
	sublist[2].max_width = 0x0009;
	sublist[2].min_width = 0x0009;
	sublist[2].pad_char  = Blank;

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt2;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Utility_Msg_Class;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	return;
}
/* M003 END */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\_msgret.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
page	       60,132
name	       _msgret
title	       C to Message Retriever
;-------------------------------------------------------------------
;
;	MODULE: 	_msgret
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 message retriever
;
;	CALLING FORMAT:
;			msgret(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AN000;

	MSG_UTILNAME <MEM>		;IDENTIFY THE COMPONENT 		;AN000;

;-------------------------------------------------------------------
;-------------------------------------------------------------------


_TEXT	SEGMENT BYTE PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT WORD PUBLIC 'BSS'
_BSS	ENDS

DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME	CS: DGROUP, DS: DGROUP, SS: DGROUP, ES: NOTHING

	public	data_sysloadmsg
	public	data_sysdispmsg
	public	data_sysgetmsg

_DATA	SEGMENT

	MSG_SERVICES <MSGDATA>
	MSG_SERVICES <LOADmsg,FARmsg>
	MSG_SERVICES <DISPLAYmsg,GETmsg,CHARmsg,NUMmsg>
	MSG_SERVICES <MEM.CLA,MEM.CLB,MEM.CL1,MEM.CL2,MEM.CTL>			     ;AN000;


data_sysloadmsg proc far

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------

	call	sysloadmsg		; call the message retriever

;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6+4]		  ; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

data_sysloadmsg endp


data_sysdispmsg proc far

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------

	call	sysdispmsg

;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6+4]		  ; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

data_sysdispmsg endp


data_sysgetmsg	proc far

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------

	call	sysgetmsg		; call the message retriever

;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6+4]		  ; fix di (arg 1)

	push	ax			; save ax
	mov	[di+00],es		; load segregs.es
	mov	[di+06],ds		; load outregs.ds
	pop	ax			; restore ax

	pop	di			; restore di
	push	di			; save it
	mov	di,[bp+8+4]		  ; fix di (arg 2)
	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

data_sysgetmsg	endp

include msgdcl.inc

_DATA	ends			; end code segment

_TEXT	SEGMENT

	assume cs:_TEXT

	public	_sysdispmsg
	public	_sysloadmsg
	public	_sysgetmsg

_sysdispmsg	proc	near
		call	data_sysdispmsg
		ret
_sysdispmsg	endp

_sysloadmsg	proc	near
		call	data_sysloadmsg
		ret
_sysloadmsg	endp

_sysgetmsg	proc	near
		call	data_sysgetmsg
		ret
_sysgetmsg	endp

_TEXT	ENDS
	end


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\doesmac.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

CallInstall MACRO   name,mpx,fn,save,restore
BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM
.xcref	break
IF Installed
    IFNB    <save>
	SaveReg <save>
    ENDIF
	MOV	AX,(mpx SHL 8) + fn
	INT	2Fh
    IFNB    <restore>
	RestoreReg  <restore>
    ENDIF
ELSE
	Invoke	name
ENDIF
ENDM

BREAK <SaveReg - save a set of registers>

SaveReg MACRO	reglist 		;; push those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth + 1
	PUSH	reg
ENDM
ENDM
.xcref	SaveReg

BREAK <RestoreReg - unsave some registers>

RestoreReg  MACRO   reglist		;; pop those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth - 1
	POP	reg
ENDM
ENDM
.xcref	RestoreReg

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\mem\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\msg2nls.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

BADDOS equ 1
ALLINS equ 2
FNF    equ 3
FLAG1  equ LEFT_ALIGN+CHAR_FIELD_ASCIIZ

;*****************************************************************************
;******************************************************************************
;		VALUES FOR THE MSG_DESC CONTROL BLOCK
ONE_SUBS       EQU   1		   ;ONE VARIABLE FIELD IN MESSAGE
TWO_SUBS       EQU   2		   ;TWO VARIABLE FIELDS IN MESSAGE
THREE_SUBS     EQU   3		   ;THREE VARIABLE FIELDS IN MESSAGE
CLASS_1        EQU   EXT_ERR_CLASS ;CLASS 1 (DOS EXTENDED ERRORS)
CLASS_2        EQU   PARSE_ERR_CLASS ;CLASS 2 (PARSE ERRORS)
CLASS_A        EQU   UTILITY_MSG_CLASS ;CLASS A TYPE MESSAGE

;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.

;MSG_DESC	   STRUC
;MSG_NUM	   DW	 0	    ;MESSAGE NUMBER (TO AX)
;MSG_HAND	   DW	 0	     ;HANDLE OF OUTPUT DEVICE (TO BX)
;MSG_SUBLIST	   Dd	 0	    ;POINTER TO SUBLIST (TO SI)
;MSG_COUNT	   DW	 0	    ;SUBSTITUTION COUNT (TO CX)
;MSG_CLASS	   DB	 0	    ;MESSAGE CLASS (IN HIGH BYTE, TO DH)
;				    ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
;MSG_DESC	   ENDS
;		VALUES FOR THE SUBLIST CONTROL BLOCK
PC_ID_0        EQU   0		   ;ID OF " - " TRAILER TO MESSAGE
PC_ID_1        EQU   1		   ;ID OF PERCENT VARIABLE FIELD
PC_ID_2        EQU   2		   ;ID OF PERCENT VARIABLE FIELD
PC_ID_3        EQU   3		   ;ID OF PERCENT VARIABLE FIELD
MAX_0	       EQU   0		   ;MAXIMUM WIDTH OF STRING FIELD (0=NO LIMIT)
MIN_1	       EQU   1		   ;MINIMUM WIDTH OF STRING FIELD
ID_0	       EQU   0

;Message PARM LIST Structure
  PARMLIST1 LABEL   BYTE  ;PARM LIST
       ;(File not found - 'PATH_SPEC')
       DB  11	      ;PARMLIST size
       DB  0	      ;reserved
       DD  PATH_SPEC
       DB  id_0       ;; n of %n
       DB  FLAG1      ;; data type
       DB  max_0      ;;max width
       DB  min_1      ;;min width
       DB  PAD_CHAR   ;;char defined to be space


  PARMLIST2 LABEL   BYTE  ;PARM LIST
       ;(NLSFUNC already installed)
       DB  11	      ;PARMLIST size
       DB  0	      ;reserved
       DD  UTILITY    ;; ptr to data
       DB  1	      ;; n of %n
       DB  FLAG1      ;; data type
       DB  0	      ;;max width
       DB  1	      ;;min width
       DB  PAD_CHAR   ;;char defined

  PARMLIST3 LABEL   BYTE  ;PARM LIST
       ;(Invalid parameter 'PATH_SPEC')
       DB  11	      ;PARMLIST size
       DB  0	      ;reserved
       DD  PATH_SPEC   ;; ptr to data
       DB  id_0       ;; n of %n
       DB  FLAG1      ;; data type
       DB  0	      ;;max width
       DB  1	      ;;min width
       DB  PAD_CHAR   ;;char defined

;		THE NEXT GROUP ARE ALL CLASS "1" MESSAGES

;		PUBLIC MSGNUM_EXTERR
;MSGNUeM_EXTERR  MSG_DESC <FNF,STDERR,,,CLASS_1> ;ALL EXTENDED DOS ERRORS
				   ;File not found - %0

;		THE NEXT GROUP ARE ALL CLASS "2" MESSAGES

;		PUBLIC MSGNUM_PARSE ;SO PARSE DRIVER CAN FIND IT
;MSGNUM_PARSE	MSG_DESC <,STDERR,,,CLASS_2> ;ALL PARSING ERRORS BUT INVALID
						;SYNTAX
				   ;ERROR NUMBER WILL NEED TO BE FILLED IN

;		THE NEXT GROUP ARE ALL CLASS "A" MESSAGES
;		THESE ARE THE "CANNED" MESSAGES ALWAYS PRESENT

;		PUBLIC MSGNUM_VER
;MSGNUM_VER	MSG_DESC <1,STDERR> ;"Incorrect DOS Version"

;		PUBLIC MSGNUM_INST
;MSGNUM_INST	MSG_DESC <ALLINS,STDERR> ;"%1 - already installed"
;end of MSGHAN.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\nlsparm.asm ===
PAGE	,132			;
	TITLE	NLSPARM.SAL - NLSFUNC  SYSTEM COMMAND LINE PARSER

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: NLSPARM.SAL
;
; DESCRIPTIVE NAME: Include the DOS system PARSER in the SEGMENT
;		    configuration expected by the modules of NLSFUNC.
;
;FUNCTION: The common code of the DOS command line PARSER is optimized by
;	   the setting of certain switches that cause the conditional
;	   assembly of only the required portions of the common PARSER.
;	   The segment registers are ASSUMED according to the type .EXE.
;
; ENTRY POINT: SYSPARSE, near
;
; INPUT:
;	ES - has seg id of the SEGMENT
;	     that contains the input control blocks,
;	     defined below.
;
;	DI - offset into ES of the PARMS INPUT BLOCK
;
;	DS - has seg id of the SEGMENT
;	     that contains the DOS input COMMAND
;	     string, which is originally presented at 81h
;	     in the PSP.
;
;	SI - offset into DS of the text of the DOS input COMMAND string
;	     as originally presented at 81H in the PSP.
;
;	DX - zero
;
;	CX - ordinal value, intially zero, updated on each subsequent call
;	     to the value returned in CX on the previous call.
;
;	CS - points to the segment containing the
;	     INCLUDE PARSE.SAL statement
;
;	DS - also points to the segment containing the INCLUDE
;	     PARSE.SAL statement.
;
; EXIT-NORMAL:	Output registers:
;	 AX - return code:
;	    RC_No_Error     equ     0	 ; No error
;	    RC_EOL	    equ     -1	 ; End of command line
;
;	 DX - Offset into ES of the selected RESULT BLOCK.
;	 BL - terminated delimiter code
;	 CX - new operand ordinal
;	 SI - set past scanned operand
;
; EXIT-ERROR: Output registers:
;	 AX - return code:
;	    RC_Too_Many     equ     1	 ; Too many operands
;	    RC_Op_Missing   equ     2	 ; Required operand missing
;	    RC_Not_In_SW    equ     3	 ; Not in switch list provided
;	    RC_Not_In_Key   equ     4	 ; Not in keyword list provided
;	    RC_Out_Of_Range equ     6	 ; Out of range specified
;	    RC_Not_In_Val   equ     7	 ; Not in value list provided
;	    RC_Not_In_Str   equ     8	 ; Not in string list provided
;	    RC_Syntax	    equ     9	 ; Syntax error
;
; INTERNAL REFERENCES:
;    ROUTINES: SYSPARSE:near (INCLUDEd in PARSE.SAL)
;
;    DATA AREAS: none
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
;    DATA AREAS: control blocks pointed to by input registers.
;
; NOTES:
;	 This module should be processed with the ASMUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT  NLSPARM,NUL;
;
;	 To assemble these modules, the sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 NLSFUNC.SAL
;
; REVISION HISTORY: A000 Version 4.00: add PARSER, System Message Handler,
;
; COPYRIGHT: "The DOS NLSFUNC Utility"
;	     "Version 4.00 (C)Copyright 1988 Microsoft
;	     "Licensed Material - Program Property of Microsoft "
;
;****************** END OF SPECIFICATIONS *****************************
	IF1
	    %OUT    COMPONENT=NLSFUNC, MODULE=NLSPARM.SAL...
	ENDIF
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<MACRO DEFINITION>
; =  =	=  =  =  =  =  =  =  =	=  =

HEADER	MACRO	TEXT
.XLIST
	SUBTTL	TEXT
.LIST
	PAGE
	ENDM

; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<SYSPARSE - SYSTEM COMMAND LINE PARSER>
NLS_DATA SEGMENT BYTE PUBLIC  'DATA'

CAPSW   EQU	1			;SUPPORT FILENAME TBL CAPS
FARSW	EQU	0			;PARSER CALL FAR
FILESW  EQU	1			;CHECK FOR FILESPEC
SWSW	EQU	1			;SUPPORT CHECKING FOR SWITCHES
DATESW	EQU	0			;SUPPRESS DATE CHECKING
TIMESW	EQU	0			;SUPPRESS TIME CHECKING
CMPXSW	EQU	0			;SUPPRESS CHECKING COMPLEX LIST
NUMSW	EQU	0			;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;SUPPRESS KEYWORD SUPPORT
VAL1SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 1
VAL2SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 2
VAL3SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 3
DRVSW	EQU	0			;SUPPORT OF DRIVE ONLY FORMAT
QUSSW	EQU	0			;SUPPRESS SUPPORT OF QUOTED STRING FORMAT

;	 INCLUDE PSDATA.INC		 ;PARSE WORK AREA & EQUATES

NLS_DATA ENDS

NLS_INIT_CODE SEGMENT BYTE PUBLIC 'CODE'

;	 ASSUME  CS:NLS_INIT_CODE,DS:NLS_DATA
	 ASSUME  CS:NLS_INIT_CODE,DS:nothing ; tsuneo

;	 mov	 ax,NLS_DATA
;	 mov	 ds,ax

;INCSW	 equ	 0



	include version.inc
	INCLUDE PARSE.ASM
       PUBLIC  SYSPARSE

NLS_INIT_CODE ENDS
;NLS_DATA ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\nlsfunc.asm ===
PAGE	,132  ;
	TITLE	NLSFUNC - GET/SET CP & COUNTRY INFO   CHCP SUPPORT

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;**************************************************************************
;This is the NLSFUNC int2f command that supports the INT21h functions
;Get_Extended Country Information and the Set_codepage...
;NLSFUNC will read the COUNTRY.SYS information from disk , store the
;data in a buffer , then move the information into a buffer
;area specified by DOS.
;d:NLSFUNC {path}
;									 *
;CHECKINSTALL:								 *
;CheckRequest proc							 *
;	  If installed previously					 *
;	     report back error already installed and exit		 *
;	  otherwise  goto install					 *
;Checkrequest endp							 *
;*************************************************************************
;				NEW CODE				 *
;*************************************************************************
subttl get extended country data
page
;
;***************************************
;*  Process_Path Procedure	       *
;***************************************
;*  CALL SYSLOADMSG		       *
;*  Do DOS Version check	       *
;*  If ne X.X then (carry set)		*
;*   CALL SYSDISPLAY_MSG	       *
;*   DISPLAY_MSG(Message number 001)   *
;*    (001 - Incorrect DOS Version)    *
;*    (Class 3 - Utility Msg)	       *
;*   exit			       *
;*  else			       *
;*   Establish addressability	       *
;*   to command line parms (DS:SI)     *
;*   Establish addressability to PARM  *
;*   control block	   (ES:DI)     *
;*				       *
;*     Call SYSPARSE for filename      *
;*     GET Parse Block results	       *
;*     IF PARSE_ERROR		       *
;*	  CALL SYSDISPLAY_MSG (Class 2)*
;*	  DISPLAY_MSG = PARSE_NUM      *
;*     ELSE			       *
;*	  SUCCESSFUL_PARSE (0 or -1)   *
;*     ENDIFELSE		       *
;*     GET_PARSE_RESULTS Path_Spec     *
;*     IF No path exist then	       *
;*	  assume current directory     *
;*	  assume default filename      *
;*     ENDIF			       *
;*     IF No Drive exist then	       *
;*	  Use Current Drive	       *
;*     ENDIF			       *
;*     IF No filename exist then       *
;*	  assume default filename      *
;*	  and concatenate with drive   *
;*     ENDIF			       *
;*     CHECK_PATH		       *
;*     IF PATH EXIST THAN	       *
;*	  INSTALL_NLS	(NLS_RESCODE)  *
;*     ENDIF			       *
;*     ELSE NOT PATH_EXIST THAN        *
;*	  GET_PARSE_RESULTS (Class 3)  *
;*	  PASS_TO_MSGTXT (Message 003) *
;*	  (File not found %1)	       *
;*	  ERR_CODE SET TO 2	       *
;*	  EXIT			       *
;*     ENDIFELSE		       *
;*				       *
;*  INSTALL_NLS 		       *
;*	  CHECK INSTALL FLAG	       *
;*	  IF INSTALLED		       *
;*	     (Class 3)		       *
;*	     PASS_TO_MGSTXT (Msg 002)  *
;*	     %1 already installed      *
;*	  ELSE			       *
;*	     HOOK IN CODE	       *
;*	     TERMINATE & STAY RESIDENT *
;*	  ENDIFELSE		       *
;*				       *
;*				       *
;*   EXIT			       *
;*	 CHECK FOR ERRORCODE	       *
;*	 exit to DOS		       *
;***************************************
;
;INSTALL:
;	  Get the current 2f handler in the chain
;	  make it the next install my handler in the
;	  beginning of the the chain using get interrupt (25)
;	  and set interrupt (35); Once in the chain
;	  terminate and stay resident.
;
;DOS NEEDS ME.......
;
;Install Dos Interface Logic
;     Dos issues Call Install
;	     Establish residency
;	  If Mult Id is mine	(* NLSFUNC*)
;	     CheckInstall Status to see if installed or not
;	  otherwise
;	     jump to the next 2f handler
;CheckInstall
;	  If not installed returns
;	  If installed program is executed  (*NLSFUNC resident portion *)
;*******************************************************************************
;
;Program Logic
;
;     Check to make sure not reserved DOS number in the al
;
;     Go establish which function is to be performed
;
;Sel_Func proc
;	  mov FUNC_CODE,al
;	  case
;	     function code = 0
;	     function code = 1
;	     function code = 2
;	     function code = 3
;	     function code = 4
;	  otherwise error_routine
;	  return
;Sel_Func endp


;funcode0 proc
;INSTALL     NLSFUNC must be installed in mem
;	     return 0FFh that I am installed
;funcode0 endp

;funcode1 proc
;	    (* Means Set codepage and "select" device drivers*)
;	    same at funcode 3 plus device drivers are invoked with the
;	    specified code page.
;funcode1 endp

;funcode2 proc
;	   (* Get_extended_country info issued by DOS not in buffer*)
;	    BP = info_type
;	    call trans_Cty_Data Proc
;	    return
;funcode2 endp

;funcode3 proc
;	    (* Means Set codepage *)
;	    On entry DOS gives me the CODEP in BX & the CC in DX,SIZE in CX
;	     Search for Country.sys file on disk
;	    if file is found	  }BUFFER will exist in code 320 (can be altered)
;		the control buffer = 64 bytes of the buffer
;		the data buffer = 256 bytes of the buffer
;	     call Trans_Cty_Data Proc
;	    otherwise return an error flag
;	     return
;funcode3 endp


;funcode4 proc
;	   (* Get_extended_country info - old 38 call*)
;	    set flag and same as funcode 2
;	    data returned slightly Revised
;funcode4 endp

;	   ****************************
;	    if selected is FUNCTION 1, 3
;	       PassDOS_Data(*ES:DI*)
;	    otherwise FUNCTION 2, 4
;	       Get the INFO ID
;	       Flag that it is function 2
;	       PassUserData(*ES:DI*)
;	    mov NO_ERRORS to ERROR_FLAG
;	    ****************************
;Trans_Cty_Data Proc
;	     Open file(Dos call back 38)
;	     Do an LSEEK to move CTY_INFO into NLSFUNC control buffer 39
;	     Do an LSEEK to move tables into NLSFUNC data buffer 39
;	    if R/W pointer ok on Disk
;	     Read the file(Dos call back 38)
;	     Check to see if it is FUNCTION 1 or FUNCTION 2
;	       Flag if FUNCTION 2
;	       if FUNCTION 2
;		Search for user specified INFO ID
;		until found or report back error to DOS & exit
;		if INFO ID is found
;		   godo move the data and set the counter to zero (entry value)
;
;
;
;
;MOVE_DATA:    Manage transfer from disk to buffer
;	       Check to see if entire entry can fit in to the data
;	       buffer if not read the maximum allowed into buffer
;	       Check to see what is left to read; read until no more
;	       Search for appropriate field in the DOS INFO
;		if found move in info until complete
;		   get the next entry until number of entries is 0
;		otherwise
;		   report to DOS error and exit
;	     loop back to read file until (all entries are Obtained) or (EOF)
;	     Close file handle (Dos call back 40)
;	    otherwise mov 05h to error_flag & jump to error_routine
;
;	    return
;Trans ENDP
;
;
;Error_routine	proc
;	     mov al,error_flag
;	     return
;error_routine	endp
;*******************************************************************************
;**********************************INTRO****************************************
subttl	Revision History
page
;****************************** Revision History *************************** ;
;
; =A  7/29/86  RG   PTM P64
;     Prevent overwrite of DOS monocase routine entry point during
;     transfer of SetCountryInfo.
;     For Get Ext Cty Info, put DOS monocase routine entry point into
;     user buffer.
;
; =B  7/29/86  RG	 PTM P67
;     Correct jump condition in ERROR_ROUTINE of NLSRES_CODE.
;     This prevents exit without COUNTRY.SYS file close.
;
; =C  7/30/86  RG	 PTM P85
;     Preserve ES register in NLSFUNC for IBMDOS.
;
; =D  7/31/86  RG	 PTM P86
;     Corrects information put into user buffer for Get Extended
;     Country Information.
;
; =E  7/31/85  RG	 DCR 18
;     CHCP support.
;
; =F  8/4/86   RG
;     Get Country Info - Revised info from Get Extended Country Info
;
; =G  8/5/86   RG
;     Correct carry set for good exit.
;
; =H  8/5/86   RG
;     Start extended info at length instead of signature.
;
; =FC 8/14/86  FChen
;     Insert code for control buff management and actual length retunred
;
; =I  8/20/86  RG
;     Improve path parameter parsing.
;
; =J  8/22/86  RG
;     Change error codes
;
; =K  8/28/86  RG
;     65 call-get ext cty info	put final csize (# bytes returned)
;     in cx on iret ;
;
; =L  11/7/86  RG
;     Set error to INVALID DATA (13) on no cp/cty match.
;
; =M  05/20/87 CNS
;     Additional re-design for structured code using STRUC
;     PARSER implementation
;     Message Retriever implementation
;     DBCS Support for Environmental Vector recognition (Walk Devices& IOCTL call)
;     Enable the Interrupt when NLSFUNC is loaded PTM ???
;
;AN001; P2685 NLSFUNC should not visit the same device repeatedly. 01/15/88 J.K.
;AN002; P3934 Bad write on sacred DOS area - segmentation incorrect  03/22/88 CNS
;*******************************************************************************
subttl macros
page
PUSHALL       macro  reg1,reg2,reg3			;used to save all
		push reg1				;registers needed
		push reg2				;for DOS interactions
		push reg3
	      endm

POPALL	     macro   reg1,reg2,reg3			;used to restore all
		pop reg3				;for DOS interactions
		pop reg2
		pop reg1
	      endm

;SHOWERR       macro   msg,len_msg
;		 mov	 ah,40h
;		 mov	 bx,2
;		 lea	 dx,msg 			 ;displays error msgs
;		 mov	 cx,len_msg
;		 int	 21h
;		endm


EXTRN		SYSPARSE:NEAR

subttl NLSFUNC data
page
NLS_DATA	SEGMENT byte PUBLIC 'DATA'

;Copyright 1988 Microsoft
;***************************** MSG DATA ************************************
UTILITY 	db	"NLSFUNC",0           ;AC000;
;***************************** MSG DATA ************************************

.xlist
include copyrigh.inc			;AN000;
include struc.inc
include DOESMAC.INC
include MULT.INC
include sf.inc				;AN001;
include DOSCNTRY.INC
include DEVSYM.INC
include SYSMSG.INC			;AN000;
include FUNCDBCS.INC			;AN000;
include MSG2NLS.INC
include FUNCPARM.INC			;AN000;
include version.inc			; MSKK02 07/18/89
MSG_UTILNAME <NLSFUNC>			;AN000;

.list

MSG_OPTIONS_FIRST	equ	300	; first options message line
MSG_OPTIONS_LAST        equ     302     ; last options message line

MULT_NLSFUNC	equ	14h
INSTALLED	equ	0ffh
; nlsfunc function codes
CHG_CODEPAGE	 equ	1
GET_EXT_CTY_INFO equ	2
SET_CODEPAGE	 equ	3
GET_CTY_INFO	 equ	4

INVALID_FUNCTION equ	1		     ;=J
INVALID_DATA	 equ	13		     ;=L
;FILE_NOT_FOUND  equ	2		     ;=J(=L no longer explicitly used)
;TAB		  equ	 9
;CR		  equ	 13
PAD_CHAR	 equ	' '                  ;AN000;
BAD_INVOKE	 equ	65		     ;=E
UPCASE_A	 equ	'A'
BUFFSIZE	 equ	512 ;	      ;AC000;REDUCTION OF ORIGINAL (128 BYTES) TO STORE
LOCATE_INFOTYPE  equ	18	      ;THE DEVICE LIST & THE OLD COUNTRY INFO
CTL_BUFF	 equ	256 ;	      ;AC000;
ID_TAG		 equ	8
DATA_BUFF_LENG	 equ	(BUFFSIZE - CTL_BUFF)
MAXBUFF_FIT	 equ	(BUFFSIZE - (CTL_BUFF + ID_TAG))
DATA_N_ID	 equ	(CTL_BUFF + ID_TAG)
SETCTY_LENG	 equ	38
;SPACE		  equ	 ' '
BACKSLASH	 equ	'\'
PERIOD		 equ	'.'
;COLON		  equ	 ':'
;
;**************** NEW VARIABLE	****************
subttl NLSFUNC data
page
IN_DEX		  equ	 bp			       ;AN000;
FILESPEC_PTR	  equ	 byte ptr ds:[in_dex]	       ;AN000;
FILEVAL 	 equ	0100h	;convert data block after checking for the
				;AN000;
				;drive only to look for the filespec
CL_NUM		 equ	81h	;command line at the PSP
				;AN000;
;**************** NEW VARIABLE	****************
;interrupts
SET_INT 	 equ	25h
GET_INT 	 equ	35h
;
;dos call backs
;dosopen	 equ	38
;dosclose	 equ	39
;lseek		 equ	40
;dosread	 equ	41
;
;NO_ERRORS	 equ	0FFh

;variable definition area
;initialization area

MSG_SERVICES <MSGDATA>
; Replace a bunch of bytes that are storing one byte (0 or 1) for one
; byte where I control each bit.

ID_CHECK_F      equ     00000001b
GET_EXT_F       equ     00000010b
GOOD_PAR_F      equ     00000100b
PARSE_ERR_F     equ     00001000b
EXIT_STAY_F     equ     00010000b
NO_PARMS_F      equ     00100000b
GOOD_PATH_F     equ     01000000b
OPTIONS_SENT_F  equ     10000000b

INFO_FLAG       db      ID_CHECK_F      ;Only ID_CHECK_F set, the rest 0




;ID_CHECK        db      1               ;resident variable re-initialize
ALL_DONE	db	0		;resident variable re-initialize
;GET_EXT         db      0               ;resident variable re-initialize
INFO_ID 	db	0		;resident variable re-initialize
DONT_CLOSE	db	0		;if open or close error,this is set

RES_PARASIZE	dw	0		;adjusted size for terminate & stay func.
ERROR_CODE	db	0		;contains extended error code val
FUNC_CODE	db	0		;save function number
;GOOD_PAR        db      0
;PARSE_ERR       db      0

SI_DOSLOCATE	dw	0
DS_DOSLOCATE	dw	0
SAVEDX		dw	0		;=FC  file offset
SAVECX		dw	0		;=FC
NOFFSET 	dw	2		;=FC
CSIZE		dw	0
CCODE		dw	0
CPAGE		dw	0
;VALID_FUNC      db      0               ;Flag to check for valid function #
;EXIT_STAY       db      0
FILENAME	db     "COUNTRY.SYS",0
PATH_SPEC	db	64 dup(0)	;used to build path parameter
USER_PATH	db	0		;=I
PAR_RETC	dw     0
;NO_PARMS        db     0
;GOOD_PATH       db     0
;OPTIONS_SENT    db      0               ; non-zero if options msg displayed
PATHSEG 	DW     0
SW_SPEC 	dW     0
;LENGTH_HOLD     db     0                  ;dead code
;***CNS
CUR_PTR        DW	0		   ;AN003;; keeps track of parameter position	   ;AN000
OLD_PTR        DW	0		   ;AN003;; keeps track of parameter position	   ;AN000
;***CNS
;********************************************************************************
NLS_BUFFER	db	BUFFSIZE dup (?)  ;NLS BUFFER to transfer data


DATASIZE	equ	$-NLS_DATA

NLS_DATA ENDS

NLS_INIT_CODE	SEGMENT BYTE PUBLIC 'CODE'

		ASSUME CS:NLS_INIT_CODE,DS:NOTHING,ES:NOTHING,SS:NOTHING



INT_2f_NEXT	DD	?	;Chain location.
subttl resident code
page
;**************************** resident portion ********************************

NLSRES_CODE	PROC	NEAR
		cmp	ah,MULT_NLSFUNC 	;Check the mutliplex value
		je	IS_NLSFUNC		;the # is mine
		jmp	dword ptr INT_2F_NEXT	;Chain to* the next handler

IS_NLSFUNC:


		cmp	al,0f8h 	;Make sure AL does not have reserved
					;DOS value 0F8 - 0FFH
		jb	SEL_FUNC	;Select the function code between 0,
					;1,2,3,4

		iret			;return on reserved functions

SEL_FUNC:


		push	es		;=C
		push	ds		;save the user's data segment
		push	si
		push	ds
		push	ax		;save the function value


		mov	ax,NLS_DATA	;so it won't be hosed
		mov	ds,ax		;set the data segment to mine

		ASSUME DS:NLS_DATA

		pop	ax
		pop	DS_DOSLOCATE
		pop	SI_DOSLOCATE

                mov     INFO_FLAG,ID_CHECK_F    ;re-initalize flags
                mov     ALL_DONE,0              ;from resident portion
                mov     DONT_CLOSE,0            ;no open or close error yet

		pushall bx,cx,dx	;save all DOS registers
		pushall bp,si,di	;save all DOS registers
; *************************** CNS **********************************************
		sti			;;AN000;the interrupt for external devices
					;AN000;
; *************************** CNS **********************************************
		mov	FUNC_CODE,al	;save function #
;               or      al,al
;               jnz     FUNCODE_DOSTATE ;state is not 0
                dec     al              ;Tell DOS I am installed (dec 0 = ff)
                js      RES_EXIT        ;state is 0
;               jmp     short RES_EXIT  ;exit


FUNCODE_DOSTATE:
;               dec     al                              ;cmp     al,CHG_CODEPAGE
                jz      FUNCODE3_1                      ;je      FUNCODE3_1
                dec     al                              ;cmp     al,GET_EXT_CTY_INFO
                jz      FUNCODE2                        ;je      FUNCODE2
                dec     al                              ;cmp     al,SET_CODEPAGE
                jz      FUNCODE3_1                      ;je      FUNCODE3_1
                                                        ; If al >= 4 then do 4


FUNCODE4:     ;Get Country Data - old 38 call =F
		mov	bp,1		;set info_id to 1 =F
;               jmp     short FUNCODE2  ;                 =F


FUNCODE2:      ;Get Extended Country Information
		mov	ax,bp		;information requested by the user
		mov	INFO_ID,al
                or      INFO_FLAG,GET_EXT_F ;get extended cty into user buffer
		call	RES_MAIN
		jc	ERROR_ROUTINE

		jmp	short CLOSE_FILE	  ;=E



FUNCODE3_1:    ;Set Codepage/Get Country Information =E
		les	di,dword ptr SI_DOSLOCATE
;		cmp	es:[di].ccDosCodePage,bx	;=E
;		jne	fc3_1_10			;=E
;		cmp	es:[di].ccDosCountry,dx 	;=E
;		jne	fc3_1_10			;=E
;		mov	CPAGE,bx	     ;get the codepage value =E
;		jmp	short fc3_1_20			;=E
;
;fc3_1_10:
		call	RES_MAIN
		jc	ERROR_ROUTINE
		CallInstall Dosclose,multdos,39,<ax,bx,cx,dx,ds,es>,<es,ds,dx,cx,bx,ax> ;close the file
		jc	NO_CLOSE

fc3_1_20:
		cmp	FUNC_CODE,1	       ;=E
		je	FUNCODE1	       ;=E
		mov	al,ALL_DONE	       ;=E
		jmp	short RES_EXIT	       ;=E


FUNCODE1:      ;CHCP - Change Code Page    =E
		call	WALK_DEVICES	    ;=E
		mov	al,ALL_DONE	    ;=E
		jmp	short RES_EXIT	    ;=E

NO_CLOSE:
		mov	ALL_DONE,al	;=J
		inc	DONT_CLOSE

;if an error was detected

ERROR_ROUTINE:
		mov	al,ALL_DONE
		cmp	DONT_CLOSE,1
		je	RES_EXIT
;               jmp     CLOSE_FILE



CLOSE_FILE:				     ;DOS  3eh function close COUNTRY.SYS
		mov	al,ALL_DONE

		CallInstall Dosclose,multdos,39,<ax,bx,cx,dx,ds,es>,<es,ds,dx,cx,bx,ax> ;close the file
		jc	NO_CLOSE
						;clear to let DOS know ok


RES_EXIT:
		popall	bp,si,di	;restore all DOS registers
		popall	bx,cx,dx	;restore all DOS registers

		cmp	FUNC_CODE,GET_EXT_CTY_INFO ;			  =K
		jne	NC_IRET 	;				  =K
                or      al,al           ;if successful 65 call, put size  =K
                jnz     NC_IRET         ;of info returned in CX           =K
		mov	cx,CSIZE	;				  =K

NC_IRET:				;				  =K
		pop	ds		;restore user's data segment  =K moved
		pop	es		;=C			      =K moved
		iret			;Return to DOS


NLSRES_CODE	ENDP
;*******************************END OF NLSRES_CODE******************************
subttl resident main routine
page
;*******************************RES_MAIN****************************************
RES_MAIN	PROC	NEAR

;               mov    VALID_FUNC,1     ;function exist   ; dead code?
		mov    CPAGE,bx 	;get the codepage value
		mov    CCODE,dx 	;get the country code
		mov    CSIZE,cx 	;size of the buffer
;               call   CHK_OPEN         ;go open file if possible

; instead of calling the procedure, I include the procedure here
; Begining of procedure CHK_OPEN

                xor     cx,cx                           ;zero cx for open
                cmp     USER_PATH,1                     ;either user supplied=I
                je      co_user                         ;or default DOS

co_dos:         push    ds                              ;save current ds value
                push    si                              ;save current si value
                lds     si,dword ptr SI_DOSLOCATE       ;old dos ds si value
                lea     dx,ds:[si].ccPATH_COUNTRYSYS
                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>
                pop     si                              ;restore current si
                pop     ds                              ;restore current ds
                jmp     short co_10

co_user:        lea     dx,PATH_SPEC
                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>

co_10:          jc      BADREP_FILE                     ;bx contains the
                mov     bx,ax                           ;file handle
                jmp     short END_OPEN

BADREP_FILE:
                mov     ALL_DONE,al                     ;=J
                inc     DONT_CLOSE

END_OPEN:
; End of procedure CHK_OPEN

		jc     END_RES		;scan and read country info

		mov	ax,CCODE
		mov	dx,CPAGE
		mov	si,offset NLS_BUFFER
		call	Trans_Cty_Data
					;into my buffer & the dos buffer
  END_RES:
		ret

RES_MAIN	ENDP
;*******************************END RES_MAIN************************************
subttl	check open procedure
page
;******************************CHECK OPEN PROCEDURE****************************
;CHK_OPEN        PROC    NEAR
;
;
;                xor     cx,cx                           ;zero cx for open
;                cmp     USER_PATH,1                     ;either user supplied=I
;                je      co_user                         ;or default DOS
;
;co_dos:         push    ds                              ;save current ds value
;                push    si                              ;save current si value
;                lds     si,dword ptr SI_DOSLOCATE       ;old dos ds si value
;                lea     dx,ds:[si].ccPATH_COUNTRYSYS
;                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>
;                pop     si                              ;restore current si
;                pop     ds                              ;restore current ds
;                jmp     short co_10
;
;co_user:        lea     dx,PATH_SPEC
;                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>
;
;co_10:          jc      BADREP_FILE                     ;bx contains the
;                mov     bx,ax                           ;file handle
;                jmp     short END_OPEN
;
;BADREP_FILE:
;                mov     ALL_DONE,al                     ;=J
;                inc     DONT_CLOSE
;
;END_OPEN:
;                ret
;
;   CHK_OPEN     ENDP
;******************************END OF CHKOPEN**********************************
subttl transfer country data
page
;******************************TRANS_CTY__DATA ********************************
TRANS_CTY_DATA	PROC	NEAR

TRANSTART:
		push	di			;save start of CTY/CP INFO
						;get the size of the file
		xor	cx,cx			;clear cx to start at
		xor	dx,dx			;at the beginning of the
						;file
		call	READ_CTLBUFF		;Read in the file header
                jnc     CHK_INFOTYPE
                jmp     END_TRANS               ;=G

CHK_INFOTYPE:
		add	si,LOCATE_INFOTYPE	;si > Country info type
		cmp	byte ptr ds:[si],1	;only 1 type exist currently
		je	GET_INFOIDS
		jmp	BAD_FILE
GET_INFOIDS:
		inc	si			;si > set to file offset
		mov	dx,word ptr ds:[si]	;Get the Info file offset
		mov	cx,word ptr ds:[si+2]	;Doubleword

		mov	SAVEDX,dx		;=FC save offset
		mov	SAVECX,cx		;=FC for more than 1 buffer
		mov	NOFFSET,2		;=FC start from beginning

		call	READ_CTLBUFF		;Read Info
                jc      Bridge_END_TRANS
;               jmp     END_TRANS               ;=G

COUNT_ENTRIES:

		mov	cx,word ptr ds:[si]	;Get count of entries
						;in info
		inc	si			;next word
		inc	si			;si >  Entry info packet

FIND_CTY:					;Search for CTY/CP combo

		mov	ax,word ptr ds:[si]	;=FC get size of entry
                inc     ax                      ;=FC include length filed
                inc     ax
		add	NOFFSET,ax		;=FC look ahead
		cmp	NOFFSET,CTL_BUFF-4	;=FC < (256 - 4)
		jb	IN_BUFF 		;=FC
		sub	NOFFSET,ax		;=FC restore to old offset
		push	cx			;=FC save number of cntries
		mov	cx,SAVECX		;=FC get file offset
		mov	dx,SAVEDX		;=FC
		add	dx,NOFFSET		;=FC update to the entry
		adc	cx,0			;=FC beginning
		mov	SAVECX,cx		;=FC save them for next use
		mov	SAVEDX,dx		;=FC
		call	READ_CTLBUFF		;=FC read next buffer in
		jc	READERROR		;=FC read error occurs
		pop	cx			;=FC restore number of cntries
		mov	NOFFSET,0		;=FC a new beginning
IN_BUFF:

		mov	dx,CPAGE
		mov	ax,CCODE
		cmp	ax,word ptr ds:[si+2]	 ;compare country id
		jne	NEXT_CTY
		cmp	dx, word ptr ds:[si+4]	;compare code page id
		je	FOUND_CTY
                or      dx,dx             ;=FC    if default pick the
		jz	FOUND_CTY2	  ;=FC	  1st country

NEXT_CTY:
		add	si, word ptr ds:[si]	;next entry
		inc	si
		inc	si			;take a word for size of entry itself
		loop	FIND_CTY

		mov	ALL_DONE,INVALID_DATA	;if it exits the loop	=J =L
		jmp	FINDCTY_FAIL		;then no cp/cty match

READERROR:	pop	cx			;=FC
Bridge_END_TRANS:
                jmp     END_TRANS               ;=FC

FOUND_CTY2:	mov	dx,word ptr ds:[si+4]	;=FC from now on,this is
		mov	CPAGE,dx		;=FC the code page

FOUND_CTY:		       ;found the matching entry
		mov	dx, word ptr ds:[si+10] ;get the file offset of country data
		mov	cx, word ptr ds:[si+12]
		call	READ_CTLBUFF
                jc      Bridge_END_TRANS
;               jmp     END_TRANS               ;=G
NUM_ENTRY:
		mov	cx, word ptr ds:[si]	;get the number of entries to handle.
		inc	si
		inc	si			;SI -> first entry

SETDOSCTY_DATA:
.REPEAT
		 push	 di			 ;ES:DI -> DOS_COUNTRY_CDPG_INFO
		 push	 si			 ;si -> current entry in Control buffer
		 push	 cx			 ;save # of entry left

		mov	al, byte ptr ds:[si+2]	;get data entry id
		xor	ah,ah			;clear out for comparison with
						;info-id in case id is > 256



                test    INFO_FLAG,GET_EXT_F     ;check to see if function 2
						;get_extended info was needed
                jz      TRANSALL                ;if not assume function code 1
						;set codepage

		cmp	INFO_ID,-1		;Minus 1 means return all of the
		jne	CHK_ID			;country info to the user
						;otherwise get the specific
						;info id and return only that info


		pop	cx			;error can not return all
		pop	si			;info accept for currently
		pop	di			;loaded control info in DOS
		jmp	BAD_SETID		;area

CHK_ID: 	cmp	al,INFO_ID		;check to see if the selected
						;id is the same as the id in the
						;ctrl buffer area

		jne	SETDOSCTY_NEXT		;if not equal go search for the
						;next information id

		pop	cx			;Bingo!! Found it set counter
		mov	cx,1			;to zero to exit loop
		push	cx

                and     INFO_FLAG,NOT ID_CHECK_F    ;Turn bit off.  found a valid id
                test    INFO_FLAG,GET_EXT_F         ;after transferring data to USER
                jnz     GET_ADDR                    ;area

						;set cx image in stack to force
						;exit loop
TRANSALL:



		call	GetDOSCTY_Dest		   ;get the address of destination in ES:DI
		jc	SetDOSCTY_NEXT		   ;No matching data entry id in DOS

GET_ADDR:

		mov	dx, word ptr ds:[si+4]	   ;get offset of data
		mov	cx, word ptr ds:[si+6]



SEEK_READ:

		push	ax			   ;=A	save data id.
		xor	bp,bp						;DOS 4200h function
		CallInstall Lseek,multdos,40,<bx,cx,ds,es,di,si>,<si,di,es,ds,cx,bx>		 ;move ptr
		pop	ax			   ;=A
		jc	DATASEEKNREAD
										     ;when ptr moved
		mov	dx,offset NLS_BUFFER +CTL_BUFF							;set the buffer to the beginning of the
										     ;data buffer area

		mov	cx,DATA_BUFF_LENG					     ;set to number of bytes in the
										     ;data buffer area
		push	ax			   ;=A
								       ;DOS 3fh
		CallInstall Dosread,Multdos,41,<bx,cx,ds,es,di,si>,<si,di,es,ds,cx,bx>		 ;Read cx many bytes into the buffer
		pop	ax			   ;=A
		jc    DATASEEKNREAD

IS_EXTENDED:
                test    INFO_FLAG,GET_EXT_F
                jz      CHK_OVERWRITE
		call	GETEXT_CTY
		jmp	short SETDOSCTY_NEXT


CHK_OVERWRITE:					   ;=A
						   ; If SetCountryInfo, then
						   ; put DOS monocase routine
						   ; entry point into
						   ; NLS_BUFFER so don't
						   ; write over.  =A

						   ; MSKK02 07/18/89
		call	SetDBCS_before_clear	   ; check DBCS vector set


		cmp	al,SetCountryInfo	   ;=A
		jne	DOS_MOVE		   ;=A
		mov	ax,word ptr es:[di+24]	   ;=A
		mov	word ptr ds:[NLS_BUFFER+CTL_BUFF + 32],ax  ;=A
		mov	ax,word ptr es:[di+26]	   ;=A
		mov	word ptr ds:[NLS_BUFFER+CTL_BUFF + 34],ax  ;=A

		mov	ax,CPAGE		   ;=FC, CPAGE is right
		mov	word ptr ds:[NLS_BUFFER+CTL_BUFF + 12],ax  ;=FC

DOS_MOVE:
		call	CHK_ADJUST						     ;now check to see if the entire
										     ;table fits

SETDOSCTY_NEXT:

		pop	cx
		pop	si
		pop	di
		add	si, word ptr ds:[si]
		inc	si
		inc	si
		dec	cx
		.UNTIL <cx eq 0>    NEAR		     ;loop    SETDOSCTY_DATA

		;Check for an invalid id
                test    INFO_FLAG,GET_EXT_F     ;Check to see if a get_ext func 2 was issued
                jz      CTLSEEKnREAD            ;if not move on
                test    INFO_FLAG,ID_CHECK_F    ;if so check to see if an id was found
                jnz     BAD_SETID               ;if none was found report an error
                                                ;otherwise continue



CTLSEEKnREAD:
		clc				;=G
		jmp	short END_TRANS 	;exit



DATASEEKnREAD:
		mov    ALL_DONE,al		;=J
		pop	cx
		pop	si
		pop	di
		jmp    short END_TRANS

BAD_SETID:
;               mov     ALL_DONE,INVALID_FUNCTION  ;=J
;               jmp    short FINDCTY_FAIL          ;=J

BAD_FILE:
		mov	ALL_DONE,INVALID_FUNCTION  ;=J

FINDCTY_FAIL:
		stc

END_TRANS:
		pop	di			;Restore header start
		ret



TRANS_CTY_DATA	ENDP

						; MSKK02 07/18/89
SetDBCS_before_clear:
		cmp	al,SetDBCS		; DBCS vector set?
		jnz	@F			; jump if not
		cmp	word ptr es:[di], 0	; zero byte data block?
		jz	@F			; jump if so
		push	di			;
		push	ax			;
		push	cx			;
		mov	cx,es:[di]		; load block length
		add	di,2			; points actual data
		xor	al,al			; fill bytes
		rep	stosb			; clear data block
		pop	cx			;
		pop	ax			;
		pop	di			;
@@:
		ret				;

;******************************END TRANS_CTY_DATA ******************************
subttl get DOS country destination
page
;****************************GETCTY_DEST***********************************************
GetDOSCty_Dest	 proc	 near
;Get the destination address in the DOS country info table.
;Input: AL - Data ID
;	ES:DI -> DOS_COUNTRY_CDPG_INFO
;On return:
;	ES:DI -> Destination address of the matching data id
;	carry set if no matching data id found in DOS.

	push	cx
	add	di, ccNumber_of_entries ;skip the reserved area, syscodepage etc.
	mov	cx, word ptr es:[di]	;get the number of entries
	inc	di
	inc	di			;SI -> the first start entry id
GetCntryDest:
	cmp	byte ptr es:[di], al
	je	GetCntryDest_OK
	cmp	byte ptr es:[di], SetCountryInfo ;was it SetCountryInfo entry?
	je	GetCntryDest_1
	add	di, 5			;next data id
	jmp	short GetCntryDest_loop

GetCntryDest_1:
	add	di, NEW_COUNTRY_SIZE + 1 ;next data id

GetCntryDest_loop:
	loop	GetCntryDest
	stc
	jmp	short	GetCntryDest_exit

GetCntryDest_OK:

	cmp	al, SetCountryInfo	;select country info?
	jne	GetCntryDest_OK1
	inc	di			;now DI -> ccCountryInfoLen
	clc				;clear the carry
	jmp	short	GetCntryDest_exit

GetCntryDest_OK1:

	les	di, dword ptr es:[di+1] ;get the destination in ES:DI
	clc

GetCntryDest_Exit:
	pop	cx
	ret

GetDOSCty_Dest	 endp
;****************************GETDOSCTY_DEST*************************************
subttl get extended country data
page
;****************************GETEXT_CTY*****************************************
GETEXT_CTY	proc

JUSTONE_ID:
		mov	ah,func_code	;=F
		cmp	ah,GET_CTY_INFO ;=F
		je	id_ctyinfo1	;=F

		mov	al,INFO_ID
		mov	byte ptr es:[di],al

		cmp	INFO_ID,SetCountryInfo ;SETCTY_INFO  =D moved.
		je	ID_CTYINFO	       ;=D don't want ptr if 1.

		mov	word ptr es:[di+1],offset nls_buffer + ctl_buff+8  ;=H
		mov	word ptr es:[di+3],ds	     ;my current ds value
		mov	CSIZE,5 		     ;=K

		jmp	short GET_EXT_END

ID_CTYINFO:
		inc	di		;=D  (old code - add di,5) =F(moved).
id_ctyinfo1:				;=F
		mov	cx,CSIZE
					;next line used to be "add si,5"
					;si needs to point to cty info. =D
		mov	si,offset nls_buffer + ctl_buff + 8  ;=D

		push	es		;=A  put DOS Monocase Routine
		push	di		;=A  entry point in user buffer.
		push	ax		;=A
		les	di,dword ptr si_doslocate ;=A
		mov	ax,word ptr es:[di].ccMono_Ptr	  ;=A
		mov	word ptr ds:[si+24],ax		  ;=A
		mov	ax,word ptr es:[di].ccMono_Ptr+2  ;=A
		mov	word ptr ds:[si+26],ax		  ;=A

		mov	ax,CPAGE			  ;=FC trust CPAGE
		mov	word ptr ds:[si+4],ax		  ;=FC

		pop	ax		;=A
		pop	di		;=A
		pop	es		;=A

		push	bx		;=F
		cmp	ah,GET_CTY_INFO ;=F if get cty info(38) slide info
		jne	id_ctyinfo2	;=F ptr up to date.
		add	si,6		;=F
		mov	cx,old_country_size ;=FC
		jmp	short MOVE_CTY	 ;=FC

id_ctyinfo2:	mov	bx,word ptr ds:[si]	;=FC get table size


		sub	CSIZE,3 	;=FC  size begins after length field
		mov	cx,CSIZE	;=FC

		cmp	cx,bx			;=D was cmped to SETCTR_LENG
		ja	TRUNC_SIZE	;=FC  used to be jg
		jmp	short  MOV_SIZE
TRUNC_SIZE:
		mov	cx,bx		;=F
MOV_SIZE:
		mov	es:[di],cx	;=FC  move actual length to user's buff
                inc     di              ;=FC  update index
                inc     di
                inc     si              ;=FC  skip length field
                inc     si

MOVE_CTY:	pop	bx		;=F
		mov	CSIZE,cx	;=K
		add	CSIZE,3 	;=K
		rep	movsb

GET_EXT_END:
		ret

GETEXT_CTY	endp
;*****************************END GETEXT_CTY*************************************
subttl read into control buffer
page
;**************************READ_CTLBUFF*****************************************
;
READ_CTLBUFF		proc	near
;Move file pointer to CX:DX
;Read 64 bytes into the control buffer.  Assume that the necessary data
;is within that limit.
;SI will be set to beginning of the offset my NLS_BUFFER hence DS:SI points to the control buffer.
;Entry:  CX,DX offset from the start of the file where the read/write pointer
;	 be moved.
;	 BX - file handle
;	 DS - buffer seg.
;Return: The control data information is read into DS:0 - DS:0200.
;	 CX,DX value destroyed.
;	 Carry set if error in Reading file.
;
								    ;Function 4200h
		xor	bp,bp
		CallInstall Lseek,multdos,40,<bx,cx,ds,es,di,si>,<si,di,es,ds,cx,bx>	;move pointer
		jc	NO_SEEK1

		mov	dx,offset NLS_BUFFER	  ;ds:dx -> control buffer
		mov	si,dx			  ;index for the entire buffer
						  ;read into the buffer function 3fh
		mov	cx, CTL_BUFF		  ;XXX bytes. Size of the information
		CallInstall Dosread,multdos,41,<bx,cx,dx,ds,es,di,si>,<si,di,es,ds,dx,cx,bx>	;should be less than XXX bytes.
		jc	NO_READ1
		jmp	short RICB_exit


NO_SEEK1:
;                mov    ALL_DONE,al               ;=J
;                jmp    short RICB_exit

NO_READ1:
		 mov	ALL_DONE,al		  ;=J

RICB_exit:				  ;In this case 64 bytes
		  ret

READ_CTLBUFF	  endp
;****************************END READ_CTLBUFF***********************************
subttl check / adjust / move data into DOS buffer
page
;****************************CHK_ADJUST*****************************************
CHK_ADJUST	PROC  NEAR

		push	ax			;save info id
		mov	si,offset NLS_BUFFER+DATA_N_ID		  ;start of buffer + tag id
		mov	cx, word ptr ds:[si]	;get the length of the structure

		inc	cx
		inc	cx

		cmp	cx,MAXBUFF_FIT
		jbe	MOVE_DATA
		push	cx
		mov	cx,MAXBUFF_FIT
		rep	movsb
		pop	cx
		sub	cx,MAXBUFF_FIT

NEED_ADJUST:
		mov	dx,offset NLS_BUFFER+CTL_BUFF		  ;reset to the beginning of the data buffer
		mov	si,dx			;reset to the beginning of the data buffer
		cmp	cx,DATA_BUFF_LENG	;check to see if it fits for the nth read
		jbe	LAST_READ		;last portion fits
		push	cx			;save how much is left to read
		mov	cx,DATA_BUFF_LENG	;set to how much you read at one time

		;read again					      ;function 3fh
						      ;read into the data buffer
		CallInstall Dosread,multdos,41,<bx,cx,dx,ds,es,di,si>,<si,di,es,ds,dx,cx,bx>  ;save the file handle
		jc	ADJUST_END

		rep	movsb			      ;move data into DOS area
		pop	cx			      ;restore size remaining to
		sub	cx,DATA_BUFF_LENG	      ;be read get new size
		jmp	NEED_ADJUST			  ;must read agian

LAST_READ:
						      ;one more read 3f
		 CallInstall Dosread,multdos,41,<bx,cx,dx,ds,es,di,si>,<si,di,es,ds,dx,cx,bx>
		 jc	ADJUST_END

MOVE_DATA:
		rep	movsb			      ;move data into DOS area

ADJUST_END:
		pop	ax
		ret
CHK_ADJUST	ENDP
;*******************************END CHK_ADJUST *********************************
subttl walk through device drivers and invoke
page
;************************ WALK DEVICE DRIVERS **********************************
;=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=

WALK_DEVICES	PROC  NEAR

		mov	si,offset NLS_BUFFER ;Prepare to hold device name
		push	es			;AN001; Clear out NLS_BUFFER to 0
		push	ds			;AN001;
		pop	es			;AN001;
		mov	di, si			;AN001; ES:DI-> NLS_BUFFER
		xor	ax, ax			;AN001; AX=0
		mov	cx, BUFFSIZE		;AN001;
		shr	cx, 1			;AN001; /2 to make a # of words
		rep	stosw			;AN001;
		pop	es			;AN001; Restore es
						;Get ptr to hdr of 1st device.
		push	si			;AN001;
		CallInstall GetDevLst,Multdos,44,<DS>,<DS>
		pop	si			;AN001;
		mov	es,bx		    ;bx:ax -> hdr.
		mov	di,ax
char_test:
		test	es:[di].sdevatt,devtyp ;check attribute word for
                je      BR_GET_NEXT_DEVICE
;               jmp     GET_NEXT_DEVICE        ;character device.

OPEN_DEVICE:
		push	si
		push	di		    ;set up asciiz filename
		add	di,10		    ;for DOS file open
		mov	cx,8

set_asciiz:	mov	al,es:[di]
		cmp	al,20h
		je	done_set_asciiz
		mov	ds:[si],al
		inc	di
		inc	si
		loop	set_asciiz

done_set_asciiz:xor	al,al
		mov	ds:[si],al

		pop	di
		pop	si

		mov	cx,1		    ;open for write
		mov	dx,si
		CallInstall Dosopen,Multdos,38,<DS,SI,ES,DI>,<DI,ES,SI,DS>
		jnc	end_open_device

BR_GET_NEXT_DEVICE:
		jmp	GET_NEXT_DEVICE     ; ignore this =FC

end_open_device:
		mov	bx,ax		    ;put handle in bx
		call	Chk_Revisit	    ;AN001; Have been here already?
                jc      BR_CLOSE_DEVICE     ;AN001; No, a new one.
;               jmp     short CLOSE_DEVICE    ;AN001; Yes. Close and ignore this.

INVOKE_DEVICE:
		push	ds		    ;Check print queue first.
		push	si		    ;Set up for 2f print call.
		clc
		mov	ax,0106h	    ;2f call to command.com.
		int	2fh		    ;If print active: carry set,
		jnc	invoke_it	    ;DS:SI -> hdr of printing device.
		cmp	si,di		    ;Check if printing device is this
		jne	invoke_it	    ;device.  Match on ptr to device.
		mov	ax,ds
		mov	cx,es
		cmp	ax,cx
		jne	invoke_it

		pop	si
		pop	ds
		mov	ALL_DONE,BAD_INVOKE ;Match.  Set invoke error.

BR_CLOSE_DEVICE:
		jmp	short CLOSE_DEVICE

invoke_it:	pop	si			     ;save the current
		pop	ds				;environment

;*************** CNS *********** Start of DBCS Support
;  PUSH    DS			   ;ICE
;  push    bx			   ;ICE
;  push    ax			   ;ICE
;  mov	   bx,0140H		   ;ICE
;  xor	   ax,ax		   ;ICE
;  mov	   ds,ax		   ;ICE
;  mov	   ax,word ptr ds:[bx]	   ;ICE
;  mov	   word ptr ds:[bx],ax	   ;ICE
;  POP	   ax			   ;ICE
;  pop	   bx			   ;ICE
;  pop	   ds			   ;ICE
	       push    di
	       push    bx
	       push    cx
	       push    es
	       les     di,dword ptr SI_DOSLOCATE     ;get the environmental
;*************** CNS ******************
;	       mov     bx,es:[di].ccDBCS_ptr	     ;values to allow
;	       mov     es,es:[di].ccDBCS_ptr+2	     ;recognition and
;*************** CNS ******************
	       les     bx,es:[di].ccDBCS_ptr
	       mov     cx,es:[bx]		     ;invocation of data
               inc     cx
               inc     cx
               inc     bx                            ;and ID for start
               inc     bx
	       mov     di,offset pk.DBCS_EV	     ;and stop values for
						     ;otherwise it is a DBCS
;****CHANGE					     ;or custom designed codepage

	       mov     PK.PACKLEN,cx		     ;if packet length is zero

NODBCS_CP:
	       add     cx,-2			     ;AN002; reset counter before CP addition

;****CHANGE

DB_EVECS:
               or      cx,cx                         ;AN002;no need to alter packet
               jz      NO_LOAD                       ;An002;initialized to zero


	 .REPEAT				      ;;AN000;DBCS transmission
						     ;AN000;
	       mov     al,es:[bx]		     ;;AN000;get the the contents
;***CNS 						;AN000;
	       mov     ds:[di],al			;;AN002;of where the DBCS Points
;***CNS 						;AN000;
	       inc     di			     ;;AN000;data packet for ioctl
						     ;AN000;
	       inc     bx			     ;AN000;;call--- get the start
						     ;stop values to load
						     ;AN000;
		dec	cx			     ;AN000;

	  .UNTIL <CX EQ 0 >			     ;AN000;
						      ;invocation of 1 codepage
						     ;standard codepage selection


NO_LOAD:

		 pop	 es			       ;AN000;;accordingly & restore
						       ;AN000;
		 pop	 cx			       ;AN000;;values
						       ;AN000;
		 pop	 bx			       ;AN000;
						       ;AN000;
		 pop	 di			       ;AN000;
						       ;AN000;;invoke codepage
;************************ CNS*** End of DBCS

					    ;Set up data packet for generic
		mov	ax,cpage	    ;ioctl call.
		mov	pk.packcpid,ax
		lea	dx,pk

		mov	cx,004ah
		mov	bp,0ch		    ;generic ioctl
		CallInstall IOCTL,multdos,43,<DS,SI,ES,DI,BX>,<BX,DI,ES,SI,DS>
		jc	device_error


CLOSE_DEVICE:
		CallInstall Dosclose,multdos,39,<DS,SI,ES,DI>,<DI,ES,SI,DS>
		jc	dev_open_close_error  ; ignore this =FC

GET_NEXT_DEVICE:
		cmp	word ptr es:[di],0FFFFH
		je	END_WALK_DEVICES
		les	di,dword ptr es:[di]
		jmp	char_test

DEVICE_ERROR:
		cmp	ax,1
		je	CLOSE_DEVICE
		CallInstall GetExtErr,multdos,45,<DS,SI,ES,DI,BX>,<BX,DI,ES,SI,DS>
		cmp	ax,22
		je	CLOSE_DEVICE
		mov	ALL_DONE,BAD_INVOKE
		jmp	CLOSE_DEVICE

dev_open_close_error:
		mov	ALL_DONE,BAD_INVOKE
		jmp	GET_NEXT_DEVICE

END_WALK_DEVICES:


		ret

WALK_DEVICES	endp
;*********************** END WALK DEVICE DRIVERS *******************************
;************************ Chk_Revisit******************************************
;This routine will check if we are opening the same device driver again.
;If it is, then carry bit will set.
;This routine will use the NLS_BUFFER to keep the history of already
;visited device driver address (OFFSET,SEGMENT).  NLS_BUFFER will be
;used from the end of the buffer towards to the front of the buffer.
;For 512 byte length and considering the front part used for OPEN device
;driver name string, this will handle appr. 126 devices maximum. which is
;sufficient enough. - J.K. 1/15/88
;IN: BX = file handle
;    DS = NLS_BUFFER segment
;OUT: carry set = visited
;     carry not set = new one.
;     Other registers saved.

Chk_Revisit	proc	near
	push	ax				;AN001;
	push	bx				;AN001;
	push	es				;AN001;
	push	di				;AN001;
	mov	ax, 1220h			;AN001; Get the spot of SFT
	int	2fh				;AN001;
	jc	Chk_Rvst_Ret			;AN001; This won't happen
	xor	bx, bx				;AN001;
	mov	bl, byte ptr es:[di]		;AN001;
	mov	ax, 1216h			;AN001; Get the SFT pointer
	int	2fh				;AN001; es:di-> SFT table
	jc	Chk_Rvst_Ret			;AN001; This won't happen
	mov	ax, word ptr es:[di].SF_DEVPTR	;AN001; offset of device
	mov	bx, word ptr es:[di].SF_DEVPTR+2;AN001; Segment of device
	mov	di, offset NLS_BUFFER		;AN001;
	add	di, BUFFSIZE-2			;AN001; ds:di-> last word of the buffer
Chk_Rvst_While: 				;AN001;
	cmp	word ptr ds:[di], 0		;AN001; di-> segment value
	jne	Chk_Rvst_Cont			;AN001;
	cmp	word ptr ds:[di-2], 0		;AN001; offset
	jne	Chk_Rvst_Cont			;AN001;
	jmp	short Chk_Rvst_New		;AN001; Encountered a blank entry in the buffer
Chk_Rvst_Cont:					;AN001;
	cmp	word ptr ds:[di], bx		;AN001;
	jne	Chk_Rvst_Next			;AN001;
	cmp	word ptr ds:[di-2], ax		;AN001;
	jne	Chk_Rvst_Next			;AN001;
	stc					;AN001; found a match
	jmp	short Chk_Rvst_Ret		;AN001;
Chk_Rvst_Next:					;AN001;
	sub	di, 4				;AN001; move the pointer to the next entry
	jmp	Chk_Rvst_While			;AN001;
Chk_Rvst_New:					;AN001;
	mov	word ptr ds:[di],bx		;AN001; Keep the current open device segment
	mov	word ptr ds:[di-2], ax		;AN001; and offset
	clc					;AN001; New device
Chk_Rvst_Ret:					;AN001;
	pop	di				;AN001;
	pop	es				;AN001;
	pop	bx				;AN001;
	pop	ax				;AN001;
	ret					;AN001;
Chk_Revisit	endp

subttl end nlsfunc resident code
page
 NLSRES_LENG	equ	$-NLSRES_CODE+DATASIZE
subttl initialization
page
;***************************** NLSFUNC Initialization **************************


	ASSUME	CS:NLS_INIT_CODE,SS:STACK
	PUBLIC	MAIN
MAIN	PROC	FAR

	mov	ax,NLS_DATA		;set up data segment
	mov	ds,ax
	assume	ds:NLS_DATA

	mov	PATHSEG,ax

	call	 SYSLOADMSG		 ;does DOS version check

	.IF <NC>

	   mov	dx,NLSRES_LENG		;calculate paragraph
	   add	dx,15			;add 15
	   shr	dx,1			;divide by 16 to get conversion from
	   shr	dx,1			;bytes to paragraphs
	   shr	dx,1
	   shr	dx,1
	   add	dx,11h			;size based on the byte size of
	   mov	RES_PARASIZE,dx 	;the resident procedure
	   call	PROCESS_PATH

	.ELSE

	   call	SYSDISPMSG

	.ENDIF

	; See if we should install and set
	; the TSR flag.

;       .IF <OPTIONS_SENT eq 0>

            test    INFO_FLAG,OPTIONS_SENT_F
            jnz     JJOPSOUT


;          .IF <NO_PARMS eq 1> or
;             .IF <GOOD_PATH eq 1>

            test    INFO_FLAG,NO_PARMS_F OR GOOD_PATH_F
            jz      JJOPSOUT

OPSEOK:
	      call INSTALL_NLS		;let's install NLSFUNC

;             .IF <NC>

            jc      JJOPSOUT
            or      INFO_FLAG,EXIT_STAY_F     ;if nothing wrong occured


;             .ENDIF    ; <NC>
;          .ENDIF       ; <NO_PARMS eq 1> or <GOOD_PATH eq 1>
;       .ENDIF          ; <OPTIONS_SENT eq 0>
JJOPSOUT:
								;determine path of exit
								;error or residency

;****************************** EXIT PROG *********************************************

	push	ax			  ;AN004;save existing values
	push	es			  ;
	xor	ax,ax
	mov	ax,es:[2ch]
        or      ax,ax
        jz      NO_FREEDOM
	mov	es,ax
	mov	ax,4900H		    ;AN004;make the free allocate mem func
	int	21h

NO_FREEDOM:
	pop	es			  ;AN004;restore existing values
	pop	ax			  ;

;       .IF <EXIT_STAY eq 1>            ;Terminate and stay resident

            test    INFO_FLAG,EXIT_STAY_F
            jz      JJEXSY

	   mov     bx,4			;1st close file handles

	   .REPEAT
	      mov  ah,3eh
	      int  21h
	      dec  bx
	   .UNTIL <BX eq 0>

            mov     ah,031h
            mov     dx,RES_PARASIZE      ;paragraphs allocated
            jmp     short JJEXOUT

;       .ELSE
JJEXSY:
	   clc
	   mov     ah,04ch		;value passed to ERRORLEVEL

;       .ENDIF
JJEXOUT:

	mov	al, ERROR_CODE		;check for an error
	int	21H

MAIN	ENDP

;****************************** EXIT PROG *********************************************
subttl parse
page
; On entry: ES points at the PSP
;	    DS points at NLS_DATA
;	    DX was used to calculate paragraph size
;
;	    PARSER EFFECTS  ES & DS wil be swapped
;
; Changes : ES:DI seg:off containing PARM Input Block
; to	    DS:SI seg:off containing command line
; segments
;
;
;
;
;
;
;****************************** PROCESS PATH ***********************************
;=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=

PROCESS_PATH	PROC	NEAR

					;to command line parms


		push	es		;;AC000;e original es (nothing)
					;AC000;
		push	ds		;AC000;he original ds (Nls_data)
					;AC002;
		push	ds		;save for both es & ds to point at data

		push	es		;AC000;hat's in my es the PSP value
					;AN000;
		push	ds		;AN000;he segment id that points to my
					;es now points to data
		pop	es		;AC000;
					;input parameter control block (NLS_DATA)
					;AN000;

		pop	ds		;AN000; points to the segment for
					;the command line string
					;AN000;

		ASSUME	DS:NOTHING,ES:NLS_DATA

		xor	dx,dx
		xor	cx,cx

;***CNS
RE_START:
		mov	si,80h		;get the command line length

		mov	cl,byte ptr ds:[si]	;get the length for the counter
;
;               mov     LENGTH_HOLD,cl          ;save the length of the command line
;



;		.IF <dx eq 0>

		     mov     di,OFFSET NLS_BUFFER    ;
 ;		     mov     dx,1
 ;		.ELSE
 ;		     mov     di,OFFSET PATH_SPEC    ;
 ;		     mov     dx,-1
 ;		.ENDIF

		mov	si,CL_NUM	;AN000; points to the offset command
					;line input string at value 81h
					;AN000;

		rep	movsb			;transfer command line to NLS_BUFFER

;		.IF <dx eq 1>
;		    jmp RE_START
;		.ENDIF

;***CNS




		mov	di,OFFSET NLS_PARMS    ;AN000; into ES of the PARMS INPUT
					;BLOCK
					;AN000;
		pop	ds		       ; ds also point at NLS_DATA


		ASSUME	DS:NLS_DATA


		mov	si,OFFSET NLS_BUFFER	;si now points to the offset command
;***CNS

                xchg    ax,CUR_PTR              ;AN003;Save environment
                                                ;AN003;Set advancing ptr to end of argument
                xchg    ax,OLD_PTR              ;AN003;after saving the beginning the string
                                                ;AN003;
                xchg    ax,CUR_PTR              ;AN003;Restore the environment
                mov     CUR_PTR,si

;***CNS



		xor	cx,cx			;AN000;l value should be atleast 1
		xor	dx,dx			;AN000;ut dx for input into the PARSER
						;AN000;

	.WHILE <PAR_RETC eq 0> 			;AN000;

	   call	SYSPARSE			;AN000;empt to parse
;***CNS

                xchg    ax,CUR_PTR              ;AN003;Save environment
                                                ;AN003;Set advancing ptr to end of argument
                xchg    ax,OLD_PTR              ;AN003;after saving the beginning the string
                                                ;AN003;
                xchg    ax,CUR_PTR              ;AN003;Restore the environment
                mov     CUR_PTR,si

;***CNS

	   .IF <RES_SYN EQ <OFFSET OPT_SYN>>

	      ; Display the user options help message

	      call	DISPLAY_OPTIONS

	      ; Flag that the options message has been displayed,
	      ; and now we want out of this program so the user
	      ; can try again.

              or        INFO_FLAG,OPTIONS_SENT_F  ; to get out of program
              and       INFO_FLAG,NOT EXIT_STAY_F ;  and not TSR
              mov       ERROR_CODE, 0             ;  and no error for help
              mov       ax, 1                     ; to get out of WHILE loop

	   .ELSEIF <Res_type eq 5>		;AN000;ound
						;AN000;
	      mov	USER_PATH,1		;AN000;;path specified
						;AC000;
	   .ENDIF				;AN000;

	   mov	PAR_RETC, AX			;AN000;;keep parsing until eoln
						;AN000;
	.ENDWHILE				;AN000;

	; If we didn't display the option help message,
	; then continue on with normal processing.

;       .IF <OPTIONS_SENT EQ 0> NEAR

            test    INFO_FLAG,OPTIONS_SENT_F
            jz      JJBR1
            jmp     JJOUT1

;          .IF <PAR_RETC gt 0>                  ;AN000;;parse error
JJBR1:
            cmp     PAR_RETC,0
            jnge    JJRETC


	      LEA   DI,PATH_SPEC		;AN003;Set PTR to look at the STRING
	      PUSH  SI				;AN003;Save current SI index
	      PUSH  AX
	      MOV   AX,OLD_PTR			;AN003;Last locale of the end of a PARAM
	      SUB   CUR_PTR,AX			;AN003;Get the length via the PSP
	      MOV   SI,CUR_PTR
	      MOV   CX,SI			;AN003;Save it in CX to move in the chars
	      POP   AX				;AN003;Restore the PTR to the command line position

	      MOV   SI,OLD_PTR			;AN003;Last locale of the end of a PARAM
	      REP   MOVSB			;AN003;Move in the chars until no more

	      LEA   DI,PATH_SPEC		;AN003;Set PTR to look at the STRING

	      POP   SI				;AN003;Restore the PTR to the command line position

	      mov   cx,1			;AN003;;
	      mov   bx,STDERR			;AN003;
	      mov   dl,no_input			;AN003;
	      mov   dh,PARSE_ERR_CLASS		;AN003;
	      mov   ds,PATHSEG			;AN003;
	      mov   si,OFFSET PARMLIST3		;AN003;
	      call  SYSDISPMSG			;AN003;
              or    INFO_FLAG,PARSE_ERR_F       ;AN003;;PARSE ERROR OCCURED

            jmp     short JJOUTRETC

;          .ELSEIF <CX eq 1>                    ;AN000;ordinal check
JJRETC:

                cmp cx,1
                jne JJCX
						;AN000;
              or    INFO_FLAG,GOOD_PAR_F        ;AN000;you are at the end of the line

            jmp     short JJOUTRETC             ;AN000;

JJCX:
;          .ELSE

            or      INFO_FLAG,NO_PARMS_F        ;AN000;there is no argument go install

;          .ENDIF               ; <PAR_RETC gt 0>
JJOUTRETC:


;         .IF <PARSE_ERR eq 0> NEAR             ;AN000;if not true you encountered a parse error

                test INFO_FLAG,PARSE_ERR_F
                jnz JJOUT1

;            .IF <GOOD_PAR eq 1> NEAR           ;AN000;there is a parameter line available
						;to parse
                test    INFO_FLAG,GOOD_PAR_F    ;AN000;
                jz      JJOUT1                  ;Check the flags to see what
						;was returned in the return block

	        lea     di,path_spec		;AC000;es:di > final path_spec
						;that will be used after fixup

;               .IF <USER_PATH gt 0>            ;AC000;drive has been solved need
                                                ;to check the filespec now
                cmp USER_PATH,0
                jnge USPA1

	           xor   in_dex,in_dex		;AN000;clear ctr
		   mov   bx,Res_POFF 		;AN000;get file spec ptr to text
		   push  ds			;AN000;prepare for entry
		   mov   ds,Res_PSEG 		;AN000;
		   mov   in_dex,bx		;AN000;string seg value if filename

;               .ENDIF        ;user path        ;AN000;
USPA1:

	        .WHILE <Filespec_PTR ne NULL>	;load chars until no more
						;AN000;
						;AN000;
		   mov	al,FILESPEC_PTR 	;AN000;
		   mov	byte ptr es:[di],al	;move value into pathspec and
		   inc	in_dex			;increment to next char position
		   inc	di			;AN000;

	        .ENDWHILE

;************************** CNS **********************************************
;The new method of checking for a "bogus" file will be to attempt an
;open on the path_spec if pathspec exist close path and continue if
;carry set stuff error code with 02 and exit.....
;*****************************************************************************
;	        push	es			;AN000;

	        pop	ds			;into find first
	        mov	si,di			;AN000;
	        xor	cx,cx			;AN000;

	        ASSUME	DS:NLS_DATA

	        mov	byte ptr ds:[si],NULL	;add asciiz value
						;AN000;
	        lea	dx,PATH_SPEC		;check full pathname
	        mov	ah,4eh
	        int	21h
						;set up addressability
;               .IF <NC>

                jc      JJC1

		   clc				;ok-clear carry/exit
                   or   INFO_FLAG,GOOD_PATH_F

                jmp     short JJOUT1

;               .ELSE
JJC1:
	           mov	ax,FNF			;AN000;
	           mov	cx,1			; ;AN000;
	           mov	bx,STDERR		;AN000;
	           mov	dl,no_input		;AN000;
	           mov	dh,UTILITY_MSG_CLASS 	;AN000;
	           mov	ds,PATHSEG		;AN000;
	           mov	si,OFFSET PARMLIST1	;AN000;
		   call	SYSDISPMSG		;AN000;
		   mov	ERROR_CODE,02		;
		   stc

;               .ENDIF  ; <NC>

;            .ENDIF     ; <GOOD_PAR eq 1>

;          .ENDIF       ; <PARSE_ERR eq 0>

;       .ENDIF          ; <OPTIONS_SENT EQ 0>

JJOUT1:


	pop	ds				;AN000;;restore original ds (NLS_DATA)
						;AN000;
	pop	es				;AN000;;restore original es (nothing)
						;AN000;
						;AN000;;after munging around with the PARSER

	ASSUME	DS:NLS_DATA,ES:NOTHING

	ret

PROCESS_PATH	ENDP


subttl display_options
page
;**************************** DISPLAY OPTIONS *******************************
;
; 04/26/90 c-PaulB
;
; on entry:
;   No value passed
;
; on exit:
;   No value returned
;   AX, BX, CX, DX, SI modified
;
; function:
;   Displays all lines of the options help message to standard
;   output.
;
;**************************** DISPLAY OPTIONS *******************************

	PUBLIC	DISPLAY_OPTIONS
DISPLAY_OPTIONS	PROC NEAR

	push	ds
	mov	ax, MSG_OPTIONS_FIRST		; message to display
	mov	bx, STDOUT			; output handle
	mov	cx, 0				; no substitutions
	mov	dh, UTILITY_MSG_CLASS		; message class
	mov	dl, no_input			; no input wanted
	mov	si, 0				; no substitution list
	mov	ds, PATHSEG
DO_LOOP:
	call	SYSDISPMSG			; send this message line
	cmp	ax, MSG_OPTIONS_LAST		; last message?
	je	DO_DONE				;  we're done if so
	inc	ax				; else get next msg
	jmp	short DO_LOOP			;  and go do it
DO_DONE:
	pop	ds
	ret

DISPLAY_OPTIONS ENDP


;****************************** CNS *******************************************
subttl install NLSFUNC
page
;******************************** INSTALL NLSFUNC *****************************

INSTALL_NLS	PROC	NEAR

		push	es

		xor	ax,ax			  ;clear the ax
		mov	ah,MULT_NLSFUNC 	  ;load in my multiplex
		INT	2fh			  ;id value 14
		or	al,al			  ;check to see if
;		jz	DO_INSTALL		  ;hooked in the chain
; *********************** CNS *************************************************

	   .IF <Z>				  ;AN000

						  ;Install NLSFUNC
		mov	al,2fh			  ;Get interrupt
		mov	ah,GET_INT		  ;2f in the chain
		int	21h
		mov	word ptr INT_2f_NEXT+2,ES ;store the address
		mov	word ptr INT_2f_NEXT,BX   ;to make the current
		push	ds			  ;2f handler next in
		push	cs			  ;the chain
		pop	ds			  ;set Dataseg to the Code
		mov	dx,offset NLSRES_CODE	  ;give start address
		mov	al,2fh			  ;of resident logic
		mov	ah,SET_INT		  ;set the 2f in the
		int	21h			  ;chain
		pop	ds			  ;restore original ds
						  ;terminate &
		CLC				  ; Let main know everything OK 	 ;BN001;
						  ;stay
;FREE THE ENVIRONMENT				  ;no then install

;		  push	  ax			  ;AN004;save existing values
;		  push	  es			  ;
;		  mov	  ah,49H		  ;AN004;make the free allocate mem func
;		  mov	  es,es:[2ch]		    ;AN004;get the segment address
;		  int	  21h			  ;
;		  pop	  es			  ;AN004;restore existing values
;		  pop	  ax			  ;

	   .ELSE				   ;AN000;
;TBR Message retriever				  ;otherwise
		   mov	   ax,ALLINS		     ;
		   mov	   cx,1 		     ;
		   mov	   bx,STDERR		       ;AN000;
		   mov	   dl,no_input		       ;AN000;
		   mov	   dh,UTILITY_MSG_CLASS 	 ;AN000;
		   mov	   ds,PATHSEG
		   mov	   si,OFFSET PARMLIST2
		   call    SYSDISPMSG		      ;AN000;
		   mov	   ERROR_CODE,80	      ;UTILITY ERROR CODE
		   stc

.ENDIF

		pop	es

		ret

INSTALL_NLS	ENDP

msg_services <LOADmsg>				      ;AN000;
msg_services <DISPLAYmsg,CHARmsg>		      ;AN000;
msg_services <nlsfunc.cl1,nlsfunc.cl2,nlsfunc.cla>    ;AN000;

;******************************** END OF NLS_INIT_CODE **************************
NLS_INIT_CODE	 ENDS
subttl stack
page

STACK	SEGMENT   PARA	STACK 'STACK'
	DB	  512 DUP (?)
STACK	ENDS

	END	MAIN

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\funcdbcs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;; generic ioctl call data "packet" pointed to by DS:DX    =E
PACKET		STRUC	   ;USED BY MINOR CODES: 6AH,4AH,4DH (SELECT, QUERY SELECTED, PREPARE END)  =E
PACKLEN 	DW   0	     ;LENGTH OF PACKET IN BYTES =E	  2/16/KK
PACKCPID	DW   0	   ;CODE PAGE ID	      =E
DBCS_EV 	DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
PACKET		ENDS


STD_CPLENGTH  equ	2
PK	      PACKET <>  ;CNS

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\funcparm.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;Parser INPUT PARM LIST Structure

	PUBLIC	NLS_PARMS
 NLS_PARMS	label  word
      dw	NLS_PARMSX
      db	0	  ;no extra delimiters

	PUBLIC	NLS_PARMSX
 NLS_PARMSX	label  word
      db	0,1	  ;Min 0 - no path
			  ;Max 1 - path
      dw	NLS_POS1
      db	1         ; 1 switch supported
      dw	NLS_OPTS  ; its addr

	PUBLIC	NLS_POS1
 NLS_POS1	label  word
      dw	0201h	 ;File spec (optional)
      dw	0001h	 ;Cap result by file
      dw	Res_Valptr   ;tbl
      dw	NoVal	     ;no value list
      db	0	     ;no switch or
			     ;keyword synonyms

	PUBLIC	NLS_OPTS, OPT_SYN
NLS_OPTS	label word
	dw	0000		; Match Mask
	dw	0000		; Function Mask
	dw	RES_VALPTR	; ptr to results
	dw	NOVAL		; ptr to values
	db	1		; count of synonyms
OPT_SYN	db	"/?", 0

NOVAL label word
	db	0

	PUBLIC	RES_VALPTR, RES_SYN
    RES_VALPTR	label word

      RES_TYPE	 db	?	;Result_type
      RES_ITAG	 db	0	;Matched item tag
      RES_SYN	 dw	0	;synonym returned
      RES_POFF	 dw	0	;drive type or beginning of string
      RES_PSEG	 dw	0	;may be string
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\qbasic\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\qbasic\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\qbasic\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\qbasic\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\qbasic\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\qbasic\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\qbasic\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\nlsfunc\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\setver.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*	SETVER.C 																					*/
/*																									*/
/*	This module contains the functions which read in the version table		*/
/*	from MSDOS.SYS and then updates the table with new entries and				*/
/*	writes it back to the file.															*/
/*																									*/
/*	The fake version table is located in the DOS system file and it's			*/
/*	location and length are specified with 2 words at offset 7 in the			*/
/* file. The first word is the table offset and second word is length.		*/
/*																									*/
/*	Table layout:																				*/
/*																									*/
/* ENTRY FILENAME LEN:	Length of filename in bytes	1 byte					*/
/* ENTRY FILENAME:	Variable length to 12 bytes	? bytes						*/
/* ENTRY VERSION MAJOR: Dos major version to return	1 byte					*/
/* ENTRY VERSION MINOR: Dos minor version to return	1 byte					*/
/*																									*/
/*																									*/
/*	USEAGE:																						*/
/*		List table:		SETVER [D:]															*/
/*		Add entry:		SETVER [D:] name.ext X.XX										*/
/*		Delete entry:	SETVER [D:] name.ext /DELETE									*/
/*		Delete entry quietly: SETVER [D:] name.ext /DELETE /QUIET				*/
/*		Display help	SETVER /?															*/
/*																									*/
/*	WHERE:																						*/
/*		D: is the drive containing MSDOS.SYS											*/
/*		name.ext is the executable file name											*/
/*		X.XX is the major and minor version numbers									*/
/*																									*/
/*	RETURN CODES:																				*/
/*		0	Successful completion															*/
/*		1	Invalid switch																		*/
/*		2	Invalid file name																	*/
/*		3	Insuffient memory																	*/
/*		4	Invalid version number format													*/
/*		5	Entry not found in the table													*/
/*		6	MSDOS.SYS file not found														*/
/*		7	Invalid MSDOS.SYS or IBMDOS.SYS file										*/
/*		8	Invalid drive specifier															*/
/*		9	Too many command line parameters												*/
/*		10	DOS version was not specified													*/
/*		11	Missing parameter																	*/
/*		12 Error reading MS-DOS system file												*/
/*		13 Version table is corrupt														*/
/*		14 Specifed file does not support a version table							*/
/*		15 Insuffient space in version table for new entry							*/
/*		16 Error writing MS-DOS system file												*/
/*																									*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <dos.h>
#include <io.h>
#include <fcntl.h>

#include <setver.h>
#include <message.h>


/***************************************************************************/

static char				*ReadBuffer;
static char 			*LieBuffer;		 		/* Buffer to read lietable into	*/
static char 			*EndBuf;			 		/* Ptr to end of the buffer 		*/
struct ExeHeader		ExeHdr;
struct DevHeader		DevHdr;
struct TableEntry		Entry;
static char				*szSetVer = "SETVERXX";

long						FileOffset;
/* static UINT				TableLen; */

/***************************************************************************/
/* Program entry point. Parses the command line and if it's valid executes */
/* the requested function and then returns the proper error code. Any		*/
/* error codes returned by ParseCommand are negative so they must be			*/
/* converted with a negate before being returned as valid error codes.		*/
/*																									*/
/*	int main( int argc, char *argv[] )													*/
/*																									*/
/*	ARGUMENTS:	argc - Count of command line arguments				 				*/
/*					argv - Array of ptrs to argument strings							*/
/*	RETURNS:		int	- Valid return code for batch processing					*/
/*																								 	*/
/***************************************************************************/

int main( int argc, char *argv[] )
{
	register		iFunc;
	char			szError[ 80 ];

	iFunc = ParseCmd( argc, argv, &Entry );
	if ( iFunc >= 0 )
		iFunc = DoFunction( iFunc );

	if ( iFunc != S_OK )
	{
		iFunc = -(iFunc);
#ifdef BILINGUAL
		if (IsDBCSCodePage())
		{
			strcpy( szError, ErrorMsg[ 0 ] );
			strcat( szError, ErrorMsg[ iFunc ] );
		}
		else
		{
			strcpy( szError, ErrorMsg2[ 0 ] );
			strcat( szError, ErrorMsg2[ iFunc ] );
		}
#else
		strcpy( szError, ErrorMsg[ 0 ] );
		strcat( szError, ErrorMsg[ iFunc ] );
#endif
		PutStr( szError );
#ifdef BILINGUAL
		if (IsDBCSCodePage())
			PutStr( szMiniHelp );
		else
			PutStr( szMiniHelp2 );
#else
		PutStr( szMiniHelp );
#endif
	}
	return( iFunc	);
}

/***************************************************************************/
/* Calls the appropriate function to do whatever was specified by the		*/
/* user. The lie table if first read in except in the case only the help	*/
/* function was requested. To be sure duplicate table entries are not		*/
/* created a call to DeleteEntry with the new program name will be done		*/
/* before the new entry is created.														*/
/*																									*/
/*	int DoFunction( int iFunc )															*/
/*																									*/
/*	ARGUMENTS:	iFunct - The function to be performed								*/
/*	RETURNS:		int	 - S_OK if no errors else an error code					*/
/*																									*/
/***************************************************************************/

int DoFunction( int iFunc )
{
	register		iStatus;

	if ( iFunc == DO_HELP )
	{
#ifdef BILINGUAL
		if (IsDBCSCodePage())
			DisplayMsg( Help );
		else
			DisplayMsg( Help2 );
#else
		DisplayMsg( Help );
#endif
		return( S_OK );
	}

	if ( iFunc == DO_ADD_FILE )
#ifdef BILINGUAL
		if (IsDBCSCodePage())
			DisplayMsg( Warn );
		else
			DisplayMsg( Warn2 );
#else
		DisplayMsg( Warn );							/* Read in the lie table and	*/
#endif
															/* then decide what to do		*/
	if ( (iStatus = ReadVersionTable()) == S_OK )
	{
		if ( iFunc == DO_LIST )
			iStatus = DisplayTable();
		else
		{
			if ( (iFunc == DO_DELETE || iFunc == DO_QUIET) &&
				  (iStatus = MatchFile( LieBuffer, Entry.szFileName )) < S_OK )
				return( iStatus );
															/* Always a delete before add	*/

			if ( (iStatus = DeleteEntry()) == S_OK &&	iFunc == DO_ADD_FILE )
				iStatus = AddEntry();

			if ( iStatus == S_OK &&
				  (iStatus = WriteVersionTable()) == S_OK &&
				   !(iFunc == DO_QUIET) )
			{
#ifdef BILINGUAL
				if (IsDBCSCodePage())
					PutStr( SuccessMsg );
				else
					PutStr( SuccessMsg_2 );
				if ( SetVerCheck() == TRUE )		/* M001 */
				{
					if (IsDBCSCodePage())
						PutStr( SuccessMsg2 );
					else
						PutStr( SuccessMsg2_2 );
				}
#else
				PutStr( SuccessMsg );
				if ( SetVerCheck() == TRUE )		/* M001 */
					PutStr( SuccessMsg2 );
#endif
			}
		}
	}
					/* M001 Install check to see if currently in device chain */
	if ( iStatus == S_OK && iFunc != DO_QUIET && SetVerCheck() == FALSE )
#ifdef BILINGUAL
	{
		if (IsDBCSCodePage())
			DisplayMsg( szNoLoadMsg );
		else
			DisplayMsg( szNoLoadMsg2 );
	}
#else
		DisplayMsg( szNoLoadMsg );
#endif

	return( iStatus );
}

/***************************************************************************/
/* Displays the help text for "/?" option, or the warning text.				*/
/*																									*/
/*	void DisplayHelp( tbl )																	*/
/*																									*/
/*	ARGUMENTS:	char *tbl[]													 				*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void DisplayMsg( char *tbl[] )
{
	register i;

	for ( i = 0; tbl[i] != NULL; i++ )
		PutStr( tbl[ i ] );
}

/***************************************************************************/
/* Displays all entries in the version table which must have already been	*/
/* read into the work buffer. The name and version number are created as	*/
/* as ascii string in a tempory buffer and then printed as a single string */
/* in the format:																			 	*/
/*																								 	*/
/*	1234567890123456789																		*/
/*	FILENAME.EXT	X.XX																		*/
/*																								 	*/
/*	int DisplayTable( void )														 		*/
/*																								 	*/
/*	ARGUMENTS:	void																			*/
/*	RETURNS:		int	- S_CORRUPT_TABLE if table corrupt else S_OK				*/
/*																								 	*/
/***************************************************************************/

int DisplayTable( void )
{
	char		*BufPtr;
	char		*szTmp;
	char		*szVersion;
	char		szEntry[ 50 ];

	BufPtr = LieBuffer;
	szVersion = szEntry + VERSION_COLUMN;

	PutStr( "" );
	while ( *BufPtr != 0 && BufPtr < EndBuf )
	{
														 	/* Chk for table corruption	*/
		if ( !IsValidEntry( BufPtr ) )
			return( S_CORRUPT_TABLE );
												/* Copy file name and pad with spaces	*/
		strncpy( szEntry, BufPtr+1, (unsigned)((int)*BufPtr) );
		for ( szTmp = szEntry + *BufPtr; szTmp < szVersion; szTmp++ )
			*szTmp = ' ';

															/* Point to version number		*/
		BufPtr += *BufPtr;
		BufPtr++;

															/* Now create ascii version	*/
		itoa( (int)*(BufPtr++), szVersion, DECIMAL );
		strcat( szVersion, (int)*BufPtr < 10 ? ".0" : "." );
		itoa( (int)*(BufPtr++), strchr( szVersion, EOL ), DECIMAL );

		PutStr( szEntry );
	}
	if ( BufPtr == LieBuffer )
#ifdef BILINGUAL
	{
		if (IsDBCSCodePage())
			PutStr( szTableEmpty );
		else
			PutStr( szTableEmpty2 );
	}
#else
		PutStr( szTableEmpty );
#endif

	return( S_OK );
}


/***************************************************************************/
/* Deletes all matching entries in the version table by moving all of the	*/
/* entries following the matched entry down in the buffer to replace the	*/
/* entry being deleted. After the entries are moved down the residuals		*/
/* at the end of the table must be zeroed out. Before returning the entire */
/* end of the table buffer after the valid entries is zeroed out to remove */
/* any possible corruption.																*/
/*																									*/
/*	int DeleteEntry( void )																	*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- S_CORRUPT_TABLE if errors found else S_OK				*/
/*																									*/
/***************************************************************************/

int DeleteEntry( void )
{
	char		*pchPtr;
	char		*pchTmp;
	int		iOffset;
	UINT		uEntryLen;
	UINT		uBlockLen;

	pchPtr = LieBuffer;

	while ( (iOffset = MatchFile( pchPtr, Entry.szFileName )) >= 0 )
	{
		pchPtr = LieBuffer + iOffset;						/* Move block down		*/
		uEntryLen = (UINT)((int)*pchPtr) + 3;
		uBlockLen = (UINT)(EndBuf - pchPtr) + uEntryLen;
		memmove( pchPtr, pchPtr + uEntryLen, uBlockLen );

		pchTmp = pchPtr + uBlockLen;			 			/* Clean end of blk		*/
		memset( pchTmp, 0, uEntryLen );
	}

	if ( iOffset == S_ENTRY_NOT_FOUND )		 			/* Clean end of table	*/
	{
		if ( (pchTmp = GetNextFree()) != NULL )
			memset( pchTmp, 0, DevHdr.TblLen - (unsigned)(pchTmp - LieBuffer) );
		return( S_OK );
	}
	else
		return( S_CORRUPT_TABLE );
}


/***************************************************************************/
/* Adds a new entry to the end of any existing entries in the version		*/
/* table. There must be suffient room in the table for the entry or the	 	*/
/* call will fail with a S_NO_ROOM error returned.									*/
/*																									*/
/*	int AddEntry( void )																		*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- S_OK if room for entry else S_NO_ROOM		 			*/
/*																									*/
/***************************************************************************/

int AddEntry( void )
{
	register		iLen;
	char			*pchNext;

	iLen = (int)strlen( Entry.szFileName ) + 3;

	if ( (pchNext = GetNextFree()) != NULL && iLen <= EndBuf - pchNext )
	{
		*pchNext = (char)(iLen - 3);
		strcpy( pchNext + 1, Entry.szFileName );
		pchNext += (int)(*pchNext) + 1;
		*(pchNext++) = (char)Entry.MajorVer;
		*pchNext = (char)Entry.MinorVer;
		return( S_OK );
	}
	else
		return( S_NO_ROOM );
}


/***************************************************************************/
/* Returns the offset of a specified name in the version table. The start	*/
/* of the search is specified by the caller so that searches for duplicate */
/* entries can be made without redundency. NOTE: file name entries in the	*/
/* version table are not zero terminated strings so the comparision must	*/
/* be conditioned by length and the search strings length must be checked	*/
/* to avoid an error caused by a match of a shorter table entry name.		*/
/*																								 	*/
/*	int MatchFile( char *pchStart, char *szFile )							 		*/
/*																								 	*/
/*	ARGUMENTS:	pchStart - Ptr specifying search starting point	 				*/
/*					szFile	- Ptr to file name to match								*/		
/*	RETURNS:		int		- Offset of entry from start of version				*/
/*								  buffer or -1 if not match or							*/
/*								  S_CORRUPT_TABLE if error					 				*/
/*																								 	*/
/***************************************************************************/

int MatchFile( char *pchPtr, char *szFile )
{
	for ( ; pchPtr < EndBuf && *pchPtr != 0; pchPtr += *pchPtr + 3 )
	{
		if ( !IsValidEntry( pchPtr ) )						/* Corruption check	*/
			return( S_CORRUPT_TABLE );
		else if ( strncmp( szFile, pchPtr + 1, (UINT)((int)*pchPtr) ) == S_OK &&
					 *(szFile + *pchPtr) == EOL )
			return( pchPtr - LieBuffer );						/* Return ptr offset */
	}
	return( S_ENTRY_NOT_FOUND );								/* Return no match	*/
}

/***************************************************************************/
/* Checks a version table entry to see if it a valid entry. The definition */
/* of a valid entry is one which has a file length less than MAX_NAME_LEN	*/
/* and the entire entry lies within the version table.							*/
/*																								 	*/
/*	int IsValidEntry( char *pchPtr )														*/
/*																								 	*/
/*	ARGUMENTS:	pchPtr - Ptr to version tbl entry in table buffer				*/
/*	RETURNS:		int	 - TRUE if entry is valid else FALSE						*/
/*																								 	*/
/***************************************************************************/

int IsValidEntry( char *pchPtr )
{
	if ( (int)*pchPtr < MAX_NAME_LEN && (pchPtr + (int)*pchPtr + 3) < EndBuf )
		return( TRUE );
	else
		return( FALSE );
}


/***************************************************************************/
/* Returns a pointer to the next free entry in the version table. If there */
/* are no free entries left in the buffer a NULL ptr will be returned.		*/
/* Since DeleteEntry is always called before AddEntry there is no check	 	*/
/* for table corruption since it will have already been done by the			*/
/* DeleteEntry call.																		 	*/
/*																								 	*/
/*	char *GetNextFree( void )																*/
/*																								 	*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		char*	- Ptr to next free entry or NULL if tbl full 			*/
/*																								 	*/
/* NOTE: This caller of this function must check to be sure any entry any	*/
/*			entry to be added at the ptr returned will fit in the remaining	*/
/*			buffer area because the remaining buffer size may be less than	 	*/
/*			MAX_ENTRY_SIZE.																	*/
/*																								 	*/
/***************************************************************************/

char *GetNextFree( void )
{
	char		*pchPtr;

	for ( pchPtr = LieBuffer; *pchPtr != 0 && pchPtr < EndBuf;
			pchPtr += *pchPtr + 3 )
		;

	return( pchPtr < EndBuf ? pchPtr : NULL );
}

/***************************************************************************/
/* Opens the DOS system file and reads in the table offset and length		*/
/* structure. Then allocates a buffer and reads in the table.					*/
/*																									*/
/*	int ReadVersionTable( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- OK if successful else error code							*/
/*																									*/
/***************************************************************************/

int ReadVersionTable( void )
{
	register		iStatus;						/* Function's return value				*/
	int			iFile;						/* DOS file handle 						*/
	unsigned		uRead;						/* Number of bytes read from file	*/


			/* Open the file and read in the max buffer len from stack seg		*/

	if ( _dos_open( Entry.Path, O_RDONLY, &iFile ) != S_OK )
		return( S_FILE_NOT_FOUND );

	if ( _dos_read( iFile, &ExeHdr, sizeof( ExeHdr ), &uRead ) == S_OK &&
		  uRead == sizeof( ExeHdr ) )
	{
		FileOffset += (long)(ExeHdr.HeaderParas * 16);
		if ( SeekRead( iFile, &DevHdr, FileOffset, sizeof( DevHdr ) ) == S_OK )
		{
			if ( strncmp( DevHdr.Name, szSetVer, 8 ) == S_OK &&
				  DevHdr.VersMajor == 1 )
			{
				FileOffset += DevHdr.TblOffset;
				if ( (LieBuffer = malloc( DevHdr.TblLen )) == NULL )
					iStatus = S_MEMORY_ERROR;

				else if ( SeekRead( iFile, LieBuffer, FileOffset,
							 DevHdr.TblLen ) == S_OK )
				{
					iStatus = S_OK;
					EndBuf = LieBuffer + DevHdr.TblLen;
				}
			}
			else
				iStatus = S_INVALID_SIG;
		}
		else
			iStatus = S_FILE_READ_ERROR;
	 }
	 else
		iStatus = S_FILE_READ_ERROR;
	_dos_close( iFile );

	return( iStatus );
}

/***************************************************************************/
/* Opens the DOS system file and writes the versin table back to the file. */
/*																									*/
/*	int WriteVersionTable( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- OK if successful else error code							*/
/*																									*/
/***************************************************************************/

int WriteVersionTable( void )
{
	register			iStatus;					/* Function's return value				*/
	int				iFile;					/* DOS file handle						*/
	unsigned			uWritten;				/* Number of bytes written to file	*/
	struct find_t	Info;

	if ( _dos_findfirst( Entry.Path, _A_HIDDEN|_A_SYSTEM, &Info ) == S_OK &&
		  _dos_setfileattr( Entry.Path, _A_NORMAL ) == S_OK &&
		  _dos_open( Entry.Path, O_RDWR, &iFile ) == S_OK )
	{
		if ( _dos_seek( iFile, FileOffset, SEEK_SET ) == FileOffset &&
			  _dos_write(iFile, LieBuffer, DevHdr.TblLen, &uWritten ) == S_OK &&
			  uWritten == DevHdr.TblLen )
			iStatus = S_OK;
		else
			iStatus = S_FILE_WRITE_ERROR;

		_dos_setftime( iFile, Info.wr_date, Info.wr_time );
		_dos_close( iFile );
		_dos_setfileattr( Entry.Path, (UINT)((int)(Info.attrib)) );
	}
	else
		iStatus = S_FILE_NOT_FOUND;

	return( iStatus );
}

/***************************************************************************/
/* Seeks to the specified offset in a file and reads in the specified		*/
/* number of bytes into the caller's buffer.											*/
/*																									*/
/*	unsigned SeekRead( int iFile, char *Buf, long lOffset, unsigned uBytes )*/
/*																									*/
/*	ARGUMENTS:	iFile		- Open DOS file handle										*/
/*					Buf		- Ptr to read buffer											*/
/*					lOffset	- Offset in file to start reading at					*/
/*					uBytes	- Number of bytes to read									*/
/*	RETURNS:		unsigned	- S_OK if successfull else S_FILE_READ_ERROR			*/
/*																									*/
/***************************************************************************/

int SeekRead( int iFile, void *Buf, long lOffset, unsigned uBytes )
{
	unsigned		uRead;

	if ( _dos_seek( iFile, lOffset, SEEK_SET ) == lOffset &&
		  _dos_read( iFile, Buf, uBytes, &uRead ) == S_OK &&
		  uRead == uBytes )
		return( S_OK );
	else
		return( S_FILE_READ_ERROR );
}


#ifdef BILINGUAL
int	IsDBCSCodePage()
{
	union REGS inregs,outregs;

	inregs.x.ax = 0x4f01;
	int86(0x2f,&inregs,&outregs);

#ifdef JAPAN
	if (outregs.x.bx == 932)
#endif
#ifdef KOREA
	if (outregs.x.bx == 949)
#endif
#ifdef PRC
	if (outregs.x.bx == 936)
#endif
#ifdef TAIWAN
	if (outregs.x.bx == 950)
#endif
		return(1);
	else
		return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\setver.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                         */
/* SETVER.H                                                                */
/*                                                                         */
/*	Include file for MS-DOS set version program.                       		*/
/*                                                                         */
/*	johnhe	05-01-90                                                   		*/
/***************************************************************************/


#pragma pack(1)

/***************************************************************************/
/* Normal variable typedefs. These type defs are compatible with OS2	   	*/
/* typedefs.								   												*/
/***************************************************************************/

typedef  char           CHAR;
typedef  unsigned char  UCHAR;
typedef  int            INT;
typedef  unsigned int   UINT;
typedef  long           LONG;
typedef  unsigned long  UL;
typedef  float          FLOAT;
typedef  double         DOUBLE;

/***************************************************************************/
/* Standard global constants.						   									*/
/* Don't change the TRUE define because some functions depend on it being  */
/* 1 instead of !FALSE.							   										*/
/***************************************************************************/

#ifndef	FALSE
  #define FALSE    	0
#endif

#ifndef	TRUE
  #define TRUE 	   1
#endif

#define	EOL	  		'\0'

#define	HEX	  		16
#define	DECIMAL	  	10
#define	OCTAL      	8

/***************************************************************************/
/* Module specific constants						   									*/
/***************************************************************************/

#define	MAX_NAME_LEN			13
#define	MAX_ENTRY_SIZE			(MAX_NAME_LEN + 1 + 2 + 1)
#define	MAX_PATH_LEN			68

#define	MAX_VERSION 			0x0a00		/* Max version 9.99	*/
#define	MIN_VERSION 			0x020b		/* Min version 2.11	*/

#define	S_ERROR					-1
#define	S_OK						0
#define	S_INVALID_SWITCH		-1
#define	S_INVALID_FNAME		-2
#define	S_MEMORY_ERROR 		-3
#define	S_BAD_VERSION_FMT 	-4
#define	S_ENTRY_NOT_FOUND 	-5
#define	S_FILE_NOT_FOUND		-6
#define	S_BAD_DRV_SPEC 		-7
#define	S_TOO_MANY_PARMS		-8
#define	S_MISSING_PARM			-9	    		/* Missing version number or /d	*/
#define	S_FILE_READ_ERROR		-10
#define	S_CORRUPT_TABLE		-11
#define	S_INVALID_SIG			-12
#define	S_NO_ROOM				-13
#define	S_FILE_WRITE_ERROR	-14
#define	S_INVALID_PATH			-15

#define	DO_LIST 					1
#define	DO_ADD_FILE 			2
#define	DO_DELETE 				3
#define	DO_HELP   				4
#define	DO_QUIET					5

#define	VERSION_COLUMN			16				/* Screen column for version #	*/
#define	SIGNATURE_STR			"PCMN"		/* Signature string in MSDOS.SYS	*/
#define	SIGNATURE_LEN			4
#define	BUF_LEN					4096

/***************************************************************************/
/* Defines for possible command line switches.										*/
/***************************************************************************/

#define	HELP_SWITCH		"?"
#define	DEL_SWITCH		"DELETE"
#define	SWITCH_CHAR 	'/'
#define	QUIET_SWITCH   "QUIET"

/***************************************************************************/

struct TableEntry
{
	char		Drive;
#ifdef JAPAN
	char		Path[ MAX_PATH_LEN+10 ];
#else
	char		Path[ MAX_PATH_LEN ];
#endif
	char		szFileName[ MAX_NAME_LEN + 1 ];
	UCHAR		MajorVer;
	UCHAR		MinorVer;
};

struct ExeHeader
{
	UINT		Signature;
	UINT		LastPageLen;
	UINT		TotalFilePages;
	UINT		NumRelocEntries;
	UINT		HeaderParas;
	UINT		MinEndParas;
	UINT		MaxEndParas;
	UINT		StackSeg;
	UINT		StackPtr;
	UINT		NegChkSum;
	UINT		IndexPtr;
	UINT		CodeSeg;
	UINT		RelocTblOffset;
	UINT		OverlayNum;
};

struct DevHeader
{
	char far		*NextDevice;
	unsigned		DeviceAttrib;
	char near	*Strategy;
	char near	*Entry;
	char			Name[ 8 ];
	char			VersMinor;
	char			VersMajor;
	long			TblOffset;
	unsigned		TblLen;
};

/***************************************************************************/
/* Function prototypes for SETVER.C                                        */
/***************************************************************************/

extern  int   main( int argc, char *argv[] );
static  int   Error( int iErrCode );
static  int   DoFunction( int iFunction );

static  void  DisplayMsg( char *tbl[] );
static  int   DeleteEntry( void );
static  int   AddEntry( void );

static  int   DisplayTable( void );
static  int   MatchFile( char *pchStart, char *szFile );
static  int   IsValidEntry( char *pchPtr );
static  char  *GetNextFree( void );

static  int   ReadVersionTable( void );
static  int   WriteVersionTable( void );

static  int   SeekRead( int iFile, void *Buf, long lOffset, unsigned uBytes );

#ifdef BILINGUAL
static	int	IsDBCSCodePage(void);
#endif

/***************************************************************************/
/* Function prototypes for PARSE.C                                         */
/***************************************************************************/

extern  int   ParseCmd( int argc, char *argv[], struct TableEntry *Entry );
static  int   IsValidFile( char *szFileName );
static  UINT  ParseVersion( char *szVersion );
static  int   IsDigitStr( char *szStr );
static  char  *SkipLeadingChr( char *szStr, char chChar );
static  void  RemoveTrailing( char *szStr, char chChar );
static  int   MatchSwitch( char *szCmdParm, char *szTestSwitch );
static  int   IsValidFileName( char *szFile );
static  int   IsReservedName( char *szFile );
static  int   IsWildCards( char *szFile );
static  int   ValidFileChar( char *szFile );
static  int   IsValidFileChr( char Char );

#ifdef DBCS 
static  int   IsDBCSLeadByte(unsigned char);
static	int   CheckDBCSTailByte(unsigned char *,unsigned char *);
#endif

/***************************************************************************/
/* Function prototypes for DOS.ASM                                         */
/***************************************************************************/

extern  int   IsValidDrive( unsigned DrvLetter );
extern  void  PutStr( char *String );
extern  long  _dos_seek( int Handle, long lOffset, int Mode );
extern  int	  SetVerCheck ( void );					/* M001 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\device.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;========================================================
COMMENT #

	DEVICE.ASM


	=================================================
	Device driver to activate the version table in
	MS-DOS 5.0. Upon initialization the driver will
	set the DWORD PTR in the DOS data area at offset
	05dh to point to the version table in the device
	driver and also calculates the minimum install
	size needed to include only the valid entries
	in the default version table.


	================================================

	johnhe - 12/30/90

END COMMENT #

; =======================================================

INCLUDE		VERSIONA.INC

CMD		EQU	2		; Command field offset in packet
STATUS		EQU	3		; Return status field offset
DEV_LEN		EQU	14		; Device length field offset

DOS_TABLE	EQU	5dh		; Lie table ptr offset in dos data
TABLE_LEN	EQU	2048		; Max size of lie table

; ====================================================================

A_DEVICE SEGMENT BYTE PUBLIC 'CODE'
	ASSUME	CS:A_DEVICE, DS:NOTHING, ES:NOTHING

PUBLIC	ENTRY
PUBLIC	DeviceInit

; ====================================================================


DeviceHeader:
		dw	-1,-1
		dw	1000000000000000b; Device attributes (character device)
		dw	Strategy	; Device strategy entry offset
		dw	Entry		; Device entry offset
		db	'SETVERXX'
ExtendedHeader:				; Extended header is used by the
					; SETVER.EXE program to determine
					; where the version table is located
					; within the .EXE file
VerMinor	db	0		; Version 1.0 of Setver
VerMajor	db	1		;
TableOffset	dd	OFFSET VerList	; Offset of table from device start
TableLength	dw	TABLE_LEN	; Max table size
PtrSave	dd	(?)			; Address of device packet

; ====================================================================

; ====================================================================

StratProc PROC	FAR

Strategy:
	mov	WORD PTR CS:[PtrSave],BX	; Save device packet for
	mov	WORD PTR CS:[PtrSave][2],ES	; use on call to dev entry
	ret

StratProc	ENDP	
	
; ====================================================================

; ====================================================================

Entry PROC FAR				; Device driver entry location
	push	BX
	push	DS
	
	lds	BX,[PtrSave]		; DS:BX --> Cmd structure
	mov	AL,DS:[BX].CMD		; AL == command from sysinit
	cbw
	or	AX,AX			; Check for init function zero
	jnz	CmdError		; If not init then error
	jmp	DeviceInit		; Jmp to initialize device

CmdError:
	mov	AL,3			; Return invalid function code
	mov	AH,10000001b		; Signal error in AH

SetStatus:
	mov	[BX].Status,AX		 ; Copy status to packet

	pop	DS
	pop	BX
	ret

Entry ENDP

; ====================================================================
; ====================================================================

SIG	db	'PCMN'
TblLen	dw	TABLE_LEN

; ====================================================================
; ====================================================================


; NTVDM commented out unsupported drivers\apps 19-Aug-1992 Jonle
if 0
        db      10,"WIN200.BIN"         ,3,40   ; windows 2.x
        db      10,"WIN100.BIN"         ,3,40   ; win 1.x
        db      11,"WINWORD.EXE"        ,4,10   ; winword 1.0
	db	9, "EXCEL.EXE"		,4,10	; excel 2.x
        db      11,"HITACHI.SYS"        ,4,00   ; CDROMS
        db      10,"MSCDEX.EXE"         ,4,00   ; CDROMS
        db      10,"REDIR4.EXE"         ,4,00   ; Banyan networks
        db      7, "NET.EXE"            ,4,00   ; 3+ Open
        db      7, "NET.COM"            ,3,30   ; IBM PCLP
        db      12,"NETWKSTA.EXE"       ,4,00   ; 3+ Open
        db      12,"DXMA0MOD.SYS"       ,3,30   ; Token ring
        db      7, "BAN.EXE"            ,4,00   ; Banyan
        db      7, "BAN.COM"            ,4,00   ; Banyan
        db      11,"MSREDIR.EXE"        ,4,00   ; LanMan
	db      9, "METRO.EXE"          ,3,31   ; Lotus Metro
        db      12,"IBMCACHE.SYS"       ,3,40   ; IBM CHACHE Program
        db      11,"REDIR40.EXE"        ,4,00   ; IBM PCLP 1.3/4 redirector
	db	6, "DD.EXE"		,4,01	; Laplink III software
	db	6, "DD.BIN"		,4,01	; Laplink III software
	db	7, "LL3.EXE"		,4,01   ; Laplink III software
        db      9, "REDIR.EXE"          ,4,00   ; DOS 4 redir
        db      9, "SYQ55.SYS"          ,4,00   ; Removable SCSII drive from Syquest
        db      12,"SSTDRIVE.SYS"       ,4,00   ; Columbia SCSI driver
        db      8, "ZDRV.SYS"           ,4,01   ; Unisys CD-ROM B#4734
        db      8, "ZFMT.SYS"           ,4,01   ; Unisys CD-ROM B#4734
        db      11,"TOPSRDR.EXE"        ,4,00   ; TOPS redir Bug 5968
endif

        public  VerList

VerList db      11,"WINWORD.EXE"        ,4,10   ; winword 1.0
	db	9, "EXCEL.EXE"		,4,10	; excel 2.x
        db      9, "METRO.EXE"          ,3,31   ; Lotus Metro
        db      6, "DD.EXE"             ,4,01   ; Laplink III software
	db	6, "DD.BIN"		,4,01	; Laplink III software
        db      7, "LL3.EXE"            ,4,01   ; Laplink III software

        db      (TABLE_LEN - ($ - VerList)) dup (0)
	db	0


; ====================================================================
; Device initialization function first determines minimum size the
; driver needs to be and then sets the DWORD PTR in the DOS data area
; to the location of the version table.
; ====================================================================

DeviceInit:

	push	BX
	push	CX
	mov	AH,30h			; Get version
	int	21h
	pop	CX
	pop	BX

	cmp	AX,expected_version
	je	SetupScan
	xor	AX,AX			; Set end of device to 0
	jmp	SHORT SetDevEnd
	
SetupScan:
	push	SI
	push	DS
	mov	AX,CS
	mov	DS,AX
	mov	SI, OFFSET VerList	; DS:SI --> Version table

	xor	AX,AX			; Clear high byte of AX
ScanLoop:
	lodsb				; Grab the name length
 	or	AX,AX			; Test for end of the table
	jz	FoundEnd
	inc	AX			; Add 2 bytes for the version number
	inc	AX
	add	SI,AX			; Make SI so it points to next entry
	jmp	SHORT ScanLoop

FoundEnd:
	mov	AX,SI			; AX == Offset of end of table
	inc	AX			; Need 1 zero byte at end of table
	pop	DS
	pop	SI

SetTablePtr:
	push	BX
	push	ES

	push	AX			; Save end of device offset
	mov	AH,52h			; Get the DOS data segment
	int	21h
	pop	AX			; Restore end of device offset to AX

	cli				; Safety measure when altering DOSdata
	mov	WORD PTR ES:[DOS_TABLE], OFFSET VerList ; Offset of lie table
	mov	WORD PTR ES:[DOS_TABLE][2],CS	; Segment of lie table
	sti
	pop	ES
	pop	BX

SetDevEnd:
	mov	WORD PTR DS:[BX].DEV_LEN,AX ; Set end of driver @ end of list
	mov	DS:[BX].DEV_LEN[2],CS	; Set device segment
	mov	AH,00000001b		; Normal status return

	jmp	SetStatus		; End of init code

; ====================================================================

A_DEVICE ENDS

; ====================================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\parse.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/* PARSE.C 													 									*/				 
/*																									*/						
		 
/*	Command line parsing functions for SETVER.C.										*/
/*																									*/
/*	Valid command lines are:																*/
/*		List table: 					SETVER [D:\path] 									*/
/*		Add entry:						SETVER [D:\path] name.ext X.XX			 	*/
/*		Delete entry:					SETVER [D:\path] name.ext /DELETE		 	*/
/*		Display help					SETVER /? 											*/
/*		Delete entry quietly:		SETVER [D:\path] name.ext /DELETE /QUIET	*/
/*																									*/
/*	The following error codes are returned: 											*/
/*																									*/
/*		S_INVALID_SWITCH	Invalid switch										 			*/
/*		S_INVALID_FNAME	Invalid file name 								 			*/
/*		S_BAD_VERSION_FMT	Invalid version number format 		 					*/
/*		S_BAD_DRV_SPEC		Invalid drive/path specifier				 				*/
/*		S_TOO_MANY_PARMS	Too many command line parameters	 						*/
/*		S_MISSING_PARM		Missing parameter 								 			*/
/*		S_INVALID_PATH		Path specifier is invalid									*/
/*																									*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

#include	<stdio.h>
#include	<stdlib.h>
#include	<ctype.h>
#include	<string.h>
#include	<dos.h>
#include	<direct.h>

#include	<setver.h>

/***************************************************************************/
/* Parses the command line to get the optional drive letter, optional 		*/
/* executable file name and optional switch /DELETE. Also handles a single */
/* "/?" switch for displaying command help. The /DELETE switch will accept */
/* any number of chars in the the word DELETE for the switch. 	Also			*/
/* supports a /QUIET switch, similarly handled, but only valid in 			*/
/* combination with the /DELETE switch													*/
/*																									*/
/*	int ParseCmd( int argc, char *argv[], struct TableEntry *Entry )	 		*/
/*																									*/
/*	ARGUMENTS:	argc	- Count of command line arguments 					 		*/
/*					argv	- Array of ptrs to command line argments		 			*/
/*					Entry - Ptr to struct to be filled in 						 		*/
/*	RETURNS:		int 	- Valid function number or parse error code  			*/
/*																									*/
/***************************************************************************/

int ParseCmd( int argc, char *argv[], struct TableEntry *Entry )
{
	register		Funct;
	unsigned		uVersion;
	int			iTmp;
	int			iStrLen;

	strcpy( Entry->Path, argv[0] );			/* Set default setver.exe path	*/

	if ( argc == 1 )								/* Chk for default of 0 parms		*/
		return( DO_LIST );						/* No args so just do a listing	*/

	for ( iTmp = 1; iTmp < argc; iTmp++ )
                strupr( argv[ iTmp ] );                                        /* Convert params to upper case */

														/* Chk for help switch				*/
	if ( MatchSwitch( argv[ 1 ], HELP_SWITCH ) )
		return( argc > 2 ? S_TOO_MANY_PARMS : DO_HELP);

	iTmp = 1;

												/* Chk for optional drive:\path spec	*/
	if ( strchr( argv[1], ':' ) )
	{
                if ( IsValidDrive( (unsigned)argv[1][0] - 0x40 ) && argv[1][1] == ':' )
		{
			if ( (iStrLen = strlen( argv[1] )) > (MAX_PATH_LEN - 1) )
				return( S_INVALID_PATH );
			else
			{
				strcpy( Entry->Path, argv[1] );
#ifdef DBCS
				if ( (*(Entry->Path + iStrLen - 1) != '\\' && argv[1][2] != EOL )
					|| CheckDBCSTailByte(Entry->Path,Entry->Path + iStrLen - 1) )
#else
				if ( *(Entry->Path + iStrLen - 1) != '\\' && argv[1][2] != EOL )
#endif
					strcat( Entry->Path, "\\" );
				strcat( Entry->Path, "SETVER.EXE" );
				iTmp++;
			}
		}
		else
			return( S_BAD_DRV_SPEC );
	}

	if ( iTmp >= argc )
		Funct = DO_LIST;

	else if ( IsValidFileName( argv[ iTmp ] ) )
	{
		strcpy( Entry->szFileName, argv[ iTmp++ ] );

		if ( iTmp >= argc )				/* Version # or /D or /Q must follow	*/
			Funct = S_MISSING_PARM;

				/* note that Quiet switch requires Del switch also be supplied */
		else if ( MatchSwitch( argv[ iTmp ], DEL_SWITCH ) )
		{
			if ( ++iTmp < argc )	 /* more args left */
			{
				if (MatchSwitch(argv[iTmp], QUIET_SWITCH))
					Funct = (++iTmp < argc ? S_TOO_MANY_PARMS : DO_QUIET);
				else
					Funct = S_TOO_MANY_PARMS;
			}
			else
				Funct = DO_DELETE;
		}
		else if ( MatchSwitch( argv[iTmp], QUIET_SWITCH ) )
		{
			if ( ++iTmp < argc )						 /* must find delete switch	*/
				if (MatchSwitch(argv[iTmp], DEL_SWITCH))
					Funct = (++iTmp < argc ? S_TOO_MANY_PARMS : DO_QUIET);
				else
					Funct = S_INVALID_SWITCH;
			else
				Funct = S_INVALID_SWITCH;
		}
		else if ( *argv[iTmp] == '/' )		/* Make sure not a bogus switch	*/
			Funct = S_INVALID_SWITCH;
		else if ( (uVersion = ParseVersion( argv[ iTmp++ ] )) != 0 )
		{
			Entry->MajorVer = (char)(uVersion >> 8);
			Entry->MinorVer = (char)(uVersion & 0xff);
			Funct = (iTmp < argc ? S_TOO_MANY_PARMS : DO_ADD_FILE);
		}
		else
			Funct = S_BAD_VERSION_FMT;
	}
	else
		Funct = S_INVALID_FNAME;

	return( Funct );
}


/***************************************************************************/
/* Parses a DOS major and minor version number from an ascii string in the */
/* form of "00.00" where the major number is on the left of the decminal	*/
/* point and the minor version follows the version number. Valid version	*/
/* numbers are decimal numbers between 2.00 and 9.99.				 				*/
/*										 															*/
/*	unsigned ParseVersion( char *szDosVer )					 						*/
/*										 															*/
/*	ARGUMENTS:	szDosVer - Ptr to an ascii verion number string 	 			*/
/*	RETURNS:		unsigned - Version # in the form (Major << 8) + 	 			*/
/*								  Minor or 0 if not valid version string  			*/
/*																									*/
/***************************************************************************/

unsigned ParseVersion( char *szDosVer )
{
	unsigned		Version = 0;
	size_t		Len;
	char			*szMinor;

		/* First parse the minor version number */
	if ( (szMinor = strchr( szDosVer, '.' )) != NULL )
	{
		*szMinor = EOL;
		szMinor++;
		if ( (Len = strlen( szMinor )) > 2	|| !IsDigitStr( szMinor ) )
			Version = (unsigned) S_ERROR;
		else
		{
			Version = (unsigned)atoi( szMinor );
			while( Len++ < 2 )								/* Convert .x to .x0	*/
				Version *= 10;
		}
	}
		/* Now get the major part of the number */
	szDosVer = SkipLeadingChr( szDosVer, '0' );
	if ( Version == (unsigned)S_ERROR || strlen( szDosVer ) > 2 ||
			 !IsDigitStr( szDosVer ) )
		Version = 0;
	else
		Version |= ((unsigned)atoi( szDosVer ) << 8);

		/* Check for min and max versions */
	if ( Version < MIN_VERSION || Version >= MAX_VERSION )
		Version = 0;

	return( Version );
}

/***************************************************************************/
/* Checks a string to verify that all characters in the string are decmial */
/* numbers 0-9.									 											*/
/*										 															*/
/*	int IsDigitStr( char *szStr )						 									*/
/*										 															*/
/*	ARGUMENTS:	szStr - Ptr to ascii string to be scanned 				 		*/
/*	RETURNS:		int 	- TRUE if all chars are numbers else FALSE	 			*/
/*										 															*/
/***************************************************************************/

int IsDigitStr( char *szStr )
{
	while( *szStr != EOL	)
	{
		if ( !isdigit( *(szStr++) ) )
			return( FALSE );
	}
	return( TRUE );
}

/***************************************************************************/
/* Accepts a pointer to a string and a single character to match. Returns  */
/* a ptr to the first character in the string not matching the specified	*/
/* character.									 												*/
/*										 															*/
/*	char *SkipLeadingChr( char *szStr, char chChar )			 					*/
/*										 															*/
/*	ARGUMENTS:	szStr  - Ptr to an ascii string										*/
/*					chChar - Ascii character to match 								 	*/
/*	RETURNS:		char * - Ptr to first char in the string not			 			*/
/*								matching the specified character 				 		*/
/***************************************************************************/

char *SkipLeadingChr( char *szStr, char chChar )
{
	while( *szStr == chChar )
		szStr++;
	return( szStr );
}


/***************************************************************************/
/* Compares a cmd line switch against a test string. The test switch is an */
/* ascii string which will be used as a pattern to be matched against the  */
/* command string. The command string may be any subset of the test string */
/* which has been prefixed with a switch character.				 				*/
/*										 															*/
/*	int MatchSwitch( char *szCmdParm, char *szTestSwitch )			 			*/
/*										 															*/
/*	ARGUMENTS:	szCmdParm		- Command line parameter to be tested 			*/
/*					szTestSwitch	- Switch to test command line against 			*/
/*	RETURN:		int				- TRUE if there is a match else FALSE 			*/
/*																									*/
/***************************************************************************/

int MatchSwitch( char *szCmdParm, char *szTestSwitch )
{
		/* Must have a leading '/' and at least 1 char */
	if ( *(szCmdParm++) != SWITCH_CHAR || *szCmdParm == EOL )
		return( FALSE );

	while ( *szTestSwitch != EOL && *szTestSwitch == *szCmdParm )
		szTestSwitch++, szCmdParm++;

	return( *szCmdParm == EOL ? TRUE : FALSE );
}


/***************************************************************************/
/* Scans a string to see if the string can be used a valid file name.		*/
/* The scan checks to be sure each character in the name is a valid		 	*/
/* character for a path name. There is also a check to be sure that only	*/
/* there is not more than 1 decimal in the name and that if there is a		*/
/* decimal that the primary name and extension do not exceed the maximum	*/
/* length of 8 chars for primary and 3 for extension. If the name does		*/
/* not include a decimal the max length is 8 characters.			 				*/
/*										 															*/
/*	int IsValidFileName( char *szPath )					 								*/
/*										 															*/
/*	ARGUMENTS:	szFile - String containing a file name. 					 		*/
/*	RETURNS	:	int 	 - TRUE if valid name else FALSE. 					 		*/
/*										 															*/
/***************************************************************************/

int IsValidFileName( char *szFile )
{
	char *szDecimal;

	RemoveTrailing( szFile, '.' );

		/*
		 *	Check to be sure length of filename is greater than 0,
		 *	there are no invalid file characters,
		 *	there is no path associated with the filename,
		 *	the filename is not a reserved DOS filename, and
		 *	there are no wildcard characters used in the filename.
	 	*/
#ifdef DBCS
	if ( strlen( szFile ) > 0 && ValidFileChar( szFile ) &&
			 ((strchr(szFile, '\\') == NULL) || CheckDBCSTailByte(szFile,strchr(szFile, '\\'))) &&
			 !IsReservedName( szFile ) && !IsWildCards( szFile ) )
#else
	if ( strlen( szFile ) > 0 && ValidFileChar( szFile ) &&
			 (strchr(szFile, '\\') == NULL) &&
			 !IsReservedName( szFile ) && !IsWildCards( szFile ) )
#endif
	{
			/* Check for appropriate 8.3 filename */
		if ( (szDecimal = strchr( szFile, '.' )) != NULL )
		{
			if ( strchr( szDecimal + 1, '.' ) == NULL &&	/* Chk for more '.'s */
					 (szDecimal - szFile) <= 8 && 			/* Chk lengths			*/
					 (strchr( szDecimal, EOL ) - szDecimal - 1) <= 3 )
				return ( TRUE );
		}
		else if ( strlen( szFile ) <= 8 )
			return ( TRUE );
	}
	return( FALSE );
}

/***************************************************************************/
/* Checks all of the characters in a string to see if they are vaild path  */
/* name characaters.								 											*/
/*										 															*/
/*	int ValidFileChar( char *szFile )					 								*/
/*										 															*/
/*	ARGUMENTS:	szFile - File name string 												*/
/*	RETURN:		int 	 - TRUE if chars in string are valid else 	 			*/
/*								FALSE																*/
/*										 															*/
/***************************************************************************/

int ValidFileChar( char *szFile )
{
	int IsOk = TRUE;

	while ( IsOk && *szFile != EOL )
	#ifdef DBCS
		if (IsDBCSLeadByte(*szFile))
			szFile += 2;
		else
	#endif
		IsOk = IsValidFileChr( *(szFile++) );
	return( IsOk );
}


/***************************************************************************/
/* Checks a file or path name against a list of reserved DOS filenames and */
/* returns TRUE if the name is a reserved name. The function must first		*/
/* off any extension from the name.						 								*/
/*										 															*/
/*	int IsReservedName( char *szFile )					 								*/
/*										 															*/
/*	ARGUMENTS:	szFile - File name string				 								*/
/*	RETURN:		int 	 - TRUE if name is reserved DOS name				 		*/
/*																									*/
/***************************************************************************/

int IsReservedName( char *szFile )
{
	register Status;
	register i;
	char *szTmp;
	static char *apszRes[] = { "AUX", "CLOCK$", "COM1", "COM2",
										"COM3", "COM4", "CON", "LPT", "LPT1",
										"LPT2", "LPT3", "LST", "NUL", "PRN", NULL };

	if ( (szTmp = strchr( szFile, '.' )) != NULL )
		*szTmp = EOL;
	for ( i = 0, Status = FALSE; Status == FALSE && apszRes[i] != NULL; i++ )
                Status = !strcmpi( szFile, apszRes[i] );
	if ( szTmp != NULL )
		*szTmp = '.';

	return( Status );
}

/***************************************************************************/
/* Checks a file or path name for any wildcards (* and ?).	If wildcard 	*/
/* characters exist, it returns TRUE.  Otherwise, it returns FALSE. 			*/
/*										 															*/
/*	int IsWildCards( char *szFile )									 					*/
/*										 															*/
/*	ARGUMENTS:	szFile - File name string				 								*/
/*	RETURN:		int 	 - TRUE if wildcards exist in name					 		*/
/*																									*/
/***************************************************************************/

int IsWildCards( char *szFile )
{
	if ( ((strchr( szFile, '*' )) != NULL) ||
		  ((strchr( szFile, '?' )) != NULL) )
		return( TRUE );
	return( FALSE );
}


/***************************************************************************/
/* Validates a character as a valid path and file name character. 			*/
/*													 												*/
/*	IsValidFileChr( char Char )						 									*/
/*													 												*/
/*	ARGUMENTS:	Char - Character to be tested 										*/
/*	RETURNS:    int  - TRUE if a valid character else FALSE 		 				*/
/*													 												*/
/***************************************************************************/

int IsValidFileChr( char Char )
{
	int IsOk;

	switch( Char )
	{
		case ' '	:
		case '\t' :
		case 0x0d :
		case '/'	:
		case ':'	:
		case ';'	:
		case '='	:
		case '<'	:
		case '>'	:
		case '|'	:
			IsOk = FALSE;
			break;
		default		:
			IsOk = TRUE;
			break;
	}
	return( IsOk );
}

/***************************************************************************/
/* Removes all trailing characters of the type specified from a string. 	*/
/*																									*/
/*	void RemoveTrailing( char *String, char Char )							 		*/
/*																									*/
/*	ARGUMENTS:	String - pointer to a string				 							*/
/*					Char	 - ascii char to remove from end of string				*/
/*	RETURNS:	void							 													*/
/*										 															*/
/***************************************************************************/

void RemoveTrailing( char *String, char Char )
{
	char *EndOfString;

	EndOfString = strchr(String, EOL );
	while( EndOfString != String && *(EndOfString-1) == Char )
		EndOfString--;
	*EndOfString = EOL;
}

/***************************************************************************/
/* Copyright (c) 1989 - Microsoft Corp.                                    */
/* All rights reserved.                                                    */
/*                                                                         */
/* Returns a pointer to the first character in the filename which may or	*/
/* may not be appended to a path.														*/
/* 																								*/
/* char *ParseFileName( char *szPath ) 												*/
/* 																								*/
/* ARGUMENTS:	szPath	- Ptr to a file path in the form d:\xxxx\xxx.xxx	*/
/* RETURNS: 	char *	- Ptr to file name or character after last			*/
/* 							  backslash or ':' in the string if the path did	*/
/* 							  not contain a file name									*/
/*										 															*/
/***************************************************************************/

char *ParseFileName( char *szPath )
{
	char	*szPtr;

	for ( szPtr = szPath;
			*szPtr != EOL && (IsValidFileChr( *szPtr ) ||	*szPtr == ':');
			szPtr++ )
		#ifdef DBCS
			if (IsDBCSLeadByte(*szPtr))
				szPtr++;
		#else
			;
		#endif

	#ifdef DBCS
		while(( --szPtr >= szPath && *szPtr != '\\' && *szPtr != ':') ||
				(szPtr >= szPath && CheckDBCSTailByte(szPath,szPtr)) )
	#else
		while( --szPtr >= szPath && *szPtr != '\\' && *szPtr != ':' )
	#endif
			;

	return( ++szPtr );
}

#ifdef DBCS
/***************************************************************************/
/* Test if the character is DBCS lead byte. 											*/
/*																									*/
/*	int IsDBCSLeadByte(char c)																*/
/*																									*/
/*	ARGUMENTS:	c - character to test 													*/
/*	RETURNS:	TRUE if leadbyte																*/
/*										 															*/
/***************************************************************************/

int IsDBCSLeadByte(c)
unsigned char c;
{
	static unsigned char far *DBCSLeadByteTable = NULL;
	union REGS inregs,outregs;
	struct SREGS segregs;
	unsigned char far *p;


	if (DBCSLeadByteTable == NULL)
	{
		inregs.x.ax = 0x6300;							/* get DBCS lead byte table */
		intdosx(&inregs, &outregs, &segregs);
		FP_OFF(DBCSLeadByteTable) = outregs.x.si;
		FP_SEG(DBCSLeadByteTable) = segregs.ds;
	}

	p = DBCSLeadByteTable;
	while (p[0] || p[1])
	{
		if (c >= p[0] && c <= p[1])
			return TRUE;
		p += 2;
	}
	return ( FALSE );
}


/***************************************************************************/
/*
/*	Check if the character point is at tail byte
/*
/*	input:	*str = strart pointer of the string
/*		*point = character pointer to check
/*	output:	TRUE if at the tail byte
/*
/***************************************************************************/

int	CheckDBCSTailByte(str,point)
unsigned char *str,*point;
{
	unsigned char *p;

	p = point;
	while (p != str)
	{
		p--;
		if (!IsDBCSLeadByte(*p))
		{
			p++;
			break;
		}
	}
	return ((point - p) & 1 ? TRUE : FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\dos.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;================= DOS.ASM =========================
COMMENT #


  johnhe - 05/09/90

END COMMENT #

;========================================================

INVALID_DRIVE	EQU	15
DOS_PUTCHAR	EQU	02

DOSSEG
.Model	  SMALL,C


.Data

CrLf	db	0dh, 0ah, 0


.Code

; =========================================================================
; Verifies that a drive exists using the IsChangeable IOCtl function.
;
; int IsValidDrive( char DrvLetter )
;
; ARGUMENTS:	DrvLetter	- The drive letter to verify
; RETURNS:	int		- FALSE if not a valid drive letter
;				  else !FALSE
;
; =========================================================================

IsValidDrive	PROC Drive:WORD

	mov	BX,Drive		; BX = Drive number
	cmp	BX,26			; Make not greater than drive Z
	jg	NotValid

	mov	AX,4408h		; AX = IOCtl Is changeable function
	int	21h
	jnc	IsValid			; Drv valid
					; Else check error code to see if
	cmp	AX,INVALID_DRIVE	; invalid drive error
	jne	IsValid 		; Drive is valid

NotValid:
	xor	AX,AX			; Return FALSE
	jmp	SHORT DrvChkRet		; Done

IsValid:
	mov	AX,1			; Return TRUE

DrvChkRet:
	ret				; Return AX = TRUE or FALSE
	
IsValidDrive	ENDP

; =========================================================================
; Displays a zero terminated ascii string on the console followed by
; a carriage return line feed conbination.
;
; void PutStr( char *String )
;
; ARGUMENTS:	String - Ptr to string to be displayed
; RETURNS:	void
;
; =========================================================================

PutStr PROC USES SI, String:PTR

	mov	SI,String			; DS:SI -> to caller's string
	mov	CX,2				; 2 loops 

PrintLoop:
	cld					; Always clear direction flag
	lodsb					; Load char in AL & inc SI
	or	AL,AL				; Test for EOL character
	jz	EndOfStr

	mov	AH,DOS_PUTCHAR			; AH = DOS put char function
	mov	DL,AL				; Put character to print in DL
	int	21h				; Output the character
	jmp	SHORT PrintLoop			; Go back and do the next one

EndOfStr:
	mov	SI,OFFSET CrLf			; DS:SI -> CR/LF return string
	loop	PrintLoop			; Go back and print CR/LF

	ret

PutStr ENDP

; =========================================================================
;
; Seeks to the specified offset in an open disk
; disk file.
; 
; long	_dos_seek( int Handle, long lOffset, int Mode )
; 
; ARGUMENTS:	Handle	- Open DOS file handle
; 		lOffset - Offset to seek to in bytes
; 		Mode	- Seek mode as described below
; 			  0 = Beginning of file + offset
; 			  1 = Current file position + offset
; 			  2 = End of file + offset
; RETURNS:	long	- New offset in file is success
; 			  or -1L if error
; =========================================================================
  
_dos_seek PROC USES ES, Handle:WORD, lOffset:DWORD, Mode:BYTE

	mov	AH,42h		; AH = DOS file SEEK function
	mov	AL,Mode		; AL = SEEK mode specified by caller
	mov	BX,Handle	; BX = Open file handle from caller

LoadOffset:
	les	DX,lOffset	; Load file offset into ES:DX
	mov	CX,ES		; CX:DX = Offset to seek to in the file

Int21Call:
	int	21h		; DOS call
	jc	SeekError	; Error check
	jmp	SHORT SeekReturn ;Everything is OK

SeekError:
	mov	AX,-1		; Error code
	cwd			; Extend sign to make a LONG (dword)

SeekReturn:
	ret

_dos_seek ENDP

; =======================================================
; M001 ; Start of changes to check for SETVER.EXE in the
;        device chain.
; =======================================================

.DATA

SetVerStr	db	'SETVERXX'

LEN_SETVERSTR	EQU	$-SetVerStr

.Code

; =======================================================
;
; Checks to see if SETVER.EXE was installed as as a device
; driver by walking the device chain looking for the name
; "SETVERXX".
;
; int SetVerCheck ( void )
; 
; ARGUMENTS:	NONE
; RETURNS:	int - TRUE if SetVer device driver is installed else FALSE
;
; =======================================================

SetVerCheck PROC USES SI DI DS ES
	ASSUME	ES:NOTHING

	mov	AH,52h
	int	21h			; ES:BX --> first DBP

	push	BX			; Save offset
	mov	AH,30h
	int	21h			; AL == Major version
	pop	DI			; Restore DPB offset to BX

	add	DI,17h			; DOS 2.x offset of NULL device is 17h
	cmp	AL,2			; See if version is really 2.x
	jle	@f
	add	DI,0bh			; Offset for DOS > 2.x is 22h
@@:
	mov	AX,@DATA
	mov	DS,AX

	mov	SI,OFFSET SetVerStr
	mov	CX,LEN_SETVERSTR
	cld

NameCmpLoop:
	cmp	DI,0ffffh		; See if ES:DX is xxxx:ffff
	je	NoSetVer

SaveSetup:
	push	CX			; Save name length
	push	DI			; Save ptr to current device
	push	SI			; Save ptr to SetVer string
	add	DI,0ah			; ES:DI --> Device name + 1
	
	repe	cmpsb
	pop	SI
	pop	DI
	pop	CX

	je	FoundSetVer
	les	DI,ES:[DI]		; Load ptr to next device.
	jmp	SHORT NameCmpLoop

NoSetVer:
	xor	AX,AX
	jmp	SHORT SetVerReturn

FoundSetVer:
	mov	AX,1

SetVerReturn:
	ret

SetVerCheck ENDP

; =======================================================
; M001 ; End of changes
; =======================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\br\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
        "\r\nERROR: ",
        "Opo invlida.",
        "Nome de arquivo invlido.",
        "No h memria suficiente.",
        "Verso invlida. O formato deve ser 2.11 - 9.99.",
        "No foi localizada a entrada especificada na tabela de verso.",
        "No foi possvel encontrar o arquivo SETVER.EXE.",
        "A unidade especificada no  vlida.",
        "H muitos parmetros na linha de comando.",
        "Falta um parmetro.",
        "Lendo o arquivo SETVER.EXE.",
        "A tabela de verso est danificada.",
        "A verso do arquivo SETVER no caminho especificado no  compatvel.",
        "No h mais espao para novas entradas na tabela de verso.",
        "Gravando o arquivo SETVER.EXE."
        "Foi especificado um caminho invlido para SETVER.EXE."
};

char *SuccessMsg                = "\r\nA tabela de verso foi atualizada com xito";
char *SuccessMsg2               = "A mudana de verso ter efeito na prxima vez que reiniciar o sistema";
char *szMiniHelp                = "       Se desejar obter ajuda, execute \"SETVER /?\"";
char *szTableEmpty      	= "\r\nNo foram localizadas entradas na tabela de verso";

char *Help[] =
{
        "Define o nmero de verso que o MS-DOS relata a um programa.\r\n",
        "Exibe a tabela de verso atual: SETVER [unidade:caminho]",
        "Adiciona uma entrada:           SETVER [unidade:caminho] arquivo n.nn",
        "Exclui uma entrada:             SETVER [unidade:caminho] arquivo /DELETE [/QUIET]\r\n",
        "  [unidade:caminho] Especifica a localizao do arquivo SETVER.EXE.",
        "  arquivo           Especifica o nome do programa.",
        "  n.nn              Especifica a verso do MS-DOS a ser relatada ao programa.",
        "  /DELETE ou /D     Exclui a entrada da tabela de verso relativa ao programa",
        "                    especificado.",
        "  /QUIET            Oculta a mensagem que normalmente  exibida ao se excluir uma",
        "                    entrada da tabela de verso.",
        NULL

};
char *Warn[] =
{
   "\nAVISO - O aplicativo que est sendo adicionado  tabela de verso do",
   "MS-DOS pode no ter sido verificado pela Microsoft nesta verso do MS-DOS.",
   "Entre em contato com o distribuidor de software para determinar se este",
   "aplicativo ser executado corretamente com esta verso do MS-DOS.",
   "Se este aplicativo for executado especificando um nmero de verso do MS-DOS",
   "diferente, os dados podem ser perdidos, danificados ou poder haver",
   "instabilidades no sistema. Em tais circunstncias, a Microsoft no se",
   "responsabiliza por nenhuma perda ou dano.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
        "",
        "OBSERVAO: O dispositivo SETVER no foi carregado. Para ativ-lo ",
        "            voc deve carregar o dispositivo SETVER.EXE no CONFIG.SYS.",
        NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\chp\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};

#ifdef BILINGUAL
char *ErrorMsg2[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg_2 		= "\r\nVersion table successfully updated";
char *SuccessMsg2_2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp2 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty2	= "\r\nNo entries found in version table";

char *Help2[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn2[] =
{
										/* m100	*/
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg2[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\cht\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};

#ifdef BILINGUAL
char *ErrorMsg2[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg_2 		= "\r\nVersion table successfully updated";
char *SuccessMsg2_2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp2 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty2	= "\r\nNo entries found in version table";

char *Help2[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn2[] =
{
										/* m100	*/
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg2[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\chs\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};

#ifdef BILINGUAL
char *ErrorMsg2[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg_2 		= "\r\nVersion table successfully updated";
char *SuccessMsg2_2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp2 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty2	= "\r\nNo entries found in version table";

char *Help2[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn2[] =
{
										/* m100	*/
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg2[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\el\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\n: ",
	"뤘 槫  夘 ⚡.",
	" 椦  妬  夘 ⚡.",
	" ᨮ  㣞.",
	"  ⡛  夘 ⚡, ⧜  ⮜  2.11 - 9.99.",
	" ⤞ 騞  ⟞  夘 橜.",
	" 㫘      SETVER.EXE.",
	" 樠  ᛘ 婡  夘 ⚡.",
	"   ⮜   ⫨.",
	" ᣜ 姜.",
	"夜 ᚤਫ਼  妬 SETVER.EXE.",
	" 夘 橜 夘 ⤦.",
	"  SETVER  ⤞   夘   ⡛.",
	" ᨮ 騦  夘 橜  ✪ 㩜.",
	"夜    SETVER.EXE."
	"   柞    SETVER.EXE  夘 ⚡."
};

char *SuccessMsg                = "\r\n 夘 橜 韞  ";
char *SuccessMsg2               = "  ⡛    棜    㩜  穫 ";
char *szMiniHelp                = "        㩫 \"SETVER /?\"  㟜";
char *szTableEmpty      = "\r\n ⟞ 㩜  夘 橜";

char *Help[] =
{
	"   ⡛  ⨜  MS-DOS  ⤘ 暨.\r\n",
	"ᤠ  ⮦ 夘 橜:  SETVER [婡:]",
	"㡞 騞:      SETVER [婡:]  n.nn",
	" 騞:      SETVER [婡:]  /DELETE [/QUIET]\r\n",
	"  [婡:]    ⩞  妬 SETVER.EXE.",
	"                 妬  ᣣ.",
	"  n.nn                ⡛ MS-DOS   ⨜  暨.",
	"  /DELETE  /D          夘 橜  騞",
	"                       ⤦ 暨.",
	"  /QUIET             桨  磘  坜   ",
	"                       騞  夘 橜.",
	NULL

};
char *Warn[] =
{
   "\n -    ⫝̸  夘 橜  MS-DOS   ",
   " ⮜    Microsoft    ⡛  MS-DOS.  ",
   "㩫           㩜 ",
   "    ⡛  MS-DOS.  ",
   " ⩜    夦   MS-DOS  ⨜ ",
   " ⡛  MS-DOS,   ᩜ   ⯜ ⤘  ",
   " ⩜ ៜ  穫.     姫ਫ਼,  Microsoft ",
   " 礜   颜  圪.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	":   SETVER  ⮜ .   㩜  ",
    "          橜   SETVER ⧜  驜   SETVER.EXE.",
    "           CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\cs\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
        "\r\nCHYBA: ",
        "Neplatn pepna.",
        "Neplatn nzev souboru.",
        "Nedostatek pamti.",
        "Neplatn slo verze, formt mus bt: 2.11 - 9.99.",
        "Zadan poloka nebyla nalezena v tabulce verz.",
        "Nelze nalzt soubor SETVER.EXE.",
        "Neplatn specifiktor jednotky.",
        "Pli mnoho parametr pkazov dky.",
        "Schz parametr.",
        "Nat se soubor SETVER.EXE.",
        "Tabulka verz je pokozena.",
        "Soubor SETVER na zadan cest nen kompatibiln s danou verz.",
        "V tabulce verz ji nen prostor pro dal poloky.",
        "Zapisuje se soubor SETVER.EXE."
        "Byla zadna neplatn cesta k souboru SETVER.EXE."
};

char *SuccessMsg                = "\r\nTabulka verz spn aktualizovna";
char *SuccessMsg2               = "Zmna verze nabude platnosti po ptm sputn tohoto systmu";
char *szMiniHelp                = "       Pkaz \"SETVER /?\" zobraz npovdu";
char *szTableEmpty      = "\r\nV tabulce verz nejsou dn poloky";

char *Help[] =
{
        "Nastavit slo verze systmu, kter systm MS-DOS hls programu.\r\n",
        "Zobrazit aktuln tabulku verz: SETVER [jednotka:cesta]",
        "Pidat poloky:                  SETVER [jednotka:cesta] soubor n.nn",
        "Odstranit poloku:               SETVER [jednotka:cesta] soubor /DELETE [/QUIET]\r\n",
        "  [jednotka:cesta]   Uruje umstn souboru SETVER.EXE.",
        "  soubor             Uruje nzev souboru danho programu.",
        "  n.nn               Uruje verzi MS-DOS, kter se m programu nahlsit.",
        "  /DELETE i /D      Odstran poloku z tabulky verz pro dan program.",
        "  /QUIET             Potla zprvu, kter se jinak zobraz pi odstrann",
        "                     poloky z tabulky verz.",
        NULL

};
char *Warn[] =
{
   "\nUPOZORNN - Aplikace, kterou pidvte do tabulky verz MS-DOS, ",
   "zejm nebyla verifikovna firmou Microsoft pro tuto verzi systmu.  ",
   "MS-DOS. Obrate se na dodavatele softwaru a zjistte, zda dan ",
   "aplikace bude sprvn fungovat s touto verz systmu MS-DOS.  ",
   "Pokud tuto aplikaci spustte tak, e nastavte sstm MS-DOS na ",
   "hlen jin verze systmu, pak mete ztratit i pokodit data, nebo ",
   "zpsobit nestabilitu systmu.  V takovm ppad nen spolenost ",
   "Microsoft odpovdn za jakoukoliv ztrtu i kodu.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
        "",
        "POZNMKA: Zazen SETVER nenateno. Hlen verz SETVER se aktivuje",
        "          natenm zazen SETVER.EXE pomoc souboru CONFIG.SYS.",
        NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\da\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nFEJL: ",
	"Ugyldig parameter.",
	"Ugyldigt filnavn.",
	"Der er ikke hukommelse nok.",
	"Ugyldigt versionsnummer. Formatet skal vre 2.11 - 9.99.",
	"Det angivne element kunne ikke findes i versionstabellen.",
	"Filen Setver.exe kunne ikke findes.",
	"Ugyldig drevangivelse.",
	"Der er for mange kommandolinjeparametre.",
	"Der mangler en parameter.",
	"Lser filen Setver.exe.",
	"Versionstabellen er beskadiget.",
	"Filen Setver.exe i den angivne sti er ikke en kompatibel version.",
	"Der er ikke plads til flere elementer i versionstabellen.",
	"Skriver filen Setver.exe."
	"Der blev angivet en ugyldig sti til filen Setver.exe."
};

char *SuccessMsg 		= "\r\nVersionstabellen blev opdateret";
char *SuccessMsg2		= "Versionsndringen vil trde i kraft, nste gang systemet startes";
char *szMiniHelp 		= "       Brug \"SETVER /?\" for at f hjlp";
char *szTableEmpty	= "\r\nDer er ingen elementer i versionstabellen";

char *Help[] =
{
        "Stter det versionsnummer, som MS-DOS rapporterer til et program.\r\n",
        "Viser den aktuelle versionstabel:  SETVER [drev:sti]",
        "Tilfjer element:                  SETVER [drev:sti] filnavn n.nn",
        "Sletter element:                   SETVER [drev:sti] filnavn /DELETE [/QUIET]\r\n",
        "  [drev:sti]         Angiver placeringen af filen Setver.exe.",
        "  filnavn            Angiver programmets filnavn.",
        "  n.nn               Angiver den MS-DOS-version, der skal rapporteres til",
        "                     programmet.",
        "  /DELETE eller /D   Sletter versionstabelelementet for det angivne program.",
        "  /QUIET             Skjuler de meddelelser, som normalt vises under sletning",
        "                     af versionstabelelementer.",
	NULL

};
char *Warn[] =
{
   "\nADVARSEL - Det program, som du fjer til MS-DOS-versionstabellen, er",
   "muligvis ikke blevet verificeret af Microsoft p denne version af MS-DOS.",
   "Kontakt din forhandler for yderligere oplysninger om, hvorvidt dette",
   "program kan kre korrekt under denne version af MS-DOS. Krer du",
   "dette program ved at indstille MS-DOS til at rapportere et andet",
   "MS-DOS-versionsnummer, kan du tabe eller beskadige data. Skulle",
   "dette ske, er Microsoft ikke ansvarlig for eventuelle tab eller skader.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"BEMRK: Enheden SETVER er ikke indlst. Du skal indlse Setver.exe i",
   "        din Config.sys for at aktivere SETVER's versionsrapportering.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\es\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Modificador no vlido.",
	"Nombre de archivo no vlido.",
	"Memoria insuficiente.",
	"Versin no vlida. El formato debe ser 2.11 - 9.99.",
	"No se ha encontrado la entrada especificada en la tabla de versin.",
	"No se ha encontrado el archivo SETVER.EXE.",
	"La unidad especificada no es vlida.",
	"Hay demasiados parmetros de lnea de comandos.",
	"Falta un parmetro.",
	"Leyendo el archivo SETVER.EXE.",
	"La tabla de versin est daada.",
	"La versin del archivo SETVER de la ruta especificada no es compatible.",
	"No queda espacio para ms entradas en la tabla de versin.",
	"Escribiendo el archivo SETVER.EXE."
	"Se ha especificado una ruta para SETVER.EXE no vlida."
};

char *SuccessMsg                = "\r\nSe ha actualizado la tabla de versin";
char *SuccessMsg2               = "El cambio de versin harefecto la prxima vez que reinicie su sistema";
char *szMiniHelp                = "       Si desea obtener ayuda utilice \"SETVER /?\"";
char *szTableEmpty      = "\r\nNo se han encontrado entradas en la tabla de versin";

char *Help[] =
{
	"Establece el nmero de versin que MS-DOS indica a los programas.\r\n",
	"Muestra tabla de vers. act.:  SETVER [unidad:ruta]",
	"Agregar entrada:              SETVER [unidad:ruta] archivo n.nn",
	"Eliminar entrada:             SETVER [unidad:ruta] archivo /DELETE [/QUIET]\r\n",
	"  [unidad:ruta]   Especifica la ubicacin del archivo SETVER.EXE.",
	"  archivo         Especifica el nombre de archivo del programa.",
	"  n.nn            Especifica la versin de MS-DOS a usar con el programa.",
	"  /DELETE o /D    Elimina el programa especificado de la tabla de versin.",
	"  /QUIET          Oculta el mensaje que normalmente se muestra al eliminar una",
	"                  entrada de la tabla de versin.",
	NULL

};
char *Warn[] =
{
   "\nADVERTENCIA - La aplicacin que est agregando a la tabla de versin de MS-DOS ",
   "puede no haber sido comprobada por Microsoft en esta versin de MS-DOS.  ",
   "Pongase en contacto con su distribuidor de software para determinar si esta ",
   "aplicacin se ejecutar correctamente con esta versin de MS-DOS.  ",
   "Si ejecuta esta aplicacin especificando que MS-DOS indique un nmero de versin ",
   "de MS-DOS diferente, se puede producir prdida de datos, estos pueden ser daados ",
   "o se puede causar inestabilidad en el sistema. En tales circunstancias, Microsoft ",
   "no es reponsable de ninguna prdida o dao.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	"NOTA: no se ha cargado el dispositivo SETVER. Para activar SETVER",
   "      debe cargar el dispositivo SETVER.EXE en su CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\fr\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERREUR: ",
	"Commutateur non valide.",
	"Nom de fichier non valide.",
	"Mmoire insuffisante.",
	"Numro de version non valide, le format doit tre 2.11 - 9.99.",
	"L'entre spcifie n'a pas t trouve dans la table de version.",
	"Impossible de trouver le fichier SETVER.EXE.",
	"Spcification de lecteur non valide.",
	"Trop de paramtres sur la ligne de commande.",
	"Paramtre manquant.",
	"Lecture du fichier SETVER.EXE.",
	"La table de version est endommage.",
	"Le fichier SETVER dans le chemin spcifi n'est pas une version compatible.",
	"Il y a plus d'espace dans les nouvelles entres de la table de version.",
	"Ecriture du fichier SETVER.EXE."
	"Un chemin non valide a t spcifi pour SETVER.EXE."
};

char *SuccessMsg 		= "\r\nMise  jour russie pour la table de version";
char *SuccessMsg2		= "La modification de version prendra effet la prochaine fois que vous redmarrez";
char *szMiniHelp 		= "       Utilisez \"SETVER /?\" pour avoir de l'aide";
char *szTableEmpty	= "\r\nAucune entre trouve dans la table de version";

char *Help[] =
{
        "Dfinit le numro de version que MS-DOS fournit  un programme.\r\n",
        "Affiche la table de version courante :  SETVER [lecteur:chemin]",
        "Ajoute une entre :   SETVER [lecteur:chemin] nom_de_fichier n.nn",
        "Supprime une entre : SETVER [lecteur:chemin] nom_de_fichier /DELETE [/QUIET]\r\n",
        "  [lecteur:chemin] Spcifie l'emplacement du fichier SETVER.EXE.",
        "  nom_de_fichier   Spcifie le nom de fichier du programme.",
        "  n.nn             Spcifie la version MS-DOS  fournir au programme.",
        "  /DELETE ou /D    Supprime l'entre de table de version pour le prog. spcifi.",
        "  /QUIET           Cache le message habituellement affich pendant la",
        "                   suppression d'entres de table de version.",
	NULL

};
char *Warn[] =
{
   "\nAVERTISSEMENT - L'application que vous ajoutez  la table de version MS-DOS",
   "peut ne pas avoir t vrifie par Microsoft pour cette version de MS-DOS.  ",
   "Veuillez contacter votre revendeur de logiciel pour savoir si cette ",
   "application fonctionnera correctement avec cette version de MS-DOS.  ",
   "Si vous excutez cette application en instruisant MS-DOS de fournir un ",
   "numro de version MS-DOS diffrent, vous pouvez perdre ou endommager ",
   "des donnes, ou causer une dstabilisation du systme.  Dans ces ",
   "circonstances, Microsoft n'est pas responsable pour toute perte ou dgt.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"REMARQUE : priphrique SETVER non charg. Pour activer le service de version",
   "      SETVER vous devez charger le priphrique SETVER.EXE dans votre CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\fi\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nVIRHE: ",
	"Valitsin ei kelpaa.",
	"Tiedostonimi ei kelpaa.",
	"Liian vhn muistia.",
	"Versionumero ei kelpaa. Numeron on oltava 2.11 - 9.99.",
	"Mritetty vienti ei lydy versiotaulukosta.",
	"Tiedostoa SETVER.EXE ei lydy.",
	"Asemamritys ei kelpaa.",
	"Liian monta komentoriviparametria.",
	"Puuttuva parametri.",
	"Luetaan SETVER.EXE-tiedostoa.",
	"Versiotaulukko on vahingoittunut.",
	"Mritetyss polussa oleva SETVER-tiedoston versio ei ole yhteensopiva.",
	"Versiotaulukossa ei ole tilaa uusille vienneille.",
	"Kirjoitetaan SETVER.EXE-tiedostoon."
	"Mritetty SETVER.EXE-tiedoston polku ei kelpaa."
};

char *SuccessMsg                = "\r\nVersiotaulukko on pivitetty";
char *SuccessMsg2               = "Versiomuutos tulee voimaan uudelleenkynnistyksen jlkeen";
char *szMiniHelp                = "       Saat listietoja kirjoittamalla \"SETVER /?\" ";
char *szTableEmpty      = "\r\nVersiotaulukossa ei ole vientej";

char *Help[] =
{
	"Asettaa versionumeron, jonka MS-DOS ilmoittaa ohjelmalle.\r\n",
	"Nyt nyk. versiotaulukko: SETVER [asema:polku]",
	"Lis vienti:              SETVER [asema:polku] tiedostonimi n.nn",
	"Poista vienti:             SETVER [asema:polku] tiedostonimi /DELETE [/QUIET]\r\n",
	"  [asema:polku]   Mritt SETVER.EXE-tiedoston sijainnin.",
	"  tiedostonimi    Mritt ohjelman tiedostonimen.",
	"  n.nn            Mritt ohjelmalle ilmoitettavan MS-DOS-version.",
	"  /DELETE tai /D  Poistaa mritetyn ohjelman versiotaulukkoviennin.",
	"  /QUIET          Piilottaa viestin, joka yleens esitetn poistettaessa",
	"                  versiotaulukkovienti.",
	NULL

};
char *Warn[] =
{
   "\nVAROITUS - Microsoft ei ehk ole vahvistanut tmn",
   "MS-DOS-versiotaulukkoon listtvn ohjelman toimimista tll",
   "MS-DOSin versiolla. Varmista ohjelmiston myyjlt, toimiiko",
   "sovellus virheettmsti tmn MS-DOSin version kanssa. Jos",
   "kytt ohjelmaa ohjaten MS-DOSin ilmoittamaan toisen MS-DOSin",
   "versionumeron, tm voi aiheuttaa tietojen katoamista,",
   "vahingoittumista tai jrjestelmn epvakautta. Tss tapauksessa",
   "Microsoft ei ole vastuussa aiheutuneista vahingoista.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	"HUOMAUTUS: SETVER ei ole ladattuna. Aktivoi SETVER-version ilmoitus",
   "           lataamalla ohjelma SETVER.EXE CONFIG.SYS-tiedostossa.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\ger\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                        */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nFEHLER: ",
	"Unzulssige Option.",
	"Ungltiger Dateiname.",
	"Zuwenig Arbeitsspeicher.",
	"Unzulssige Versionsnummer, muss zwischen 2.11 und 9.99 liegen.",
	"Angegebener Eintrag in der Versionstabelle nicht gefunden.",
	"Datei SETVER.EXE nicht gefunden.",
	"Ungltige Laufwerksangabe.",
	"Zu viele Parameter in der Befehlszeile.",
	"Fehlender Parameter.",
	"Datei SETVER.EXE wird gelesen.",
	"Versionstabelle ist fehlerhaft.",
	"Datei SETVER im angegebenen Pfad ist eine nicht-kompatible Version.",
	"Kein Speicherplatz mehr in der Versionstabelle fr neue Eintrge.",
	"Datei SETVER.EXE wird geschrieben."
	"Der angegebene Pfad zu SETVER.EXE ist ungltig."
};

char *SuccessMsg                = "\r\nVersionstabelle erfolgreich aktualisiert";
char *SuccessMsg2               = "Der Versionswechsel wird beim nchsten Neustart des Systems wirksam";
char *szMiniHelp                = "        Geben Sie \"SETVER /?\" fr die Anzeige von Hilfe ein.";
char *szTableEmpty      = "\r\nKeine Eintrge in der Versionstabelle gefunden";
char *Help[] =
{
	"Setzt die Versionsnummer, die MS-DOS an ein Programm meldet.\r\n",
	"Versionstabelle anzeigen:  SETVER [Laufwerk:Pfad]",
	"Eintrag hinzufgen:        SETVER [Laufwerk:Pfad] Dateiname n.nn",
	"Eintrag lschen:           SETVER [Laufwerk:Pfad] Dateiname /DELETE [/QUIET]\r\n",
	" [Laufwerk:Pfad]   Position der Datei SETVER.EXE.",
	" Dateiname         Dateiname des Programms.",
	" n.nn              An das Programm zu meldende MS-DOS-Version.",
	" /D(ELETE)    Lscht den Versionstabelleneintrag fr das angegebene Programm.",
	" /QUIET       Zeigt beim Lschen eines Eintrags aus der Versionstabelle keine",
	"              Meldung an.",
	NULL

};
char *Warn[] =
{
	"\nVORSICHT - Die Anwendung, die Sie zur MS-DOS-Versionstabelle hinzufgen,",
	"ist mglicherweise nicht von Microsoft fr diese MS-DOS-Version berprft",
	"worden. Fragen Sie Ihren Software-Hndler, ob dieses Programm mit dieser",
	"Version von MS-DOS korrekt ausgefhrt wird. Wenn Sie MS-DOS anweisen, bei",
	"der Ausfhrung dieser Anwendung eine andere MS-DOS-Versionsnummer zu melden,",
	"knnen Sie Daten verlieren oder beschdigen oder Systeminstabilitten verur-",
	"sachen. Microsoft ist in diesem Fall nicht fr Datenverluste oder -beschdi-",
	"gungen verantwortlich.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	"HINWEIS: SETVER-Treiber nicht geladen. Um die SETVER-Versionsmeldung",
     "         zu aktivieren, mssen Sie den SETVER.EXE-Treiber in der ",
     "         Datei CONFIG.SYS laden.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\kor\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\n: ",
	"ġ Ʋϴ.",
	" ̸ Ʋϴ.",
	"޸𸮰 մϴ.",
	" ȣ Ʋϴ. 2.11 9.99  ̾ մϴ.",
	" ׸  ̺ ϴ.",
	"SETVER.EXE  ã  ϴ.",
	"̺ ڰ Ʋϴ.",
	"ٿ Ű  ʹ ϴ.",
	"Ű  ϴ.",
	"SETVER.EXE  д ",
	" ̺ ջǾϴ.",
	" ο ִ SETVER  ȣȯǴ  ƴմϴ.",
	" ̺  ׸ ߰  ϴ.",
	"SETVER.EXE   "
	"SETVER.EXE  ΰ Ʋϴ."
};

char *SuccessMsg 		= "\r\n ̺   ƽϴ.";
char *SuccessMsg2		= "   ý ٽ  Ŀ ˴ϴ.";
char *szMiniHelp 		= "        ʿϸ \"SETVER /?\" Ͻʽÿ.";
char *szTableEmpty	= "\r\n ̺ ƹ ׸ ϴ.";

char *Help[] =
{
        "MS-DOS α׷ ϴ  ȣ մϴ.\r\n",
        "  ̺ ǥ:        SETVER [̺:]",
        "׸ ߰:                    SETVER [̺:]  ̸ n.nn",
        "׸ :                    SETVER [̺:]  ̸ /DELETE [/QUIET]\r\n",
        "  [̺:]     SETVER.EXE  ġ մϴ.",
        "   ̸           α׷  ̸ մϴ.",
        "  n.nn                α׷  MS-DOS  մϴ.",
        "  /DELETE Ǵ /D      α׷  ̺ ׸ մϴ.",
        "  /QUIET               ̺ ׸   ǥõǴ ޽",
        "                    ϴ.",
	NULL

};
char *Warn[] =
{
   "\n - ڰ MS-DOS  ̺ ߰Ϸ  α׷, ",
   "Microsoft   MS-DOS Ȯ    ֽϴ.  ",
   " α׷   MS-DOS ùٷ ۵  ",
   " Ʈ Ǹ ü Ͻʽÿ. ",
   "MS-DOS Ͽ ٸ MS-DOS  ȣ ϵ Ͽ ",
   "  α׷ ϸ, ͸ Ұų ջų  ְ ",
   "ý Ҿϰ   ֽϴ. ׷ Ȳ, ",
   " ؿ ؼ Microsoft å ʽϴ.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	": SETVER ̽ о鿩 ʾҽϴ. SETVER   ",
   "      Ϸ CONFIG.SYS SETVER.EXE ̽ о鿩 մϴ.",
	NULL
};

#ifdef BILINGUAL
char *ErrorMsg2[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg_2 		= "\r\nVersion table successfully updated";
char *SuccessMsg2_2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp2 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty2	= "\r\nNo entries found in version table";

char *Help2[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn2[] =
{
										/* m100	*/
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg2[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\hu\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
        "\r\nHIBA: ",
        "rvnytelen kapcsol.",
        "Hibs fjlnv.",
        "Nincs elg memria.",
        "rvnytelen verziszm. A verzinak  2.11 - 9.99 kz kell esnie.",
        "A megadott bejegyzs nem tallhat a verziszm-tblzatban.",
        "A SETVER.EXE fjl nem tallhat.",
        "rvnytelen meghajt.",
        "Tl sok parancssori kapcsol.",
        "Hinyz paramter.",
        "SETVER.EXE fjl olvassa.",
        "A verziszm-tblzat srlt.",
        "A megadott elrsi ton tallt SETVER fjl nem kompatbilis ezzel a programmal.",
        "Nincs tbb hely a verziszm-tblzatban.",
        "SETVER.EXE fjl rsa."
        "A SETVER.EXE programra mutat elrsi t rvnytelen."
};

char *SuccessMsg                = "\r\nA verziszm-tblzat frisstse megtrtnt.";
char *SuccessMsg2               = "A verziszm vltozs a szmtgp jraindtsa utn jut rvnyre.";
char *szMiniHelp                = "       A \"SETVER /?\" parancs megjelenti a program sgjt.";
char *szTableEmpty      = "\r\nA verziszm-tblzat res.";

char *Help[] =
{
        "Belltja, hogy az MS-DOS milyen verziszmot jelezzen a programoknak.\r\n",
        "A jelenlegi verziszm-tblzat listzsa:  SETVER [meghajt:elrsi t]",
        "j bejegyzs:              SETVER [meghajt:elrsi t] fjlnv n.nn",
        "Bejegyzs trlse:         SETVER [meghajt:elrsi t] fjlnv /DELETE [/QUIET]\r\n",
        "  [meghajt:elrsi t] A SETVER.EXE fjl elrsi tja.",
        "  fjlnv               A tblzatba felvenni kvnt program neve.",
        "  n.nn                  A programnak jelzend MS-DOS verziszm.",
        "  /DELETE vagy /D       Trli a megadott program bejegyzst a tblzatbl.",
        "  /QUIET                Nem jelenti meg a bejegyzs trlsekor egybknt ",
        "                        megjelen zenetet.",
        NULL

};
char *Warn[] =
{
   "\nFIGYELMEZTETS - A programot, amelyhez bejegyzst kvn kszteni, a ",
   "Microsoft nem tesztelte az MS-DOS ezen verzijval. Vegye fel a kapcsolatot ",
   "a szoftver ksztjvel s krdezze meg, hogy a program helyesen ",
   "mkdik-e ezzel az MS-DOS verzival. Ha gy hasznlja az alkalmazst, ",
   "hogy nem a valdi MS-DOS verziszmot jelzi neki, akkor ez adatvesztst ",
   "okozhat, illetve a rendszer instabilitshoz vezethet. Ebben az esetben ",
   "a Microsoft nem vllal felelssget a keletkezett krrt.",
   "  ",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
        "",
        "MEGJEGYZS: a SETVER illesztprogram nincs betltve. A verziszm-jelent ",
        "            mkdtetshez a CONFIG.SYS segtsgvel be kell tltenie a",
        "            SETVER.EXE programot.",
        NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\it\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERRORE: ",
	"Opzione non valida.",
	"Nome file non valido.",
	"Memoria insufficiente.",
	"Numero di versione non valido. Il formato deve essere 2.11 - 9.99.",
	"Voce specificata non trovata nella tabella delle versioni.",
	"Impossibile trovare il file SETVER.EXE.",
	"Specificatore di unit non valido.",
	"Troppi parametri nella riga di comando.",
	"Parametro mancante.",
	"Lettura del file SETVER.EXE.",
	"La tabella delle versioni  danneggiata.",
	"Il file SETVER nel percorso specificato non  una versione compatibile.",
	"Spazio per le nuove voci esaurito nella tabella delle versioni.",
	"Scrittura del file SETVER.EXE."
	"Percorso specificato per SETVER.EXE non valido."
};

char *SuccessMsg                = "\r\nTabella delle versioni aggiornata correttamente";
char *SuccessMsg2               = "La modifica delle versioni sar effettiva al riavvio del sistema";
char *szMiniHelp                = "     Usare \"SETVER /?\" per la Guida";
char *szTableEmpty      = "\r\nNessuna voce trovata nella tabella delle versioni";

char *Help[] =
{
	"Imposta la versione che MS-DOS riporta ad un programma.\r\n",
	"Visualizza la tabella corrente: SETVER [unit:perc]",
	"Aggiunge voce:                  SETVER [unit:perc] nomefile n.nn",
	"Elimina voce:                   SETVER [unit:perc] nomefile /DELETE [/QUIET]\r\n",
	"  [unit:perc]    Indica la posizione del file SETVER.EXE.",
	"  nomefile        Indica il nome file del programma.",
	"  n.nn            Indica la versione di MS-DOS da riportare al programma.",
	"  /DELETE or /D   Elimina la voce dalla tabella per il programma specificato.",
	"  /QUIET          Nasconde il messaggio normalmente visualizzato durante",
	"                  l'eliminazione della voce dalla tabella delle versioni.",
	NULL

};
char *Warn[] =
{
   "\nAVVISO - L'applicazione aggiunta alla tabella delle versioni di MS-DOS ",
   "potrebbe non essere verificata da Microsoft con questa versione di MS-DOS. ",
   "Rivolgersi al fornitore del software per assicurarsi che questa applicazione ",
   "funzioni correttamente con questa versione di MS-DOS. Se l'applicazione ",
   "viene eseguita richiedendo a MS-DOS di riportare un numero di versione di ",
   "MS-DOS differente,  possibile perdere o danneggiare dati o causare l' ",
   "instabilit del sistema. In questa circostanza, Microsoft non  responsabile ",
   "per alcun danno o perdita di dati.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	"NOTA: periferica SETVER non caricata. Per attivare la modifica delle versioni",
   "      riportate, includere l'istruzione device=SETVER.EXE nel file CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\jpn\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nG[: ",
	"XCb`Ⴂ܂.",
	"t@CႢ܂.",
	"܂.",
	"o[WԍႢ܂.  2.11 - 9.99 łȂ΂Ȃ܂.",
	"o[We[uɂ͎w肳ꂽGg܂.",
        "SETVER.EXEt@C܂.",
	"hCuw肪Ⴂ܂.",
	"R}hC̃p[^܂.",
	"p[^sł.",
	"SETVER.EXEt@Cǂݍł܂.",
	"o[We[uԈĂ܂.",
	"w肳ꂽpX SETVER t@C, ݊̂Ȃo[Wł.",
	"o[We[u̐VK̃Gĝ߂̋Ԃ͂ςł.",
#ifdef JAPAN
	"SETVER.EXEt@Cł܂.",
#else
	"SETVER.EXEt@Cł܂."
#endif
	"SETVER.EXE ɑ΂ĊԈpXw肳܂."
};

char *SuccessMsg 		= "\r\no[We[uXV܂.";
char *SuccessMsg2		= "o[W̕ύX, VXeNĂLɂȂ܂.";
char *szMiniHelp 		= "       wv\\ɂ, \"SETVER /?\" ƂĂ.";
char *szTableEmpty	= "\r\no[We[uɂ, Gg܂.";

char *Help[] =
{
        "MS-DOS vO֕Ԃo[Wԍݒ肵܂.\r\n",
        "o[We[u\\:   SETVER [ײ:߽]",
        "Ggǉ:               SETVER [ײ:߽] ̧ٖ n.nn",
        "Gg폜:               SETVER [ײ:߽] ̧ٖ /DELETE [/QUIET]\r\n",
        "  [ײ:߽]   SETVER.EXE t@C̈ʒuw肵܂.",
        "  ̧ٖ         vÕt@Cw肵܂.",
        "  n.nn           vOɕԂ MS-DOS o[Ww肵܂.",
        "  /DELETE (/D)   wvÕo[We[uGg폜܂.",
        "  /QUIET         o[We[uGg폜Ă, ʏ\\",
        "                 bZ[W\\܂.",
	NULL
};
char *Warn[] =
{
										/* m100	*/
   " - MS-DOS ̃o[We[uɃvOǉƂɂ̃vO",
   "Ɏs邩ǂ, Microsoft ł͊mFĂȂƂ܂.",
   "w肵vO ̃o[W MS-DOS ŐɎsł邩ǂ, ",
   "\\tgEFÃ[J[ɖ₢킹Ă.",
   "̃o[W MS-DOS Ńo[We[uύXẴvOs",
   ", f[^ꂽ, ȂȂ, sɂȂ錴ɂȂ邱Ƃ܂.",
   "̍ۂ̐ӔC, Microsoft ł͕˂܂̂ł.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
        "",
        ": SETVERfoCX͑gݍ܂Ă܂. SETVER ̃o[W񍐂Lɂ",
   "      ߂ɂ CONFIG.SYS SETVER.EXEfoCXǂݍޕKv܂.",
        NULL
};

#ifdef BILINGUAL
char *ErrorMsg2[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg_2 		= "\r\nVersion table successfully updated";
char *SuccessMsg2_2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp2 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty2	= "\r\nNo entries found in version table";

char *Help2[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn2[] =
{
										/* m100	*/
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg2[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\nl\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nFOUT: ",
	"Ongeldige schakeloptie.",
	"Ongeldige bestandsnaam.",
	"Onvoldoende geheugen.",
	"Ongeldig versienummer, opmaak moet 2.11 - 9.99 zijn.",
	"Opgegeven ingang niet gevonden in de versietabel.",
	"Kan het bestand SETVER.EXE niet vinden.",
	"Ongeldige stationsaanduiding.",
	"Teveel opdrachtparameters.",
	"Parameter ontbreekt.",
	"Bezig met het lezen van bestand SETVER.EXE.",
	"Versietabel is beschadigd.",
	"Het bestand SETVER in het opgegeven pad is geen compatibele versie.",
	"Er is geen ruimte in de versietabel voor nieuwe ingangen.",
	"Bezig met het schrijven van bestand SETVER.EXE."
	"Er is een ongeldig pad voor SETVER.EXE opgegeven."
};

char *SuccessMsg                = "\r\nVersietabel met succes bijgewerkt";
char *SuccessMsg2               = "De versiewijziging treedt in werking als de computer opnieuw wordt gestart.";
char *szMiniHelp                = "       Gebruik \"SETVER /?\" voor help";
char *szTableEmpty      = "\r\nGeen ingangen gevonden in de versietabel";

char *Help[] =
{
	"Stelt het versienummmer in dat MS-DOS opgeeft aan het programma.\r\n",
	"Weergeven huidige versietabel:  SETVER [station:pad]",                          
	"Toevoegen van ingang:           SETVER [station:pad] bestandsnaam n.nn",
	"Verwijderen van ingang:         SETVER [station:pad] bestandsnaam", 
	"                                /DELETE [/QUIET]\r\n",
	"  [station:pad]   De locatie van het bestand SETVER.EXE.",
	"  bestandsnaam    De bestandsnaam van het programma.",
	"  n.nn            De MS-DOS-versie die wordt opgegeven aan het programma.",
	"  /DELETE of /D   De versietabelingang voor het opgegeven", 
	"                  programma wordt verwijderd.",
	"  /QUIET          Het bericht dat verschijnt als een versietabel wordt",
	"                  verwijderd, wordt niet weergegeven.",
	NULL

};
char *Warn[] =
{
   "\nWAARSCHUWING - De toepassing die u toevoegt aan de versietabel van",
   "MS-DOS is misschien niet door Microsoft gecontroleerd voor deze versie",
   "van MS-DOS. Neem contact op met uw leverancier voor informatie over",
   "de mogelijkheid deze toepassing op de juiste wijze uit te voeren onder",
   "deze versie van MS-DOS. Als u deze toepassing uitvoert door MS-DOS",
   "opdracht te geven een ander MS-DOS-versienummer op te geven, kunt u",
   "gegevens verliezen of beschadigen, of het systeem kan instabiel wor-",
   "den. In dat geval is Microsoft niet verantwoordelijk voor eventueel",
   "gegevensverlies.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	"NB: SETVER is niet geladen. Om het weergeven van de versie door",
	"    SETVER te activeren, dient u SETVER.EXE op te nemen in CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\no\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nFEIL: ",
	"Ugyldig bryter.",
	"Ugyldig filnavn.",
	"Ikke nok minne.",
	"Ugyldig versjonnummer. Formatet m vre 2.11 - 9.99.",
	"Angitt post ble ikke funnet i versjonstabellen.",
	"Fant ikke filen SETVER.EXE.",
	"Ugyldig stasjonsbokstav.",
	"For mange parametere i kommandolinjen.",
	"Manglende parameter.",
	"Leser filen SETVER.EXE.",
	"Versjonstabellen er skadet.",
	"Filen SETVER i angitt bane er ikke en kompatibel versjon.",
	"Det er ikke mer plass i versjonstabellen.",
	"Skriver filen SETVER.EXE."
	"Angitt bane til SETVER.EXE er ugyldig."
};

char *SuccessMsg                = "\r\nVersjonstabellen ble oppdatert.";
char *SuccessMsg2               = "Versjonsendringen vil tre i kraft neste gang du starter systemet.";
char *szMiniHelp                = "      Bruk \"SETVER /?\" for hjelp";
char *szTableEmpty      = "\r\nVersjonstabellen er tom.";

char *Help[] =
{
	"Setter versjonsnummeret som MS-DOS rapporterer til et program.\r\n",
	"Vis gjeldende versjonstabell:  SETVER [stasjon:bane]",
	"Legg til oppfring:            SETVER [stasjon:bane] filnavn n.nn",
	"Slett oppfring:               SETVER [stasjon:bane] filnavn /DELETE [/QUIET]\r\n",
	"  [stasjon:bane]    Angir hvor filen SETVER.EXE finnes.",
	"  filnavn           Angir filnavnet for programmet.",
	"  n.nn              Angir MS-DOS-versjonen som rapporteres til programmet.",
	"  /DELETE eller /D  Sletter oppfringen for valgt program.",
	"  /QUIET            Viser ikke meldingen som vanligvis vises under sletting av",
	"                    versjonstabelloppfringen.",
	NULL

};
char *Warn[] =
{
   "\nADVARSEL - Programmet du la til versjonstabellen for MS-DOS  ",
   "er kanskje ikke bekreftet av Microsoft for denne versjonen av MS-DOS.  ",
   "Kontakt leverandren for informasjon om dette programmet vil  ",
   "virke under denne versjonen av MS-DOS.  ",
   "Hvis du kjrer dette programmet ved  be MS-DOS rapportere ",
   "et forskjellig versjonsnummer, kan du miste eller delegge data eller ",
   "forrsake et ustabilt system. Microsoft vil i et slikt tilfelle ikke ",
   "vre ansvarlig for tap av data.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	"Obs!  SETVER-enhet er ikke lastet inn. Du m laste Setver.exe i",
   "      Config.sys for  aktivere versjonsrapportering.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\pl\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
        "\r\nBD: ",
        "Nieprawidowy przecznik.",
        "Nieprawidowa nazwa pliku.",
        "Za mao pamici.",
        "Zy numer wersji, prawidowy format to 2.11 - 9.99.",
        "Podanego wpisu nie mona znale w tabeli wersji.",
        "Nie mona znale pliku SETVER.EXE.",
        "Nieprawidowe okrelenie dysku.",
        "Za wiele parametrw wiersza polecenia.",
        "Brak parametru.",
        "Czytanie pliku SETVER.EXE.",
        "Tabela wersji jest uszkodzona.",
        "Plik SETVER w podanej ciece nie jest plikiem zgodnej wersji.",
        "W tabeli wersji nie ma ju miejsca na nowe wpisy.",
        "Zapisywanie pliku SETVER.EXE."
        "Podano nieprawidow ciek do pliku SETVER.EXE."
};

char *SuccessMsg                = "\r\nTabela wersji zostaa pomylnie zaktualizowana";
char *SuccessMsg2               = "Zmiana wersji zacznie obowizywa od nastpnego uruchomienia systemu";
char *szMiniHelp                = "       Uyj polecenia \"SETVER /?\", aby uzyska pomoc";
char *szTableEmpty      = "\r\nBrak wpisw w tabeli wersji";

char *Help[] =
{
        "Ustawia wersj MS-DOS raportowan przez system.\r\n",
        "Wywietla biec tabel wersji: SETVER [dysk:cieka]",
        "Dodaje wpis:                     SETVER [dysk:cieka] plik n.nn",
        "Usuwa wpis:                      SETVER [dysk:scieka] plik /DELETE [/QUIET]\r\n",
        "  [dysk:cieka]    Okrela lokalizacj pliku SETVER.EXE.",
        "  nazwapliku        Okrela nazw pliku programu.",
        "  n.nn              Okrela wersj MS-DOS, ktra bdzie podawana programowi.",
        "  /DELETE lub /D    Usuwa wpis tabeli wersji dla okrelonego programu.",
        "  /QUIET            Ukrywa komunikat wywietlany zwykle podczas usuwania",
        "                    wpisu tabeli wersji.",
	NULL

};
char *Warn[] =
{
   "\nOSTRZEENIE - Aplikacja dodawana do tabeli wersji systemu Windows moga ",
   "nie zosta sprawdzona przez Microsoft dla tej wersji systemu Windows.  ",
   "Skontaktuj si z producentem w celu uzyskania informacji, czy aplikacja ",
   "bdzie dziaaa poprawnie w tej wersji systemu Windows. Jeli ",
   "uruchomisz t aplikacj, wydajc dla systemu Windows polecenie zgaszania ",
   "innego numeru wersji systemu MS-DOS, moe nastpi utrata lub uszkodzenie ",
   "danych lub wystpi niestabilno systemu. W takich okolicznociach firma",
   "Microsoft nie jest odpowiedzialna za adne straty lub zniszczenia.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
        "UWAGA: Urzdzenie SETVER nie jest zaadowane. Aby uaktywni podawanie wersji",
   "      przez SETVER, naley zaadowa SETVER.EXE w pliku CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\psu\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\usa\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\share\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\share\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\ru\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\n: ",
	"ࠢ ࠬ.",
	"ࠢ쭮  䠩.",
	"筮 .",
	"ࠢ  ᨨ. ࠢ ଠ: 2.11 - 9.99.",
	"     ⠡ ᨩ.",
	" 㤠  䠩 SETVER.EXE.",
	"ࠢ쭮  .",
	"誮  ࠬ஢  ப.",
	"ய饭 ࠬ.",
	"⥭ 䠩 SETVER.EXE.",
	" ᨩ ०.",
	" 㪠뢠  䠩 SETVER, 騩 ᮢ⨬ .",
	" ⠡ ᨩ     ⮢.",
	" 䠩 SETVER.EXE."
	"  䠩 SETVER.EXE  ࠢ쭮."
};

char *SuccessMsg                = "\r\n ᨩ ᯥ譮 ";
char *SuccessMsg2               = " ᨨ 㯨  ᨫ ᫥ १㧪 ⥬.";
char *szMiniHelp                = "       ᯮ   \"SETVER /?\"  祭 ࠢ";
char *szTableEmpty      = "\r\n ᨩ ";

char *Help[] =
{
	"  ᨨ,  MS-DOS ᮮ頥 ணࠬ.\r\n",
	"뢥 ⥪ ⠡ ᨩ: SETVER [:]",
	" :               SETVER [:] 䠩 n.nn",
	" :                SETVER [:] 䠩 /DELETE [/QUIET]\r\n",
	"  [:]      ᯮ 䠩 SETVER.EXE.",
	"  filename          䠩 ⭮ ணࠬ.",
	"  n.nn              MS-DOS  ⢥ ணࠬ.",
	"  /DELETE  /D    ⠡ ᨩ  㪠 ணࠬ.",
	"  /QUIET          ⬥ ᮮ饭, 筮 ⮡ࠦ  㤠",
	"                   ⠡ ᨩ.",
	NULL

};
char *Warn[] =
{
   "\n - 塞  ⠡ ᨩ MS-DOS ਫ ",
   "   ஢ Microsoft  ⮩ ᨥ MS-DOS. ",
   "  ⠢騪 ⮩ ணࠬ  ଠ樥  ⮬, 㤥  ",
   " ਫ ४⭮ ࠡ  ࠢ ⮩ ᨨ MS-DOS. ",
   "᫨  㬥   ਫ, ⠢ MS-DOS ᮮ ",
   "㣮  ᨨ MS-DOS,      ᯮ . ",
   "  ⠪ ਢ  ⮩稢 ࠡ ⥬.  ⮬ 砥 ",
   "Microsoft   ⢥⢥    ० .",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
   "",
   ": ணࠬ SETVER  㦥.  ⨢樨 SETVER ",
   "             饭   ᨨ 室  ", 
   "            맮 SETVER.EXE  䠩 CONFIG.SYS.",
   NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\sv\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
     "\r\nFEL:   ",
     "Felaktig vxel.",
     "Felaktigt filnamn.",
     "Det finns inte tillrckligt mycket ledigt minne.",
     "Felaktigt versionsnummer. Formatet mste vara mellan 2.11 och 9.99.",
     "Det gick inte att hitta den angivna posten i versionstabellen.",
     "Det gick inte att hitta filen SETVER.EXE.",
     "Felaktig enhetsbokstav.",
     "Fr mnga kommandoradsparametrar.",
     "Parameter saknas.",
     "Lser filen SETVER.EXE.",
     "Versionstabellen r skadad.",
     "Filen SETVER i den angivna skvgen r inte en kompatibel version.",
     "Det finns inte tillrckligt med ledigt utrymme fr nya poster i versionstabellen.",
     "Skriver filen SETVER.EXE."
     "Den angivna skvgen till filen SETVER.EXE r felaktig."
};

char *SuccessMsg                = "\r\nVersionstabellen har uppdaterats";
char *SuccessMsg2               = "Versionsndringen brjar glla nr du startar om datorn";
char *szMiniHelp                = "       Syntax \"SETVER /?\" fr hjlp";
char *szTableEmpty      = "\r\nDet gick inte att hitta ngra poster i versionstabellen";

char *Help[] = 
{
     "Anger vilket versionsnummer MS-DOS ska rapportera till olika program.\r\n",
     "Visa aktuell versionstabell:   SETVER [enhet:skvg]",
     "Lgg till post:                SETVER [enhet:skvg] filnamn n.nn",
     "Ta bort post:                  SETVER [enhet:skvg] filnamn /DELETE [/QUIET]\r\n",
     "  [enhet:skvg]  Anger var filen SETVER.EXE finns.",
     "  filnamn         Anger namnet p programfilen.",
     "  n.nn            Anger vilket versionsnummer MS-DOS ska rapportera till",
     "                  programfilen.",
     "  /DELETE         Tar bort den post i versionstabellen som motsvaras av den",
     "                  angivna programfilen. Du kan ocks skriva /D.",
     "  /QUIET          Meddelandet som vanligen visas nr en post tas bort frn", 
     "                  versionstabellen visas inte.",
     NULL

};
char *Warn[] =
{
   "\nVARNING - Det kan hnda att Microsoft inte har verifierat att ",
   "programmet gr att kra nr du ndrar programmets versionsnummer.  ",
   "Kontakta din terfrsljare fr att ta reda p om detta program ",
   "r kompatibelt med den aktuella versionen av MS-DOS.  ",
   "Om du kr programmet efter att ha ndrat i versionstabellen kan ",
   "du frlora data, frstra data eller gra systemet instabilt. ",
   "Microsoft ansvarar inte fr eventuella frluster eller skador ",
   "av data.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
     "",
     "OBS! Drivrutinen SETVER har inte lsts in. Om du vill aktivera ",
     "     versionsrapportering mste du lgga till SETVER.EXE i din CONFIG.SYS.",
     NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\pt\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERRO: ",
	"Parmetro invlido.",
	"Nome de ficheiro invlido.",
	"Memria insuficiente.",
	"N. de verso invlido, formato tem de ser 2.11 - 9.99.",
	"Entrada especificada no encontrada na tabela de verses.",
	"Ficheiro SETVER.EXE no encontrado.",
	"Especificador de unidade invlido.",
	"Demasiados parmetros de linha de comando.",
	"Parmetro em falta.",
	"a ler o ficheiro SETVER.EXE.",
	"Tabela de verses danificada.",
	"O ficheiro SETVER no caminho especificado  de uma verso incompatvel.",
	"No h mais espao para novas entradas na tabela de verses.",
	"a escrever o ficheiro SETVER.EXE."
	"Foi especificado um caminho invlido para SETVER.EXE."
};

char *SuccessMsg 		= "\r\nTabela de verses actualizada com xito";
char *SuccessMsg2		= "A mudana de verso surtir efeito da prxima vez que reiniciar o sistema";
char *szMiniHelp 		= "       Use \"SETVER /?\" para ajuda";
char *szTableEmpty	= "\r\nNenhumas entradas encontradas na tabela de verses";

char *Help[] =
{
        "Define o n. de verso que o MS-DOS devolve a um programa.\r\n",
        "Mostrar a tabela de verses actual:   SETVER [unidade:caminho]",
        "Adicionar entrada:   SETVER [unidade:caminho] NomeFicheiro n.nn",
        "Eliminar entrada:    SETVER [unidade:caminho] NomeFicheiro /DELETE [/QUIET]\r\n",
        "  [unidade:caminho]  Especifica a localizao do ficheiro SETVER.EXE.",
        "  nomedeficheiro     Especifica o nome do ficheiro de programa.",
        "  n.nn               Especifica a verso MS-DOS a ser devolvida ao programa.",
        "  /DELETE ou /D Elimina a entrada na tabela de verses do programa especificado",
        "  /QUIET        Oculta a mensagem geralmente mostrada durante a eliminao da",
        "                entrada na tabela de verses.",
	NULL

};
char *Warn[] =
{
   "\nAVISO - A aplicao que est a adicionar  tabela de verses MS-DOS ",
   "pode no ter sido verificada pela Microsoft nesta verso do MS-DOS.  ",
   "Contacte o seu fornecedor de software para obter informaes ",
   "sobre se esta aplicao executar correctamente nesta verso do MS-DOS.  ",
   "Se executar esta aplicao instrundo o MS-DOS para devolver um n. de ",
   "verso diferente, pode perder ou danificar dados ou causar ",
   "instabilidades de sistema. Nessa circunstncia, a Microsoft no  ",
   "responsvel por quaisquer perdas ou danos.",
   NULL
};


char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTA: O dispositivo SETVER no est carregado. Para activar o relatrio de ",
   "      verses, tem de carregar o dispositivo SETVER.EXE no CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\tst\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\setver\tr\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nHATA: ",
	"Geersiz anahtar.",
	"Geersiz dosya ad.",
	"Yetersiz bellek.",
	"Geersiz srm numaras, biim 2.11 - 9.99 olmal.",
	"Belirtilen girdi srm tablosunda bulunamad.",
	"SETVER.EXE dosyas bulunamad.",
	"Geersiz src tantcs.",
	"ok fazla komut satr parametresi.",
	"Eksik parametre.",
	"SETVER.EXE dosyas okunuyor.",
	"Srm tablosu bozuk.",
	"Belirtilen yoldaki SETVER dosyas uyumlu bir srm deil.",
	"Yeni girdiler iin srm tablosunda baka yer yok.",
	"SETVER.EXE dosyas yazlyor."
	"SETVER.EXE dosyas iin geersiz bir yol belirtildi."
};

char *SuccessMsg 		= "\r\Srm tablosu baaryla gncelletirildi";
char *SuccessMsg2		= "Srm deiiklii, bilgisayarnz yeniden balattnzda etkili olacaktr";
char *szMiniHelp 		= "       Yardm iin \"SETVER /?\" kullann";
char *szTableEmpty	= "\r\nSrm tablosunda girdi bulunamad ";

char *Help[] =
{
        "MS-DOS''un bir programa bildirdii srm numarasn ayarlar.\r\n",
        "Geerli srm tablosunu gsterir:  SETVER [src:yol]",
        "Girdi ekle:                        SETVER [src:yol] dosyaad n.nn",
        "Girdi sil:                         SETVER [src:yol] dosyaad /DELETE [/QUIET]\r\n",
        "  [src:yol]    SETVER.EXE dosyasnn yerini belirtir.",
        "  dosyaad        Program dosya adn belirtir.",
        "  n.nn            Programa bildirilecek MS-DOS srmn belirtir.",
        "  /DELETE or /D   Belirtilen program iin srm tablosu girdisini siler.",
        "  /QUIET          Normalde srm tablosu girdisini silerken gsterilen",
        "                  iletileri gizler.",
	NULL

};
char *Warn[] =
{
   "\nUYARI - MS-DOS srm tablosuna eklediiniz uygulama ",
   "bu MS-DOS srmnde Microsoft tarafndan onaylanmam olabilir.  ",
   "Bu MS-DOS srmnde bu uygulamann doru alp almayacan renmek ",
   "iin ltfen yazlmnzn satcsyla balant kurun.  ",
   "Bu uygulamay, MS-DOS''un farkl bir MS-DOS srm numaras ",
   "bildirmesini isteyerek altrrsanz, veri kaybedebilir veya bozabilirsiniz ",
   "veya sistem kararszlklarna yol aabilirsiniz. Bu koullarda Microsoft, ",
   "veri kaybndan veya bozulmasndan sorumlu deildir.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOT: SETVER aygt ykl deil. SETVER srm bildirimini etkinletirmek iin",
   "      SETVER.EXE aygtn CONFIG.SYS dosyanzda yklemelisiniz.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\cmd\share\share.asm ===
; share.asm
;
; Copyright (c) 1991, Microsoft Corporation
;
; History:
;   13-Apr-1992 Sudeep Bharati (sudeepb)
;   Created.
;
;   On NT this utility is just a stub which does nothing.
;

code	segment byte public 'CODE'
	assume	cs:code, ds:code, es:code

	org	100h
public	start
start:
	mov	ah,4ch
	xor	al,al
	int	21h
	ret

code	ends
	end	start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\ansi.asm ===
PAGE	,132
TITLE	CONDEV	FANCY CONSOLE DRIVER
;******************************************************************************

;  Change Log:

;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  06/01/90  MKS  C02  Bug#173.  ANSI was permitting you to go  one line below
;                      the bottom of the screen.  PROMPT $e[25;3H $e[1B will
;                      show you. (PYS: badly done. M005)
;******************************************************************************

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

;       ADDRESSES FOR I/O

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;------------------------------------------------------------------------------
; New functionality in DOS 4.00
; GHG fix scrolling flashes on Mod 25/30's
; P1767 VIDEO_MODE_TABLE not initialized correctly		10/16/87 J.K.
; D375 /X needs to be supported by ANSI sequence also		12/14/87 J.K.
; D397 /L option for Enforcing number of lines			12/17/87 J.K.
; D479  An option to disable the extended keyboard functions	02/12/88 J.K.
; P4241 AN001 fix be Revised to fix this problem		04/20/88 J.K.
; P4532 Scrolling has a snow for CGA adapter			04/27/88 J.K.
; P4533 In mode Dh, Eh, Fh, 10h and 13h, Scrolling not working	04/27/88 J.K.
; P4766 In mode 11h, and 12h erase display leaves bottom 5	05/24/88 F.G.
;------------------------------------------------------------------------------

INCLUDE	DEVSYM.INC
INCLUDE	ANSI.INC		;equates and structures
INCLUDE	VECTOR.INC

BREAK	<ANSI driver code>

PUBLIC	SWITCH_X		; /X option for extended keyboard redefinition support
PUBLIC	SCAN_LINES
PUBLIC	VIDEO_MODE_TABLE
PUBLIC	VIDEO_TABLE_MAX
PUBLIC	MAX_VIDEO_TAB_NUM	;P1767
PUBLIC	PTRSAV
PUBLIC	ERR1
PUBLIC	ERR2
PUBLIC	EXT_16
PUBLIC	BRKKY
PUBLIC	COUT
PUBLIC	BASE
PUBLIC	MODE
PUBLIC	MAXCOL
PUBLIC	EXIT
PUBLIC	NO_OPERATION
PUBLIC	HDWR_FLAG
PUBLIC	SWITCH_L
PUBLIC	SWITCH_K
PUBLIC	SWITCH_S		; M008 /S for screensize option setting.
PUBLIC	fhavek09		; M006

PUBLIC	CON$READ
PUBLIC	CON$RDND
PUBLIC	CON$FLSH
PUBLIC	CON$WRIT
PUBLIC	VIDEO
PUBLIC	CUU
PUBLIC	CUD
PUBLIC	CUF
PUBLIC	CUB
PUBLIC	CUP
PUBLIC	ED
PUBLIC	CPR
PUBLIC	SM
PUBLIC	RM
PUBLIC	SGR
PUBLIC	DSR
PUBLIC	KEYASN
PUBLIC	EXTKEY
PUBLIC	PSCP
PUBLIC	PRCP

IFDEF	JAPAN
PUBLIC	ROW_ADJ
ENDIF

CODE	SEGMENT PUBLIC BYTE

	ASSUME CS:CODE,DS:NOTHING,ES:NOTHING
;-----------------------------------------------

;	C O N - CONSOLE DEVICE DRIVER


EXTRN	CON$INIT	: NEAR		; ANSI initialization code
EXTRN	GENERIC_IOCTL	: NEAR		; Generic IOCTL code
EXTRN	REQ_TXT_LENGTH	: WORD		; current text length
EXTRN	GRAPHICS_FLAG	: BYTE		; graphics flag

ATTRIB	EQU	CHARDEV+DEVIOCTL+DEV320+ISSPEC+ISCOUT+ISCIN
CONDEV:	SYSDEV	<-1,ATTRIB,STRATEGY,ENTRY,'CON     '>	; Matches CON

;--------------------------------------------------------------

;	COMMAND JUMP TABLES
CONTBL:
	DW	CON$INIT
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	CON$READ
	DW	CON$RDND
	DW	NO_OPERATION
	DW	CON$FLSH
	DW	CON$WRIT
	DW	CON$WRIT
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	GENERIC_IOCTL		; generic IOCTL routine offset
MAX_CMD	EQU	($ - CONTBL)/2		; size of CONTBL

CMDTABL DB	'A'
	DW	CUU			; cursor up
	DB	'B'
	DW	CUD			; cursor down
	DB	'C'
	DW	CUF			; cursor forward
	DB	'D'
	DW	CUB			; cursor back
	DB	'H'
	DW	CUP			; cursor position
	DB	'J'
	DW	ED			; erase display
	DB	'K'
	DW	EL			; erase line
	DB	'R'
	DW	CPR			; cursor postion report
	DB	'f'
	DW	CUP			; cursor position
	DB	'h'
	DW	SM			; set mode
	DB	'l'
	DW	RM			; reset mode
	DB	'm'
	DW	SGR			; select graphics rendition
	DB	'n'
	DW	DSR			; device status report
	DB	'p'
	DW	KEYASN			; key assignment
	DB	'q'			; dynamic support of /X option through ansi sequence
	DW	EXTKEY			; esc[0q = reset it. esc[1q = set it
	DB	's'
	DW	PSCP			; save cursor postion
	DB	'u'
	DW	PRCP			; restore cursor position
IFDEF	JAPAN
	DB	'M'
	DW	DELETE			; delete line
	DB	'L'
	DW	INSERT			; insert line
ENDIF
	DB	00

GRMODE	DB	00,00000000B,00000111B
	DB	01,11111111B,00001000B
	DB	04,11111000B,00000001B
	DB	05,11111111B,10000000B
	DB	07,11111000B,01110000B
	DB	08,10001000B,00000000B
	DB	30,11111000B,00000000B
	DB	31,11111000B,00000100B
	DB	32,11111000B,00000010B
	DB	33,11111000B,00000110B
	DB	34,11111000B,00000001B
	DB	35,11111000B,00000101B
	DB	36,11111000B,00000011B
	DB	37,11111000B,00000111B
	DB	40,10001111B,00000000B
	DB	41,10001111B,01000000B
	DB	42,10001111B,00100000B
	DB	43,10001111B,01100000B
	DB	44,10001111B,00010000B
	DB	45,10001111B,01010000B
	DB	46,10001111B,00110000B
	DB	47,10001111B,01110000B
	DB	0FFH

;---------------------------------------------------
;	Device entry point


PTRSAV	DD	0

BUF1:	BUF_DATA <>			; Next CON Buffer area

STRATP	PROC	FAR

STRATEGY:
	mov	word ptr cs:[PTRSAV],bx
	mov	word ptr cs:[PTRSAV+2],es
	ret

STRATP	ENDP

ENTRY:
	push	si
	push	ax
	push	cx
	push	dx
	push	di
	push	bp
	push	ds
	push	es
	push	bx

; Check if header link has to be set	(Code ported from
;						DISPLAY.SYS)

	lea	bx,BUF1
	mov	di,OFFSET CONDEV	; CON Device header

	mov	CONPTR.DEV_HDRO,di
	mov	CONPTR.DEV_HDRS,cs
	cld				; all moves forward

	cmp	CONPTR.CON_STRAO, -1
	jne	L4			; has been linked to DOS CON
	cmp	CONPTR.CON_STRAS, -1
	jne	L4			; has been linked to DOS CON
					; next device header :	ES:[DI]
	lds	si,dword ptr CONPTR.DEV_HDRO
	les	di,HP.SDEVNEXT

L1:					; while pointer to next device header
	push	es			; is not -1
	pop	ax
	cmp	ax,-1
	jne	NOT0FFFF		; leave if both offset and segment are
	cmp	di,-1			; 0FFFFH
	je	L4

NOT0FFFF:
	push	di
	push	si
	mov	cx,8
	lea	di,NHD.SDEVNAME
	lea	si,HP.SDEVNAME
	repe	cmpsb
	pop	si
	pop	di
	and	cx,cx
					; Exit if name is found in linked hd.
	jnz	L3			; Name is not found
					; Name is found in the linked header
	mov	ax,NHD.SDEVSTRAT	; Get the STRATEGY address
	mov	CONPTR.CON_STRAO,ax
	mov	ax,es
X1:	mov	CONPTR.CON_STRAS,ax

	mov	ax,NHD.SDEVINT	 	; Get the INTERRUPT address
	mov	CONPTR.CON_INTRO,ax
	mov	ax,es
X2:	mov	CONPTR.CON_INTRS,ax

	jmp	SHORT L4		; Device Name
L3:
	les	di,NHD.SDEVNEXT
	jmp	L1
L4:
	lds	bx,cs:[PTRSAV]		; GET PONTER TO I/O PACKET

	mov	cx,word ptr ds:[bx].COUNT

	mov	al,byte ptr ds:[bx].CMD
	cbw
	mov	si,OFFSET CONTBL
	add	si,ax
	add	si,ax
	cmp	al,MAX_CMD		; not a call for ANSI...chain to lower device
	ja	NO_OPERATION

ifdef   KOREA                                   ; <MSCH>
        mov     ah, byte ptr ds:[bx].media
endif   ; KOREA

	les	di,dword ptr ds:[bx].TRANS

	; Following code, supplied by Compaq, is the "hit-it-on-the-head"
	; approach to solving the problem of resetting the screen length
	; after a character set reload.	We should try to find a better
	; approach.	For now this will stay in. - MGD

	push	ax			; SAVE AX
	mov	ax,40H			; GET ROM VAR
	mov	ds,ax			;

	mov	al,ds:[84h]		; GET MAX NUM OF ROWS
	cmp	al,0			; Q:ZERO
	jne	ENTRY10			; jmp IF NO
	mov	al,24			; SET TO 24 ROWS
ENTRY10:				;
	push	cs
	pop	ds

	ASSUME	ds:CODE

	inc	al			; BUMP FOR ONE BASED
	mov	byte ptr [REQ_TXT_LENGTH],al ; SET LENGTH TO 40:84H VALUE.	*F
	pop	ax			; RESTORE AX

	jmp	word ptr [si]		; GO DO COMMAND

;=====================================================
;=
;=	SUBROUTINES SHARED BY MULTIPLE DEVICES
;=
;=====================================================
;----------------------------------------------------------

;	EXIT - ALL ROUTINES RETURN THROUGH THIS PATH

BUS$EXIT:				; DEVICE BUSY EXIT
	mov	ah,00000011B
	jmp	SHORT ERR1

NO_OPERATION:
	call	PASS_CONTROL		; Pass control to lower CON
	jmp	SHORT ERR2

ERR$EXIT:
	mov	ah,10000001B		; MARK ERROR RETURN
	jmp	SHORT ERR1

EXITP	PROC	FAR

EXIT:	mov	ah,00000001B

ifdef   KOREA
INTERIM$EXIT:                           ; <MSCH>
endif   ; KOREA

ERR1:	lds	bx,cs:[PTRSAV]
	mov	word ptr [bx].STATUS,ax	; MARK OPERATION COMPLETE
ERR2:
	pop	bx
	pop	es
	pop	ds
	pop	bp
	pop	di
	pop	dx
	pop	cx
	pop	ax
	pop	si
	ret				; RESTORE REGS and RETURN
EXITP	ENDP


;	PASS CONTROL

;	This calls the attached device to perform any further
;	action on the call!


PASS_CONTROL	PROC
	lea	si,BUF1
	les	bx,cs:[PTRSAV]			; pass the request header to the
	call	dword ptr cs:[si].CON_STRAO	; CON strategy routine.
	call	dword ptr cs:[si].CON_INTRO	; interrupt the CON
	ret
PASS_CONTROL	ENDP
;-----------------------------------------------

;	BREAK KEY HANDLING

BRKKY:
	mov	byte ptr cs:ALTAH,3	; INDICATE BREAK KEY SET
INTRET: iret


;	WARNING - Variables are very order dependent, be careful
;		 when adding new ones!	- c.p.

WRAP		DB	0		; 0 = WRAP, 1 = NO WRAP
ASNPTR		DW	4
STATE		DW	S1
MODE		DB	3		;*
MAXCOL		DB	79		;*
COL		DB	0
ROW		DB	0
SAVCR		DW	0
INQ		DB	0
PRMCNT		LABEL	BYTE
PRMCNTW 	DW	0
KEYCNT		DB	0
KEYPTR		DW	BUF
REPORT		DB	ESC_CHAR,'[00;00R',CR	;CURSOR POSTION REPORT BUFFER
ALTAH		DB	0			;Special key handling

SAVE_CHAR	DW	0			; Temp storage for char/attr for new scroll code

EXT_16		DB	0		; Extended INT 16h flag
SWITCH_X	DB	OFF		; /X flag
SWITCH_L	DB	OFF		; DCR397; 1= /L flag entered.
SWITCH_K	DB	OFF		; To control EXT_16
fhavek09	DB	OFF		; M006
SCAN_LINES	DB	?		; flag for available scan lines (VGA)
HDWR_FLAG	DW	0		; byte of flags indicating video support
SWITCH_S	DB	OFF		; M008; /S flag

ifdef   KOREA                           ;
REQ_TYPE        DB      0               ;
EXT_REQ_TYPE    DB      0               ;
LEADBYTE        DB      0               ;
TRAILBYTE       DB      0               ;
ECSPRE          DB      0               ;
endif   ; KOREA                         ;

VIDEO_MODE_TABLE	LABEL	BYTE	; table containing applicable
MODE_TABLE	<>			; video modes and corresponding
MODE_TABLE	<>			; data.
MODE_TABLE	<>			; this table is initialized at
MODE_TABLE	<>			; INIT time
MODE_TABLE	<>			
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>

ifdef	KOREA				;  The KOREAN video mode
MODE_TABLE   <>                         ;  have 4 more than standard
MODE_TABLE   <>                         ;  VGA  card
MODE_TABLE   <>                         ;
MODE_TABLE   <>                         ;
endif   ; KOREA                         ;

VIDEO_TABLE_MAX	EQU	$		; maximum address for video table
MAX_VIDEO_TAB_NUM	EQU	($-VIDEO_MODE_TABLE)/TYPE MODE_TABLE ;P1767 Max number of table


IFDEF		DBCS
dbcs_flag	DB	0		; 0=single, 1=lead byte, 2=tail byte
ENDIF
IFDEF		JAPAN
new_mode	DB	0		; mode for '>'
row_adj		DB	0		; for ESC[>1l
ENDIF

;-------------------------------------------------------------

;	CHROUT - WRITE OUT CHAR IN AL USING CURRENT ATTRIBUTE

ATTRW		LABEL	WORD
ATTR		DB	00000111B		; CHARACTER ATTRIBUTE
BPAGE		DB	0			; BASE PAGE
BASE		DW	0b800h
SCREEN_SEG 	DW	00000h

chrout:

ifdef   KOREA                   ; <MSCH>
;
        cmp     [leadbyte],1    ; Is the previous byte a lead byte?  ; KeyW
        jnz     TestDBCSRange   ; No,
        mov     byte ptr [leadbyte],0
        mov     byte ptr [trailbyte],1   ; Mark that this is trail byte of ECS
        jmp     short OUTCHR
;
;
; Note : TestECS routine is hard coded. If you have the different code range,
;        you should change some codes below.
; 1990/11/9 This routine is changed to use IsDBCS routines.
;
TestDBCSRange:
        mov     byte ptr [trailbyte], 0 ; Mark it as a non trail byte
        call    IsDBCSleadbyte
        jnz     realout                 ; Jump if one byte code
;
;       CMP     AL, 0A1H                ;
;       JB      REALOUT                 ;
;       CMP     AL, 0FEH                ;
;       JA      REALOUT                 ;

        mov     byte ptr [leadbyte], 1  ;  it as a lead byte
        mov     ah, [col]               ;
        cmp     ah, [maxcol]            ;
        jnz     outchr                  ;
;                                       ;
; Decide the position to print the Lead byte which is on the column boundary.
;
        cmp     [wrap],0                ;
        jz      skip1                   ;
        dec     [col]                   ;
        cmp     [ecspre],1              ;
        jnz     oneback1                ;
        dec     [col]                   ;
oneback1:                               ;
        call    setit1                  ;
        jmp     short outchr            ;
skip1:                                  ;
        push    ax                      ;
        call    outchr1                 ;
        pop     ax                      ;
        jmp     short outchr            ;
realout:
endif   ; KOREA                         ;

	cmp	al,13
	jnz	trylf
	mov	[COL],0

ifdef	KOREA
	jmp	setit
else
IFDEF	JAPAN
	jmp	setit
ELSE
	jmp	short setit
ENDIF
endif   ; KOREA

trylf:	cmp	al,10
	jz	lf
	cmp	al,7
	jnz	tryback
torom:
	mov	bx,[ATTRW]
	and	bl,7
	mov	ah,14
	int	10h
ret5:	ret

tryback:
	cmp	al,8
	jnz	outchr
	cmp	[COL],0
	jz	ret5
	dec	[COL]
	jmp	short setit

outchr:
	mov	bx,[ATTRW]
	mov	cx,1
	mov	ah,9
	int	10h
	inc	[COL]
	mov	al,[COL]
	cmp	al,[MAXCOL]
	jbe	setit
	cmp	[wrap],0
	jz	outchr1
	dec	[COL]

ifdef   KOREA
;
;       Set boundary position for DBCS code.
;               No lead byte can arrive here.
;
        cmp     [trailbyte],1
        jnz     onebk
        dec     [col]
onebk:
        call    setit1
;
; We don't need ECSPRE change, because we have enough time to deal with it.
; Wait for another character to change ECSPRE.
;
endif	; KOREA

	ret
outchr1:
	mov	[COL],0
lf:	inc	[ROW]
	mov	ah,30			; GHG	Fix for ROUNDUP/PALACE
	mov	al,MODE		 	; GHG	Fix for ROUNDUP/PALACE
	cmp	al,11H			; GHG	Fix for ROUNDUP/PALACE
	je	LF2			; GHG	Fix for ROUNDUP/PALACE
	cmp	al,12H			; GHG	Fix for ROUNDUP/PALACE
	je	LF2			; GHG	Fix for ROUNDUP/PALACE

	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jne	tmplab1
	mov	ah,DEFAULT_LENGTH
	jmp	short tmplab2
tmplab1:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
tmplab2:
LF2:					; GHG	Fix for ROUNDUP/PALACE
IFDEF JAPAN
	sub	ah,row_adj
ENDIF
	cmp	[ROW],AH		; GHG	Fix for ROUNDUP/PALACE
	jb	setit
	dec	ah			; GHG	Fix for ROUNDUP/PALACE
	mov	[ROW],AH		; GHG	Fix for ROUNDUP/PALACE
	call	scroll

setit:

ifdef	   KOREA
preset:
        xor     al, al
        cmp     [trailbyte],al
        jz      noDBCStrail
        inc     al
noDBCStrail:
        mov     [ecspre], al
setit1:
endif   ; KOREA

	mov	dh,row
	mov	dl,col
	mov	bh,[bpage]
	mov	ah,2
	int	10h
	ret

;Writing a LF char through Teletype function to scroll the screen
;has a side effect of changing the color of the cursor when the PROMPT
;setting in PTM P4241 is used. AN001 uses this method to fix the strobing
;problem of the palace machine.	The old method of scrolling used to directly
;write into video buffer.	The old method has been used by AN001 for
;CGA adater of mode 2 or 3 only.
;To solve P4241, but to maintain the fix of the strobing problem of palace
;machine, we return back to the old logic but the old logic has to be
;Revised for the displays above CGA level.	For the adapters above
;CGA display, we don't need to turn off/on the video - this will causes
;a strobing, if you use do this,	for Palace machine.
;This logic will be only applied to mode 2 and 3 only.

; Following code is bug fix supplied by Compaq - MGD
scroll:

ifdef	KOREA				; Responsible for ROM
        mov     al, 10
        jmp     torom
else
IFDEF	JAPAN				; ### if JAPAN ###

	xor	cx,cx
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	scroll10		; if nor graphic
	mov	dh,DEFAULT_LENGTH
	xor	bh,bh
	jmp	short scroll20
scroll10:
	mov	dh,byte ptr [REQ_TXT_LENGTH]
	mov	bh,[ATTR]
scroll20:
	sub	dh,row_adj
	dec	dh
	mov	dl,[MAXCOL]
	mov	ax,0601h		; scroll up
	int	10h
	jmp	short setit

else					; ### if Not JAPAN ###

	mov	al,mode		 	; get display mode
	cmp	al,4			;Q: mode less than 4?
	jc	is_text		 	;Y: perform kludge
	cmp	al,7			;N: Q: monochrome mode?
	je	is_text		 	;   Y: perform kludge
	mov	al,10			; send the line feed to the ROM
	jmp	torom			; exit
is_text:
	mov	ah,8			; read char/attr at cursor pos
	mov	bh,[bpage]
	int	10h
	mov	[save_char],ax		; save char/attribute

	mov	ah,9			; write char at cursor pos
	mov	bx,[ATTRW]		; use current attribute
	mov	cx,1
	int	10h

	mov	al,10			; send the line feed to the ROM
	call	torom
	mov	ah,3			; read cursor pos
	int	10h
	push	dx			; save it
	mov	ah,2			; set cursor position
	dec	dh			; (to row-1)
	int	10h

	mov	ax,[save_char]		; retrieve saved char/attr
	mov	bl,ah
	mov	ah,9			; write it back to the screen
	mov	cx,1
	int	10h

	pop	dx			; retrieve new cursor position
	mov	ah,2			; set cursor position
	int	10h
	ret
ENDIF					; ### end if Not JAPAN ###
endif   ; KOREA


;------------------------------------------------------

;	CONSOLE READ ROUTINE

CON$READ:
	jcxz	CON$EXIT

ifdef   KOREA                           ;
        mov     [req_type], 0           ;
        mov     [ext_req_type], 10h     ;
        test    ah, 00000001b           ;
        jz      con$loop                ;
        mov     [req_type], 0f0h        ; ; Get Interim mode
        mov     [ext_req_type], 0f8h    ;
        cmp     cx, 1                   ;
        jnz     con$ndisp               ;
                                        ;
        call    chrin                   ;
        stosb                           ;
        cmp     ah, 0f0h                ; ; Is this an interim code ?
        jnz     con$exit                ;
        mov     ah, 00000101b           ;
        jmp     interim$exit            ; ; return to DOS with interim flag set
con$ndisp:                              ;
        call    chrin                   ;
        cmp     ah, 0f0h                ; ; Is this an interim code ?
        jz      con$ndisp               ; ; Skip the interims
        stosb                           ;
        LOOP    CON$NDISP               ;
        JMP     EXIT                    ;
endif   ; KOREA


CON$LOOP:
	push	cx			; SAVE COUNT
	call	CHRIN			; GET CHAR IN AL
	pop	cx
	stosb				; STORE CHAR AT ES:DI
	loop	CON$LOOP
CON$EXIT:
	jmp	EXIT
;---------------------------------------------------------

;	INPUT SINGLE CHAR INTO AL

CHRIN:	xor	ax,ax
	xchg	al,ALTAH		; GET CHARACTER & ZERO ALTAH
	or	al,al
	jnz	KEYRET

INAGN:	cmp	KEYCNT,0
	jnz	KEY5A

ifdef   KOREA
        mov     ah, [req_type]
else
	xor	ah,AH
endif   ; KOREA

	cmp	EXT_16,ON		; extended interrupt available?
	jne	tmplab3

ifdef   KOREA
        mov     ah, [ext_req_type]
else
	mov	ah,10h			; yes..perform extended call
endif	; KOREA

	INT	16h

ifdef   KOREA
        cmp     ah, 0f0h
        jz      keyret1                 ; Breief return for the interim code
endif   ; KOREA

	cmp	SWITCH_X,OFF		; /X switch used?
	jne	tmplab5
	call	CHECK_FOR_REMAP 	; no....map to normal call

tmplab5:
	call	SCAN			; check for redefinition
	jz	tmplab4			; no redefinition?....and
	cmp	SWITCH_X,ON		; /X switch used?
	jne	tmplab4
	call	CHECK_FOR_REMAP 	; then remap..
	or	bx,bx			; reset zero flag for jump test in old code

	jmp	short tmplab4

;	extended interrupt not available

tmplab3:
	int	16h

ifdef   KOREA
        cmp     ah, 0f0h
        jz      keyret1
endif   ; KOREA

	call	SCAN			; check for redefinition

tmplab4:
	jnz	ALT10			; IF NO MATCH JUST RETURN IT

	dec	cx
	dec	cx
	inc	bx
	inc	bx
	cmp	al,0			; check whether keypacket is an extended one
	jz	tmplab7
	cmp	al,0e0h
	jnz	tmplab6

ifdef   KOREA
        cmp     ah, 0f0h
        jb      mschtmp2
        cmp     ah, 0f2h
        jbe     tmplab7
mschtmp2:
endif   ; KOREA

	cmp	SWITCH_X,1
	jnz	tmplab6
tmplab7:
	dec	cx			; adjust pointers
	inc	bx			; appropiately
tmplab6:
	mov	KEYCNT,cl
	mov	KEYPTR,bx
KEY5A:					; Jmp here to get rest of translation
	call	KEY5			; GET FIRST KEY FROM TRANSLATION
ALT10:
	or	ax,ax			; Check for non-key after BREAK
	jz	INAGN
	or	al,al			; SPECIAL CASE?
	jnz	KEYRET
	mov	ALTAH,ah		; STORE SPECIAL KEY
KEYRET:

ifdef   KOREA
        mov     ah, 0f1h
keyret1:
endif   ; KOREA

	ret

KEY5:	mov	bx,KEYPTR		; GET A KEY FROM TRANSLATION TABLE
	mov	ax,word ptr [bx]
	dec	KEYCNT
	inc	bx
	or	al,al
	jnz	KEY6
	inc	bx
	dec	KEYCNT
KEY6:	mov	KEYPTR,bx
	ret

SCAN:	mov	bx,OFFSET BUF
KEYLP:	mov	cl,byte ptr [bx]
	xor	ch,ch
	or	cx,cx
	jz	NOTFND
	cmp	al,0			; check whether extended keypacket
	jz	tmplab8
	cmp	al,0e0h			; extended must be enabled with /x
	jnz	tmplab9

ifdef   KOREA                           ; Jump when Hangeul char
        cmp     ah, 0f0h
        jb      mschtmp1
        cmp     ah, 0f2h
        jbe     tmplab9
mschtmp1:
endif   ; KOREA

	cmp	SWITCH_X,ON
	jnz	tmplab9
tmplab8:
	cmp	ax,word ptr [bx+1]	; yes...compare the word
	jmp	short tmplab10
tmplab9:
	cmp	al,byte ptr [bx+1]	; no...compare the byte
tmplab10:
	jz	MATCH
	add	bx,cx
	jmp	KEYLP
NOTFND:	or	bx,bx
MATCH:	ret
;--------------------------------------------------------------

;	KEYBOARD NON DESTRUCTIVE READ, NO WAIT

CON$RDND:
	mov	al,[ALTAH]
	or	al,al

ifdef   KOREA
        jnz     To_RDEXIT
else
	jnz	RDEXIT
endif   ; KOREA

	cmp	[KEYCNT],0
	jz	RD1
	mov	bx,[KEYPTR]
	mov	al,byte ptr [bx]

ifdef   KOREA
to_rdexit:
        jmp     rdexit
else
	jmp	SHORT RDEXIT
endif   ; KOREA

RD1:

ifdef   KOREA
        mov     [req_type], 1
        mov     [ext_req_type], 11H
        test    ah, 00000001b
        jz      rd11
        mov     [req_type], 0f1h
        mov     [ext_req_type], 0f9H
RD11:
        mov     ah, [req_type]
        cmp     ext_16, on
        jnz     tmplab11
        mov     ah, [ext_req_type]
else
        mov     ah,1
	cmp	EXT_16,ON
	jnz	tmplab11
	add	ah,10h			; yes....adjust to extended call
endif	; KOREA

tmplab11:
	int	16h
	jz	CheckForEvent
	or	ax,ax
	jnz	RD2

ifdef   KOREA
        mov     ah, [req_type]
        and     ah, 11111110b
else
        mov     ah,0
endif   ; KOREA

	cmp	EXT_16,ON		; extended interrupt available?
	jne	tmplab12

ifdef   KOREA
        mov     ah, [ext_req_type]
        and     ah, 11111110b
else
	mov	ah,10h			; yes..perform extended call
endif   ; KOREA

	int	16h
	cmp	SWITCH_X,OFF		; /X switch used?
	jnz	tmplab13
	call	CHECK_FOR_REMAP		; no....map to normal call
	jmp	short tmplab13
tmplab12:
	int	16h
tmplab13:
	jmp	CON$RDND

RD2:

ifdef   KOREA
        cmp     ah, 0f0h
        jz      rdexit
endif   ; KOREA

	call	SCAN
	jz	tmplab14		; if no redefinition
	cmp	EXT_16,ON
	jnz	tmplab14		; and extended INT16 used
	cmp	SWITCH_X,ON		; and /x used
	jnz	tmplab14

	call	CHECK_FOR_REMAP		; remap to standard call
	or	bx,bx			; reset zero flag for jump test in old code

tmplab14:
	jnz	RDEXIT

	mov	al,byte ptr [bx+2]
	cmp	byte ptr [bx+1],0
	jnz	RDEXIT
	mov	al,byte ptr [bx+3]
RDEXIT: lds	bx,[PTRSAV]
	mov	[bx].MEDIA,al
EXVEC:	jmp	EXIT

; M006 - begin

CheckForEvent:
	cmp	fhavek09,0
	jz	CONBUS			; return with busy status if not k09

	les	bx,[ptrsav]
	assume	es:nothing
	test	es:[bx].status,0400h	; system wait enabled?
	jz	CONBUS			;  return with busy status if not

;	need to wait for ibm response to request for code
;	on how to use the system wait call.

	mov	ax,4100h		; wait on an external event
	xor	bl,bl			; wait for any event
	int	15h			; call rom for system wait

; M006 - end

CONBUS: jmp	BUS$EXIT
;--------------------------------------------------------------

;	KEYBOARD FLUSH ROUTINE

CON$FLSH:
	mov	[ALTAH],0		; Clear out holding buffer
	mov	[KEYCNT],0

ifdef   KOREA
        mov     ah, 0f3h
        int     16h
 ReadNullByte:                          ; We may have final char
        mov     ah, 0f1h
        int     16h
        jz      FlushDone
        mov     ah, 0f0h
        int     16h
        jmp     short   ReadNullByte
FlushDone:
else
Flush:	mov	ah,1
	cmp	EXT_16,ON		; if extended call available
	jnz	tmplab15
	add	ah,10h			; then use it
tmplab15:

	int	16h
	jz	FlushDone
	mov	ah,0

	cmp	EXT_16,ON		; if extended call available
	jnz	tmplab16
	add	ah,10h			; use it
tmplab16:
	int	16h
	jmp	Flush
FlushDone:
endif   ; KOREA

	jmp	EXVEC
;----------------------------------------------------------

;	CONSOLE WRITE ROUTINE

CON$WRIT:
	jcxz	EXVEC

ifdef   KOREA
        test    ah, 00000001b
        jnz     con$lp_nac      ;OUT CHAR WITHOUT CURSOR ADVANCING
endif   ; KOREA

CON$LP: mov	al,es:[di]		; GET CHAR
	inc	di
	call	OUTC			; OUTPUT CHAR
	loop	CON$LP			; REPEAT UNTIL ALL THROUGH
	jmp	EXVEC

ifdef   KOREA
con$lp_nac:
        mov     al, es:[di]
        inc     di
        call    outchr_nac      ;OUTPUT CHAR WITHOUT CURSOR MOVE
        loop    con$lp_nac      ;REPEAT UNTIL ALL THROUGH
        jmp     exit

outchr_nac:
        push    ax
        push    si
        push    di
        push    bp
        mov     ah, 0feh        ;OUTPUT CHAR WITHOUT CURSOR ADVANCING
        mov     bl, 7           ;SET FOREGROUND COLOR
        int     10h             ;CALL ROM BIOS
        pop     bp
        pop     di
        pop     si
        pop     ax
        ret
endif

COUT:	sti
	push	ds
	push	cs
	pop	ds
	call	OUTC
	pop	ds
	Iret

OUTC:	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	es
	push	bp

	mov	[BASE],0b800h
	xchg	ax,si			; SAVE CHARACTER TO STUFF
	mov	ax,40h			; POINT TO ROS BIOS
	mov	ds,ax
	mov	ax,ds:[49h]		; AL=MODE, AH=MAX COL
	dec	ah			; ANSI NEEDS 0-79 OR 0-39
	mov	word ptr cs:[MODE],ax	; SAVE MODE and MAX COL
	cmp	al,7
	jnz	NOT_BW
	mov	word ptr cs:[BASE],0B000H
NOT_BW: mov	al,ds:[62H]		; GET ACTIVE PAGE
	mov	cs:[BPAGE],al
	cbw
	add	ax,ax
	mov	bx,ax
	mov	ax,ds:[bx+50H]		; AL=COL, AH=ROW
	mov	word ptr cs:[COL],ax	; SAVE ROW and COLUMN
	mov	ax,ds:[4EH]		; GET START OF SCREEN SEG
	mov	cl,4
	shr	ax,cl			; CONVERT TO A SEGMENT
	push	cs
	pop	ds
	mov	[SCREEN_SEG],ax
	xchg	ax,si			; GET BACK CHARACTER IN AL

	call	VIDEO
	pop	bp
	pop	es
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret


;----------------------------------------------------------

;	OUTPUT SINGLE CHAR IN AL TO VIDEO DEVICE

VIDEO:	mov	si,OFFSET STATE
	jmp	[si]

S2:	cmp	al,'['
	jz	S22

ifdef   KOREA
        cmp     al, '$'
        jnz     chk_off
        mov     word ptr [si], offset S8
        ret
chk_off:
        cmp     al, '('
        jnz     jmp_S1
        mov     word ptr [si], offset S10
        ret
jmp_S1:
endif   ; KOREA

	jmp	S1
S22:	mov	word ptr [si],OFFSET S3
	xor	bx,bx
	mov	word ptr INQ,bx
	jmp	SHORT S3B

S3:	cmp	al,';'
	jnz	S3C
S3A:	inc	PRMCNT
S3B:	call	GETPTR
	xor	ax,ax
	mov	word ptr [bx],ax	; DEFAULT VALUE IS ZERO
	ret

S3C:	cmp	al,'0'
	jb	S3D
	cmp	al,'9'
	ja	S3D
	call	GETPTR
	sub	al,'0'
	xchg	al,byte ptr [bx]
	mov	ah,10
	mul	ah			; *10
	add	byte ptr [bx],al	; movE IN DIGIT
	ret

S3D:	cmp	al,'='
	jz	S3ret
	cmp	al,'?'
	jz	S3ret
IFDEF JAPAN
	cmp	al,'>'
	jz	s3f
ENDIF
	cmp	al,'"'			; BEGIN QUOTED STRING
	jz	S3E
	cmp	al,"'"
	jnz	S7
S3E:	mov	word ptr [si],OFFSET S4
	mov	[INQ],al
S3ret:	ret

IFDEF JAPAN
s3f:
	mov	new_mode,1
	jmp	short s3ret
ENDIF


;	ENTER QUOTED STRINGS


S4:	cmp	al,[INQ]		; CHECK FOR STRING TERMINATOR
	jnz	S4A
	dec	PRMCNT			; TERMINATE STRING
	mov	word ptr [si],OFFSET S3
	ret

S4A:	call	GETPTR
	mov	byte ptr [bx],al
	mov	word ptr [si],OFFSET S4
	jmp	S3A

;	LOOK FOR ANSI COMMAND SPECIFIED IN AL


	PUBLIC	S7
S7:	mov	bx,OFFSET CMDTABL-3

S7A:	add	bx,3
	cmp	byte ptr [bx],0
	jz	S1B
	cmp	byte ptr [bx],al
	jnz	S7A

S7B:	mov	ax,word ptr [bx+1]	; AX = JUMP addRESS
	mov	bx,OFFSET BUF
	inc	bx
	add	bx,ASNPTR		; BX = PTR TO PARM LIST
	mov	DL,byte ptr [bx]
	xor	DH,DH			; DX = FIRST PARAMETER
	mov	cx,dx
	or	cx,cx
	jnz	S7C
	inc	cx			; CX = DX, CX=1 IF DX=0
S7C:	jmp	ax			; AL = COMMAND

S1:	cmp	al,ESC_CHAR		; ESCAPE SEQUENCE?
	jnz	S1B
IFDEF	DBCS
	mov	dbcs_flag,0
ENDIF
IFDEF	JAPAN
	mov	new_mode,0
ENDIF
	mov	word ptr [si],OFFSET S2
	ret

S1B:

ifndef  KOREA                           ; IN KOREA, WE ALREADY handled
IFDEF DBCS
	cmp	dbcs_flag,1
	jz	set_dbcs		; if it was lead byte
	cmp	dbcs_flag,2
	jnz	@f			; if it was not tail byte
	mov	dbcs_flag,0		; reset
@@:
	call	IsDBCSLeadByte
	jnz	@f			; if this is not lead byte
set_dbcs:
	inc	dbcs_flag
@@:
	cmp	dbcs_flag,1
	jnz	@f
	mov	dl,col
	cmp	dl,maxcol
	jnz	@f
	push	ax
	mov	al,' '
	call	chrout
	pop	ax
@@:
ENDIF
endif   ; NOT KOREA

	call	CHROUT
S1A:	mov	word ptr [STATE],OFFSET S1
	ret

ifdef   KOREA
S8:     cmp     al, ')'
        jnz     s1
        mov     word ptr [si], offset S9
        ret
S9:     cmp     al, '1'
        jnz     S1
han_on:
        mov     ah, 0f2h
        mov     al, 08h                 ; Hangeul input mode on
        int     16h
        ret

S10:    cmp     al, '2'
        jnz     S1
han_off:
        mov     ah, 0f2h
        mov     al, 00h
        int     16h
        ret
endif   ; KOREA

MOVCUR:					;C02
	cmp	byte ptr [bx],AH
	jz	SETCUR
	add	byte ptr [bx],al
	loop	MOVCUR
SETCUR: mov	dx,word ptr COL
;*C05	xor	bx,bx
	mov	ah,0fh			;*C05
	int	10h			;*C05
	mov	ah,2
	int	16
	jmp	S1A

CUP:
					
IFDEF	JAPAN				; ### if JAPAN ###
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab17		; if not graphic mode
	mov	ah,DEFAULT_LENGTH
	jmp	short tmplab18
tmplab17:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
tmplab18:
	sub	ah,row_adj
	cmp	cl,ah
ELSE
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab17
	cmp	cl,DEFAULT_LENGTH
	jmp	short tmplab18
tmplab17:
	cmp	cl,byte ptr [REQ_TXT_LENGTH]
tmplab18:
ENDIF					; ### end if JAPAN ###

	ja	SETCUR
	mov	al,MAXCOL
	mov	ch,byte ptr [bx+1]
	or	ch,CH
	jz	CUP1
	dec	CH
CUP1:	cmp	al,CH
	ja	CUP2
	mov	ch,al
CUP2:	xchg	cl,CH
	dec	CH
	mov	word ptr COL,cx
	jmp	SETCUR

CUF:	mov	ah,MAXCOL
	mov	al,1
CUF1:	mov	bx,OFFSET COL
	jmp	MOVCUR

CUB:	mov	ax,00FFH
	jmp	CUF1

CUU:	mov	ax,00FFH
CUU1:	mov	bx,OFFSET ROW
	jmp	MOVCUR

CUD:
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab19
	mov	ah,DEFAULT_LENGTH
	jmp	short tmplab20
tmplab19:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
	dec	ah			; M005; REQ_TXT_LENGTH is not 0 based
tmplab20:
IFDEF JAPAN
	sub	ah,row_adj
ENDIF
	mov	al,1
	jmp	CUU1

ExtKey:
	cmp	dl, 0			; DL = previous parameter
	jne	ExtKey_1
	mov	Switch_X, OFF		; reset it if 0.
	jmp	S1A
ExtKey_1:
	cmp	dl, 1			; 1 ?
	je	SetExtKey
	jmp	S1A			; ignore it
SetExtKey:
	mov	Switch_X, ON		; set it if 1.
	jmp	S1A

PSCP:	mov	ax,word ptr COL
	mov	SAVCR,ax
	jmp	SETCUR

PRCP:	mov	ax,SAVCR
	mov	word ptr COL,ax
	jmp	SETCUR

SGR:	xor	cx,cx
	xchg	cl,PRMCNT
	call	GETPTR
	inc	cx
SGR1:	mov	al,byte ptr [bx]
	push	bx
	mov	bx,OFFSET GRMODE
SGR2:	mov	ah,byte ptr [bx]
	add	bx,3
	cmp	ah,0FFH
	jz	SGR3
	cmp	ah,al
	jnz	SGR2
	mov	ax,word ptr [bx-2]
	and	ATTR,al
	or	ATTR,AH
SGR3:	pop	bx
	inc	bx
	loop	SGR1
	jmp	SETCUR

IFDEF JAPAN				; ### if JAPAN ###
ED:
	mov	bl,dl			; save function no.
	mov	dh,30
	mov	al,MODE
	cmp	al,11h
	je	ed20			; if graphic 640X480
	cmp	al,12h
	je	ed20			; if graphic 640X480
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	ed10			; if not graphic mode
	mov	dh,DEFAULT_LENGTH
	jmp	short ed20
ed10:
	mov	dh,byte ptr [REQ_TXT_LENGTH]
ed20:
	sub	dh,row_adj
	dec	dh			; last row
	mov	dl,MAXCOL
	xor	cx,cx
	cmp	bl,0
	jz	ed_func0
	cmp	bl,1
	jz	ed_func1
	mov	word ptr COL,cx		; ESC[2J
	jmp	short ed_30
ed_func0:				; ESC[0J
	push	dx
	mov	cx,word ptr COL
	mov	dh,ch
	mov	dl,MAXCOL
	call	erase			; erase to eol
	pop	dx
	mov	ch,ROW
	cmp	ch,dh
	jz	ed_end			; if at bottom
	inc	ch
	mov	cl,0
	jmp	short ed_30
ed_func1:				; ESC[1J
	mov	dx,word ptr COL
	mov	ch,dh
	mov	cl,0
	call	erase			; erase from top
	mov	dh,ROW
	cmp	dh,0
	jz	ed_end
	dec	dh
	mov	dl,MAXCOL
	xor	cx,cx
ed_30:
	call	erase
ed_end:
	jmp	setcur

EL:
	cmp	dl,1
	jz	el_func1
	cmp	dl,2
	jz	el_func2
	mov	cx,word ptr COL		; ESC[0K
	mov	dh,ch
	mov	dl,MAXCOL
	jmp	short el_10
el_func1:
	mov	dx,word ptr COL		; ESC[1K
	mov	ch,dh
	mov	cl,0
	jmp	short el_10
el_func2:
	mov	ch,ROW			; ESC[2K
	mov	dh,ch
	mov	cl,0
	mov	dl,MAXCOL
el_10:
	call	erase
	jmp	setcur

erase:
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE	; if we are in graphics mode,
	jnz	erase10
	xor	bh,bh			; then use 0 as attribute
	jmp	short erase20
erase10:
	mov	bh,ATTR			; else use ATTR
erase20:
	mov	ax,0600H		; clear
	int	10h
	ret

else					; ### if Not JAPAN ###

ED:	xor	cx,cx
	mov	word ptr COL,cx
	mov	DH,30
	mov	al,MODE
	cmp	al,11H
	je	ERASE
	cmp	al,12H
	je	ERASE

	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab21
	mov	dh,DEFAULT_LENGTH
	jmp	short tmplab22
tmplab21:
	mov	dh,byte ptr [REQ_TXT_LENGTH]
tmplab22:
ERASE:	mov	DL,MAXCOL

	cmp	GRAPHICS_FLAG,GRAPHICS_MODE	; if we are in graphics mode,
	jnz	tmplab23
	xor	bh,bh			;	then use 0 as attribute
	jmp	short tmplab24
tmplab23:
	mov	bh,ATTR			;	else use ATTR
tmplab24:
	mov	ax,0600H
	int	16
ED3:	jmp	SETCUR

EL:	mov	cx,word ptr COL
	mov	DH,CH
	jmp	ERASE

ENDIF					; ### end if Not JAPAN ###

IFDEF JAPAN				; ### if JAPAN ###
delete:
	mov	ah,6			; scroll up
	jmp	short insdel
insert:
	mov	ah,7			; scroll down
insdel:
	mov	al,cl			; set scroll number
	mov	COL,0			; set to top of row
	mov	cx,word ptr COL
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	line10			; if not graphic mode
	mov	dh,DEFAULT_LENGTH
	xor	bh,bh			; attribute
	jmp	short line20
line10:
	mov	bh,ATTR
	mov	dh,byte ptr [REQ_TXT_LENGTH]
line20:
	sub	dh,row_adj
	dec	dh
	mov	dl,MAXCOL
	int	10h			; scroll
	jmp	setcur
ENDIF					; ### end if JAPAN ###

BIN2ASC:mov	DL,10
	inc	AL
	xor	ah,AH
	div	dl
	add	ax,'00'
	ret
DSR:	mov	ah,REQ_CRSR_POS
	push	bx
	xor	bh,bh
	int	10h
	pop	bx
	push	dx
	mov	al,dh			;REPORT CURRENT CURSOR POSITION
	call	BIN2ASC
	mov	word ptr REPORT+2,ax
	pop	dx
	mov	al,DL
	call	BIN2ASC
	mov	word ptr REPORT+5,ax
	mov	[KEYCNT],9
	mov	[KEYPTR],OFFSET REPORT
CPR:	jmp	S1A

RM:	mov	cl,1
	jmp	SHORT SM1

SM:	xor	cx,cx
SM1:	mov	al,DL

IFDEF JAPAN
	cmp	new_mode,1
	jz	nmode
ENDIF

	cmp	al,MODE7		;	if mode isn't (0-6, 13-19)
	jl	tmplab25		;	then skip	(cas -- signed?)
	cmp	al,MODE13
	jl	tmplab26
	cmp	al,MODE19
	jg	tmplab26

tmplab25:
	test	HDWR_FLAG,LCD_ACTIVE	; is this the LCD?
	jz	tmplab25a		; skip if not

	push	ds			; WGR yes...
	push	ax			; WGR save mode
	mov	ax,ROM_BIOS
	mov	ds,ax			; WGR get equipment status flag..
	mov	ax,DS:[EQUIP_FLAG]
	and	ax,INIT_VID_MASK	; WGR clear initial video bits..
	or	ax,LCD_COLOR_MODE	; WGR .....set bits as color
	mov	ds:[EQUIP_FLAG],ax 	; WGR replace updated flag.
	pop	ax			; WGR restore mode.
	pop	ds

tmplab25a:

	mov	ah,SET_MODE		; WGR yes....set mode..
	int	10H
	jmp	short tmplab27

tmplab26:
	cmp	al,7			; then if 7, wrap at EOL
	jnz	tmplab27
	mov	[WRAP],CL		; WGR yes....wrap...
tmplab27:
	jmp	CPR

IFDEF JAPAN				; ### if JAPAN ###
nmode:
	mov	new_mode,0
	cmp	al,1
	jz	row_mode		; set row mode
	cmp	al,5
	jz	cur_mode		; set cursor mode
	jmp	cpr
row_mode:
	mov	row_adj,0
	jcxz	row_mode_ret		; if set mode
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	row_mode10		; if not graphic mode
	mov	ah,DEFAULT_LENGTH
	jmp	short row_mode20
row_mode10:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
row_mode20:
	dec	ah
	cmp	row,ah
	jb	row_mode_30		; if cursor not at bottom row
	dec	row
	call	scroll
row_mode_30:
	inc	row_adj
row_mode_ret:
	jmp	cpr
cur_mode:
	push	cx
	mov	ah,3			; get cursor
	mov	bh,bpage
	int	10h
	pop	ax
	or	ax,ax
	jz	cur_mode10		; if for cursor off
	and	ch,11011111b		; cursor on
	jmp	short cur_mode20
cur_mode10:
	or	ch,00100000b		; corsor off
cur_mode20:
	mov	ah,1			; set cursor
	int	10h
	jmp	cpr
ENDIF					; ### end if JAPAN ###

KEYASN: xor	dx,dx
	xchg	DL,PRMCNT		;GET CHARACTER COUNT
	inc	dx
	inc	dx

	call	GETPTR
	mov	ax,word ptr [bx]	;GET CHARACTER TO BE ASSIGNED
	call	SCAN			;LOOK IT UP
	jnz	KEYAS1

	mov	di,bx			;DELETE OLD DEFINITION
	sub	ASNPTR,cx
	mov	KEYCNT,0		; This delete code shuffles the
					; key definition table all around.
					; This will cause all sorts of trouble
					; if we are in the middle of expanding
					; one of the definitions being shuffled.
					; So shut off the expansion.
	mov	si,di
	add	si,cx
	mov	cx,OFFSET BUF+ASNMAX
	sub	cx,si
	cld
	push	es			; SAVE USER'S ES
	push	CS
	pop	es			; SET UP ES addRESSABILITY
	rep	movsb
	pop	es			; RESTORE ES

KEYAS1: call	GETPTR
	cmp	DL,3
	jb	KEYAS3
	mov	byte ptr [bx-1],DL	; SET LENGTH
	add	ASNPTR,dx		; REMEMBER END OF LIST
	add	bx,dx
	cmp	ASNPTR,ASNMAX		; Too much???
	jb	KEYAS3			; No
	sub	bx,dx			; Next three instructions undo the above
	sub	ASNPTR,dx
KEYAS3: mov	byte ptr [bx-1],00
	mov	STATE,OFFSET S1		; RETURN
	ret

GETPTR: mov	bx,ASNPTR
	inc	bx
	add	bx,PRMCNTW
	cmp	bx,ASNMAX + 8
	jb	GET1
	dec	PRMCNT
	jmp	GETPTR
GET1:	add	bx,OFFSET BUF
	ret




; CHECK_FOR_REMAP:

; This function esnures that the keypacket
; passed to it in AX is mapped to a standard INT16h call



CHECK_FOR_REMAP PROC NEAR
	cmp	al,0e0h			; extended key?
	jnz	tmplab28

ifdef   KOREA
        cmp     ah, 0f0h
        jb      mschtmp
        cmp     ah, 0f2h
        jbe     tmplab28
mschtmp:
endif   ; KOREA

	or	ah,ah			; probably, but check for alpha character
	jz	tmplab28
	xor	al,al			; if not an alpha, map extended to standard
tmplab28:
	ret
CHECK_FOR_REMAP ENDP

IFDEF DBCS

;	Test if the character is DBCS Lead Byte

;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Lead Byte

	public	DBCSLeadByteTable
DBCSLeadByteTable	dd	0

IsDBCSLeadByte		proc	near
	push	ax
	push	si
	push	ds
	lds	si,cs:DBCSLeadByteTable
idlb_check:
	cmp	word ptr [si],0
	jz	idlb_not		; if end of table
	cmp	al,[si]
	jb	idlb_next		; if below low value
	cmp	al,[si+1]
	jbe	idlb_yes		; if below high value
idlb_next:
	add	si,2			; do next
	jmp	short idlb_check
idlb_not:
	or	al,1			; reset ZF
	jmp	short idlb_end
idlb_yes:
	and	al,0			; set ZF
idlb_end:
	pop	ds
	pop	si
	pop	ax
	ret
IsDBCSLeadByte		endp
ENDIF


BUF	DB	4,00,72H,16,0
	DB	ASNMAX+8-5 DUP (?)

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\ansi.inc ===
;   Equates and Strucs.


;------------------------------------------------------------------------------
; D425 For OS2 compatibiltiy box, /L option status query     01/14/88 J.K.
; D493 New INIT request structure for error message          02/25/88 J.K.
; P4934 Change ANSI 2F function number to 1Ah                05/20/88 F.G.
;------------------------------------------------------------------------------


;	DEVICE Header		DS:[SI]	-- to locate the next CON header
;	NEXT device header	ES:[DI]


HP		EQU	DS:[SI]
NHD		EQU	ES:[DI]

; CON data structure	CS:[BX]

CONPTR		EQU	CS:[BX]
					; STATES
BUF_DATA	STRUC
DEV_HDRO	DW	-1		; device driver header offset
DEV_HDRS	DW	-1
CON_STRAO	DW	-1		; dos CON strategy offset
CON_STRAS	DW	-1
CON_INTRO	DW	-1		; dos CON strategy offset
CON_INTRS	DW	-1
BUF_DATA	ENDS

;	INIT Structures and equates
IFNDEF		TRUE
TRUE		EQU	-1
ENDIF
IFNDEF		FALSE
FALSE		EQU	0
ENDIF
BRKADR		EQU	6Ch		; Break vector address
CR		EQU	13		; carriage return
BACKSP		EQU	8		; backspace
ESC_CHAR	EQU	1BH
ASNMAX		EQU	400		; (increased) SIZE OF KEY ASSIGNMENT BUFFER
ROM_BIOS	EQU	40h		; Segment of ROM_BIOS data area
EQUIP_FLAG	EQU	10h		; equipment flag. (for LCD)
KBD_FLAG_3	EQU	96h		; offset of KBD_FLAG_3 in data area
NUM_ROWS	EQU	84h		; offset of number of rows in data area
EXT16_FLAG	EQU	00010000b	; mask for Extended INT16 bit
INIT_VID_MASK	EQU	0FFCFh		; mask for equipment list
LCD_COLOR_MODE	EQU	20h		; LCD as color
LCD_MONO_MODE	EQU	30h		; LCD as MONOchrome
UNKNOWN_CMD	EQU	8103H		; unknown command status byte
RC_EOL		EQU	-1		; parser return code for EOL
RC_NO_ERROR	EQU	0		; parser return code for not in switch list
INVALID_PARM	EQU	10		; PARSE Invalid parameter message number
SSTRING		EQU	3		; PARSE Too many parameters message
FUNC_CALL	EQU	1BH		; VGA functionality call
ALT_SELECT	EQU	12H		; EGA alternate select call
EGA_INFO	EQU	10H		; EGA return information subcall
ALT_PRT_SC	EQU	20H		; select alternate print screen subcall
MONOCHROME	EQU	1		; monochrome attached to EGA
COLOR		EQU	0		; some color attached to EGA
PS2_MONO	EQU	7		; display adapter types...
PS2_COLOR	EQU	8
MOD30_MONO	EQU	0BH
MOD30_COLOR	EQU	0CH
LCD_MODEL	EQU	0F9H		; Convertible model byte value
GET_SYS_ID	EQU	0C0H		; INT15H call for system identification
GET_STATUS	EQU	43H		; read system status (Convertible)
MONO_ADDRESS	EQU	0B000H		; base address for monochrome
COLOR_ADDRESS	EQU	0B800H		; base address for CGA
UNOCCUPIED	EQU	-1		; value in VIDEO_MODE_TABLE if space unused
LCD_ACTIVE	EQU	00000001B	; LCD adapter is present
MONO_ACTIVE	EQU	00000010B	; monochrome adapter is present
CGA_ACTIVE	EQU	00000100B	; CGA adapter is present
MCGA_ACTIVE	EQU	00001000B	; MCGA is present
E5151_ACTIVE	EQU	00010000B	; EGA with monochrome is present
E5153_ACTIVE	EQU	00100000B	; EGA with color display is present
E5154_ACTIVE	EQU	01000000B	; EGA with enhanced color display is present
VGA_ACTIVE	EQU	10000000B	; VGA is present
INT10_LOW	EQU	(4*10H)		; interrupt 10 vector location
INT10_HI	EQU	(4*10H)+2
INT2F_LOW	EQU	(4*2FH)		; interrupt 2F vector location
INT2F_HI	EQU	(4*2FH)+2
ONE		EQU	1
THREE		EQU	3
EIGHT		EQU	8
NINE		EQU	9
FOURTEEN	EQU	14
REQ_CRSR_POS	EQU	3		; function call to return cursor position
MODE7		EQU	7
MODE13		EQU	13
MODE15		EQU	15
MODE19		EQU	19

;	Request Header Structure (INIT)

INIT_REQ_HDR	STRUC			; INIT Request header structure
		DB	13 DUP(?)	; standard request header
NUM_UNITS	DB	?		; number of units (N/A)
END_ADDRESS_O	DW	?		; ending address of resident code
END_ADDRESS_S	DW	?
ARG_PTR		DD	?		; ptr. to remaining arguments
DRIVE_NUM	DB	?		; drive number (N/A)
CONFIG_ERRMSG	DW	0		; Flag to control "Error in CONFIG.SYS.." msg.
INIT_REQ_HDR	ENDS


; Information Block Structure
;	(for functionality call)


INFO_BLOCK	STRUC			; information block for functionality call
STATIC_ADDRESS	DD	?		; address of static functionality table
		DB	33 DUP(?)	; don't care
ACTIVE_DISPLAY	DB	?		; active display code
ALT_DISPLAY	DB	?		; alternate display code
		DB	3 DUP(?)	; don't care
CURRENT_SCANS	DB	?		; current number of scan lines
		DB	2 DUP(?)	; don't care
MISC_INFO	DB	?		; miscellaneous state information
		DB	18 DUP(?)	; don't care
INFO_BLOCK	ENDS

; Video table entry structure


MODE_TABLE	STRUC
V_MODE		DB	-1		; video mode
D_MODE		DB	-1		; display mode
RESERVED_BYTE	DB	0		; reserved
COLORS		DW	-1		; colors
SCR_WIDTH	DW	-1		; screen width (pels)
SCR_LENGTH	DW	-1		; screen length (pels)
SCR_COLS	DW	-1		; number columns
SCR_ROWS	DW	-1		; number rows
MODE_TABLE	ENDS


; Structure of Static Block
;	(for functionality call


STATIC_BLOCK	STRUC			; format of static functionality table
		DB	7 DUP(?)	; don't care
SCAN_TEXT	DB	?		; available scan lines in text modes
STATIC_BLOCK	ENDS


; Structure of System ID call return block


SYS_ID		STRUC			; format of return system config data
		DW	?		; don't care
MODEL_BYTE	DB	?		; model byte
SYS_ID		ENDS



; INT2f Strucs and Equates


MULT_ANSI	EQU	1Ah		; ANSI multiplex number
INSTALL_CHECK	EQU	0		; install check for ANSI
IOCTL_2F	EQU	1		; 2F interface to IOCTL
DA_INFO_2F	EQU	2h		; J.K. Information passing to ANSI.
					; Subfunction code for IOCTL_2F
GET_SUBFUNC	EQU	7FH		; WGR Same structure as GET_IOCTL(ANSI)

;Info Struture for DA_INFO_2F. (DS:DX point to this packet)
;J.K. Note: For DOS 4.00, DA_INFO_PACKET is used by DISPLAY.SYS to signal ANSI.SYS that
;DISPLAY.SYS is calling/finishing INT 10h SET MODE call.	ANSI.SYS needs this
;infomration since it also hooks INT 10h vector.
;For this DA_SETMODE_FLAG purpose, DA_INFO_LEVEL and DA_INFO_DIRECTION should always be
;set to 0.	This can be extended for another information passing scheme between
;DISPLAY.SYS and ANSI.SYS in the future version.
;For DA_SETMODE_FLAG, DISPLAY.SYS should be extremely careful that when it calls
;with DA_SETMODE_FLAG =1, then it should calls with DA_SETMODE_FLAG=0
;when it finished INT 10h function call. Otherwise, the system goes .....

;D425. At the request of OS2 compatibility box, when the user ask to ANSI
; with DA_INFO_LEVEL=1, then ANSI sets DA_OPTION_L_STATE based on /L option
; status.

DA_INFO_PACKET	STRUC
DA_INFO_LEVEL	DB	0		; 0=used for SET_MODE_FLAG 1=for L_STATE
DA_SETMODE_FLAG	DB	0		; 1: DISPLAY.SYS is calling INT 10h call, SET MODE. 0=finished.
DA_L_STATE	DB	0		; 1 = /L active, 0 = /L inactive
DA_INFO_PACKET	ENDS



; GENERIC IOCTL Strucs and Equates



DISPLAY_TYPE	EQU	3		; MAJ_FUNC type for display
GET_FUNC	EQU	7FH		; MIN_FUNC for get subfunction
SET_FUNC	EQU	5FH		; MIN_FUNC for set subfunction
REQ_VID_MODE	EQU	0FH		; request video mode INT10h function call
DONE		EQU	0100H		; set done bit for IOCTL status
CMD_ERROR	EQU	8000H		; set error bit for IOCTL status
INVALID_FUNC	EQU	1		; invalid function
NOT_SUPPORTED	EQU	10		; return code non-supported ioctl function
NOT_AVAILABLE	EQU	12		; return code for font not available
TEXT_MODE	EQU	1		; text mode = 1 in request packet
GRAPHICS_MODE	EQU	2		; graphics mode = 2
DEFAULT_LENGTH	EQU	25		; normal screen length
OFF		EQU	0000H
ON		EQU	0001H
INT_BIT		EQU	00100000b	; mask for int. bit from functionality call
FOUND		EQU	1		; flag value for FOUND
NOT_FOUND	EQU	0		; flag value for not FOUND
SET_MODE	EQU	0		; set mode INT10H function number
DISPLAY_CHECK	EQU	0AD00H		; install check for DISPLAY.SYS
CHECK_ACTIVE	EQU	0AD02H		; active code page check for DISPLAY.SY
INSTALLED	EQU	0FFH		; present in AL if installed
LOAD_8X8	EQU	1112H		; register value for 8x8 ROM load
SET_BLOCK_0	EQU	1103H		; activate block = 0.
CHECK_FOR_FONT	EQU	0AD10H		; check for 8x8 RAM font - DISPLAY.SYS
SELECT_SCAN	EQU	30H		; subfunction to set scan lines (VGA)
SET_INTENSIFY	EQU	0		; value to enable intensify.
SET_BLINK	EQU	1		; value to enable blink.
BLINK_TOGGLE	EQU	1003H		; INT10 call to toggle int/blink bit.
CURSOR_FLAG	EQU	87H		; cursor flag byte in ROM_BIOS
SET_CURSOR_CALL EQU	1		; INT10 function call to set cursor typ
VIDEO_MASK	EQU	7FH		; turn of clear buffer bit of mode value
MULT_ANSI	EQU	1Ah		; ANSI multiplex number		;AC003
INSTALL_CHECK	EQU	0		; install check for ANSI
IOCTL_2F	EQU	1		; 2F interface to IOCTL
NOT_CY		EQU	0FFFEH		; turn carry bit off
CY		EQU	1		; turn carry bit off
INVALID_FLAGS	EQU	0FFFEH		; test for invalid flags in control word
TURN_OFF	EQU	0FEH		; values to turn off and on cursor..
TURN_ON		EQU	NOT TURN_OFF	; emulation
SUB_SIZE	EQU	11		; sublist size
LEFT_ASCIIZ	EQU	00010000B	; left-aligned asciiz string
UNLIMITED	EQU	0		; unlimited message size.


CMDLEN	=	0	;LENGTH OF THIS COMMAND
UNIT	=	1	;SUB UNIT SPECIFIER
CMD	=	2	;COMMAND CODE
STATUS	=	3	;STATUS
MEDIA	=	13	;MEDIA DESCRIPTOR
TRANS	=	14	;TRANSFER ADDRESS
COUNT	=	18	;COUNT OF BLOCKS OR CHARACTERS
START	=	20	;FIRST BLOCK TO TRANSFER


; REQUEST PACKET STRUCTURE (Generic IOCTL)


REQ_PCKT	STRUC
INFO_LEVEL	DB	?		; information level (should be 0)
		DB	?		; reserved
DATA_LENGTH	DW	?		; length of remaining data
RP_FLAGS	DW	?		; control flags
RP_MODE		DB	?		; display mode
RESERVED2	DB	?		; reserved
RP_COLORS	DW	?		; # of colors
RP_WIDTH	DW	?		; screen width
RP_LENGTH	DW	?		; screen length
RP_COLS		DW	?		; columns
RP_ROWS		DW	?		; rows
REQ_PCKT	ENDS


; Scan Lines available structure


SCAN_LINE_STR	STRUC
NUM_LINES	DW	?		; number of scan lines
REP_1BH		DB	?		; representation in 1Bh call
REP_12H		DB	?		; representation in 12h call
SCAN_LINE_STR	ENDS


; SUBLIST struc


SUB_STRUC	STRUC
		DB	2 DUP(?)
SUB_PTR_O	DW	?
SUB_PTR_S	DW	?
SUB_STRUC	ENDS


; RESULT BUFFER struc


RESULT_STRUC	STRUC
RESULT_TYPE	DB	?
		DB	?
RES_SYN_PTR	DW	?
RES_PTR		DD	?
RESULT_STRUC	ENDS

BREAK		MACRO	subtitle
		SUBTTL	subtitle
		PAGE	,132
ENDM

AsmVars		Macro	varlist
IRP		var,<varlist>
AsmVar		var
ENDM
ENDM

AsmVar		Macro	var
IFNDEF		var
var		=	FALSE
ENDIF
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\ioctl.asm ===
PAGE	,132
TITLE	ANSI Generic IOCTL Code

;******************************************************************************

;  Change Log:

;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------

;  06/29/90  MKS  C04  Bug#1150.  Video 7 Fastwrite VGA has problems if a
;		       Hercules mono board is the active display.

;******************************************************************************

;****************** START OF SPECIFICATIONS **************************

;  MODULE NAME: IOCTL.ASM

;  DESCRIPTIVE NAME: PERFORM THE GENERIC IOCTL CALL IN ANSI.SYS

;  FUNCTION: THE GENERIC DEVICE IOCTL IS USED TO SET AND GET THE
;	     MODE OF THE DISPLAY DEVICE ACCORDING TO PARAMETERS PASSED
;	     IN A BUFFER. ADDITIONALLY, THE CALL CAN TOGGLE THE
;	     USE OF THE INTENSITY BIT, AND CAN LOAD THE 8X8 CHARACTER
;	     SET, EFFECTIVELY GIVING MORE LINES PER SCREEN. THE
;	     AVAILABILITY OF THIS FUNCTION VARIES STRONGLY WITH HARDWARE
;	     ATTACHED.

;  ENTRY POINT: GENERIC_IOCTL

;  INPUT: LOCATION OF REQUEST PACKET STORED DURING STRATEGY CALL.

;  AT EXIT:
;     NORMAL: CARRY CLEAR - DEVICE CHARACTERISTICS SET

;     ERROR: CARRY SET - ERROR CODE IN AX.
;	     AX = 1  - INVALID FUNCTION. EXTENDED ERROR = 20
;	     AX = 10 - UNSUPPORTED FUNCTION ON CURRENT HARDWARE.
;			EXTENDED ERROR = 29
;	     AX = 12 - DISPLAY.SYS DOES NOT HAVE 8X8 RAM CHARACTER SET.
;			EXTENDED ERROR = 31

;  INTERNAL REFERENCES:

;     ROUTINES: GET_IOCTL - PERFORMS THE GET DEVICE CHARACTERISTICS
;		SET_IOCTL - PERFORMS THE SET DEVICE CHARACTERISTICS
;		GET_SEARCH - SEARCHES THE INTERNAL VIDEO TABLE FOR THE
;			     CURRENT MODE MATCH
;		SET_SEARCH - SEARCHES THE INTERNAL VIDEO TABEL FOR THE
;			     CURRENT MODE MATCH
;		SET_CURSOR_EMUL - SETS THE BIT THAT CONTROLS CURSOR EMULATION
;		INT10_COM - INTERRUPT 10H HANDLER TO KEEP CURRENT SCREEN SIZE
;		INT2F_COM - INTERRUPT 2FH INTERFACE TO GENERIC IOCTL
;		MAP_DOWN - PERFORMS CURSOR TYPE MAPPING FOR EGA WITH MONOCHROME
;		SET_VIDEO_MODE - SETS THE VIDEO MODE

;     DATA AREAS: SCAN_LINE_TABLE - HOLDS SCAN LINE INFORMATION FOR PS/2
;		  FUNC_INFO - BUFFER FOR PS/2 FUNCTIONALITY CALL.


;  EXTERNAL REFERENCES:

;     ROUTINES: INT 10H SERVICES

;     DATA AREAS: VIDEO_MODE_TABLE - INTERNAL TABLE FOR CHARACTERISTICS TO MODE
;				     MATCH-UPS

;  NOTES:

;  REVISION HISTORY:

;      Label: "DOS ANSI.SYS Device Driver"
;	      "Version 4.00 (C) Copyright 1988 Microsoft"
;	      "Licensed Material - Program Property of Microsoft"

;****************** END OF SPECIFICATIONS ****************************
;Modification history *********************************************************
; P1350 Codepage switching not working on EGA		   10/10/87 J.K.
; P1626 ANSI does not allow lines=43 with PS2,Monochrome	   10/15/87 J.K.
; p1774 Lines=43 after selecting cp 850 does not work	   10/20/87 J.K.
; p1740 MODE CON LINES command causes problem with PE2 w PS/210/24/87 J.K.
; p2167 Does'nt say EGA in medium resol. cannot do 43 lines  10/30/87 J.K.
; p2236 After esc [=0h, issuing INT10h,AH=fh returns mode=1. 11/3/87  J.K.
; p2305 With ANSI loaded, loading RDTE hangs the system	   11/06/87 J.K.
; P2617 Order dependecy problem with Display.sys		   11/23/87 J.K.
; p2716 HOT key of VITTORIA does not work properly	   12/03/87 J.K.
; d398  /L option for Enforcing the number of lines	   12/17/87 J.K.
; D425 For OS2 compatibiltiy box, /L option status query	   01/14/88 J.K.
; P5699 Moving selecting alternate print screen routine to only when it
; 10/26/88    is needed.  OEM EGA cards don't support the call it, so they
; K. Sayers   couldn't (shift) print screen at all when the alt. routine was
;	      invoked during initialization.
;******************************************************************************

INCLUDE		DEVSYM.INC
INCLUDE		ANSI.INC
INCLUDE		MULT.INC

PUBLIC		GENERIC_IOCTL
PUBLIC		SET_IOCTL
PUBLIC		GET_IOCTL
PUBLIC		SET_SEARCH
PUBLIC		GET_SEARCH
PUBLIC		SET_CURSOR_EMUL
PUBLIC		FUNC_INFO
PUBLIC		MAX_SCANS
PUBLIC		INT10_COM
PUBLIC		SET_MODE_HANDLER
PUBLIC		SET_CURSOR_HANDLER
PUBLIC		ROM_INT10
PUBLIC		INT2F_COM
PUBLIC		INT2F_HANDLER
PUBLIC		ROM_INT2F
PUBLIC		ABORT
PUBLIC		MAP_DOWN
PUBLIC		SET_VIDEO_MODE
PUBLIC		REQ_TXT_LENGTH
PUBLIC		GRAPHICS_FLAG
PUBLIC		DO_ROWS
PUBLIC		Display_Loaded_Before_Me

CODE		SEGMENT  PUBLIC  BYTE
		ASSUME CS:CODE,DS:CODE

EXTRN		PTRSAV:DWORD
EXTRN		NO_OPERATION:NEAR
EXTRN		ERR1:NEAR
EXTRN		VIDEO_MODE_TABLE:BYTE
EXTRN		MAX_VIDEO_TAB_NUM:ABS
EXTRN		HDWR_FLAG:WORD
EXTRN		SCAN_LINES:BYTE
EXTRN		SWITCH_L:Byte			;Defined in ANSI.ASM

IFDEF		JAPAN
EXTRN		row_adj:byte
ENDIF

SCAN_LINE_TABLE	LABEL	BYTE
		SCAN_LINE_STR <200,000000001B,0>	; 200 scan lines
		SCAN_LINE_STR <344,000000010B,1>	; 350 scan lines
		SCAN_LINE_STR <400,000000100B,2>	; 400 scan lines
SCANS_AVAILABLE	EQU	($ - SCAN_LINE_TABLE)/TYPE SCAN_LINE_STR

;This is used when ANSI calls Get_IOCTL, Set_IOCTL by itself.
In_Generic_IOCTL_flag	db	0
I_AM_IN_NOW		EQU	00000001b
SET_MODE_BY_DISPLAY	EQU	00000010b	;Display.sys calls Set mode INT 10h.
CALLED_BY_INT10COM	EQU	00000100b	;To prevent from calling set mode int 10h again.

INT10_V_Mode		db	0ffh		;Used by INT10_COM

My_IOCTL_Req_Packet	REQ_PCKT <0,0,0Eh,0,?,0,?,?,?,?,?>

FUNC_INFO		INFO_BLOCK <>		;data block for functionality call
ROM_INT10		DW	?		;segment and offset of original..
			DW	?		;interrupt 10h vector.
ROM_INT2F		DW	?		;segment and offset of original..
			DW	?		;interrupt 2Fh vector.
INTENSITY_FLAG		DW	OFF		;intensity flag initially off
REQ_TXT_LENGTH		DW	DEFAULT_LENGTH	;requested text screen length
SCAN_DESIRED		DB	0		;scan lines desired
MAX_SCANS		DB	0		;maximum scan line setting
GRAPHICS_FLAG		DB	TEXT_MODE	;flag for graphics mode
Display_Loaded_Before_Me db	0		;flag
ANSI_SetMode_Call_Flag	db	0		;Ansi is issuing INT10,AH=0.
ALT_PRT_SC_INVOKED	DB	FALSE		;indicates that have already set up alternat print screen routine



; PROCEDURE_NAME: GENERIC_IOCTL

; FUNCTION:
; TO GET OR SET DEVICE CHARACTERISTICS ACCORDING TO THE BUFFER PASSED
; IN THE REQUEST PACKET.

; AT ENTRY:

; AT EXIT:
;	NORMAL: CARRY CLEAR - DEVICE CHARACTERISTICS SET

;	ERROR: CARRY SET - ERROR CODE IN AL. (SEE MODULE DESCRIPTION ABOVE).

; NOTE: THIS PROC IS PERFORMED AS A JMP AS WITH THE OLD ANSI CALLS.



GENERIC_IOCTL:
	les	bx,[PTRSAV]			; establish addressability to request header
	mov	al,es:[bx].MINORFUNCTION
	les	di,es:[bx].GENERICIOCTL_PACKET	; point to request packet

	cmp	al,GET_FUNC			; is this get subfunction?
	jnz	gi_not_get

	call	GET_IOCTL			; yes...execute routine

	jmp	short gi_check_error

gi_not_get:
	cmp	al,SET_FUNC			; is this the set subfunction?
	jnz	gi_none

	call	SET_IOCTL			; yes....execute routine

gi_check_error:
	jnc	gi_done				; branch if no error
	or	ax,CMD_ERROR			; yes...set error bit in status

gi_done:
	or	ax,DONE				; add done bit to status
	jmp	ERR1				; return with status in ax

gi_none:
	jmp	NO_OPERATION			; call lower CON device


; PROCEDURE_NAME: GET_IOCTL

; FUNCTION:
; THIS PROCEDURE RETURNS DEVICE CHARACTERISTICS.

; AT ENTRY: ES:DI POINTS TO REQUEST BUFFER

; AT EXIT:
;	NORMAL: CARRY CLEAR - REQUEST BUFFER CONTAINS DEVICE CHARACTERISTICS

;	ERROR: CARRY SET - ERROR CONDITION IN AX



GET_IOCTL	PROC	NEAR

	cmp	es:[di].INFO_LEVEL,0		; check for valid info level
	jnz	gi_invalid
	cmp	es:[di].DATA_LENGTH,TYPE MODE_TABLE+1 ; and buffer size
	jge	gi_valid

gi_invalid:
	mov	ax,INVALID_FUNC			; not valid...unsupported
	stc					; function..set error flag and
	ret

gi_valid:
	mov	es:[di].INFO_LEVEL+1,0		; set reserved byte to 0.
	mov	ah,REQ_VID_MODE			; request current video mode
	int	10H
	and	al,VIDEO_MASK
	lea	si,VIDEO_MODE_TABLE		; point to resident video table
	call	GET_SEARCH			; perform search
	jnc	gi_supported			; found?

	mov	ax,NOT_SUPPORTED		; no....load unsupported function
	ret					; carry already set

gi_supported:
	push	di				;Save Request Buffer pointer
	mov	WORD PTR es:[di].DATA_LENGTH,(TYPE MODE_TABLE)+1 ;length of data is struc size
	inc	si				; skip mode value
	add	di,RP_FLAGS			; point to flag word

;	VGA,MCGA: VALUE RETURNED FROM FUNCTIONALITY CALL
;	EGA: VALUE LAST SET THROUGH IOCTL. DEFAULT IS BLINKING.
;	CGA,MONO: BLINKING

	cmp	al,7				; M004; Monochrome screen?
	mov	ax,OFF				; assume CGA,MONO 
						; (we always have blink).
	jz	gi_flags_done			; M004;

	cmp	HDWR_FLAG,MCGA_ACTIVE		; if we have an EGA or better
	jl	gi_flags_done

	test	HDWR_FLAG,VGA_ACTIVE		; VGA supported?
	jz	gi_as_intensity_flag

	push	es				; yes...prepare for
	push	di				; functionality call

	push	ds
	pop	es
	lea	di,FUNC_INFO			; point to data block
	mov	ah,FUNC_CALL			; load function number
	xor	bx,bx				; implementation type 0
	int	10H

	mov	INTENSITY_FLAG,OFF		; assume no intensity
	test	es:[di].MISC_INFO,INT_BIT	; is blink bit set?
	jnz	gi_intensity_is_fine		; if not no intensity

	inc	INTENSITY_FLAG			; we want intensity

gi_intensity_is_fine:
	pop	di				; restore registers
	pop	es

gi_as_intensity_flag:
	mov	ax,INTENSITY_FLAG		; write the control flag..

gi_flags_done:
	stosw					; write the control flag..
						; point to next field (display)
	mov	cx,(TYPE MODE_TABLE)-1		; load count
	rep	movsb				; transfer data from video table
						; to request packet
	sub	si,TYPE MODE_TABLE		; point back to start of mode data

ifdef JAPAN
	dec	di				; point to number of rows
	dec	di
ENDIF

	cmp	[si].D_MODE,TEXT_MODE		; if we are in text mode and
	jnz	gi_row_counted
	cmp	[si].SCR_ROWS,DEFAULT_LENGTH	; length <> 25 then we have an EGA or VGA
	jz	gi_row_counted

ifndef JAPAN
	dec	di				; point back to length entry in req packet
	dec	di
ENDIF
	push	ds
	mov	ax,ROM_BIOS			; load ROM BIOS data area segment
	mov	ds,ax
	mov	al,BYTE PTR ds:[NUM_ROWS]	; load current number of rows
	cbw
	inc	ax				; add 1 to row count
	mov	WORD PTR es:[di],ax		; and copy to request packet
	pop	ds

gi_row_counted:

ifdef JAPAN
	mov	al,row_adj
	xor	ah,ah
	sub	es:[di],ax			; support ESC[>1l
ENDIF

	xor	ax,ax				; no errors
	clc					; clear error flag
	pop	di				; Restore Request Buffer pointer
	ret					; return to calling module

GET_IOCTL	ENDP




; PROCEDURE_NAME: SET_IOCTL

; FUNCTION:
; THIS PROCEDURE SETS THE VIDEO MODE AND CHARACTER SET ACCORDING
; TO THE CHARACTERSTICS PROVIDED.

; AT ENTRY:
;	ES:[DI] POINTS TO REQUEST BUFFER

; AT EXIT:
;	NORMAL: CLEAR CARRY - VIDEO MODE SET

;	ERROR: CARRY SET - ERROR CONDITION IN AX



SET_IOCTL	PROC	NEAR

	or	In_Generic_IOCTL_Flag, I_AM_IN_NOW	; Signal GENERIC_IOCTL request being processed
	push	REQ_TXT_LENGTH			; save old value in case of error
ifdef JAPAN
	push	word ptr row_adj
endif

	cmp	es:[di].INFO_LEVEL,0		; check for valid info level
	jnz	si_invalid
	cmp	es:[di].DATA_LENGTH,TYPE MODE_TABLE+1 ; ane buffer size
	jnz	si_invalid
	mov	ax,es:[di].RP_FLAGS		; test for invalid flags
	test	ax,INVALID_FLAGS
	jnz	si_invalid
	test	es:[di].RP_FLAGS,ON		; if intensity is requested and..
	jz	si_valid
	cmp	HDWR_FLAG,MCGA_ACTIVE		; hardware does not support it
	jge	si_valid

si_invalid:
	mov	ax,INVALID_FUNC			; not valid...unsupported..
	jmp	si_failed

si_valid:
	call	SET_SEARCH			; search table for match
	jnc	si_mode_valid

si_not_supp:
	jmp	si_not_supported

si_mode_valid:
	cmp	[si].D_MODE,TEXT_MODE		; is a text mode being requested?
	jz	si_do_text_mode

	call	SET_VIDEO_MODE
	jmp	si_end_ok	

si_do_text_mode:
	mov	ax,es:[di].RP_ROWS		; save new requested value.

ifdef JAPAN
	mov	row_adj,0
	cmp	ax,DEFAULT_LENGTH-1
	jnz	@f
	mov	row_adj,1
	inc	ax
@@:
endif

	mov	REQ_TXT_LENGTH,ax

	cmp	ax,DEFAULT_LENGTH		; is it just 25 lines needed?
	jz	si_display_ok

	mov	ax,DISPLAY_CHECK
	int	2FH

	cmp	al,INSTALLED			; or is DISPLAY.SYS not there?
	jnz	si_display_ok

	mov	ax,CHECK_FOR_FONT
	int	2FH				; or if it is does it have the..
	jnc	si_display_ok

	mov	ax,NOT_AVAILABLE		; DISPLAY.SYS does not have the font
	jmp	si_failed
	
si_display_ok:
	cmp	[si].SCR_ROWS,UNOCCUPIED
	jz	si_is_vga
	test	HDWR_FLAG,VGA_ACTIVE
	jz	si_non_vga

si_is_vga:
	mov	ax,1A00h			;Get currently active adap.;C04
	int	10h				;VGA interrupt             ;C04
	mov	ax,REQ_TXT_LENGTH		; restore AX
	cmp	bl,7				;Q: non_vga adapter?	   ;C04
	jb	si_non_vga			;Yes so do other stuff	   ;C04

process_vga:
	mov	cl,3				; ax loaded with length requested
	shl	ax,cl				; mulitply by 8 to get scan lines
	lea	bx,SCAN_LINE_TABLE		; load bx with scan line table start
	mov	cx,SCANS_AVAILABLE		; total number of scan lines settings

pv_while:
	cmp	ax,[bx].NUM_LINES		; pointing at the right setting?
	jz	pv_found

	add	bx,TYPE SCAN_LINE_STR		; not this setting..point to next
	loop	pv_while
	
	jmp	short si_not_supp

pv_found:
	mov	dl,[bx].REP_1BH

	test	SCAN_LINES,dl			; does the hardware have it?
	jz	si_not_supp

	mov	cl,[bx].REP_12H			; yes, store value to set it
	mov	SCAN_DESIRED,cl

	cmp	REQ_TXT_LENGTH,DEFAULT_LENGTH	; 25 lines requested?
	jnz	pv_scan_ok

	mov	al,MAX_SCANS			; desired scan setting should be..
	mov	SCAN_DESIRED,AL			; the maximum.

pv_scan_ok:

; following added to overcome problems with rolling
; screens in QBX and WZMAIL.	Problem still exists when switching between
; mono and VGA screens when ANSI is loaded with /L.

	test	In_Generic_IOCTL_Flag,CALLED_BY_INT10COM
	jnz	si_set_mode_done

	mov	ah,ALT_SELECT			; set the appropriate number..
	mov	bl,SELECT_SCAN			; of scan lines..
	mov	al,SCAN_DESIRED
	int	10H

	jmp	short si_processed

si_non_vga:
	mov	ax,REQ_TXT_LENGTH
	cmp	ax,DEFAULT_LENGTH		; see if length requested..
	jz	si_cursor_emul			; is valid
	cmp	ax,[si].SCR_ROWS
	jnz	si_not_supported

si_cursor_emul:
	call	SET_CURSOR_EMUL

si_processed:
	call	SET_VIDEO_MODE

si_set_mode_done:
	call	DO_ROWS
	cmp	ALT_PRT_SC_INVOKED,FALSE	; If not set up already
	jnz	si_printscreen_ok
	cmp	es:[di].RP_ROWS,DEFAULT_LENGTH	; and needed because lines	(or 30?)
	jle	si_printscreen_ok
	cmp	HDWR_FLAG,MCGA_ACTIVE		; and if we have EGA or better then.. (supported)
	jl	si_printscreen_ok

	mov	ah,ALT_SELECT			; issue select alternate print..
	mov	BL,ALT_PRT_SC			; screen routine call..
	int	10H
	mov	ALT_PRT_SC_INVOKED,TRUE		; mark that it was done

si_printscreen_ok:
	call	SET_CURSOR_EMUL			; yes..ensure cursor emulation
						; is set accordingly.
	cmp	HDWR_FLAG,MCGA_ACTIVE		; for the EGA and better...
	jl	si_end_ok

	cmp	[si].V_MODE,7			; M004; and not monochrome
	jz	si_end_ok

	xor	bx,bx				; bx: 1=intensity on, 0: off
						; assume off
	test	es:[di].RP_FLAGS,ON		
	jz	si_intensity_ok

	inc	bx				; user wants intensity

si_intensity_ok:
	mov	INTENSITY_FLAG,bx
	mov	ax,BLINK_TOGGLE
	xor	bl,ON				; bl is opposite
						; of INTENSITY_FLAG
	int	10H

si_end_ok:
	and	In_Generic_IOCTL_Flag, NOT I_AM_IN_NOW	; Turn the flag off
ifdef JAPAN
	pop	ax				; throw old row_adj
endif
	pop	ax				; forget old REQ_TXT_LENGTH
	xor	ax,ax				; clear error register
	clc					; clear error flag
	ret

si_not_supported:
	mov	ax,NOT_SUPPORTED

si_failed:
	and	In_Generic_IOCTL_Flag, NOT I_AM_IN_NOW	; Turn the flag off
ifdef JAPAN
	pop	word ptr row_adj
endif
	pop	REQ_TXT_LENGTH			; error...so restore old value.
	stc					; set error flag
	ret

SET_IOCTL	ENDP



; Procedure name: DO_ROWS
; Function:
;	Only called for TEXT_MODE.
;	If (REQ_TXT_LENGTH <> DEFAULT_LENGTH) &
;	(DISPLAY.SYS not loaded or CODEPAGE not active)
;	then
;	LOAD ROM 8X8 charater.


DO_ROWS		PROC	NEAR

	cmp	req_txt_length, DEFAULT_LENGTH
	je	dr_exit
	mov	ax,LOAD_8X8 			; load 8x8 ROM font
	xor	bl,bl
	int	10H				; M003;
	mov	ax,SET_BLOCK_0			; activate block = 0
	xor	bl,bl
	int	10H				; M003;
dr_exit:
	ret

DO_ROWS 	ENDP






; PROCEDURE_NAME: SET_SEARCH

; FUNCTION:
; THIS PROCEDURE SEARCHES THE RESIDENT VIDEO TABLE IN ATTEMPT TO
; FIND A MODE THAT MATCHES THE CHARACTERISTICS REQUESTED.

; AT ENTRY:

; AT EXIT:
;	NORMAL: CARRY CLEAR - SI POINTS TO APPLICABLE RECORD

;	ERROR: CARRY SET

; When INT10_V_Mode <> 0FFH, then assumes that the user
;	issuing INT10h, Set mode function call.	Unlike Generic IOCTL
;	set mode call, the user already has taken care of the video mode.
;	So, we also find the matching V_MODE.

; WARNING: TRASH CX

SET_SEARCH	PROC	NEAR

	lea	si,VIDEO_MODE_TABLE		; point to video table
	mov	cx,MAX_VIDEO_TAB_NUM 		; load counter, # of tables

ss_while:
	cmp	[si].V_MODE,UNOCCUPIED		; while we have valid entries
	jz	ss_not_found

	mov	al,INT10_V_Mode

	cmp	al,0ffh				; if not issued by Int10 set mode,
	jnz	ss_from_set_mode

	
	mov	al,es:[di].RP_MODE		; load register for compare.
	cmp	[si].D_MODE,al			; match?
	jnz	ss_end_while

	mov	ax,es:[di].RP_COLORS		; yes...prepare next field
	cmp	[si].COLORS,ax			; match?
	jnz	ss_end_while

	cmp	es:[di].RESERVED2,0		; yes, ensure reserved byte is zero
	jnz	ss_end_while

	cmp	es:[di].RP_MODE,GRAPHICS_MODE	; for graphics mode
	jnz	ss_not_graphic			; check the following:

	mov	ax,es:[di].RP_WIDTH		; screen width.
	cmp	[si].SCR_WIDTH,ax
	jnz	ss_end_while

	mov	ax,es:[di].RP_LENGTH		; screen length
	cmp	[si].SCR_LENGTH,ax
	jnz	ss_end_while			; ignore #rows and #coloumns

	jmp	short ss_found

ss_not_graphic:
	mov	ax,es:[di].RP_COLS		; the rows are matched
	cmp	[si].SCR_COLS,ax		; in the main routine
	jnz	ss_end_while

ss_found:
	clc
	jmp	short ss_done

ss_from_set_mode:
	cmp	[si].V_MODE,al			; if V_MODE = AL, we are ok
	jz	ss_found

ss_end_while:
	add	si,type MODE_TABLE		; then, this is not the correct entry.
	loop	ss_while			; Let's find the next entry.

ss_not_found:
	stc

ss_done:
	mov	INT10_V_Mode, 0FFh		; Done. Reset the value
	ret

SET_SEARCH	ENDP




; PROCEDURE_NAME: GET_SEARCH

; FUNCTION:
; THIS PROCEDURE SEARCHES THE VIDEO TABLE LOOKING FOR A MATCHING
; VIDEO MODE.

; AT ENTRY: DS:SI POINTS TO VIDEO TABLE
;		AL CONTAINS THE MODE REQUESTED

; AT EXIT:
;	NORMAL: CARRY CLEAR, DS:SI POINTS TO MATCHING RECORD

;	ERROR: CARRY SET

; WARNING: TRASH CX

GET_SEARCH	PROC	NEAR

	mov	cx,MAX_VIDEO_TAB_NUM		; # of total tables

gs_while:
	cmp	[si].V_MODE,UNOCCUPIED		; while we're not pointing to
	jz	gs_error
	cmp	[si].V_MODE,al			; the right mode and we are still
	jz	gs_got_it

	add	si,TYPE MODE_TABLE		; point to the next mode
	loop	gs_while

gs_error:
	stc					; no, set error flag
	ret

gs_got_it:
	clc
	ret

GET_SEARCH	ENDP



; PROCEDURE_NAME: SET_CURSOR_EMUL

; FUNCTION:
; THIS PROCEDURE SETS THE CURSOR EMULATION BIT OFF IN ROM BIOS. THIS
; IS TO PROVIDE A CURSOR ON THE EGA WITH THE 5154 LOADED WITH AN 8X8
; CHARACTER SET.

; AT ENTRY:

; AT EXIT:
;	NORMAL: CURSOR EMULATION BIT SET FOR APPLICABLE HARDWARE

;	ERROR: N/A



SET_CURSOR_EMUL PROC	NEAR

	test	HDWR_FLAG,E5154_ACTIVE		; EGA with 5154?
	jz	sce_done

	push	si
	push	ds				; yes..so..
	mov	ax,ROM_BIOS			; check cursor emulation..
	mov	ds,ax
	mov	si,CURSOR_FLAG
	mov	al,BYTE PTR [si]

	cmp	cs:REQ_TXT_LENGTH,DEFAULT_LENGTH; >25 lines req?
	jnz	sce_cursor_on

	and	al,TURN_OFF			; no....set it OFF

	jmp	short sce_cursor_ok

sce_cursor_on:
	or	al,TURN_ON			; yes...set it ON

sce_cursor_ok:
	mov	BYTE PTR [si],AL
	pop	ds
	pop	si

sce_done:
	ret					; return to calling module

SET_CURSOR_EMUL	ENDP




; PROCEDURE_NAME: INT10_COM

; FUNCTION:
; THIS IS THE INTERRUPT 10H HANDLER TO CAPTURE THE FOLLOWING FUNCTIONS:

;	AH=1H (SET CURSOR TYPE). CURSOR EMULATION IS PERFORMED IF WE HAVE
;		AND EGA WITH A 5151 MONITOR, AND 43 LINES IS REQUESTED.

;M002; What is bellow was modified. The /L option was removed. But ansi
;M002; will still do a GET_IOCTL/SET_IOCTL for the application.
;	AH=0H (SET MODE) SCREEN LENGTH IS MAINTAINED WHEN POSSIBLE. (IE. IN
;		TEXT MODES ONLY.)
;	AN004; Capturing Set Mode call and enforcing the # of Rows based on the
;		previous Set_IOCTL request lines was a design mistake.	ANSI cannot
;		covers the all the application program out there which use INT 10h
;		directly to make a full screen interface by their own way.
;		This part of logic has been taken out by the management decision.
;		Instead, for each set mdoe INT 10h function call, if it were not
;		issued by SET_IOCTL procedures itself, or by DISPLAY.SYS program,
;		then we assume that it was issued by an APPS, that usually does not
;		know the new ANSI GET_IOCTL/SET_IOCTL interfaces.
;		In this case, ANSI is going to call GET_IOCTL and SET_IOCTL function
;		call - This is not to lose the local data consistency in ANSI.

; AT ENTRY:

; AT EXIT:
;	NORMAL:

;	ERROR:



INT10_COM	PROC	NEAR

	sti 					; restore interrupts
	cmp	ah,SET_CURSOR_CALL
	jz	SET_CURSOR_HANDLER
	cmp	ah,SET_MODE
	jz	SET_MODE_HANDLER

	jmp	DWORD PTR cs:ROM_INT10		; no...pass it on.

SET_CURSOR_HANDLER:
	push	ax

	test	cs:HDWR_FLAG,E5151_ACTIVE	; do we have an EGA?
	jz	sch_goto_rom
	cmp	cs:REQ_TXT_LENGTH,DEFAULT_LENGTH
	jz	sch_goto_rom
	cmp	cs:GRAPHICS_FLAG,TEXT_MODE	; with 5151..so perform cursor mapping
	jnz	sch_goto_rom
	cmp	cl,8
	jl	sch_goto_rom

	mov	al,ch				; check for cursor..
	and	al,60h				; off emulation. J.K.

	cmp	al,20h
	jz	sch_goto_rom

	mov	al,ch				; start position for cursor
	call	MAP_DOWN
	mov	ch,al
	mov	al,cl				; end position for cursor
	call	MAP_DOWN
	mov	cl,al

sch_goto_rom:
	pop	ax
	jmp	DWORD PTR CS:ROM_INT10		; continue interrupt processing

SET_MODE_HANDLER:
	pushf					; prepare for IRET
	mov	cs:ANSI_SetMode_Call_Flag, 1	; Used by INT2F_COM
	call	DWORD PTR CS:ROM_INT10		; call INT10 routine
	mov	cs:ANSI_SetMode_Call_Flag, 0	; Reset it
	push	bp
	push	es
	push	ds
	push	si
	push	di
	push	dx
	push	cx
	push	bx
	push	ax
	push	cs
	pop	ds
	mov	ah,REQ_VID_MODE			; get current mode..
	pushf
	call	DWORD PTR ROM_INT10
	and	al,VIDEO_MASK			; mask bit 7 (refresh)
	test	In_Generic_IOCTL_Flag, (I_AM_IN_NOW + SET_MODE_BY_DISPLAY)	; Flag is on?
;If not (I_AM_IN_NOW or SET_MODE_BY_DISPLAY),

	jnz	smh_ioctl_done

;	cmp	SWITCH_L,0			;M002; No more /L
;	jnz	smh_ioctl_done			;M002; No more /L

	push	ax				;Save mode
	push	es
	push	cs
	pop	es
	mov	di,offset My_IOCTL_Req_Packet
	mov	INT10_V_Mode,al			;Save current mode for SET_SEARCH
	call	Get_IOCTL

	jc	smh_set_ioctl_done

	or	In_Generic_IOCTL_Flag, CALLED_BY_INT10COM ;Do not set mode INT 10h again. Already done.
	call	Set_IOCTL
	and	In_Generic_IOCTL_Flag, not CALLED_BY_INT10COM

smh_set_ioctl_done:

	pop	es
	pop	ax				;Restore mode
	mov	INT10_V_Mode,0FFh


smh_ioctl_done:

	lea	si,VIDEO_MODE_TABLE
	call	GET_SEARCH 			; look through table for mode selected.
	jc	smh_graphic_mode		; M001; if not found then
						; M001; assume graphic mode

	cmp	[si].D_MODE,TEXT_MODE		; text mode?
	jz	smh_text_mode

smh_graphic_mode:
	mov	GRAPHICS_FLAG,GRAPHICS_MODE	; no, set graphics flag
	jmp	short smh_flag_done

smh_text_mode:
	mov	GRAPHICS_FLAG,TEXT_MODE		; set TEXT MODE


smh_flag_done:

;	test	In_Generic_IOCTL_Flag, I_AM_IN_NOW
;	jnz	smh_l_done			; M002; No more /L
;	cmp	Graphics_Flag,TEXT_MODE		; M002; No more /L
;	jnz	smh_l_done			; M002; No more /L
;	cmp	SWITCH_L,1			; M002; No more /L
;	jnz	smh_l_done			; M002; No more /L

;	call	DO_ROWS				; M002; No more /L

smh_l_done:

;For each SET mode function int 10h function call, if it is not
;issued by ANSI GET_IOCTL and SET_IOCTL procedure themselves, we assume
;that the APPS, which usually does not know the ANSI GET_IOCTL/SET_IOCTL
;interfaces, intend to change the screen mode.	In this case, ANSI is
;kind enough to call GET_IOCTL and SET_IOCTL function call for themselves.

	pop	ax
	pop	bx
	pop	cx
	pop	dx
	pop	di
	pop	si
	pop	ds
	pop	es
	pop	bp
	iret

INT10_COM	ENDP




; PROCEDURE_NAME: INT2F_COM

; FUNCTION:
; THIS IS THE INTERRUPT 2FH HANDLER TO CAPTURE THE FOLLOWING FUNCTIONS:

;	ax=1A00H INSTALL REQUEST. ANSI WILL RETURN AL=FFH IF LOADED.

;	AH=1A01H THIS IS THE INT2FH INTERFACE TO THE GENERIC IOCTL.
;	NOTE: THE GET CHARACTERISTICS FUNCTION CALL WILL RETURN
;		THE REQ_TXT_LENGTH IN THE BUFFER AS OPPOSED TO
;		THE ACTUAL HARDWARE SCREEN_LENGTH
;	Ax=1A02h This is an information passing from DISPLAY.SYS about
;		the INT 10h, SET MODE call.

; AT ENTRY:

; AT EXIT:
;	NORMAL:

;	ERROR:



INT2F_COM	PROC	NEAR

	sti
	cmp	ah,multANSI			; is this for ANSI?
	jnz	ic_goto_rom
	cmp	al,DA_INFO_2F
	jle	INT2F_HANDLER

ic_goto_rom:
	jmp	DWORD PTR CS:ROM_INT2F		; no....jump to old INT2F

INT2F_HANDLER:

	cmp	al,INSTALL_CHECK
	jnz	ih_not_check

;	do install check

	mov	al,INSTALLED			; load value to indicate installed
	clc					; clear error flag.
	jmp	ih_iret

ih_not_check:
	cmp	al,DA_INFO_2F			; IOCTL or INFO passing?
	jbe	ih_valid
	jmp	ih_iret

ih_valid:
	push	bp
	push	ax				; s
	push	cx				; a
	push	dx				; v
	push	ds				; e	r
	push	es				;	e
	push	di				;	g
	push	si				;	s.
	push	bx
	push	ds				; load ES with DS (for call)
	pop	es
	mov	di,dx				; load DI with dx (for call)
	push	cs				; setup local addressability
	pop	ds

	cmp	al,IOCTL_2F			; IOCTL request
	jnz	ih_not_ioctl

	cmp	cl,GET_FUNC			; get function requested.
	jnz	ih_not_get

	call	GET_IOCTL

	jc	ih_set_flags			; if no error and
	cmp	HDWR_FLAG,E5151_ACTIVE		; >25 lines supported
	jl	ih_set_flags
	cmp	[si].D_MODE,TEXT_MODE		; this is a text mode then..
	jnz	ih_set_flags


;	cmp	SWITCH_L,1			; M002; No more /L
;	jz	ih_use_rtl			; M002; No more /L

	cmp	ANSI_SetMode_Call_Flag,1
	jnz	ih_use_rtl			; if not originated by ANSI thru AH=0, Int10
	cmp	Display_Loaded_Before_me,1	; or Display.sys not loaded before ANSI,
	jz	ih_get_ok

ih_use_rtl:
	mov	bx,REQ_TXT_LENGTH		; then use REQ_TXT_LENGTH instead..
ifdef JAPAN
	sub	bl,row_adj
endif
	mov	es:[di].RP_ROWS,bx

ih_get_ok:
	clc
	jmp	short ih_set_flags

ih_not_get:
	cmp	cl,SET_FUNC
	jnz	ih_invalid

	call	SET_IOCTL			; set function requested.

	jmp	short ih_set_flags

;	invalid function

ih_invalid:
	mov	ax,INVALID_FUNC			; load error and...
	stc 					; set error flag.
	jmp	short ih_set_flags		; Info. passing

ih_not_ioctl:
	cmp	es:[di].DA_INFO_LEVEL,0		; 0 - DA_SETMODE_FLAG request
	jnz	ih_not_info


	cmp	es:[di].DA_SETMODE_FLAG,1
	jnz	ih_not_set

	or	In_Generic_IOCTL_Flag, SET_MODE_BY_DISPLAY	;Turn the flag on
	jmp	short ih_info_ok

ih_not_set:
	and	In_Generic_IOCTL_Flag, not SET_MODE_BY_DISPLAY	;Turn the flag off

	jmp	short ih_info_ok

ih_not_info:

	cmp	es:[di].DA_INFO_LEVEL,1		; 1 = DA_L_STATA query
	jnz	ih_info_ok

;	mov	al,cs:[SWITCH_L]		; M002; No more /L
	mov	al,OFF				; M002; No more /L

	mov	es:[di].DA_L_STATE, al

ih_info_ok:
	clc					; clear carry. There is no Error in DOS 4.00 for this call.

ih_set_flags:
	pop	bx				; restore all..
	pop	si
	pop	di				;	registers except..
	pop	es
	pop	ds				;	BP.
	pop	dx
	pop	cx
	push	ax				; save error condition
	mov	bp,sp				; setup frame pointer
	mov	ax,[bp+10]			; load stack flags
	jc	ih_error			; carry set???

	and	ax,NOT_CY			; no.. set carry off.
	mov	[bp+10],ax			; put back on stack.
	pop	ax				; remove error flag from stack
	pop	ax				; no error so bring back function call
	XCHG	ah,al				; exchange to show that ANSI present
	jmp	short ih_pop_bp

ih_error:
	or	ax,CY				; yes...set carry on.
	mov	[bp+10],ax			; put back on stack.
	pop	ax				; restore error flag
	pop	bp				; pop off saved value of ax (destroyed)

ih_pop_bp:
	pop	bp				; restore final register.
ih_iret:
ABORT:	iret

INT2F_COM	ENDP




; PROCEDURE_NAME: MAP_DOWN

; FUNCTION:
; THIS PROCEDURE MAPS THE CURSOR START (END) POSITION FROM A 14 PEL
; BOX SIZE TO AN 8 PEL BOX SIZE.

; AT ENTRY: AL HAS THE CURSOR START (END) TO BE MAPPED.

; AT EXIT:
;	NORMAL: AL CONTAINS THE MAPPED POSITION FOR CURSOR START (END)

;	ERROR: N/A



MAP_DOWN	PROC	NEAR

	push	bx
	xor	ah,ah 			; clear upper byte of cursor position
	mov	bl,EIGHT		; multiply by current box size.
	push	dx			;	al	x
	mul	bl			;	---- = ---
	pop	dx			;	14	8
	mov	bl,FOURTEEN
	div	bl			; divide by box size expected.
	pop	bx
	ret

MAP_DOWN	ENDP




; PROCEDURE_NAME: SET_VIDEO_MODE

; FUNCTION:
; THIS PROCEDURE SETS THE VIDEO MODE SPECIFIED IN DS:[SI].V_MODE.

; AT ENTRY: DS:SI.V_MODE CONTAINS MODE NUMBER

; AT EXIT:
;	NORMAL: MODE SET

;	ERROR: N/A



SET_VIDEO_MODE PROC	NEAR

	test	In_Generic_IOCTL_Flag,CALLED_BY_INT10COM
	jnz	svm_done

	mov	al,[si].V_MODE			; ..issue set mode

	test	HDWR_FLAG,LCD_ACTIVE
	jnz	svm_update_bios			; is this the LCD?
	test	HDWR_FLAG,VGA_ACTIVE		; or VGA? (done for BRECON card)
	jz	svm_update_done

svm_update_bios:
	push	ds				; yes...
	mov	bl,al				; save mode
	mov	ax,ROM_BIOS
	mov	ds,ax				; get equipment status flag..
	mov	ax,ds:[EQUIP_FLAG]
	and	ax,INIT_VID_MASK		; clear initial video bits..

	cmp	bl,MODE7			; are we setting mono?
	jz	svm_mono
	cmp	bl,MODE15
	jnz	svm_color

svm_mono:
	or	ax,LCD_MONO_MODE		; yes...set bits as mono
	jmp	short svm_update_it

svm_color:
	or	ax,LCD_COLOR_MODE		; no...set bits as color

svm_update_it:
	mov	ds:[EQUIP_FLAG],ax	 	; replace updated flag.
	mov	al,bl			 	; restore mode.
	pop	ds

svm_update_done:
	mov	ah,SET_MODE			; set mode
	int	10H

svm_done:
	ret

SET_VIDEO_MODE	ENDP

CODE		ENDS
		END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\ansiinit.asm ===
PAGE	,132
TITLE	ANSI Console device CON$INIT routine

;******************************************************************************

;  Change Log:

;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------
;  06/05/90  MKS  C03  Bug#234.  ANSI was not recognizing the presence of a
;		       VGA if there was another video board in the system.
;******************************************************************************



;  MODULE_NAME: CON$INIT

;  FUNCTION:
;    THIS PROCEDURE PERFORMS ALL NECESSARY INITIALIZATION ROUTINES
;  FOR ANSI.SYS.

;  THIS ROUTINE WAS SPLIT FROM THE ORIGINAL ANSI.ASM SOURCE FILE
;  FOR RELEASE 4.00 OF DOS.  ALL CHANGED LINES HAVE BEEN MARKED WITH
; . NEW PROCS HAVE BEEN MARKED AS SUCH.


; P1767 VIDEO_MODE_TABLE not initialized correctly	   10/16/87 J.K.
; P2617 Order dependecy problem with Display.sys		   11/23/87 J.K.
; D479  An option to disable the extended keyboard functions 02/12/88 J.K.
; D493 New INIT request structure for error message	   02/25/88 J.K.
; P5699 Moving selecting alternate print screen routine to only when it
; 10/26/88    is needed.  OEM EGA cards don't support the call it, so they
; K. Sayers   couldn't (shift) print screen at all.
;-------------------------------------------------------------------------------

INCLUDE	ANSI.INC			; equates and strucs

PUBLIC	CON$INIT		


CODE	SEGMENT	PUBLIC	BYTE
	ASSUME	CS:CODE,DS:CODE

EXTRN	VIDEO_MODE_TABLE:BYTE
EXTRN	FUNC_INFO:BYTE
EXTRN	HDWR_FLAG:WORD
EXTRN	VIDEO_TABLE_MAX:ABS
EXTRN	SCAN_LINES:BYTE
EXTRN	PTRSAV:DWORD
EXTRN	PARSE_PARM:NEAR
EXTRN	ERR2:NEAR
EXTRN	EXT_16:BYTE
EXTRN	BRKKY:NEAR
EXTRN	COUT:NEAR
EXTRN	BASE:WORD
EXTRN	MODE:BYTE
EXTRN	MAXCOL:BYTE
EXTRN	EXIT:NEAR
EXTRN	MAX_SCANS:BYTE
EXTRN	ROM_INT10:WORD
EXTRN	INT10_COM:NEAR
EXTRN	ROM_INT2F:WORD
EXTRN	INT2F_COM:NEAR
EXTRN	ABORT:BYTE
EXTRN	Display_Loaded_Before_me:byte	;Defined in IOCTL.ASM
EXTRN	Switch_K:Byte
EXTRN	fhavek09:BYTE			; M006
EXTRN	Switch_S:BYTE			; M008

ifdef	DBCS
EXTRN	DBCSLeadByteTable:dword
endif


INCLUDE	ANSIVID.INC			; video tables data

CON$INIT:
	lds	bx,cs:[PTRSAV]		; establish addressability to request header	
	lds	si,[BX].ARG_PTR		; ds:SI now points to rest of DEVICE=statement
	call	PARSE_PARM		; parse DEVICE= command line
	jnc	CONT_INIT		; no error in parse...continue install
	lds	bx,cs:[PTRSAV]		; prepare to abort install			 
	xor	ax,ax			;						 
	mov	[BX].NUM_UNITS,al	; set number of units to zero		 
	mov	[BX].END_ADDRESS_O,ax	; set ending address offset to 0		 
	mov	[BX].END_ADDRESS_S,cs	; set ending address segment to CS		 
	mov	word ptr [bx].CONFIG_ERRMSG, -1 ; Let IBMBIO display "Error in CONFIG.SYS..".
	mov	ax,UNKNOWN_CMD		; set error in status			 
	mov	WORD PTR [BX].STATUS,ax ; set error status				 
	jmp	ERR2			; prepare to exit

CONT_INIT:			
	push	cs		
	pop	ds			; restore DS to ANSI segment
	mov	ax,ROM_BIOS	
	mov	es,ax			; ES now points to BIOS data area

	cmp	Switch_S,OFF		; M008
	jz	noscreensizesw		; M008

	mov	BYTE PTR es:[84h],24	; M008 ; Use default value

noscreensizesw:				; M008

	mov	ah,es:[KBD_FLAG_3]	; load AH with KBD_FLAG_3

	test	ah,EXT16_FLAG		; if extended Int16 available
	jz	tlab01
	cmp	Switch_K,OFF		; and user didn't disable it
	jnz	tlab01

	mov	EXT_16,ON		; then enable extended int16
tlab01:
	call	DET_HDWR		; procedure to determine video hardware status
	call	LOAD_INT10		; load interrupt 10h handler
	call	LOAD_INT2F		; load interrupt 2Fh handler

; M006 - begin
	push	ds
	pop	es
	xor	di,di			; es:di points to begining of driver

	mov	ax,4101h		; wait for bh=es:[di]
	mov	bl,1			; wait for 1 clock tick
	mov	bh,byte ptr es:[di]
	stc				; Assume we will fail
	int	15h
	jc	CheckColor
	mov	fhavek09,ON		; remember we have a k09 type
CheckColor:
; M006 - end

	int	11h
	and	al,00110000b
	cmp	al,00110000b
	jnz	iscolor
	mov	[base],0b000h		;look for bw card
iscolor:
	cmp	al,00010000b		;look for 40 col mode
	ja	setbrk
	mov	[mode],0
	mov	[maxcol],39

setbrk:
	xor	bx,bx
	mov	ds,bx
	mov	bx,BRKADR
	mov	WORD PTR [BX],OFFSET BRKKY
	mov	WORD PTR [BX+2],cs

	mov	bx,29H*4
	mov	WORD PTR [BX],OFFSET COUT
	mov	WORD PTR [BX+2],cs

ifdef DBCS
	mov	ax,6300h
	int	21h			; get DBCS lead byte table
	mov	word ptr cs:DBCSLeadByteTable,si
	mov	word ptr cs:DBCSLeadByteTable+2,ds
endif

	lds	bx,cs:[PTRSAV]
	mov	WORD PTR [BX].TRANS,OFFSET CON$INIT	;SET BREAK ADDRESS
	mov	[BX].TRANS+2,cs
	jmp	EXIT




;	PROCEDURE_NAME: DET_HDWR

;	FUNCTION:
;	THIS CODE DETERMINES WHAT VIDEO HARDWARE IS AVAILABLE.	THIS INFORMATION
;	IS USED TO LOAD APPROPRIATE VIDEO TABLES INTO MEMORY FOR USE IN THE
;	GENERIC IOCTL.

;	AT ENTRY:

;	AT EXIT:
;	NORMAL: FLAG WORD WILL CONTAIN BITS SET FOR THE APPROPRIATE
;		TABLES. IN ADDITION, FOR VGA SUPPORT, A FLAG BYTE
;		WILL CONTAIN THE AVAILABLE SCAN LINE SETTINGS FOR THE
;		INSTALLED ADAPTER.
;		VIDEO TABLES WILL BE LOADED INTO MEMORY REFLECTING
;		APPLICABLE MODE SETTINGS AND SCREEN LINE LENGTHS.

;	ERROR:	N/A



DET_HDWR	PROC	NEAR
	mov	ah,GET_SYS_ID		; see if this is a Convertible
	int	15h

	cmp	es:[BX].MODEL_BYTE,LCD_MODEL	; and it has an LCD attached
	jnz	tlab04

	mov	ah,GET_STATUS		; system status will tell us
	int	15h

	test	al,1			; if bit 0 = 0 then LCD..
	jnz	tlab04

	or	HDWR_FLAG,LCD_ACTIVE	; so ...set hdwr flag and...
	lea	si,COLOR_TABLE
	mov	cx,COLOR_NUM		; load color table (for LCD)
	call	LOAD_TABLE
	lea	si,MONO_TABLE		; and mono table
	mov	cx,MONO_NUM
	call	LOAD_TABLE
	jmp	short tlab05

;	not LCD... check for CGA and mono

tlab04:
	mov	ax,MONO_ADDRESS		; write to mono buffer to see if present
	call	CHECK_BUF

	cmp	ah,al
	jnz	tlab03			; if present then,

	or	HDWR_FLAG,MONO_ACTIVE	; set hdwr flag and..
	lea	si,MONO_TABLE
	mov	cx,MONO_NUM		; load mono table
	call	LOAD_TABLE

tlab03:

	mov	ax,COLOR_ADDRESS	; write to CGA buffer to see if present
	call	CHECK_BUF
	cmp	ah,al
	jnz	tlab02			; if present then,

	or	HDWR_FLAG,CGA_ACTIVE	; set hdwr flag and...
	lea	si,COLOR_TABLE
	mov	cx,COLOR_NUM		; load color table
	call	LOAD_TABLE

tlab02:

tlab05:
	push	cs			; setup addressiblity for
	pop	es			;	functionality call

	xor	ax,ax
	mov	ah,FUNC_call		; functionality call
	xor	bx,bx 			; implementation type 0
	lea	DI,FUNC_INFO		; block to hold data
	int	10H

	cmp	al,FUNC_call		; if call supported, then...
	jne	tlab11

	mov	ax,1A00h		; alternate check for VGA	;C03
	int	10h			; C03

	cmp	bl,8			; test for color VGA or mono VGA
	jz	tlab08
	cmp	bl,7
	jnz	tlab09
tlab08:

	or	HDWR_FLAG,VGA_ACTIVE	; yes ....so
	lea	si,COLOR_TABLE		; set hdwr flag and...
	mov	cx,COLOR_NUM		; load color table +..
	call	LOAD_TABLE
	lea	si,VGA_TABLE		; load VGA table
	mov	cx,VGA_NUM
	call	LOAD_TABLE

	jmp	short tlab07

;	not VGA, must be MCGA

tlab09:
	cmp	[DI].ACTIVE_DISPLAY,MOD30_MONO
	jz	tlab06
	cmp	[DI].ACTIVE_DISPLAY,MOD30_COLOR
	jz	tlab06
	cmp	[DI].ALT_DISPLAY,MOD30_MONO
	jz	tlab06
	cmp	[DI].ALT_DISPLAY,MOD30_COLOR
	jnz	tlab07

tlab06:
	or	HDWR_FLAG,MCGA_ACTIVE	; so...set hdwr flag and...
	lea	si,COLOR_TABLE
	mov	cx,COLOR_NUM		; load color table +..
	call	LOAD_TABLE
	lea	si,MCGA_TABLE		; load MCGA table
	mov	cx,MCGA_NUM
	call	LOAD_TABLE

tlab07:
	mov	al,[DI].CURRENT_SCANS	; copy current scan line setting..
	mov	MAX_SCANS,al 		; as maximum text mode scan setting.
	les	DI,[DI].STATIC_ADDRESS	; point to static functionality table
	mov	al,es:[DI].SCAN_TEXT	; load available scan line flag byte..
	mov	SCAN_LINES,al		; and store it in resident data.

	jmp	short DET_HDWR_DONE

;	call not supported, try EGA

tlab11:
	mov	ah,alT_SELECT		; alternate select call
	mov	BL,EGA_INFO		; get EGA information subcall
	int	10H

	cmp	bl,EGA_INFO		; see if call was valid
	jz	DET_HDWR_DONE

	cmp	bh,MONOCHROME		; yes, check for monochrome
	jnz	tlab17

	or	HDWR_FLAG,E5151_ACTIVE	; ..5151 found so set hdwr flag and..
	lea	si,EGA_5151_TABLE
	mov	cx,EGA_5151_NUM		; load 5151 table.
	call	LOAD_TABLE

	jmp	short DET_HDWR_DONE

tlab17:
	and	CL,0FH			; clear upper nibble of switch setting byte

	cmp	cl,9			; test for switch settings of 5154
	jz	tlab13
	cmp	cl,3
	jnz	tlab14
tlab13:

	or	HDWR_FLAG,E5154_ACTIVE	; so..set hdwr flag and...
	lea	si,COLOR_TABLE
	mov	cx,COLOR_NUM		; load color table +..
	call	LOAD_TABLE
	lea	si,EGA_5154_TABLE	; load 5154 table
	mov	cx,EGA_5154_NUM
	call	LOAD_TABLE

	jmp	short DET_HDWR_DONE

;	5154 not found, must be 5153

tlab14:
	or	HDWR_FLAG,E5153_ACTIVE	; so..set hdwr flag and...
	lea	si,COLOR_TABLE
	mov	cx,COLOR_NUM		; load color table +..
	call	LOAD_TABLE
	lea	si,EGA_5153_TABLE	; load 5153 table
	mov	cx,EGA_5153_NUM
	call	LOAD_TABLE

DET_HDWR_DONE:
	ret
DET_HDWR	ENDP




; PROCEDURE_NAME: CHECK_BUF

; FUNCTION:
; THIS PROCEDURE WRITES TO THE VIDEO BUFFER AND READS THE DATA BACK
; AGAIN TO DETERMINE THE EXISTANCE OF THE VIDEO CARD.

; AT ENTRY:

; AT EXIT:
;	NORMAL: AH EQ AL IF BUFFER PRESENT
;		AH NE AL IF NO BUFFER

;	ERROR: N/A



CHECK_BUF PROC	NEAR			; write to video buffer to see if it is present

	push	ds
	mov	ds,ax			; load DS with address of buffer
	mov	CH,ds:0			; save buffer information (if present)
	mov	al,55H 			; prepare to write sample data
	mov	ds:0,al			; write to buffer
	push	BX			; terminate the bus so that lines..
	pop	BX			; are reset
	mov	ah,ds:0			; bring sample data back...
	mov	ds:0,CH			; repair damage to buffer
	pop	ds
	ret

CHECK_BUF ENDP



; PROCEDURE_NAME: LOAD_TABLE

; FUNCTION:
; THIS PROCEDURE COPIES ONE OF THE VIDEO TABLES INTO RESIDENT DATA.
; IT MAY BE REPEATED TO LOAD SEVERAL TABLES INTO THE SAME DATA SPACE.
; MATCHING MODES WILL BE OVERWRITTEN...THEREFORE..CARE MUST BE TAKEN
; IN LOAD ORDERING.

; AT ENTRY:
;	SI: POINTS TO TOP OF TABLE TO COPY
;	CX: NUMBER OF RECORDS TO COPY

; AT EXIT:
;	NORMAL: TABLE POINTED TO BY SI IS COPIED INTO RESIDENT DATA AREA

;	ERROR: N/A



LOAD_TABLE PROC	NEAR
	push	DI			; save DI
	push	es			; and ES
	push	cs			; setup ES to code segment
	pop	es			
	lea	DI,VIDEO_MODE_TABLE	; point DI to resident video table

while01:
	cmp	cx,0			; do for as many records as there are
	jz	while01_exit
	cmp	di,VIDEO_TABLE_MAX	; check to ensure other data not overwritten
	jge	while01_exit		; cas --- signed compare!!!

	mov	al,[DI].V_MODE		; prepare to check resident table

	cmp	al,UNOCCUPIED		; if this spot is occupied
	jz	tlab20
	cmp	al,[si].V_MODE		; and is not the same mode then
	jz	tlab20

	add	DI,TYPE MODE_TABLE	; do not touch...go to next mode

	jmp	short while01

;	can write at this location

tlab20:
	push	cx			; save record count
	mov	cx,TYPE MODE_TABLE	; load record length
	rep	movsb			; copy record to resident data
	lea	DI,VIDEO_MODE_TABLE	; Set DI to the top of the target again.
	pop	cx			; restore record count and..
	dec	cx			; decrement

	jmp	short while01

while01_exit:
	pop	es			; restore..
	pop	DI			; registers
	ret
LOAD_TABLE ENDP




; PROCEDURE_NAME: LOAD_INT10

; FUNCTION:
; THIS PROCEDURE LOADS THE INTERRUPT HANDLER FOR INT10H

; AT ENTRY:

; AT EXIT:
;	NORMAL: INTERRUPT 10H VECTOR POINTS TO INT10_COM. OLD INT 10H
;		VECTOR STORED.

;	ERROR:	N/A



LOAD_INT10 PROC	NEAR
	push	es
	xor	ax,ax 			; point ES to low..
	mov	es,ax	 		; memory.
	mov	cx,es:WORD PTR INT10_LOW; store original..
	mov	cs:ROM_INT10,cx		; interrupt 10h..
	mov	cx,es:WORD PTR INT10_HI	; location..
	mov	cs:ROM_INT10+2,cx
	cli
	mov	es:WORD PTR INT10_LOW,OFFSET INT10_COM ; replace vector..
	mov	es:WORD PTR INT10_HI,cs	; with our own..
	sti
	mov	ax, DISPLAY_CHECK	;DISPLAY.SYS already loaded?
	int	2fh
	cmp	al, INSTALLED
	jne	L_INT10_Ret
	mov	cs:Display_Loaded_Before_Me,1
L_INT10_Ret:
	pop	es
	ret
LOAD_INT10 ENDP




; PROCEDURE_NAME: LOAD_INT2F

; FUNCTION:
; THIS PROCEDURE LOADS THE INTERRUPT HANDLER FOR INT2FH

; AT ENTRY:

; AT EXIT:
;	NORMAL: INTERRUPT 2FH VECTOR POINTS TO INT2F_COM. OLD INT 2FH
;		VECTOR STORED.

;	ERROR:	N/A



LOAD_INT2F PROC	NEAR
	push	es
	xor	ax,ax 			; point ES to low..
	mov	es,ax 			; memory.
	mov	ax,es:WORD PTR INT2F_LOW; store original..
	mov	cs:ROM_INT2F,ax		; interrupt 2Fh..
	mov	cx,es:WORD PTR INT2F_HI	; location..
	mov	cs:ROM_INT2F+2,cx
	or	ax,cx 			; check if old int2F is 0
	jnz	tlab21
	mov	ax,OFFSET ABORT		; yes....point to..
	mov	cs:ROM_INT2F,ax		; IRET.
	mov	ax,cs
	mov	cs:ROM_INT2F+2,ax

tlab21:
	cli
	mov	es:WORD PTR INT2F_LOW,OFFSET INT2F_COM	; replace vector..
	mov	es:WORD PTR INT2F_HI,cs	; with our own..
	sti
	pop	es
	ret
LOAD_INT2F ENDP


CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\ansivid.inc ===
VGA_TABLE	   LABEL BYTE
    MODE_TABLE	 < 1, 1,, 16,  -1,  -1, 40, -1> ; mode	1 Ŀ To give preference
    MODE_TABLE	 < 0, 1,, 16,  -1,  -1, 40, -1> ; mode	0   of COxx over
    MODE_TABLE	 < 3, 1,, 16,  -1,  -1, 80, -1> ; mode	3   BWxx.
    MODE_TABLE	 < 2, 1,, 16,  -1,  -1, 80, -1> ; mode	2 	(see text)
    MODE_TABLE	 < 7, 1,,  0,  -1,  -1, 80, -1> ; mode	7
    MODE_TABLE	 <13, 2,, 16, 320, 200, 40, 25> ; mode 13
    MODE_TABLE	 <14, 2,, 16, 640, 200, 80, 25> ; mode 14
    MODE_TABLE	 <15, 2,,  0, 640, 350, 80, 25> ; mode 15
    MODE_TABLE	 <16, 2,, 16, 640, 350, 80, 25> ; mode 16
    MODE_TABLE	 <17, 2,,  2, 640, 480, 80, 30> ; mode 17
    MODE_TABLE	 <18, 2,, 16, 640, 480, 80, 30> ; mode 18
    MODE_TABLE	 <19, 2,,256, 320, 200, 40, 25> ; mode 19
VGA_NUM 	 EQU  ($ - VGA_TABLE)/(TYPE MODE_TABLE)

MCGA_TABLE	   LABEL BYTE
    MODE_TABLE	 <17, 2,,  2, 640, 480, 80, 30> ; mode 17
    MODE_TABLE	 <19, 2,,256, 320, 200, 40, 25> ; mode 19
MCGA_NUM	 EQU  ($ - MCGA_TABLE)/(TYPE MODE_TABLE)

EGA_5154_TABLE	   LABEL BYTE
    MODE_TABLE	 < 1, 1,, 16,  -1,  -1, 40, 43> ; mode	1 Ŀ To give preference
    MODE_TABLE	 < 0, 1,, 16,  -1,  -1, 40, 43> ; mode	0   of COxx over
    MODE_TABLE	 < 3, 1,, 16,  -1,  -1, 80, 43> ; mode	3   BWxx.
    MODE_TABLE	 < 2, 1,, 16,  -1,  -1, 80, 43> ; mode	2 	(see text)
    MODE_TABLE	 <13, 2,, 16, 320, 200, 40, 25> ; mode 13
    MODE_TABLE	 <14, 2,, 16, 640, 200, 80, 25> ; mode 14
    MODE_TABLE	 <16, 2,, 16, 640, 350, 80, 25> ; mode 16
EGA_5154_NUM	 EQU  ($ - EGA_5154_TABLE)/(TYPE MODE_TABLE)

EGA_5153_TABLE	   LABEL BYTE
    MODE_TABLE	 <13, 2,, 16, 320, 200, 40, 25> ; mode 13
    MODE_TABLE	 <14, 2,, 16, 640, 200, 80, 25> ; mode 14
EGA_5153_NUM	 EQU  ($ - EGA_5153_TABLE)/(TYPE MODE_TABLE)

EGA_5151_TABLE	   LABEL BYTE
    MODE_TABLE	 < 7, 1,,  0,  -1,  -1, 80, 43> ; mode	7
    MODE_TABLE	 <15, 2,,  0, 640, 350, 80, 25> ; mode 15
EGA_5151_NUM	 EQU  ($ - EGA_5151_TABLE)/(TYPE MODE_TABLE)

MONO_TABLE	   LABEL BYTE
    MODE_TABLE	 < 7, 1,,  0,  -1,  -1, 80, 25> ; mode	7
MONO_NUM	 EQU  ($ - MONO_TABLE)/(TYPE MODE_TABLE)

COLOR_TABLE	   LABEL BYTE
    MODE_TABLE	 < 1, 1,, 16,  -1,  -1, 40, 25> ; mode	1 Ŀ To give preference
    MODE_TABLE	 < 0, 1,, 16,  -1,  -1, 40, 25> ; mode	0   of COxx over
    MODE_TABLE	 < 3, 1,, 16,  -1,  -1, 80, 25> ; mode	3   BWxx.
    MODE_TABLE	 < 2, 1,, 16,  -1,  -1, 80, 25> ; mode	2 	(see text)
    MODE_TABLE	 < 4, 2,,  4, 320, 200, 40, 25> ; mode	4
    MODE_TABLE	 < 5, 2,,  2, 320, 200, 40, 25> ; mode	5
    MODE_TABLE	 < 6, 2,,  2, 640, 200, 80, 25> ; mode	6
COLOR_NUM	 EQU  ($ - COLOR_TABLE)/(TYPE MODE_TABLE)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\parser.asm ===
PAGE	    ,132
TITLE	    PARSE CODE AND CONTROL BLOCKS FOR ANSI.SYS

;****************** START OF SPECIFICATIONS **************************

;  MODULE NAME: PARSER.ASM

;  DESCRIPTIVE NAME: PARSES THE DEVICE= STATEMENT IN CONFIG.SYS FOR
;		     ANSI.SYS

;  FUNCTION: THE COMMAND LINE PASSED TO ANSI.SYS IN THE CONFIG.SYS
;	     STATEMENT IS PARSED TO CHECK FOR THE /X SWITCH. A FLAG
;	     IS CLEARED IF NOT FOUND.

;  ENTRY POINT: PARSE_PARM

;  INPUT: DS:SI POINTS TO EVERYTHING AFTER DEVICE=

;  AT EXIT:
;     NORMAL: SWITCH FLAGS WILL BE SET IF /X or /L IS FOUND

;     ERROR: CARRY SET

;  INTERNAL REFERENCES:

;     ROUTINES: SYSLOADMSG - MESSAGE RETRIEVER LOADING CODE
;		SYSDISPMSG - MESSAGE RETRIEVER DISPLAYING CODE
;		PARM_ERROR - DISPLAYS ERROR MESSAGE
;		SYSPARSE - PARSING CODE

;     DATA AREAS: PARMS - PARSE CONTROL BLOCK FOR SYSPARSE

;  EXTERNAL REFERENCES:

;     ROUTINES: N/A

;     DATA AREAS: SWITCH - BYTE FLAG FOR EXISTENCE OF SWITCH PARAMETER

;  NOTES:

;  REVISION HISTORY:
;	    A000 - DOS Version 4.00

;      Label: "DOS ANSI.SYS Device Driver"
;	      "Version 4.00 (C) Copyright 1988 Microsoft"
;	      "Licensed Material - Program Property of Microsoft"

;****************** END OF SPECIFICATIONS ****************************
;Modification history**********************************************************
; P1529 ANSI /x /y gives wrong error message		   10/8/87 J.K.
; D397  /L option for "Enforcing" the line number            12/17/87 J.K.
; D479  An option to disable the extended keyboard functions 02/12/88 J.K.
;******************************************************************************


INCLUDE     ANSI.INC	    ; ANSI equates and structures
.XLIST
INCLUDE     SYSMSG.INC	    ; Message retriever code
MSG_UTILNAME <ANSI>	    ; Let message retriever know its ANSI.SYS
.LIST

PUBLIC	    PARSE_PARM	     ; near procedure for parsing DEVICE= statement



; Set assemble switches for parse code that is not required!!



DateSW	      EQU     0
TimeSW	      EQU     0
CmpxSW	      EQU     0
DrvSW	      EQU     0
QusSW	      EQU     0
NumSW	      EQU     0
KeySW	      EQU     0
Val1SW	      EQU     0
Val2SW	      EQU     0
Val3SW	      EQU     0


CODE	      SEGMENT  PUBLIC BYTE
	      ASSUME CS:CODE

.XLIST
MSG_SERVICES <MSGDATA>
MSG_SERVICES <DISPLAYmsg,LOADmsg,CHARmsg>
MSG_SERVICES <ANSI.CL1>
MSG_SERVICES <ANSI.CL2>
MSG_SERVICES <ANSI.CLA>

INCLUDE     VERSION.INC
INCLUDE     PARSE.ASM       ; Parsing code
.LIST


EXTRN	    SWITCH_X:BYTE	 ; /X switch flag
extrn	    Switch_L:Byte	 ; /L switch flag
extrn	    Switch_K:Byte	 ; /K switch flag
extrn	    Switch_S:Byte	 ; M008 ; /S or /SCREENSIZE switch flag	



; PARM control blocks for ANSI
; Parsing DEVICE= statment from CONFIG.SYS

; DEVICE=[d:][path]ANSI.SYS [/X] [/K] [/L] [/S | /SCREENSIZE] ; M008



PARMS	       LABEL WORD
	       DW	PARMSX
	       DB	0		   ; no extra delimeters or EOLs.

PARMSX	       LABEL BYTE
	       DB	1,1		   ; 1 valid positional operand
	       DW	FILENAME	   ; filename
	       DB	1		   ; 1 switche definition in the following
	       DW	Switches
	       DB	0		   ; no keywords

FILENAME       LABEL WORD
	       DW	0200H		   ; file spec
	       DW	0001H		   ; cap by file table
	       DW	RESULT_BUF	   ; result
	       DW	NOVALS		   ; no value checking done
	       DB	0		   ; no switch/keyword synonyms

Switches       LABEL WORD
	       DW	0		   ; switch with no value
	       DW	0		   ; no functions
	       DW	RESULT_BUF	   ; result
	       DW	NOVALS		   ; no value checking done
	       DB	5		   ;AN003; M008; 5 switch synonym
X_SWITCH       DB	"/X",0             ; /X name
L_SWITCH       DB	"/L",0             ; /L
K_SWITCH       DB	"/K",0             ; /K
SSIZE_SWITCH   DB	"/SCREENSIZE",0    ; M008; /SCREENSIZE
S_SWITCH       DB	"/S",0             ; M008; /S

NOVALS	       LABEL BYTE
	       DB	0		   ; no value checking done

RESULT_BUF     LABEL BYTE
	       DB	?		   ; type returned (number, string, etc.)
	       DB	?		   ; matched item tag (if applicable)
SYNONYM_PTR    DW	0		   ; synonym ptr (if applicable)
	       DD	?		   ; value

SUBLIST        LABEL DWORD		   ; list for substitution
	       DB	SUB_SIZE
	       DB	0
	       DD	?
	       DB	1
	       DB	LEFT_ASCIIZ
	       DB	UNLIMITED
	       DB	1
	       DB	" "

Old_SI		dw	?
Saved_Chr	db	0
Continue_Flag	db	ON
Parse_Err_Flag	db	OFF



; PROCEDURE_NAME: PARSE_PARM

; FUNCTION:
; THIS PROCEDURE PARSES THE DEVICE= PARAMETERS FROM THE INIT REQUEST
; BLOCK. ERROR MESSAGES ARE DISPLAYED ACCORDINGLY.

; AT ENTRY: DS:SI POINTS TO EVERYTHING AFTER THE DEVICE= STATEMENT

; AT EXIT:
;    NORMAL: CARRY CLEAR - SWITCH FLAG BYTE SET TO 1 IF /X FOUND

;    ERROR: CARRY SET



PARSE_PARM    PROC     NEAR
	      CALL     SYSLOADMSG		; load message

	jnc	plab01

		CALL	 SYSDISPMSG		; display error message
		STC				; ensure carry still set

	jmp	plab02

plab01:
		PUSH	 CS			; establish ES ..
		POP	 ES			; addressability to data
		LEA	 DI,PARMS		; point to PARMS control block
		XOR	 CX,CX			; clear both CX and DX for
		XOR	 DX,DX			;  SYSPARSE
		CALL	 SYSPARSE		; move pointer past file spec
		mov	 Switch_L, OFF
		mov	 Switch_X, OFF

while01:
	cmp	Continue_Flag,ON
	jz	plab_bogus		; M008; bogus label to avoid jmp
	jmp	while01_end		; M008; out of short range.

plab_bogus:				; M008

	mov Old_SI, SI		;to be use by PARM_ERROR
	call SysParse

	cmp	ax,RC_EOL
	jnz	plab09

	mov Continue_Flag, OFF
	jmp	short while01

plab09:

	cmp	ax,RC_NO_ERROR
	jz	plab07

	   mov Continue_Flag, OFF
	   mov Switch_X, OFF
	   mov Switch_L, OFF
	   mov Switch_K, OFF
	   call Parm_Error
	   mov Parse_Err_Flag,ON

	jmp	short while01

plab07:

	cmp	Synonym_ptr,offset X_SWITCH
	jnz	plab05

	mov	Switch_X,ON
	jmp	short plab04


plab05:
	cmp	Synonym_ptr,offset L_SWITCH
	jnz	plab03

	mov	Switch_L,ON
	jmp	short plab04

plab03:						; M008
	cmp	Synonym_ptr, offset S_SWITCH	; M008
	jnz	plab11				; M008

plab12:						; M008
	mov	Switch_S,ON			; M008
	jmp	short plab04			; M008
						
plab11:						; M008
	cmp	Synonym_ptr, offset SSIZE_SWITCH; M008
	jz	plab12				; M008

	mov	Switch_K,ON		; must be /K

plab04:
	clc

	jmp	while01

while01_end:

	cmp	Parse_Err_Flag,ON
	jnz	plab10

	stc
	jmp	short plab02

plab10:
	clc

plab02:

	      RET
PARSE_PARM    ENDP




; PROCEDURE_NAME: PARM_ERROR

; FUNCTION:
; LOADS AND DISPLAYS "Invalid parameter" MESSAGE

; AT ENTRY:
;   DS:Old_SI -> parms that is invalid

; AT EXIT:
;    NORMAL: ERROR MESSAGE DISPLAYED

;    ERROR: N/A



PARM_ERROR    PROC   NEAR
	      PUSH   CX
	      PUSH   SI
	      PUSH   ES
	      PUSH   DS

;	       PUSH   CS
;	       POP    DS		 ; establish addressability
;	       MOV    BX,DX
;	       LES    DX,[BX].RES_PTR	 ; find offending parameter
	       push   ds
	       pop    es
	       mov    si, cs:Old_SI	;Now es:dx -> offending parms
	       push   si		;Save it
Get_CR:
	       cmp    byte ptr es:[si], 13 ;CR?
	       je     Got_CR
	       inc    si
	       jmp    Get_CR
Got_CR:
	       inc    si		   ; The next char.
	       mov    al, byte ptr es:[si]
	       mov    cs:Saved_Chr, al	   ; Save the next char

	       mov    byte ptr es:[si], 0     ; and make it an ASCIIZ
	       mov    cs:Old_SI, si	; Set it again
	       pop    dx		; saved SI -> DX

	       push   cs
	       pop    ds		;for addressability

	      LEA    SI,SUBLIST 	; ..and place the offset..
	      MOV    [SI].SUB_PTR_O,DX	; ..in the SUBLIST..
	      MOV    [SI].SUB_PTR_S,ES
	      MOV    AX,INVALID_PARM	; load 'Invalid parameter' message number
	      MOV    BX,STDERR		; to standard error
	      MOV    CX,ONE		; 1 substitution
	      XOR    DL,DL		; no input
	      MOV    DH,UTILITY_MSG_CLASS ; parse error
	      CALL   SYSDISPMSG 	; display error message
	      mov    si, cs:Old_SI	;restore the original char.
	      mov    cl, cs:Saved_Chr
	      mov    byte ptr es:[si], cl

	      POP    DS
	      POP    ES
	      POP    SI
	      POP    CX
	      RET
PARM_ERROR    ENDP

include msgdcl.inc

CODE	      ENDS
	      END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\ansi\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls852.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 852
;
; -----------------------------------------
;
Latin2_852_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 100,101,102,103,104,105,106,107,108,109,126,127,128,129,130,131
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 132,033,039,040,044,047,052,053,054,055,058,059,060,064,065,068
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 073,074,075,078,083,086,091,092,093,094,096,133,134,135,136,137
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 138,033,039,040,044,047,052,053,054,055,058,059,060,064,065,068
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 073,074,075,078,083,086,091,092,093,094,096,139,140,141,142,032
   ;                                               
  db 043,089,048,038,035,088,041,043,063,051,072,072,057,098,035,041
   ;                                               
  db 048,061,061,070,071,062,062,082,082,071,089,084,084,063,143,042
   ;                                               
  db 034,056,069,087,036,036,097,097,050,050,144,098,042,081,145,146
   ;                                               
  db 151,152,153,154,155,034,038,049,081,156,157,158,159,099,099,160
   ;                                               
  db 161,162,163,164,165,166,037,037,167,168,169,170,171,172,173,147
   ;                                               
  db 045,045,046,051,046,066,056,057,049,174,175,176,177,085,088,178
   ;                                               
  db 069,079,070,067,067,066,080,080,076,087,076,090,095,095,085,180
   ;                                               
  db 148,181,182,183,184,149,150,185,186,187,188,090,077,077,179,255


;
;Latin2_852_collate label word
; ctable  <,'COLLATE',256>
;  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
;  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
;   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
;  db 001,008,025,039,035,040,038,024,026,027,036,041,005,004,011,010
;   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
;  db 049,050,051,052,053,054,055,056,057,058,007,006,044,045,046,009
;   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
;  db 033,060,072,074,082,088,098,100,102,104,110,112,114,122,124,130
;   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
;  db 140,142,144,150,159,165,175,177,179,181,185,028,037,029,015,002
;   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
;  db 013,059,071,073,081,087,097,099,101,103,109,111,113,121,123,129
;   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
;  db 139,141,143,149,158,164,174,176,178,180,184,030,047,031,020,200
;   ;                                               
;  db 080,170,089,065,067,168,075,079,119,093,138,137,107,187,068,076
;   ;                                               
;  db 090,116,115,133,135,118,117,152,151,136,171,161,160,120,043,077
;   ;                                               
;  db 061,105,131,166,070,069,189,188,096,095,000,186,078,155,030,031
;   ;                                               
;  db 240,240,240,240,240,062,066,092,156,240,240,240,240,191,190,240
;   ;                                               
;  db 240,240,240,240,240,240,064,063,240,240,240,240,240,240,240,034
;   ;                                               
;  db 085,086,084,094,083,128,106,108,091,240,240,240,240,163,169,240
;   ;                                               
;  db 132,157,134,126,125,127,154,153,146,167,145,173,182,183,162,012
;   ;                                               
;  db 004,019,023,016,014,032,042,022,017,018,021,172,148,147,240,255
;

;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 852
;
; ---------------------------------------------------------------
;
Latin2_852_ucase label word
 ctable  <,'UCASE  ',128>
  ;                            x
  db 080h,09Ah,090h,0B6h,08Eh,0DEh,08Fh,080h,09Dh,0D3h,08Ah,08Ah,0D7h,08Dh,08Eh,08Fh
  ;              x                  x                              x
  db 090h,091h,092h,0E2h,099h,095h,05Fh,097h,097h,099h,09Ah,09Bh,09Bh,09Dh,09Eh,0ACh
  db 0B5h,092h,0E0h,0E9h,0A4h,0A4h,0A6h,0A6h,0A8h,0A8h,0AAh,08Dh,0ACh,0B8h,0AEh,0AFh
  db 0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BDh,0BFh
  db 0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C6h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
  db 0D1h,0D1h,0D2h,0D3h,0D2h,0D5h,0D6h,0D7h,0B7h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
  db 0E0h,0E1h,0E2h,0E3h,0E3h,0D5h,0E6h,0E6h,0E8h,0E9h,0E8h,0EBh,0EDh,0EDh,0DDh,0EFh
  db 0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0EBh,0FCh,0FCh,0FEh,0FFh

;
;       World Trade Mono Case Filename Character Tables
;
;
; ----------------------------------------------------------------------------
CP852_ucfile label word
 ctable  <,'FUCASE ',128>
		      ;  View this table in CP852
    ;                                               
  db  "","","","","","","","","","","","","","","",""
    ;                                                   
  db  "","","","","","","","","","","","","","","",""
    ;                                               
  db  "","","","","","","","","","","","","","","",""
    ;                                               
  db  176,177,178,179,180,"","","","",185,186,187,188,"","",191
    ;                                               
  db  192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
    ;                                               
  db  "","","","","","","","","",217,218,219,220,"","",223
    ;                                               
  db  "","","","","","","","","","","","","","","",""
    ;                                               
  db  "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\country.asm ===
;
;       create country.sys file
;
;
	include mkcntry.inc
;
; -----------------------------------------------------------
;
;       Data for COUNTRY.SYS file
;
; -----------------------------------------------------------
dseg    segment para
cdinfo  label   word
	db      0ffh,'COUNTRY'          ; signature
	db      8 dup (0)               ; reserved
	dw      PTRCNT                  ; number of pointers in header
	db      CIPTYPE                 ; type = country info pointer
	dd      offset cntryinfo        ; pointer to country information
;
cntryinfo label word
cntrycnt=0
	dw      finalCNT                ; number of countries

 ctryent <CENTRYSIZE,CID_AL,852,,,al852_data>   ; Albania
 ctryent <CENTRYSIZE,CID_AL,850,,,al850_data>   ;

 ctryent <CENTRYSIZE,CID_AR,850,,,ar850_data>   ; Argentina
 ctryent <CENTRYSIZE,CID_AR,437,,,ar437_data>   ;

 ctryent <CENTRYSIZE,CID_AU,437,,,au437_data>   ; Australia
 ctryent <CENTRYSIZE,CID_AU,850,,,au850_data>   ;

 ctryent <CENTRYSIZE,CID_AT,850,,,at850_data>   ; Austria
 ctryent <CENTRYSIZE,CID_AT,437,,,at437_data>   ;

 ctryent <CENTRYSIZE,CID_BE,850,,,be850_data>   ; Belgium
 ctryent <CENTRYSIZE,CID_BE,437,,,be437_data>   ;

 ctryent <CENTRYSIZE,CID_BH,852,,,bh852_data>   ; Bosnia/Herzegovina
 ctryent <CENTRYSIZE,CID_BH,850,,,bh850_data>   ;

 ctryent <CENTRYSIZE,CID_BR,850,,,br850_data>   ; Brazil
 ctryent <CENTRYSIZE,CID_BR,437,,,br437_data>   ;

 ctryent <CENTRYSIZE,CID_BG,855,,,bg855_data>   ; Bulgaria IBM Country Code
 ctryent <CENTRYSIZE,CID_BG,850,,,bg850_data>   ;

 ctryent <CENTRYSIZE,CID_BGI,855,,,bgi855_data> ; Bulgaria Real Country Code
 ctryent <CENTRYSIZE,CID_BGI,850,,,bgi850_data> ;

 ctryent <CENTRYSIZE,CID_CA,850,,,ca850_data>   ; Canada French
 ctryent <CENTRYSIZE,CID_CA,863,,,ca863_data>   ; 

 ctryent <CENTRYSIZE,CID_CAE,850,,,cae850_data> ; Canada English
 ctryent <CENTRYSIZE,CID_CAE,863,,,cae863_data> ; 

 ctryent <CENTRYSIZE,CID_CL,850,,,cl850_data>   ; Chile
 ctryent <CENTRYSIZE,CID_CL,437,,,cl437_data>   ;

 ctryent <CENTRYSIZE,CID_CO,850,,,co850_data>   ; Colombia
 ctryent <CENTRYSIZE,CID_CO,437,,,co437_data>   ;

 ctryent <CENTRYSIZE,CID_CRO,852,,,cro852_data> ; Croatia
 ctryent <CENTRYSIZE,CID_CRO,850,,,cro850_data> ;

 ctryent <CENTRYSIZE,CID_CS,852,,,cs852_data>   ; Czech Republic
 ctryent <CENTRYSIZE,CID_CS,850,,,cs850_data>   ;

 ctryent <CENTRYSIZE,CID_EC,850,,,ec850_data>   ; Ecuador
 ctryent <CENTRYSIZE,CID_EC,437,,,ec437_data>   ;

 ctryent <CENTRYSIZE,CID_DK,850,,,dk850_data>   ; Denmark
 ctryent <CENTRYSIZE,CID_DK,865,,,dk865_data>   ;

 ctryent <CENTRYSIZE,CID_FI,850,,,fi850_data>   ; Finland 
 ctryent <CENTRYSIZE,CID_FI,437,,,fi437_data>   ;

 ctryent <CENTRYSIZE,CID_FR,850,,,fr850_data>   ; France
 ctryent <CENTRYSIZE,CID_FR,437,,,fr437_data>   ; 

 ctryent <CENTRYSIZE,CID_GR,850,,,gr850_data>   ; Germany
 ctryent <CENTRYSIZE,CID_GR,437,,,gr437_data>   ; 

 ctryent <CENTRYSIZE,CID_GK,869,,,gk869_data>   ; Greece
 ctryent <CENTRYSIZE,CID_GK,737,,,gk737_data>   ; 
 ctryent <CENTRYSIZE,CID_GK,850,,,gk850_data>   ;

 ctryent <CENTRYSIZE,CID_HK,437,,,hk437_data>   ; Hong Kong SAR

 ctryent <CENTRYSIZE,CID_HU,852,,,hu852_data>   ; Hungary
 ctryent <CENTRYSIZE,CID_HU,850,,,hu850_data>   ;

 ctryent <CENTRYSIZE,CID_IC,850,,,ic850_data>   ; Iceland
 ctryent <CENTRYSIZE,CID_IC,861,,,ic861_data>   ; 

 ctryent <CENTRYSIZE,CID_IN,437,,,in437_data>   ; Indea

 ctryent <CENTRYSIZE,CID_AFE,437,,,afe437_data> ; International English
 ctryent <CENTRYSIZE,CID_AFE,850,,,afe850_data> ;

 ctryent <CENTRYSIZE,CID_IT,850,,,it850_data>   ; Italy
 ctryent <CENTRYSIZE,CID_IT,437,,,it437_data>   ; 

 ctryent <CENTRYSIZE,CID_IE,850,,,ie850_data>   ; Ireland
 ctryent <CENTRYSIZE,CID_IE,437,,,ie437_data>   ;

 ctryent <CENTRYSIZE,CID_LA,850,,,la850_data>   ; Latin America
 ctryent <CENTRYSIZE,CID_LA,437,,,la437_data>   ;

 ctryent <CENTRYSIZE,CID_MAC,855,,,mac855_data> ; FYRO Macedonia
 ctryent <CENTRYSIZE,CID_MAC,850,,,mac850_data> ;

 ctryent <CENTRYSIZE,CID_MY,437,,,my437_data>   ; Malaysia

 ctryent <CENTRYSIZE,CID_MX,850,,,mx850_data>   ; Mexico
 ctryent <CENTRYSIZE,CID_MX,437,,,mx437_data>   ;

 ctryent <CENTRYSIZE,CID_NL,850,,,nl850_data>   ; Netherlands
 ctryent <CENTRYSIZE,CID_NL,437,,,nl437_data>   ; 

 ctryent <CENTRYSIZE,CID_NZ,437,,,nz437_data>   ; New Zealand
 ctryent <CENTRYSIZE,CID_NZ,850,,,nz850_data>   ;

 ctryent <CENTRYSIZE,CID_NO,850,,,no850_data>   ; Norway
 ctryent <CENTRYSIZE,CID_NO,865,,,no865_data>   ;

 ctryent <CENTRYSIZE,CID_PL,852,,,pl852_data>   ; Poland
 ctryent <CENTRYSIZE,CID_PL,850,,,pl850_data>   ;

 ctryent <CENTRYSIZE,CID_PO,850,,,po850_data>   ; Portugal
 ctryent <CENTRYSIZE,CID_PO,860,,,po860_data>   ;

 ctryent <CENTRYSIZE,CID_RO,852,,,ro852_data>   ; Romania
 ctryent <CENTRYSIZE,CID_RO,850,,,ro850_data>   ;

 ctryent <CENTRYSIZE,CID_RU,866,,,ru866_data>   ; Russia
 ctryent <CENTRYSIZE,CID_RU,437,,,ru437_data>   ; 
 ctryent <CENTRYSIZE,CID_RU,850,,,ru850_data>   ; 
 ctryent <CENTRYSIZE,CID_RU,855,,,ru855_data>   ; 
 ctryent <CENTRYSIZE,CID_RU,852,,,ru852_data>   ;

 ctryent <CENTRYSIZE,CID_SM,855,,,sm855_data>   ; Serbia/Montenegro
 ctryent <CENTRYSIZE,CID_SM,850,,,sm850_data>   ;

 ctryent <CENTRYSIZE,CID_SG,437,,,sg437_data>   ; Singapore

 ctryent <CENTRYSIZE,CID_SL,852,,,sl852_data>   ; Slovakia
 ctryent <CENTRYSIZE,CID_SL,850,,,sl850_data>   ;

 ctryent <CENTRYSIZE,CID_SLN,852,,,sln852_data> ; Slovenia
 ctryent <CENTRYSIZE,CID_SLN,850,,,sln850_data> ;

 ctryent <CENTRYSIZE,CID_ZA,437,,,za437_data>   ; South Africa
 ctryent <CENTRYSIZE,CID_ZA,850,,,za850_data>   ;

 ctryent <CENTRYSIZE,CID_SP,850,,,sp850_data>   ; Spain
 ctryent <CENTRYSIZE,CID_SP,437,,,sp437_data>   ;

 ctryent <CENTRYSIZE,CID_SV,850,,,sv850_data>   ; Sweden
 ctryent <CENTRYSIZE,CID_SV,437,,,sv437_data>   ; 

 ctryent <CENTRYSIZE,CID_SW,850,,,sw850_data>   ; Switzerland
 ctryent <CENTRYSIZE,CID_SW,437,,,sw437_data>   ;

 ctryent <CENTRYSIZE,CID_TR,857,,,tr857_data>   ; Turkey
 ctryent <CENTRYSIZE,CID_TR,850,,,tr850_data>   ; 

 ctryent <CENTRYSIZE,CID_UK,850,,,uk850_data>   ; United Kingdom
 ctryent <CENTRYSIZE,CID_UK,437,,,uk437_data>   ; 

 ctryent <CENTRYSIZE,CID_US,437,,,us437_data>   ; United States
 ctryent <CENTRYSIZE,CID_US,850,,,us850_data>   ;

 ctryent <CENTRYSIZE,CID_VE,850,,,ve850_data>   ; Venezuela
 ctryent <CENTRYSIZE,CID_VE,437,,,ve437_data>   ;

 ctryent <CENTRYSIZE,CID_YU,852,,,yu852_data>   ; Yugoslavia
 ctryent <CENTRYSIZE,CID_YU,850,,,yu850_data>   ;
 ctryent <CENTRYSIZE,CID_YC,855,,,yc855_data>   ; Yugoslavia Cyrillic

 ctryent <CENTRYSIZE,CID_IS,850,,,is850_data>   ; Israel
 ctryent <CENTRYSIZE,CID_IS,862,,,is862_data>   ; 

 ctryent <CENTRYSIZE,CID_AS,850,,,as850_data>   ; Area South (Arab States)
 ctryent <CENTRYSIZE,CID_AS,864,,,as864_data>   ; 

 ctryent <CENTRYSIZE,CID_JP,437,,,jp437_data>   ; Japan
 ctryent <CENTRYSIZE,CID_JP,932,,,jp932_data>   ; 

 ctryent <CENTRYSIZE,CID_KO,949,,,ko949_data>   ; Korea Windows
 ctryent <CENTRYSIZE,CID_KO,437,,,ko437_data>   ; Korea
 ctryent <CENTRYSIZE,CID_KO,1361,,,ko1361_data>   ; 

 ctryent <CENTRYSIZE,CID_PR,936,,,pr936_data>   ; PRC
 ctryent <CENTRYSIZE,CID_PR,437,,,pr437_data>   ; 

 ctryent <CENTRYSIZE,CID_TA,950,,,ta938_data>   ; Taiwan Windows
 ctryent <CENTRYSIZE,CID_TA,437,,,ta437_data>   ; Taiwan Old MS-DOS Code
 ctryent <CENTRYSIZE,CID_TA,938,,,ta938_data>   ; 
 ctryent <CENTRYSIZE,CID_TAI,950,,,tai938_data> ; Taiwan Real Country Code
 ctryent <CENTRYSIZE,CID_TAI,437,,,tai437_data> ; 
 ctryent <CENTRYSIZE,CID_TAI,938,,,tai938_data> ; 

 ctryent <CENTRYSIZE,CID_ISO,437,,,iso437_data> ; Work around an NLSFUNC.EXE
 ctryent <CENTRYSIZE,CID_ISO,737,,,iso437_data> ;  bug entry.  USA with
 ctryent <CENTRYSIZE,CID_ISO,850,,,iso850_data> ;  ISO 8601 Date format.
 ctryent <CENTRYSIZE,CID_ISO,852,,,iso850_data> ; 
 ctryent <CENTRYSIZE,CID_ISO,855,,,iso850_data> ;
 ctryent <CENTRYSIZE,CID_ISO,857,,,iso850_data> ;


dummy   macro   p
finalCNT        equ     p
	endm
	dummy   %cntrycnt


al852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,al852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

al850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,al850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


as864_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,as864_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Arabic_864_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

as850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,as850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ar850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ar850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ar437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ar437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


au437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,au437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

au850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,au850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


at850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,at850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,German_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,German_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

at437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,at437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


be850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,be850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Belgian_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

be437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,be437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Belgian_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


bh852_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bh852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

bh850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bh850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


br850_data label   word
  dw    CDATAITEMS                    ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,br850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Brazilian_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

br437_data label   word
  dw    CDATAITEMS                    ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,br437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


bg855_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bg855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

bg850_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bg850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

bgi855_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bgi855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

bgi850_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bgi850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ca850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ca850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ca863_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ca863_info>
  ctrydat <CDATASIZE,SETCOLLATE,,FrnCdn_863_collate>
  ctrydat <CDATASIZE,SETUCASE,,FrnCdn_863_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,FrnCdn_863_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


cae850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cae850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

cae863_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cae863_info>
  ctrydat <CDATASIZE,SETCOLLATE,,FrnCdn_863_collate>
  ctrydat <CDATASIZE,SETUCASE,,FrnCdn_863_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,FrnCdn_863_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


cl850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cl850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

cl437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cl437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


co850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,co850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

co437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,co437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


cro852_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cro852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

cro850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cro850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


cs852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cs852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

cs850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cs850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


dk850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,dk850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Danish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Nordic_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Nordic_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

dk865_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,dk865_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Danish_865_collate>
  ctrydat <CDATASIZE,SETUCASE,,Nordic_865_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Nordic_865_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ec850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ec850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ec437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ec437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


fi850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,fi850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Finnish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

fi437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,fi437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Swed_Fin_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


fr850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,fr850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

fr437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,fr437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


gr850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,gr850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,German_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,German_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

gr437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,gr437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


gk869_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,gk869_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Greek_869_collate>
  ctrydat <CDATASIZE,SETUCASE,,Greek_869_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Greek_869_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

gk737_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,gk737_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Greek_737_collate>  
  ctrydat <CDATASIZE,SETUCASE,,Greek_737_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Greek_737_ucase>   
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

gk850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,gk850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


hk437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,hk437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


hu852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,hu852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

hu850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,hu850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ic850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ic850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ic861_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ic861_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Icelandic_861_collate>
  ctrydat <CDATASIZE,SETUCASE,,Icelandic_861_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Icelandic_861_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


afe437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,afe437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

afe850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,afe850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ie850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ie850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ie437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ie437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


in437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,in437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


is862_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,is862_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Hebrew_862_collate>
  ctrydat <CDATASIZE,SETUCASE,,Hebrew_862_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Hebrew_862_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

is850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,is850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


it850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,it850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

it437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,it437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


jp932_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,jp932_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Japan_932_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,jp932_dbcs>

jp437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,jp437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ko949_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ko949_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Korea_949_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,ko949_dbcs>


ko1361_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ko1361_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Korea_949_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,ko1361_dbcs>


ko437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ko437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


la850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,la850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

la437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,la437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


mac855_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,mac855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

mac850_data label   word
  dw     CDATAITEMS                               ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,mac850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


my437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,my437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


mx850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,mx850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

mx437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,mx437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


nl850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,nl850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Dutch_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Dutch_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Dutch_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

nl437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,nl437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Dutch_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Dutch_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Dutch_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


nz437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,nz437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

nz850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,nz850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


no850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,no850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Norwegian_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Nordic_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Nordic_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

no865_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,no865_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Norwegian_865_collate>
  ctrydat <CDATASIZE,SETUCASE,,Nordic_865_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Nordic_865_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


pr936_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,pr936_info>
  ctrydat <CDATASIZE,SETCOLLATE,,PRC_936_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,pr936_dbcs>


pr437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,pr437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


pl852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,pl852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

pl850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,pl850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


po850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,po850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

po860_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,po860_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Portuguese_860_collate>
  ctrydat <CDATASIZE,SETUCASE,,Portuguese_860_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Portuguese_860_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ro852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ro852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ro850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ro850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ru866_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ru866_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Russian_866_collate>
  ctrydat <CDATASIZE,SETUCASE,,Russian_866_ucase>
  ctrydat <CDATASIZE,SETLCASE,,ru866_lcase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Russian_866_ucase>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ru437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ru437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ru850_data label   word
  dw      CDATAITEMS                             ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ru850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ru855_data label   word
  dw      CDATAITEMS                             ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ru855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ru852_data label   word
  dw      CDATAITEMS                             ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ru852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sm855_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sm855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sm850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sm850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sg437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sg437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sl852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sl852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sl850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sl850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sln852_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sln852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sln850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sln850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


za437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,za437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

za850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,za850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sp850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sp850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sp437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sp437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sv850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sv850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Swedish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sv437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sv437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Swed_Fin_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sw850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sw850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Swiss_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swiss_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swiss_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sw437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sw437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Swiss_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swiss_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swiss_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ta938_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ta938_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Taiwan_938_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,ta938_dbcs>

ta437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ta437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


tai938_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,tai938_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Taiwan_938_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,ta938_dbcs>

tai437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,tai437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


tr857_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,tr857_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Turkish_857_collate>
  ctrydat <CDATASIZE,SETUCASE,,Turkish_857_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Turkish_857_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

tr850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,tr850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Turkish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Turkish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Turkish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


uk850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,uk850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

uk437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,uk437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


us437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,us437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

us850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,us850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ve850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ve850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ve437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ve437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


yu852_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,yu852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

yu850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,yu850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

yc855_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,yc855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


iso437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,iso437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

iso850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,iso850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>



; ----------------------------------------
;                                                       
;       World Trade Country Info Tables
;
; ----------------------------------------

;================================================

al852_info   label   word   ;CP852 Albania
   ctable  <>
   cinfo   <CID_AL,852,YMD,'L','e','k',000,0,'.',0,',',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

al850_info   label   word   ;CP850 Albania
   ctable  <>
   cinfo   <CID_AL,850,YMD,'L','e','k',000,0,'.',0,',',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

as864_info   label   word   ;CP864 Area South (Arabic)
   ctable  <>
   cinfo   <CID_AS,864,DMY,164,000,000,000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,3,HR12,0,';'>

as850_info   label   word   ;CP850 Area South (Arabic)
   ctable  <>
   cinfo   <CID_AS,864,DMY,'',000,000,000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,3,HR12,0,';'>

;================================================

ar850_info   label   word   ;CP850 Argentina
   ctable  <>
   cinfo   <CID_AR,850,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,'.',0,CurrAmount,2,HR24,0,','> 

ar437_info   label   word   ;CP437 Argentina
   ctable  <>
   cinfo   <CID_AR,437,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,'.',0,CurrAmount,2,HR24,0,','> 

;================================================

au437_info   label   word   ;CP437 Australia
   ctable  <>
   cinfo   <CID_AU,437,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

au850_info   label   word   ;CP850 Australia
   ctable  <>
   cinfo   <CID_AU,850,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

at850_info   label   word   ;CP850 Austria
   ctable  <>
   cinfo   <CID_AT,850,DMY,'S',000,000,000,0,'.',0,',',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'> 

at437_info   label   word   ;CP437 Austria
   ctable  <>
   cinfo   <CID_AT,437,DMY,'S',000,000,000,0,'.',0,',',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'> 

;================================================

be850_info   label   word   ;CP850 Belgium
   ctable  <>
   cinfo   <CID_BE,850,DMY,'B','F',000,000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,2,HR24,0,';'>      

be437_info   label   word   ;CP437 Belgium
   ctable  <>
   cinfo   <CID_BE,437,DMY,'B','F',000,000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,2,HR24,0,';'>      

;================================================

bh852_info   label   word   ;CP852 Bosnia/Herzegovina
   ctable  <>
   cinfo   <CID_BH,852,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

bh850_info   label   word   ;CP850 Bosnia/Herzegovina
   ctable  <>
   cinfo   <CID_BH,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

br850_info   label   word   ;CP850 Brazil
   ctable  <>
   cinfo   <CID_BR,850,DMY,'C','r','$',000,0,'.',0,',',0,'/',0,':',0,Cur_Amount,2,HR24,0,';'>

br437_info   label   word   ;CP437 Brazil
   ctable  <>
   cinfo   <CID_BR,437,DMY,'C','r','$',000,0,'.',0,',',0,'/',0,':',0,Cur_Amount,2,HR24,0,';'>

;================================================

bg855_info   label   word   ;CP855 Bulgaria  IBM Country Code
   ctable  <>
   cinfo   <CID_BG,855,DMY,'','','.',000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

bg850_info   label   word   ;CP850 Bulgaria  IBM Country Code
   ctable  <>
   cinfo   <CID_BG,850,DMY,'L','v',000,000,0,' ',0,',',0,'.',0,'.',0,CurrAmount,2,HR24,0,';'>

bgi855_info  label   word   ;CP855 Bulgaria  Real Country Code
   ctable  <>
   cinfo  <CID_BGI,855,DMY,'','','.',000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

bgi850_info  label   word   ;CP850 Bulgaria  Real Country Code
   ctable  <>
   cinfo  <CID_BGI,850,DMY,'L','v',000,000,0,' ',0,',',0,'.',0,'.',0,CurrAmount,2,HR24,0,';'>

;================================================

ca850_info   label   word   ;CP850 French Canadian
   ctable  <>
   cinfo   <CID_CA,850,YMD,'$',000,000,000,0,' ',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>

ca863_info   label   word   ;CP863 French Canadian
   ctable  <>
   cinfo   <CID_CA,863,YMD,'$',000,000,000,0,' ',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>

;================================================

cae850_info  label   word   ;CP850 English Canadian
   ctable  <>
   cinfo  <CID_CAE,850,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

cae863_info  label   word   ;CP863 English Canadian
   ctable  <>
   cinfo  <CID_CAE,863,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

cl850_info   label   word   ;CP850 Chile
   ctable  <>
   cinfo   <CID_CL,850,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,','> 

cl437_info   label   word   ;CP437 Chile
   ctable  <>
   cinfo   <CID_CL,437,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,','> 

;================================================

; Columbia
co850_info   label   word   ;CP850 Columbia
   ctable  <>
   cinfo   <CID_CO,850,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

co437_info   label   word   ;CP437 Columbia
   ctable  <>
   cinfo   <CID_CO,437,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

;================================================

cro852_info  label   word   ;CP852 Croatia
   ctable  <>
   cinfo  <CID_CRO,852,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

cro850_info  label   word   ;CP850 Croatia
   ctable  <>
   cinfo  <CID_CRO,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

cs852_info   label   word   ;CP852 Czech Republic
   ctable  <>
   cinfo   <CID_CS,852,DMY,'K','',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,','>

cs850_info   label   word   ;CP850 Czech Republic
   ctable  <>
   cinfo   <CID_CS,850,DMY,'K','c',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,','>

;================================================

dk850_info   label   word   ;CP850 Denmark
   ctable  <>
   cinfo   <CID_DK,850,DMY,'k','r',000,000,0,'.',0,',',0,'-',0,'.',0,Cur_Amount,2,HR24,0,';'>

dk865_info   label   word   ;CP865 Denmark
   ctable  <>
   cinfo   <CID_DK,865,DMY,'k','r',000,000,0,'.',0,',',0,'-',0,'.',0,Cur_Amount,2,HR24,0,';'>

;================================================

ec850_info   label   word   ;CP850 Ecuador
   ctable  <>
   cinfo   <CID_EC,850,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,','> 

ec437_info   label   word   ;CP437 Ecuador
   ctable  <>
   cinfo   <CID_EC,437,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,','> 


;================================================

fi850_info   label   word   ;CP850 Finland
   ctable  <>
   cinfo   <CID_FI,437,DMY,'m','k',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

fi437_info   label   word   ;CP437
   ctable  <>
   cinfo   <CID_FI,437,DMY,'m','k',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

;================================================

fr850_info   label   word   ;CP850 France
   ctable  <>
   cinfo   <CID_FR,850,DMY,'F',000,000,000,0,' ',0,',',0,'/',0,':',0,Amount_Cur,2,HR24,0,';'> 

fr437_info   label   word   ;CP437 France
   ctable  <>
   cinfo   <CID_FR,437,DMY,'F',000,000,000,0,' ',0,',',0,'/',0,':',0,Amount_Cur,2,HR24,0,';'> 

;================================================

gr850_info   label   word   ;CP850 Germany
   ctable  <>
   cinfo   <CID_GR,850,DMY,'D','M',000,000,0,'.',0,',',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'> 

gr437_info   label   word   ;CP437 Germany
   ctable  <>
   cinfo   <CID_GR,437,DMY,'D','M',000,000,0,'.',0,',',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'> 

;================================================

gk869_info   label   word   ;CP869 Greece
   ctable  <>
   cinfo   <CID_GK,869,DMY,'','','',000,0,'.',0,',',0,'/',0,':',0,AmountCurr,2,HR12,0,','>

gk737_info   label   word   ;CP737 Greece
   ctable  <>
   cinfo   <CID_GK,737,DMY,'','','',000,0,'.',0,',',0,'/',0,':',0,AmountCurr,2,HR12,0,','>

gk852_info   label   word   ;CP852 Greece
   ctable  <>
   cinfo   <CID_GK,852,DMY,'D','r','s',000,0,'.',0,',',0,'/',0,':',0,AmountCurr,2,HR12,0,','>

gk850_info   label   word   ;CP850 Greece
   ctable  <>
   cinfo   <CID_GK,850,DMY,'D','r','s',000,0,'.',0,',',0,'/',0,':',0,AmountCurr,2,HR12,0,','>

;================================================

hk437_info   label   word   ;CP437 Hong Kong SAR
   ctable  <>
   cinfo   <CID_HK,437,DMY,'H','K','$',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

;================================================

hu852_info   label   word   ;CP852 Hungary
   ctable  <>
   cinfo   <CID_HU,852,YMD,'F','t',000,000,0,' ',0,',',0,'.',0,'.',0,CurrAmount,2,HR24,0,';'>

hu850_info   label   word   ;CP850 Hungary
   ctable  <>
   cinfo   <CID_HU,850,YMD,'F','t',000,000,0,' ',0,',',0,'.',0,'.',0,CurrAmount,2,HR24,0,';'>

;================================================

ic861_info   label   word   ;CP861 Iceland
   ctable  <>
   cinfo   <CID_IC,861,YMD,'','K','r',000,0,' ',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>

ic850_info   label   word   ;CP850 Iceland
   ctable  <>
   cinfo   <CID_IC,850,YMD,'k','r',000,000,0,' ',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>

;================================================

in437_info   label   word   ;CP437 Indea
   ctable  <>
   cinfo   <CID_IN,437,DMY,'R','s',000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

;================================================

afe437_info  label   word   ;CP437 International English
   ctable  <>
   cinfo  <CID_AFE,437,DMY,'$',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,2,HR12,0,','>

afe850_info  label   word   ;CP850 International English
   ctable  <>
   cinfo  <CID_AFE,850,DMY,'$',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,2,HR12,0,','>

;================================================

ie850_info   label   word   ;CP850 Ireland
   ctable  <>
   cinfo   <CID_IE,850,DMY,'I','R','',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

ie437_info   label   word   ;CP437 Ireland
   ctable  <>
   cinfo   <CID_IE,437,DMY,'I','R','',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

;================================================

is862_info   label   word   ;CP862 Israel
   ctable  <>
   cinfo   <CID_IS,862,DMY,153,000,000,000,0,',',0,'.',0,'/',0,':',0,Cur_Amount,2,HR24,0,','>

is850_info   label   word   ;CP850 Israel
   ctable  <>
   cinfo   <CID_IS,850,DMY,'N','I','S',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

it850_info   label   word   ;CP850 Italy
   ctable  <>
   cinfo   <CID_IT,850,DMY,'L','.',000,000,0,'.',0,',',0,'/',0,'.',0,Cur_Amount,0,HR24,0,';'>       

it437_info   label   word   ;CP437 Italy
   ctable  <>
   cinfo   <CID_IT,437,DMY,'L','.',000,000,0,'.',0,',',0,'/',0,'.',0,Cur_Amount,0,HR24,0,';'>       

;================================================

jp932_info   label   word   ;CP932 Japan
   ctable  <>
   cinfo   <CID_JP,932,YMD,'\',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,0,HR24,0,','>

jp437_info   label   word   ;CP437 Japan
   ctable  <>
   cinfo   <CID_JP,437,MDY,'$',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,2,HR12,0,','>

;================================================

ko949_info   label   word   ;CP949 Korea
   ctable  <>
   cinfo   <CID_KO,949,YMD,'\',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,0,HR24,0,','>  

ko1361_info   label   word   ;CP1361 Korea
   ctable  <>
   cinfo   <CID_KO,1361,YMD,'\',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,0,HR24,0,','>  

ko437_info   label   word   ;CP437 Korea
   ctable  <>
   cinfo   <CID_KO,437,MDY,'$',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,2,HR12,0,','>

;================================================

la850_info   label   word   ;CP850 Latin America
   ctable  <>
   cinfo   <CID_LA,850,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

la437_info   label   word   ;CP437 Latin America
   ctable  <>
   cinfo   <CID_LA,437,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

;================================================

mac855_info  label   word   ;CP855 FYRO Macedonia
   ctable  <>
   cinfo  <CID_MAC,855,YMD,'','','',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

mac850_info  label   word   ;CP850 FYRO Macedonia
   ctable  <>
   cinfo  <CID_MAC,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

my437_info   label   word   ;CP437 Malaysia
   ctable  <>
   cinfo   <CID_MY,437,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>  

;================================================

mx850_info   label   word   ;CP850 Mexico
   ctable  <>
   cinfo   <CID_MX,850,DMY,'N','$',000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

mx437_info   label   word   ;CP437 Mexico
   ctable  <>
   cinfo   <CID_MX,437,DMY,'N','$',000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

;================================================

nl850_info   label   word   ;CP850 Netherlands
   ctable  <>
   cinfo   <CID_NL,850,DMY,'',000,000,000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,';'>

nl437_info   label   word   ;CP437 Netherlands
   ctable  <>
   cinfo   <CID_NL,437,DMY,'',000,000,000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,';'>

;================================================

nz437_info   label   word   ;CP437 New Zealand
   ctable  <>
   cinfo   <CID_NZ,437,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

nz850_info   label   word   ;CP850 New Zealand
   ctable  <>
   cinfo   <CID_NZ,850,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

no850_info   label   word   ;CP850 Norway
   ctable  <>
   cinfo   <CID_NO,850,DMY,'k','r',000,000,0,' ',0,',',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'>

no865_info   label   word   ;CP865 Norway
   ctable  <>
   cinfo   <CID_NO,865,DMY,'k','r',000,000,0,' ',0,',',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'> 

;================================================

pr936_info   label   word   ;CP936 People's Republic of China
   ctable  <>
   cinfo   <CID_PR,936,YMD,'\',000,000,000,0,',',0,'.',0,'.',0,':',0,CurrAmount,2,HR12,0,','>

pr437_info   label   word   ;CP437 People's Republic of China
   ctable  <>
   cinfo   <CID_PR,437,YMD,'$',000,000,000,0,',',0,'.',0,'.',0,':',0,CurrAmount,2,HR12,0,','>

;================================================

pl852_info   label   word   ;CP852 Poland 
   ctable  <>
   cinfo   <CID_PL,852,YMD,'Z','',000,000,0,' ',0,',',0,'.',0,':',0,CurrAmount,2,HR24,0,';'>

pl850_info   label   word   ;CP850 Poland 
   ctable  <>
   cinfo   <CID_PL,850,YMD,'Z','l',000,000,0,' ',0,',',0,'.',0,':',0,CurrAmount,2,HR24,0,';'>

;================================================

po850_info   label   word   ;CP850 Portugal
   ctable  <>
   cinfo   <CID_PO,850,DMY,'E','s','c','.',0,'.',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>        

po860_info   label   word   ;CP860 Portugal
   ctable  <>
   cinfo   <CID_PO,860,DMY,'E','s','c','.',0,'.',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>        

;================================================

ro852_info   label   word   ;CP852 Romania
   ctable  <>
   cinfo   <CID_RO,852,YMD,'L','e','i',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

ro850_info   label   word   ;CP850 Romania
   ctable  <>
   cinfo   <CID_RO,850,YMD,'L','e','i',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

ru866_info   label   word   ;CP866 Russia
   ctable  <>
   cinfo   <CID_RU,866,DMY,'','.',000,000,0,' ',0,'.',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'>

ru437_info   label   word   ;CP437 Russia
   ctable  <>
   cinfo   <CID_RU,437,DMY,'r','.',000,000,0,' ',0,'.',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'>

ru850_info   label   word   ;CP850 Russia
   ctable  <>
   cinfo   <CID_RU,850,DMY,'r','.',000,000,0,' ',0,'.',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'>

ru855_info   label   word   ;CP855 Russia
   ctable  <>
   cinfo   <CID_RU,855,DMY,'','.',000,000,0,' ',0,'.',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'>

ru852_info   label   word   ;CP852 Russia
   ctable  <>
   cinfo   <CID_RU,852,DMY,'r','.',000,000,0,' ',0,'.',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'>

;================================================

sm855_info   label   word   ;CP855 Serbia/Montenegro
   ctable  <>
   cinfo   <CID_SM,855,YMD,'','','',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

sm850_info   label   word   ;CP850 Serbia/Montenegro
   ctable  <>
   cinfo   <CID_SM,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

sg437_info   label   word   ;CP437 Singapore
   ctable  <>
   cinfo   <CID_SG,437,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>  

;================================================

sl852_info   label   word   ;CP852 Slovakia
   ctable  <>
   cinfo   <CID_SL,852,DMY,'S','k',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

sl850_info   label   word   ;CP850 Slovakia
   ctable  <>
   cinfo   <CID_SL,850,DMY,'S','k',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

;================================================

sln852_info  label   word   ;CP852 Slovenia
   ctable  <>
   cinfo  <CID_SLN,852,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

sln850_info  label   word   ;CP850 Slovenia
   ctable  <>
   cinfo  <CID_SLN,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

za437_info   label   word   ;CP437 South Africa
   ctable  <>
   cinfo   <CID_ZA,437,YMD,'R',000,000,000,0,' ',0,',',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

za850_info   label   word   ;CP850 South Africa
   ctable  <>
   cinfo   <CID_ZA,850,YMD,'R',000,000,000,0,' ',0,',',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

sp850_info   label   word   ;CP850 Spain
   ctable  <>
   cinfo   <CID_SP,437,DMY,'P','t','s',000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,0,HR24,0,';'>   

sp437_info   label   word   ;CP437 Spain
   ctable  <>
   cinfo   <CID_SP,437,DMY,'',000,000,000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,0,HR24,0,';'> 

;================================================

sv850_info   label   word   ;CP850 Sweden
   ctable  <>
   cinfo   <CID_SV,850,YMD,'k','r',000,000,0,' ',0,',',0,'-',0,'.',0,Amount_Cur,2,HR24,0,';'>      

sv437_info   label   word   ;CP437 Sweden
   ctable  <>
   cinfo   <CID_SV,437,YMD,'k','r',000,000,0,' ',0,',',0,'-',0,'.',0,Amount_Cur,2,HR24,0,';'>      

;================================================

sw850_info   label   word   ;CP850 Switzerland
   ctable  <>
   cinfo   <CID_SW,850,DMY,'S','F','r','.',0,"'",0,'.',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'> 

sw437_info   label   word   ;CP437 Switzerland
   ctable  <>
   cinfo   <CID_SW,437,DMY,'S','F','r','.',0,"'",0,'.',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'> 

;================================================

ta938_info   label   word   ;CP938 Taiwan
   ctable  <>
   cinfo  <CID_TA,938,YMD,'N','T','$',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>

ta437_info   label   word   ;CP437 Taiwan
   ctable  <>
   cinfo  <CID_TA,437,YMD,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>    

tai938_info  label   word   ;CP938 Taiwan with Real Country/Region Code
   ctable  <>
   cinfo   <CID_TAI,938,YMD,'N','T','$',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>

tai437_info  label   word   ;CP437 Taiwan with Country/Region Code
   ctable  <>
   cinfo   <CID_TAI,437,YMD,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>    

;================================================

tr850_info   label   word   ;CP852 Turkey
   ctable  <>
   cinfo   <CID_TR,850,DMY,'T','L',000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,';'>

tr857_info   label   word   ;CP852 Turkey
   ctable  <>
   cinfo   <CID_TR,857,DMY,'T','L',000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,';'>

;================================================

uk850_info   label   word   ;CP850 United Kingdom
   ctable  <>
   cinfo   <CID_UK,850,DMY,'',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

uk437_info   label   word   ;CP437 United Kingdom
   ctable  <>
   cinfo   <CID_UK,437,DMY,'',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

;================================================

us437_info   label   word   ;CP437 United States
   ctable  <>
   cinfo   <CID_US,437,MDY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>

us850_info   label   word   ;CP850 United States
   ctable  <>
   cinfo   <CID_US,850,MDY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>

;================================================

ve850_info   label   word   ;CP850 Venezuela
   ctable  <>
   cinfo   <CID_VE,850,DMY,'B','s','.',000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

ve437_info   label   word   ;CP437 Venezuela
   ctable  <>
   cinfo   <CID_VE,437,DMY,'B','s','.',000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

;================================================

yu852_info   label   word   ;CP852 Yugoslavia
   ctable  <>
   cinfo   <CID_YU,852,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

yu850_info   label   word   ;CP850 Yugoslavia
   ctable  <>
   cinfo   <CID_YU,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

yc855_info   label   word   ;CP855 Yugoslavia Cyrillic
   ctable  <>
   cinfo   <CID_YC,855,YMD,'','','',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

iso437_info  label   word   ;CP437 Work around an NLSFUNC.EXE Bug Entry
   ctable  <>
   cinfo  <CID_ISO,437,YMD,'E','A','$',000,0,'.',0,',',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

iso850_info  label   word   ;CP850 Work around an NLSFUNC.EXE Bug Entry
   ctable  <>
   cinfo  <CID_ISO,850,YMD,'J','K','$',000,0,',',0,'.',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

	page

include nls437.inc
include nls737.inc
include nls850.inc
include nls852.inc
include nls855.inc
include nls857.inc
include nls860.inc
include nls861.inc
include nls862.inc
include nls863.inc
include nls864.inc
include nls865.inc
include nls866.inc
include nls869.inc
include nls93x.inc


; ----------------------------------------------------------------------------
;
;       World Trade Valid Filename Character Tables
;
;               Currently all countries have same (4/14/86)
;
;
; ----------------------------------------------------------------------------
Valid_flist label word
		ctable  <,'FCHAR  ',fclend-fclbegin>
fclbegin        label   word
		db      1,0,255                         ; include all
		db      0,0,20h                         ; exclude 0 - 20h
		db      2,14,'."/\[]:|<>+=;,'           ; exclude 14 special chars
fclend          label   word



; ----------------------------------------------------------------------------
;
;       World Trade DBCS Tables
;
;           Currently all countries have same (4/14/86)
;
;
; ----------------------------------------------------------------------------
;                                  
Not_dbcs label word
		ctable  <,'DBCS   ',dbcsterm-dbcsbegin>         ;AN000;
dbcsbegin       label   word                                    ;AN000;
dbcsterm        db      0,0                                     ;AN000;
dbcsend         label   word                                    ;AN000;



include DBCS93x.inc



include copyrigh.inc

; ---------------------------------------------------------------
;
;               END OF CDI SEGMENT
;
; ---------------------------------------------------------------


dseg    ends
	end


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls737.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 737
;
; -----------------------------------------
;
Greek_737_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,015,044,084,072,085,082,043,050,052,079,089,010,009,022,021
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 112,114,115,117,119,120,121,123,124,125,014,012,097,100,103,018
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 069,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 226,228,230,232,234,236,238,240,242,244,246,054,081,055,027,003
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 042,197,199,201,203,205,207,209,211,213,215,217,219,221,223,225
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 227,229,231,233,235,237,239,241,243,245,247,056,105,057,033,063
   ;                                               
  db 126,131,133,135,137,141,143,147,149,156,158,160,162,164,168,170
   ;                                               
  db 172,174,177,179,186,188,190,192,127,132,134,136,138,142,144,148
   ;                                               
  db 150,157,159,161,163,165,167,171,173,175,176,178,180,187,189,191
   ;                                               
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;                                               
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;                                               
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;                                               
  db 193,130,140,146,154,152,169,182,184,195,128,139,145,151,181,168
   ;                                            
  db 194,091,096,102,153,183,080,099,045,036,037,088,248,116,254,255


;
; ---------------------------------------------------------------
;
;      World Trade Case Mappings for Code Page 737
;
; ---------------------------------------------------------------
;
Greek_737_ucase label word
 ctable  <,'UCASE  ',128>

;                                                                 
  db 080h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
;                                                                 
  db 090h,091h,092h,093h,094h,095h,096h,097h,080h,081h,082h,083h,084h,085h,086h,087h
;                                                                 
  db 088h,089h,08ah,08bh,08ch,08dh,08eh,08fh,090h,091h,05fh,092h,093h,094h,095h,096h
;                                                                 
  db 0b0h,0b1h,0b2h,0b3h,0b4h,0b5h,0b6h,0b7h,0b8h,0b9h,0bah,0bbh,0bch,0bdh,0beh,0bfh
;                                                                 
  db 0c0h,0c1h,0c2h,0c3h,0c4h,0c5h,0c6h,0c7h,0c8h,0c9h,0cah,0cbh,0cch,0cdh,0ceh,0cfh
;                                                                 
  db 0d0h,0d1h,0d2h,0d3h,0d4h,0d5h,0d6h,0d7h,0d8h,0d9h,0dah,0dbh,0dch,0ddh,0deh,0dfh
;                                                                 
  db 097h,0eah,05fh,0ech,0f4h,0edh,0eeh,0efh,0f5h,0f0h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
;                                                             
  db 0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls855.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 855
;
; -----------------------------------------
;
Russian_855_collate label word
 ctable  <,'COLLATE',256>
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,008,016,030,025,031,028,015,017,018,026,032,005,004,011,010
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 038,039,040,041,042,043,044,045,046,047,007,006,033,034,035,009
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 024,049,051,053,055,057,059,061,063,065,067,069,071,073,075,077
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 079,081,083,085,087,089,091,093,095,097,099,019,027,020,013,002
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 012,048,050,052,054,056,058,060,062,064,066,068,070,072,074,076
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 078,080,082,084,086,088,090,092,094,096,098,021,036,022,014,172
   ;                                               
  db "H","H","G","G",134,134,135,135,"S","S",139,139,140,140,"J","J"
   ;                                               
  db "L","L","N","N","H","H","K","K",152,152,"C","C",163,163,161,161
   ;                                               
  db 128,128,129,129,155,155,132,132,133,133,153,153,131,131,061,062
   ;                                               
  db 176,177,178,179,180,154,154,138,138,185,186,187,188,141,141,191
   ;                                               
  db 192,193,194,195,196,197,142,142,200,201,202,203,204,205,206,"$"
   ;                                               
  db 143,143,144,144,145,145,146,146,147,217,218,219,220,147,164,223
   ;                                               
  db 164,148,148,149,149,150,150,151,151,136,136,130,130,159,159,"#"
   ;                                               
  db "-",160,160,137,137,157,157,162,162,158,158,156,156,253,254,255


Cyrillic_855_collate label word
 ctable  <,'COLLATE',256>
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,008,016,030,025,031,028,015,017,018,026,032,005,004,011,010
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 038,039,040,041,042,043,044,045,046,047,007,006,033,034,035,009
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 024,049,051,053,055,057,059,061,063,065,067,069,071,073,075,077
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 079,081,083,085,087,089,091,093,095,097,099,019,027,020,013,002
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 012,048,050,052,054,056,058,060,062,064,066,068,070,072,074,076
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 078,080,082,084,086,088,090,092,094,096,098,021,036,022,014,200
   ;                                               
  db 112,113,110,111,118,119,116,117,124,125,128,129,130,131,134,135
   ;                                               
  db 140,141,146,147,160,161,158,159,164,165,174,175,188,189,180,181
   ;                                               
  db 100,101,102,103,170,171,108,109,114,115,166,167,106,107,021,022
   ;                                               
  db 240,240,240,240,240,168,169,126,127,240,240,240,240,132,133,240
   ;                                               
  db 240,240,240,240,240,240,136,137,240,240,240,240,240,240,240,025
   ;                                               
  db 138,139,142,143,144,145,148,149,150,240,240,240,240,151,190,240
   ;                                               
  db 191,152,153,154,155,156,157,162,163,120,121,104,105,184,185,029
   ;                                               
  db 004,182,183,122,123,176,177,186,187,178,179,172,173,023,240,255


;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 855
;
; ---------------------------------------------------------------
;
Cyrillic_855_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls850.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 850
;
; -----------------------------------------
;
Latin1_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,065,067,069,069,069,073,073,073,065,065
   ;                                               
  db 069,065,065,079,079,079,085,085,089,079,085,079,036,079,158,036
   ;                                               
  db 065,073,079,085,078,078,166,167,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,036
   ;                                               
  db 068,068,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,083,079,079,079,079,230,232,232,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Latin2_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,067,068,069,071,073,074,075,076,078,079,080,081,082,083
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 085,086,087,088,089,090,092,093,094,095,097,040,047,041,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,067,068,069,071,073,074,075,076,078,079,080,081,082,083
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 085,086,087,088,089,090,092,093,094,095,097,040,047,041,126,127
   ;                                               
  db 068,091,072,066,066,066,066,068,072,072,072,077,077,077,066,066
   ;                                               
  db 072,099,099,084,100,084,091,091,096,100,091,084,036,084,158,036
   ;                                               
  db 066,077,084,091,082,082,065,084,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,066,066,066,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,066,066,200,201,202,203,204,205,206,036
   ;                                               
  db 070,070,072,072,072,076,077,077,077,217,218,219,220,221,077,223
   ;                                               
  db 084,067,084,084,084,084,230,098,098,091,091,091,096,096,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


;
;Latin2_850_collate label word
; ctable  <,'COLLATE',256>
;  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
;  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
;   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
;  db 001,008,025,039,035,040,038,024,026,027,036,041,005,004,011,010
;   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
;  db 049,050,051,052,053,054,055,056,057,058,007,006,044,045,046,009
;   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
;  db 033,060,072,074,082,088,098,100,102,104,110,112,114,122,124,130
;   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
;  db 140,142,144,150,159,165,175,177,179,181,185,028,037,029,015,002
;   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
;  db 013,059,071,073,081,087,097,099,101,103,109,111,113,121,123,129
;   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
;  db 139,141,143,149,158,164,174,176,178,180,184,030,047,031,020,198
;   ;                                               
;  db 080,170,089,065,067,201,201,079,202,093,202,203,107,203,068,201
;   ;                                               
;  db 090,201,201,133,135,205,207,207,208,136,171,205,035,205,199,199
;   ;                                               
;  db 061,105,131,166,204,204,201,205,199,199,199,200,200,199,030,031
;   ;                                               
;  db 240,240,240,240,240,062,066,201,199,240,240,240,240,035,035,240
;   ;                                               
;  db 240,240,240,240,240,240,201,201,240,240,240,240,240,240,240,034
;   ;                                               
;  db 085,086,202,094,202,203,106,108,203,240,240,240,240,047,203,240
;   ;                                               
;  db 132,157,134,205,205,205,199,206,206,166,207,207,182,183,199,012
;   ;                                            
;  db 004,199,199,200,199,032,042,022,017,018,199,200,200,200,240,255
;

Dutch_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,143,067,069,069,069,073,073,073,065,143
   ;                                               
  db 069,146,146,079,079,079,085,085,152,079,085,079,156,079,158,159
   ;                                               
  db 065,073,079,085,165,165,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,207
   ;                                               
  db 209,209,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,225,079,079,079,079,230,232,232,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Danish_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,126,127
   ;                                               
  db 067,089,069,065,091,065,093,067,069,069,069,073,073,073,091,093
   ;                                               
  db 069,091,091,079,092,079,085,085,089,092,089,092,036,092,158,036
   ;                                               
  db 065,073,079,085,078,078,065,079,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,036
   ;                                               
  db 068,068,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,083,079,079,079,079,230,080,080,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Norwegian_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,091,065,093,067,069,069,069,073,073,073,091,093
   ;                                               
  db 069,091,091,079,092,079,085,085,089,092,089,092,036,092,158,036
   ;                                               
  db 065,073,079,085,078,078,065,079,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,036
   ;                                               
  db 068,068,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,083,079,079,079,079,230,080,080,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Finnish_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,089,069,065,092,065,091,067,069,069,069,073,073,073,092,091
   ;                                               
  db 069,092,092,079,093,079,085,085,089,093,089,093,036,093,158,036
   ;                                               
  db 065,073,079,085,078,078,166,167,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,036
   ;                                               
  db 068,068,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,083,079,079,079,079,230,232,232,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Swedish_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,089,069,065,092,065,091,067,069,069,069,073,073,073,092,091
   ;                                               
  db 069,092,092,079,093,079,085,085,089,093,089,093,036,093,158,036
   ;                                               
  db 065,073,079,085,078,078,166,167,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,036
   ;                                               
  db 068,068,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,083,079,079,093,093,230,232,232,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Swiss_850_collate label word
 ctable  <,'COLLATE',256>
  db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 000,165,168,133,185,134,135,169,170,171,136,158,172,174,175,176
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 117,118,120,122,124,125,126,127,128,129,177,178,160,161,162,179
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 137,002,018,020,024,028,038,040,042,044,055,057,059,061,063,067
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 081,083,085,087,090,094,104,106,108,110,115,138,139,140,191,173
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 190,003,019,021,025,029,039,041,043,056,045,058,060,062,064,068
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 082,084,086,088,091,095,105,107,109,111,116,142,143,144,193,157
   ;                                               
  db 022,103,031,009,011,007,015,023,035,037,033,053,051,049,010,014
   ;                                               
  db 030,017,016,074,076,072,101,099,114,075,102,080,184,079,164,188
   ;                                               
  db 005,047,070,097,066,065,149,148,180,154,156,131,130,166,181,182
   ;                                               
  db 207,208,209,206,204,004,008,006,153,210,211,212,213,186,187,198
   ;                                               
  db 197,202,201,203,205,200,013,012,214,215,216,217,218,219,220,183
   ;                                               
  db 027,026,034,036,032,054,046,050,052,199,196,223,221,155,048,222
   ;                                               
  db 069,089,073,071,078,077,146,092,093,096,100,098,113,112,145,189
   ;                                            
  db 167,159,141,132,151,150,163,194,147,192,195,119,123,121,152,001


Belgian_850_collate label word
 ctable  <,'COLLATE',256>
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 255,033,034,035,036,037,038,255,040,041,042,043,044,255,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,065,067,069,069,069,073,073,073,065,065
   ;                                               
  db 069,065,065,079,079,079,085,085,089,079,085,079,156,079,158,159
   ;                                               
  db 065,073,079,085,078,164,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 255,255,255,255,255,065,065,065,184,255,255,255,255,189,190,255
   ;                                               
  db 255,255,255,255,255,255,065,065,255,255,255,255,255,255,255,207
   ;                                               
  db 068,068,069,069,069,073,073,073,073,255,255,255,255,221,073,255
   ;                                               
  db 079,083,079,079,079,079,230,084,084,085,085,085,089,089,238,239
   ;                                            
  db 255,241,242,243,244,245,246,247,248,249,250,251,252,253,255,255


Spanish_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164
  db 165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 000,060,061,062,063,064,065,000,066,067,068,069,070,000,071,072
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 034,035,036,037,038,039,040,041,042,043,073,074,075,076,077,078
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 079,001,002,003,006,008,009,010,011,012,013,014,015,017,018,020
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 021,022,023,024,026,028,029,030,031,032,033,080,081,082,083,084
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 085,001,002,003,006,008,009,010,011,012,013,014,015,017,018,020
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 021,022,023,024,026,028,029,030,031,032,033,086,087,088,089,090
   ;                                               
  db 004,028,008,001,001,001,001,004,008,008,008,012,012,012,001,001
   ;                                               
  db 008,001,001,020,020,020,028,028,032,020,028,020,092,020,094,095
   ;                                               
  db 001,012,020,028,019,019,001,020,096,097,098,099,100,101,102,103
   ;                                               
  db 104,105,106,107,108,001,001,001,184,109,110,001,001,091,093,113
   ;                                               
  db 114,115,116,117,118,119,187,188,120,121,122,123,124,125,126,189
   ;                                               
  db 007,007,008,008,008,012,012,012,012,127,128,129,130,199,012,131
   ;                                               
  db 020,025,020,020,020,020,132,027,027,028,028,028,032,032,213,214
   ;                                            
  db 000,133,216,217,218,219,134,220,221,222,000,223,224,135,136,225


;
;Spanish_850_collate label word
; ctable  <,'COLLATE',256>
;  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
;  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
;   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
;  db 001,009,023,045,039,046,044,022,026,027,042,047,006,005,014,013
;   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
;  db 060,064,066,068,070,071,072,073,074,075,008,007,051,052,053,011
;   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
;  db 036,077,094,096,104,108,118,120,122,124,134,136,138,144,146,150
;   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
;  db 165,167,169,171,174,178,188,190,192,194,199,028,043,029,017,002
;   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
;  db 016,076,093,095,103,107,117,119,121,123,133,135,137,143,145,149
;   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
;  db 164,166,168,170,173,177,187,189,191,193,198,030,055,031,019,200
;   ;                                               
;  db 098,185,109,083,087,081,085,097,113,115,111,131,129,127,088,086
;   ;                                               
;  db 110,091,092,156,158,154,183,181,197,159,186,162,040,163,050,200
;   ;                                               
;  db 079,125,152,179,147,148,078,151,012,035,054,062,061,010,024,025
;   ;                                               
;  db 254,254,254,254,254,080,084,082,034,254,254,254,254,038,041,254
;   ;                                               
;  db 254,254,254,254,254,254,089,090,254,254,254,254,254,254,254,037
;   ;                                               
;  db 105,106,114,116,112,200,126,130,132,254,254,254,254,056,128,254
;   ;                                               
;  db 153,172,157,155,160,161,058,175,176,180,184,182,195,196,003,015
;   ;                                            
;  db 005,048,201,063,033,032,049,021,057,018,020,065,069,067,254,255
;

Turkish_850_collate label word
 ctable  <,'COLLATE',256>
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 000,009,023,045,039,046,044,022,026,027,042,047,006,005,014,013
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 060,064,066,068,070,071,072,073,074,075,008,007,051,052,053,011
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 036,077,094,096,100,102,112,114,118,120,132,134,136,138,140,144
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 159,161,163,165,170,172,182,184,186,188,191,028,043,029,017,002
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 016,076,093,095,099,101,111,113,117,121,131,133,135,137,139,143
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 158,160,162,164,169,171,181,183,185,187,190,030,055,031,019,192
   ;                                               
  db 098,179,103,083,087,081,085,097,107,109,105,129,127,125,088,086
   ;                                               
  db 104,091,092,151,156,148,177,175,189,157,180,154,040,155,050,192
   ;                                               
  db 079,123,146,173,141,142,078,145,012,035,054,062,061,010,024,025
   ;                                               
  db 240,240,240,240,240,080,084,082,034,240,240,240,240,038,040,240
   ;                                               
  db 240,240,240,240,240,240,089,090,240,240,240,240,240,240,240,037
   ;                                               
  db 193,193,108,110,106,119,124,128,130,240,240,240,240,056,125,240
   ;                                               
  db 147,166,151,149,152,153,058,193,193,174,178,176,193,193,003,015
   ;                                            
  db 005,048,193,063,033,032,049,021,057,018,020,065,069,067,240,255


;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for 850
;
; ---------------------------------------------------------------
;
Latin1_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


German_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Spanish_850_ucase label word
Swed_Fin_850_ucase label word
Nordic_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Swiss_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Dutch_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Latin2_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Brazilian_850_ucase label word
 ctable      <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255

Turkish_850_ucase label word
 ctable      <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255

;
;       World Trade Mono Case Filename Character Tables
;
;
; ----------------------------------------------------------------------------
CP850_ucfile label word
 ctable  <,'FUCASE ',128>
		      ;  View this table in CP850
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\dbcs93x.inc ===
; ----------------------------------------------------------------------------
;
;       World Trade DBCS Tables for Code Pages 932, 949, 936, and 938
;
; ----------------------------------------------------------------------------
;

;
;    Japan DBCS lead byte table
;
jp932_dbcs      label   word                          
		ctable  <,'DBCS   ',db932end-db932bgn>
db932bgn        label   word                          
		db      081h,09Fh                     
		db      0E0h,0FCh                     
db932term       db      000h,000h                     
db932end        equ     $
                                                      
;
;    Korea DBCS lead byte table
;
ko949_dbcs      label   word                          
		ctable  <,'DBCS   ',db949end-db949bgn>
db949bgn        label   word                          
		db      081h,0FEh                     
db949term       db      000h,000h                     
db949end        equ     $


ko1361_dbcs      label   word                          
		ctable  <,'DBCS   ',db1361end-db1361bgn>
db1361bgn        label   word                          
		db      084h,0d3h                     
		db      0d8h,0deh                     
		db      0e0h,0f9h                     
db1361ter       db      000h,000h                     
db1361end        equ     $

;
;    PRC DBCS lead byte table
;
pr936_dbcs      label   word                          
		ctable  <,'DBCS   ',db936end-db936bgn>
db936bgn        label   word                          
		db      0A1h,0FEh                     
db936term       db      000h,000h                     
db936end        equ     $

;
;    Taiwan DBCS lead byte table
;
ta938_dbcs      label   word                          
		ctable  <,'DBCS   ',ta938end-ta938bgn>
ta938bgn        label   word                          
		db      081h,0FEh                     
ta938term       db      000h,000h                     
ta938end        equ     $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls437.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 437
;
; -----------------------------------------
;
Latin1_437_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db " ","!",'"',"#","$","%","&","'","(",")","*","+",",","-",".","/"
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db "0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?"
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db "P","Q","R","S","T","U","V","W","X","Y","Z","[","\","]","^","_"
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db "`","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db "P","Q","R","S","T","U","V","W","X","Y","Z","{","|","}","~",127
   ;                                               
  db "C","U","E","A","A","A","A","C","E","E","E","I","I","I","A","A"
   ;                                               
  db "E","A","A","O","O","O","U","U","Y","O","U","$","$","$","$","$"
   ;                                               
  db "A","I","O","U","N","N",166,167,"?",169,170,171,172,"!",'"','"'
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,"S",226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Dutch_437_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 128,154,144,065,142,065,143,128,069,069,069,073,073,073,142,143
   ;                                               
  db 144,146,146,079,079,079,085,085,152,079,085,155,156,157,158,159
   ;                                               
  db 065,073,079,085,165,165,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Spanish_437_collate label word
 ctable  <,'COLLATE',256>
  db 000,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164
  db 165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 000,060,061,062,063,064,065,000,066,067,068,069,070,000,071,072
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 034,035,036,037,038,039,040,041,042,043,073,074,075,076,077,078
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 079,001,002,003,006,008,009,010,011,012,013,014,015,017,018,020
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 021,022,023,024,026,028,029,030,031,032,033,080,081,082,083,084
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 085,001,002,003,006,008,009,010,011,012,013,014,015,017,018,020
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 021,022,023,024,026,028,029,030,031,032,033,086,087,088,089,090
   ;                                               
  db 004,028,008,001,001,001,001,004,008,008,008,012,012,012,001,001
   ;                                               
  db 008,001,001,020,020,020,028,028,032,020,028,091,092,093,094,095
   ;                                               
  db 001,012,020,028,019,019,001,020,096,097,098,099,100,101,102,103
   ;                                               
  db 104,105,106,107,108,181,182,183,184,109,110,111,112,185,186,113
   ;                                               
  db 114,115,116,117,118,119,187,188,120,121,122,123,124,125,126,189
   ;                                               
  db 190,191,192,193,194,195,196,197,198,127,128,129,130,199,200,131
   ;                                               
  db 201,025,202,203,204,205,132,206,207,208,209,210,211,212,213,214
   ;                                               
  db 215,133,216,217,218,219,134,220,221,222,000,223,224,135,136,225

;
;Spanish_437_collate label word
; ctable  <,'COLLATE',256>
;  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255 
;  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255 
;   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
;  db 001,009,023,045,039,046,044,022,026,027,042,047,006,005,014,013 
;   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
;  db 060,064,066,068,070,071,072,073,074,075,008,007,051,052,053,011 
;   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
;  db 036,077,094,096,104,108,118,120,122,124,134,136,138,144,146,150 
;   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
;  db 165,167,169,171,174,178,188,190,192,194,199,028,043,029,017,002 
;   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
;  db 016,076,093,095,103,107,117,119,121,123,133,135,137,143,145,149 
;   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
;  db 164,166,168,170,173,177,187,189,191,193,198,030,055,031,019,200 
;   ;                                               
;  db 098,185,109,083,087,081,085,097,113,115,111,131,129,127,088,086
;   ;                                               
;  db 110,091,092,156,158,154,183,181,197,158,186,038,040,041,039,200
;   ;                                               
;  db 079,125,152,179,147,148,078,151,012,200,054,062,061,010,024,025
;   ;                                               
;  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
;   ;                                               
;  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
;   ;                                               
;  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
;   ;                                               
;  db 201,172,202,203,204,205,058,206,207,208,209,210,211,212,213,214
;   ;                                               
;  db 215,048,216,217,218,219,049,220,057,020,020,223,224,067,240,255
;

Swed_Fin_437_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,089,069,065,092,065,091,067,069,069,069,073,073,073,092,091
   ;                                               
  db 069,092,092,079,093,079,085,085,089,093,089,036,036,036,036,036
   ;                                               
  db 065,073,079,085,078,078,166,167,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Swiss_437_collate label word
 ctable  <,'COLLATE',256>
  db 001,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214
  db 215,216,217,218,140,141,219,220,221,222,223,224,225,226,227,228
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,060,061,062,063,064,065,066,067,068,069,070,071,072,073,074
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 032,033,034,035,036,037,038,039,040,041,075,076,077,078,079,080
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 081,002,003,004,005,007,008,009,010,011,012,013,014,015,016,018
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 019,020,021,022,024,026,027,028,029,030,031,082,083,084,052,085
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 051,002,003,004,005,007,008,009,010,011,012,013,014,015,016,018
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 019,020,021,022,024,026,027,028,029,030,031,086,087,088,054,089
   ;                                               
  db 004,026,007,002,002,002,002,004,007,007,007,011,011,011,002,002
   ;                                               
  db 007,002,002,018,018,018,026,026,030,018,026,111,090,112,150,092
   ;                                               
  db 002,011,018,026,017,017,002,018,093,151,095,096,097,098,099,100
   ;                                               
  db 101,102,103,104,105,152,153,154,155,107,108,109,110,156,157,113
   ;                                               
  db 114,115,116,117,118,119,158,159,120,121,122,123,124,125,126,160
   ;                                               
  db 161,162,163,164,165,166,167,168,169,128,129,130,131,170,171,133
   ;                                               
  db 172,023,173,174,175,176,134,177,178,179,180,181,182,183,184,185
   ;                                               
  db 186,137,187,188,189,190,142,191,143,192,144,193,194,147,148,001


Belgian_437_collate label word
 ctable  <,'COLLATE',256>
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 255,033,034,035,036,037,038,255,040,041,042,043,044,255,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,065,067,069,069,069,073,073,073,065,065
   ;                                               
  db 069,065,065,079,079,079,085,085,089,079,085,155,156,157,158,159
   ;                                               
  db 065,073,079,085,078,078,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
   ;                                               
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
   ;                                               
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,255,255


;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 437
;
; ---------------------------------------------------------------
;
Latin1_437_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","E","A","","A","","","E","E","E","I","I","I","",""
   ;                                               
  db "","","","O","","O","U","U","Y","","","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255


Swed_Fin_437_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","A","","A","","","E","E","E","I","I","I","",""
   ;                                               
  db "","","","O","","O","U","U","Y","","","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255


Swiss_437_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","A","","A","","","E","E","E","I","I","I","",""
   ;                                               
  db "","","","O","","O","U","U","Y","","","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255


Dutch_437_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","U","E","A","A","A","","","E","E","E","I","I","I","A",""
   ;                                               
  db "E","","","O","O","O","U","U","","O","U","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255


;
;       World Trade Mono Case Filename Character Tables
;
;
; ----------------------------------------------------------------------------
CP437_ucfile label word
 ctable  <,'FUCASE ',128>
		      ;  View this table in CP437
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\mkcntry.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
;        include file for create cdi file
;
PTRCNT          EQU     1               ; NUMBER OF POINTERS
CIPTYPE         EQU     1               ; TYPE FOR COUNTRY INFO POINTER
; CNTRYCNT        EQU     18              ; NUMBER OF COUNTRIES SUPPORTED

;
; entry type symbols
;
SETCOUNTRYINFO  EQU     1
SETUCASE        EQU     2
SETLCASE        EQU     3
SETUCASEFILE    EQU     4
SETFILELIST     EQU     5
SETCOLLATE      EQU     6
SETDBCS         EQU     7


CDATAITEMS      EQU     SETDBCS - 1     ; NUMBER OF ENTRIES IN COUNTRY DATA


;
; country id's
;
CID_UK          EQU     044             ; United Kingdom
CID_FR          EQU     033             ; France
CID_GR          EQU     049             ; Germany
CID_SP          EQU     034             ; Spain
CID_IT          EQU     039             ; Italy
CID_SV          EQU     046             ; Sweden
CID_AFE         EQU     061             ; International English
CID_DK          EQU     045             ; Denmark
CID_SW          EQU     041             ; Switzerland
CID_NO          EQU     047             ; Norway
CID_NL          EQU     031             ; Netherlands
CID_BE          EQU     032             ; Belgium
CID_FI          EQU     358             ; Finland
CID_US          EQU     001             ; United States
CID_IS          EQU     972             ; Israel
CID_CA          EQU     002             ; Canadian French
CID_CAE         EQU     004             ; Canadian English
CID_AS          EQU     785             ; Area South (Saudi Arabia)
CID_PO          EQU     351             ; Portugal
CID_LA          EQU     003             ; Latin America
CID_BR          EQU     055             ; Brazil
CID_IC          EQU     354             ; Iceland
CID_TR          EQU     090             ; Turkey
CID_YU          EQU     038             ; YUGOSLAVIA
CID_CS          EQU     420             ; CZECH
CID_GK          EQU     030             ; GREEK  added 9/15/93
CID_HU          EQU     036             ; HUNGARY
CID_PL          EQU     048             ; POLAND
CID_RO          EQU     040             ; ROMANIA
CID_JP          EQU     081             ; Japan         2/17/KK
CID_KO          EQU     082             ; Korea         2/17/KK
CID_PR          EQU     086             ; PRC           2/17/KK
CID_TA          EQU     088             ; Taiwan        2/17/KK
CID_TAI         EQU     886             ; Real Country/Region Code for Taiwan   (EA)
CID_RU          EQU     007             ; Russia  (YST)
CID_AL          EQU     355             ; Albania                        (EA)
CID_AR          EQU     054             ; Argentina                      (EA)
CID_AU          EQU     061             ; Australia                      (EA)
CID_AT          EQU     043             ; Austria                        (EA)
CID_BH          EQU     387             ; Bosnia/Herzegovina             (EA)
CID_BG          EQU     035             ; IBM Country Code for Bulgaria  (EA)
CID_BGI         EQU     359             ; Real Country Code for Bulgaria (EA)
CID_CL          EQU     056             ; Chile                          (EA)
CID_CO          EQU     057             ; Columbia                       (EA)
CID_CRO         EQU     384             ; Croatia                        (EA)
CID_EC          EQU     593             ; Ecuador                        (EA)
CID_MAC         EQU     389             ; FYRO Macedonia                 (EA)
CID_IE          EQU     353             ; Ireland                        (EA)
CID_MX          EQU     052             ; Mexico                         (EA)
CID_NZ          EQU     064             ; New Zealand                    (EA)
CID_SM          EQU     381             ; Serbia/Montenegro              (EA)
CID_SLN         EQU     386             ; Slovenia                       (EA)
CID_ZA          EQU     027             ; South Africa                   (EA)
CID_VE          EQU     058             ; Venezuela                      (EA)
CID_YC          EQU     038             ; Yugoslavia Cyrillic            (EA)
CID_HK          EQU     852             ; Hong Kong SAR                  (EA)
CID_IN          EQU     091             ; Indea                          (EA)
CID_MY          EQU     060             ; Malaysia                       (EA)
CID_SG          EQU     065             ; Singapore                      (EA)
CID_SL          EQU     421             ; SLOVAK (Not Real Country Code,
                                        ;  but need to get a new number
                                        ;  since it now has different
                                        ;  settings than Czech Rep. and
                                        ;  AT&T have not assigned a new
                                        ;  number yet.)                  (EA)
CID_ISO         EQU     711             ; Work around an NLSFUNC.EXE bug
                                        ;  Entry.  USA with ISO 8601 Date
                                        ;  format.                       (EA)
CID_XX          EQU     000             ; Dummy entry


;
; country code pages
;
CP_UK           EQU     850
CP_FR           EQU     850
CP_GR           EQU     850
CP_SP           EQU     850
CP_IT           EQU     850
CP_SV           EQU     850
CP_AFE          EQU     437
CP_DA           EQU     865
CP_SW           EQU     850
CP_NO           EQU     865
CP_NL           EQU     850
CP_BE           EQU     850
CP_FI           EQU     850
CP_US           EQU     437
CP_IS           EQU     862
CP_CA           EQU     863
CP_CAE          EQU     863
CP_AS           EQU     864
CP_PO           EQU     860
CP_BR           EQU     850
CP_IC           EQU     850
CP_TR           EQU     857
CP_GK           EQU     869             ; GREEK
CP_YU           EQU     852             ; YUGOSLAVIA
CP_CS           EQU     852             ; CZECH
CP_SL           EQU     852             ; SLOVAK (CZECH)
CP_HU           EQU     852             ; HUNGARY
CP_PL           EQU     852             ; POLAND
CP_RO           EQU     852             ; ROMANIA
CP_JP           EQU     932             ; Japan  2/17/KK
CP_KO           EQU     949             ; Korea         2/17/KK
CP_PR           EQU     936             ; PRC           2/17/KK
CP_TA           EQU     938             ; Taiwan        2/17/KK
CP_TAI          EQU     938
CP_RU           EQU     866             ; Russia  1/22/91 (YST)
CP_AL           EQU     852             ; Albania                        (EA)
CP_AR           EQU     850             ; Argentina                      (EA)
CP_AU           EQU     437             ; Australia                      (EA)
CP_AT           EQU     850             ; Austria                        (EA)
CP_BH           EQU     852             ; Bosnia/Herzegovina             (EA)
CP_BG           EQU     855             ; IBM Country Code for Bulgaria  (EA)
CP_BGI          EQU     855             ; Real Country Code for Bulgaria (EA)
CP_CL           EQU     850             ; Chile                          (EA)
CP_CO           EQU     850             ; Columbia                       (EA)
CP_CRO          EQU     852             ; Croatia                        (EA)
CP_EC           EQU     850             ; Ecuador                        (EA)
CP_MAC          EQU     855             ; FYRO Macedonia                 (EA)
CP_IE           EQU     850             ; Ireland                        (EA)
CP_MX           EQU     850             ; Mexico                         (EA)
CP_NZ           EQU     437             ; New Zealand                    (EA)
CP_SM           EQU     855             ; Serbia/Montenegro              (EA)
CP_SLN          EQU     852             ; Slovenia                       (EA)
CP_ZA           EQU     437             ; South Africa                   (EA)
CP_VE           EQU     850             ; Venezuela                      (EA)
CP_HK           EQU     437             ; Hong Kong SAR                  (EA)
CP_IN           EQU     437             ; Indea                          (EA)
CP_MY           EQU     437             ; Malaysia                       (EA)
CP_SG           EQU     437             ; Singapore                      (EA)
CP_ISO          EQU     437             ; Work around an NLSFUNC.EXE bug
                                        ;  Entry.  USA with ISO 8601 Date
                                        ;  format.                       (EA)


;
; date formats
;
MDY             EQU     0
DMY             EQU     1
YMD             EQU     2

;
; time formats
;
HR12            EQU     0               ; 12 HOUR TIME FORMAT
HR24            EQU     1               ; 24 HOUR TIME FORMAT

;
; CURRENCY FORMAT FLAGS
;
CurrAmount      EQU     0               ;  $100
AmountCurr      EQU     1               ;   100$ 
Cur_Amount      EQU     2               ; $ 100
Amount_Cur      EQU     3               ;   100 $

;
; STRUC definitions
;
CTRYSTR STRUC
ESIZE   DW      0                       ; SIZE OF ENTRY
CNTRYID DW      0                       ; COUNTRY ID
CODPAGE DW      0                       ; CODE PAGE ID
RESV1   DW      0                       ; RESERVED
RESV2   DW      0                       ; RESERVED
CDPOINT DW      0                       ; POINTER TO COUNTRY DATA
        DW      0
CTRYSTR ENDS


CENTRYSIZE      EQU  (TYPE CTRYSTR) - 2 ; SIZE OF COUNTRY ENTRY


CTRYENT MACRO PARMS
         CTRYSTR <PARMS>
         CNTRYCNT = CNTRYCNT + 1
ENDM


CTRYDAT STRUC
        DW      0
        DB      0
        DB      0
        DW      0
        DW      0
CTRYDAT ENDS


CDATASIZE       EQU  (TYPE CTRYDAT) - 2 ; SIZE OF COUNTRY DATA


CINFO   STRUC                           ; OFFSET   FIELD
        DW      0                       ;    0     COUNTRY ID
        DW      0                       ;    2     CODE PAGE
        DW      0                       ;    4     DATE FORMAT
        DB      0                       ;    5     CURRENCY SYMBOL (5 BYTES)
        DB      0
        DB      0
        DB      0
        DB      0
        DB      0                       ;   10     1000 SEPARATOR
        DB      0
        DB      0                       ;   12     DECIMAL SEPARATOR
        DB      0
        DB      0                       ;   14     DATE SEPARATOR
        DB      0
        DB      0                       ;   16     TIME SEPARATOR
        DB      0
        DB      0                       ;   18     CURRENCY FORMAT FLAGS
        DB      0                       ;   19     DIGITS IN CURRENCY
        DB      0                       ;   20     TIME FORMAT
        DD      0                       ;   21     RESERVED
        DB      0                       ;   25     DATA LIST SEPARATOR
        DB      0
        DW      5 DUP (0)               ;   27     RESERVED
CINFO   ENDS


CINFOSIZE       EQU     TYPE CINFO      ; SIZE OF COUNTRY INFO TABLE


CTABLE  STRUC
        DB      0FFh
        DB      'CTYINFO'
        DW      CINFOSIZE
CTABLE  ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls862.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 862
;
; -----------------------------------------
;
Hebrew_862_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143
   ;                                               
  db 144,145,146,147,148,149,150,151,152,153,154,036,036,036,036,036
   ;                                               
  db 065,073,079,085,078,078,166,167,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


;
; ---------------------------------------------------------------
;
;      World Trade Case Mappings for Code Page 862
;
; ---------------------------------------------------------------
;
Hebrew_862_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls857.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 857
;
; -----------------------------------------
;
Turkish_857_collate label word
 ctable  <,'COLLATE',256>
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 000,009,023,045,039,046,044,022,026,027,042,047,006,005,014,013
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 060,064,066,068,070,071,072,073,074,075,008,007,051,052,053,011
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 036,077,094,096,100,102,112,114,118,120,132,134,136,138,140,144
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 159,161,163,165,170,172,182,184,186,188,191,028,043,029,017,002
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 016,076,093,095,099,101,111,113,117,121,131,133,135,137,139,143
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 158,160,162,164,169,171,181,183,185,187,190,030,055,031,019,192
   ;                                               
  db 098,179,103,083,087,081,085,097,107,109,105,129,127,119,088,086
   ;                                               
  db 104,091,092,150,156,148,177,175,122,157,180,154,040,155,168,167
   ;                                               
  db 079,123,146,173,141,142,116,115,012,035,054,062,061,010,024,025
   ;                                               
  db 240,240,240,240,240,080,084,082,034,240,240,240,240,038,041,240
   ;                                               
  db 240,240,240,240,240,240,089,090,240,240,240,240,240,240,240,037
   ;                                               
  db 145,078,108,110,106,001,124,128,130,240,240,240,240,056,126,240
   ;                                               
  db 147,166,151,149,152,153,058,001,050,174,178,176,125,189,003,015
   ;                                               
  db 005,048,001,063,033,032,049,021,057,018,020,065,069,067,240,255


;
; ---------------------------------------------------------------
;
;       World Trade Case Mappings
;
; ---------------------------------------------------------------
;
Turkish_857_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","I","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","",""," ","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls860.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 860
;
; -----------------------------------------
;
Portuguese_860_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,065,067,069,069,069,073,079,073,065,065
   ;                                               
  db 069,065,069,079,079,079,085,085,073,079,085,036,036,085,036,079
   ;                                               
  db 065,073,079,085,078,078,166,167,063,079,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 860
;
; ---------------------------------------------------------------
;
Portuguese_860_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls861.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 861
;
; -----------------------------------------
;
Icelandic_861_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,126,127
   ;                                               
  db 067,089,'E',065,091,065,093,067,069,069,069,'D','D','[',091,093
   ;                                               
  db 'E','\','\',079,']','[',085,'Y','Y',']',089,092,036,092,036,036
   ;                                               
  db 'A','I','O','U','A','I','O','U',063,169,170,171,172,033,034,036
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 861
;
; ---------------------------------------------------------------
;
Icelandic_861_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","A","","A","","","E","E","E","","","","",""
   ;                                               
  db "","","","O","","","U","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls864.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 864
;
; -----------------------------------------
;
Arabic_864_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143
   ;                                               
  db 144,145,146,147,148,149,150,151,152,233,234,251,255,235,236,179
   ;                                               
  db 153,154,182,155,156,184,253,254,188,189,192,194,163,196,198,200
   ;                                               
  db 164,165,166,167,168,169,170,171,172,173,224,174,206,208,210,175
   ;                                               
  db 157,180,181,183,185,217,186,187,190,191,193,195,197,199,201,202
   ;                                               
  db 203,204,205,207,209,211,213,214,215,218,222,158,159,160,161,216
   ;                                               
  db 178,225,227,229,237,239,241,243,245,246,250,212,219,221,220,238
   ;                                               
  db 177,176,240,242,244,247,249,223,226,231,232,230,228,248,162,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls863.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 863
;
; -----------------------------------------
;
FrnCdn_863_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,134,067,069,069,069,073,073,141,065,143
   ;                                               
  db 069,069,069,079,069,073,085,085,152,079,085,155,156,085,085,159
   ;                                               
  db 160,161,079,085,164,165,166,167,073,169,170,171,172,173,174,175
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 863
;
; ---------------------------------------------------------------
;
FrnCdn_863_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "C","U","E","A","A","A","","C","E","E","E","I","I","","A",""
   ;                                               
  db "E","E","E","O","E","I","U","U","","O","U","","","U","U",""
   ;                                               
  db "","","O","U","","","","","I","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls865.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 865
;
; -----------------------------------------
;
Danish_865_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,126,127
   ;                                               
  db 067,089,069,065,091,065,093,067,069,069,069,073,073,073,091,093
   ;                                               
  db 069,091,091,079,092,079,085,085,089,092,089,092,036,092,036,036
   ;                                               
  db 065,073,079,085,078,078,065,079,063,169,170,171,172,033,034,036
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Norwegian_865_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,089,069,065,091,065,093,067,069,069,069,073,073,073,091,093
   ;                                               
  db 069,091,091,079,092,079,085,085,089,092,089,092,036,092,036,036
   ;                                               
  db 065,073,079,085,078,078,065,079,063,169,170,171,172,033,034,036
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 865
;
; ---------------------------------------------------------------
;
Nordic_865_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","A","","A","","","E","E","E","I","I","I","",""
   ;                                               
  db "","","","O","","O","U","U","Y","","","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls866.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 866
;
; -----------------------------------------
;
Russian_866_collate label word
 ctable  <,'COLLATE',256>
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,008,016,030,025,031,028,015,017,018,026,032,005,004,011,010
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 038,039,040,041,042,043,044,045,046,047,007,006,033,034,035,009
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 024,049,051,053,055,057,059,061,063,065,067,069,071,073,075,077
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 079,081,083,085,087,089,091,093,095,097,099,019,027,020,013,002
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 012,048,050,052,054,056,058,060,062,064,066,068,070,072,074,076
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 078,080,082,084,086,088,090,092,094,096,098,021,036,022,014,172
   ;                                               
  db 101,103,105,107,109,111,115,117,119,121,123,125,127,129,131,133
   ;                                               
  db 135,137,139,141,143,145,147,149,151,153,155,157,159,161,163,165
   ;                                               
  db 100,102,104,106,108,110,114,116,118,120,122,124,126,128,130,132
   ;                                               
  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
   ;                                               
  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
   ;                                               
  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
   ;                                               
  db 134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164
   ;                                               
  db 113,112,167,166,169,168,171,170,037,037,037,173,029,025,240,255


;
; ---------------------------------------------------------------
;
;      World Trade Case Mappings for Code Page 866
;
; ---------------------------------------------------------------
;
Russian_866_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255


ru866_lcase        label   word
		ctable <,'LCASE ',256>
		db        0,  1,  2,  3,  4,  5,  6,  7
		db        8,  9, 10, 11, 12, 13, 14, 15
		db       16, 17, 18, 19, 20, 21, 22, 23
		db       24, 25, 26, 27, 28, 29, 30, 31
		db      " ","!",'"',"#","$","%","&","'"
		db      "(",")","*","+",",","-",".","/"
		db      "0","1","2","3","4","5","6","7"
		db      "8","9",":",";","<","=",">","?"
		db      "@","a","b","c","d","e","f","g"
		db      "h","i","j","k","l","m","n","o"
		db      "p","q","r","s","t","u","v","w"
		db      "x","y","z","[","\","]","^","_"
		db      "`","a","b","c","d","e","f","g"
		db      "h","i","j","k","l","m","n","o"
		db      "p","q","r","s","t","u","v","w"
		db      "x","y","z","{","|","}","~",127
		db      "","","","","","","",""   ; 80..87
		db      "","","","","","","",""   ; 88..8f
		db      "","","","","","","",""   ; 90..97
		db      "","","","","","","",""   ; 98..9f
		db      "","","","","","","",""   ; a0..a7
		db      "","","","","","",'',''   ; a8..af
		db      176,177,178,179,180,"","",""   ; b0..b7
		db      "",185,186,187,188,"","",191   ; b8..bf
		db      192,193,194,195,196,197,"",""   ; c0..c7
		db      200,201,202,203,204,205,206,""   ; c8..cf
		db      "","","","","","","",""   ; d0..d7
		db      "",217,218,219,220,"","",223   ; d8..df
		db      "","","","","","","",""   ; e0..e7
		db      "","","","","","","",""   ; e8..ef
		db      "","","","","","","",""   ; f0..f7
		db      "","","","","","",254,255   ; f8..ff
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\disp_win\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\disp_win\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\disp_win\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\font_win\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\font_win\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls93x.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 932
;
; -----------------------------------------
;
Japan_932_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db " ","!",'"',"#","$","%","&","'","(",")","*","+",",","-",".","/"
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db "0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?"
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db "P","Q","R","S","T","U","V","W","X","Y","Z","[","\","]","^","_"
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db "`","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db "P","Q","R","S","T","U","V","W","X","Y","Z","{","|","}","~",127
   ;                                               
  db 128,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 129,130,131,132,133,189,134,135,136,137,138,139,140,141,142,143
   ;                                               
  db 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159
   ;                                               
  db 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,190,191,192
   ;                                               
  db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 949
;
; -----------------------------------------
;
Korea_949_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db " ","!",'"',"#","$","%","&","'","(",")","*","+",",","-",".","/"
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db "0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?"
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db "P","Q","R","S","T","U","V","W","X","Y","Z","[","\","]","^","_"
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db "`","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db "P","Q","R","S","T","U","V","W","X","Y","Z","{","|","}","~",127
   ;                                               
  db 128,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204
   ;                                               
  db 205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220
   ;                                               
  db 221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236
   ;                                               
  db 237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252
   ;                                               
  db 129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144
   ;                                               
  db 145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160
   ;                                               
  db 161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176
   ;                                               
  db 177,178,179,180,181,182,183,184,185,186,187,188,189,253,254,255


;
; -----------------------------------------------
;
;     Collating Table(s) for Code Pages 936 & 938
;
; -----------------------------------------------
;
PRC_936_collate    label word
Taiwan_938_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db " ","!",'"',"#","$","%","&","'","(",")","*","+",",","-",".","/"
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db "0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?"
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db "P","Q","R","S","T","U","V","W","X","Y","Z","[","\","]","^","_"
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db "`","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db "P","Q","R","S","T","U","V","W","X","Y","Z","{","|","}","~",127
   ;                                               
  db 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143
   ;                                               
  db 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159
   ;                                               
  db 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


;
; --------------------------------------------------------------------
;
;     World Trade Case Mappings for Code Pages 932, 949, 936, and 938
;
; --------------------------------------------------------------------
;
DBCS_93x_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\font_win\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\dev\country\nls869.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 869
;
; -----------------------------------------
;
Greek_869_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,015,044,084,072,085,082,043,050,052,079,089,010,009,022,021
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 112,114,115,117,119,120,121,123,124,125,014,012,097,100,103,018
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 069,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 226,228,230,232,234,236,238,240,242,244,246,054,081,055,027,003
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 042,197,199,201,203,205,207,209,211,213,215,217,219,221,223,225
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 227,229,231,233,235,237,239,241,243,245,247,056,105,057,033,063
   ;                                               
  db 111,111,111,111,111,111,128,111,036,104,106,042,043,139,009,145
   ;                                               
  db 151,153,168,111,111,181,183,066,194,117,119,130,076,140,146,152
   ;                                               
  db 154,155,169,182,126,131,133,135,137,141,143,114,147,149,048,049
   ;                                               
  db 110,110,110,110,110,156,158,160,162,110,110,110,110,164,166,110
   ;                                               
  db 110,110,110,110,110,110,170,172,110,110,110,110,110,110,100,174
   ;                                               
  db 177,179,186,188,190,190,127,132,134,110,110,110,110,136,138,110
   ;         